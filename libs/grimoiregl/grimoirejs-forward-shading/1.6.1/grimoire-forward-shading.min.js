!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(this,function(){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=16)}([function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(14),u=o(l),c=n(22),f=o(c),d=n(25),h=o(d),p=n(5),_=o(p),g=n(3),m=o(g),v=n(24),b=o(v),y=n(1),C=o(y),w=function(e){function t(){i(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments));return e.lights={point:[],directional:[],spot:[]},e.shadowMapCameras=[],e}return a(t,e),s(t,[{key:"$awake",value:function(){var e=this;this.getAttributeRaw("shadowQuality").watch(function(t){e._singleShadowMapSize=Math.pow(2,t)},!0)}},{key:"$mount",value:function(){this._gl=this.companion.get("gl"),this._shadowMapTexture=new h.default(this._gl),this._lightMatricesTexture=new h.default(this._gl),this._lightMatricesTexture.magFilter=WebGLRenderingContext.NEAREST,this._lightMatricesTexture.minFilter=WebGLRenderingContext.NEAREST,this._shadowMapRenderbuffer=new b.default(this._gl),this._maxTextureSize=this._gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_SIZE),this._shadingManager=this.node.getComponentInAncestor(m.default);var e=this.node.getComponent(_.default);this._lightSceneDesc=e.sceneDescription.lights,this._shadingManager.addSceneLightManager(this),this._updateShadowMapSize(),this.shadowMapFBO=new f.default(this._gl),this.shadowMapFBO.update(this._shadowMapTexture),this.shadowMapFBO.update(this._shadowMapRenderbuffer)}},{key:"$unmount",value:function(){this._shadingManager.removeSceneLightManager(this),this.shadowMapFBO.destroy(),this._shadowMapTexture.destroy()}},{key:"addLight",value:function(e){switch(e.lightType){case"point":this.lights.point.push(e),this._lightSceneDesc.point.colors.incrementLength(),this._lightSceneDesc.point.positions.incrementLength(),this._lightSceneDesc.point.params.incrementLength();break;case"directional":this.lights.directional.push(e),this._lightSceneDesc.directional.colors.incrementLength(),this._lightSceneDesc.directional.directions.incrementLength(),this._lightSceneDesc.directional.params.incrementLength();break;case"spot":this.lights.spot.push(e),this._lightSceneDesc.spot.colors.incrementLength(),this._lightSceneDesc.spot.directions.incrementLength(),this._lightSceneDesc.spot.positions.incrementLength(),this._lightSceneDesc.spot.params.incrementLength()}this._shadingManager.updateLightCount()}},{key:"removeLight",value:function(e){switch(e.lightType){case"point":var t=this.lights.point.indexOf(e);this.lights.point.splice(t,1),this._lightSceneDesc.point.colors.decrementLength(),this._lightSceneDesc.point.positions.decrementLength(),this._lightSceneDesc.point.params.decrementLength();break;case"directional":var n=this.lights.directional.indexOf(e);this.lights.directional.splice(n,1),this._lightSceneDesc.directional.colors.decrementLength(),this._lightSceneDesc.directional.directions.decrementLength(),this._lightSceneDesc.directional.params.decrementLength();break;case"spot":var o=this.lights.spot.indexOf(e);this.lights.spot.splice(o,1),this._lightSceneDesc.spot.colors.decrementLength(),this._lightSceneDesc.spot.directions.decrementLength(),this._lightSceneDesc.spot.positions.decrementLength(),this._lightSceneDesc.spot.params.decrementLength()}this._shadingManager.updateLightCount()}},{key:"addShadowMapCamera",value:function(e){this.shadowMapCameras.push(e),e.shadowMapIndex=this.shadowMapCameras.length-1,this._updateShadowMapSize()}},{key:"removeShadowMapCamera",value:function(e){var t=this.shadowMapCameras.indexOf(e);this.shadowMapCameras.splice(t,1);for(var n=0;n<this.shadowMapCameras.length;n++)this.shadowMapCameras[n].shadowMapIndex=n;this._updateShadowMapSize()}},{key:"viewportByShadowmapIndex",value:function(e){var t=e%this._shadowMapElementCounts.X,n=(e-t)/this._shadowMapElementCounts.X;this._gl.viewport(t*this._singleShadowMapSize,n*this._singleShadowMapSize,this._singleShadowMapSize,this._singleShadowMapSize)}},{key:"updateLightMatricies",value:function(e){var t=this;this.shadowMapCameras.forEach(function(t){t.updateCamera(e)}),this.shadowMapCameras.forEach(function(e,n){for(var o=e.ProjectionViewMatrix.rawElements,i=0;i<16;i++)t.lightMatrices[16*n+i]=o[i]}),this._updateLightMatricesTexture()}},{key:"_updateShadowMapSize",value:function(){var e=this._maxTextureSize,t=this._singleShadowMapSize,n=this.shadowMapCameras.length,o=0===n?0:Math.pow(2,Math.ceil(Math.log2(Math.ceil(Math.sqrt(n)))))*t;if(o>e)throw new Error("Max shadow map buffer size overflow");0===n?(this._shadowMapTexture.update(0,1,1,0,WebGLRenderingContext.RGB,WebGLRenderingContext.UNSIGNED_BYTE),this._shadowMapRenderbuffer.update(WebGLRenderingContext.DEPTH_COMPONENT16,1,1)):(this._shadowMapTexture.update(0,o,o,0,WebGLRenderingContext.RGB,WebGLRenderingContext.UNSIGNED_BYTE),this._shadowMapRenderbuffer.update(WebGLRenderingContext.DEPTH_COMPONENT16,o,o));var i=Math.pow(2,Math.ceil(Math.log2(n)));this.lightMatrices=new Float32Array(16*i),this._shadowMapElementCounts=new u.default(o/t,o/t),this._updateLightMatricesTexture(),this._lightSceneDesc.shadowMap={shadowMapCountPerEdge:this._shadowMapElementCounts,count:i,shadowMap:this._shadowMapTexture,lightMatrices:this._lightMatricesTexture,pixelSize:1/this._singleShadowMapSize}}},{key:"_updateLightMatricesTexture",value:function(){var e=this.shadowMapCameras.length;this._lightMatricesTexture.update(0,4,Math.pow(2,Math.ceil(Math.log2(e))),0,WebGLRenderingContext.RGBA,WebGLRenderingContext.FLOAT,this.lightMatrices)}}]),t}(C.default);t.default=w,w.attributes={shadowQuality:{converter:"Number",default:9}}},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.Node.Component},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(5),u=o(l),c=n(0),f=o(c),d=n(1),h=o(d),p=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$mount",value:function(){this.__sceneLightManager=this.node.getComponentInAncestor(f.default);var e=this.__sceneLightManager.node.getComponent(u.default).sceneDescription;this.__lightDesc=e.lights,this.__sceneLightManager.addLight(this)}},{key:"$unmount",value:function(){this.__sceneLightManager.removeLight(this)}},{key:"__ensureIndex",value:function(e){var t=e.indicies.indexOf(this.id);return t>=0?t:(e.indicies.push(this.id),e.indicies.length-1)}}]),t}(h.default);t.default=p},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(1),u=o(l),c=n(20),f=o(c),d=n(18),h=o(d),p=n(31),_=o(p),g=n(33),m=o(g),v=function(e){function t(){i(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments));return e._sceneLightManagers=[],e}return a(t,e),s(t,[{key:"$awake",value:function(){this._macroRegistry=this.companion.get("MaterialFactory").macro,this._macroRegistry.setValue("DIR_LIGHT_COUNT","0"),this._macroRegistry.setValue("POINT_LIGHT_COUNT","0"),this._macroRegistry.setValue("SPOT_LIGHT_COUNT","0"),this._macroRegistry.setValue("SHADOW_MAP_COUNT","0"),f.default.addSORTMaterial("basic-shading",_.default),f.default.addSORTMaterial("simple-shading",m.default);var e=this.getAttribute("useHighQualityShading")?"basic-shading":"simple-shading";h.default.rewriteDefaultMaterial(e)}},{key:"addSceneLightManager",value:function(e){this._sceneLightManagers.push(e),this.updateLightCount()}},{key:"removeSceneLightManager",value:function(e){var t=this._sceneLightManagers.indexOf(e);this._sceneLightManagers.splice(t,1),this.updateLightCount()}},{key:"updateLightCount",value:function(){for(var e=0,t=0,n=0,o=0,i=0;i<this._sceneLightManagers.length;i++){var r=this._sceneLightManagers[i];e=Math.max(r.lights.directional.length,e),n=Math.max(r.lights.point.length,n),t=Math.max(r.lights.spot.length,t),o=Math.max(r.shadowMapCameras.length,o)}this._macroRegistry.setValue("DIR_LIGHT_COUNT",e+""),this._macroRegistry.setValue("POINT_LIGHT_COUNT",n+""),this._macroRegistry.setValue("SPOT_LIGHT_COUNT",t+""),this._macroRegistry.setValue("SHADOW_MAP_COUNT",o+"")}}]),t}(u.default);t.default=v,v.attributes={useHighQualityShading:{converter:"Boolean",default:!1}},v._typeToMacros={point:"POINT_LIGHT_COUNT",directional:"DIR_LIGHT_COUNT",spot:"SPOT_LIGHT_COUNT"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,n);if(void 0===i){var r=Object.getPrototypeOf(t);return null===r?void 0:e(r,n,o)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(o)},u=n(28),c=o(u),f=n(29),d=o(f),h=n(0),p=o(h),_=n(17),g=o(_),m=n(27),v=o(m),b=function(e){function t(){i(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments));return e._sceneAABBCache=new v.default,e._vectorCache=new d.default(0,0,0),e}return a(t,e),s(t,[{key:"$awake",value:function(){this.Near=.01,this.Far=50,this.OrthographicMode=!0,this.OrthoSize=30,this.AutoAspect=!1,this.Aspect=1}},{key:"$mount",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"$mount",this).call(this),this.containedScene.node.getComponent(p.default).addShadowMapCamera(this)}},{key:"updateCamera",value:function(e){this._sceneAABBCache.clear();for(var t=c.default.inverse(e.ProjectionViewMatrix),n=0;n<2;n++)for(var o=0;o<2;o++)for(var i=0;i<2;i++)this._vectorCache.rawElements[0]=0==n?-1:1,this._vectorCache.rawElements[1]=0==o?-1:1,this._vectorCache.rawElements[2]=0==i?-1:1,this._sceneAABBCache.expand(c.default.transformPoint(t,this._vectorCache));this._sceneAABBCache.pointLBF.subtractWith(this._sceneAABBCache.Center).magnitude}},{key:"$unmount",value:function(){this.containedScene.node.getComponent(p.default).removeShadowMapCamera(this)}}]),t}(g.default);t.default=b},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.SceneComponent},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(2),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(e){function t(){return o(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),a(t,[{key:"$awake",value:function(){var e=this;this.lightType="directional",this.getAttributeRaw("color").boundTo("_color"),this.getAttributeRaw("intensity").boundTo("_intensity"),this.getAttributeRaw("shadow").watch(function(t){return e._useShadowChanged(t)},!0),this._transform=this.node.getComponent("Transform")}},{key:"$update",value:function(e){var t=e.lights.directional,n=this.__ensureIndex(t),o=this._transform.forward,i=this._transform.globalPosition;t.directions.set(n,o.X,o.Y,o.Z);var r=this._color;t.colors.set(n,r.R*this._intensity,r.G*this._intensity,r.B*this._intensity),t.params.set(n,this._shadowCamera?this._shadowCamera.shadowMapIndex:-1,i.X,i.Y,i.Z)}},{key:"_useShadowChanged",value:function(e){!e&&this._shadowCamera?(this._shadowCamera.dispose(),this._shadowCamera=null):e&&(this._shadowCamera=this.node.addComponent("ShadowMapCamera"))}}]),t}(l.default);t.default=u,u.attributes={color:{converter:"Color3",default:"white"},intensity:{converter:"Number",default:1},shadow:{converter:"Boolean",default:!1}}},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(1),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(e){function t(){return o(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),a(t,[{key:"$awake",value:function(){var e=this;this.getAttributeRaw("type").watch(function(t){return e._onLightTypeChanged(t)},!0)}},{key:"_onLightTypeChanged",value:function(e){(e=e.toLowerCase())!==this._lastLightType&&(this._lastLightType=e,this._removeLastTypeComponent(),this._addLightTypeComponent(e))}},{key:"_addLightTypeComponent",value:function(e){switch(e){case"directional":this._lightTypeComponent=this.node.addComponent("DirectionalLightType",{},!0);break;case"point":this._lightTypeComponent=this.node.addComponent("PointLightType",{},!0);break;case"spot":this._lightTypeComponent=this.node.addComponent("SpotLightType",{},!0)}}},{key:"_removeLastTypeComponent",value:function(){this._lightTypeComponent&&this._lightTypeComponent.dispose()}}]),t}(l.default);t.default=u,u.attributes={type:{converter:"String",default:"Directional"}}},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(2),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(e){function t(){return o(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),a(t,[{key:"$awake",value:function(){this.lightType="point",this.getAttributeRaw("color").boundTo("_color"),this._transform=this.node.getComponent("Transform"),this.getAttributeRaw("distance").boundTo("_distance"),this.getAttributeRaw("decay").boundTo("_decay"),this.getAttributeRaw("intensity").boundTo("_intensity")}},{key:"$update",value:function(e){var t=e.lights.point,n=this.__ensureIndex(t),o=this._transform.globalPosition;t.positions.set(n,o.X,o.Y,o.Z),t.colors.set(n,this._color.R*this._intensity,this._color.G*this._intensity,this._color.B*this._intensity),t.params.set(n,this._distance,this._decay)}}]),t}(l.default);t.default=u,u.attributes={color:{converter:"Color3",default:"white"},distance:{converter:"Number",default:5},decay:{converter:"Number",default:2},intensity:{converter:"Number",default:1}}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(0),u=o(l),c=n(1),f=o(c),d=n(19),h=o(d),p=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$mount",value:function(){if(this._renderSceneComponent=this.node.getComponent(h.default),!this._renderSceneComponent)throw new Error("There was no RenderScene component found on the node attached RenderShadowMapComponent");this._gl=this.companion.get("gl")}},{key:"$render",value:function(e){var t=this,n=e.camera?e.camera:this._renderSceneComponent.camera,o=n.containedScene.node.getComponent(u.default);0!==o.shadowMapCameras.length&&(o.shadowMapFBO.bind(),this._gl.clearColor(0,0,0,0),this._gl.clearDepth(1),this._gl.clear(WebGLRenderingContext.COLOR_BUFFER_BIT|WebGLRenderingContext.DEPTH_BUFFER_BIT),o.updateLightMatricies(n),o.shadowMapCameras.forEach(function(n){o.viewportByShadowmapIndex(n.shadowMapIndex),n.updateContainedScene(e.timer),n.renderScene({camera:n,buffers:null,layer:"default",viewport:e.viewport,technique:"depth",renderer:t._renderSceneComponent,sceneDescription:{},timer:e.timer})}),this._gl.flush(),this._gl.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER,null))}}]),t}(f.default);t.default=p,p.attributes={}},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=function e(t,n,o){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,n);if(void 0===i){var r=Object.getPrototypeOf(t);return null===r?void 0:e(r,n,o)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(o)},l=n(4),u=function(e){return e&&e.__esModule?e:{default:e}}(l),c=function(e){function t(){return o(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),a(t,[{key:"$awake",value:function(){s(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"$awake",this).call(this),this.OrthographicMode=!1}}]),t}(u.default);t.default=c},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(2),l=function(e){return e&&e.__esModule?e:{default:e}}(s),u=function(e){function t(){return o(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),a(t,[{key:"$awake",value:function(){var e=this;this.lightType="spot",this.getAttributeRaw("color").boundTo("_color"),this._transform=this.node.getComponent("Transform"),this.getAttributeRaw("innerCone").boundTo("_innerCone"),this.getAttributeRaw("outerCone").boundTo("_outerCone"),this.getAttributeRaw("decay").boundTo("_decay"),this.getAttributeRaw("intensity").boundTo("_intensity"),this.getAttributeRaw("shadow").watch(function(t){return e._useShadowChanged(t)},!0)}},{key:"$update",value:function(e){var t=e.lights.spot,n=this.__ensureIndex(t),o=this._transform.globalPosition,i=this._transform.up.negateThis();t.positions.set(n,o.X,o.Y,o.Z),t.colors.set(n,this._color.R*this._intensity,this._color.G*this._intensity,this._color.B*this._intensity),t.directions.set(n,i.X,i.Y,i.Z),t.params.set(n,this._innerCone,this._outerCone,this._decay,this._shadowCamera?this._shadowCamera.shadowMapIndex:-1)}},{key:"_useShadowChanged",value:function(e){!e&&this._shadowCamera?(this._shadowCamera.dispose(),this._shadowCamera=null):e&&(this._shadowCamera=this.node.addComponent("SpotLightShadowMapCamera"))}}]),t}(l.default);t.default=u,u.attributes={color:{converter:"Color3",default:"white"},innerCone:{converter:"Angle2D",default:"5d"},outerCone:{converter:"Angle2D",default:"20d"},decay:{converter:"Number",default:1},intensity:{converter:"Number",default:1},shadow:{converter:"Boolean",default:!1}}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(26),s=o(a),l=n(21),u=o(l),c=n(32),f=o(c),d=function(){function e(){i(this,e)}return r(e,null,[{key:"registerAll",value:function(){s.default.staticImports["forward-shading"]=f.default,this._registerLightVariable("DIRECTIONAL_LIGHT_DIRECTIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.directional.directions.elements)}),this._registerLightVariable("DIRECTIONAL_LIGHT_COLORS",function(e,t,n){return t.uniformVector3Array(e,n.lights.directional.colors.elements)}),this._registerLightVariable("DIRECTIONAL_LIGHT_PARAMS",function(e,t,n){return t.uniformVector4Array(e,n.lights.directional.params.elements)}),this._registerLightVariable("POINT_LIGHT_POSITIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.point.positions.elements)}),this._registerLightVariable("POINT_LIGHT_COLORS",function(e,t,n){return t.uniformVector3Array(e,n.lights.point.colors.elements)}),this._registerLightVariable("POINT_LIGHT_PARAMS",function(e,t,n){return t.uniformVector2Array(e,n.lights.point.params.elements)}),this._registerLightVariable("SPOT_LIGHT_POSITIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.spot.positions.elements)}),this._registerLightVariable("SPOT_LIGHT_COLORS",function(e,t,n){return t.uniformVector3Array(e,n.lights.spot.colors.elements)}),this._registerLightVariable("SPOT_LIGHT_DIRECTIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.spot.directions.elements)}),this._registerLightVariable("SPOT_LIGHT_PARAMS",function(e,t,n){return t.uniformVector4Array(e,n.lights.spot.params.elements)}),this._registerLightVariable("SHADOW_MATRICES",function(e,t,n){return t.uniformTexture2D(e,n.lights.shadowMap.lightMatrices)}),this._registerLightVariable("SHADOW_MATRICES_COUNT",function(e,t,n){return t.uniformFloat(e,n.lights.shadowMap.count)}),this._registerLightVariable("SHADOW_MAP_TEXTURE",function(e,t,n){return t.uniformTexture2D(e,n.lights.shadowMap.shadowMap)}),this._registerLightVariable("SHADOW_MAP_ELEMENT_COUNT",function(e,t,n){return t.uniformVector2(e,n.lights.shadowMap.shadowMapCountPerEdge)}),this._registerLightVariable("SHADOW_MAP_PIXEL_SIZE",function(e,t,n){return t.uniformFloat(e,n.lights.shadowMap.pixelSize)})}},{key:"_registerLightVariable",value:function(e,t){u.default.add(e,function(e){return function(n,o){t(e.name,n,o.sceneDescription)}})}}]),e}();t.default=d},function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),r=function(){function e(t,n){o(this,e),this.size=t,this.length=n,this.resize(t,n)}return i(e,[{key:"resize",value:function(e,t){this.elements=new Float32Array(e*t),this.size=e,this.length=t}},{key:"set",value:function(e,t,n,o,i){var r=this.size*e;this.elements[r+0]=t,void 0!==n&&(this.elements[r+1]=n,void 0!==o&&(this.elements[r+2]=o,void 0!==i&&(this.elements[r+3]=i)))}},{key:"incrementLength",value:function(){this.resize(this.size,this.length+1)}},{key:"decrementLength",value:function(){this.resize(this.size,this.length-1)}}]),e}();t.default=r},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.Vector2},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(10),r=o(i),a=n(14),s=o(a),l=n(9),u=o(l),c=n(4),f=o(c),d=n(13),h=o(d),p=n(0),_=o(p),g=n(6),m=o(g),v=n(7),b=o(v),y=n(8),C=o(y),w=n(11),T=o(w),O=n(3),M=o(O),S=n(30),P=o(S),R=n(23),L=o(R),E=n(12),A=o(E),D=n(5),I=o(D),x=function(e,t,n,o){return new(n||(n=Promise))(function(i,r){function a(e){try{l(o.next(e))}catch(e){r(e)}}function s(e){try{l(o.throw(e))}catch(e){r(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(a,s)}l((o=o.apply(e,t||[])).next())})};t.default=function(){P.default.register(function(){return x(void 0,void 0,void 0,regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:I.default.onSceneDescriptionCreation(function(e){e.lights={directional:{indicies:[],directions:new h.default(3,0),colors:new h.default(3,0),params:new h.default(4,0)},point:{indicies:[],positions:new h.default(3,0),colors:new h.default(3,0),params:new h.default(2,0)},spot:{indicies:[],positions:new h.default(3,0),directions:new h.default(3,0),colors:new h.default(3,0),params:new h.default(4,0)},shadowMap:{shadowMapCountPerEdge:new s.default(0,0),shadowMap:null,lightMatrices:null,pixelSize:0,count:0}}}),t=P.default,t.registerComponent("ForwardShadingManager",M.default),t.registerComponent("Light",b.default),t.registerComponent("DirectionalLightType",m.default),t.registerComponent("PointLightType",C.default),t.registerComponent("SpotLightType",T.default),t.registerComponent("SceneLightManager",_.default),t.registerComponent("ShadowMapCamera",f.default),t.registerComponent("RenderShadowMap",u.default),t.registerComponent("SpotLightShadowMapCamera",r.default),t.overrideDeclaration("scene",["SceneLightManager"]),t.overrideDeclaration("render-scene",["RenderShadowMap"]),t.nodeDeclarations.get("goml").defaultComponents.push(t.ns("http://grimoire.gl/ns/default")("ForwardShadingManager")),t.registerNode("light",["Transform","Light"]),A.default.registerAll(),L.default.request("OES_texture_float");case 17:case"end":return e.stop()}},e,this)}))})}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(6),r=o(i),a=n(3),s=o(a),l=n(7),u=o(l),c=n(2),f=o(c),d=n(8),h=o(d),p=n(9),_=o(p),g=n(0),m=o(g),v=n(4),b=o(v),y=n(10),C=o(y),w=n(11),T=o(w),O=n(12),M=o(O),S=n(13),P=o(S),R=n(15),L=o(R),E={Components:{DirectionalLightTypeComponent:r.default,ForwardShadingManagerComponent:s.default,LightComponent:u.default,LightTypeComponentBase:f.default,PointLightTypeComponent:h.default,RenderShadowMapComponent:_.default,SceneLightManager:m.default,ShadowMapCameraComponent:b.default,SpotLightShadowMapCameraComponent:C.default,SpotLightTypeComponent:T.default},Util:{LightVariableRegister:M.default,VectorArrayContainer:P.default}},A=(0,L.default)();Object.assign(E,{__VERSION__:"1.6.1",__NAME__:"grimoirejs-forward-shading"}),Object.assign(A||{},E),window.GrimoireJS.lib.forward_shading=E,t.default=A},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.CameraComponent},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.MaterialContainerComponent},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.RenderSceneComponent},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Material.MaterialFactory},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Material.UniformResolverRegistry},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.FrameBuffer},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.GLExtRequestor},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.RenderBuffer},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.Texture2D},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Sort.ImportResolver},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.AABB},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.Matrix},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.Vector3},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS},function(e,t){e.exports='@Technique default{\n@Pass{\n@BlendFunc(SRC_ALPHA,ONE_MINUS_SRC_ALPHA)\nFS_PREC(mediump,float)\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec4 vPosition;\n\n#ifdef ATTRIBUTE_COLOR_ENABLED\nvarying vec4 vColor;\n#endif\n\n#ifdef VS\n  attribute vec3 position;\n  attribute vec3 normal;\n  #ifdef ATTRIBUTE_TEXCOORD_ENABLED\n  attribute vec2 texCoord;\n  #endif\n  #ifdef ATTRIBUTE_COLOR_ENABLED\n  @COLOR\n  attribute vec4 color;\n  #endif\n\n  uniform mat4 _matPVM;\n  uniform mat4 _matM;\n\n  void main(){\n    gl_Position = _matPVM * vec4(position,1.0);\n    vNormal = normalize((_matM * vec4(normal,0.0)).xyz);\n    vPosition = (_matM * vec4(position,1.0));\n    #ifndef ATTRIBUTE_TEXCOORD_ENABLED\n    vTexCoord = position.xy / 2.0 + vec2(0.5);\n    #endif\n    #ifdef ATTRIBUTE_TEXCOORD_ENABLED\n    vTexCoord = texCoord;\n    #endif\n    #ifdef ATTRIBUTE_COLOR_ENABLED\n    vColor = color;\n    #endif\n  }\n#endif\n\n#ifdef FS\n  @CAMERA_POSITION\n  uniform vec3 _cameraPosition;\n\n  uniform sampler2D texture;\n\n  @HAS_TEXTURE{sampler:"texture"}\n  uniform bool useTexture;\n\n  uniform sampler2D roughnessMap;\n\n  @HAS_TEXTURE{sampler:"roughnessMap"}\n  uniform bool useRoughnessMap;\n\n  @{default:"white",type:"color"}\n  uniform vec4 albedo;\n\n  @{default:1.0}\n  uniform float roughness;\n\n  @{default:0.99}\n  uniform float metalic;\n\n  @{default:"black",type:"color"}\n  uniform vec3 emission;\n\n  @import "forward-shading"\n\n  void main(){\n    vec3 dBaseColor = albedo.rgb;\n    vec4 lastColor = vec4(0,0,0,albedo.a);\n    #ifdef ATTRIBUTE_COLOR_ENABLED\n    dBaseColor *= vColor.rgb;\n    #endif\n    if(useTexture){\n      vec4 texColor = texture2D(texture,vTexCoord);\n      dBaseColor = pow(texColor.rgb,vec3(2.2));\n      lastColor.a *= texColor.a;\n    }\n    float r = roughness;\n    if(useRoughnessMap){\n      r *= texture2D(roughnessMap,vTexCoord).r;\n    }\n    vec3 dielectricSpecular = vec3(0.04);\n    vec3 diffuse = mix(dBaseColor.rgb * (1. - dielectricSpecular.r),vec3(0),metalic);\n    vec3 f0 = mix(dielectricSpecular,dBaseColor.rgb,metalic);\n    BRDF_PARAMS param = BRDF_PARAMS(diffuse,f0,roughness);\n    lastColor.rgb += emission + shading(param,vNormal,vPosition.xyz/vPosition.w);\n    gl_FragColor.rgb = pow(lastColor.rgb,vec3(1.0/2.2)); // Gamma correction\n    gl_FragColor.a = albedo.a;\n    #ifdef ATTRIBUTE_COLOR_ENABLED\n    gl_FragColor.a *= vColor.a;\n    #endif\n  }\n#endif\n}\n}\n\n@Technique hitarea{\n  @Disable(BLEND)\n  @Pass{\n    FS_PREC(mediump,float)\n\n    #ifdef VS\n      attribute vec3 position;\n      uniform mat4 _matPVM;\n\n      void main(){\n        gl_Position = _matPVM * vec4(position,1.0);\n      }\n    #endif\n\n    #ifdef FS\n      @MESH_INDEX\n      uniform vec4 meshIndex;\n      void main(){\n        gl_FragColor = meshIndex;\n      }\n    #endif\n  }\n}\n\n@Technique depth{\n  @Pass{\n    @CullFace(FRONT)\n  FS_PREC(highp,float)\n\n  varying vec4 vPos;\n\n  vec3 EncodeFloatRGB( float v ) {\n    vec3 enc = vec3(1.0, 255.0, 65025.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzz * vec3(1.0/255.0,1.0/255.0,0.0);\n    return enc;\n  }\n\n  float DecodeFloatRGB( vec3 rgb ) {\n    return dot( rgb, vec3(1.0, 1./255.0, 1./65025.0) );\n  }\n\n  #ifdef VS\n    attribute vec3 position;\n    uniform mat4 _matPVM;\n    void main(){\n      gl_Position = vPos= _matPVM * vec4(position,1.0);\n    }\n  #endif\n\n  #ifdef FS\n    void main(){\n      gl_FragColor.rgb = EncodeFloatRGB((vPos.z/vPos.w + 1.0)/2.0);\n      gl_FragColor.a = 1.0;\n    }\n  #endif\n  }\n}\n'},function(e,t){e.exports="#define GR_FORWARD_SHADING_ENABLED\n@ReferMacro(DIR_LIGHT_COUNT,0)\n@ReferMacro(POINT_LIGHT_COUNT,0)\n@ReferMacro(SPOT_LIGHT_COUNT,0)\n@ReferMacro(SHADOW_MAP_COUNT,0)\n@ReferMacro(OES_TEXTURE_FLOAT,)\n\n#if DIR_LIGHT_COUNT > 0\n  #define USE_DIR_LIGHT\n#endif\n\n#if POINT_LIGHT_COUNT > 0\n  #define USE_POINT_LIGHT\n#endif\n\n#if SPOT_LIGHT_COUNT > 0\n  #define USE_SPOT_LIGHT\n#endif\n\n#if SHADOW_MAP_COUNT > 0\n  #define USE_SHADOW_MAP\n#endif\n\n#ifdef USE_DIR_LIGHT\n  @DIRECTIONAL_LIGHT_DIRECTIONS\n  uniform vec3 _dLightDir[DIR_LIGHT_COUNT];\n\n  @DIRECTIONAL_LIGHT_COLORS\n  uniform vec3 _dLightColor[DIR_LIGHT_COUNT];\n\n  @DIRECTIONAL_LIGHT_PARAMS\n  uniform vec4 _dLightParams[DIR_LIGHT_COUNT];\n#endif\n\n#ifdef USE_POINT_LIGHT\n\n  @POINT_LIGHT_POSITIONS\n  uniform vec3 _pLightPosition[POINT_LIGHT_COUNT];\n\n  @POINT_LIGHT_COLORS\n  uniform vec3 _pLightColor[POINT_LIGHT_COUNT];\n\n  @POINT_LIGHT_PARAMS\n  uniform vec2 _pLightParam[POINT_LIGHT_COUNT];\n\n#endif\n\n#ifdef USE_SPOT_LIGHT\n\n  @SPOT_LIGHT_POSITIONS\n  uniform vec3 _sLightPosition[SPOT_LIGHT_COUNT];\n\n  @SPOT_LIGHT_DIRECTIONS\n  uniform vec3 _sLightDir[SPOT_LIGHT_COUNT];\n\n  @SPOT_LIGHT_COLORS\n  uniform vec3 _sLightColor[SPOT_LIGHT_COUNT];\n\n  @SPOT_LIGHT_PARAMS\n  uniform vec4 _sLightParam[SPOT_LIGHT_COUNT];\n#endif\n\n#ifdef USE_SHADOW_MAP\n  @SHADOW_MAP_ELEMENT_COUNT\n  uniform vec2 _shadowMapElementCount;\n\n  @SHADOW_MAP_PIXEL_SIZE\n  uniform float _shadowMapPixelSize;\n\n  @SHADOW_MATRICES\n  uniform sampler2D _lightMatrices;\n\n  @SHADOW_MATRICES_COUNT\n  uniform float _lightMatricesCount;\n\n  @SHADOW_MAP_TEXTURE\n  uniform sampler2D _shadowMapTexture;\n\n  @{default:0.01}\n  uniform float shadowBias;\n\n  highp float decodeFloatRGB( vec3 rgb ) {\n    return dot( rgb, vec3(1.0, 1./255.0, 1./65025.0) );\n  }\n#endif\n\n// Define simple shading params\n\n#ifndef BRDF_PARAMS\n  #ifdef SIMPLE_SHADING\n  #define BRDF_PARAMS simple_params\n  struct simple_params{\n    vec3 diffuse;\n    vec3 specular;\n    float shiningness;\n  };\n  #endif\n#endif\n\n// Define pbr params\n#ifndef BRDF_PARAMS\n\n#define BRDF_PARAMS pbr_params\n\nstruct pbr_params{\n    vec3 albedo;\n    vec3 f0;\n    float roughness;\n};\n#endif\n\n  float lambert(vec3 lightDirection,vec3 surfaceNormal) {\n    return max(0.0, dot(lightDirection, surfaceNormal));\n  }\n\n  #ifndef DIFFUSE_BRDF\n    #define DIFFUSE_BRDF lambertBRDF\n\n    vec3 lambertBRDF(BRDF_PARAMS param,vec3 i,vec3 o,vec3 n){\n      #ifdef SIMPLE_SHADING\n        return param.diffuse / PI;\n      #endif\n      #ifndef SIMPLE_SHADING\n        return param.albedo / PI;\n      #endif\n    }\n  #endif\n\n  #ifndef SPECULAR_BRDF\n    #ifdef SIMPLE_SHADING\n      #define SPECULAR_BRDF blinnPhongBRDF\n\n      vec3 blinnPhongBRDF(BRDF_PARAMS param,vec3 h,vec3 o){\n        return param.specular * (param.shiningness + 2.)/(2. * PI) * pow(max(dot(o,h),0.),param.shiningness);\n      }\n    #endif\n  #endif\n\n  #ifndef SPECULAR_BRDF\n    #define SPECULAR_BRDF cookTorranceBRDF\n\n    float ctd_GGX_Distribution(BRDF_PARAMS param,vec3 l,vec3 v,vec3 n,vec3 h){\n      float alpha2 = pow(param.roughness,4.0);\n      float nh2 = pow(dot(n,h),2.0);\n      return alpha2/(PI*pow(nh2*(alpha2 - 1.0) + 1.0,2.0));\n    }\n\n    float ctg_GGX_SingleGeometryTerm(BRDF_PARAMS param,vec3 n,vec3 v){\n      float d = dot(n,v);\n      float alpha2 = pow(param.roughness,4.);\n      return 2.*d /(d + sqrt(d*d + alpha2*(1. - d*d)));\n    }\n\n    vec3 ctf_Schlick(BRDF_PARAMS param,vec3 l,vec3 v,vec3 n,vec3 h){\n      vec3 f0 = param.f0;\n      float vh = dot(v,n);\n      return f0 + pow(1.0-vh,5.0) * (vec3(1.0) - f0);\n    }\n\n\n    vec3 cookTorranceBRDF(BRDF_PARAMS param,vec3 l,vec3 v,vec3 n){\n      vec3 h = normalize(l+v);\n      return  ctf_Schlick(param,l,v,n,h) * ctd_GGX_Distribution(param,l,v,n,h) * ctg_GGX_SingleGeometryTerm(param,n,l) * ctg_GGX_SingleGeometryTerm(param,n,v)/(4.0 * dot(l,n) * dot(v,n));\n    }\n  #endif\n\n  #ifndef BRDF\n    #ifdef SIMPLE_SHADING\n      #define BRDF simpleBRDF\n\n      vec3 simpleBRDF(BRDF_PARAMS param,vec3 i,vec3 o,vec3 n){\n        return DIFFUSE_BRDF(param,i,o,n)+ SPECULAR_BRDF(param,reflect(-i,n),o);\n      }\n    #endif\n  #endif\n\n  #ifndef BRDF\n    #define BRDF pbrBRDF\n    vec3 pbrBRDF(BRDF_PARAMS param,vec3 i,vec3 o,vec3 n){\n      return DIFFUSE_BRDF(param,i,o,n) + SPECULAR_BRDF(param,i,o,n);\n    }\n  #endif\n#ifdef USE_DIR_LIGHT\n\n#ifdef USE_SHADOW_MAP\n\n  bool isUVRegion(vec2 uv){\n    return all(bvec4(greaterThan(uv,vec2(0,0)),lessThan(uv,vec2(1,1))));\n  }\n\n  vec2 correctUV(vec2 uv,float index){\n    float i = fract(index / _shadowMapElementCount.x) * _shadowMapElementCount.x;\n    float j = (index - i) / _shadowMapElementCount.x;\n    return vec2((i + uv.x)/_shadowMapElementCount.x,(j + uv.y)/_shadowMapElementCount.y);\n  }\n\n  float shadowCoefficient(vec3 fragPosition,highp mat4 lightMatrix,float index){\n    highp vec4 lPos = lightMatrix * vec4(fragPosition,1.0);\n    if(any(bvec2(lPos.z/lPos.w > 1.0,lPos.z/lPos.w < -1.0))){\n      return 1.0;\n    }\n    vec2 bUV = lPos.xy / lPos.w / 2.0 + vec2(0.5);\n    highp float od = (lPos.z/lPos.w + 1.0)/2.0;\n    float fill = 0.0;\n    float N = 0.;\n    // PCF sampling\n    vec2 lUV = bUV;\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(_shadowMapPixelSize,0);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(-_shadowMapPixelSize,0);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(0,_shadowMapPixelSize);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(0,-_shadowMapPixelSize);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    if(N > 4.0){\n      return 1.0 - fill/N;\n    }\n    return 1.0;\n  }\n\n  highp vec4 fromLightMatrices(vec2 uv){\n    return texture2D(_lightMatrices,uv);\n  }\n\n  highp mat4 fetchLightMatrix(float index){\n    float y = 1.0 / _lightMatricesCount * (index  + 0.5);\n    return mat4(\n      fromLightMatrices(vec2(0.125,y)),\n      fromLightMatrices(vec2(0.375,y)),\n      fromLightMatrices(vec2(0.625,y)),\n      fromLightMatrices(vec2(0.875,y))\n      );\n  }\n#endif\n\n  vec3 directionalLight(BRDF_PARAMS param,vec3 fragNormal,vec3 fragPosition){\n    vec3 result = vec3(0,0,0);\n    for(int i = 0; i < DIR_LIGHT_COUNT;i++){\n      vec3 lI = lambert(fragNormal,-_dLightDir[i]) * _dLightColor[i];\n      float sc = 1.0;\n      #ifdef USE_SHADOW_MAP // Shadowmap Calculations\n        if(_dLightParams[i].x >= 0.0){\n          highp mat4 lMat = fetchLightMatrix(_dLightParams[i].x);\n          sc = shadowCoefficient(fragPosition,lMat,_dLightParams[i].x);\n        }\n      #endif\n      vec3 lColor = sc * lI * BRDF(param,-_dLightDir[i],normalize(_cameraPosition - fragPosition),fragNormal);\n      result += lColor;\n    }\n    return result;\n  }\n#endif\n#ifdef USE_POINT_LIGHT\n  vec3 pointLight(BRDF_PARAMS param,vec3 fragNormal,vec3 fragPosition){\n    vec3 result = vec3(0,0,0);\n    for(int i = 0; i < POINT_LIGHT_COUNT;i++){\n      vec3 l2p = _pLightPosition[i] - fragPosition;\n      float d = length(l2p);\n      vec2 lightParam = _pLightParam[i];\n      float atten = max(0.,1.0-d/lightParam.x)/(1.0 + lightParam.y*lightParam.y*d);\n      l2p = normalize(l2p);\n      vec3 lI = lambert(fragNormal,l2p)* _pLightColor[i] * atten;\n      vec3 lColor = lI  * BRDF(param,l2p,normalize(_cameraPosition - fragPosition),fragNormal);\n      result += lColor ;\n    }\n    return result;\n  }\n#endif\n#ifdef USE_SPOT_LIGHT\n  vec3 spotLight(BRDF_PARAMS param,vec3 fragNormal,vec3 fragPosition){\n    vec3 result = vec3(0);\n    for(int i = 0; i < SPOT_LIGHT_COUNT; i++){\n      float innerConeAngle = _sLightParam[i].x;\n      float outerConeAngle = _sLightParam[i].y;\n      float outCos=cos(outerConeAngle);\n      float innCos=cos(innerConeAngle);\n\n      vec3 p2l = _sLightPosition[i] - fragPosition;\n      float d = length(p2l);\n      p2l=p2l/d;\n      float c = dot(-p2l,normalize(_sLightDir[i]));\n      float decay = _sLightParam[i].z;//減衰係数\n      decay = 1.;\n      float angleDecay = decay;\n      //\n      float distDecayCoefficient = 1.0 / (d * d);\n      float angleDecayCoefficient = pow(clamp((c-outCos)/(innCos-outCos),0.0,1.0),angleDecay);\n      //\n      vec3 lI = lambert(p2l,fragNormal)*_sLightColor[i]*angleDecayCoefficient*distDecayCoefficient;\n      vec3 lColor = lI * BRDF(param,p2l,normalize(_cameraPosition - fragPosition),fragNormal);\n      result += lColor;\n    }\n    return result;\n  }\n#endif\n  vec3 shading(BRDF_PARAMS params,vec3 fragNormal,vec3 fragPosition){\n    vec3 lightingColor = vec3(0);\n    #ifdef USE_DIR_LIGHT\n    lightingColor.rgb += directionalLight(params,fragNormal,fragPosition);\n    #endif\n    #ifdef USE_POINT_LIGHT\n    lightingColor.rgb += pointLight(params,fragNormal,fragPosition);\n    #endif\n    #ifdef USE_SPOT_LIGHT\n    lightingColor.rgb += spotLight(params,fragNormal,fragPosition);\n    #endif\n    return lightingColor;\n  }\n"},function(e,t){e.exports='@Technique default{\n@Pass{\n@BlendFunc(SRC_ALPHA,ONE_MINUS_SRC_ALPHA)\nFS_PREC(mediump,float)\n#define SIMPLE_SHADING\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec4 vPosition;\n\n#ifdef ATTRIBUTE_COLOR_ENABLED\nvarying vec4 vColor;\n#endif\n\n#ifdef VS\n  attribute vec3 position;\n  attribute vec3 normal;\n\n  #ifdef ATTRIBUTE_TEXCOORD_ENABLED\n  attribute vec2 texCoord;\n  #endif\n\n  #ifdef ATTRIBUTE_COLOR_ENABLED\n  @COLOR\n  attribute vec4 color;\n  #endif\n\n  uniform mat4 _matPVM;\n  uniform mat4 _matM;\n\n  void main(){\n    gl_Position = _matPVM * vec4(position,1.0);\n    vNormal = normalize((_matM * vec4(normal,0.0)).xyz);\n    vPosition = (_matM * vec4(position,1.0));\n    #ifndef ATTRIBUTE_TEXCOORD_ENABLED\n    vTexCoord = position.xy / 2.0 + vec2(0.5);\n    #endif\n    #ifdef ATTRIBUTE_TEXCOORD_ENABLED\n    vTexCoord = texCoord;\n    #endif\n    #ifdef ATTRIBUTE_COLOR_ENABLED\n    vColor = color;\n    #endif\n\n  }\n#endif\n\n#ifdef FS\n  @CAMERA_POSITION\n  uniform vec3 _cameraPosition;\n\n  uniform sampler2D texture;\n\n  @HAS_TEXTURE{sampler:"texture"}\n  uniform bool useTexture;\n\n  @{default:"white",type:"color"}\n  uniform vec4 diffuse;\n\n  @{default:0.3}\n  uniform float shiningness;\n\n  @{default:"black",type:"color"}\n  uniform vec3 emission;\n\n  @{default:"white",type:"color"}\n  uniform vec3 specular;\n\n  @{default:0.5}\n  uniform float specularRatio;\n\n  @import "forward-shading"\n\n  void main(){\n    vec4 lastColor = vec4(0,0,0,diffuse.a);\n    vec3 dBaseColor = diffuse.rgb;\n    #ifdef ATTRIBUTE_COLOR_ENABLED\n    dBaseColor.rgb *= vColor.rgb;\n    #endif\n    if(useTexture){\n      vec4 texColor = texture2D(texture,vTexCoord);\n      dBaseColor = pow(texColor.rgb,vec3(2.2));\n      lastColor.a = texColor.a;\n    }\n    BRDF_PARAMS param = BRDF_PARAMS(dBaseColor,specular,shiningness);\n    lastColor.rgb += emission + shading(param,vNormal,vPosition.xyz/vPosition.w);\n    gl_FragColor.rgb = pow(lastColor.rgb,vec3(1.0/2.2)); // Gamma correction\n    gl_FragColor.a = lastColor.a;\n    #ifdef ATTRIBUTE_COLOR_ENABLED\n    gl_FragColor.a *= vColor.a;\n    #endif\n  }\n#endif\n}\n}\n\n@Technique hitarea{\n  @Disable(BLEND)\n  @Pass{\n    FS_PREC(mediump,float)\n\n    #ifdef VS\n      attribute vec3 position;\n      uniform mat4 _matPVM;\n\n      void main(){\n        gl_Position = _matPVM * vec4(position,1.0);\n      }\n    #endif\n\n    #ifdef FS\n      @MESH_INDEX\n      uniform vec4 meshIndex;\n      void main(){\n        gl_FragColor = meshIndex;\n      }\n    #endif\n  }\n}\n\n@Technique depth{\n  @Pass{\n    @CullFace(FRONT)\n  FS_PREC(highp,float)\n\n  varying vec4 vPos;\n\n  vec3 EncodeFloatRGB( float v ) {\n    vec3 enc = vec3(1.0, 255.0, 65025.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzz * vec3(1.0/255.0,1.0/255.0,0.0);\n    return enc;\n  }\n\n  float DecodeFloatRGB( vec3 rgb ) {\n    return dot( rgb, vec3(1.0, 1./255.0, 1./65025.0) );\n  }\n\n  #ifdef VS\n    attribute vec3 position;\n    uniform mat4 _matPVM;\n    void main(){\n      gl_Position = vPos= _matPVM * vec4(position,1.0);\n    }\n  #endif\n\n  #ifdef FS\n    void main(){\n      gl_FragColor.rgb = EncodeFloatRGB((vPos.z/vPos.w + 1.0)/2.0);\n      gl_FragColor.a = 1.0;\n    }\n  #endif\n  }\n}\n'}])});