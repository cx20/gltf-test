define(["./when-4bbc8319","./Matrix2-860854d4","./Transforms-0becfc64","./ComponentDatatype-8f55628c","./RuntimeError-1349fdaf","./GeometryAttribute-4590b388","./GeometryAttributes-7827a6c2","./IndexDatatype-1d853600","./VertexFormat-b8b51b88","./WallGeometryLibrary-5659a4a7","./combine-e9466e32","./WebGLConstants-508b9636","./arrayRemoveDuplicates-b1a32b72","./PolylinePipeline-55bb263f","./EllipsoidGeodesic-0a6aa4ee","./EllipsoidRhumbLine-d4d43630","./IntersectionTests-1d677ce2","./Plane-0e4269ac"],(function(e,t,n,i,a,o,r,s,l,m,u,p,c,d,y,f,g,h){"use strict";const C=new t.Cartesian3,b=new t.Cartesian3,x=new t.Cartesian3,A=new t.Cartesian3,_=new t.Cartesian3,E=new t.Cartesian3,w=new t.Cartesian3;function F(n){const a=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,o=n.maximumHeights,r=n.minimumHeights,s=e.defaultValue(n.vertexFormat,l.VertexFormat.DEFAULT),m=e.defaultValue(n.granularity,i.CesiumMath.RADIANS_PER_DEGREE),u=e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84);this._positions=a,this._minimumHeights=r,this._maximumHeights=o,this._vertexFormat=l.VertexFormat.clone(s),this._granularity=m,this._ellipsoid=t.Ellipsoid.clone(u),this._workerName="createWallGeometry";let p=1+a.length*t.Cartesian3.packedLength+2;e.defined(r)&&(p+=r.length),e.defined(o)&&(p+=o.length),this.packedLength=p+t.Ellipsoid.packedLength+l.VertexFormat.packedLength+1}F.pack=function(n,i,a){let o;a=e.defaultValue(a,0);const r=n._positions;let s=r.length;for(i[a++]=s,o=0;o<s;++o,a+=t.Cartesian3.packedLength)t.Cartesian3.pack(r[o],i,a);const m=n._minimumHeights;if(s=e.defined(m)?m.length:0,i[a++]=s,e.defined(m))for(o=0;o<s;++o)i[a++]=m[o];const u=n._maximumHeights;if(s=e.defined(u)?u.length:0,i[a++]=s,e.defined(u))for(o=0;o<s;++o)i[a++]=u[o];return t.Ellipsoid.pack(n._ellipsoid,i,a),a+=t.Ellipsoid.packedLength,l.VertexFormat.pack(n._vertexFormat,i,a),i[a+=l.VertexFormat.packedLength]=n._granularity,i};const v=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),L=new l.VertexFormat,k={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:v,vertexFormat:L,granularity:void 0};return F.unpack=function(n,i,a){let o;i=e.defaultValue(i,0);let r=n[i++];const s=new Array(r);for(o=0;o<r;++o,i+=t.Cartesian3.packedLength)s[o]=t.Cartesian3.unpack(n,i);let m,u;if(r=n[i++],r>0)for(m=new Array(r),o=0;o<r;++o)m[o]=n[i++];if(r=n[i++],r>0)for(u=new Array(r),o=0;o<r;++o)u[o]=n[i++];const p=t.Ellipsoid.unpack(n,i,v);i+=t.Ellipsoid.packedLength;const c=l.VertexFormat.unpack(n,i,L),d=n[i+=l.VertexFormat.packedLength];return e.defined(a)?(a._positions=s,a._minimumHeights=m,a._maximumHeights=u,a._ellipsoid=t.Ellipsoid.clone(p,a._ellipsoid),a._vertexFormat=l.VertexFormat.clone(c,a._vertexFormat),a._granularity=d,a):(k.positions=s,k.minimumHeights=m,k.maximumHeights=u,k.granularity=d,new F(k))},F.fromConstantHeights=function(t){const n=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;let i,a;const o=t.minimumHeight,r=t.maximumHeight,s=e.defined(o),l=e.defined(r);if(s||l){const e=n.length;i=s?new Array(e):void 0,a=l?new Array(e):void 0;for(let t=0;t<e;++t)s&&(i[t]=o),l&&(a[t]=r)}return new F({positions:n,maximumHeights:a,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},F.createGeometry=function(a){const l=a._positions,u=a._minimumHeights,p=a._maximumHeights,c=a._vertexFormat,d=a._granularity,y=a._ellipsoid,f=m.WallGeometryLibrary.computePositions(y,l,p,u,d,!0);if(!e.defined(f))return;const g=f.bottomPositions,h=f.topPositions,F=f.numCorners;let v=h.length,L=2*v;const k=c.position?new Float64Array(L):void 0,H=c.normal?new Float32Array(L):void 0,V=c.tangent?new Float32Array(L):void 0,G=c.bitangent?new Float32Array(L):void 0,D=c.st?new Float32Array(L/3*2):void 0;let P,T=0,z=0,O=0,R=0,S=0,I=w,N=E,M=_,W=!0;v/=3;let B=0;const U=1/(v-F-1);for(P=0;P<v;++P){const e=3*P,n=t.Cartesian3.fromArray(h,e,C),a=t.Cartesian3.fromArray(g,e,b);if(c.position&&(k[T++]=a.x,k[T++]=a.y,k[T++]=a.z,k[T++]=n.x,k[T++]=n.y,k[T++]=n.z),c.st&&(D[S++]=B,D[S++]=0,D[S++]=B,D[S++]=1),c.normal||c.tangent||c.bitangent){let a=t.Cartesian3.clone(t.Cartesian3.ZERO,A);const o=t.Cartesian3.subtract(n,y.geodeticSurfaceNormal(n,b),b);if(P+1<v&&(a=t.Cartesian3.fromArray(h,e+3,A)),W){const e=t.Cartesian3.subtract(a,n,x),i=t.Cartesian3.subtract(o,n,C);I=t.Cartesian3.normalize(t.Cartesian3.cross(i,e,I),I),W=!1}t.Cartesian3.equalsEpsilon(n,a,i.CesiumMath.EPSILON10)?W=!0:(B+=U,c.tangent&&(N=t.Cartesian3.normalize(t.Cartesian3.subtract(a,n,N),N)),c.bitangent&&(M=t.Cartesian3.normalize(t.Cartesian3.cross(I,N,M),M))),c.normal&&(H[z++]=I.x,H[z++]=I.y,H[z++]=I.z,H[z++]=I.x,H[z++]=I.y,H[z++]=I.z),c.tangent&&(V[R++]=N.x,V[R++]=N.y,V[R++]=N.z,V[R++]=N.x,V[R++]=N.y,V[R++]=N.z),c.bitangent&&(G[O++]=M.x,G[O++]=M.y,G[O++]=M.z,G[O++]=M.x,G[O++]=M.y,G[O++]=M.z)}}const q=new r.GeometryAttributes;c.position&&(q.position=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k})),c.normal&&(q.normal=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:H})),c.tangent&&(q.tangent=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),c.bitangent&&(q.bitangent=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),c.st&&(q.st=new o.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:D}));const J=L/3;L-=6*(F+1);const Y=s.IndexDatatype.createTypedArray(J,L);let Z=0;for(P=0;P<J-2;P+=2){const e=P,n=P+2,a=t.Cartesian3.fromArray(k,3*e,C),o=t.Cartesian3.fromArray(k,3*n,b);if(t.Cartesian3.equalsEpsilon(a,o,i.CesiumMath.EPSILON10))continue;const r=P+1,s=P+3;Y[Z++]=r,Y[Z++]=e,Y[Z++]=s,Y[Z++]=s,Y[Z++]=e,Y[Z++]=n}return new o.Geometry({attributes:q,indices:Y,primitiveType:o.PrimitiveType.TRIANGLES,boundingSphere:new n.BoundingSphere.fromVertices(k)})},function(n,i){return e.defined(i)&&(n=F.unpack(n,i)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),F.createGeometry(n)}}));
