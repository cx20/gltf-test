!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("redcube",[],t):"object"==typeof exports?exports.redcube=t():e.redcube=t()}(self,()=>(()=>{var e,t,r={603:()=>{},843:e=>{e.exports=function(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var t=0,r=e.length;function n(){var n="";do{var i=e[t];if(10==i){++t;break}n+=String.fromCharCode(i)}while(++t<r);return n}for(var i=0,s=0,a=1,o=!1,l=0;l<20;l++){var c,u=n();if(c=u.match("#\\?RADIANCE"));else if(c=u.match("FORMAT=32-bit_rle_rgbe"))o=!0;else if(c=u.match("EXPOSURE=\\s*([0-9]*[.][0-9]*)"))a=Number(c[1]);else if(c=u.match("#.*"));else if(c=u.match("-Y ([0-9]+) \\+X ([0-9]+)")){s=Number(c[1]),i=Number(c[2]);break}}if(!o)throw new Error("File is not run length encoded!");var f=new Uint8Array(i*s*4);!function(e,t,r,n,i,s){var a,o,l,c=new Array(4),u=null,f=new Array(2),h=e.length;function m(t){var r=0;do{t[r++]=e[n]}while(++n<h&&r<t.length);return r}function d(t,r,i){var s=0;do{t[r+s++]=e[n]}while(++n<h&&s<i);return s}function p(e,t,r,n){var i=4*n,s=d(t,r,i);if(s<i)throw new Error("Error reading raw pixels: got "+s+" bytes, expected "+i)}for(;s>0;){if(m(c)<c.length)throw new Error("Error reading bytes: expected "+c.length);if(2!=c[0]||2!=c[1]||128&c[2])return t[r++]=c[0],t[r++]=c[1],t[r++]=c[2],t[r++]=c[3],void p(0,t,r,i*s-1);if(((255&c[2])<<8|255&c[3])!=i)throw new Error("Wrong scanline width "+((255&c[2])<<8|255&c[3])+", expected "+i);null==u&&(u=new Array(4*i)),a=0;for(var T=0;T<4;T++)for(o=(T+1)*i;a<o;){if(m(f)<f.length)throw new Error("Error reading 2-byte buffer");if((255&f[0])>128){if(0==(l=(255&f[0])-128)||l>o-a)throw new Error("Bad scanline data");for(;l-- >0;)u[a++]=f[1]}else{if(0==(l=255&f[0])||l>o-a)throw new Error("Bad scanline data");if(u[a++]=f[1],--l>0){if(d(u,a,l)<l)throw new Error("Error reading non-run data");a+=l}}}for(T=0;T<i;T++)t[r+0]=u[T],t[r+1]=u[T+i],t[r+2]=u[T+2*i],t[r+3]=u[T+3*i],r+=4;s--}}(e,f,0,t,i,s);for(var h=new Float32Array(i*s*4),m=0;m<f.length;m+=4){var d=f[m+0]/255,p=f[m+1]/255,T=f[m+2]/255,E=f[m+3],g=Math.pow(2,E-128);d*=g,p*=g,T*=g;var x=m;h[x+0]=d,h[x+1]=p,h[x+2]=T,h[x+3]=1}return{shape:[i,s],exposure:a,gamma:1,data:h}}}},n={};function i(e){var t=n[e];if(void 0!==t)return t.exports;var s=n[e]={exports:{}};return r[e](s,s.exports,i),s.exports}i.m=r,i.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return i.d(t,{a:t}),t},i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce((t,r)=>(i.f[r](e,t),t),[])),i.u=e=>"libs/"+{277:"glslang",514:"twgsl",621:"draco3d",971:"libktx"}[e]+".js",i.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e={},t="redcube:",i.l=(r,n,s,a)=>{if(e[r])e[r].push(n);else{var o,l;if(void 0!==s)for(var c=document.getElementsByTagName("script"),u=0;u<c.length;u++){var f=c[u];if(f.getAttribute("src")==r||f.getAttribute("data-webpack")==t+s){o=f;break}}o||(l=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,i.nc&&o.setAttribute("nonce",i.nc),o.setAttribute("data-webpack",t+s),o.src=r),e[r]=[n];var h=(t,n)=>{o.onerror=o.onload=null,clearTimeout(m);var i=e[r];if(delete e[r],o.parentNode&&o.parentNode.removeChild(o),i&&i.forEach(e=>e(n)),t)return t(n)},m=setTimeout(h.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=h.bind(null,o.onerror),o.onload=h.bind(null,o.onload),l&&document.head.appendChild(o)}},i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;i.g.importScripts&&(e=i.g.location+"");var t=i.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var n=r.length-1;n>-1&&(!e||!/^http(s?):/.test(e));)e=r[n--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),i.p=e})(),(()=>{var e={792:0};i.f.j=(t,r)=>{var n=i.o(e,t)?e[t]:void 0;if(0!==n)if(n)r.push(n[2]);else{var s=new Promise((r,i)=>n=e[t]=[r,i]);r.push(n[2]=s);var a=i.p+i.u(t),o=new Error;i.l(a,r=>{if(i.o(e,t)&&(0!==(n=e[t])&&(e[t]=void 0),n)){var s=r&&("load"===r.type?"missing":r.type),a=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+s+": "+a+")",o.name="ChunkLoadError",o.type=s,o.request=a,n[1](o)}},"chunk-"+t,t)}};var t=(t,r)=>{var n,s,[a,o,l]=r,c=0;if(a.some(t=>0!==e[t])){for(n in o)i.o(o,n)&&(i.m[n]=o[n]);l&&l(i)}for(t&&t(r);c<a.length;c++)s=a[c],i.o(e,s)&&e[s]&&e[s][0](),e[s]=0},r=self.webpackChunkredcube=self.webpackChunkredcube||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var s={};return(()=>{"use strict";i.r(s),i.d(s,{RedCube:()=>Ce});class e{_services;_singletons;constructor(){this._services=new Map,this._singletons=new Map,this.update=this.update.bind(this)}register(e,t,r=[],...n){this._services.set(e,{definition:t,dependencies:r,args:n}),this._isClass(t)?t.__update=this.update:this._updateDep(e,t)}get(e){const t=this._services.get(e);if(!t)return null;if(this._isClass(t.definition)){const r=this._singletons.get(e);if(r)return r;{const r=this._createInstance(t);return this._singletons.set(e,r),r}}return t.definition}update(e,...t){this._services.get(e).args=t,this._singletons.delete(e);const r=this.get(e);this._updateDep(e,r)}_updateDep(e,t){for(const[r,n]of this._singletons)this._services.get(r).dependencies.some(t=>t===e)&&n[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(n,t);this._singletons.set(e,t)}_getResolvedDependencies(e){let t=[];return e.dependencies&&(t=e.dependencies.map(e=>[e,this.get(e)])),t}_createInstance(e){const t=new e.definition(...e.args);return this._getResolvedDependencies(e).forEach(([e,r])=>{t[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(t,r)}),t}_isClass(e){return"function"==typeof e&&/^class\s/.test(Function.prototype.toString.call(e))}}class t{elements;constructor(e){let t,r,n;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(r=e.elements,n=new Float32Array(16),t=0;t<16;++t)n[t]=r[t];this.elements=n}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}set(e){let t,r,n;if(r=e,n=this.elements,r!==n){for(t=0;t<16;++t)n[t]=r[t];return this}}multiply(e){return this.concat(e),this}concat({elements:e}){let t,r,n,i,s,a,o,l;if(r=this.elements,n=this.elements,i=e,r===i)for(i=new Float32Array(16),t=0;t<16;++t)i[t]=r[t];for(t=0;t<4;t++)s=n[t],a=n[t+4],o=n[t+8],l=n[t+12],r[t]=s*i[0]+a*i[1]+o*i[2]+l*i[3],r[t+4]=s*i[4]+a*i[5]+o*i[6]+l*i[7],r[t+8]=s*i[8]+a*i[9]+o*i[10]+l*i[11],r[t+12]=s*i[12]+a*i[13]+o*i[14]+l*i[15];return this}setInverseOf({elements:e}){let t,r,n,i,s;if(r=e,n=this.elements,i=new Float32Array(16),i[0]=r[5]*r[10]*r[15]-r[5]*r[11]*r[14]-r[9]*r[6]*r[15]+r[9]*r[7]*r[14]+r[13]*r[6]*r[11]-r[13]*r[7]*r[10],i[4]=-r[4]*r[10]*r[15]+r[4]*r[11]*r[14]+r[8]*r[6]*r[15]-r[8]*r[7]*r[14]-r[12]*r[6]*r[11]+r[12]*r[7]*r[10],i[8]=r[4]*r[9]*r[15]-r[4]*r[11]*r[13]-r[8]*r[5]*r[15]+r[8]*r[7]*r[13]+r[12]*r[5]*r[11]-r[12]*r[7]*r[9],i[12]=-r[4]*r[9]*r[14]+r[4]*r[10]*r[13]+r[8]*r[5]*r[14]-r[8]*r[6]*r[13]-r[12]*r[5]*r[10]+r[12]*r[6]*r[9],i[1]=-r[1]*r[10]*r[15]+r[1]*r[11]*r[14]+r[9]*r[2]*r[15]-r[9]*r[3]*r[14]-r[13]*r[2]*r[11]+r[13]*r[3]*r[10],i[5]=r[0]*r[10]*r[15]-r[0]*r[11]*r[14]-r[8]*r[2]*r[15]+r[8]*r[3]*r[14]+r[12]*r[2]*r[11]-r[12]*r[3]*r[10],i[9]=-r[0]*r[9]*r[15]+r[0]*r[11]*r[13]+r[8]*r[1]*r[15]-r[8]*r[3]*r[13]-r[12]*r[1]*r[11]+r[12]*r[3]*r[9],i[13]=r[0]*r[9]*r[14]-r[0]*r[10]*r[13]-r[8]*r[1]*r[14]+r[8]*r[2]*r[13]+r[12]*r[1]*r[10]-r[12]*r[2]*r[9],i[2]=r[1]*r[6]*r[15]-r[1]*r[7]*r[14]-r[5]*r[2]*r[15]+r[5]*r[3]*r[14]+r[13]*r[2]*r[7]-r[13]*r[3]*r[6],i[6]=-r[0]*r[6]*r[15]+r[0]*r[7]*r[14]+r[4]*r[2]*r[15]-r[4]*r[3]*r[14]-r[12]*r[2]*r[7]+r[12]*r[3]*r[6],i[10]=r[0]*r[5]*r[15]-r[0]*r[7]*r[13]-r[4]*r[1]*r[15]+r[4]*r[3]*r[13]+r[12]*r[1]*r[7]-r[12]*r[3]*r[5],i[14]=-r[0]*r[5]*r[14]+r[0]*r[6]*r[13]+r[4]*r[1]*r[14]-r[4]*r[2]*r[13]-r[12]*r[1]*r[6]+r[12]*r[2]*r[5],i[3]=-r[1]*r[6]*r[11]+r[1]*r[7]*r[10]+r[5]*r[2]*r[11]-r[5]*r[3]*r[10]-r[9]*r[2]*r[7]+r[9]*r[3]*r[6],i[7]=r[0]*r[6]*r[11]-r[0]*r[7]*r[10]-r[4]*r[2]*r[11]+r[4]*r[3]*r[10]+r[8]*r[2]*r[7]-r[8]*r[3]*r[6],i[11]=-r[0]*r[5]*r[11]+r[0]*r[7]*r[9]+r[4]*r[1]*r[11]-r[4]*r[3]*r[9]-r[8]*r[1]*r[7]+r[8]*r[3]*r[5],i[15]=r[0]*r[5]*r[10]-r[0]*r[6]*r[9]-r[4]*r[1]*r[10]+r[4]*r[2]*r[9]+r[8]*r[1]*r[6]-r[8]*r[2]*r[5],s=r[0]*i[0]+r[1]*i[4]+r[2]*i[8]+r[3]*i[12],0===s)return this;for(s=1/s,t=0;t<16;t++)n[t]=i[t]*s;return this}invert(){return this.setInverseOf(this)}makeOrthographic(e,t,r,n,i,s){var a=this.elements,o=1/(t-e),l=1/(r-n),c=1/(s-i),u=(t+e)*o,f=(r+n)*l,h=(s+i)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-h,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}setOrtho(e,t,r,n){let i,s,a,o;return s=1/e,a=1/t,o=2/(r-n),i=this.elements,i[0]=s,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=o,i[11]=(n+r)/(r-n),i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setPerspective(e,t,r,n){let i,s,a,o;if(r===n||0===t)throw"null frustum";if(r<=0)throw"near <= 0";if(n<=0)throw"far <= 0";if(e/=2,a=Math.sin(e),0===a)throw"null frustum";return s=1/(n-r),o=Math.cos(e)/a,i=this.elements,i[0]=o/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=o,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-(n+r)*s,i[11]=-1,i[12]=0,i[13]=0,i[14]=-2*r*n*s,i[15]=0,this}perspective(e,r,n,i){return this.concat((new t).setPerspective(e,r,n,i))}multiplyVector4({elements:e}){const t=this.elements,r=e,n=new o,i=n.elements;return i[0]=r[0]*t[0]+r[1]*t[4]+r[2]*t[8]+r[3]*t[12],i[1]=r[0]*t[1]+r[1]*t[5]+r[2]*t[9]+r[3]*t[13],i[2]=r[0]*t[2]+r[1]*t[6]+r[2]*t[10]+r[3]*t[14],i[3]=r[0]*t[3]+r[1]*t[7]+r[2]*t[11]+r[3]*t[15],n}getScaling(){let e=this.elements,t=e[0],r=e[1],i=e[2],s=e[4],a=e[5],o=e[6],l=e[8],c=e[9],u=e[10];return new n([Math.sqrt(t*t+r*r+i*i),Math.sqrt(s*s+a*a+o*o),Math.sqrt(l*l+c*c+u*u)])}scale(e){const t=e.elements[0],r=e.elements[1],n=e.elements[2],i=this.elements;return i[0]*=t,i[4]*=r,i[8]*=n,i[1]*=t,i[5]*=r,i[9]*=n,i[2]*=t,i[6]*=r,i[10]*=n,i[3]*=t,i[7]*=r,i[11]*=n,this}restoreScale(e){const t=e.elements[0],r=e.elements[1],n=e.elements[2],i=this.elements;return i[0]/=t,i[4]/=r,i[8]/=n,i[1]/=t,i[5]/=r,i[9]/=n,i[2]/=t,i[6]/=r,i[10]/=n,i[3]/=t,i[7]/=r,i[11]/=n,this}setTranslate(e){const t=this.elements,r=e.elements[0],n=e.elements[1],i=e.elements[2];return t[12]=r,t[13]=n,t[14]=i,t[15]=1,this}translate(e,t,r){const n=this.elements;return n[12]+=n[0]*e+n[4]*t+n[8]*r,n[13]+=n[1]*e+n[5]*t+n[9]*r,n[14]+=n[2]*e+n[6]*t+n[10]*r,n[15]+=n[3]*e+n[7]*t+n[11]*r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,n))}rotate(e,t){let r,n,i,s,a,o,l,c,u,f,h,m,d,p,T,E,g,x,v,R,b,S,_,A,U=e.elements[0],P=e.elements[1],N=e.elements[2],F=Math.hypot(U,P,N);if(F<Number.EPSILON)return null;F=1/F,U*=F,P*=F,N*=F,r=Math.sin(t),n=Math.cos(t),i=1-n;let I=this.elements;return s=I[0],a=I[1],o=I[2],l=I[3],c=I[4],u=I[5],f=I[6],h=I[7],m=I[8],d=I[9],p=I[10],T=I[11],E=U*U*i+n,g=P*U*i+N*r,x=N*U*i-P*r,v=U*P*i-N*r,R=P*P*i+n,b=N*P*i+U*r,S=U*N*i+P*r,_=P*N*i-U*r,A=N*N*i+n,I[0]=s*E+c*g+m*x,I[1]=a*E+u*g+d*x,I[2]=o*E+f*g+p*x,I[3]=l*E+h*g+T*x,I[4]=s*v+c*R+m*b,I[5]=a*v+u*R+d*b,I[6]=o*v+f*R+p*b,I[7]=l*v+h*R+T*b,I[8]=s*S+c*_+m*A,I[9]=a*S+u*_+d*A,I[10]=o*S+f*_+p*A,I[11]=l*S+h*_+T*A,this}makeRotationAxis(e,t){const r=this.elements,n=Math.cos(t),i=Math.sin(t),s=1-n,a=e.elements[0],o=e.elements[1],l=e.elements[2],c=s*a,u=s*o;return r[0]=c*a+n,r[1]=c*o-i*l,r[2]=c*l+i*o,r[3]=0,r[4]=c*o+i*l,r[5]=u*o+n,r[6]=u*l-i*a,r[7]=0,r[8]=c*l-i*o,r[9]=u*l+i*a,r[10]=s*l*l+n,r[11]=0,r[15]=1,this}makeRotationFromQuaternion(e){const t=this.elements,r=e[0],n=e[1],i=e[2],s=e[3],a=r+r,o=n+n,l=i+i,c=r*a,u=r*o,f=r*l,h=n*o,m=n*l,d=i*l,p=s*a,T=s*o,E=s*l;return t[0]=1-(h+d),t[4]=u-E,t[8]=f+T,t[1]=u+E,t[5]=1-(c+d),t[9]=m-p,t[2]=f-T,t[6]=m+p,t[10]=1-(c+h),this}transpose(){let e,t;return e=this.elements,t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}}class r{elements;constructor(e){this.elements=e.slice()}lerp(e,t,r){const n=this.elements;for(let i=0;i<n.length;i++)n[i]=e[i]+r*(t[i]-e[i]);return this}}class n{elements;get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}static FromArrayToRef(e,t,r){r.x=e[t],r.y=e[t+1],r.z=e[t+2]}constructor(e){const t=new Float32Array(3);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2]),this.elements=t}projectOnVector(e){const t=n.dot(e,this)/e.lengthSq();return new n(e).scale(t)}applyQuaternion({elements:e}){const t=this.elements[0],r=this.elements[1],n=this.elements[2],i=e[0],s=e[1],a=e[2],o=e[3],l=o*t+s*n-a*r,c=o*r+a*t-i*n,u=o*n+i*r-s*t,f=-i*t-s*r-a*n;return this.elements[0]=l*o+f*-i+c*-a-u*-s,this.elements[1]=c*o+f*-s+u*-i-l*-a,this.elements[2]=u*o+f*-a+l*-s-c*-i,this}normalize(){const e=this.elements,t=e[0],r=e[1],n=e[2];let i=Math.sqrt(t*t+r*r+n*n);return i?(1==i||(i=1/i,e[0]=t*i,e[1]=r*i,e[2]=n*i),this):(e[0]=0,e[1]=0,e[2]=0,this)}add(e){const t=this.elements;return e=e.elements,t[0]=t[0]+e[0],t[1]=t[1]+e[1],t[2]=t[2]+e[2],this}addS(e){const t=this.elements;return t[0]=t[0]+e,t[1]=t[1]+e,t[2]=t[2]+e,this}scale(e){const t=this.elements;return t[0]=t[0]*e,t[1]=t[1]*e,t[2]=t[2]*e,this}scale2(e){return new n([this.x*e,this.y*e,this.z*e])}subtract2(e){return new n([this.x-e.x,this.y-e.y,this.z-e.z])}add2(e){return new n([this.x+e.x,this.y+e.y,this.z+e.z])}distanceToSquared(e,t,r){const n=this.elements[0]-e,i=this.elements[1]-t,s=this.elements[2]-r;return n*n+i*i+s*s}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],t[2]=t[2]-e[2],this}divideScalar(e){return this.scale(1/e)}applyMatrix4({elements:e}){const t=this.elements[0],r=this.elements[1],n=this.elements[2],i=e;this.elements[0]=i[0]*t+i[4]*r+i[8]*n+i[12],this.elements[1]=i[1]*t+i[5]*r+i[9]*n+i[13],this.elements[2]=i[2]*t+i[6]*r+i[10]*n+i[14];const s=i[3]*t+i[7]*r+i[11]*n+i[15];return this.divideScalar(s)}lerp(e,t,r){const n=this.elements,i=e[0],s=e[1],a=e[2];return n[0]=i+r*(t[0]-i),n[1]=s+r*(t[1]-s),n[2]=a+r*(t[2]-a),this}lengthSq(){return this.elements[0]*this.elements[0]+this.elements[1]*this.elements[1]+this.elements[2]*this.elements[2]}multiply({elements:e}){return this.elements[0]*=e[0],this.elements[1]*=e[1],this.elements[2]*=e[2],this}static angle(e,t){const r=new n(e.elements),i=new n(t.elements);r.normalize(),i.normalize();const s=n.dot(r,i);return s>1?0:Math.acos(s)}static cross(e,t){e=e.elements,t=t.elements;const r=e[0],i=e[1],s=e[2],a=t[0],o=t[1],l=t[2],c=new n;return c.elements[0]=i*l-s*o,c.elements[1]=s*a-r*l,c.elements[2]=r*o-i*a,c}static dot(e,t){return e=e.elements,t=t.elements,e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}}class a{min=new n([1/0,1/0,1/0]);max=new n([-1/0,-1/0,-1/0]);expand(e){this.min.min(e.min),this.max.max(e.max)}getSize(){const e=new n;return e.subVectors(this.max,this.min),e.length()}}class o{elements;constructor(e){const t=new Float32Array(4);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3]),this.elements=t}set(e){const t=this.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],this}add(e){const t=this.elements;return e=e.elements,t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=t[3]+e[3],this}normalize(){const e=this.elements[0],t=this.elements[1],r=this.elements[2],n=this.elements[3];let i=e*e+t*t+r*r+n*n;return i>0&&(i=1/Math.sqrt(i),this.elements[0]=e*i,this.elements[1]=t*i,this.elements[2]=r*i,this.elements[3]=n*i),this}setFromRotationMatrix({elements:e}){const t=e,r=t[0],n=t[4],i=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],u=t[10],f=r+a+u;let h;return f>0?(h=.5/Math.sqrt(f+1),this.elements[3]=.25/h,this.elements[0]=(c-o)*h,this.elements[1]=(i-l)*h,this.elements[2]=(s-n)*h):r>a&&r>u?(h=2*Math.sqrt(1+r-a-u),this.elements[3]=(c-o)/h,this.elements[0]=.25*h,this.elements[1]=(n+s)/h,this.elements[2]=(i+l)/h):a>u?(h=2*Math.sqrt(1+a-r-u),this.elements[3]=(i-l)/h,this.elements[0]=(n+s)/h,this.elements[1]=.25*h,this.elements[2]=(o+c)/h):(h=2*Math.sqrt(1+u-r-a),this.elements[3]=(s-n)/h,this.elements[0]=(i+l)/h,this.elements[1]=(o+c)/h,this.elements[2]=.25*h),this}lerp(e,t,r){const n=this.elements;if(0===r)return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],this;if(1===r)return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],this;const i=e[0],s=e[1],a=e[2],o=e[3];let l=o*t[3]+i*t[0]+s*t[1]+a*t[2];if(l<0?(n[3]=-t[3],n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],l=-l):(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3]),l>=1)return n[3]=o,n[0]=i,n[1]=s,n[2]=a,this;const c=1-l*l;if(c<=Number.EPSILON){var u=1-r;return n[3]=u*o+r*n[3],n[0]=u*i+r*n[0],n[1]=u*s+r*n[1],n[2]=u*a+r*n[2],this.normalize()}const f=Math.sqrt(c),h=Math.atan2(f,l),m=Math.sin((1-r)*h)/f,d=Math.sin(r*h)/f;return n[3]=o*m+n[3]*d,n[0]=i*m+n[0]*d,n[1]=s*m+n[1]*d,n[2]=a*m+n[2]*d,this}inverse(){return this.elements[0]=-this.elements[0],this.elements[1]=-this.elements[1],this.elements[2]=-this.elements[2],this}}class l{elements;get x(){return this.elements[0]}get y(){return this.elements[1]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}constructor(e){const t=new Float32Array(2);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1]),this.elements=t}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],this}lerp(e,t,r){const n=this.elements,i=e[0],s=e[1];return n[0]=i+r*(t[0]-i),n[1]=s+r*(t[1]-s),this}}class c{children;bin;matrixWorld;matrix;transparentChildren;opaqueChildren;meshes;tracks;cameras;lights;variants;constructor(){this.opaqueChildren=[],this.transparentChildren=[],this.meshes=[],this.children=[],this.bin=[],this.matrixWorld=new t,this.matrix=new t,this.variants=[]}}class u{uuid;name;id;children;matrix;matrixWorld;parent;reflow;constructor(e,r){this.uuid=Math.floor(Date.now()*Math.random()),this.name=e,this.children=[],this.matrix=new t,this.matrixWorld=new t,this.parent=r}getPosition(){return new Float32Array([this.matrixWorld.elements[12],this.matrixWorld.elements[13],this.matrixWorld.elements[14]])}setPosition(e,t,r){t&&this.matrix.makeRotationFromQuaternion(t),r&&this.matrix.scale(new n(r)),e&&this.matrix.setTranslate(new n(e))}setMatrix(e){this.matrix.set(e)}setMatrixWorld(e){this.matrixWorld.set(e)}updateMatrix(){const e=new t;e.multiply(this.parent.matrixWorld),e.multiply(this.matrix),this.setMatrixWorld(e.elements)}}const f={0:"NONE",1:"ONE",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN",256:"DEPTH_BUFFER_BIT",512:"NEVER",513:"LESS",514:"EQUAL",515:"LEQUAL",516:"GREATER",517:"NOTEQUAL",518:"GEQUAL",519:"ALWAYS",768:"SRC_COLOR",769:"ONE_MINUS_SRC_COLOR",770:"SRC_ALPHA",771:"ONE_MINUS_SRC_ALPHA",772:"DST_ALPHA",773:"ONE_MINUS_DST_ALPHA",774:"DST_COLOR",775:"ONE_MINUS_DST_COLOR",776:"SRC_ALPHA_SATURATE",1024:"STENCIL_BUFFER_BIT",1028:"FRONT",1029:"BACK",1032:"FRONT_AND_BACK",1280:"INVALID_ENUM",1281:"INVALID_VALUE",1282:"INVALID_OPERATION",1285:"OUT_OF_MEMORY",1286:"INVALID_FRAMEBUFFER_OPERATION",1798:"drawingBufferHeight",2304:"CW",2305:"CCW",2712:"drawingBufferWidth",2849:"LINE_WIDTH",2884:"CULL_FACE",2885:"CULL_FACE_MODE",2886:"FRONT_FACE",2928:"DEPTH_RANGE",2929:"DEPTH_TEST",2930:"DEPTH_WRITEMASK",2931:"DEPTH_CLEAR_VALUE",2932:"DEPTH_FUNC",2960:"STENCIL_TEST",2961:"STENCIL_CLEAR_VALUE",2962:"STENCIL_FUNC",2963:"STENCIL_VALUE_MASK",2964:"STENCIL_FAIL",2965:"STENCIL_PASS_DEPTH_FAIL",2966:"STENCIL_PASS_DEPTH_PASS",2967:"STENCIL_REF",2968:"STENCIL_WRITEMASK",2978:"VIEWPORT",3024:"DITHER",3042:"BLEND",3074:"READ_BUFFER",3088:"SCISSOR_BOX",3089:"SCISSOR_TEST",3106:"COLOR_CLEAR_VALUE",3107:"COLOR_WRITEMASK",3314:"UNPACK_ROW_LENGTH",3315:"UNPACK_SKIP_ROWS",3316:"UNPACK_SKIP_PIXELS",3317:"UNPACK_ALIGNMENT",3330:"PACK_ROW_LENGTH",3331:"PACK_SKIP_ROWS",3332:"PACK_SKIP_PIXELS",3333:"PACK_ALIGNMENT",3379:"MAX_TEXTURE_SIZE",3386:"MAX_VIEWPORT_DIMS",3408:"SUBPIXEL_BITS",3410:"RED_BITS",3411:"GREEN_BITS",3412:"BLUE_BITS",3413:"ALPHA_BITS",3414:"DEPTH_BITS",3415:"STENCIL_BITS",3553:"TEXTURE_2D",4352:"DONT_CARE",4353:"FASTEST",4354:"NICEST",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT",5131:"HALF_FLOAT",5386:"INVERT",5890:"TEXTURE",6144:"COLOR",6145:"DEPTH",6146:"STENCIL",6402:"DEPTH_COMPONENT",6403:"RED",6406:"ALPHA",6407:"RGB",6408:"RGBA",6409:"LUMINANCE",6410:"LUMINANCE_ALPHA",7680:"KEEP",7681:"REPLACE",7682:"INCR",7683:"DECR",7936:"VENDOR",7937:"RENDERER",7938:"VERSION",9728:"NEAREST",9729:"LINEAR",9984:"NEAREST_MIPMAP_NEAREST",9985:"LINEAR_MIPMAP_NEAREST",9986:"NEAREST_MIPMAP_LINEAR",9987:"LINEAR_MIPMAP_LINEAR",10240:"TEXTURE_MAG_FILTER",10241:"TEXTURE_MIN_FILTER",10242:"TEXTURE_WRAP_S",10243:"TEXTURE_WRAP_T",10497:"REPEAT",10752:"POLYGON_OFFSET_UNITS",16384:"COLOR_BUFFER_BIT",32769:"CONSTANT_COLOR",32770:"ONE_MINUS_CONSTANT_COLOR",32771:"CONSTANT_ALPHA",32772:"ONE_MINUS_CONSTANT_ALPHA",32773:"BLEND_COLOR",32774:"FUNC_ADD",32775:"MIN",32776:"MAX",32777:"BLEND_EQUATION_RGB",32778:"FUNC_SUBTRACT",32779:"FUNC_REVERSE_SUBTRACT",32819:"UNSIGNED_SHORT_4_4_4_4",32820:"UNSIGNED_SHORT_5_5_5_1",32823:"POLYGON_OFFSET_FILL",32824:"POLYGON_OFFSET_FACTOR",32849:"RGB8",32854:"RGBA4",32855:"RGB5_A1",32856:"RGBA8",32857:"RGB10_A2",32873:"TEXTURE_BINDING_2D",32874:"TEXTURE_BINDING_3D",32877:"UNPACK_SKIP_IMAGES",32878:"UNPACK_IMAGE_HEIGHT",32879:"TEXTURE_3D",32882:"TEXTURE_WRAP_R",32883:"MAX_3D_TEXTURE_SIZE",32926:"SAMPLE_ALPHA_TO_COVERAGE",32928:"SAMPLE_COVERAGE",32936:"SAMPLE_BUFFERS",32937:"SAMPLES",32938:"SAMPLE_COVERAGE_VALUE",32939:"SAMPLE_COVERAGE_INVERT",32968:"BLEND_DST_RGB",32969:"BLEND_SRC_RGB",32970:"BLEND_DST_ALPHA",32971:"BLEND_SRC_ALPHA",33e3:"MAX_ELEMENTS_VERTICES",33001:"MAX_ELEMENTS_INDICES",33071:"CLAMP_TO_EDGE",33082:"TEXTURE_MIN_LOD",33083:"TEXTURE_MAX_LOD",33084:"TEXTURE_BASE_LEVEL",33085:"TEXTURE_MAX_LEVEL",33170:"GENERATE_MIPMAP_HINT",33189:"DEPTH_COMPONENT16",33190:"DEPTH_COMPONENT24",33296:"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",33297:"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",33298:"FRAMEBUFFER_ATTACHMENT_RED_SIZE",33299:"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",33300:"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",33301:"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",33302:"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",33303:"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",33304:"FRAMEBUFFER_DEFAULT",33306:"DEPTH_STENCIL_ATTACHMENT",33319:"RG",33320:"RG_INTEGER",33321:"R8",33323:"RG8",33325:"R16F",33326:"R32F",33327:"RG16F",33328:"RG32F",33329:"R8I",33330:"R8UI",33331:"R16I",33332:"R16UI",33333:"R32I",33334:"R32UI",33335:"RG8I",33336:"RG8UI",33337:"RG16I",33338:"RG16UI",33339:"RG32I",33340:"RG32UI",33503:"TEXTURE_IMMUTABLE_LEVELS",33635:"UNSIGNED_SHORT_5_6_5",33640:"UNSIGNED_INT_2_10_10_10_REV",33648:"MIRRORED_REPEAT",33901:"ALIASED_POINT_SIZE_RANGE",33902:"ALIASED_LINE_WIDTH_RANGE",33984:"TEXTURE0",33985:"TEXTURE1",33986:"TEXTURE2",33987:"TEXTURE3",33988:"TEXTURE4",33989:"TEXTURE5",33990:"TEXTURE6",33991:"TEXTURE7",33992:"TEXTURE8",33993:"TEXTURE9",33994:"TEXTURE10",33995:"TEXTURE11",33996:"TEXTURE12",33997:"TEXTURE13",33998:"TEXTURE14",33999:"TEXTURE15",34e3:"TEXTURE16",34001:"TEXTURE17",34002:"TEXTURE18",34003:"TEXTURE19",34004:"TEXTURE20",34005:"TEXTURE21",34006:"TEXTURE22",34007:"TEXTURE23",34008:"TEXTURE24",34009:"TEXTURE25",34010:"TEXTURE26",34011:"TEXTURE27",34012:"TEXTURE28",34013:"TEXTURE29",34014:"TEXTURE30",34015:"TEXTURE31",34016:"ACTIVE_TEXTURE",34024:"MAX_RENDERBUFFER_SIZE",34041:"DEPTH_STENCIL",34042:"UNSIGNED_INT_24_8",34045:"MAX_TEXTURE_LOD_BIAS",34055:"INCR_WRAP",34056:"DECR_WRAP",34067:"TEXTURE_CUBE_MAP",34068:"TEXTURE_BINDING_CUBE_MAP",34069:"TEXTURE_CUBE_MAP_POSITIVE_X",34070:"TEXTURE_CUBE_MAP_NEGATIVE_X",34071:"TEXTURE_CUBE_MAP_POSITIVE_Y",34072:"TEXTURE_CUBE_MAP_NEGATIVE_Y",34073:"TEXTURE_CUBE_MAP_POSITIVE_Z",34074:"TEXTURE_CUBE_MAP_NEGATIVE_Z",34076:"MAX_CUBE_MAP_TEXTURE_SIZE",34229:"VERTEX_ARRAY_BINDING",34338:"VERTEX_ATTRIB_ARRAY_ENABLED",34339:"VERTEX_ATTRIB_ARRAY_SIZE",34340:"VERTEX_ATTRIB_ARRAY_STRIDE",34341:"VERTEX_ATTRIB_ARRAY_TYPE",34342:"CURRENT_VERTEX_ATTRIB",34373:"VERTEX_ATTRIB_ARRAY_POINTER",34467:"COMPRESSED_TEXTURE_FORMATS",34660:"BUFFER_SIZE",34661:"BUFFER_USAGE",34816:"STENCIL_BACK_FUNC",34817:"STENCIL_BACK_FAIL",34818:"STENCIL_BACK_PASS_DEPTH_FAIL",34819:"STENCIL_BACK_PASS_DEPTH_PASS",34836:"RGBA32F",34837:"RGB32F",34842:"RGBA16F",34843:"RGB16F",34852:"MAX_DRAW_BUFFERS",34853:"DRAW_BUFFER0",34854:"DRAW_BUFFER1",34855:"DRAW_BUFFER2",34856:"DRAW_BUFFER3",34857:"DRAW_BUFFER4",34858:"DRAW_BUFFER5",34859:"DRAW_BUFFER6",34860:"DRAW_BUFFER7",34861:"DRAW_BUFFER8",34862:"DRAW_BUFFER9",34863:"DRAW_BUFFER10",34864:"DRAW_BUFFER11",34865:"DRAW_BUFFER12",34866:"DRAW_BUFFER13",34867:"DRAW_BUFFER14",34868:"DRAW_BUFFER15",34877:"BLEND_EQUATION_ALPHA",34892:"TEXTURE_COMPARE_MODE",34893:"TEXTURE_COMPARE_FUNC",34894:"COMPARE_REF_TO_TEXTURE",34917:"CURRENT_QUERY",34918:"QUERY_RESULT",34919:"QUERY_RESULT_AVAILABLE",34921:"MAX_VERTEX_ATTRIBS",34922:"VERTEX_ATTRIB_ARRAY_NORMALIZED",34930:"MAX_TEXTURE_IMAGE_UNITS",34962:"ARRAY_BUFFER",34963:"ELEMENT_ARRAY_BUFFER",34964:"ARRAY_BUFFER_BINDING",34965:"ELEMENT_ARRAY_BUFFER_BINDING",34975:"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",35040:"STREAM_DRAW",35041:"STREAM_READ",35042:"STREAM_COPY",35044:"STATIC_DRAW",35045:"STATIC_READ",35046:"STATIC_COPY",35048:"DYNAMIC_DRAW",35049:"DYNAMIC_READ",35050:"DYNAMIC_COPY",35051:"PIXEL_PACK_BUFFER",35052:"PIXEL_UNPACK_BUFFER",35053:"PIXEL_PACK_BUFFER_BINDING",35055:"PIXEL_UNPACK_BUFFER_BINDING",35056:"DEPTH24_STENCIL8",35069:"VERTEX_ATTRIB_ARRAY_INTEGER",35070:"VERTEX_ATTRIB_ARRAY_DIVISOR",35071:"MAX_ARRAY_TEXTURE_LAYERS",35076:"MIN_PROGRAM_TEXEL_OFFSET",35077:"MAX_PROGRAM_TEXEL_OFFSET",35097:"SAMPLER_BINDING",35345:"UNIFORM_BUFFER",35368:"UNIFORM_BUFFER_BINDING",35369:"UNIFORM_BUFFER_START",35370:"UNIFORM_BUFFER_SIZE",35371:"MAX_VERTEX_UNIFORM_BLOCKS",35373:"MAX_FRAGMENT_UNIFORM_BLOCKS",35374:"MAX_COMBINED_UNIFORM_BLOCKS",35375:"MAX_UNIFORM_BUFFER_BINDINGS",35376:"MAX_UNIFORM_BLOCK_SIZE",35377:"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",35379:"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",35380:"UNIFORM_BUFFER_OFFSET_ALIGNMENT",35382:"ACTIVE_UNIFORM_BLOCKS",35383:"UNIFORM_TYPE",35384:"UNIFORM_SIZE",35386:"UNIFORM_BLOCK_INDEX",35387:"UNIFORM_OFFSET",35388:"UNIFORM_ARRAY_STRIDE",35389:"UNIFORM_MATRIX_STRIDE",35390:"UNIFORM_IS_ROW_MAJOR",35391:"UNIFORM_BLOCK_BINDING",35392:"UNIFORM_BLOCK_DATA_SIZE",35394:"UNIFORM_BLOCK_ACTIVE_UNIFORMS",35395:"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",35396:"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",35398:"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",35632:"FRAGMENT_SHADER",35633:"VERTEX_SHADER",35657:"MAX_FRAGMENT_UNIFORM_COMPONENTS",35658:"MAX_VERTEX_UNIFORM_COMPONENTS",35659:"MAX_VARYING_COMPONENTS",35660:"MAX_VERTEX_TEXTURE_IMAGE_UNITS",35661:"MAX_COMBINED_TEXTURE_IMAGE_UNITS",35663:"SHADER_TYPE",35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35679:"SAMPLER_3D",35680:"SAMPLER_CUBE",35682:"SAMPLER_2D_SHADOW",35685:"FLOAT_MAT2x3",35686:"FLOAT_MAT2x4",35687:"FLOAT_MAT3x2",35688:"FLOAT_MAT3x4",35689:"FLOAT_MAT4x2",35690:"FLOAT_MAT4x3",35712:"DELETE_STATUS",35713:"COMPILE_STATUS",35714:"LINK_STATUS",35715:"VALIDATE_STATUS",35717:"ATTACHED_SHADERS",35718:"ACTIVE_UNIFORMS",35721:"ACTIVE_ATTRIBUTES",35723:"FRAGMENT_SHADER_DERIVATIVE_HINT",35724:"SHADING_LANGUAGE_VERSION",35725:"CURRENT_PROGRAM",35738:"IMPLEMENTATION_COLOR_READ_TYPE",35739:"IMPLEMENTATION_COLOR_READ_FORMAT",35863:"UNSIGNED_NORMALIZED",35866:"TEXTURE_2D_ARRAY",35869:"TEXTURE_BINDING_2D_ARRAY",35887:"ANY_SAMPLES_PASSED",35898:"R11F_G11F_B10F",35899:"UNSIGNED_INT_10F_11F_11F_REV",35901:"RGB9_E5",35902:"UNSIGNED_INT_5_9_9_9_REV",35904:"SRGB",35905:"SRGB8",35907:"SRGB8_ALPHA8",35967:"TRANSFORM_FEEDBACK_BUFFER_MODE",35968:"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",35971:"TRANSFORM_FEEDBACK_VARYINGS",35972:"TRANSFORM_FEEDBACK_BUFFER_START",35973:"TRANSFORM_FEEDBACK_BUFFER_SIZE",35976:"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",35977:"RASTERIZER_DISCARD",35978:"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",35979:"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",35980:"INTERLEAVED_ATTRIBS",35981:"SEPARATE_ATTRIBS",35982:"TRANSFORM_FEEDBACK_BUFFER",35983:"TRANSFORM_FEEDBACK_BUFFER_BINDING",36003:"STENCIL_BACK_REF",36004:"STENCIL_BACK_VALUE_MASK",36005:"STENCIL_BACK_WRITEMASK",36006:"FRAMEBUFFER_BINDING",36007:"RENDERBUFFER_BINDING",36008:"READ_FRAMEBUFFER",36009:"DRAW_FRAMEBUFFER",36010:"READ_FRAMEBUFFER_BINDING",36011:"RENDERBUFFER_SAMPLES",36012:"DEPTH_COMPONENT32F",36013:"DEPTH32F_STENCIL8",36048:"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",36049:"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",36050:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",36051:"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",36052:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",36053:"FRAMEBUFFER_COMPLETE",36054:"FRAMEBUFFER_INCOMPLETE_ATTACHMENT",36055:"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",36057:"FRAMEBUFFER_INCOMPLETE_DIMENSIONS",36061:"FRAMEBUFFER_UNSUPPORTED",36063:"MAX_COLOR_ATTACHMENTS",36064:"COLOR_ATTACHMENT0",36065:"COLOR_ATTACHMENT1",36066:"COLOR_ATTACHMENT2",36067:"COLOR_ATTACHMENT3",36068:"COLOR_ATTACHMENT4",36069:"COLOR_ATTACHMENT5",36070:"COLOR_ATTACHMENT6",36071:"COLOR_ATTACHMENT7",36072:"COLOR_ATTACHMENT8",36073:"COLOR_ATTACHMENT9",36074:"COLOR_ATTACHMENT10",36075:"COLOR_ATTACHMENT11",36076:"COLOR_ATTACHMENT12",36077:"COLOR_ATTACHMENT13",36078:"COLOR_ATTACHMENT14",36079:"COLOR_ATTACHMENT15",36096:"DEPTH_ATTACHMENT",36128:"STENCIL_ATTACHMENT",36160:"FRAMEBUFFER",36161:"RENDERBUFFER",36162:"RENDERBUFFER_WIDTH",36163:"RENDERBUFFER_HEIGHT",36164:"RENDERBUFFER_INTERNAL_FORMAT",36168:"STENCIL_INDEX8",36176:"RENDERBUFFER_RED_SIZE",36177:"RENDERBUFFER_GREEN_SIZE",36178:"RENDERBUFFER_BLUE_SIZE",36179:"RENDERBUFFER_ALPHA_SIZE",36180:"RENDERBUFFER_DEPTH_SIZE",36181:"RENDERBUFFER_STENCIL_SIZE",36182:"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",36183:"MAX_SAMPLES",36194:"RGB565",36202:"ANY_SAMPLES_PASSED_CONSERVATIVE",36203:"MAX_ELEMENT_INDEX",36208:"RGBA32UI",36209:"RGB32UI",36214:"RGBA16UI",36215:"RGB16UI",36220:"RGBA8UI",36221:"RGB8UI",36226:"RGBA32I",36227:"RGB32I",36232:"RGBA16I",36233:"RGB16I",36238:"RGBA8I",36239:"RGB8I",36244:"RED_INTEGER",36248:"RGB_INTEGER",36249:"RGBA_INTEGER",36255:"INT_2_10_10_10_REV",36269:"FLOAT_32_UNSIGNED_INT_24_8_REV",36289:"SAMPLER_2D_ARRAY",36292:"SAMPLER_2D_ARRAY_SHADOW",36293:"SAMPLER_CUBE_SHADOW",36294:"UNSIGNED_INT_VEC2",36295:"UNSIGNED_INT_VEC3",36296:"UNSIGNED_INT_VEC4",36298:"INT_SAMPLER_2D",36299:"INT_SAMPLER_3D",36300:"INT_SAMPLER_CUBE",36303:"INT_SAMPLER_2D_ARRAY",36306:"UNSIGNED_INT_SAMPLER_2D",36307:"UNSIGNED_INT_SAMPLER_3D",36308:"UNSIGNED_INT_SAMPLER_CUBE",36311:"UNSIGNED_INT_SAMPLER_2D_ARRAY",36336:"LOW_FLOAT",36337:"MEDIUM_FLOAT",36338:"HIGH_FLOAT",36339:"LOW_INT",36340:"MEDIUM_INT",36341:"HIGH_INT",36347:"MAX_VERTEX_UNIFORM_VECTORS",36348:"MAX_VARYING_VECTORS",36349:"MAX_FRAGMENT_UNIFORM_VECTORS",36386:"TRANSFORM_FEEDBACK",36387:"TRANSFORM_FEEDBACK_PAUSED",36388:"TRANSFORM_FEEDBACK_ACTIVE",36389:"TRANSFORM_FEEDBACK_BINDING",36662:"COPY_READ_BUFFER_BINDING",36663:"COPY_WRITE_BUFFER_BINDING",36756:"R8_SNORM",36757:"RG8_SNORM",36758:"RGB8_SNORM",36759:"RGBA8_SNORM",36764:"SIGNED_NORMALIZED",36975:"RGB10_A2UI",37137:"MAX_SERVER_WAIT_TIMEOUT",37138:"OBJECT_TYPE",37139:"SYNC_CONDITION",37140:"SYNC_STATUS",37141:"SYNC_FLAGS",37142:"SYNC_FENCE",37143:"SYNC_GPU_COMMANDS_COMPLETE",37144:"UNSIGNALED",37145:"SIGNALED",37146:"ALREADY_SIGNALED",37147:"TIMEOUT_EXPIRED",37148:"CONDITION_SATISFIED",37149:"WAIT_FAILED",37154:"MAX_VERTEX_OUTPUT_COMPONENTS",37157:"MAX_FRAGMENT_INPUT_COMPONENTS",37167:"TEXTURE_IMMUTABLE_FORMAT",37440:"UNPACK_FLIP_Y_WEBGL",37441:"UNPACK_PREMULTIPLY_ALPHA_WEBGL",37442:"CONTEXT_LOST_WEBGL",37443:"UNPACK_COLORSPACE_CONVERSION_WEBGL",37444:"BROWSER_DEFAULT_WEBGL",37447:"MAX_CLIENT_WAIT_TIMEOUT_WEBGL",4294967295:"INVALID_INDEX","-1":"TIMEOUT_IGNORED"};let h;const m=[0,0,0,1];function d(e,t){return Math.random()*(t-e)+e}function p(e,t,r){return e+r*(t-e)}function T(e){let t;switch(e){case"MAT2":case"VEC4":t=4;break;case"MAT3":t=9;break;case"MAT4":t=16;break;case"VEC3":t=3;break;case"VEC2":t=2;break;case"SCALAR":t=1}return t}function E(e,t){if(0===t.length)return[-1,-1,0];let r=-1;for(let n=t.length-1;n>=0;n--)if(e>=t[n].time){r=n;break}if(-1===r||r===t.length-1)return r<0&&(r=0),[r,r,0];{const s=t[r],a=t[r+1];return e=Math.max(s.time,Math.min(e,a.time)),[r,r+1,(n=s.time,i=a.time,(e-n)/(i-n))]}var n,i}const g=new Map;function x(e,t,r){const n=function(e){let t;switch(f[e]){case"BYTE":case"UNSIGNED_BYTE":t=1;break;case"SHORT":case"UNSIGNED_SHORT":t=2;break;case"UNSIGNED_INT":case"FLOAT":t=4}return t}(t.componentType),i=T(t.type),s=(r.byteOffset||0)+(t.byteOffset||0),a=r.byteStride,o=a*t.count/n,l=t.count*i;let c,u=o||l;switch(e.byteLength<u*n+s&&(u-=t.byteOffset),f[t.componentType]){case"BYTE":c=new Int8Array(e,s,u);break;case"UNSIGNED_BYTE":c=new Uint8Array(e,s,u);break;case"SHORT":c=new Int16Array(e,s,u);break;case"UNSIGNED_SHORT":c=new Uint16Array(e,s,u);break;case"UNSIGNED_INT":c=new Uint32Array(e,s,u);break;case"FLOAT":c=new Float32Array(e,s,u)}if(u!==l){const e=new c.constructor(l);let t=0;for(let r=0;r<e.length;r+=i){for(let n=0;n<i;n++)e[r+n]=c[t+n];t+=a/n}return e}return c}function v(e,t,r,n){let i;switch(f[t]){case"BYTE":i=new Int8Array(e,r,n);break;case"UNSIGNED_BYTE":i=new Uint8Array(e,r,n);break;case"SHORT":i=new Int16Array(e,r,n);break;case"UNSIGNED_SHORT":i=new Uint16Array(e,r,n);break;case"UNSIGNED_INT":i=new Uint32Array(e,r,n);break;case"FLOAT":i=new Float32Array(e,r,n)}return i}function R(e,t,r){const n=h.createShader(e);h.shaderSource(n,t),h.compileShader(n),h.attachShader(r,n);const i=h.getShaderInfoLog(n);if(i)throw new Error(i)}function b(e,t){const r=h.createProgram();if(R(h.VERTEX_SHADER,e,r),R(h.FRAGMENT_SHADER,t,r),h.linkProgram(r),h.validateProgram(r),!h.getProgramParameter(r,h.LINK_STATUS)){const e=h.getProgramInfoLog(r);throw new Error(`Could not compile WebGL program. ${e}`)}return r}function S(e,t){!function e(r){t(r),r.children&&r.children.forEach(e)}(e)}function _(e,r,i,s){const[a,l]=e,c=new t;c.setTranslate(new n([0,0,.05]));const u=new t(r);u.multiply(c);const f=u.multiplyVector4(new o([0,0,0,1]));f.elements[0]=(2*a/i-1)*f.elements[3],f.elements[1]=(-2*l/s+1)*f.elements[3];const h=u.invert().multiplyVector4(f);return[h.elements[0],h.elements[1]]}function A(e){const{aspect:r,zoom:n}=e;let i;if("perspective"===e.type&&e.perspective){const{yfov:n}=e.perspective;i=(new t).setPerspective(n,r,e.perspective.znear||1,e.perspective.zfar||2e6)}else"orthographic"===e.type&&e.orthographic&&(i=(new t).setOrtho(e.orthographic.xmag*n,e.orthographic.ymag*n,e.orthographic.znear,e.orthographic.zfar));return i}function U(e=0,t=0){return e+t}function P(e){return f[e]}function N(e){let t;switch(!0){case e instanceof Uint8Array:t=e=>e/255;break;case e instanceof Int8Array:t=e=>Math.max(e/127,-1);break;case e instanceof Uint16Array:t=e=>e/65535;break;case e instanceof Int16Array:t=e=>Math.max(e/32767,-1)}if(t){const r=new Float32Array(e.length);for(let n=0;n<e.length;n++)r[n]=t(e[n]);return r}return e}g.set(Int8Array,"BYTE"),g.set(Uint8Array,"UNSIGNED_BYTE"),g.set(Int16Array,"SHORT"),g.set(Uint16Array,"UNSIGNED_SHORT"),g.set(Uint32Array,"UNSIGNED_INT"),g.set(Float32Array,"FLOAT");class F extends u{geometry;material;program;defines;mode;frontFace;distance;visible;variants;uniformBindGroup1;pipeline;constructor(e,t){super(e,t),this.program=null,this.defines=null,this.mode=4,this.variants=[]}setDefines(e){this.defines=e}setBlend(e){this.material.blend=e}setMaterial(e){this.material=e}drawWebGPU(e,r,{stateBuffer:n,renderState:i,needUpdateView:s,needUpdateProjection:a,camera:o,light:l}){const{isprerefraction:c}=i;if(!this.material.transmissionFactor||!c){if(this.reflow){const r=new t(this.matrixWorld);r.invert().transpose(),this.geometry.uniformBuffer.updateWebGPU(e,"model",this.matrixWorld.elements),this.geometry.uniformBuffer.updateWebGPU(e,"normalMatrix",r.elements)}if(n.updateWebGPU(e,"isTone",0),s){this.geometry.uniformBuffer.updateWebGPU(e,"view",o.matrixWorldInvert.elements),this.geometry.uniformBuffer.updateWebGPU(e,"light",l.matrixWorldInvert.elements);const t=new Float32Array(3);t.set(l.getPosition(),0),this.material.materialUniformBuffer.updateWebGPU(e,"viewPos",o.getPosition()),this.material.lightPosBuffer.updateWebGPU(e,"lightPos",t)}if(a&&this.geometry.uniformBuffer.updateWebGPU(e,"projection",o.projection.elements),this instanceof I&&this.bones.some(e=>e.reflow)){const t=this.getJointMatrix(),r=new Float32Array(16*t.length);let n=0;for(const e of t)r.set(e.elements,0+16*n),n++;e.device.queue.writeBuffer(this.skinBuffer,0*Float32Array.BYTES_PER_ELEMENT,r.buffer,r.byteOffset,r.byteLength)}r.setBindGroup(0,this.uniformBindGroup1),r.setVertexBuffer(0,this.geometry.verticesWebGPUBuffer),this.geometry.indicesBuffer?(r.setIndexBuffer(this.geometry.indicesWebGPUBuffer,"uint32"),r.drawIndexed(this.geometry.indicesBuffer.length)):r.draw(this.geometry.attributes.POSITION.length/3,1,0,0)}}draw(e,{lights:r,camera:n,light:i,needUpdateView:s,needUpdateProjection:a,preDepthTexture:o,colorTexture:l,renderState:c,fakeDepth:u,isIBL:f,isDefaultLight:h}){const{isprepender:m,isprerefraction:d}=c;if(!this.material.transmissionFactor||!d){if(e.useProgram(this.program),e.bindVertexArray(this.geometry.VAO),e.bindBufferBase(e.UNIFORM_BUFFER,0,this.geometry.UBO),this.reflow){const r=new t(this.matrixWorld);r.invert().transpose(),this.geometry.uniformBuffer.update(e,"model",this.matrixWorld.elements),this.geometry.uniformBuffer.update(e,"normalMatrix",r.elements)}if(s&&(this.geometry.uniformBuffer.update(e,"view",n.matrixWorldInvert.elements),this.geometry.uniformBuffer.update(e,"light",i.matrixWorldInvert.elements)),a&&this.geometry.uniformBuffer.update(e,"projection",n.projection.elements),this.geometry.uniformBuffer.update(e,"isShadow",m?1:0),this instanceof I&&(e.bindBufferBase(e.UNIFORM_BUFFER,2,this.geometry.SKIN),this.bones.some(e=>e.reflow))){const t=this.getJointMatrix(),r=new Float32Array(16*t.length);let n=0;for(const e of t)r.set(e.elements,0+16*n),n++;e.bufferSubData(e.UNIFORM_BUFFER,0,r)}if(this.material.UBO&&(e.bindBufferBase(e.UNIFORM_BUFFER,1,this.material.UBO),s)){const t=new Float32Array(4*r.length);r.forEach((e,r)=>{t.set(e.getPosition(),4*r)}),this.material.materialUniformBuffer.update(e,"viewPos",n.getPosition()),e.bindBufferBase(e.UNIFORM_BUFFER,4,this.material.lightUBO2),this.material.lightPosBuffer.update(e,"lightPos",t)}this.material.lightUBO1&&(e.bindBufferBase(e.UNIFORM_BUFFER,3,this.material.lightUBO1),e.bindBufferBase(e.UNIFORM_BUFFER,4,this.material.lightUBO2),e.bindBufferBase(e.UNIFORM_BUFFER,5,this.material.lightUBO3),e.bindBufferBase(e.UNIFORM_BUFFER,6,this.material.lightUBO4)),this.material.matrices.length&&e.bindBufferBase(e.UNIFORM_BUFFER,8,this.material.lightUBO5),this.material.sphericalHarmonics&&e.bindBufferBase(e.UNIFORM_BUFFER,7,this.material.sphericalHarmonics),e.uniform1i(this.material.uniforms.depthTexture,o&&!m?o.index:u.index),e.uniform1i(this.material.uniforms.colorTexture,d?u.index:l.index),e.uniform2f(e.getUniformLocation(this.program,"isTone"),d?0:1,0),e.uniform2f(e.getUniformLocation(this.program,"isIBL"),f?1:0,0),e.uniform2f(e.getUniformLocation(this.program,"isDefaultLight"),h||r.some(e=>!e.isInitial)?1:0,0),this.material.baseColorTexture&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.material.baseColorTexture),e.bindSampler(0,this.material.baseColorTexture.sampler)),this.material.metallicRoughnessTexture&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this.material.metallicRoughnessTexture),e.bindSampler(1,this.material.metallicRoughnessTexture.sampler)),this.material.normalTexture&&(e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,this.material.normalTexture),e.bindSampler(2,this.material.normalTexture.sampler)),this.material.occlusionTexture&&(e.activeTexture(e.TEXTURE3),e.bindTexture(e.TEXTURE_2D,this.material.occlusionTexture),e.bindSampler(3,this.material.occlusionTexture.sampler)),this.material.emissiveTexture&&(e.activeTexture(e.TEXTURE4),e.bindTexture(e.TEXTURE_2D,this.material.emissiveTexture),e.bindSampler(4,this.material.emissiveTexture.sampler)),this.material.clearcoatTexture&&(e.activeTexture(e.TEXTURE8),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatTexture),e.bindSampler(8,this.material.clearcoatTexture.sampler)),this.material.clearcoatRoughnessTexture&&(e.activeTexture(e.TEXTURE9),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatRoughnessTexture),e.bindSampler(9,this.material.clearcoatRoughnessTexture.sampler)),this.material.sheenColorTexture&&(e.activeTexture(e.TEXTURE11),e.bindTexture(e.TEXTURE_2D,this.material.sheenColorTexture),e.bindSampler(11,this.material.sheenColorTexture.sampler)),this.material.sheenRoughnessTexture&&(e.activeTexture(e.TEXTURE12),e.bindTexture(e.TEXTURE_2D,this.material.sheenRoughnessTexture),e.bindSampler(12,this.material.sheenRoughnessTexture.sampler)),this.material.iridescenceThicknessTexture&&(e.activeTexture(e.TEXTURE17),e.bindTexture(e.TEXTURE_2D,this.material.iridescenceThicknessTexture),e.bindSampler(17,this.material.iridescenceThicknessTexture.sampler)),this.material.diffuseTransmissionTexture&&(e.activeTexture(e.TEXTURE20),e.bindTexture(e.TEXTURE_2D,this.material.diffuseTransmissionTexture),e.bindSampler(20,this.material.diffuseTransmissionTexture.sampler)),this.material.diffuseTransmissionColorTexture&&(e.activeTexture(e.TEXTURE21),e.bindTexture(e.TEXTURE_2D,this.material.diffuseTransmissionColorTexture),e.bindSampler(21,this.material.diffuseTransmissionColorTexture.sampler)),this.material.anisotropyTexture&&(e.activeTexture(e.TEXTURE22),e.bindTexture(e.TEXTURE_2D,this.material.anisotropyTexture),e.bindSampler(22,this.material.anisotropyTexture.sampler)),this.material.clearcoatNormalTexture&&(e.activeTexture(e.TEXTURE10),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatNormalTexture),e.bindSampler(10,this.material.clearcoatNormalTexture.sampler)),this.material.transmissionTexture&&(e.activeTexture(e.TEXTURE14),e.bindTexture(e.TEXTURE_2D,this.material.transmissionTexture),e.bindSampler(14,this.material.transmissionTexture.sampler)),this.material.specularTexture&&(e.activeTexture(e.TEXTURE15),e.bindTexture(e.TEXTURE_2D,this.material.specularTexture),e.bindSampler(15,this.material.specularTexture.sampler)),this.material.specularColorTexture&&(e.activeTexture(e.TEXTURE19),e.bindTexture(e.TEXTURE_2D,this.material.specularColorTexture),e.bindSampler(19,this.material.specularColorTexture.sampler)),this.material.thicknessTexture&&(e.activeTexture(e.TEXTURE16),e.bindTexture(e.TEXTURE_2D,this.material.thicknessTexture),e.bindSampler(16,this.material.thicknessTexture.sampler)),this.material.doubleSided&&e.disable(e.CULL_FACE),this.frontFace&&e.frontFace(e.CW),this.geometry.indicesBuffer?e.drawElements(this.mode,this.geometry.indicesBuffer.length,e[g.get(this.geometry.indicesBuffer.constructor)],0):e.drawArrays(this.mode,0,this.geometry.attributes.POSITION.length/3),this.material.doubleSided&&e.enable(e.CULL_FACE),this.frontFace&&e.frontFace(e.CCW)}}setGeometry(e){this.geometry=e}setProgram(e){this.program=e}setMode(e=4){this.mode=e}setVariants(e){this.variants=e}setFrontFace(){this.frontFace=!0}isVisible(e){const t=new n(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld),r=this.geometry.boundingSphere.radius*this.matrixWorld.getMaxScaleOnAxis();let i,s=!0;for(const n of e)if(i=n.elements[0]*t.elements[0]+n.elements[1]*t.elements[1]+n.elements[2]*t.elements[2]+n.elements[3],i<-r){s=!1;break}return this.distance=i+r,s}calculateBounding(){this.geometry.calculateBounding(this.matrixWorld)}}class I extends F{bones;boneInverses;skin;skinBuffer;constructor(e,t){super(e,t)}setSkinWebGPU(e,t){this.bones=t.bones,this.boneInverses=t.boneInverses;const r=this.getJointMatrix(),n=new Float32Array(16*r.length);let i=0;for(const e of r)n.set(e.elements,0+16*i),i++;const s=n.byteLength,a=256+s,{device:o}=e,l=o.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.skinBuffer=l;const c={binding:22,resource:{buffer:l,offset:0,size:s}};return o.queue.writeBuffer(l,0,n.buffer,n.byteOffset,n.byteLength),c}setSkin(e,t){this.bones=t.bones,this.boneInverses=t.boneInverses;const r=this.getJointMatrix(),n=new Float32Array(16*r.length);let i=0;for(const e of r)n.set(e.elements,0+16*i),i++;const s=e.getUniformBlockIndex(this.program,"Skin");e.uniformBlockBinding(this.program,s,2);const a=e.createBuffer();return e.bindBuffer(e.UNIFORM_BUFFER,a),e.bufferData(e.UNIFORM_BUFFER,n,e.DYNAMIC_DRAW),this.geometry.SKIN=a,e.bindBuffer(e.UNIFORM_BUFFER,null),this}getJointMatrix(){const e=new t(this.matrixWorld).invert(),r=[];for(let n=0;n<this.boneInverses.length;n++){const i=(new t).multiply(e).multiply(this.bones[n].matrixWorld).multiply(this.boneInverses[n]);r.push(i)}return r}}class M extends u{}class C extends u{isInitial;props;matrixWorldInvert;projection;modelSize;modelXSize;modelYSize;yaw;pitch;matrixInitial;rotation;constructor(e,r,n){super(r,n),this.matrixWorldInvert=new t,this.projection=new t,this.props=e,this.yaw=0,this.pitch=-Math.PI,this.rotation=new t}setProjection(e){this.projection.set(e.elements)}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld),this.matrixInitial||(this.matrixInitial=new t(this.matrixWorld))}setZ(e){this.matrix.elements[14]=e,this.matrixInitial=new t(this.matrix),this.setMatrixWorld(this.matrix.elements)}getViewProjMatrix(){const e=new t;return e.multiply(this.projection),e.multiply(this.matrixWorldInvert),e}pan(e,r,i,s){const a=_(e,this.projection,i,s),o=_(r,this.projection,i,s),l=new n([...a,0]),c=new n([...o,0]);if("orthographic"===this.props.type){const e=2*this.matrixWorld.elements[14],t=l.subtract(c).scale(e);this.matrixInitial.translate(t.elements[0],t.elements[1],0)}else{const e=10*this.matrixWorld.elements[14],t=c.subtract(l).scale(e);this.matrixInitial.translate(t.elements[0],t.elements[1],0)}const u=new t(this.rotation);u.multiply(this.matrixInitial),this.setMatrixWorld(u.elements)}rotate(e,r){var i,s,a;this.yaw+=.01*(e[0]-r[0]),this.pitch+=.01*(e[1]-r[1]),this.pitch=(i=this.pitch,s=-1.5*Math.PI,a=-.5*Math.PI,i<s?s:i>a?a:i);const o=new t;o.rotate(new n([1,0,0]),this.pitch),o.rotate(new n([0,1,0]),-this.yaw),o.rotate(new n([1,0,0]),Math.PI),this.rotation=o;const l=new t(o);l.multiply(this.matrixInitial),this.setMatrixWorld(l.elements)}zoom(e){if(this.matrixInitial.elements[14]>5*this.modelSize&&e>0)return;this.matrixInitial.elements[14]+=e*this.modelSize*.001;const r=new t(this.rotation);r.multiply(this.matrixInitial),this.setMatrixWorld(r.elements),this.updateNF()}updateNF(){if(this.props.isInitial){const e=Math.min(...this.matrixWorld.getScaling().elements),t=this.modelSize/e,r=Math.abs(this.matrixWorldInvert.elements[14]),n=this.props.perspective||this.props.orthographic;n.znear=Math.max(r-t,.05*t),n.zfar=r+t}this.setProjection(A(this.props))}}class L extends u{matrixWorldInvert;type;color;intensity;isInitial;spot;constructor(e,r,i){super(r,i);const{type:s,color:a=[1,1,1],intensity:o,isInitial:l,spot:c={}}=e;this.type=s,this.color=new n(a),this.intensity=o,this.isInitial=l,this.spot=c,this.matrixWorldInvert=new t}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld)}setZ(e){this.matrix.elements[13]=e,this.matrix.elements[14]=e,this.setMatrixWorld(this.matrix.elements)}update(e){if(this.isInitial||"directional"===this.type){const r=new t;r.makeRotationAxis(new n([0,1,0]),e),r.multiply(this.matrix),this.setMatrixWorld(r.elements)}}}class O{offset;map;tempStore;store;bufferWebGPU;constructor(){this.map=new Map,this.tempStore={},this.offset=0}getBuffer(e){const{length:t}=e;return 3===t?new Float32Array([e[0],e[1],e[2],0]):9===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0]):12===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,e[9],e[10],e[11],0]):6===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0]):e}add(e,t){void 0===t.length&&(t=[t]),this.map.set(e,this.offset);const r=this.getBuffer(t);this.tempStore[e]=r,this.offset+=Math.max(r.length,4)}update(e,t,r){void 0===r.length&&(r=new Float32Array([r]));const n=this.map.get(t),i=this.getBuffer(r);this.store.set(i,n),e.bufferSubData(e.UNIFORM_BUFFER,n*Float32Array.BYTES_PER_ELEMENT,i)}updateWebGPU(e,t,r){const{device:n}=e;void 0===r.length&&(r=new Float32Array([r]));const i=this.map.get(t),s=this.getBuffer(r);this.store.set(s,i),n.queue.writeBuffer(this.bufferWebGPU,i*Float32Array.BYTES_PER_ELEMENT,s.buffer,s.byteOffset,s.byteLength)}done(){this.store=new Float32Array(this.offset);for(const[e,t]of this.map)this.store.set(this.tempStore[e],t);this.tempStore=null}}class y{name;extensions;extras;pbrMetallicRoughness;normalTexture;occlusionTexture;emissiveTexture;emissiveFactor;alphaMode;alphaCutoff;doubleSided}const B={baseColorFactor:[1,0,0,1]},w={directional:0,point:1,spot:2};class D extends y{blend;uniforms;alpha;UBO;defines;matrices;uniformBuffer;lightUBO1;lightUniformBuffer1;lightUBO2;lightUniformBuffer2;lightUBO3;lightUniformBuffer3;lightUBO4;lightUBO5;lightUniformBuffer4;uniformBindGroup1;constructor(e=B,t,r,n){super();const i=Object.assign({},e);if(this.defines=r,this.name=i.name,this.matrices=[],this.diffuseTransmissionColorFactor=[1,1,1],!i.pbrMetallicRoughness&&i.extensions&&i.extensions.KHR_materials_pbrSpecularGlossiness){i.pbrMetallicRoughness={};const e=i.extensions.KHR_materials_pbrSpecularGlossiness;i.pbrMetallicRoughness.baseColorTexture=e.diffuseTexture,i.pbrMetallicRoughness.metallicRoughnessTexture=e.specularGlossinessTexture,i.pbrMetallicRoughness.baseColorFactor=e.diffuseFactor,i.pbrMetallicRoughness.specularFactor=e.specularFactor,i.pbrMetallicRoughness.glossinessFactor=e.glossinessFactor,r.push({name:"SPECULARGLOSSINESSMAP"})}if(i.extensions&&i.extensions.KHR_materials_clearcoat){const e=i.extensions.KHR_materials_clearcoat;if(this.clearcoatFactor=e.clearcoatFactor,this.clearcoatRoughnessFactor=e.clearcoatRoughnessFactor,r.push({name:"CLEARCOAT"}),e.clearcoatTexture){const{extensions:n,texCoord:i}=e.clearcoatTexture;if(this.clearcoatTexture=t[e.clearcoatTexture.index],r.push({name:"CLEARCOATMAP",value:i?2:1}),n){const e=n.KHR_texture_transform;e&&this.buildTrans(e,r,"CLEARCOATMAP")}}if(e.clearcoatNormalTexture){const{extensions:n,texCoord:i}=e.clearcoatNormalTexture;if(this.clearcoatNormalTexture=t[e.clearcoatNormalTexture.index],r.push({name:"CLEARCOATNORMALMAP",value:i?2:1}),n){const e=n.KHR_texture_transform;e&&this.buildTrans(e,r,"CLEARCOATNORMALMAP")}}if(e.clearcoatRoughnessTexture){const{extensions:n,texCoord:i}=e.clearcoatRoughnessTexture;if(this.clearcoatRoughnessTexture=t[e.clearcoatRoughnessTexture.index],r.push({name:"CLEARCOATROUGHMAP",value:i?2:1}),n){const e=n.KHR_texture_transform;e&&this.buildTrans(e,r,"CLEARCOATROUGHMAP")}}}if(i.extensions&&i.extensions.KHR_materials_sheen){const{sheenColorTexture:e,sheenColorFactor:n,sheenRoughnessFactor:s,sheenRoughnessTexture:a}=i.extensions.KHR_materials_sheen;if(this.sheenColorFactor=n,this.sheenRoughnessFactor=s,e){const{extensions:n,texCoord:i}=e;if(this.sheenColorTexture=t[e.index],r.push({name:"SHEENMAP",value:i?2:1}),n){const e=n.KHR_texture_transform;e&&this.buildTrans(e,r,"SHEENMAP")}}if(a){const{extensions:e,texCoord:n}=a;if(this.sheenRoughnessTexture=t[a.index],r.push({name:"SHEENROUGHNESSMAP",value:n?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,r,"SHEENROUGHNESSMAP")}}r.push({name:"SHEEN"})}if(i.extensions&&i.extensions.KHR_materials_transmission){const{transmissionFactor:e,transmissionTexture:n}=i.extensions.KHR_materials_transmission;this.transmissionFactor=e,n&&(this.transmissionTexture=t[n.index],r.push({name:"TRANSMISSIONMAP"})),r.push({name:"TRANSMISSION"})}if(i.extensions&&i.extensions.KHR_materials_volume){const{attenuationColor:e,attenuationDistance:n,thicknessFactor:s,thicknessTexture:a}=i.extensions.KHR_materials_volume;this.attenuationColor=e,this.attenuationDistance=n,this.thicknessFactor=s,this.ior=1.5,a&&(this.thicknessTexture=t[a.index],r.push({name:"THICKNESSMAP"})),r.push({name:"VOLUME"})}if(i.extensions&&i.extensions.KHR_materials_emissive_strength){const{emissiveStrength:e}=i.extensions.KHR_materials_emissive_strength;this.emissiveStrength=e}if(i.extensions&&i.extensions.KHR_materials_anisotropy){const{anisotropyStrength:e,anisotropyRotation:n,anisotropyTexture:s}=i.extensions.KHR_materials_anisotropy;this.anisotropyStrength=e,this.anisotropyRotation=n,s&&(this.anisotropyTexture=t[s.index],r.push({name:"ANISOTROPYMAP",value:s.texCoord?2:1})),r.push({name:"ANISOTROPY"})}if(i.extensions&&i.extensions.KHR_materials_dispersion){const{dispersion:e}=i.extensions.KHR_materials_dispersion;this.dispersion=e,r.push({name:"DISPERSION"})}if(i.extensions&&i.extensions.KHR_materials_iridescence){const{iridescenceTexture:e,iridescenceThicknessTexture:n,iridescenceFactor:s,iridescenceIor:a,iridescenceThicknessMaximum:o,iridescenceThicknessMinimum:l}=i.extensions.KHR_materials_iridescence;this.iridescenceFactor=s,this.iridescenceIOR=a,this.iridescenceThicknessMaximum=o,this.iridescenceThicknessMinimum=l,e&&(this.iridescenceTexture=t[e.index]),n&&(this.iridescenceThicknessTexture=t[n.index],r.push({name:"IRIDESCENCEMAP",value:n.texCoord?2:1})),r.push({name:"IRIDESCENCE"})}if(i.extensions&&i.extensions.KHR_materials_diffuse_transmission){const{diffuseTransmissionFactor:e,diffuseTransmissionTexture:n,diffuseTransmissionColorFactor:s,diffuseTransmissionColorTexture:a}=i.extensions.KHR_materials_diffuse_transmission;this.diffuseTransmissionFactor=e,n&&(this.diffuseTransmissionTexture=t[n.index],r.push({name:"DIFFUSE_TRANSMISSION_MAP",value:n.texCoord?2:1})),this.diffuseTransmissionColorFactor=s??[1,1,1],a&&(this.diffuseTransmissionColorTexture=t[a.index],r.push({name:"DIFFUSE_TRANSMISSION_COLOR_MAP",value:a.texCoord?2:1})),r.push({name:"DIFFUSE_TRANSMISSION"})}if(i.extensions&&i.extensions.KHR_materials_ior&&(this.ior=i.extensions.KHR_materials_ior.ior,r.push({name:"IOR"})),i.extensions&&i.extensions.KHR_materials_specular){const{specularFactor:e,specularTexture:n,specularColorFactor:s,specularColorTexture:a}=i.extensions.KHR_materials_specular;this.specularFactor=e,this.specularColorFactor=s,n&&(this.specularTexture=t[n.index],r.push({name:"SPECULARMAP"})),a&&(this.specularColorTexture=t[a.index],r.push({name:"SPECULARCOLORMAP"})),r.push({name:"SPECULAR"})}this.uniforms={baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,clearcoatTexture:null,clearcoatRoughnessTexture:null,sheenRoughnessTexture:null,iridescenceThicknessTexture:null,sheenColorTexture:null,clearcoatNormalTexture:null,emissiveTexture:null,prefilterMap:null,charlieMap:null,brdfLUT:null,irradianceMap:null,transmissionTexture:null,specularTexture:null,specularColorTexture:null,thicknessTexture:null,colorTexture:null,Sheen_E:null,depthTexture:null,diffuseTransmissionTexture:null,diffuseTransmissionColorTexture:null,anisotropyTexture:null};const{pbrMetallicRoughness:s}=i;if(s&&(this.baseColorFactor=s.baseColorFactor,this.roughnessFactor=s.roughnessFactor,this.metallicFactor=s.metallicFactor,s.specularFactor&&(this.specularFactor=s.specularFactor),s.glossinessFactor&&(this.glossinessFactor=s.glossinessFactor)),this.alpha="BLEND"===i.alphaMode,this.doubleSided=i.doubleSided,this.emissiveFactor=i.emissiveFactor,this.extras=i.extras,s&&s.metallicRoughnessTexture){const{extensions:e,texCoord:n}=s.metallicRoughnessTexture;if(this.metallicRoughnessTexture=t[s.metallicRoughnessTexture.index],r.push({name:"METALROUGHNESSMAP",value:n?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,r,"METALROUGHNESSMAP")}}if(i.normalTexture){const{extensions:e,texCoord:n,scale:s}=i.normalTexture;if(this.normalTexture=t[i.normalTexture.index],this.normalTextureScale=s,r.push({name:"NORMALMAP",value:n?2:1}),e){const t=e.KHR_texture_transform;t&&(this.normalTextureScale=void 0,this.buildTrans(t,r,"NORMALMAP"))}}if(i.occlusionTexture){const{extensions:e,texCoord:n}=i.occlusionTexture;if(this.occlusionTexture=t[i.occlusionTexture.index],r.push({name:"OCCLUSIONMAP",value:n?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,r,"OCCLUSIONMAP")}}if(s&&s.baseColorTexture){const{extensions:e,texCoord:n}=s.baseColorTexture;if(this.baseColorTexture=t[s.baseColorTexture.index],r.push({name:"BASECOLORTEXTURE",value:n?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,r,"BASECOLORTEXTURE")}}if(i.emissiveTexture){const{extensions:e,texCoord:n}=i.emissiveTexture;if(this.emissiveTexture=t[i.emissiveTexture.index],r.push({name:"EMISSIVEMAP",value:n?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,r,"EMISSIVEMAP")}}"MASK"===i.alphaMode?r.push({name:"ALPHATEST",value:i.alphaCutoff??.5}):"BLEND"===i.alphaMode&&r.push({name:"ALPHATEST",value:.01}),this.doubleSided&&r.push({name:"DOUBLESIDED"}),i.extensions&&i.extensions.KHR_materials_unlit&&r.push({name:"NOLIGHT"}),this.matrices.length&&r.push({name:"MATRICES",value:this.matrices.length})}buildTrans(e,r,n=""){if(e.offset||e.scale||e.rotation){const i=e.offset||[0,0],s=e.scale||[1,1],a=e.rotation||0;r.push({name:`${n}_TEXTURE_TRANSFORM`,value:this.matrices.push((new t).set([...i,0,0,...s,0,0,a,0,0,0,0,0,0,0]))-1})}}setHarmonics(e){this.sphericalHarmonics=e}updateUniformsWebgl(e,t){e.useProgram(t),this.baseColorTexture&&(this.uniforms.baseColorTexture=e.getUniformLocation(t,"baseColorTexture"),e.uniform1i(this.uniforms.baseColorTexture,0)),this.metallicRoughnessTexture&&(this.uniforms.metallicRoughnessTexture=e.getUniformLocation(t,"metallicRoughnessTexture"),e.uniform1i(this.uniforms.metallicRoughnessTexture,1)),this.normalTexture&&(this.uniforms.normalTexture=e.getUniformLocation(t,"normalTexture"),e.uniform1i(this.uniforms.normalTexture,2)),this.occlusionTexture&&(this.uniforms.occlusionTexture=e.getUniformLocation(t,"occlusionTexture"),e.uniform1i(this.uniforms.occlusionTexture,3)),this.emissiveTexture&&(this.uniforms.emissiveTexture=e.getUniformLocation(t,"emissiveTexture"),e.uniform1i(this.uniforms.emissiveTexture,4)),this.clearcoatTexture&&(this.uniforms.clearcoatTexture=e.getUniformLocation(t,"clearcoatTexture"),e.uniform1i(this.uniforms.clearcoatTexture,8)),this.clearcoatRoughnessTexture&&(this.uniforms.clearcoatRoughnessTexture=e.getUniformLocation(t,"clearcoatRoughnessTexture"),e.uniform1i(this.uniforms.clearcoatRoughnessTexture,9)),this.clearcoatNormalTexture&&(this.uniforms.clearcoatNormalTexture=e.getUniformLocation(t,"clearcoatNormalTexture"),e.uniform1i(this.uniforms.clearcoatNormalTexture,10)),this.sheenRoughnessTexture&&(this.uniforms.sheenRoughnessTexture=e.getUniformLocation(t,"sheenRoughnessTexture"),e.uniform1i(this.uniforms.sheenRoughnessTexture,12)),this.iridescenceThicknessTexture&&(this.uniforms.iridescenceThicknessTexture=e.getUniformLocation(t,"iridescenceThicknessTexture"),e.uniform1i(this.uniforms.iridescenceThicknessTexture,17)),this.anisotropyTexture&&(this.uniforms.anisotropyTexture=e.getUniformLocation(t,"anisotropyTexture"),e.uniform1i(this.uniforms.anisotropyTexture,22)),this.diffuseTransmissionColorTexture&&(this.uniforms.diffuseTransmissionColorTexture=e.getUniformLocation(t,"diffuseTransmissionColorTexture"),e.uniform1i(this.uniforms.diffuseTransmissionColorTexture,21)),this.diffuseTransmissionTexture&&(this.uniforms.diffuseTransmissionTexture=e.getUniformLocation(t,"diffuseTransmissionTexture"),e.uniform1i(this.uniforms.diffuseTransmissionTexture,20)),this.sheenColorTexture&&(this.uniforms.sheenColorTexture=e.getUniformLocation(t,"sheenColorTexture"),e.uniform1i(this.uniforms.sheenColorTexture,11)),this.transmissionTexture&&(this.uniforms.transmissionTexture=e.getUniformLocation(t,"transmissionTexture"),e.uniform1i(this.uniforms.transmissionTexture,14)),this.specularTexture&&(this.uniforms.specularTexture=e.getUniformLocation(t,"specularTexture"),e.uniform1i(this.uniforms.specularTexture,15)),this.specularColorTexture&&(this.uniforms.specularColorTexture=e.getUniformLocation(t,"specularColorTexture"),e.uniform1i(this.uniforms.specularColorTexture,19)),this.thicknessTexture&&(this.uniforms.thicknessTexture=e.getUniformLocation(t,"thicknessTexture"),e.uniform1i(this.uniforms.thicknessTexture,16)),this.uniforms.prefilterMap=e.getUniformLocation(t,"prefilterMap"),this.uniforms.charlieMap=e.getUniformLocation(t,"charlieMap"),this.uniforms.brdfLUT=e.getUniformLocation(t,"brdfLUT"),this.uniforms.irradianceMap=e.getUniformLocation(t,"irradianceMap"),this.uniforms.depthTexture=e.getUniformLocation(t,"depthTexture"),this.uniforms.colorTexture=e.getUniformLocation(t,"colorTexture"),this.uniforms.Sheen_E=e.getUniformLocation(t,"Sheen_E"),e.uniform1i(this.uniforms.prefilterMap,6),e.uniform1i(this.uniforms.charlieMap,18),e.uniform1i(this.uniforms.brdfLUT,7),e.uniform1i(this.uniforms.irradianceMap,5),e.uniform1i(this.uniforms.Sheen_E,13);{const r=e.getUniformBlockIndex(t,"Material");e.uniformBlockBinding(t,r,1);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.materialUniformBuffer.store,e.STATIC_DRAW),this.UBO=n}{const r=e.getUniformBlockIndex(t,"LightColor");e.uniformBlockBinding(t,r,3);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.lightColorBuffer.store,e.STATIC_DRAW),this.lightUBO1=n}{const r=e.getUniformBlockIndex(t,"LightPos");e.uniformBlockBinding(t,r,4);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.lightPosBuffer.store,e.STATIC_DRAW),this.lightUBO2=n}{const r=e.getUniformBlockIndex(t,"Spotdir");e.uniformBlockBinding(t,r,5);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.spotdirBuffer.store,e.STATIC_DRAW),this.lightUBO3=n}{const r=e.getUniformBlockIndex(t,"LightIntensity");e.uniformBlockBinding(t,r,6);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.lightIntensityBuffer.store,e.STATIC_DRAW),this.lightUBO4=n}if(this.matrices.length){const r=e.getUniformBlockIndex(t,"TextureMatrices");e.uniformBlockBinding(t,r,8);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.textureMatricesBuffer.store,e.STATIC_DRAW),this.lightUBO5=n}}createUniforms(e,t){const r=new Float32Array(4*t.length),i=new Float32Array(4*t.length),s=new Float32Array(4*t.length),a=new Float32Array(4*t.length),o=new Float32Array(16*this.matrices.length);t.forEach((e,t)=>{r.set(new n([e.matrixWorld.elements[8],e.matrixWorld.elements[9],e.matrixWorld.elements[10]]).normalize().elements,4*t),i.set(e.getPosition(),4*t),s.set(e.color.elements,4*t),a.set([e.intensity,e.spot.innerConeAngle??0,e.spot.outerConeAngle??0,w[e.type]],4*t)}),this.matrices.forEach((e,t)=>{o.set(e.elements,16*t)});{const t=new O;t.add("baseColorFactor",this.baseColorFactor??[.8,.8,.8,1]),t.add("viewPos",e.getPosition()),t.add("specularFactor",this.specularFactor??1),t.add("specularColorFactor",this.specularColorFactor??[1,1,1]),t.add("emissiveFactor",this.emissiveFactor??[0,0,0]),t.add("glossinessFactor",this.glossinessFactor??.5),t.add("metallicFactor",this.metallicFactor??1),t.add("roughnessFactor",this.roughnessFactor??1),t.add("clearcoatFactor",this.clearcoatFactor??0),t.add("clearcoatRoughnessFactor",this.clearcoatRoughnessFactor??0),t.add("sheenColorFactor",this.sheenColorFactor??0),t.add("sheenRoughnessFactor",this.sheenRoughnessFactor??0),t.add("transmissionFactor",this.transmissionFactor??0),t.add("ior",this.ior??1),t.add("normalTextureScale",this.normalTextureScale??1),t.add("attenuationColor",this.attenuationColor??[1,1,1]),t.add("attenuationDistance",this.attenuationDistance??1),t.add("thicknessFactor",this.thicknessFactor??0),t.add("emissiveStrength",this.emissiveStrength??1),t.add("anisotropy",[this.anisotropyStrength??0,this.anisotropyRotation??0]),t.add("iridescence",[this.iridescenceFactor??0,this.iridescenceIOR??1.3,this.iridescenceThicknessMaximum??400,this.iridescenceThicknessMinimum??100]),t.add("diffuseTransmissionFactor",[this.diffuseTransmissionFactor??0,...this.diffuseTransmissionColorFactor]),t.add("dispersionFactor",[this.dispersion??0]),t.done(),this.materialUniformBuffer=t}{const e=new O;e.add("lightColor",s),e.done(),this.lightColorBuffer=e}{const e=new O;e.add("lightPos",i),e.done(),this.lightPosBuffer=e}{const e=new O;e.add("spotdir",r),e.done(),this.spotdirBuffer=e}{const e=new O;e.add("lightIntensity",a),e.done(),this.lightIntensityBuffer=e}if(this.matrices.length){const e=new O;e.add("textureMatrices",o),e.done(),this.textureMatricesBuffer=e}}updateUniformsWebGPU(e){const{device:t}=e,r=t.createBuffer({size:256+this.materialUniformBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.materialUniformBuffer.bufferWebGPU=r;const n=t.createBuffer({size:256+this.lightColorBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=t.createBuffer({size:256+this.lightPosBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.lightPosBuffer.bufferWebGPU=i;const s=t.createBuffer({size:256+this.spotdirBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a=t.createBuffer({size:256+this.lightIntensityBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});let o;this.textureMatricesBuffer&&(o=t.createBuffer({size:256+this.textureMatricesBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}));const l=this.baseColorTexture?this.baseColorTexture.sampler:t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"repeat",addressModeV:"repeat",addressModeW:"repeat"}),c=[{binding:1,resource:{buffer:r,offset:0,size:this.materialUniformBuffer.store.byteLength}},{binding:2,resource:l},{binding:24,resource:t.createSampler({magFilter:"linear"})},{binding:3,resource:this.baseColorTexture?.createView()},{binding:4,resource:this.metallicRoughnessTexture?.createView()},{binding:5,resource:this.normalTexture?.createView()},{binding:6,resource:this.emissiveTexture?.createView()},{binding:7,resource:this.occlusionTexture?.createView()},{binding:8,resource:this.clearcoatTexture?.createView()},{binding:9,resource:this.clearcoatRoughnessTexture?.createView()},{binding:10,resource:this.transmissionTexture?.createView()},{binding:11,resource:this.sheenColorTexture?.createView()},{binding:12,resource:this.sheenRoughnessTexture?.createView()},{binding:13,resource:this.clearcoatNormalTexture?.createView()},{binding:14,resource:this.specularTexture?.createView()},{binding:15,resource:{buffer:n,offset:0,size:this.lightColorBuffer.store.byteLength}},{binding:16,resource:{buffer:i,offset:0,size:this.lightPosBuffer.store.byteLength}},{binding:17,resource:{buffer:s,offset:0,size:this.spotdirBuffer.store.byteLength}},{binding:18,resource:{buffer:a,offset:0,size:this.lightIntensityBuffer.store.byteLength}},{binding:29,resource:this.thicknessTexture?.createView()},{binding:31,resource:this.anisotropyTexture?.createView()},{binding:32,resource:this.iridescenceThicknessTexture?.createView()},{binding:33,resource:this.specularColorTexture?.createView()},{binding:34,resource:this.diffuseTransmissionTexture?.createView()},{binding:23,resource:this.textureMatricesBuffer&&{buffer:o,offset:0,size:this.textureMatricesBuffer.store.byteLength}}];t.queue.writeBuffer(r,0,this.materialUniformBuffer.store.buffer,this.materialUniformBuffer.store.byteOffset,this.materialUniformBuffer.store.byteLength),t.queue.writeBuffer(n,0,this.lightColorBuffer.store.buffer,this.lightColorBuffer.store.byteOffset,this.lightColorBuffer.store.byteLength),t.queue.writeBuffer(i,0,this.lightPosBuffer.store.buffer,this.lightPosBuffer.store.byteOffset,this.lightPosBuffer.store.byteLength),t.queue.writeBuffer(s,0,this.spotdirBuffer.store.buffer,this.spotdirBuffer.store.byteOffset,this.spotdirBuffer.store.byteLength),t.queue.writeBuffer(a,0,this.lightIntensityBuffer.store.buffer,this.lightIntensityBuffer.store.byteOffset,this.lightIntensityBuffer.store.byteLength),this.textureMatricesBuffer&&t.queue.writeBuffer(o,0,this.textureMatricesBuffer.store.buffer,this.textureMatricesBuffer.store.byteOffset,this.textureMatricesBuffer.store.byteLength),this.uniformBindGroup1=c.filter(e=>e.resource)}hasNormal(){return Boolean(this.normalTexture)||Boolean(this.clearcoatNormalTexture)}setColor(e,t,r){e.bindBufferBase(e.UNIFORM_BUFFER,1,this.UBO),this.materialUniformBuffer.update(e,t,r.elements)}}class G{redraw;isPan;isDrag;x;y;constructor(e,t){this.redraw=t,document.addEventListener("wheel",this,{passive:!1}),e.addEventListener("mousedown",this),e.addEventListener("mousemove",this),e.addEventListener("mouseup",this),document.addEventListener("keyup",this),document.addEventListener("keydown",this),addEventListener("resize",this)}handleEvent(e){switch(e.type){case"wheel":this.zoom(e);break;case"mousedown":this.onStart(e);break;case"mousemove":this.onMove(e);break;case"mouseup":this.onEnd();break;case"keyup":this.onKeyUp();break;case"keydown":this.onKeyDown(e);break;case"resize":this.onResize()}}onResize(){this.redraw("resize")}onKeyDown(e){(e.shiftKey||e.ctrlKey)&&(this.isPan=!0)}onKeyUp(){this.isPan=!1}onStart(e){this.x=e.clientX,this.y=e.clientY,this.isDrag=!0}onMove(e){this.isDrag&&(this.isPan?this.redraw("pan",[this.x,this.y],[e.clientX,e.clientY]):this.redraw("rotate",[this.x,this.y],[e.clientX,e.clientY]),this.x=e.clientX,this.y=e.clientY)}onEnd(){this.isDrag=!1}zoom(e){e.preventDefault(),this.redraw("zoom",e.deltaY)}}var V=i(843),H=i.n(V);const X="#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 index;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n} uniforms;\r\n\r\n\r\nlayout (location = 0) out vec3 outUV;\r\n\r\nvoid main() {\r\n\toutUV = inPosition;\r\n    mat4 rotView = mat4(mat3(uniforms.view[int(uniforms.index.x)]));\r\n    gl_Position = uniforms.projection * rotView * vec4(inPosition, 1.0);\r\n}\r\n",z="#version 460\r\nlayout (location = 0) in vec2 pos;\r\n\r\nlayout (location = 0) out vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n",W=new Float32Array([-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1]),k=new Float32Array([-1,1,-1,-1,1,1,1,-1]),j=new Float32Array([-1,1,-1,-1,1,-1,1,-1,1,1,-1,1]),Y=i.p+"assets/Sheen_E.hdr",q=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))];class K{preScaled=!1;l00=new n;l1_1=new n;l10=new n;l11=new n;l2_2=new n;l2_1=new n;l20=new n;l21=new n;l22=new n;scaleInPlace(e){this.l00.scale(e),this.l1_1.scale(e),this.l10.scale(e),this.l11.scale(e),this.l2_2.scale(e),this.l2_1.scale(e),this.l20.scale(e),this.l21.scale(e),this.l22.scale(e)}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scale(q[0]),this.l1_1.scale(q[1]),this.l10.scale(q[2]),this.l11.scale(q[3]),this.l2_2.scale(q[4]),this.l2_1.scale(q[5]),this.l20.scale(q[6]),this.l21.scale(q[7]),this.l22.scale(q[8])}static FromArray(e){const t=new K;return n.FromArrayToRef(e[0],0,t.l00),n.FromArrayToRef(e[1],0,t.l1_1),n.FromArrayToRef(e[2],0,t.l10),n.FromArrayToRef(e[3],0,t.l11),n.FromArrayToRef(e[4],0,t.l2_2),n.FromArrayToRef(e[5],0,t.l2_1),n.FromArrayToRef(e[6],0,t.l20),n.FromArrayToRef(e[7],0,t.l21),n.FromArrayToRef(e[8],0,t.l22),t}}class Z{_harmonics;get preScaledHarmonics(){return this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}x=new n;y=new n;z=new n;xx=new n;yy=new n;zz=new n;xy=new n;yz=new n;zx=new n;scale(e){this.x.scale(e),this.y.scale(e),this.z.scale(e),this.xx.scale(e),this.yy.scale(e),this.zz.scale(e),this.yz.scale(e),this.zx.scale(e),this.xy.scale(e)}static FromHarmonics(e){const t=new Z;return t._harmonics=e,t.x=e.l11.scale2(1.02333).scale2(-1),t.y=e.l1_1.scale2(1.02333).scale2(-1),t.z=e.l10.scale2(1.02333),t.xx=e.l00.scale2(.886277).subtract2(e.l20.scale2(.247708)).add2(e.l22.scale2(.429043)),t.yy=e.l00.scale2(.886277).subtract2(e.l20.scale2(.247708)).subtract2(e.l22.scale2(.429043)),t.zz=e.l00.scale2(.886277).add2(e.l20.scale2(.495417)),t.yz=e.l2_1.scale2(.858086).scale2(-1),t.zx=e.l21.scale2(.858086).scale2(-1),t.xy=e.l2_2.scale2(.858086),t.scale(1/Math.PI),t}}const J=512;let $=128;function Q(e,{data:t,shape:r,usage:n=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}){const i=new Float32Array(t.length);let s,a,o,l,c,u;for(let e=0;e<=r[1];e++)for(let n=0;n<=r[0];n++)s=e*r[0]+n,a=t[4*s],o=t[4*s+1],l=t[4*s+2],c=t[4*s+3],u=(r[1]-e+1)*r[0]+n,i[4*u]=a,i[4*u+1]=o,i[4*u+2]=l,i[4*u+3]=c;const f=e.createTexture({size:[r[0],r[1],1],format:"rgba32float",usage:n}),h=4*r[0]*4;return e.queue.writeTexture({texture:f},i,{bytesPerRow:h},[r[0],r[1],1]),f}class ee{camera;envMatrix;VAO;quadVAO;IndexBufferLength;cubeprogram;irradianceprogram;mipmapcubeprogram;bdrfprogram;level;diffuse;MVPMatrix;framebuffer;irradiancebuffer;prefilterbuffer;views;prefilterrender;brdfbuffer;canvas;url;sampler;samplerCube;envData;uniformBuffer;originalCubeTexture;brdfLUTTexture;original2DTexture;irradiancemap;prefilterMap;Sheen_E;prefilterTexture;charlieTexture;irradianceTexture;tempTexture;bdrfTexture;cubeTexture;pipeline;pipeline2;pipeline3;constructor(e){this.url=e,this.envMatrix=new t}setCamera(e){this.camera=e}setCanvas(e){this.canvas=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}drawQuad(e){const r=new t,n=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});r.multiply(A(n));const{device:i,context:s}=e;let a;{const e=i.createTexture({size:[this.width,this.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}).createView();a={colorAttachments:[{view:s.getCurrentTexture().createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:e,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}const o=[{binding:0,resource:i.createSampler({magFilter:"linear"})},{binding:1,resource:this.originalCubeTexture.createView()}],l=i.createCommandEncoder(),c=l.beginRenderPass(a),u=this.buildPipeline(e,"#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec2 inPosition;\n        \n        layout (location = 0) out vec2 outUV;\n\n        //uniform mat4 projection;\n        //uniform mat4 view;\n        \n        void main() {\n            outUV = inPosition * 0.5 + 0.5;\n            gl_Position = vec4(inPosition, 0.0, 1.0);\n        }\n        ","#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec2 outUV;\n        layout (location = 0) out vec4 color;\n\n        layout(set = 0, binding = 0) uniform sampler baseSampler;\n        layout(set = 0, binding = 1) uniform texture2D environmentMap;\n        \n        void main() {\n            vec3 c = texture(sampler2D(environmentMap, baseSampler), outUV).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",2,[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}}],[{format:"bgra8unorm"}]);c.setPipeline(u),c.setVertexBuffer(0,this.buildVertex(e,j)),c.setBindGroup(0,i.createBindGroup({layout:u.getBindGroupLayout(0),entries:o})),c.draw(6),c.end(),i.queue.submit([l.finish()])}drawCube(e){const{device:r,context:n}=e,i=new t,s=Object.assign({},this.camera.props,{perspective:{yfov:1.1,znear:.01,zfar:1e4}});i.multiply(A(s));const a=new O;a.add("view",this.camera.matrixWorldInvert.elements),a.add("projection",i.elements),a.done();const o=a.store.byteLength,l=256+o,c=r.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});let u;r.queue.writeBuffer(c,0,a.store.buffer,a.store.byteOffset,a.store.byteLength);{const e=r.createTexture({size:[this.width,this.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}).createView();u={colorAttachments:[{view:n.getCurrentTexture().createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:e,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}const f=[{binding:0,resource:{buffer:c,offset:0,size:o}},{binding:1,resource:r.createSampler({magFilter:"linear"})},{binding:2,resource:this.irradianceTexture.createView({dimension:"cube"})}],h=r.createCommandEncoder(),m=h.beginRenderPass(u),d=this.buildPipeline(e,"#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec3 inPosition;\n        \n        layout (location = 0) out vec3 outUV;\n\n        layout(set = 0, binding = 0) uniform Uniforms {\n            mat4 view;\n            mat4 projection;\n        } uniforms;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = uniforms.projection * uniforms.view * vec4(inPosition*1.4, 1.0);\n        }\n        ","#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec3 outUV;\n        layout (location = 0) out vec4 color;\n\n        layout(set = 0, binding = 1) uniform sampler baseSampler;\n        layout(set = 0, binding = 2) uniform textureCube environmentMap;\n        \n        void main() {\n            vec3 c = textureLod(samplerCube(environmentMap, baseSampler), outUV, 1.0).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",3,[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube",sampleType:"float"}}],[{format:"bgra8unorm"}]);m.setPipeline(d),m.setVertexBuffer(0,this.buildVertex(e,W)),m.setBindGroup(0,r.createBindGroup({layout:d.getBindGroupLayout(0),entries:f})),m.draw(36),m.end(),r.queue.submit([h.finish()])}async createEnvironmentBuffer(e,r){if(this.envData=e,e){const n=new t;n.makeRotationFromQuaternion(new o(e.rotation).elements);const i=K.FromArray(e.irradianceCoefficients);i.scaleInPlace(e.intensity),i.convertIrradianceToLambertianRadiance();const s=Z.FromHarmonics(i),{preScaledHarmonics:a}=s,l=new O;l.add("vSphericalL00",a.l00.elements),l.add("vSphericalL1_1",a.l1_1.elements),l.add("vSphericalL10",a.l10.elements),l.add("vSphericalL11",a.l11.elements),l.add("vSphericalL2_2",a.l2_2.elements),l.add("vSphericalL2_1",a.l2_1.elements),l.add("vSphericalL20",a.l20.elements),l.add("vSphericalL21",a.l21.elements),l.add("vSphericalL22",a.l22.elements),l.add("rotationMatrix",n.elements),l.done(),this.uniformBuffer=l;const c=r.device.createBuffer({size:256+l.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});l.bufferWebGPU=c,r.device.queue.writeBuffer(c,0,l.store.buffer,l.store.byteOffset,l.store.byteLength),$=e.specularImageSize}}async createTexture(e){const r=[[new n([0,1,0]),Math.PI/2],[new n([0,1,0]),-Math.PI/2],[new n([1,0,0]),Math.PI/2],[new n([1,0,0]),-Math.PI/2],[new n([0,1,0]),Math.PI],[new n([0,1,0]),0]];this.views=r.map((e,r)=>{const i=new t;if(i.makeRotationAxis(e[0],e[1]),2!==r&&3!==r){const e=new t;e.makeRotationAxis(new n([0,0,1]),Math.PI),i.multiply(e)}return(new t).setInverseOf(i)});const{device:i}=e;await fetch(this.url).then(e=>e.arrayBuffer()).then(e=>{const t=Q(i,H()(e));return this.originalCubeTexture=t,t}),await fetch(Y).then(e=>e.arrayBuffer()).then(e=>{const t=Q(i,H()(e));return this.Sheen_E=t,t})}buildPass(e,t){const{device:r}=e,n=r.createTexture({size:[t,t,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}).createView(),i=r.createTexture({size:[t,t,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:"rgba32float"});return this.tempTexture=i,{colorAttachments:[{view:i.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:n,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}buildPipeline(e,t,r,n,i,s){const{device:a,glslang:o,wgsl:l}=e;function c(e,t){const r=o.compileGLSL(e,t);return l.convertSpirV2WGSL(r)}const u=a.createBindGroupLayout({entries:i}),f=a.createPipelineLayout({bindGroupLayouts:[u]});return a.createRenderPipeline({layout:f,vertex:{module:a.createShaderModule({code:c(t,"vertex")}),entryPoint:"main",buffers:[{arrayStride:Float32Array.BYTES_PER_ELEMENT*n,attributes:[{shaderLocation:0,offset:0,format:`float32x${n}`}]}]},fragment:{module:a.createShaderModule({code:c(r,"fragment")}),entryPoint:"main",targets:s},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}})}buildVertex(e,t){const{device:r}=e,n=r.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set(t),n.unmap(),n}drawBRDF(e){const{device:t}=e;this.bdrfTexture=t.createTexture({label:"bdrfTexture",size:[J,J,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba32float"});const r=t.createCommandEncoder(),n=this.buildPass(e,J),i=r.beginRenderPass(n),s=this.buildPipeline(e,z,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 uv;\r\nlayout (location = 0) out vec4 color;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nvec2 IntegrateBRDF(float NdotV, float roughness) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 integratedBRDF = IntegrateBRDF(uv.x, uv.y);\r\n    color = vec4(integratedBRDF, 0.0, 0.0);\r\n}\r\n",2,[],[{format:"rgba32float"}]);i.setPipeline(s),i.setVertexBuffer(0,this.buildVertex(e,j)),i.setBindGroup(0,t.createBindGroup({layout:s.getBindGroupLayout(0),entries:[]})),i.setViewport(0,0,J,J,0,1),i.draw(6),i.end(),r.copyTextureToTexture({texture:this.tempTexture},{texture:this.bdrfTexture},[J,J,1]),t.queue.submit([r.finish()])}drawWebGPU(e,r,n,i,s){const{device:a}=e,o=new t,l=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});o.multiply(A(l));const c=new O;c.add("index",new Float32Array([i,0,0,0])),c.add("projection",o.elements),c.add("view0",this.views[0].elements),c.add("view1",this.views[1].elements),c.add("view2",this.views[2].elements),c.add("view3",this.views[3].elements),c.add("view4",this.views[4].elements),c.add("view5",this.views[5].elements),c.done();const u=c.store.byteLength,f=256+u,h=a.createBuffer({size:f,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(h,0,c.store.buffer,c.store.byteOffset,c.store.byteLength);const m=[{binding:0,resource:{buffer:h,offset:0,size:u}},{binding:1,resource:a.createSampler({magFilter:"linear"})},{binding:2,resource:this.originalCubeTexture.createView()}],d=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}}],p=a.createCommandEncoder(),T=this.buildPass(e,J),E=p.beginRenderPass(T),g=this.pipeline||this.buildPipeline(e,X,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform texture2D diffuse;\r\n\r\nconst vec2 invAtan = vec2(0.1591, 0.3165);\r\nvec2 SampleSphericalMap(vec3 v) {\r\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\r\n    uv *= invAtan;\r\n    uv += 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 uv = SampleSphericalMap(normalize(outUV));\r\n    vec3 c = texture(sampler2D(diffuse, baseSampler), uv).rgb;\r\n    \r\n    color = vec4(c, 1.0);\r\n}\r\n",3,d,[{format:"rgba32float"}]);this.pipeline=g,E.setPipeline(g),E.setVertexBuffer(0,this.buildVertex(e,W)),E.setBindGroup(0,a.createBindGroup({layout:g.getBindGroupLayout(0),entries:m})),E.setViewport(0,0,r,n,0,1),E.draw(36),E.end(),p.copyTextureToTexture({texture:this.tempTexture},{texture:this.cubeTexture,mipLevel:s,origin:{z:i}},[r,n,1]),a.queue.submit([p.finish()])}drawWebGPU2(e,r,n,i,s){const{device:a}=e,o=new t,l=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});o.multiply(A(l));const c=new O;c.add("index",new Float32Array([i,0,0,0])),c.add("projection",o.elements),c.add("view0",this.views[0].elements),c.add("view1",this.views[1].elements),c.add("view2",this.views[2].elements),c.add("view3",this.views[3].elements),c.add("view4",this.views[4].elements),c.add("view5",this.views[5].elements),c.done();const u=c.store.byteLength,f=256+u,h=a.createBuffer({size:f,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(h,0,c.store.buffer,c.store.byteOffset,c.store.byteLength);const m=[{binding:0,resource:{buffer:h,offset:0,size:u}},{binding:1,resource:a.createSampler({magFilter:"linear"})},{binding:2,resource:this.cubeTexture.createView({dimension:"cube"})}],d=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube",sampleType:"float"}}],p=a.createCommandEncoder(),T=this.buildPass(e,32),E=p.beginRenderPass(T),g=this.pipeline2||this.buildPipeline(e,X,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform textureCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nvoid main() {\r\n    vec3 N = normalize(outUV);\r\n    vec3 irradiance = vec3(0.0);\r\n\r\n    vec3 up    = vec3(0.0, 1.0, 0.0);\r\n    vec3 right = cross(up, N);\r\n    up         = cross(N, right);\r\n\r\n    float sampleDelta = 0.025;\r\n    float nrSamples = 0.0; \r\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \r\n\r\n            irradiance += textureLod(samplerCube(environmentMap, baseSampler), sampleVec, 3.0).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = irradiance * (1.0 / float(nrSamples)) * (1.0 / PI); // * PI Hack\r\n    \r\n    color = vec4(irradiance, 1.0);\r\n}\r\n",3,d,[{format:"rgba32float"}]);this.pipeline2=g,E.setPipeline(g),E.setVertexBuffer(0,this.buildVertex(e,W)),E.setBindGroup(0,a.createBindGroup({layout:g.getBindGroupLayout(0),entries:m})),E.setViewport(0,0,r,n,0,1),E.draw(36),E.end(),p.copyTextureToTexture({texture:this.tempTexture},{texture:this.irradianceTexture,mipLevel:s,origin:{z:i}},[r,n,1]),a.queue.submit([p.finish()])}drawWebGPU3(e,r,n,i,s){const{device:a}=e,o=new t,l=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});o.multiply(A(l));const c=s/4,u=new O;u.add("index",new Float32Array([i,c,0,0])),u.add("projection",o.elements),u.add("view0",this.views[0].elements),u.add("view1",this.views[1].elements),u.add("view2",this.views[2].elements),u.add("view3",this.views[3].elements),u.add("view4",this.views[4].elements),u.add("view5",this.views[5].elements),u.done();const f=u.store.byteLength,h=256+f,m=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(m,0,u.store.buffer,u.store.byteOffset,u.store.byteLength);const d=[{binding:0,resource:{buffer:m,offset:0,size:f}},{binding:1,resource:a.createSampler({magFilter:"linear"})},{binding:2,resource:this.cubeTexture.createView({dimension:"cube"})}],p=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube",sampleType:"float"}}],T=a.createCommandEncoder(),E=this.buildPass(e,$),g=a.createTexture({size:[$,$,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:"rgba32float"});E.colorAttachments.push({view:g.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}});const x=T.beginRenderPass(E),v=this.pipeline3||this.buildPipeline(e,X,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec4 color2;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 roughness;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n};\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform textureCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness, bool isCharlie, float cosZ) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    if (isCharlie) {\r\n        sinTheta = pow(Xi.y, a / (2.0*a + 1.0));\r\n        cosTheta = sqrt(1.0 - sinTheta * sinTheta);\r\n        cosZ = cosTheta;\r\n    }\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n}\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nfloat D_Charlie(float sheenRoughness, float NdotH) {\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float invR = 1.0 / sheenRoughness;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\n\r\nvec3 x(bool isCharlie, float roughness) {\r\n    vec3 N = normalize(outUV);    \r\n    vec3 R = N;\r\n    vec3 V = R;\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    float totalWeight = 0.0;   \r\n    vec3 prefilteredColor = vec3(0.0);     \r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        float cosZ;\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness, isCharlie, cosZ);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(dot(N, L), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float D = DistributionGGX(N, H, roughness);\r\n            float pdf = (D * max(dot(N, H), 0.0) / (4.0 * max(dot(H, V), 0.0))) + 0.0001;\r\n            if (isCharlie) {\r\n                pdf = D_Charlie(roughness * roughness, cosZ);\r\n            }\r\n            float saTexel = 4.0 * PI / (6.0 * 512.0 * 512.0);\r\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.00001);\r\n             \r\n            float mipLevel = roughness == 0.0 ? 0.0 :  0.5 * log2( saSample / saTexel )  ;\r\n                                 \r\n            prefilteredColor += textureLod( samplerCube(environmentMap, baseSampler), L, mipLevel ).rgb * NdotL;     \r\n            totalWeight += NdotL;\r\n        }\r\n    }\r\n    prefilteredColor = prefilteredColor / totalWeight;\r\n    return prefilteredColor;\r\n}\r\n\r\nvoid main() {\r\n    color = vec4(x(false, roughness.y), 1.0);\r\n    color2 = vec4(x(true, roughness.y), 1.0);\r\n}\r\n",3,p,[{format:"rgba32float"},{format:"rgba32float"}]);if(this.pipeline3=v,x.setPipeline(v),x.setVertexBuffer(0,this.buildVertex(e,W)),x.setBindGroup(0,a.createBindGroup({layout:v.getBindGroupLayout(0),entries:d})),x.setViewport(0,0,r,n,0,1),x.draw(36),x.end(),this.envData){let e=i;2===i&&(e=3),3===i&&(e=2);const t=this.envData.specularImages[s][e];a.queue.copyExternalImageToTexture({source:t.bitmap},{texture:this.prefilterTexture,mipLevel:s,origin:{z:i}},{width:r,height:n,depthOrArrayLayers:1})}else T.copyTextureToTexture({texture:this.tempTexture},{texture:this.prefilterTexture,mipLevel:s,origin:{z:i}},[r,n,1]),T.copyTextureToTexture({texture:g},{texture:this.charlieTexture,mipLevel:s,origin:{z:i}},[r,n,1]);a.queue.submit([T.finish()])}drawMips(e){const{device:t}=e;this.cubeTexture=t.createTexture({mipLevelCount:5,size:[J,J,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba32float"});for(let t=0;t<5;++t){const r=J*Math.pow(.5,t),n=J*Math.pow(.5,t);for(let i=0;i<6;i++)this.drawWebGPU(e,r,n,i,t)}}drawIrradiance(e){const{device:t}=e;this.irradianceTexture=t.createTexture({label:"irradianceTexture",size:[32,32,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba32float"});for(let t=0;t<6;t++)this.drawWebGPU2(e,32,32,t,0)}drawPrefilter(e){const{device:t}=e;this.prefilterTexture=t.createTexture({label:"prefilterTexture",mipLevelCount:5,size:[$,$,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba32float"}),this.charlieTexture=t.createTexture({label:"charlieTexture",mipLevelCount:5,size:[$,$,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba32float"});for(let t=0;t<5;++t){const r=$*Math.pow(.5,t),n=$*Math.pow(.5,t);for(let i=0;i<6;i++)this.drawWebGPU3(e,r,n,i,t)}}}var te=i(603);function re(e){const{ktxTexture:t,TranscodeTarget:r,transcoderConfig:n}=window.LIBKTX,{astcSupported:i,dxtSupported:s,pvrtcSupported:a,etc1Supported:o,etc2Supported:l}=n,c=new Uint8Array(e);if(!function(e){if(e.byteLength>=12){const t=new Uint8Array(e.buffer,e.byteOffset,12);if(171===t[0]&&75===t[1]&&84===t[2]&&88===t[3]&&32===t[4]&&50===t[5]&&48===t[6]&&187===t[7]&&13===t[8]&&10===t[9]&&26===t[10]&&10===t[11])return!0}return!1}(c))throw new Error("Texture is not valid ktx 2.0 file");const u=new t(c);if(u.needsTranscoding){let e;if(e=i?r.ASTC_4x4_RGBA:s?r.BC1_OR_3:a?r.PVRTC1_4_RGBA:o||l?r.ETC:r.RGBA4444,u.transcodeBasis(e,0)!==window.LIBKTX.ErrorCode.SUCCESS)throw new Error("Texture transcode failed. See console for details.");return u.glUpload().texture}}function ne(e){return"undefined"!=typeof window?window.fetch(e).then(e=>e.arrayBuffer()):new Promise(t=>{te.readFile(e,(e,r)=>{if(e)throw e;t(new Uint8Array(r).buffer)})})}let ie;function se(e,t,r,n,i){let s,a;switch(e){case"BYTE":s=new Int8Array(t),s.type="BYTE",a=new ie.DracoInt8Array,r&&i.GetAttributeInt8ForAllPoints(r,n,a);break;case"UNSIGNED_BYTE":s=new Uint8Array(t),s.type="UNSIGNED_BYTE",a=new ie.DracoUInt8Array,r&&i.GetAttributeUInt8ForAllPoints(r,n,a);break;case"SHORT":s=new Int16Array(t),s.type="SHORT",a=new ie.DracoInt16Array,r&&i.GetAttributeInt16ForAllPoints(r,n,a);break;case"UNSIGNED_SHORT":s=new Uint16Array(t),s.type="UNSIGNED_SHORT",a=new ie.DracoUInt16Array,r&&i.GetAttributeUInt16ForAllPoints(r,n,a);break;case"UNSIGNED_INT":s=new Uint32Array(t),s.type="UNSIGNED_INT",a=new ie.DracoUInt32Array,r&&i.GetAttributeUInt32ForAllPoints(r,n,a);break;case"FLOAT":s=new Float32Array(t),s.type="FLOAT",a=new ie.DracoFloat32Array,r&&i.GetAttributeFloatForAllPoints(r,n,a)}return[a,s]}const ae='#include "./vert.h"\r\n\r\nvoid main() {\r\n    #ifdef JOINTNUMBER\r\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\r\n        skin += inWeight.y * joint[int(inJoint.y)];\r\n        skin += inWeight.z * joint[int(inJoint.z)];\r\n        skin += inWeight.w * joint[int(inJoint.w)];\r\n    #else\r\n        mat4 skin = mat4(1.0);\r\n    #endif\r\n\r\n    #ifdef COLOR\r\n    #ifdef COLOR_255\r\n        vColor = inColor / 255.0;\r\n    #else\r\n        vColor = inColor;\r\n    #endif\r\n    #endif\r\n    outUV0 = inUV;\r\n    #ifdef MULTIUV\r\n    outUV2 = inUV2;\r\n    outUV3 = inUV3;\r\n    #endif\r\n    #ifdef TANGENT\r\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\r\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\r\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\r\n        #ifdef USERIGHTHANDEDSYSTEM\r\n        tangentW *= 1.0; // invertX\r\n        bitangentW *= -1.0; // invertY\r\n        #endif\r\n        outTBN = mat3(tangentW, bitangentW, normalW);\r\n    #else\r\n        outNormal = normalize(mat3(normalMatrix) * mat3(skin) * inNormal);\r\n    #endif\r\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\r\n    outPositionView = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    if (isShadow.x == 1.0) {\r\n        gl_Position = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    } else {\r\n        gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\r\n    }\r\n\r\n    gl_PointSize = 1.0;\r\n}\r\n',oe='#include "./frag.h"\r\n\r\nconst float RECIPROCAL_PI = 0.31830988618;\r\nconst float PI = 3.141592653589793;\r\nconst float EPSILON = 1e-6;\r\nconst float ambientStrength = 0.1;\r\nconst float specularStrength = 2.5;\r\nconst float specularPower = 32.0;\r\nconst float gamma = 2.2;\r\n\r\n\r\nvec2 getUV(int index) {\r\n    #ifdef MULTIUV\r\n    if (index == 2) {\r\n        return outUV3;\r\n    }\r\n    if (index == 0) {\r\n        return outUV2;\r\n    }\r\n    #endif\r\n    if (index == 1) {\r\n        return outUV0;\r\n    }\r\n}\r\n#ifdef SHADOWMAP\r\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias) {\r\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\r\n    projCoords = projCoords * 0.5 + 0.5;\r\n    float currentDepth = projCoords.z;\r\n\r\n    float shadow = 0.0;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\r\n    for (int x = -2; x <= 2; ++x) {\r\n        for (int y = -2; y <= 2; ++y) {\r\n            float pcfDepth = texture2D(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\r\n            shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\r\n        }\r\n    }\r\n    shadow /= 25.0;\r\n\r\n    return shadow;\r\n}\r\n#endif\r\n\r\nvec3 srgbToLinear(vec4 srgbIn) {\r\n    #ifdef BASISU\r\n    return srgbIn.rgb;\r\n    #else\r\n    return pow(srgbIn.rgb, vec3(2.2));\r\n    #endif\r\n}\r\n\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nfloat fresnelSchlick(float cosTheta, float F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\r\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\r\n    float x2 = x * x;\r\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\r\n\r\n    return (f - f90 * x5) / (1.0 - x5);\r\n}\r\nvec3 Schlick_to_F0(vec3 f, float VdotH) {\r\n    return Schlick_to_F0(f, vec3(1.0), VdotH);\r\n}\r\nfloat sq(float t) {\r\n    return t * t;\r\n}\r\nvec3 sq(vec3 t) {\r\n    return t * t;\r\n}\r\n// XYZ to sRGB color space\r\nconst mat3 XYZ_TO_REC709 = mat3(\r\n     3.2404542, -0.9692660,  0.0556434,\r\n    -1.5371385,  1.8760108, -0.2040259,\r\n    -0.4985314,  0.0415560,  1.0572252\r\n);\r\n\r\nfloat applyIorToRoughness(float roughness, float ior) {\r\n    #if defined VOLUME\r\n    // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\r\n    // an IOR of 1.5 results in the default amount of microfacet refraction.\r\n    return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\r\n    #else\r\n    return roughness;\r\n    #endif\r\n}\r\n\r\n// Assume air interface for top\r\n// Note: We don\'t handle the case fresnel0 == 1\r\nvec3 Fresnel0ToIor(vec3 fresnel0) {\r\n    vec3 sqrtF0 = sqrt(fresnel0);\r\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\r\n}\r\n\r\n// Conversion FO/IOR\r\nvec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\r\n    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\r\n}\r\n\r\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\r\nfloat IorToFresnel0(float transmittedIor, float incidentIor) {\r\n    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\r\n}\r\n\r\n// Fresnel equations for dielectric/dielectric interfaces.\r\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r\n// Evaluation XYZ sensitivity curves in Fourier space\r\nvec3 evalSensitivity(float OPD, vec3 shift) {\r\n    float phase = 2.0 * PI * OPD * 1.0e-9;\r\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\r\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\r\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\r\n\r\n    vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-sq(phase) * var);\r\n    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * sq(phase));\r\n    xyz /= 1.0685e-7;\r\n\r\n    vec3 srgb = XYZ_TO_REC709 * xyz;\r\n    return srgb;\r\n}\r\n\r\nvec3 evalIridescence(float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\r\n    vec3 I;\r\n\r\n    // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\r\n    float iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\r\n    // Evaluate the cosTheta on the base layer (Snell law)\r\n    float sinTheta2Sq = sq(outsideIOR / iridescenceIOR) * (1.0 - sq(cosTheta1));\r\n\r\n    // Handle TIR:\r\n    float cosTheta2Sq = 1.0 - sinTheta2Sq;\r\n    if (cosTheta2Sq < 0.0) {\r\n        return vec3(1.0);\r\n    }\r\n\r\n    float cosTheta2 = sqrt(cosTheta2Sq);\r\n\r\n    // First interface\r\n    float R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\r\n    float R12 = fresnelSchlick(cosTheta1, R0);\r\n    float R21 = R12;\r\n    float T121 = 1.0 - R12;\r\n    float phi12 = 0.0;\r\n    if (iridescenceIOR < outsideIOR) phi12 = PI;\r\n    float phi21 = PI - phi12;\r\n\r\n    // Second interface\r\n    vec3 baseIOR = Fresnel0ToIor(clamp(baseF0, 0.0, 0.9999)); // guard against 1.0\r\n    vec3 R1 = IorToFresnel0(baseIOR, iridescenceIOR);\r\n    vec3 R23 = fresnelSchlick(cosTheta2, R1);\r\n    vec3 phi23 = vec3(0.0);\r\n    if (baseIOR[0] < iridescenceIOR) phi23[0] = PI;\r\n    if (baseIOR[1] < iridescenceIOR) phi23[1] = PI;\r\n    if (baseIOR[2] < iridescenceIOR) phi23[2] = PI;\r\n\r\n    // Phase shift\r\n    float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\r\n    vec3 phi = vec3(phi21) + phi23;\r\n\r\n    // Compound terms\r\n    vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\r\n    vec3 r123 = sqrt(R123);\r\n    vec3 Rs = sq(T121) * R23 / (vec3(1.0) - R123);\r\n\r\n    // Reflectance term for m = 0 (DC term amplitude)\r\n    vec3 C0 = R12 + Rs;\r\n    I = C0;\r\n\r\n    // Reflectance term for m > 0 (pairs of diracs)\r\n    vec3 Cm = Rs - T121;\r\n    for (int m = 1; m <= 2; ++m)\r\n    {\r\n        Cm *= r123;\r\n        vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\r\n        I += Cm * Sm;\r\n    }\r\n\r\n    // Since out of gamut colors might be produced, negative color values are clamped to 0.\r\n    return max(I, vec3(0.0));\r\n}\r\n#ifdef ANISOTROPY\r\nfloat DistributionGGX(vec3 N, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float at, float ab) {\r\n    float NdotH = dot(N, H);\r\n    float TdotH = dot(anisotropicT, H);\r\n    float BdotH = dot(anisotropicB, H);\r\n\r\n    float a2 = at * ab;\r\n    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\r\n    float w2 = a2 / dot(f, f);\r\n    return a2 * w2 * w2 / PI;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, vec3 anisotropicT, vec3 anisotropicB, float at, float ab) {\r\n    float NdotV = dot(N, V);\r\n    float NdotL = dot(N, L);\r\n    float TdotV = dot(anisotropicT, V);\r\n    float TdotL = dot(anisotropicT, L);\r\n    float BdotV = dot(anisotropicB, V);\r\n    float BdotL = dot(anisotropicB, L);\r\n\r\n    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\r\n    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\r\n    float v = 0.5 / (GGXV + GGXL);\r\n    return clamp(v, 0.0, 1.0);\r\n}\r\n#else\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float NdotH = max(dot(N, H), 0.01);\r\n    float a = max(roughness*roughness, 0.01);\r\n    float alphaRoughnessSq = a * a;\r\n    float f = (NdotH * NdotH) * (alphaRoughnessSq - 1.0) + 1.0;\r\n    return alphaRoughnessSq / (PI * f * f);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float cosTheta, float roughness) {\r\n    float r = (roughness + 1.0);\r\n    float k = (r * r) / 8.0;\r\n\r\n    float nom   = cosTheta;\r\n    float denom = cosTheta * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n#endif\r\n\r\nfloat fresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\r\n    return F0 + (max(1.0 - roughness, F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 calcTransmission(vec3 color, vec3 N, float roughness, vec3 V, float transmission, float thickness) {\r\n    float refraction_ior = 1.0 / ior.x;\r\n    vec3 environmentRefraction = vec3(0.0);\r\n    #ifdef DISPERSION\r\n    float realIOR = 1.0 / ior.x;\r\n    float iorDispersionSpread = 0.04 * dispersionFactor.x * (realIOR - 1.0);\r\n    vec3 iors = vec3(realIOR - iorDispersionSpread, refraction_ior, realIOR + iorDispersionSpread);\r\n    for (int i = 0; i < 3; i++) {\r\n        refraction_ior = iors[i];\r\n    #endif\r\n\r\n    vec4 refractS = projection * view * vec4(outPosition + refract(-V, N, refraction_ior) * thickness, 1.0);\r\n    refractS.xy = refractS.xy / refractS.w;\r\n    refractS.xy = refractS.xy * 0.5 + 0.5;\r\n    const float MAX_REFLECTION_LOD = 10.0;\r\n    #if defined(WEBGPU)\r\n    refractS.y = 1.0 - refractS.y;\r\n    #endif\r\n    vec3 baseColor = textureLod2D(colorTexture, refractS.xy, applyIorToRoughness(roughness, 1.0 / refraction_ior) * MAX_REFLECTION_LOD).xyz;\r\n\r\n    #ifdef DISPERSION\r\n        environmentRefraction[i] = baseColor[i];\r\n    }\r\n    #else\r\n        environmentRefraction = baseColor;\r\n    #endif\r\n\r\n    return transmission * environmentRefraction * color;\r\n}\r\n\r\nvec3 computeEnvironmentIrradiance(vec3 normal) {\r\n    return vSphericalL00.xyz\r\n        + vSphericalL1_1.xyz * (normal.y)\r\n        + vSphericalL10.xyz * (normal.z)\r\n        + vSphericalL11.xyz * (normal.x)\r\n        + vSphericalL2_2.xyz * (normal.y * normal.x)\r\n        + vSphericalL2_1.xyz * (normal.y * normal.z)\r\n        + vSphericalL20.xyz * ((3.0 * normal.z * normal.z) - 1.0)\r\n        + vSphericalL21.xyz * (normal.z * normal.x)\r\n        + vSphericalL22.xyz * (normal.x * normal.x - (normal.y * normal.y));\r\n}\r\nfloat sheenDistribution(float sheenRoughness, vec3 N, vec3 H) {\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float alphaG = max(sheenRoughness * sheenRoughness, 0.01);\r\n    float invR = 1.0 / alphaG;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\nfloat lambdaSheenNumericHelper(float x, float alphaG) {\r\n    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\r\n    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\r\n    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\r\n    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\r\n    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\r\n    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\r\n    return a / (1.0 + b * pow(x, c)) + d * x + e;\r\n}\r\nfloat lambdaSheen(float cosTheta, float alphaG) {\r\n    if (abs(cosTheta) < 0.5) {\r\n        return exp(lambdaSheenNumericHelper(cosTheta, alphaG));\r\n    } else {\r\n        return exp(2.0 * lambdaSheenNumericHelper(0.5, alphaG) - lambdaSheenNumericHelper(1.0 - cosTheta, alphaG));\r\n    }\r\n}\r\nfloat sheenVisibility(vec3 N, vec3 V, vec3 L, float sheenRoughness) {\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float NdotV = max(dot(N, V), 0.0);\r\n\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float alphaG = sheenRoughness * sheenRoughness;\r\n\r\n    return clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) *\r\n        (4.0 * NdotV * NdotL)), 0.0, 1.0);\r\n}\r\nfloat E(float x, float y) {\r\n    return texture2D(Sheen_E, vec2(x,y)).r;\r\n}\r\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\r\nfloat pow2(float v) { return v * v; }\r\nvec3 IBLAmbient(vec3 baseColor, float metallic, vec3 n, float roughness, vec3 viewDir, float transmission, vec3 sheenColor, float sheenRoughness, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight, float anisotropy, vec3 anisotropicB, inout vec3 f_sheen, out vec3 specular) {\r\n    #ifdef ANISOTROPY\r\n    vec3 Normal = cross(anisotropicB, viewDir);\r\n    Normal = normalize(cross(Normal, anisotropicB));\r\n    float a = pow2(pow2(1.0 - anisotropy * (1.0 - roughness)));\r\n    n = normalize(mix(Normal, n, a));\r\n    #endif\r\n    \r\n    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\r\n\r\n    vec3 kD = vec3(1.0) - F * specularWeight;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n    #if defined IRIDESCENCE\r\n    kD = vec3(1.0) - mix(F, iridescenceFresnel, iridescenceFactor) * specularWeight;\r\n    kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n\r\n    vec3 R;\r\n    #ifdef SPHERICAL_HARMONICS\r\n    R = reflect(viewDir, n);\r\n    vec4 rotatedR = rotationMatrix * vec4(R.x * -1.0, R.y, R.z, 0.0);\r\n    R = rotatedR.xyz;\r\n    vec4 prefilterColor = textureLodCube(prefilterMap, R, roughness * float(SPHERICAL_HARMONICS));\r\n    vec3 prefilteredColor = srgbToLinear(vec4(prefilterColor.rgb, 0.0)) / pow(prefilterColor.a, 2.2);\r\n    vec3 irradianceVector = vec3(rotationMatrix * vec4(n.x, n.y, n.z * -1.0, 0)).xyz;\r\n    vec3 irradiance = computeEnvironmentIrradiance(irradianceVector).rgb;\r\n    #else\r\n    const float MAX_REFLECTION_LOD = 4.0;\r\n    R = reflect(-viewDir, n);\r\n    vec3 prefilteredColor = textureLodCube(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;\r\n    vec3 irradiance = textureCube(irradianceMap, n).rgb;\r\n    #endif\r\n    vec2 envBRDF  = texture2D(brdfLUT, vec2(max(dot(n, viewDir), 0.0), roughness)).rg;\r\n    vec3 kS = F;\r\n    #if defined IRIDESCENCE\r\n    kS = mix(F, iridescenceFresnel, iridescenceFactor);\r\n    #endif\r\n    specular = prefilteredColor * (kS * specularWeight * envBRDF.x + envBRDF.y);\r\n\r\n    #if defined SHEEN\r\n    float charliebrdf = texture2D(brdfLUT, vec2(max(dot(n, viewDir), 0.0), sheenRoughness)).b;\r\n    vec3 sheenSample = textureLodCube(charlieMap, R, sheenRoughness * MAX_REFLECTION_LOD).rgb;\r\n    f_sheen += sheenSample * sheenColor * charliebrdf;\r\n    #endif\r\n\r\n    return (1.0 - transmission) * kD * irradiance * baseColor;\r\n}\r\n\r\nfloat specEnv(vec3 N, vec3 V, float metallic, float roughness, vec3 F0, float specularWeight) {\r\n    float F = fresnelSchlickRoughness(max(dot(N, V), 0.0), (F0.x+F0.y+F0.z)/3.0, roughness);\r\n    vec2 envBRDF  = texture2D(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\r\n    return (F * specularWeight * envBRDF.x + envBRDF.y);\r\n}\r\n\r\n#ifdef ANISOTROPY\r\nvec3 CookTorranceSpecular2(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight) {\r\n    roughness = roughness * roughness;\r\n    float at = max(mix(roughness, 1.0, anisotropy * anisotropy), 0.001);\r\n    float ab = max(roughness, 0.001);\r\n    float D = DistributionGGX(n, H, anisotropicT, anisotropicB, at, ab);\r\n    float G = GeometrySmith(n, viewDir, lightDir, anisotropicT, anisotropicB, at, ab);\r\n    vec3 F = mix(fresnelSchlick(max(dot(viewDir, H), 0.0), F0), iridescenceFresnel, iridescenceFactor);\r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return D * G * F;\r\n}\r\nvec3 CookTorranceSpecular(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 F0, float specularWeight) {\r\n    roughness = roughness * roughness;\r\n    float at = max(mix(roughness, 1.0, anisotropy * anisotropy), 0.001);\r\n    float ab = max(roughness, 0.001);\r\n    float D = DistributionGGX(n, H, anisotropicT, anisotropicB, at, ab);\r\n    float G = GeometrySmith(n, viewDir, lightDir, anisotropicT, anisotropicB, at, ab);\r\n    vec3 F = fresnelSchlick(max(dot(viewDir, H), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return D * G * F;\r\n}\r\n#else\r\nvec3 CookTorranceSpecular2(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight) {\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);\r\n    vec3 F = mix(fresnelSchlick(max(dot(viewDir, H), 0.0), F0), iridescenceFresnel, iridescenceFactor);\r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\nvec3 CookTorranceSpecular(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 F0, float specularWeight) {\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);\r\n    vec3 F = fresnelSchlick(max(dot(viewDir, H), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\n#endif\r\n\r\nvec3 LambertDiffuse(vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir, vec3 F0, float specularWeight) {\r\n    float NdotL = max(dot(n, lightDir), 0.0);\r\n\r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \r\n\r\n    vec3 kD = vec3(1.0) - F * specularWeight;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - metallic;\r\n    #endif\r\n    return baseColor * kD / PI;\r\n}\r\n\r\nfloat saturate(float a) {\r\n\tif (a > 1.0) return 1.0;\r\n\tif (a < 0.0) return 0.0;\r\n\treturn a;\r\n}\r\nvec3 ImprovedOrenNayarDiffuse(vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L, vec3 F0, vec3 iridescenceFresnel, float iridescenceFactor, float specularWeight) {\r\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\r\n    vec3 kD = vec3(1.0) - F * specularWeight;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - metallic;\r\n    #endif\r\n    #if defined IRIDESCENCE\r\n    kD = vec3(1.0) - mix(F, iridescenceFresnel, iridescenceFactor) * specularWeight;\r\n    kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n    vec3 diffuseColor = baseColor * kD;\r\n\t// calculate intermediary values\r\n\tfloat dotNL = saturate(dot(N, L));\r\n\tfloat dotNV = saturate(dot(N, V));\r\n\tfloat dotLV = saturate(dot(L, V));\r\n\tfloat dotLH = saturate(dot(L, H));\r\n\r\n\tfloat s = dotLV - dotNL * dotNV;\r\n\tfloat t = mix(1.0, max(max(dotNL, dotNV), 0.001), step(0.0, s));\r\n\tfloat st = s * (1.0 / (t + EPSILON));\r\n\r\n\tfloat sigma2 = a;\r\n\tvec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\r\n\tfloat B = 0.45 * sigma2 / (sigma2 + 0.09);\r\n\treturn (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI) / PI;\r\n}\r\n\r\nvec2 applyTransform(vec2 uv, mat4 textureMatrix) {\r\n    mat3 translation = mat3(1, 0, 0, 0, 1, 0, textureMatrix[0].x, textureMatrix[0].y, 1);\r\n    mat3 rotation = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\r\n    if (textureMatrix[2].x != 0.0) {\r\n        rotation = mat3(\r\n            cos(-textureMatrix[2].x), sin(-textureMatrix[2].x), 0,\r\n            -sin(-textureMatrix[2].x), cos(-textureMatrix[2].x), 0,\r\n            0, 0, 1\r\n        );\r\n    }\r\n    mat3 scale = mat3(textureMatrix[1].x, 0, 0, 0, textureMatrix[1].y, 0, 0, 0, 1);\r\n\r\n    mat3 matrix = translation * rotation * scale;\r\n    vec2 outUV = ( matrix * vec3(uv, 1.0) ).xy;\r\n    return outUV;\r\n}\r\nfloat computeWrappedDiffuseNdotL(float NdotL, float w) {\r\n    float t = 1.0+w;\r\n    float invt2 = 1.0/(t*t);\r\n    return saturate((NdotL+w)*invt2);\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value*value;\r\n    return sq*sq*value;\r\n}\r\nfloat diffuseBRDF_Burley(float NdotL, float NdotV, float VdotH, float roughness) {\r\n    float diffuseFresnelNV = pow5(saturate(1.0-NdotL)+EPSILON);\r\n    float diffuseFresnelNL = pow5(saturate(1.0-NdotV)+EPSILON);\r\n    float diffuseFresnel90 = 0.5+2.0*VdotH*VdotH*roughness;\r\n    float fresnel = (1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\r\n    (1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\r\n    return fresnel/PI;\r\n}\r\n#define absEps(x) abs(x)+EPSILON\r\n\r\nvec3 cocaLambert(vec3 alpha, float distance) {\r\n    return exp(-alpha*distance);\r\n}\r\n#define maxEps(x) max(x, EPSILON)\r\nvec3 transmittanceBRDF_Burley(const vec3 tintColor, const vec3 diffusionDistance, float thickness) {\r\n    vec3 S = 1./maxEps(diffusionDistance);\r\n    vec3 temp = exp((-0.333333333*thickness)*S);\r\n    return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\r\n}\r\n\r\nvec3 computeColorAtDistanceInMedia(vec3 color, float distance) {\r\n    return -log(color)/distance;\r\n}\r\n\r\nvoid main() {\r\n    vec2 outUV = outUV0;\r\n    #ifdef BASECOLORTEXTURE\r\n        outUV = getUV(BASECOLORTEXTURE);\r\n        #ifdef BASECOLORTEXTURE_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[BASECOLORTEXTURE_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec3 baseColor = texture2D(baseColorTexture, outUV).rgb * baseColorFactor.rgb;\r\n        float alpha = min(texture2D(baseColorTexture, outUV).a, baseColorFactor.a);\r\n    #else\r\n        vec3 baseColor = baseColorFactor.rgb;\r\n        float alpha = baseColorFactor.a;\r\n    #endif\r\n\r\n    #ifdef ALPHATEST\r\n    if ( alpha < ALPHATEST ) {\r\n        discard;\r\n    }\r\n    if ( ALPHATEST > 0.01 ) {\r\n        alpha = 1.0;\r\n    }\r\n    #else\r\n        alpha = 1.0;\r\n    #endif\r\n\r\n    if ( length(vColor.rgb) != 0.0 ) {\r\n        baseColor.rgb *= vColor.rgb;\r\n    }\r\n\r\n    #ifdef NOLIGHT\r\n        color = vec4(baseColor, alpha);\r\n        return;\r\n    #endif\r\n\r\n    float ao = 1.0;\r\n    #ifdef OCCLUSIONMAP\r\n        outUV = getUV(OCCLUSIONMAP);\r\n        #ifdef OCCLUSIONMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[OCCLUSIONMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        ao = texture2D(occlusionTexture, outUV).r;\r\n    #endif\r\n\r\n    float roughness = roughnessFactor.x;\r\n    float metallic = metallicFactor.x;\r\n    float clearcoatRoughness = clearcoatRoughnessFactor.x;\r\n    float clearcoat = clearcoatFactor.x;\r\n    float clearcoatBlendFactor = clearcoat;\r\n    vec3 sheenColor = sheenColorFactor.xyz;\r\n    float sheenRoughness = sheenRoughnessFactor.x;\r\n    float transmission = transmissionFactor.x;\r\n    float transmissionDiffuse = diffuseTransmissionFactor.x;\r\n    float thickness = thicknessFactor.x;\r\n    #ifdef DIFFUSE_TRANSMISSION_MAP\r\n        vec4 diffuseTransmissionTextureV = texture2D(diffuseTransmissionTexture, outUV);\r\n        transmissionDiffuse *= diffuseTransmissionTextureV.a;\r\n    #endif\r\n    vec3 attenuationColor = attenuationColorFactor.rgb;\r\n    vec3 tintColor = diffuseTransmissionFactor.yzw;\r\n    #ifdef DIFFUSE_TRANSMISSION_COLOR_MAP\r\n        vec4 diffuseTransmissionColorTextureV = texture2D(diffuseTransmissionColorTexture, outUV);\r\n        tintColor *= diffuseTransmissionColorTextureV.rgb;\r\n    #endif\r\n    #ifdef CLEARCOATMAP\r\n        outUV = getUV(CLEARCOATMAP);\r\n        #ifdef CLEARCOATMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[CLEARCOATMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        clearcoatBlendFactor = texture2D(clearcoatTexture, outUV).r * clearcoat;\r\n    #endif\r\n    #ifdef CLEARCOATROUGHMAP\r\n        outUV = getUV(CLEARCOATROUGHMAP);\r\n        #ifdef CLEARCOATROUGHMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[CLEARCOATROUGHMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        clearcoatRoughness = texture2D(clearcoatRoughnessTexture, outUV).g * clearcoatRoughness;\r\n    #endif\r\n    #ifdef SHEENMAP\r\n        outUV = getUV(SHEENMAP);\r\n        #ifdef SHEENMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[SHEENMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec3 sheenColorTextureV = texture2D(sheenColorTexture, outUV).rgb;\r\n        sheenColor = sheenColorTextureV * sheenColor;\r\n    #endif\r\n    #ifdef SHEENROUGHNESSMAP\r\n        outUV = getUV(SHEENROUGHNESSMAP);\r\n        #ifdef SHEENROUGHNESSMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[SHEENROUGHNESSMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n    vec4 sheenRoughnessTextureV = texture2D(sheenRoughnessTexture, outUV);\r\n    sheenRoughness = sheenRoughnessTextureV.a * sheenRoughness;\r\n    #endif\r\n    float iridescenceThickness = iridescence.z;\r\n    #ifdef IRIDESCENCEMAP\r\n        iridescenceThickness = mix(iridescence.w, iridescence.z, texture2D(iridescenceThicknessTexture, outUV).g);\r\n    #endif\r\n    #ifdef TRANSMISSIONMAP\r\n        float transmissionTextureV = texture2D(transmissionTexture, outUV).r;\r\n        transmission = transmissionTextureV * transmission;\r\n    #endif\r\n    #ifdef THICKNESSMAP\r\n        float thicknessTextureV = texture2D(thicknessTexture, outUV).g;\r\n        thickness = thicknessTextureV * thickness;\r\n    #endif\r\n    #ifdef DIFFUSE_TRANSMISSION\r\n        thickness *= 2.2;\r\n    #endif\r\n    vec3 specularMap = vec3(0);\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        #ifdef METALROUGHNESSMAP\r\n            outUV = getUV(METALROUGHNESSMAP);\r\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[METALROUGHNESSMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            roughness = 1.0 - texture2D(metallicRoughnessTexture, outUV).a;\r\n            specularMap = texture2D(metallicRoughnessTexture, outUV).rgb;\r\n        #else\r\n            roughness = glossinessFactor.x;\r\n            specularMap = specularFactor;\r\n        #endif\r\n    #else\r\n        #ifdef METALROUGHNESSMAP\r\n            outUV = getUV(METALROUGHNESSMAP);\r\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[METALROUGHNESSMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            vec4 metallicRoughness = texture2D(metallicRoughnessTexture, outUV);\r\n            roughness *= metallicRoughness.g;\r\n            metallic *= metallicRoughness.b;\r\n        #endif\r\n    #endif\r\n    float specularWeight = 1.0;\r\n    #ifdef SPECULAR\r\n        specularMap = specularColorFactor;\r\n        #ifdef SPECULARCOLORMAP\r\n        specularMap *= texture2D(specularColorTexture, outUV).rgb;\r\n        #endif\r\n        specularWeight = specularFactor.x;\r\n        #ifdef SPECULARMAP\r\n        specularWeight *= texture2D(specularTexture, outUV).a;\r\n        #endif\r\n    #endif\r\n    vec3 F0 = mix(vec3(0.04), baseColor, metallic);\r\n    #if defined(IOR) && defined(VOLUME)\r\n    F0 = vec3(pow(( ior.x - 1.0) /  (ior.x + 1.0), 2.0));\r\n    #endif\r\n    #if defined SPECULAR\r\n    F0 = mix(min(F0 * specularMap, vec3(1.0)), baseColor, metallic);\r\n    #endif\r\n    #if defined SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n        #ifdef NORMALMAP\r\n            outUV = getUV(NORMALMAP);\r\n            #ifdef NORMALMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[NORMALMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            vec3 n = texture2D(normalTexture, outUV).rgb;\r\n            n = normalize(outTBN * (2.0 * n - 1.0) * vec3(normalTextureScale.x, normalTextureScale.x, 1.0));\r\n        #else\r\n            vec3 n = normalize(outTBN[2].xyz);\r\n        #endif\r\n    #else\r\n        vec3 n = normalize(outNormal);\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n    #ifdef CLEARCOATNORMALMAP\r\n        outUV = getUV(CLEARCOATNORMALMAP);\r\n        #ifdef CLEARCOATNORMALMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[CLEARCOATNORMALMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec3 clearcoatNormal = texture2D(clearcoatNormalTexture, outUV).rgb;\r\n        clearcoatNormal = normalize(outTBN * (2.0 * clearcoatNormal - 1.0));\r\n    #else\r\n        vec3 clearcoatNormal = outTBN[2].xyz;\r\n    #endif\r\n    #else\r\n        vec3 clearcoatNormal = outNormal;\r\n    #endif\r\n\r\n    vec3 viewDir = normalize(viewPos - outPosition);\r\n\r\n    #ifdef DOUBLESIDED\r\n    if (gl_FrontFacing == false) {\r\n        n = -n;\r\n        clearcoatNormal = -clearcoatNormal;\r\n    }\r\n    #endif\r\n\r\n    float shadow = 1.0;\r\n    #ifdef SHADOWMAP\r\n        vec3 l = normalize(lightPos[0] - outPosition);\r\n        float shadowBias = max(0.05 * (1.0 - dot(n, l)), 0.005);\r\n        shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\r\n    #endif\r\n\r\n    vec3 anisotropicT = vec3(0.0);\r\n    vec3 anisotropicB = vec3(0.0);\r\n    vec3 anisotropy = anisotropyFactor.xyz;\r\n    anisotropy.yz = vec2(cos(anisotropy.y), sin(anisotropy.y));\r\n    #ifdef ANISOTROPYMAP\r\n        vec4 anisotropyTex = texture2D(anisotropyTexture, outUV);\r\n        vec2 direction = anisotropyTex.rg * 2.0 - vec2(1.0);\r\n        direction = mat2(anisotropy.y, anisotropy.z, -anisotropy.z, anisotropy.y) * normalize(direction);\r\n        anisotropy.x = anisotropyTex.b * anisotropyFactor.x;\r\n        anisotropy.yz = direction;\r\n    #endif\r\n    #ifdef TANGENT\r\n        anisotropicT = normalize(outTBN * vec3(anisotropy.yz, 0.0));\r\n        anisotropicB = normalize(cross(n, anisotropicT));\r\n    #endif\r\n\r\n    #ifdef USE_PBR\r\n        vec3 finalDiffuse = vec3(0.0);\r\n        vec3 f_sheen = vec3(0.0);\r\n        float albedoSheenScaling = 1.0;\r\n        vec3 Lo = vec3(0.0);\r\n\r\n        #ifdef DIFFUSE_TRANSMISSION\r\n        float translucencyIntensity = transmissionDiffuse;\r\n        vec3 transmittance = transmittanceBRDF_Burley(tintColor, vec3(1.0), thickness);\r\n        transmittance *= translucencyIntensity;\r\n        vec3 f_transmission = transmittance;\r\n        vec3 f_transmission2 = transmittance;\r\n        #else\r\n        vec3 f_transmission = cocaLambert(computeColorAtDistanceInMedia(attenuationColor.rgb, attenuationDistance.x), thickness) * calcTransmission(baseColor, n, roughness, viewDir, transmission, thickness);\r\n        #endif\r\n\r\n        if (isDefaultLight.x == 1.0) {\r\n            int i = LIGHTINDEX;\r\n        //for (int i = 0; i < LIGHTNUMBER; ++i) {\r\n            vec3 lightDir = normalize(lightPos[i].xyz - outPosition);\r\n            float NdotL = max(dot(n, lightDir), 0.0);\r\n            vec3 H = normalize(viewDir + lightDir);\r\n\r\n            vec3 radiance = lightColor[i].xyz * lightIntensity[i].x;\r\n            float distance = dot(lightPos[i].xyz - outPosition, lightPos[i].xyz - outPosition);\r\n            float attenuation = 1.0 / (distance * distance);\r\n            // radiance = radiance * attenuation;\r\n            if (lightIntensity[i].w == 1.0) { // point\r\n                radiance = radiance * attenuation;\r\n            }\r\n            if (lightIntensity[i].w == 2.0) { // spot\r\n                float lightAngleScale = 1.0 / max(0.001, cos(lightIntensity[i].y) - cos(lightIntensity[i].z));\r\n                float lightAngleOffset = -cos(lightIntensity[i].z) * lightAngleScale;\r\n\r\n                float cd = dot(spotdir[i].xyz, lightDir);\r\n                float attenuationSpot = saturate(cd * lightAngleScale + lightAngleOffset);\r\n                attenuationSpot *= attenuationSpot;\r\n\r\n                radiance = radiance * attenuationSpot * attenuation;\r\n            }\r\n\r\n            float NdotV = saturate(dot(n, viewDir));\r\n            vec3 iridescenceF0 = vec3(0.0);\r\n            #if defined IRIDESCENCE\r\n            vec3 iridescenceFresnel = evalIridescence(1.0, iridescence.y, NdotV, iridescenceThickness, F0);\r\n            iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\r\n            vec3 specular = CookTorranceSpecular2(baseColor, metallic, n, H, anisotropicT, anisotropicB, roughness, viewDir, lightDir, anisotropy.x, iridescenceF0, iridescence.x, F0, specularWeight);\r\n            #else\r\n            vec3 specular = CookTorranceSpecular(baseColor, metallic, n, H, anisotropicT, anisotropicB, roughness, viewDir, lightDir, anisotropy.x, F0, specularWeight);\r\n            #endif\r\n            vec3 f_clearcoat = CookTorranceSpecular(vec3(0.0), 0.0, clearcoatNormal, H, anisotropicT, anisotropicB, clearcoatRoughness, viewDir, lightDir, anisotropy.x, F0, specularWeight);\r\n            vec3 clearcoatFresnel = 1.0 - clearcoatBlendFactor * fresnelSchlick(saturate(dot(clearcoatNormal, viewDir)), vec3(0.04));\r\n            #ifndef DIFFUSE_TRANSMISSION\r\n            vec3 diffuse = ImprovedOrenNayarDiffuse(baseColor, metallic, n, H, roughness, viewDir, lightDir, F0, iridescenceF0, iridescence.x, specularWeight);\r\n            //#ifdef CLEARCOAT\r\n            diffuse *= radiance * clearcoatFresnel;\r\n            //#endif\r\n            #else\r\n            float NdotV2 = absEps(dot(n, viewDir));\r\n            float NdotL2 = absEps(dot(n, lightDir));\r\n            float VdotH = absEps(dot(viewDir, H));\r\n            float diffuse = diffuseBRDF_Burley(NdotL2, NdotV2, VdotH, roughness);\r\n            #endif\r\n            #if defined SPECULARGLOSSINESSMAP\r\n                diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\r\n            #endif\r\n            #if defined SHEEN\r\n            f_sheen = NdotL * (sheenColor * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, lightDir, sheenRoughness));\r\n            albedoSheenScaling = min(1.0 - max3(sheenColor) * E(max(dot(viewDir, n), 0.0), sheenRoughness), 1.0 - max3(sheenColor) * E(max(dot(lightDir, n), 0.0), sheenRoughness));\r\n            #endif\r\n\r\n            Lo += (specular * NdotL);\r\n            //#ifdef CLEARCOAT\r\n            Lo = Lo * radiance * clearcoatFresnel + f_clearcoat * clearcoatBlendFactor;\r\n            //#endif\r\n            vec3 diffuseLobe = vec3(diffuse);\r\n\r\n            #ifdef DIFFUSE_TRANSMISSION\r\n            float trAdapt = step(0., dot(n, lightDir));\r\n            float wrapNdotL = computeWrappedDiffuseNdotL(absEps(dot(n, lightDir)), 0.02);\r\n            vec3 transmittanceNdotL = mix(f_transmission*wrapNdotL, vec3(wrapNdotL), trAdapt);\r\n            diffuseLobe = diffuseLobe * radiance * baseColor;\r\n            diffuseLobe = mix(diffuseLobe, f_transmission * transmittanceNdotL, transmissionDiffuse);\r\n            transmission = 0.0;\r\n            f_transmission = vec3(0.0);\r\n            #else\r\n            diffuseLobe *= (1.0 - transmission);\r\n            #endif\r\n\r\n            #ifndef SCATTERING\r\n            Lo += diffuseLobe;\r\n            #endif\r\n\r\n            finalDiffuse += diffuseLobe;\r\n        //}\r\n        }\r\n\r\n        vec3 ambient = vec3(0.0);\r\n        vec3 ambientClearcoat = vec3(0.0);\r\n        vec3 clearcoatFresnel = vec3(1.0);\r\n        vec3 aSpecular;\r\n        vec3 cSpecular;\r\n        if (isIBL.x == 1.0) {\r\n            float NdotV = saturate(dot(n, viewDir));\r\n            vec3 iridescenceFresnel = evalIridescence(1.0, iridescence.y, NdotV, iridescenceThickness, F0);\r\n            vec3 iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\r\n            ambient = IBLAmbient(baseColor, metallic, n, roughness, viewDir, transmission, sheenColor, sheenRoughness, iridescenceF0, iridescence.x, F0, specularWeight, anisotropy.x, anisotropicB, f_sheen, aSpecular);\r\n            vec3 placeholder = vec3(0.0);\r\n            ambientClearcoat = IBLAmbient(vec3(0.0), 0.0, clearcoatNormal, clearcoatRoughness, viewDir, transmission, sheenColor, sheenRoughness, iridescenceF0, iridescence.x, F0, specularWeight, anisotropy.x, anisotropicB, placeholder, cSpecular) * clearcoatBlendFactor;\r\n            #ifdef DIFFUSE_TRANSMISSION\r\n            ambient = mix(ambient, f_transmission2, transmissionDiffuse);\r\n            #endif\r\n            #ifndef SPHERICAL_HARMONICS\r\n            #ifndef SCATTERING\r\n            ambient += aSpecular;\r\n            #endif\r\n            ambientClearcoat += cSpecular * clearcoatBlendFactor;\r\n            #endif\r\n            clearcoatFresnel = (1.0 - clearcoatBlendFactor * fresnelSchlick(saturate(dot(clearcoatNormal, viewDir)), vec3(0.04)));\r\n        } else {\r\n            ambient = vec3(0.03) * baseColor * 0.2;\r\n        }\r\n\r\n        vec3 emissive = emissiveFactor;\r\n        #ifdef EMISSIVEMAP\r\n            outUV = getUV(EMISSIVEMAP);\r\n            #ifdef EMISSIVEMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[EMISSIVEMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            emissive *= texture2D(emissiveTexture, outUV).rgb;\r\n        #endif\r\n        emissive *= emissiveStrength.x;\r\n\r\n        #ifdef TRANSMISSION\r\n            float kT = 1.0 - specEnv(n, viewDir, metallic, roughness, F0, specularWeight);\r\n            f_transmission = f_transmission * kT;\r\n            color = vec4((Lo) * clearcoatFresnel + ambientClearcoat, alpha);\r\n            #ifndef SCATTERING\r\n            color.rgb += (ambient * ao + emissive + f_transmission) * clearcoatFresnel;\r\n            #endif\r\n        #else\r\n            color = vec4(ao * ((emissive + Lo) * clearcoatFresnel + ambientClearcoat), alpha);\r\n            #ifndef SCATTERING\r\n            color.rgb += ambient * ao * clearcoatFresnel;\r\n            #endif\r\n        #endif\r\n\r\n        color.rgb = f_sheen + color.rgb * albedoSheenScaling;\r\n    #else\r\n        vec3 lightDir = normalize(lightPos[0].xyz - outPosition);\r\n        vec3 ambient = ambientStrength * lightColor[0].xyz;\r\n\r\n        float diff = max(dot(n, lightDir), 0.0);\r\n        vec3 diffuse = diff * lightColor[0].XYZ;\r\n\r\n        vec3 reflectDir = reflect(-lightDir, n);\r\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\r\n        vec3 specular = specularStrength * spec * lightColor[0].xyz;\r\n\r\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\r\n    #endif\r\n\r\n    #ifndef SCATTERING\r\n    if (isTone.x == 1.0) {\r\n        #ifdef SPHERICAL_HARMONICS\r\n        color.rgb  *= 4.0;\r\n        vec3 X = max(vec3(0.0, 0.0, 0.0), color.rgb - 0.004);\r\n        vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n        color.rgb = retColor * retColor;\r\n        #else\r\n        // color.rgb = color.rgb / (color.rgb + vec3(1.0));\r\n        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\r\n        #endif\r\n    }\r\n    #endif\r\n\r\n    #ifdef SPHERICAL_HARMONICS\r\n    color.rgb += aSpecular;\r\n    #endif\r\n\r\n    // normalColor = vec4(n, 0.0);\r\n\r\n    #ifdef SCATTERING\r\n    specColor = vec4(Lo + aSpecular, 1.0);\r\n\r\n    vec3 irradiance = finalDiffuse;\r\n    irradiance += ambient;\r\n    irradiance += f_transmission;\r\n    irradiance /= sqrt(baseColor.rgb);\r\n\r\n    irradianceColor = vec4(clamp(irradiance, vec3(0.), vec3(1.)), 1.0);\r\n    #ifdef TRANSMISSION\r\n    albedoColor = vec4(sqrt(attenuationColor.rgb), 1.0);\r\n    #else\r\n    albedoColor = vec4(sqrt(baseColor), 1.0);\r\n    #endif\r\n    #else\r\n    irradianceColor = vec4(0.0);\r\n    albedoColor = vec4(0.0);\r\n    specColor = vec4(0.0);\r\n    #endif\r\n}\r\n',le={POSITION:[0,3],NORMAL:[1,3],TEXCOORD_0:[2,2],JOINTS_0:[3,4],WEIGHTS_0:[4,4],TANGENT:[5,4],COLOR_0:[6,4],TEXCOORD_1:[7,2],TEXCOORD_2:[8,2]};class ce{UBO;VAO;uniformBuffer;indicesBuffer;attributes;targets;blend;uniforms;SKIN;boundingSphere;vertexAccessor;indicesWebGPUBuffer;verticesWebGPUBuffer;uniformBindGroup1;g;constructor(e,t,r,i,s){let a;this.boundingSphere={center:new n,radius:null,min:null,max:null},this.uniformBuffer=null,this.UBO=null,this.VAO=null,this.indicesBuffer=null,this.attributes=null,this.targets=null,this.blend=null,this.uniforms=null,this.SKIN=null,this.targets=[];const o={},c=e.accessors[s.indices],u=new Map;for(const t in s.attributes)u.set(t,e.accessors[s.attributes[t]]);const f={min:u.get("POSITION").min,max:u.get("POSITION").max},h=s.extensions&&s.extensions.KHR_draco_mesh_compression;if(h){const r=e.bufferViews[h.bufferView],n=new i.Decoder,s=function(e,t,r,n){const i=new ie.DecoderBuffer;i.Init(new Int8Array(e,r,n),e.byteLength);const s=new ie.Mesh;return t.DecodeBufferToMesh(i,s),ie.destroy(i),s}(t[r.buffer],n,r.byteOffset,r.byteLength),l=s.num_faces(),c=s.num_points();for(const e of u.keys()){const t=n.GetAttributeByUniqueId(s,h.attributes[e]),r=T(u.get(e).type),[a,l]=se(P(u.get(e).componentType),c*r,s,t,n);for(let e=0;e<c*r;e+=r)l[e]=a.GetValue(e),l[e+1]=a.GetValue(e+1),r>2&&(l[e+2]=a.GetValue(e+2)),r>3&&(l[e+3]=a.GetValue(e+3));i.destroy(a),o[e]=l}{a=new Uint32Array(3*l),a.type="UNSIGNED_INT";const e=new i.DracoUInt32Array;for(let t=0;t<l;++t){n.GetFaceFromMesh(s,t,e);const r=3*t;a[r]=e.GetValue(0),a[r+1]=e.GetValue(1),a[r+2]=e.GetValue(2)}i.destroy(e)}i.destroy(n),i.destroy(s)}else{if(c){const r=e.bufferViews[c.bufferView];a=v(t[r.buffer],c.componentType,U(r.byteOffset,c.byteOffset),T(c.type)*c.count)}for(const r of u.keys()){const n=u.get(r),i=e.bufferViews[n.bufferView];o[r]=x(t[i.buffer],n,i)}}if(s.targets){for(const r of s.targets){const n={};for(const i in r){n[i]=e.accessors[r[i]];const s=n[i],a=e.bufferViews[s.bufferView];n[i]=x(t[a.buffer],s,a)}this.targets.push(n)}for(const e of u.keys())if(this.targets[0][e]){let t=0;const n=o[e];o[e]=new n.constructor(n.length);for(let i=0;i<o[e].length;i++)"TANGENT"!==e||(i+1)%4!=0?o[e][i]=n[i]+r.reduce((n,s,a)=>n+r[a]*this.targets[a][e][i-t],0):t++}}for(const r of u.keys()){const n=u.get(r);if("COLOR_0"===r&&"VEC3"===n.type){const e=new o[r].constructor(4*n.count);let t=0;for(let n=0;n<e.length;n++)(n+1)%4==0?e[n]=1:(e[n]=o[r][t],t++);o[r]=e}if(void 0!==n.sparse){const i=T(n.type),s=e.bufferViews[n.sparse.indices.bufferView],a=e.bufferViews[n.sparse.values.bufferView],l=v(t[s.buffer],n.sparse.indices.componentType,U(s.byteOffset,n.sparse.indices.byteOffset),n.sparse.count),c=v(t[a.buffer],n.componentType,U(a.byteOffset,n.byteOffset),T(n.type)*n.sparse.count);for(let e=0,t=l.length;e<t;e++){const t=l[e];o[r][t*i]=c[e*i],i>=2&&(o[r][t*i+1]=c[e*i+1]),i>=3&&(o[r][t*i+2]=c[e*i+2]),i>=4&&(o[r][t*i+3]=c[e*i+3])}}}void 0===o.NORMAL&&a&&(o.NORMAL=function(e,t){const r=new Float32Array(t.length/3*3);for(let s=0;s<e.length;s+=3){const a=[e[s],e[s+1],e[s+2]].map(e=>i(t,e)),o=a[1].subtract(a[0]),l=a[2].subtract(a[0]),c=n.cross(o.normalize(),l.normalize()),[u,f,h]=c.elements;for(let t=0;t<3;t++)r[3*e[s+t]+0]=r[3*e[s+t]+0]+u,r[3*e[s+t]+1]=r[3*e[s+t]+1]+f,r[3*e[s+t]+2]=r[3*e[s+t]+2]+h}return r;function i(e,t,r=3){return new n([e[t*=r],e[t+1],e[t+2]])}}(a,o.POSITION),u.set("NORMAL",{componentType:5126})),void 0===o.NORMAL&&void 0===a&&(o.NORMAL=function(e){const t=new Float32Array(e.length);for(let r=0;r<e.length;r+=9){const i=[new n([e[r],e[r+1],e[r+2]]),new n([e[r+3],e[r+4],e[r+5]]),new n([e[r+6],e[r+7],e[r+8]])],s=i[1].subtract(i[0]),a=i[2].subtract(i[0]),o=n.cross(s.normalize(),a.normalize()),[l,c,u]=o.elements;t[r]=l,t[r+1]=c,t[r+2]=u,t[r+3]=l,t[r+4]=c,t[r+5]=u,t[r+6]=l,t[r+7]=c,t[r+8]=u}return t}(o.POSITION),u.set("NORMAL",{componentType:5126})),void 0===o.TEXCOORD_0&&a&&(o.TEXCOORD_0=function(e,t){const r=new Float32Array(e.length/3*2),i=new l([1/0,1/0]),s=new l([-1/0,-1/0]);for(let a=0;a<e.length/3;++a){const o=[],l=[];for(let r=0;r<3;++r)o.push(e[3*a+r]),l.push(t[3*a+r]);const c=new n(l),u=["x","y","z"].sort((e,t)=>Math.abs(c[e])-Math.abs(c[t])),f=new n(o),h=f[u[0]],m=f[u[1]];r[2*a]=h,r[2*a+1]=m,s.x=Math.max(s.x,h),s.y=Math.max(s.y,m),i.x=Math.min(i.x,h),i.y=Math.min(i.y,m)}const a=new l(s.elements).subtract(i);for(let t=0;t<e.length/3;++t){const e=2*t;r[e]=(r[e]-i.x)/a.x,r[e+1]=(r[e+1]-i.y)/a.y}return r}(o.POSITION,o.NORMAL),u.set("TEXCOORD_0",{componentType:5126})),void 0===s.attributes.TANGENT&&a&&(o.TANGENT=function(e,t,r,i){const s=new Float32Array(r.length/3*4);for(let r=0;r<e.length;r+=3){const l=[e[r],e[r+1],e[r+2]],c=l.map(e=>a(t,e)),u=l.map(e=>a(i,e,2)),f=c[1].subtract(c[0]),h=c[2].subtract(c[0]),m=u[1].subtract(u[0]),d=u[2].subtract(u[0]);let p=m.elements[0]*d.elements[1]-m.elements[1]*d.elements[0];const T=p>0?1:-1;p=0!==p?1/p:1;const E=new n([(d.elements[1]*f.elements[0]-m.elements[1]*h.elements[0])*p,(d.elements[1]*f.elements[1]-m.elements[1]*h.elements[1])*p,(d.elements[1]*f.elements[2]-m.elements[1]*h.elements[2])*p]);E.normalize(),l.forEach(e=>{o(s,e,E,T)})}return s;function a(e,t,r=3){return t*=r,3===r?new n([e[t],e[t+1],e[t+2]]):2===r?new l([e[t],e[t+1]]):void 0}function o(e,t,r,n,i=4,s=(e,t)=>e+t){t*=i;for(let a=0;a<i;++a)e[t+a]=3===a?n:s(e[t+a],r.elements[a])}}(a,o.POSITION,o.NORMAL,o.TEXCOORD_0),u.set("TANGENT",{componentType:5126})),this.vertexAccessor=u,this.attributes=o,this.indicesBuffer=a;const{min:m,max:d}=f;this.boundingSphere.min=new n(m),this.boundingSphere.max=new n(d)}createGeometryForWebGPU(e){const{device:t}=e;let r=12;const n=this.attributes.POSITION.length/3,i=new Float32Array(3*n+2*n+3*n+4*n+(this.attributes.JOINTS_0?.length??0)+(this.attributes.WEIGHTS_0?.length??0)+(this.attributes.COLOR_0?.length??0)+(this.attributes.TEXCOORD_1?.length??0));this.attributes.WEIGHTS_0&&(r+=8),this.attributes.COLOR_0&&(r+=4),this.attributes.TEXCOORD_1&&(r+=2);let s=0,a=0,o=0;for(let e=0;e<i.length;e+=r)i[e]=this.attributes.POSITION[s],i[e+1]=this.attributes.POSITION[s+1],i[e+2]=this.attributes.POSITION[s+2],this.attributes.TEXCOORD_0&&(i[e+3]=this.attributes.TEXCOORD_0[a],i[e+4]=this.attributes.TEXCOORD_0[a+1]),i[e+5]=this.attributes.NORMAL[s],i[e+6]=this.attributes.NORMAL[s+1],i[e+7]=this.attributes.NORMAL[s+2],this.attributes.TANGENT&&(i[e+8]=this.attributes.TANGENT[o],i[e+9]=this.attributes.TANGENT[o+1],i[e+10]=this.attributes.TANGENT[o+2],i[e+11]=this.attributes.TANGENT[o+3]),this.attributes.WEIGHTS_0&&(i[e+12]=this.attributes.JOINTS_0[o],i[e+13]=this.attributes.JOINTS_0[o+1],i[e+14]=this.attributes.JOINTS_0[o+2],i[e+15]=this.attributes.JOINTS_0[o+3],i[e+16]=this.attributes.WEIGHTS_0[o],i[e+17]=this.attributes.WEIGHTS_0[o+1],i[e+18]=this.attributes.WEIGHTS_0[o+2],i[e+19]=this.attributes.WEIGHTS_0[o+3]),this.attributes.COLOR_0&&(i[e+12]=this.attributes.COLOR_0[o],i[e+13]=this.attributes.COLOR_0[o+1],i[e+14]=this.attributes.COLOR_0[o+2],i[e+15]=this.attributes.COLOR_0[o+3]),this.attributes.TEXCOORD_1&&(i[e+12]=this.attributes.TEXCOORD_1[a],i[e+13]=this.attributes.TEXCOORD_1[a+1]),s+=3,a+=2,o+=4;this.g=i;const l=t.createBuffer({size:i.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(l.getMappedRange()).set(i),l.unmap(),this.verticesWebGPUBuffer=l,this.indicesBuffer){this.indicesBuffer=new Uint32Array(this.indicesBuffer);const e=t.createBuffer({size:this.indicesBuffer.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint32Array(e.getMappedRange()).set(this.indicesBuffer),e.unmap(),this.indicesWebGPUBuffer=e}}createGeometryForWebGl(e){const t=e.createVertexArray();e.bindVertexArray(t);for(const t in this.attributes){const r=this.vertexAccessor.get(t),n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,this.attributes[t],e.STATIC_DRAW);const i=le[t];e.enableVertexAttribArray(i[0]),e.vertexAttribPointer(i[0],i[1],r.componentType,!1,0,0)}if(this.indicesBuffer){const t=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,this.indicesBuffer,e.STATIC_DRAW)}this.VAO=t,e.bindVertexArray(null)}calculateBounding(e){this.boundingSphere.min.applyMatrix4(e),this.boundingSphere.max.applyMatrix4(e);const t=this.attributes.POSITION;let r=0;this.boundingSphere.center.add(this.boundingSphere.min).add(this.boundingSphere.max).scale(.5);for(let e=0;e<t.length;e+=3)r=Math.max(r,this.boundingSphere.center.distanceToSquared(t[e],t[e+1],t[e+2]));this.boundingSphere.radius=Math.sqrt(r)}createUniforms(e,r,n){const i=new t(e);i.invert().transpose();const s=new O;s.add("model",e.elements),s.add("normalMatrix",i.elements),s.add("view",r.matrixWorldInvert.elements),s.add("projection",r.projection.elements),s.add("light",n.matrixWorldInvert.elements),s.add("isShadow",0),s.done(),this.uniformBuffer=s}updateUniformsWebGPU(e){const t=this.uniformBuffer.store.byteLength,r=256+t,{device:n}=e,i=n.createBuffer({size:r,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.uniformBuffer.bufferWebGPU=i;const s=[{binding:0,resource:{buffer:i,offset:0,size:t}}];n.queue.writeBuffer(i,0,this.uniformBuffer.store.buffer,this.uniformBuffer.store.byteOffset,this.uniformBuffer.store.byteLength),this.uniformBindGroup1=s}updateUniformsWebGl(e,t){const r=e.getUniformBlockIndex(t,"Matrices");e.uniformBlockBinding(t,r,0);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.uniformBuffer.store,e.DYNAMIC_DRAW),this.UBO=n,e.bindBuffer(e.UNIFORM_BUFFER,null)}async updateWebGPU(e,t){const{device:r,commandEncoder:n}=e;let i=0,s=0,a=0;const{g:o}=this;for(let e=0;e<o.length;e+=12)t.POSITION&&(o[e]=t.POSITION[i],o[e+1]=t.POSITION[i+1],o[e+2]=t.POSITION[i+2]),t.TEXCOORD_0&&(o[e+3]=t.TEXCOORD_0[s],o[e+4]=t.TEXCOORD_0[s+1]),t.NORMAL&&(o[e+5]=t.NORMAL[i],o[e+6]=t.NORMAL[i+1],o[e+7]=t.NORMAL[i+2]),t.TANGENT&&(o[e+8]=t.TANGENT[a],o[e+9]=t.TANGENT[a+1],o[e+10]=t.TANGENT[a+2],o[e+11]=t.TANGENT[a+3]),i+=3,s+=2,a+=4;const l=r.createBuffer({size:o.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Float32Array(l.getMappedRange()).set(o),l.unmap(),n.copyBufferToBuffer(l,0,this.verticesWebGPUBuffer,0,o.byteLength)}update(e,t){e.bindVertexArray(this.VAO);for(const r in t){const n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t[r],e.STATIC_DRAW);const i=le[r];e.enableVertexAttribArray(i[0]),e.vertexAttribPointer(i[0],i[1],e[g.get(this.attributes[r].constructor)],!1,0,0)}e.bindVertexArray(null)}}let ue;class fe{tracks;url;host;skins;textures;images;samplers;arrayBuffer;cameras;lights;programs;scene;camera;light;aspect;zoom;canvas;resize;json;defines;draco;constructor(e,t,r){this.url=e,this.host=e.substr(0,e.lastIndexOf("/")+1),this.tracks=[],this.skins=[],this.textures=null,this.images=new Map,this.samplers=null,this.arrayBuffer=null,this.cameras=[],this.lights=[],this.programs={},this.defines=t,this.resize=r}setScene(e){this.scene=e}setGl(e){ue=e}setCamera(e){this.camera=e}setLight(e){this.light=e}setCanvas(e){this.canvas=e}getBuffer(){return Promise.all(this.scene.bin.map(e=>{if("string"==typeof e){if(/base64/.test(e)){const t=e.indexOf(";base64,")+8,r=e.substring(t),n=window.atob(r),i=new ArrayBuffer(n.length),s=new Uint8Array(i);for(let e=0;e<n.length;e++)s[e]=n.charCodeAt(e);return i}return ne(`${this.host}${e}`)}return Promise.resolve(e)})).then(e=>{this.arrayBuffer=e})}createProgram(e){let t;const r=e.map(e=>`${e.name}${e.value??1}`).join("");if(this.programs[r])t=this.programs[r];else{const n=e.map(e=>`#define ${e.name} ${e.value??1}\n`).join(""),i=[ae,oe].map(e=>e.replace(/#include ".*/g,e=>{const[,t]=e.split('"');return t.includes("vert")?"#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec3 inNormal;\r\nlayout (location = 2) in vec2 inUV;\r\nlayout (location = 3) in vec4 inJoint;\r\nlayout (location = 4) in vec4 inWeight;\r\nlayout (location = 5) in vec4 inTangent;\r\nlayout (location = 6) in vec4 inColor;\r\nlayout (location = 7) in vec2 inUV2;\r\nlayout (location = 8) in vec2 inUV3;\r\n\r\nout vec4 vColor;\r\nout vec2 outUV0;\r\nout vec2 outUV2;\r\nout vec2 outUV3;\r\nout vec3 outPosition;\r\nout vec4 outPositionView;\r\n#ifdef TANGENT\r\n    out mat3 outTBN;\r\n#else\r\n    out vec3 outNormal;\r\n#endif\r\n\r\nuniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n\r\n#ifdef JOINTNUMBER\r\nuniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif":"#version 300 es\r\nprecision highp float;\r\n\r\n// #ifdef DIFFUSE_TRANSMISSION\r\n//     #define SCATTERING 1\r\n// #endif\r\n\r\n#define texture2D(p, uv) texture(p, uv)\r\n#define textureCube(p, uv) texture(p, uv)\r\n#define textureLodCube(p, uv, i) textureLod(p, uv, i)\r\n#define textureLod2D(p, uv, i) textureLod(p, uv, i)\r\n\r\nin vec4 vColor;\r\nin vec2 outUV0;\r\nin vec2 outUV2;\r\nin vec2 outUV3;\r\nin vec3 outPosition;\r\nin vec4 outPositionView;\r\n#ifdef TANGENT\r\n    in mat3 outTBN;\r\n#else\r\n    in vec3 outNormal;\r\n#endif\r\n\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec4 normalColor;\r\nlayout (location = 2) out vec4 irradianceColor;\r\nlayout (location = 3) out vec4 albedoColor;\r\nlayout (location = 4) out vec4 specColor;\r\n\r\nuniform Material {\r\n    vec4 baseColorFactor;\r\n    vec3 viewPos;\r\n    vec3 specularFactor;\r\n    vec3 specularColorFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenRoughnessFactor;\r\n    vec4 transmissionFactor;\r\n    vec4 ior;\r\n    vec4 normalTextureScale;\r\n    vec4 attenuationColorFactor; \r\n    vec4 attenuationDistance; \r\n    vec4 thicknessFactor;\r\n    vec4 emissiveStrength;\r\n    vec4 anisotropyFactor;\r\n    vec4 iridescence;\r\n    vec4 diffuseTransmissionFactor;\r\n    vec4 dispersionFactor;\r\n};\r\nuniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\nuniform LightColor {\r\n    vec4 lightColor[LIGHTNUMBER];\r\n};\r\nuniform Spotdir {\r\n    vec4 spotdir[LIGHTNUMBER];\r\n};\r\nuniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\nuniform LightPos {\r\n    vec4 lightPos[LIGHTNUMBER];\r\n};\r\n#if defined MATRICES\r\nuniform TextureMatrices {\r\n    mat4 textureMatrices[MATRICES];\r\n};\r\n#endif\r\nuniform SphericalHarmonics {\r\n    vec4 vSphericalL00;\r\n    vec4 vSphericalL1_1;\r\n    vec4 vSphericalL10;\r\n    vec4 vSphericalL11;\r\n    vec4 vSphericalL2_2;\r\n    vec4 vSphericalL2_1;\r\n    vec4 vSphericalL20;\r\n    vec4 vSphericalL21;\r\n    vec4 vSphericalL22;\r\n    mat4 rotationMatrix;\r\n};\r\n\r\nuniform sampler2D baseColorTexture;\r\nuniform sampler2D metallicRoughnessTexture;\r\nuniform sampler2D normalTexture;\r\nuniform sampler2D emissiveTexture;\r\nuniform sampler2D occlusionTexture;\r\nuniform sampler2D clearcoatTexture;\r\nuniform sampler2D clearcoatRoughnessTexture;\r\nuniform sampler2D transmissionTexture;\r\nuniform sampler2D sheenColorTexture;\r\nuniform sampler2D sheenRoughnessTexture;\r\nuniform sampler2D iridescenceThicknessTexture;\r\nuniform sampler2D clearcoatNormalTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D specularColorTexture;\r\nuniform sampler2D thicknessTexture;\r\nuniform sampler2D diffuseTransmissionTexture;\r\nuniform sampler2D diffuseTransmissionColorTexture;\r\nuniform sampler2D anisotropyTexture;\r\n\r\nuniform samplerCube prefilterMap;\r\nuniform samplerCube charlieMap;\r\nuniform sampler2D brdfLUT;  \r\nuniform samplerCube irradianceMap;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D colorTexture;\r\nuniform vec2 isTone;\r\nuniform vec2 isIBL;\r\nuniform vec2 isDefaultLight;\r\nuniform sampler2D Sheen_E;\r\n"})).map(e=>e.replace(/\n/,`\n${n}`));this.programs[r]=b(i[0],i[1]),t=this.programs[r]}return t}buildPrim(e,t,r,n,i,s){const a=this.json.materials&&this.json.materials[s.material];this.json.extensions&&this.json.extensions.EXT_lights_image_based&&this.defines.push({name:"SPHERICAL_HARMONICS",value:Math.ceil(Math.log(this.json.extensions.EXT_lights_image_based.lights[0].specularImageSize)*Math.LOG2E)+10}),this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_texture_basisu")&&this.defines.push({name:"BASISU"});const o=[...this.defines],l=new D(a,this.textures,o,this.lights);void 0!==n&&o.push({name:"JOINTNUMBER",value:this.skins[n].jointNames.length}),void 0===s.indices&&void 0===s.attributes.TANGENT||o.push({name:"TANGENT"}),void 0===s.attributes.TEXCOORD_1&&void 0===s.attributes.TEXCOORD_2||o.push({name:"MULTIUV"}),s.attributes.COLOR_0&&o.push({name:"COLOR"});const c=void 0!==n?new I(r,t):new F(r,t),u=new ce(this.json,this.arrayBuffer,i,this.draco,s);if(u.attributes.COLOR_0&&u.attributes.COLOR_0.constructor!==Float32Array&&o.push({name:"COLOR_255"}),void 0===s.attributes.TANGENT&&o.push({name:"USERIGHTHANDEDSYSTEM"}),s.extensions&&s.extensions.KHR_materials_variants){const e=s.extensions.KHR_materials_variants.mappings.map(e=>({...e,m:new D(this.json.materials[e.material],this.textures,[...o],this.lights)}));c.setVariants(e)}return c.setMode(s.mode),c.setMaterial(l),c.setGeometry(u),e.scale&&e.scale[0]<0&&c.setFrontFace(),e.scale&&l.thicknessFactor&&(l.thicknessFactor*=e.scale[0]),c.setDefines(l.defines),c instanceof I&&(c.skin=n),c.updateMatrix(),c.calculateBounding(),c}buildNode(e,t){const r=this.json.nodes[t];let n;if(void 0!==r.camera){const i=Object.assign({zoom:1,aspect:this.canvas?this.canvas.offsetWidth/this.canvas.offsetHeight:1},this.json.cameras[r.camera]);n=new C(i,t,e);const s=A(n.props);n.setProjection(s),this.cameras.push(n)}else if(r.extensions&&r.extensions.KHR_lights_punctual){const i=this.json.extensions.KHR_lights_punctual.lights[r.extensions.KHR_lights_punctual.light];i.isInitial=!1,n=new L(i,t,e),this.lights.push(n)}else n=void 0!==r.isBone?new M(t,e):new u(t,e);r.translation||r.rotation||r.scale?n.setPosition(r.translation,r.rotation,r.scale):r.matrix&&n.setMatrix(r.matrix),n.updateMatrix(),n.id=r.name,e.children.push(n),e=n,void 0!==r.mesh&&e.children.push(...this.json.meshes[r.mesh].primitives.map(this.buildPrim.bind(this,r,e,this.json.meshes[r.mesh].name,r.skin,this.json.meshes[r.mesh].weights))),r.children&&r.children.length&&r.children.forEach(this.buildNode.bind(this,e))}calculateFov(e){const r=new a;S(this.scene,e=>{e instanceof F&&r.expand(e.geometry.boundingSphere)});const i=r.getSize();if(e){const e=(new n).add(r.min).add(r.max).scale(.5),i=new t;i.translate(e.x,e.y,e.z),i.invert(),this.scene.matrixWorld.multiply(i),S(this.scene,e=>{e instanceof u&&e.updateMatrix()})}this.cameras.forEach(e=>{e.modelSize=i}),this.resize()}async buildMesh(){this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_draco_mesh_compression")&&(this.draco=await new Promise(e=>{const t={onModuleLoaded(t){ie=t,e(ie)}};i.e(621).then(i.bind(i,252)).then(e=>e.default(t))})),this.json.extensions&&this.json.extensions.KHR_materials_variants&&(this.scene.variants=this.json.extensions.KHR_materials_variants.variants),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].extensions&&this.buildNode(this.scene,e)}),0===this.lights.length&&this.light&&this.lights.push(this.light),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].children&&this.json.nodes[e].children.length&&!this.json.nodes[e].extensions&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].mesh&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].camera&&this.buildNode(this.scene,e)}),S(this.scene,e=>{if(e instanceof F&&(e.material.alpha?this.scene.transparentChildren.push(e):this.scene.opaqueChildren.push(e),this.scene.meshes.push(e),e.material.defines.push({name:"LIGHTNUMBER",value:this.lights.length}),e.material.defines.push({name:"LIGHTINDEX",value:0})),e instanceof L){const t=this.lights.findIndex(t=>t===e);e.parent.children.forEach(e=>{e instanceof F&&(e.material.defines.find(e=>"LIGHTINDEX"===e.name).value=t)})}}),this.scene.opaqueChildren.sort((e,t)=>e.distance-t.distance),this.scene.transparentChildren.sort((e,t)=>e.distance-t.distance)}buildAnimation(){if(!this.json.animations)return!0;for(const e of this.json.animations){const t=[];for(const r of e.channels){const n=0,i=e.samplers[r.sampler];if(i){const{target:s}=r;let a=s.node,o=s.path;if(void 0===a){const e=s.extensions.KHR_animation_pointer.pointer.split("/"),t=this.json.materials[e[2]].name;a=this.scene.meshes.find(e=>e.material.name===t).name,o=e[e.length-1]}const l=void 0!==e.parameters?e.parameters[i.input]:i.input,c=void 0!==e.parameters?e.parameters[i.output]:i.output,f=this.json.accessors[l],h=this.json.accessors[c],m=this.json.bufferViews[f.bufferView],d=this.json.bufferViews[h.bufferView],p=v(this.arrayBuffer[m.buffer],f.componentType,U(m.byteOffset,f.byteOffset),T(f.type)*f.count),E=v(this.arrayBuffer[d.buffer],h.componentType,U(d.byteOffset,h.byteOffset),T(h.type)*h.count),g=[];S(this.scene,e=>{e.name===a&&("weights"===o&&e instanceof u?g.push(...e.children):g.push(e))});let x=T(h.type)||g[0].geometry.targets.length;"CUBICSPLINE"===i.interpolation&&(x*=3);const R=[];for(let e=0;e<p.length;e++){const t=p[e],r=E.slice(e*x,(e+1)*x);R.push({time:t,value:N(r)})}R.length>=2&&g.length&&t.push({duration:Math.max(R[R.length-1].time,n),stoped:!1,meshes:g,component:x,type:o,name:`${g[0].name}.${o}`,keys:R,interpolation:i.interpolation})}}this.tracks.push(t)}}buildSkin(){if(!this.json.skins)return!0;for(const e of this.json.skins){const r=this.json.accessors[e.inverseBindMatrices],n=this.json.bufferViews[r.bufferView],i=v(this.arrayBuffer[n.buffer],r.componentType,U(n.byteOffset,r.byteOffset),T(r.type)*r.count),s={jointNames:e.joints,inverseBindMatrices:i,bones:[],boneInverses:[]};let a=0;for(const e of s.jointNames){this.json.nodes[e].isBone=!0;const r=s.inverseBindMatrices,n=(new t).set(r.slice(16*a,16*(a+1)));s.boneInverses.push(n),a++}this.skins.push(s)}}getJson(){return/glb/.test(this.url)?ne(this.url).then(e=>{const t=new TextDecoder("utf-8"),[r]=new Uint32Array(e,12,1),n=new Uint8Array(e,20,r),i=JSON.parse(t.decode(n)),[s]=new Uint32Array(e,20+r,1),a=e.slice(28+r,28+r+s);this.json=i,this.scene.bin.push(a)}):(e=this.url,"undefined"!=typeof window?window.fetch(e).then(e=>e.json()):new Promise(t=>{te.readFile(e,"utf8",(e,r)=>{if(e)throw e;t(JSON.parse(r))})})).then(e=>{for(const t in e.buffers)this.scene.bin.push(e.buffers[t].uri);return this.json=e,!0});var e}createSamplers(){const e=this.json.samplers||[{}];this.samplers=e.map(e=>{const t=ue.createSampler();return ue.samplerParameteri(t,ue.TEXTURE_MIN_FILTER,e.minFilter||ue.NEAREST_MIPMAP_LINEAR),ue.samplerParameteri(t,ue.TEXTURE_MAG_FILTER,e.magFilter||ue.LINEAR),ue.samplerParameteri(t,ue.TEXTURE_WRAP_S,e.wrapS||ue.REPEAT),ue.samplerParameteri(t,ue.TEXTURE_WRAP_T,e.wrapT||ue.REPEAT),t})}createSamplersWebGPU(e){function t(e){return{9729:"linear",9728:"nearest",10497:"repeat",33648:"mirror-repeat",33071:"clamp-to-edge"}[e]}const r=this.json.samplers||[{}];this.samplers=r.map(r=>e.device.createSampler({magFilter:t(r.minFilter)||"linear",minFilter:t(r.magFilter)||"linear",addressModeU:t(r.wrapS)||"repeat",addressModeV:t(r.wrapT)||"repeat",addressModeW:t(r.wrapS)||"repeat"}))}createTexturesWebGPU(e){this.createTextures(this.handleTextureLoadedWebGPU.bind(this,e))}createTexturesWebGL(){this.createTextures(this.handleTextureLoaded.bind(this))}createTextures(e){this.scene.meshes.forEach(t=>{const r=[t.material,...t.variants.map(e=>e.m)],n=["baseColorTexture","metallicRoughnessTexture","emissiveTexture","normalTexture","occlusionTexture","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","sheenColorTexture","sheenRoughnessTexture","transmissionTexture","specularTexture","specularColorTexture","thicknessTexture","iridescenceThicknessTexture","diffuseTransmissionTexture","diffuseTransmissionColorTexture","anisotropyTexture"],i=["baseColorTexture","sheenColorTexture","emissiveTexture",t.defines.find(e=>"SPECULARGLOSSINESSMAP"===e.name)&&"metallicRoughnessTexture"];for(let t=0;t<n.length;t++)for(const s of r){const r=n[t],a=s[r];a&&(i.find(e=>e===r)&&(a.srgb=!0),s[r]=e(a,r))}})}async initTextures(e){if(!this.json.textures)return!0;const t={};let r=!1;this.json.textures.forEach(e=>{e.extensions&&e.extensions.KHR_texture_basisu&&(r=!0);let n=e.extensions&&e.extensions.KHR_texture_basisu?e.extensions.KHR_texture_basisu.source:e.source;n=e.extensions&&e.extensions.EXT_texture_webp?e.extensions.EXT_texture_webp.source:n;const i=String(e.sampler)+String(n);t[i]=e,t[i].name=i,e.name=i}),r&&((await i.e(971).then(i.bind(i,606))).default({preinitializedWebGLContext:ue}).then(e=>{const t={astcSupported:ue.getExtension("WEBGL_compressed_texture_astc"),etc1Supported:ue.getExtension("WEBGL_compressed_texture_etc1"),etc2Supported:ue.getExtension("WEBGL_compressed_texture_etc"),dxtSupported:ue.getExtension("WEBGL_compressed_texture_s3tc"),bptcSupported:ue.getExtension("EXT_texture_compression_bptc"),pvrtcSupported:ue.getExtension("WEBGL_compressed_texture_pvrtc")||ue.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")};window.LIBKTX=e,window.LIBKTX.transcoderConfig=t,window.LIBKTX.GL.makeContextCurrent(window.LIBKTX.GL.registerContext(ue,{majorVersion:2}))}),await new Promise(e=>setTimeout(e,1e3)));const n=Object.values(t).map(t=>{let r=t.extensions&&t.extensions.KHR_texture_basisu?t.extensions.KHR_texture_basisu.source:t.source;r=t.extensions&&t.extensions.EXT_texture_webp?t.extensions.EXT_texture_webp.source:r;const n=this.json.images[r];return function(e,t,{bufferView:r,mimeType:n,uri:i},{url:s,name:a},o){return"undefined"!=typeof window?new Promise((l,c)=>{if("image/ktx2"===n)window.fetch(s).then(e=>e.arrayBuffer()).then(e=>{l({sampler:o,mimeType:n,name:a,image:re(e)})});else{const u=new Image;if(u.onload=()=>{e?createImageBitmap(u).then(e=>{l({sampler:o,name:a,bitmap:e})}):l({sampler:o,name:a,image:u})},u.onerror=()=>{c(new Error("Cant load texture"))},u.crossOrigin="anonymous",void 0!==r){const e=t.json.bufferViews[r],i=new Uint8Array(t.arrayBuffer[e.buffer],e.byteOffset,e.byteLength),s=new Blob([i],{type:n});u.src=URL.createObjectURL(s)}else/base64/.test(i)?u.src=i:u.src=s}}):new Promise(e=>{te.readFile(s,(t,r)=>{if(t)throw t;e({sampler:o,url:s,name:a,image:new Uint8Array(r).buffer})})})}(e,this,n,{url:`${this.host}${n.uri}`,name:t.name},t.sampler)});return Promise.all(n).then(e=>(this.textures=this.json.textures.map(t=>e.find(e=>e.name===t.name)),!0))}handleTextureLoadedWebGPU(e,{bitmap:t,sampler:r},n){const{device:i}=e,s=this.samplers[void 0!==r?r:0],a=i.createTexture({label:n,size:[t.width,t.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return i.queue.copyExternalImageToTexture({source:t},{texture:a,mipLevel:0,origin:{x:0,y:0,z:0}},{width:t.width,height:t.height,depthOrArrayLayers:1}),a.sampler=s,a}handleTextureLoaded({image:e,name:t,mimeType:r,sampler:n,srgb:i}){const s=this.samplers[void 0!==n?n:0];if(r)return e.sampler=s,e;if(this.images.get(t))return this.images.get(t);const a=ue.createTexture();return a.name=t,a.image=e.src.substr(e.src.lastIndexOf("/")),a.sampler=s,ue.activeTexture(ue.TEXTURE31),ue.bindTexture(ue.TEXTURE_2D,a),ue.pixelStorei(ue.UNPACK_COLORSPACE_CONVERSION_WEBGL,ue.NONE),ue.texImage2D(ue.TEXTURE_2D,0,i?ue.SRGB8_ALPHA8:ue.RGBA,ue.RGBA,ue.UNSIGNED_BYTE,e),ue.generateMipmap(ue.TEXTURE_2D),this.images.set(t,a),a}async getEnv(e){if(this.json.extensions&&this.json.extensions.EXT_lights_image_based){const[t]=this.json.extensions.EXT_lights_image_based.lights;if(t.specularImages=t.specularImages.map(e=>e.map(e=>{const t=this.json.images[e],r=this.json.bufferViews[t.bufferView],{buffer:n,byteLength:i,byteOffset:s}=r,a=new Uint8Array(this.arrayBuffer[n],s,i),o=new Blob([a],{type:t.mimeType}),l=window.URL.createObjectURL(o),c=new Image;return c.src=l,c})),await new Promise(e=>setTimeout(e,200)),e)for(const e of t.specularImages)for(const t of e)t.bitmap=await createImageBitmap(t);return t}}}class he{counterEl;fps;elapsedTime;lastTime;constructor(){this.counterEl=document.createElement("div"),this.counterEl.setAttribute("style","position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;"),document.body.appendChild(this.counterEl),this.fps=0,this.elapsedTime=0,this.lastTime=0}tick(e){this.fps++,this.elapsedTime+=e-this.lastTime,this.lastTime=e,this.elapsedTime>=1e3&&(this.counterEl.innerHTML=String(this.fps),this.fps=0,this.elapsedTime-=1e3)}}class me{canvas;camera;light;framebuffer;setCanvas(e){this.canvas=e}setCamera(e){this.camera=e}setLight(e){this.light=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}}let de,pe,Te;class Ee extends me{texture;program;scale;quadVAO;constructor(){super(),this.scale=2}setGL(e){de=e}preProcessing(e){de.clear(de.COLOR_BUFFER_BIT|de.DEPTH_BUFFER_BIT),e.renderScene({isprepender:!0}),de.bindFramebuffer(de.FRAMEBUFFER,this.framebuffer),de.framebufferTexture2D(de.FRAMEBUFFER,de.COLOR_ATTACHMENT0,de.TEXTURE_2D,this.texture,0),de.useProgram(this.program),de.viewport(0,0,this.width/this.scale,this.height/this.scale),de.bindVertexArray(this.quadVAO);const r=A(Object.assign({},this.camera.props,{zoom:1}));de.uniformMatrix4fv(de.getUniformLocation(this.program,"Iproj"),!1,(new t).setInverseOf(r).elements),de.uniformMatrix4fv(de.getUniformLocation(this.program,"proj"),!1,r.elements),de.uniformMatrix4fv(de.getUniformLocation(this.program,"Iview"),!1,this.camera.matrixWorld.elements),de.uniformMatrix4fv(de.getUniformLocation(this.program,"view"),!1,this.camera.matrixWorldInvert.elements),de.uniformMatrix4fv(de.getUniformLocation(this.program,"light"),!1,this.light.matrixWorldInvert.elements),de.uniform1i(de.getUniformLocation(this.program,"lightTexture"),e.preDepthTexture.index),de.uniform1i(de.getUniformLocation(this.program,"cameraTexture"),e.depthTexture.index),de.uniform3fv(de.getUniformLocation(this.program,"viewPos"),this.camera.getPosition()),de.uniform3fv(de.getUniformLocation(this.program,"lightPos"),this.light.getPosition()),de.drawArrays(de.TRIANGLE_STRIP,0,4),de.bindFramebuffer(de.FRAMEBUFFER,null),de.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){this.framebuffer=de.createFramebuffer(),de.bindFramebuffer(de.FRAMEBUFFER,this.framebuffer),this.texture=e.createOneChannelTexture(this.scale),de.framebufferTexture2D(de.FRAMEBUFFER,de.COLOR_ATTACHMENT0,de.TEXTURE_2D,this.texture,0),this.program=b("#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\nout vec4 vPosLight1;\r\nout vec4 vPosLight2;\r\nout vec3 outPositionView;\r\nout vec3 outPositionLight;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 Iproj;\r\nuniform mat4 Iview;\r\nuniform mat4 view;\r\n\r\nvoid main() {\r\n    vec4 p1 = Iview * Iproj * vec4(pos, -1.0/16.0, 1.0);\r\n    vec4 p2 = Iview * Iproj * vec4(pos, 1.0/16.0, 1.0);\r\n\r\n\tvPosLight1 = proj * light * p1;\r\n    vPosLight2 = proj * light * p2;\r\n    outPositionLight = vec3(light * p1);\r\n    outPositionView = vec3(view * p1);\r\n\r\n\tuv = pos * 0.5 + 0.5;\r\n\tgl_Position = vec4(pos, 0.0, 1.0);\r\n}\r\n","#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\n// in vec4 tPos1;\r\n// in vec4 tPos2;\r\nin vec4 vPosLight1;\r\nin vec4 vPosLight2;\r\nout float color;\r\n\r\nuniform sampler2D lightTexture;\r\nuniform sampler2D cameraTexture;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 view;\r\nuniform vec3 viewPos;\r\nuniform vec3 lightPos;\r\n\r\nin vec3 outPositionView;\r\nin vec3 outPositionLight;\r\n\r\nconst int samples = 80;\r\n\r\nvoid main() {\r\n    float stp = 1.0/float(samples);\r\n\tfloat k = 0.0;\r\n    float d = 0.0;\r\n\r\n    for (int i = 0; i < samples; i++) {\r\n\r\n        //vec4 vPos = mix(tPos1,tPos2,k);\r\n        vec4 vPosLight = mix(vPosLight1,vPosLight2,k);\r\n        k += stp;\r\n\r\n        vec3 ShadowTexC = (vPosLight.xyz/vPosLight.w) * 0.5 + 0.5;\r\n\r\n        float add = step(texture(lightTexture, ShadowTexC.xy).x, ShadowTexC.z);\r\n        d += add*stp;\r\n\t}\r\n\r\n    vec3 viewDir = normalize(viewPos - outPositionView);\r\n    vec3 L = normalize(lightPos - outPositionLight);\r\n    color = min((1.0 - d), (1.0 - dot(L, viewDir)) * 0.2);\r\n}\r\n"),this.quadVAO=de.createVertexArray(),de.bindVertexArray(this.quadVAO);const t=de.createBuffer();return de.bindBuffer(de.ARRAY_BUFFER,t),de.bufferData(de.ARRAY_BUFFER,new Float32Array(k),de.STATIC_DRAW),de.enableVertexAttribArray(0),de.vertexAttribPointer(0,2,de.FLOAT,!1,0,0),de.bindVertexArray(null),de.bindFramebuffer(de.FRAMEBUFFER,null),{name:"LIGHT"}}attachUniform(e){de.uniform1i(de.getUniformLocation(e,"light"),this.texture.index)}postProcessing(){}}class ge{parse;PP;scene;Particles;fps;camera;getState;reflow;needUpdateProjection;needUpdateView;env;currentTrack;constructor(e){this.reflow=!0,this.fps=new he,this.getState=e,this.currentTrack=0}setEnv(e){this.env=e}setCamera(e){this.camera=e}setParticles(e){this.Particles=e}setScene(e){this.scene=e}setPp(e){this.PP=e}setGl(e){pe=e}setParser(e){this.parse=e}step(e,t){const i=E(e,t.keys);if(-1===i[0]||-1===i[1]||0===i[0]&&0===i[1])return!1;const s=t.keys[i[0]],{component:a}=t;let l;l=3===a?n:4===a?o:r;const c=new l(s.value);if("rotation"===t.type)for(const e of t.meshes){const t=e.matrix.getScaling();e.matrix.makeRotationFromQuaternion(c.elements),e.matrix.scale(t)}else if("scale"===t.type)for(const e of t.meshes){if(e.matrix.animated){const t=e.matrix.getScaling();e.matrix.restoreScale(t)}e.matrix.scale(c),e.matrix.animated=!0}else if("translation"===t.type)for(const e of t.meshes)e.matrix.setTranslate(c)}spline(e,t){const r=E(e,t.keys);if(-1===r[0]||-1===r[1]||0===r[0]&&0===r[1])return!1;const i=e,s=t.keys[r[1]].time,a=t.keys[r[0]].time,l=t.component,c=s-a,u=(i-a)/c,f=u*u,h=f*u,m=-2*h+3*f,d=h-f,p=1-m,T=d-f+u,g=new Float32Array(l);for(let e=0;e!==l;e++){const n=t.keys[r[0]].value[l+e],i=t.keys[r[0]].value[2*l+e]*c,s=t.keys[r[1]].value[l+e],a=t.keys[r[1]].value[e]*c;if(g[e]=p*n+T*i+m*s+d*a,isNaN(g[e]))return!1}if("rotation"===t.type){const e=new o(g).normalize();for(const r of t.meshes){const t=r.matrix.getScaling();r.matrix.makeRotationFromQuaternion(e.elements),r.matrix.scale(t)}}else if("scale"===t.type){const e=new n(g);for(const r of t.meshes){if(r.matrix.animated){const e=r.matrix.getScaling();r.matrix.restoreScale(e)}r.matrix.scale(e),r.matrix.animated=!0}}else if("translation"===t.type){const e=new n(g);for(const r of t.meshes)r.matrix.setTranslate(e)}}updateGeometry(e,t){e.geometry.update(pe,t)}interpolation(e,t){const i=E(e,t.keys);if(-1===i[0]||-1===i[1]||0===i[0]&&0===i[1])return!1;const s=t.keys[i[0]],a=t.keys[i[1]],l=i[2],{component:c}=t;let u;u=3===c?n:4===c?o:r;const f=new u(s.value),h=new u(a.value);if("rotation"===t.type){const e=new o;e.lerp(f.elements,h.elements,l);for(const r of t.meshes){const t=r.matrix.getScaling();r.matrix.makeRotationFromQuaternion(e.elements),r.matrix.scale(t)}}else if("scale"===t.type){const e=new n;e.lerp(f.elements,h.elements,l);for(const r of t.meshes){if(r.matrix.animated){const e=r.matrix.getScaling();r.matrix.restoreScale(e)}r.matrix.scale(e),r.matrix.animated=!0}}else if("weights"===t.type){const e=new r(f.elements);e.lerp(f.elements,h.elements,l);for(const r of t.meshes){const t={};for(const n in r.geometry.targets[0])if("POSITION"===n){t[n]=r.geometry.attributes[n].slice();for(let i=0;i<e.elements.length;i++){if(0===e.elements[i])continue;const s=0;for(let a=0;a<t[n].length;a++)t[n][a]+=e.elements[i]*r.geometry.targets[i][n][a-s]}}this.updateGeometry(r,t)}}else if("translation"===t.type){const e=new n;e.lerp(f.elements,h.elements,l);for(const r of t.meshes)r.matrix.setTranslate(e)}else{const e=new o;e.lerp(f.elements,h.elements,l);for(const r of t.meshes)r.material.setColor(pe,t.type,e)}}animate(e){if(!this.parse.tracks.length)return;const t=Math.max(...this.parse.tracks.map(e=>e[0].duration));e-=Math.floor(e/t)*t;for(const t of this.parse.tracks.sort((e,t)=>e[0].duration-t[0].duration))for(const r of t){let t;switch(r.interpolation){case"LINEAR":default:t=this.interpolation(e,r);break;case"CUBICSPLINE":t=this.spline(e,r);break;case"STEP":t=this.step(e,r)}if(!1!==t){for(const e of r.meshes)S(e,e=>{e.updateMatrix(),e instanceof M&&(e.reflow=!0),e instanceof F&&(e.reflow=!0),e instanceof C&&e===this.camera&&(this.needUpdateView=!0)});this.reflow=!0}}}render(e=0){const t=e/1e3;this.animate(t),this.reflow&&(this.PP.hasPrePass&&(this.PP.bindPrePass(),this.PP.preProcessing()),this.PP.hasPostPass&&this.PP.bindPostPass(),pe.clear(pe.COLOR_BUFFER_BIT|pe.DEPTH_BUFFER_BIT),this.parse.json.extensions&&this.parse.json.extensions.EXT_lights_image_based&&this.env.draw(),this.env.draw(),this.renderScene(),this.clean(),this.PP.postprocessors.some(e=>e instanceof Ee)&&(pe.bindFramebuffer(pe.DRAW_FRAMEBUFFER,null),this.Particles.draw(e),this.reflow=!0),this.PP.hasPostPass&&this.PP.postProcessing()),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}renderScene(){if(this.needUpdateView){const e=function(e){const t=[new o,new o,new o,new o,new o,new o],r=e.elements;let n=r[0],i=r[1],s=r[2],a=r[3],l=r[4],c=r[5],u=r[6],f=r[7],h=r[8],m=r[9],d=r[10],p=r[11],T=r[12],E=r[13],g=r[14],x=r[15];return t[0].set([a-n,f-l,p-h,x-T]).normalize(),t[1].set([a+n,f+l,p+h,x+T]).normalize(),t[2].set([a+i,f+c,p+m,x+E]).normalize(),t[3].set([a-i,f-c,p-m,x-E]).normalize(),t[4].set([a-s,f-u,p-d,x-g]).normalize(),t[5].set([a+s,f+u,p+d,x+g]).normalize(),t}(this.camera.getViewProjMatrix());this.scene.meshes.forEach(t=>{t.visible=t.isVisible(e)})}this.scene.opaqueChildren.forEach(e=>{e.visible&&e.draw(pe,this.getState())}),this.scene.transparentChildren.length&&(pe.enable(pe.BLEND),pe.blendFunc(pe.SRC_ALPHA,pe.ONE_MINUS_SRC_ALPHA),this.scene.transparentChildren.forEach(e=>{e.visible&&e.draw(pe,this.getState())}),pe.disable(pe.BLEND),pe.blendFunc(pe.ONE,pe.ZERO))}clean(){S(this.scene,e=>{e.reflow=!1}),this.needUpdateView=!1,this.needUpdateProjection=!1,this.reflow=!1}}class xe extends ge{setEnv(e){this.env=e}setGl(e){Te=e}setPp(e){this.PP=e}render(e=0){const t=e/1e3;this.animate(t),this.reflow&&(this.PP.hasPrePass&&(this.PP.bindPrePass(),this.PP.preProcessing(),this.PP.target=void 0),this.PP.hasPostPass&&this.PP.bindPostPass(),this.renderScene(),this.clean(),this.PP.hasPostPass&&this.PP.postProcessing()),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}updateGeometry(e,t){e.geometry.updateWebGPU(Te,t)}renderScene(){let{renderPassDescriptor:e,context:t,device:r}=Te;e=this.PP.target?{...e,colorAttachments:this.PP.target,depthStencilAttachment:this.PP.pipeline.pass.depthStencilAttachment}:{...e,colorAttachments:[{view:t.getCurrentTexture().createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}]};const n=r.createCommandEncoder();Te.commandEncoder=n;const i=n.beginRenderPass(e);this.scene.opaqueChildren.forEach(e=>{i.setPipeline(e.pipeline),e.drawWebGPU(Te,i,this.getState())}),this.scene.transparentChildren.forEach(e=>{i.setPipeline(e.pipeline),e.drawWebGPU(Te,i,this.getState())}),i.end(),r.queue.submit([n.finish()])}}const ve={},Re="#version 300 es\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n",be="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform vec2 denom;\r\nuniform sampler2D uTexture;\r\n\r\nconst float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\nvoid main() {             \r\n    vec2 offset = 1.0 / vec2(textureSize(uTexture, 0));\r\n    vec3 result = texture(uTexture, uv).rgb * weight[0];\r\n\r\n    for (int i = 1; i < 5; ++i) {\r\n        result += texture(uTexture, uv + denom * (offset * float(i))).rgb * weight[i];\r\n        result += texture(uTexture, uv - denom * (offset * float(i))).rgb * weight[i];\r\n    }\r\n\r\n    color = vec4(result, 1.0);\r\n}\r\n";let Se,_e,Ae,Ue,Pe,Ne;class Fe extends me{texture;setGL(e){Ue=e}preProcessing(e){Ue.clear(Ue.COLOR_BUFFER_BIT|Ue.DEPTH_BUFFER_BIT),e.renderScene({isprerefraction:!0}),Ue.bindFramebuffer(Ue.FRAMEBUFFER,null),Ue.activeTexture(Ue[`TEXTURE${this.texture.index}`]),Ue.bindTexture(Ue.TEXTURE_2D,this.texture),Ue.generateMipmap(Ue.TEXTURE_2D)}preProcessingWebGPU(e){e.target=[{view:this.texture.view,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}},...e.pipeline.pass.colorAttachments.slice(1)],e.renderScene({isprerefraction:!0})}buildScreenBuffer(e){return this.texture=e.createDefaultTexture(1,!0),Ue.generateMipmap(Ue.TEXTURE_2D),Ue.bindFramebuffer(Ue.FRAMEBUFFER,e.preframebuffer),Ue.framebufferTexture2D(Ue.FRAMEBUFFER,Ue.COLOR_ATTACHMENT0,Ue.TEXTURE_2D,this.texture,0),Ue.bindFramebuffer(Ue.FRAMEBUFFER,null),{name:"REFRACTION"}}buildScreenBufferWebGPU(e){return this.texture=e.createDefaultTexture(),{name:"REFRACTION"}}attachUniform(){}postProcessing(){}postProcessingWebGPU(){}}const Ie={bloom:class extends me{tempBlurTexture;blurTexture;blurTexture2;blurTexture3;blurTexture4;program;bloorProgram;hdrTexture;setGL(e){_e=e}attachUniform(e){_e.uniform1i(_e.getUniformLocation(e,"bloom"),this.blurTexture.index)}postProcessing(e){_e.bindFramebuffer(_e.FRAMEBUFFER,this.framebuffer),_e.useProgram(this.bloorProgram),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.hdrTexture,0),_e.uniform1i(_e.getUniformLocation(this.bloorProgram,"diff"),e.screenTexture.index),_e.drawArrays(_e.TRIANGLE_STRIP,0,4),_e.useProgram(this.program),_e.viewport(0,0,this.width/2,this.height/2),this.renderBlur(this.hdrTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),_e.bindFramebuffer(_e.FRAMEBUFFER,null),_e.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=_e.createFramebuffer(),_e.bindFramebuffer(_e.FRAMEBUFFER,this.framebuffer),this.tempBlurTexture=e.createDefaultTexture(2),this.blurTexture=e.createDefaultTexture(2),this.hdrTexture=e.createByteTexture(),_e.bindFramebuffer(_e.FRAMEBUFFER,null),this.program=b(Re,be),this.bloorProgram=b(Re,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D diff;\r\n\r\nconst vec3 hdrColor = vec3(0.2126, 0.7152, 0.0722);\r\nconst float brightnessThreshold = 0.8;\r\n\r\nvoid main() {\r\n    vec3 c = texture(diff, uv).rgb;\r\n    float brightness = dot(c, hdrColor);\r\n    if (brightness > brightnessThreshold) {\r\n        color = vec4(c, 1.0);\r\n    } else {\r\n        color = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n}\r\n"),{name:"BLOOM"}}renderBlur(e,t){_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.tempBlurTexture,0),_e.clearColor(...m),_e.clear(_e.COLOR_BUFFER_BIT|_e.DEPTH_BUFFER_BIT|_e.STENSIL_BUFFER_BIT),_e.uniform1i(_e.getUniformLocation(t,"uTexture"),e.index),_e.uniform2f(_e.getUniformLocation(t,"denom"),1,0),_e.drawArrays(_e.TRIANGLE_STRIP,0,4),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.blurTexture,0),_e.uniform1i(_e.getUniformLocation(t,"uTexture"),this.tempBlurTexture.index),_e.uniform2f(_e.getUniformLocation(t,"denom"),0,1),_e.drawArrays(_e.TRIANGLE_STRIP,0,4)}preProcessing(){}},ssao:class extends me{ssaoBlurTexture;ssaoTexture;noice;kernels;ssaoProgram;ssaoBlurProgram;scale;constructor(){super(),this.scale=2}setGL(e){Se=e}attachUniform(e){Se.uniform1i(Se.getUniformLocation(e,"ssao"),this.ssaoTexture.index)}postProcessing(e){Se.bindFramebuffer(Se.FRAMEBUFFER,this.framebuffer),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.ssaoTexture,0),Se.clearColor(...m),Se.clear(Se.COLOR_BUFFER_BIT|Se.DEPTH_BUFFER_BIT),Se.useProgram(this.ssaoProgram);const r=this.camera.props.perspective||this.camera.props.orthographic;Se.uniform1i(Se.getUniformLocation(this.ssaoProgram,"normBuff"),e.normalTexture.index),Se.uniform1i(Se.getUniformLocation(this.ssaoProgram,"depthBuff"),e.depthTexture.index),Se.uniform1i(Se.getUniformLocation(this.ssaoProgram,"noice"),this.noice.index),Se.uniform2f(Se.getUniformLocation(this.ssaoProgram,"noiseScale"),this.width/this.scale/4,this.height/this.scale/4),Se.uniform1f(Se.getUniformLocation(this.ssaoProgram,"zFar"),r.zfar),Se.uniform1f(Se.getUniformLocation(this.ssaoProgram,"zNear"),r.znear),Se.uniform1f(Se.getUniformLocation(this.ssaoProgram,"bias"),.03*Math.sqrt(this.camera.modelSize)),Se.uniformMatrix4fv(Se.getUniformLocation(this.ssaoProgram,"proj"),!1,this.camera.projection.elements),Se.uniformMatrix4fv(Se.getUniformLocation(this.ssaoProgram,"view"),!1,this.camera.matrixWorldInvert.elements),Se.uniformMatrix4fv(Se.getUniformLocation(this.ssaoProgram,"projI"),!1,(new t).setInverseOf(this.camera.projection).elements),Se.uniform3fv(Se.getUniformLocation(this.ssaoProgram,"kernels"),this.kernels),Se.viewport(0,0,this.width/this.scale,this.height/this.scale),Se.drawArrays(Se.TRIANGLE_STRIP,0,4),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.ssaoBlurTexture,0),Se.clear(Se.COLOR_BUFFER_BIT|Se.DEPTH_BUFFER_BIT),Se.useProgram(this.ssaoBlurProgram),Se.uniform1i(Se.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoTexture.index),Se.uniform2f(Se.getUniformLocation(this.ssaoBlurProgram,"denom"),1,0),Se.drawArrays(Se.TRIANGLE_STRIP,0,4),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.ssaoTexture,0),Se.uniform1i(Se.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoBlurTexture.index),Se.uniform2f(Se.getUniformLocation(this.ssaoBlurProgram,"denom"),0,1),Se.drawArrays(Se.TRIANGLE_STRIP,0,4),Se.bindFramebuffer(Se.FRAMEBUFFER,null),Se.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=Se.createFramebuffer(),Se.bindFramebuffer(Se.FRAMEBUFFER,this.framebuffer),this.ssaoTexture=e.createOneChannelTexture(this.scale),this.ssaoBlurTexture=e.createOneChannelTexture(this.scale),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.ssaoTexture,0),this.ssaoProgram=b(Re,"#version 300 es\nprecision highp float;\n\nin vec2 uv;\nout float color;\n\nconst int kernelSize = 32;\nconst float power = 5.0;\n\nuniform sampler2D normBuff;\nuniform sampler2D depthBuff;\nuniform sampler2D noice;\nuniform vec2 noiseScale;\nuniform vec3 kernels[kernelSize];\nuniform mat4 proj;\nuniform mat4 projI;\nuniform mat4 view;\nuniform float zFar;\nuniform float zNear;\nuniform float bias;\n\nvec3 getPositionFromDepth(float depth) {\n\tvec4 clipSpaceLocation = vec4(0.0);\n\tclipSpaceLocation.xy = uv * 2.0 - 1.0;\n\tclipSpaceLocation.z = depth * 2.0 - 1.0;;\n\tclipSpaceLocation.w = 1.0;\n\tvec4 homogenousLocation = projI * clipSpaceLocation;\n\thomogenousLocation.xyz = homogenousLocation.xyz / homogenousLocation.w;\n\treturn homogenousLocation.xyz;\n}\n\nvoid main() {\n\tfloat depth = texture(depthBuff, uv).x;\n\tif ((2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear)) > 0.99) {\n\t\tdiscard;\n\t}\n\n\tfloat radius = bias * 2.0;\n\tvec3 pos = getPositionFromDepth(depth);\n\tvec3 normal = normalize(vec3(view * texture(normBuff, uv)));\n\tvec3 rvec = normalize(texture(noice, uv * noiseScale).xyz);\n\n\tvec3 tangent = normalize(rvec - normal * dot(rvec, normal));\n\tvec3 bitangent = cross(tangent, normal);\n\tmat3 rotate = mat3(tangent, bitangent, normal);\n\n\tfloat occlusion  = 0.0;\n\tfor (int i = 0; i < kernelSize; i++) {\n\t\tvec3 samplePos = rotate * kernels[i];\n\t\tsamplePos = pos + samplePos * radius;\n\n\t\tvec4 shift = proj * vec4(samplePos, 1.0);\n\t\tshift.xy /= shift.w;\n\t\tshift.xy = shift.xy * 0.5 + 0.5;\n\n\t\tfloat sampleDepth = getPositionFromDepth(texture(depthBuff, shift.xy).r).z;\n\n\t\tfloat distanceCheck = smoothstep(0.0, 1.0, radius / abs(pos.z - sampleDepth));\n\t\tocclusion  += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * distanceCheck;\n\t}\n\n\tocclusion = 1.0 - (occlusion / float(kernelSize));\n\tcolor = pow(occlusion, power);\n}\n"),this.ssaoBlurProgram=b(Re,be),this.buildNoice(e),this.buildKernels(),Se.bindFramebuffer(Se.FRAMEBUFFER,null),{name:"SSAO"}}buildNoice(e){const t=new Float32Array(48);for(let e=0;e<16;e++){const r=new n([2*d(0,1)-1,2*d(0,1)-1,.1]);t[3*e]=r.elements[0],t[3*e+1]=r.elements[1],t[3*e+2]=r.elements[2]}this.noice=e.createNoiceTexture(4,t)}buildKernels(){const e=new Array(32);for(let t=0;t<e.length;t++){e[t]=new n([2*d(0,1)-1,2*d(0,1)-1,d(0,1)]),e[t].normalize(),e[t].scale(d(0,1));let r=t/e.length;r=p(.1,1,r*r),e[t].scale(r)}this.kernels=new Float32Array(3*e.length);let t=0;for(const r of e)this.kernels.set(r.elements,3*t),t++}preProcessing(){}},shadow:class extends me{setGL(e){Ae=e}preProcessing(e){Ae.clear(Ae.COLOR_BUFFER_BIT|Ae.DEPTH_BUFFER_BIT),e.renderScene({isprepender:!0})}buildScreenBuffer(){return{name:"SHADOW"}}attachUniform(){}postProcessing(){}},light:Ee,refraction:Fe,scattering:class extends me{output;program;pipeline;bindGroup;setGL(e){Pe=e}attachUniform(e){Pe.uniform1i(Pe.getUniformLocation(e,"scattering"),this.output.index)}attachUniformWebGPU(){return{binding:8,resource:this.output.view}}postProcessing(e){Pe.bindFramebuffer(Pe.FRAMEBUFFER,this.framebuffer),Pe.useProgram(this.program),Pe.framebufferTexture2D(Pe.FRAMEBUFFER,Pe.COLOR_ATTACHMENT0,Pe.TEXTURE_2D,this.output,0),Pe.uniform1i(Pe.getUniformLocation(this.program,"textureSampler"),e.screenTexture.index),Pe.uniform1i(Pe.getUniformLocation(this.program,"depthSampler"),e.depthTexture.index),Pe.uniform1i(Pe.getUniformLocation(this.program,"albedoSampler"),e.albedoTexture.index),Pe.uniform1i(Pe.getUniformLocation(this.program,"irradianceSampler"),e.irradianceTexture.index),Pe.drawArrays(Pe.TRIANGLE_STRIP,0,4)}postProcessingWebGPU(e){const{device:t}=Pe,r=t.createCommandEncoder(),n=r.beginRenderPass({colorAttachments:[{view:this.output.view,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}]});n.setPipeline(this.pipeline),n.setVertexBuffer(0,e.vertexBuffer),n.setBindGroup(0,this.bindGroup),n.draw(6),n.end(),t.queue.submit([r.finish()])}buildScreenBuffer(e){return this.framebuffer=Pe.createFramebuffer(),Pe.bindFramebuffer(Pe.FRAMEBUFFER,this.framebuffer),this.output=e.createByteTexture(),Pe.bindFramebuffer(Pe.FRAMEBUFFER,null),this.program=b(Re,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\n#define rcp(x) 1./x\r\n#define GOLDEN_RATIO 1.618033988749895\r\n#define TWO_PI 6.2831855\r\nvec2 Golden2dSeq(int i, float n) {\r\n    return vec2(float(i) / n + (0.5f / n), fract(float(i) * rcp(GOLDEN_RATIO)));\r\n}\r\nvec2 SampleDiskGolden(int i, int sampleCount) {\r\n    vec2 f = Golden2dSeq(i, float(sampleCount));\r\n    return vec2(sqrt(f.x), TWO_PI * f.y);\r\n}\r\nconst float PI = 3.1415926535897932384626433832795f;\r\nconst float RECIPROCAL_PI = 0.3183098861837907f;\r\nconst float RECIPROCAL_PI2 = 0.15915494309189535f;\r\nconst float HALF_MIN = 5.96046448e-08f;\r\nconst float LinearEncodePowerApprox = 2.2f;\r\nconst float GammaEncodePowerApprox = 1.0f / LinearEncodePowerApprox;\r\nconst vec3 LuminanceEncodeApprox = vec3(0.2126f, 0.7152f, 0.0722f);\r\nconst float Epsilon = 0.0000001f;\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#define absEps(x) abs(x)+Epsilon\r\n#define maxEps(x) max(x, Epsilon)\r\n#define saturateEps(x) clamp(x, Epsilon, 1.0)\r\nmat3 transposeMat3(mat3 inMatrix) {\r\n    vec3 i0 = inMatrix[0];\r\n    vec3 i1 = inMatrix[1];\r\n    vec3 i2 = inMatrix[2];\r\n    mat3 outMatrix = mat3(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y), vec3(i0.z, i1.z, i2.z));\r\n    return outMatrix;\r\n}\r\nmat3 inverseMat3(mat3 inMatrix) {\r\n    float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\r\n    float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\r\n    float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\nfloat toLinearSpace(float color) {\r\n    return pow(color, LinearEncodePowerApprox);\r\n}\r\nvec3 toLinearSpace(vec3 color) {\r\n    return pow(color, vec3(LinearEncodePowerApprox));\r\n}\r\nvec4 toLinearSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(LinearEncodePowerApprox)), color.a);\r\n}\r\nfloat toGammaSpace(float color) {\r\n    return pow(color, GammaEncodePowerApprox);\r\n}\r\nvec3 toGammaSpace(vec3 color) {\r\n    return pow(color, vec3(GammaEncodePowerApprox));\r\n}\r\nvec4 toGammaSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(GammaEncodePowerApprox)), color.a);\r\n}\r\nfloat square(float value) {\r\n    return value * value;\r\n}\r\nvec3 square(vec3 value) {\r\n    return value * value;\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value * value;\r\n    return sq * sq * value;\r\n}\r\nfloat getLuminance(vec3 color) {\r\n    return clamp(dot(color, LuminanceEncodeApprox), 0.f, 1.f);\r\n}\r\nfloat getRand(vec2 seed) {\r\n    return fract(sin(dot(seed.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);\r\n}\r\nfloat dither(vec2 seed, float varianceAmount) {\r\n    float rand = getRand(seed);\r\n    float normVariance = varianceAmount / 255.0f;\r\n    float dither = mix(-normVariance, normVariance, rand);\r\n    return dither;\r\n}\r\nconst float rgbdMaxRange = 255.0f;\r\nvec4 toRGBD(vec3 color) {\r\n    float maxRGB = maxEps(max(color.r, max(color.g, color.b)));\r\n    float D = max(rgbdMaxRange / maxRGB, 1.f);\r\n    D = clamp(floor(D) / 255.0f, 0.f, 1.f);\r\n    vec3 rgb = color.rgb * D;\r\n    rgb = toGammaSpace(rgb);\r\n    return vec4(clamp(rgb, 0.f, 1.f), D);\r\n}\r\nvec3 fromRGBD(vec4 rgbd) {\r\n    rgbd.rgb = toLinearSpace(rgbd.rgb);\r\n    return rgbd.rgb / rgbd.a;\r\n}\r\nvec3 parallaxCorrectNormal(vec3 vertexPos, vec3 origVec, vec3 cubeSize, vec3 cubePos) {\r\n    vec3 invOrigVec = vec3(1.0f, 1.0f, 1.0f) / origVec;\r\n    vec3 halfSize = cubeSize * 0.5f;\r\n    vec3 intersecAtMaxPlane = (cubePos + halfSize - vertexPos) * invOrigVec;\r\n    vec3 intersecAtMinPlane = (cubePos - halfSize - vertexPos) * invOrigVec;\r\n    vec3 largestIntersec = max(intersecAtMaxPlane, intersecAtMinPlane);\r\n    float distance = min(min(largestIntersec.x, largestIntersec.y), largestIntersec.z);\r\n    vec3 intersectPositionWS = vertexPos + origVec * distance;\r\n    return intersectPositionWS - cubePos;\r\n}\r\nbool testLightingForSSS(float diffusionProfile) {\r\n    return diffusionProfile < 1.f;\r\n}\r\n\r\nconst vec3 diffusionS = vec3(1.0);\r\nconst float diffusionD = 1.0;\r\nconst float filterRadii = 16.5644;\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D irradianceSampler;\r\nuniform sampler2D depthSampler;\r\nuniform sampler2D albedoSampler;\r\nconst float metersPerUnit = 0.1;\r\n\r\nconst float LOG2_E = 1.4426950408889634f;\r\nconst float SSS_PIXELS_PER_SAMPLE = 4.f;\r\nconst int _SssSampleBudget = 40;\r\n#define rcp(x) 1./x\r\n#define Sq(x) x*x\r\n#define SSS_BILATERAL_FILTER true\r\nvec3 EvalBurleyDiffusionProfile(float r, vec3 S) {\r\n    vec3 exp_13 = exp2(((LOG2_E * (-1.0f / 3.0f)) * r) * S);\r\n    vec3 expSum = exp_13 * (1.f + exp_13 * exp_13);\r\n    return (S * rcp(8.f * PI)) * expSum;\r\n}\r\nvec2 SampleBurleyDiffusionProfile(float u, float rcpS) {\r\n    u = 1.f - u;\r\n    float g = 1.f + (4.f * u) * (2.f * u + sqrt(1.f + (4.f * u) * u));\r\n    float n = exp2(log2(g) * (-1.0f / 3.0f));\r\n    float p = (g * n) * n;\r\n    float c = 1.f + p + n;\r\n    float d = (3.f / LOG2_E * 2.f) + (3.f / LOG2_E) * log2(u);\r\n    float x = (3.f / LOG2_E) * log2(c) - d;\r\n    float rcpExp = ((c * c) * c) * rcp((4.f * u) * ((c * c) + (4.f * u) * (4.f * u)));\r\n    float r = x * rcpS;\r\n    float rcpPdf = (8.f * PI * rcpS) * rcpExp;\r\n    return vec2(r, rcpPdf);\r\n}\r\nvec3 ComputeBilateralWeight(float xy2, float z, float mmPerUnit, vec3 S, float rcpPdf) {\r\n    float r = sqrt(xy2 + (z * mmPerUnit) * (z * mmPerUnit));\r\n    float area = rcpPdf;\r\n    return EvalBurleyDiffusionProfile(r, S) * area;\r\n}\r\nvoid EvaluateSample(int i, int n, vec3 S, float d, vec3 centerPosVS, float mmPerUnit, float pixelsPerMm, float phase, inout vec3 totalIrradiance, inout vec3 totalWeight) {\r\n    float scale = rcp(float(n));\r\n    float offset = rcp(float(n)) * 0.5f;\r\n    float sinPhase, cosPhase;\r\n    sinPhase = sin(phase);\r\n    cosPhase = cos(phase);\r\n    vec2 bdp = SampleBurleyDiffusionProfile(float(i) * scale + offset, d);\r\n    float r = bdp.x;\r\n    float rcpPdf = bdp.y;\r\n    float phi = SampleDiskGolden(i, n).y;\r\n    float sinPhi, cosPhi;\r\n    sinPhi = sin(phi);\r\n    cosPhi = cos(phi);\r\n    float sinPsi = cosPhase * sinPhi + sinPhase * cosPhi;\r\n    float cosPsi = cosPhase * cosPhi - sinPhase * sinPhi;\r\n    vec2 vec = r * vec2(cosPsi, sinPsi);\r\n    vec2 position;\r\n    float xy2;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    position = uv + round((pixelsPerMm * r) * vec2(cosPsi, sinPsi)) * texelSize;\r\n    xy2 = r * r;\r\n    vec4 textureSample = texture(irradianceSampler, position);\r\n    float viewZ = texture(depthSampler, position).r;\r\n    vec3 irradiance = textureSample.rgb;\r\n    //if(testLightingForSSS(textureSample.a)) {\r\n        float relZ = viewZ - centerPosVS.z;\r\n        vec3 weight = ComputeBilateralWeight(xy2, relZ, mmPerUnit, S, rcpPdf);\r\n        totalIrradiance += weight * irradiance;\r\n        totalWeight += weight;\r\n    // } else {\r\n\r\n    // }\r\n}\r\n\r\nvoid main(void) {\r\n    vec4 irradianceAndDiffusionProfile = texture(irradianceSampler, uv);\r\n    vec3 centerIrradiance = irradianceAndDiffusionProfile.rgb;\r\n    int diffusionProfileIndex = int(round(irradianceAndDiffusionProfile.a * 255.f));\r\n    float centerDepth = 0.f;\r\n    vec4 inputColor = texture(textureSampler, uv);\r\n    bool passedStencilTest = testLightingForSSS(irradianceAndDiffusionProfile.a);\r\n    //if(passedStencilTest) {\r\n        centerDepth = texture(depthSampler, uv).r;\r\n    //}\r\n    if(!passedStencilTest) {\r\n        color = inputColor;\r\n        //return;\r\n    }\r\n    float distScale = 1.f;\r\n    vec3 S = diffusionS;\r\n    float d = diffusionD;\r\n    float filterRadius = filterRadii;\r\n    vec2 centerPosNDC = uv;\r\n    vec2 viewportSize = vec2(0.6520661863788713, 0.5773502691896256);\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    vec2 cornerPosNDC = uv + 0.5f * texelSize;\r\n    vec3 centerPosVS = vec3(centerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    vec3 cornerPosVS = vec3(cornerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    float mmPerUnit = 1000.f * (metersPerUnit * rcp(distScale));\r\n    float unitsPerMm = rcp(mmPerUnit);\r\n    float unitsPerPixel = 2.f * abs(cornerPosVS.x - centerPosVS.x);\r\n    float pixelsPerMm = rcp(unitsPerPixel) * unitsPerMm;\r\n    float filterArea = PI * Sq(filterRadius * pixelsPerMm);\r\n    int sampleCount = int(filterArea * rcp(SSS_PIXELS_PER_SAMPLE));\r\n    int sampleBudget = _SssSampleBudget;\r\n    int texturingMode = 0;\r\n    vec3 albedo = texture(albedoSampler, uv).rgb;\r\n    if(distScale == 0.f || sampleCount < 1) {\r\n        color = vec4(inputColor.rgb + albedo * centerIrradiance, 1.0f);\r\n        //return;\r\n    }\r\n    float phase = 0.f;\r\n    int n = min(sampleCount, sampleBudget);\r\n    vec3 centerWeight = vec3(0.f);\r\n    vec3 totalIrradiance = vec3(0.f);\r\n    vec3 totalWeight = vec3(0.f);\r\n    for(int i = 0; i < n; i++) {\r\n        EvaluateSample(i, n, S, d, centerPosVS, mmPerUnit, pixelsPerMm, phase, totalIrradiance, totalWeight);\r\n    }\r\n    totalWeight = max(totalWeight, HALF_MIN);\r\n    color = vec4(inputColor.rgb + albedo * max(totalIrradiance / totalWeight, vec3(0.0f)), 1.f);\r\n    //color = vec4(inputColor.rgb, 1.f);\r\n}\r\n"),{name:"SCATTERING"}}buildScreenBufferWebGPU(e){const t=[{binding:4,resource:e.depthTexture.sampler},{binding:5,resource:e.screenTexture.sampler},{binding:0,resource:e.screenTexture.view},{binding:1,resource:e.depthTexture.view},{binding:2,resource:e.albedoTexture.view},{binding:3,resource:e.irradianceTexture.view}];return this.pipeline=e.buildPipeline(Pe,z,"#version 460\r\nprecision highp float;\r\n\r\n#define DISABLE_UNIFORMITY_ANALYSIS\r\n\r\n#extension GL_EXT_samplerless_texture_functions:require\r\n\r\nlayout(location = 0) in vec2 inuv;\r\nlayout(location = 0) out vec4 color;\r\n\r\n#define rcp(x) 1./x\r\n#define GOLDEN_RATIO 1.618033988749895\r\n#define TWO_PI 6.2831855\r\nvec2 Golden2dSeq(int i, float n) {\r\n    return vec2(float(i) / n + (0.5f / n), fract(float(i) * rcp(GOLDEN_RATIO)));\r\n}\r\nvec2 SampleDiskGolden(int i, int sampleCount) {\r\n    vec2 f = Golden2dSeq(i, float(sampleCount));\r\n    return vec2(sqrt(f.x), TWO_PI * f.y);\r\n}\r\nconst float PI = 3.1415926535897932384626433832795f;\r\nconst float RECIPROCAL_PI = 0.3183098861837907f;\r\nconst float RECIPROCAL_PI2 = 0.15915494309189535f;\r\nconst float HALF_MIN = 5.96046448e-08f;\r\nconst float LinearEncodePowerApprox = 2.2f;\r\nconst float GammaEncodePowerApprox = 1.0f / LinearEncodePowerApprox;\r\nconst vec3 LuminanceEncodeApprox = vec3(0.2126f, 0.7152f, 0.0722f);\r\nconst float Epsilon = 0.0000001f;\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#define absEps(x) abs(x)+Epsilon\r\n#define maxEps(x) max(x, Epsilon)\r\n#define saturateEps(x) clamp(x, Epsilon, 1.0)\r\nmat3 transposeMat3(mat3 inMatrix) {\r\n    vec3 i0 = inMatrix[0];\r\n    vec3 i1 = inMatrix[1];\r\n    vec3 i2 = inMatrix[2];\r\n    mat3 outMatrix = mat3(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y), vec3(i0.z, i1.z, i2.z));\r\n    return outMatrix;\r\n}\r\nmat3 inverseMat3(mat3 inMatrix) {\r\n    float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\r\n    float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\r\n    float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\nfloat toLinearSpace(float color) {\r\n    return pow(color, LinearEncodePowerApprox);\r\n}\r\nvec3 toLinearSpace(vec3 color) {\r\n    return pow(color, vec3(LinearEncodePowerApprox));\r\n}\r\nvec4 toLinearSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(LinearEncodePowerApprox)), color.a);\r\n}\r\nfloat toGammaSpace(float color) {\r\n    return pow(color, GammaEncodePowerApprox);\r\n}\r\nvec3 toGammaSpace(vec3 color) {\r\n    return pow(color, vec3(GammaEncodePowerApprox));\r\n}\r\nvec4 toGammaSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(GammaEncodePowerApprox)), color.a);\r\n}\r\nfloat square(float value) {\r\n    return value * value;\r\n}\r\nvec3 square(vec3 value) {\r\n    return value * value;\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value * value;\r\n    return sq * sq * value;\r\n}\r\nfloat getLuminance(vec3 color) {\r\n    return clamp(dot(color, LuminanceEncodeApprox), 0.f, 1.f);\r\n}\r\nfloat getRand(vec2 seed) {\r\n    return fract(sin(dot(seed.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);\r\n}\r\nfloat dither(vec2 seed, float varianceAmount) {\r\n    float rand = getRand(seed);\r\n    float normVariance = varianceAmount / 255.0f;\r\n    float dither = mix(-normVariance, normVariance, rand);\r\n    return dither;\r\n}\r\nconst float rgbdMaxRange = 255.0f;\r\nvec4 toRGBD(vec3 color) {\r\n    float maxRGB = maxEps(max(color.r, max(color.g, color.b)));\r\n    float D = max(rgbdMaxRange / maxRGB, 1.f);\r\n    D = clamp(floor(D) / 255.0f, 0.f, 1.f);\r\n    vec3 rgb = color.rgb * D;\r\n    rgb = toGammaSpace(rgb);\r\n    return vec4(clamp(rgb, 0.f, 1.f), D);\r\n}\r\nvec3 fromRGBD(vec4 rgbd) {\r\n    rgbd.rgb = toLinearSpace(rgbd.rgb);\r\n    return rgbd.rgb / rgbd.a;\r\n}\r\nvec3 parallaxCorrectNormal(vec3 vertexPos, vec3 origVec, vec3 cubeSize, vec3 cubePos) {\r\n    vec3 invOrigVec = vec3(1.0f, 1.0f, 1.0f) / origVec;\r\n    vec3 halfSize = cubeSize * 0.5f;\r\n    vec3 intersecAtMaxPlane = (cubePos + halfSize - vertexPos) * invOrigVec;\r\n    vec3 intersecAtMinPlane = (cubePos - halfSize - vertexPos) * invOrigVec;\r\n    vec3 largestIntersec = max(intersecAtMaxPlane, intersecAtMinPlane);\r\n    float distance = min(min(largestIntersec.x, largestIntersec.y), largestIntersec.z);\r\n    vec3 intersectPositionWS = vertexPos + origVec * distance;\r\n    return intersectPositionWS - cubePos;\r\n}\r\nbool testLightingForSSS(float diffusionProfile) {\r\n    return diffusionProfile < 1.f;\r\n}\r\n\r\nconst vec3 diffusionS = vec3(1.0);\r\nconst float diffusionD = 1.0;\r\nconst float filterRadii = 16.5644;\r\n\r\nlayout(set = 0, binding = 0) uniform texture2D textureSampler;\r\nlayout(set = 0, binding = 3) uniform texture2D irradianceSampler;\r\nlayout(set = 0, binding = 1) uniform texture2D depthSampler;\r\nlayout(set = 0, binding = 2) uniform texture2D albedoSampler;\r\nlayout(set = 0, binding = 4) uniform sampler baseSampler2;\r\nlayout(set = 0, binding = 5) uniform sampler baseSampler;\r\nconst float metersPerUnit = 0.1;\r\n\r\nconst float LOG2_E = 1.4426950408889634f;\r\nconst float SSS_PIXELS_PER_SAMPLE = 4.f;\r\nconst int _SssSampleBudget = 40;\r\n#define rcp(x) 1./x\r\n#define Sq(x) x*x\r\n#define SSS_BILATERAL_FILTER true\r\nvec3 EvalBurleyDiffusionProfile(float r, vec3 S) {\r\n    vec3 exp_13 = exp2(((LOG2_E * (-1.0f / 3.0f)) * r) * S);\r\n    vec3 expSum = exp_13 * (1.f + exp_13 * exp_13);\r\n    return (S * rcp(8.f * PI)) * expSum;\r\n}\r\nvec2 SampleBurleyDiffusionProfile(float u, float rcpS) {\r\n    u = 1.f - u;\r\n    float g = 1.f + (4.f * u) * (2.f * u + sqrt(1.f + (4.f * u) * u));\r\n    float n = exp2(log2(g) * (-1.0f / 3.0f));\r\n    float p = (g * n) * n;\r\n    float c = 1.f + p + n;\r\n    float d = (3.f / LOG2_E * 2.f) + (3.f / LOG2_E) * log2(u);\r\n    float x = (3.f / LOG2_E) * log2(c) - d;\r\n    float rcpExp = ((c * c) * c) * rcp((4.f * u) * ((c * c) + (4.f * u) * (4.f * u)));\r\n    float r = x * rcpS;\r\n    float rcpPdf = (8.f * PI * rcpS) * rcpExp;\r\n    return vec2(r, rcpPdf);\r\n}\r\nvec3 ComputeBilateralWeight(float xy2, float z, float mmPerUnit, vec3 S, float rcpPdf) {\r\n    float r = sqrt(xy2 + (z * mmPerUnit) * (z * mmPerUnit));\r\n    float area = rcpPdf;\r\n    return EvalBurleyDiffusionProfile(r, S) * area;\r\n}\r\n\r\nvoid main(void) {\r\n    vec2 uv = inuv;\r\n    uv.y = 1.0 - inuv.y;\r\n    vec4 irradianceAndDiffusionProfile = texture(sampler2D(irradianceSampler, baseSampler), uv);\r\n    vec3 centerIrradiance = irradianceAndDiffusionProfile.rgb;\r\n    int diffusionProfileIndex = int(round(irradianceAndDiffusionProfile.a * 255.f));\r\n    float centerDepth = 0.f;\r\n    vec4 inputColor = texture(sampler2D(textureSampler, baseSampler), uv);\r\n    bool passedStencilTest = testLightingForSSS(irradianceAndDiffusionProfile.a);\r\n    //if(passedStencilTest) {\r\n        centerDepth = texture(sampler2D(depthSampler, baseSampler2), uv).x;\r\n    //}\r\n    if(!passedStencilTest) {\r\n        color = inputColor;\r\n        //return;\r\n    }\r\n    float distScale = 1.f;\r\n    vec3 S = diffusionS;\r\n    float d = diffusionD;\r\n    float filterRadius = filterRadii;\r\n    vec2 centerPosNDC = uv;\r\n    vec2 viewportSize = vec2(0.6520661863788713, 0.5773502691896256);\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    vec2 cornerPosNDC = uv + 0.5f * texelSize;\r\n    vec3 centerPosVS = vec3(centerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    vec3 cornerPosVS = vec3(cornerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    float mmPerUnit = 1000.f * (metersPerUnit * rcp(distScale));\r\n    float unitsPerMm = rcp(mmPerUnit);\r\n    float unitsPerPixel = 2.f * abs(cornerPosVS.x - centerPosVS.x);\r\n    float pixelsPerMm = rcp(unitsPerPixel) * unitsPerMm;\r\n    float filterArea = PI * Sq(filterRadius * pixelsPerMm);\r\n    int sampleCount = int(filterArea * rcp(SSS_PIXELS_PER_SAMPLE));\r\n    int sampleBudget = _SssSampleBudget;\r\n    int texturingMode = 0;\r\n    vec3 albedo = texture(sampler2D(albedoSampler, baseSampler), uv).rgb;\r\n    if(distScale == 0.f || sampleCount < 1) {\r\n        color = vec4(inputColor.rgb + albedo * centerIrradiance, 1.0f);\r\n        //return;\r\n    }\r\n    float phase = 0.f;\r\n    int n = min(sampleCount, sampleBudget);\r\n    vec3 centerWeight = vec3(0.f);\r\n    vec3 totalIrradiance = vec3(0.f);\r\n    vec3 totalWeight = vec3(0.f);\r\n    for(int i = 0; i < n; i++) {\r\n        float scale = rcp(float(n));\r\n        float offset = rcp(float(n)) * 0.5f;\r\n        float sinPhase, cosPhase;\r\n        sinPhase = sin(phase);\r\n        cosPhase = cos(phase);\r\n        vec2 bdp = SampleBurleyDiffusionProfile(float(i) * scale + offset, d);\r\n        float r = bdp.x;\r\n        float rcpPdf = bdp.y;\r\n        float phi = SampleDiskGolden(i, n).y;\r\n        float sinPhi, cosPhi;\r\n        sinPhi = sin(phi);\r\n        cosPhi = cos(phi);\r\n        float sinPsi = cosPhase * sinPhi + sinPhase * cosPhi;\r\n        float cosPsi = cosPhase * cosPhi - sinPhase * sinPhi;\r\n        vec2 vec = r * vec2(cosPsi, sinPsi);\r\n        vec2 position;\r\n        float xy2;\r\n        vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n        position = uv + round((pixelsPerMm * r) * vec2(cosPsi, sinPsi)) * texelSize;\r\n        xy2 = r * r;\r\n        vec3 irradiance = texture(sampler2D(irradianceSampler, baseSampler), position).rgb;\r\n        float viewZ = texture(sampler2D(depthSampler, baseSampler2), position).r;\r\n        //if(testLightingForSSS(textureSample.a)) {\r\n            float relZ = viewZ - centerPosVS.z;\r\n            vec3 weight = ComputeBilateralWeight(xy2, relZ, mmPerUnit, S, rcpPdf);\r\n            totalIrradiance += weight * irradiance;\r\n            totalWeight += weight;\r\n        // } else {\r\n\r\n        // }\r\n    }\r\n    totalWeight = max(totalWeight, HALF_MIN);\r\n    color = vec4(inputColor.rgb + albedo * max(totalIrradiance / totalWeight, vec3(0.0f)), 1.f);\r\n    //color = vec4(inputColor.rgb, 1.f);\r\n}\r\n",2,[{binding:4,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"non-filtering"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}}],!1,"scaterring"),this.bindGroup=Pe.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:t}),this.output=e.createDefaultTexture(),{name:"SCATTERING"}}preProcessing(){}preProcessingWebGPU(){}}};class Me{screenTexture;normalTexture;irradianceTexture;specTexture;albedoTexture;depthTexture;preDepthTexture;fakeDepth;camera;renderer;canvas;framebuffer;preframebuffer;postprocessors;VAO;program;renderframebuffer;MSAA;renderScene;pipeline;target;vertexBuffer;bindGroup;hasPostPass=!0;hasPrePass=!1;constructor(e,t){this.renderScene=t,this.postprocessors=e.map(e=>new Ie[e])}add(e){const t=new Ie[e];t.setGL(Ne),this.postprocessors.push(t),this.hasPostPass=!0}addPrepass(e){const t=new Ie[e];t.setGL(Ne),this.postprocessors.push(t),this.hasPrePass=!0}setCamera(e){this.camera=e,this.postprocessors.forEach(t=>{t.setCamera(e)})}setLight(e){this.postprocessors.forEach(t=>{t.light=e})}setGl(e){e&&(Ne=e,this.postprocessors.forEach(e=>{e.setGL(Ne)}),this.fakeDepth=this.createNoiceTexture(1))}setCanvas(e){this.canvas=e,this.postprocessors.forEach(t=>{t.setCanvas(e)})}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}bindPrePass(){}bindPostPass(){this.target=this.pipeline.pass.colorAttachments}preProcessing(){this.postprocessors.forEach(e=>e.preProcessingWebGPU(this))}postProcessing(){const{device:e,context:t}=Ne;this.postprocessors.forEach(e=>e.postProcessingWebGPU(this));const r=e.createCommandEncoder(),n=r.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:this.depthTexture.view,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}});n.setPipeline(this.pipeline),n.setVertexBuffer(0,this.vertexBuffer),n.setBindGroup(0,this.bindGroup),n.draw(6),n.end(),e.queue.submit([r.finish()])}createByteTexture(e){const t=Ne.device.createSampler({magFilter:"nearest",minFilter:"nearest"}),r=Ne.device.createTexture({size:[this.width,this.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"bgra8unorm",label:e});return{texture:r,sampler:t,view:r.createView()}}createDefaultTexture(e=1,t=!1){const r=Ne.device.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:t?"linear":void 0}),n=Ne.device.createTexture({size:[this.width/e,this.height/e,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba16float"});return{texture:n,sampler:r,view:n.createView()}}createOneChannelTexture(e=1){const t=Ne.device.createSampler({magFilter:"linear",minFilter:"linear"}),r=Ne.device.createTexture({size:[this.width/e,this.height/e,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"r8uint"});return{texture:r,sampler:t,view:r.createView()}}createDepthTexture(e){const t=Ne.device.createSampler({magFilter:"nearest",minFilter:"nearest"}),r=Ne.device.createTexture({size:[this.width,this.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"depth32float",label:e});return{texture:r,sampler:t,view:r.createView()}}createNoiceTexture(e){const t=Ne.device.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat"}),r=Ne.device.createTexture({size:[e,e,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba16float"});return{texture:r,sampler:t,view:r.createView()}}buildVertex(e,t){const{device:r}=e,n=r.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set(t),n.unmap(),n}buildPipeline(e,t,r,n,i,s=!1,a){const{device:o,glslang:l,wgsl:c}=e;function u(e,t){const r=l.compileGLSL(e,t);return c.convertSpirV2WGSL(r)}const f=o.createBindGroupLayout({entries:i,label:a}),h=o.createPipelineLayout({bindGroupLayouts:[f]}),m="diagnostic(off,derivative_uniformity);\n"+u(r,"fragment");return o.createRenderPipeline({layout:h,vertex:{module:o.createShaderModule({code:u(t,"vertex")}),entryPoint:"main",buffers:[{arrayStride:Float32Array.BYTES_PER_ELEMENT*n,attributes:[{shaderLocation:0,offset:0,format:`float32x${n}`}]}]},fragment:{module:o.createShaderModule({code:m,label:a}),entryPoint:"main",targets:[{format:s?"bgra8unorm":"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:s?{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}:void 0})}buildScreenBuffer(){if(0===this.postprocessors.length)return!0;this.vertexBuffer=this.buildVertex(Ne,j),this.screenTexture=this.createDefaultTexture(),this.normalTexture=this.createByteTexture("normalTexture"),this.irradianceTexture=this.createDefaultTexture(),this.specTexture=this.createDefaultTexture(),this.albedoTexture=this.createDefaultTexture(),this.depthTexture=this.createDepthTexture("depthTexture"),this.preDepthTexture=this.createDepthTexture("preDepthTexture");const e=[{view:this.screenTexture.texture.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}},{view:this.irradianceTexture.texture.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}},{view:this.albedoTexture.texture.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}},{view:this.specTexture.texture.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],t=this.postprocessors.map(e=>e.buildScreenBufferWebGPU(this)).map(e=>`#define ${e.name} ${e.value??1}\n`).join("");this.program=[z.replace(/\n/,`\n${t}`),"#version 460\r\nprecision highp float;\r\n\r\nlayout(location = 0) in vec2 inuv;\r\nlayout(location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 0) uniform texture2D original;\r\nlayout(set = 0, binding = 1) uniform texture2D position;\r\nlayout(set = 0, binding = 2) uniform texture2D normal;\r\nlayout(set = 0, binding = 3) uniform texture2D ssao;\r\nlayout(set = 0, binding = 4) uniform texture2D bloom;\r\nlayout(set = 0, binding = 5) uniform texture2D depth;\r\nlayout(set = 0, binding = 6) uniform texture2D preDepth;\r\nlayout(set = 0, binding = 7) uniform texture2D light;\r\nlayout(set = 0, binding = 8) uniform texture2D scattering;\r\nlayout(set = 0, binding = 9) uniform texture2D spec;\r\nlayout(set = 0, binding = 10) uniform sampler baseSampler;\r\n\r\nconst float gamma = 2.2;\r\n\r\nvoid main() {\r\n    vec2 uv = inuv;\r\n    uv.y = 1.0 - inuv.y;\r\n    vec3 c = texture(sampler2D(original, baseSampler), uv).rgb;\r\n    #ifdef BLOOM\r\n        c += texture(sampler2D(bloom, baseSampler), uv).rgb;\r\n    #endif\r\n    #ifdef SSAO\r\n        c *= texture(sampler2D(ssao, baseSampler), uv).r;\r\n    #endif\r\n    #ifdef LIGHT\r\n        c += texture(sampler2D(light, baseSampler), uv).r;\r\n    #endif\r\n    #ifdef SCATTERING\r\n        c = texture(sampler2D(scattering, baseSampler), uv).rgb;\r\n        c += texture(sampler2D(spec, baseSampler), uv).rgb;\r\n    #endif\r\n\r\n    c.rgb = pow(c.rgb, vec3(1.0 / gamma));\r\n\r\n    color = vec4(c, 1.0);\r\n}\r\n".replace(/\n/,`\n${t}`)],this.pipeline=this.buildPipeline(Ne,this.program[0],this.program[1],2,[{binding:10,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:8,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:9,visibility:GPUShaderStage.FRAGMENT,texture:{}}],!0,"screen"),this.pipeline.pass={colorAttachments:e,depthStencilAttachment:{view:this.depthTexture.texture.createView(),depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}};const r=this.postprocessors.filter(e=>e.attachUniformWebGPU).map(e=>e.attachUniformWebGPU()),n=[{binding:10,resource:this.screenTexture.sampler},{binding:0,resource:this.screenTexture.view},{binding:9,resource:this.specTexture.view},...r];this.bindGroup=Ne.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:n})}clear(){console.error("implement")}}class Ce{url;envUrl;canvas;events;ioc;isIBL=!0;isDefaultLight=!0;renderState={};stateBuffer={};constructor(e,t,r,n="env"){if(!e)throw new Error("Url not found");this.envUrl=n,this.url=e,this.canvas=t,this.events=new G(t,this.redraw.bind(this))}async webgpuInit(){const e=await i.e(277).then(i.bind(i,488));await i.e(514).then(i.bind(i,277));const t=await navigator.gpu.requestAdapter(),r=await t.requestDevice({requiredFeatures:["float32-filterable"]}),n=await e.default(),s=await twgsl("twgsl.wasm"),a=this.canvas.getContext("webgpu");a.configure({device:r,format:"bgra8unorm",alphaMode:"opaque"});const o=r.createTexture({size:{width:this.canvas.offsetWidth*devicePixelRatio,height:this.canvas.offsetHeight*devicePixelRatio,depthOrArrayLayers:1},format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT});return{glslang:n,wgsl:s,context:a,device:r,renderPassDescriptor:{colorAttachments:[],depthStencilAttachment:{view:o.createView(),depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}}get camera(){return this.ioc.get("camera")}get light(){return this.ioc.get("light")}get renderer(){return this.ioc.get("renderer")}get scene(){return this.ioc.get("scene")}get parse(){return this.ioc.get("parser")}get env(){return this.ioc.get("env")}get PP(){return this.ioc.get("pp")}async init(t){const r=new e;this.ioc=r;try{const e=await this.webgpuInit();r.register("canvas",this.canvas),r.register("gl",e),r.register("scene",c),r.register("light",L,[],{type:"directional",intensity:5,color:[1,1,1],isInitial:!0,spot:{}}),this.ioc.register("pp",Me,["light","camera","canvas","gl"],[],this.renderScene.bind(this)),r.register("parser",fe,["gl","scene","camera","light"],this.url,[],()=>{}),r.register("env",ee,["camera","canvas"],this.envUrl),r.register("renderer",xe,["gl","scene","parser","env","pp"],this.getState.bind(this)),r.register("camera",C,[],{type:"perspective",isInitial:!0,zoom:1,aspect:this.canvas.offsetWidth/this.canvas.offsetHeight,perspective:{yfov:45*Math.PI/180}},"perspective"),await this.parse.getJson(),await this.parse.getBuffer(),await this.parse.initTextures(!0),this.parse.buildSkin(),await this.parse.buildMesh(),this.parse.buildAnimation(),0===this.parse.cameras.length&&this.parse.cameras.push(this.camera),this.parse.createSamplersWebGPU(e),this.parse.createTexturesWebGPU(e);const t=await this.parse.getEnv(!0);await this.env.createEnvironmentBuffer(t,e),this.parse.calculateFov(this.camera.props.isInitial),this.resize(),await this.env.createTexture(e),this.env.drawBRDF(e),this.env.drawMips(e),this.env.drawIrradiance(e),this.env.drawPrefilter(e);const{renderState:n,isIBL:i,isDefaultLight:s,lights:a}=this.getState(),o=new O;o.add("isTone",n.isprerefraction?0:1),o.add("isIBL",i?1:0),o.add("isDefaultLight",s||a.some(e=>!e.isInitial)?1:0),o.done(),this.stateBuffer=o;const l=e.device.createBuffer({size:256+o.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});o.bufferWebGPU=l,e.device.queue.writeBuffer(l,0,o.store.buffer,o.store.byteOffset,o.store.byteLength),this.parse.json.extensionsUsed&&this.parse.json.extensionsUsed.includes("KHR_materials_transmission")&&this.PP.addPrepass("refraction"),this.PP.add("scattering"),(this.PP.hasPostPass||this.PP.hasPrePass)&&this.PP.buildScreenBuffer();const u=this.PP.postprocessors.find(e=>e instanceof Fe);this.scene.meshes.forEach(t=>{if(t.geometry.createGeometryForWebGPU(e),t.geometry.createUniforms(t.matrixWorld,this.camera,this.light),t.geometry.updateUniformsWebGPU(e),t.material.createUniforms(this.camera,this.parse.lights),t.material.updateUniformsWebGPU(e),t.material.uniformBindGroup1.push({binding:19,resource:this.env.prefilterTexture?.createView({dimension:"cube"})},{binding:20,resource:this.env.irradianceTexture?.createView({dimension:"cube"})},{binding:21,resource:this.env.bdrfTexture?.createView()},{binding:28,resource:this.env.Sheen_E?.createView()},{binding:26,resource:t.defines.find(e=>"TRANSMISSION"===e.name)?u.texture.texture.createView():this.PP.fakeDepth.texture.createView()},{binding:35,resource:this.env.charlieTexture?.createView({dimension:"cube"})},{binding:30,resource:{buffer:l,offset:0,size:o.store.byteLength}}),this.env.uniformBuffer&&t.material.uniformBindGroup1.push({binding:27,resource:{buffer:this.env.uniformBuffer.bufferWebGPU,offset:0,size:this.env.uniformBuffer.store.byteLength}}),t instanceof I){for(const e of this.parse.skins[t.skin].jointNames)S(this.scene,this.buildBones.bind(this,e,this.parse.skins[t.skin]));t.geometry.uniformBindGroup1.push(t.setSkinWebGPU(e,this.parse.skins[t.skin]))}t.pipeline=function(e,t,r,n,i){const s=i.map(e=>`${e.name}${e.value??1}`).join("");let a;if(ve[s])a=ve[s];else{const e=i.map(e=>`#define ${e.name} ${e.value??1}\n`).join(""),t=[ae,oe].map(e=>e.replace(/#include ".*/g,e=>e.split('"')[1].includes("vert")?"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec2 inUV;\r\nlayout (location = 2) in vec3 inNormal;\r\n#ifdef JOINTNUMBER\r\nlayout (location = 4) in vec4 inJoint;\r\nlayout (location = 5) in vec4 inWeight;\r\n#endif\r\n#ifdef TANGENT\r\nlayout (location = 3) in vec4 inTangent;\r\n#endif\r\n#ifdef COLOR\r\nlayout (location = 6) in vec4 inColor;\r\n#endif\r\n#ifdef MULTIUV\r\nlayout (location = 7) in vec2 inUV2;\r\nlayout (location = 8) in vec2 inUV3;\r\n#endif\r\n\r\nlayout(location = 0) out vec2 outUV0;\r\nlayout(location = 1) out vec2 outUV2;\r\nlayout(location = 8) out vec2 outUV3;\r\nlayout(location = 2) out vec3 outPosition;\r\nlayout(location = 3) out vec4 vColor;\r\nlayout(location = 4) out mat3 outTBN;\r\nlayout(location = 7) out vec4 outPositionView;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n\r\n#ifdef JOINTNUMBER\r\nlayout(set = 0, binding = 22) uniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif":"#version 460\r\n\r\n#extension GL_EXT_samplerless_texture_functions:require\r\n\r\n// #ifdef DIFFUSE_TRANSMISSION\r\n//     #define SCATTERING 1\r\n// #endif\r\n\r\n#define texture2D(p, uv) texture(sampler2D(p, baseSampler), uv)\r\n#define textureCube(p, uv) texture(samplerCube(p, unfilteredSampler), uv)\r\n#define textureLodCube(p, uv, i) textureLod(samplerCube(p, unfilteredSampler), uv, i)\r\n#define textureLod2D(p, uv, i) textureLod(sampler2D(p, baseSampler), uv, i)\r\n\r\n#define IBL 1\r\n#define USE_PBR 1\r\n#define WEBGPU 1\r\n\r\nlayout(location = 0) in vec2 outUV0;\r\nlayout(location = 4) in mat3 outTBN;\r\n#ifdef MULTIUV\r\nlayout(location = 1) in vec2 outUV2;\r\nlayout(location = 8) in vec2 outUV3;\r\n#endif\r\nlayout(location = 2) in vec3 outPosition;\r\nlayout(location = 3) in vec4 vColor;\r\nlayout(location = 7) in vec4 outPositionView;\r\n\r\nlayout(location = 0) out vec4 color;\r\n// layout (location = 1) out vec4 normalColor;\r\nlayout (location = 1) out vec4 irradianceColor;\r\nlayout (location = 2) out vec4 albedoColor;\r\nlayout (location = 3) out vec4 specColor;\r\n\r\nlayout(set = 0, binding = 0) uniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\nlayout(set = 0, binding = 1) uniform Uniforms {\r\n    vec4 baseColorFactor;\r\n    vec3 viewPos;\r\n    vec3 specularFactor;\r\n    vec3 specularColorFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenRoughnessFactor;\r\n    vec4 transmissionFactor;\r\n    vec4 ior;\r\n    vec4 normalTextureScale;\r\n    vec4 attenuationColorFactor; \r\n    vec4 attenuationDistance; \r\n    vec4 thicknessFactor;\r\n    vec4 emissiveStrength;\r\n    vec4 anisotropyFactor;\r\n    vec4 iridescence;\r\n    vec4 diffuseTransmissionFactor;\r\n    vec4 dispersionFactor;\r\n};\r\nlayout(set = 0, binding = 27) uniform SphericalHarmonics {\r\n    vec4 vSphericalL00;\r\n    vec4 vSphericalL1_1;\r\n    vec4 vSphericalL10;\r\n    vec4 vSphericalL11;\r\n    vec4 vSphericalL2_2;\r\n    vec4 vSphericalL2_1;\r\n    vec4 vSphericalL20;\r\n    vec4 vSphericalL21;\r\n    vec4 vSphericalL22;\r\n    mat4 rotationMatrix;\r\n};\r\nlayout(set = 0, binding = 15) uniform LightColor {\r\n    vec4 lightColor[LIGHTNUMBER];\r\n};\r\nlayout(set = 0, binding = 17) uniform Spotdir {\r\n    vec4 spotdir[LIGHTNUMBER];\r\n};\r\nlayout(set = 0, binding = 18) uniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\nlayout(set = 0, binding = 16) uniform LightPos {\r\n    vec4 lightPos[LIGHTNUMBER];\r\n};\r\n#if defined MATRICES\r\nlayout(set = 0, binding = 23) uniform TextureMatrices {\r\n    mat4 textureMatrices[MATRICES];\r\n};\r\n#endif\r\n\r\nlayout(set = 0, binding = 2) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 24) uniform sampler unfilteredSampler;\r\n#ifdef BASECOLORTEXTURE\r\nlayout(set = 0, binding = 3) uniform texture2D baseColorTexture;\r\n#endif\r\n#ifdef METALROUGHNESSMAP\r\nlayout(set = 0, binding = 4) uniform texture2D metallicRoughnessTexture;\r\n#endif\r\n#ifdef NORMALMAP\r\nlayout(set = 0, binding = 5) uniform texture2D normalTexture;\r\n#endif\r\n#ifdef EMISSIVEMAP\r\nlayout(set = 0, binding = 6) uniform texture2D emissiveTexture;\r\n#endif\r\n#ifdef OCCLUSIONMAP\r\nlayout(set = 0, binding = 7) uniform texture2D occlusionTexture;\r\n#endif\r\n#ifdef CLEARCOATMAP\r\nlayout(set = 0, binding = 8) uniform texture2D clearcoatTexture;\r\n#endif\r\n#ifdef CLEARCOATROUGHMAP\r\nlayout(set = 0, binding = 9) uniform texture2D clearcoatRoughnessTexture;\r\n#endif\r\n#ifdef TRANSMISSIONMAP\r\nlayout(set = 0, binding = 10) uniform texture2D transmissionTexture;\r\n#endif\r\n#ifdef SHEENMAP\r\nlayout(set = 0, binding = 11) uniform texture2D sheenColorTexture;\r\nlayout(set = 0, binding = 12) uniform texture2D sheenRoughnessTexture;\r\n#endif\r\n#ifdef CLEARCOATNORMALMAP\r\nlayout(set = 0, binding = 13) uniform texture2D clearcoatNormalTexture;\r\n#endif\r\n#ifdef SPECULARMAP\r\nlayout(set = 0, binding = 14) uniform texture2D specularTexture;\r\n#endif\r\nlayout(set = 0, binding = 19) uniform textureCube prefilterMap;\r\nlayout(set = 0, binding = 20) uniform textureCube irradianceMap;\r\nlayout(set = 0, binding = 21) uniform texture2D brdfLUT;\r\n#ifdef SHADOWMAP\r\nlayout(set = 0, binding = 25) uniform texture2D depthTexture;\r\n#endif\r\nlayout(set = 0, binding = 26) uniform texture2D colorTexture;\r\nlayout(set = 0, binding = 28) uniform texture2D Sheen_E;\r\nlayout(set = 0, binding = 29) uniform texture2D thicknessTexture;\r\nlayout(set = 0, binding = 31) uniform texture2D anisotropyTexture;\r\nlayout(set = 0, binding = 32) uniform texture2D iridescenceThicknessTexture;\r\nlayout(set = 0, binding = 33) uniform texture2D specularColorTexture;\r\nlayout(set = 0, binding = 34) uniform texture2D diffuseTransmissionTexture;\r\nlayout(set = 0, binding = 35) uniform textureCube charlieMap;\r\n\r\nlayout(set = 0, binding = 30) uniform StateUniform {\r\n    vec4 isTone;\r\n    vec4 isIBL;\r\n    vec4 isDefaultLight;\r\n};\r\n")).map(t=>t.replace(/\n/,`\n${e}`));ve[s]=[h(t[0],"vertex"),h(t[1],"fragment")],a=ve[s]}const o=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{}}];n.forEach(e=>{(e.binding>2&&e.binding<15||29===e.binding||31===e.binding||32===e.binding||33===e.binding||34===e.binding)&&o.push({binding:e.binding,visibility:GPUShaderStage.FRAGMENT,texture:{}})}),o.push({binding:15,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:16,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:17,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:18,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:19,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube",sampleType:"float"}},{binding:20,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube",sampleType:"float"}},{binding:21,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:24,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:26,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:28,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:35,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube",sampleType:"float"}},{binding:30,visibility:GPUShaderStage.FRAGMENT,buffer:{}}),i.find(e=>"JOINTNUMBER"===e.name)&&o.push({binding:22,visibility:GPUShaderStage.VERTEX,buffer:{}}),i.find(e=>"SPHERICAL_HARMONICS"===e.name)&&o.push({binding:27,visibility:GPUShaderStage.FRAGMENT,buffer:{}}),i.find(e=>"MATRICES"===e.name)&&o.push({binding:23,visibility:GPUShaderStage.FRAGMENT,buffer:{}});const l=e.createBindGroupLayout({entries:o}),c=e.createPipelineLayout({bindGroupLayouts:[l]}),u=[3,2,3,4];i.find(e=>"JOINTNUMBER"===e.name)&&u.push(4,4),i.find(e=>"COLOR"===e.name)&&u.push(4),i.find(e=>"MULTIUV"===e.name)&&u.push(2);const f=[{arrayStride:Float32Array.BYTES_PER_ELEMENT*u.reduce((e,t)=>e+t,0),attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:Float32Array.BYTES_PER_ELEMENT*u[0],format:"float32x2"},{shaderLocation:2,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]),format:"float32x3"},{shaderLocation:3,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]+u[2]),format:"float32x4"}]}];function h(e,n){const i=t.compileGLSL(e,n);return r.convertSpirV2WGSL(i)}return i.find(e=>"JOINTNUMBER"===e.name)&&f[0].attributes.push({shaderLocation:4,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]+u[2]+u[3]),format:"float32x4"},{shaderLocation:5,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]+u[2]+u[3]+u[4]),format:"float32x4"}),i.find(e=>"COLOR"===e.name)&&f[0].attributes.push({shaderLocation:6,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]+u[2]+u[3]),format:"float32x4"}),i.find(e=>"MULTIUV"===e.name)&&(f[0].attributes.push({shaderLocation:7,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]+u[2]+u[3]),format:"float32x2"}),f[0].attributes.push({shaderLocation:8,offset:Float32Array.BYTES_PER_ELEMENT*(u[0]+u[1]+u[2]+u[3]),format:"float32x2"})),e.createRenderPipeline({layout:c,vertex:{module:e.createShaderModule({code:a[0]}),entryPoint:"main",buffers:f},fragment:{module:e.createShaderModule({code:a[1]}),entryPoint:"main",targets:[{format:"rgba16float",blend:i.find(e=>"ALPHATEST"===e.name)?{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}:void 0},{format:"rgba16float"},{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:i.find(e=>"DOUBLESIDED"===e.name)?"none":"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}})}(e.device,e.glslang,e.wgsl,t.material.uniformBindGroup1,t.defines),t.uniformBindGroup1=e.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:[...t.geometry.uniformBindGroup1,...t.material.uniformBindGroup1]})})}catch(e){console.log(e)}this.scene.tracks=this.parse.tracks,this.scene.cameras=this.parse.cameras,this.scene.lights=this.parse.lights,this.renderer.render(),t(this.scene)}buildBones(e,t,r){r.name===e&&t.bones.push(r)}resize(){this.camera.props.aspect=this.canvas.offsetWidth/this.canvas.offsetHeight,this.canvas.width=this.canvas.offsetWidth*devicePixelRatio,this.canvas.height=this.canvas.offsetHeight*devicePixelRatio;const e=this.camera.modelSize;this.camera.props.isInitial&&this.camera.setZ(1.5*e),(this.light.isInitial||"directional"===this.light.type)&&this.light.setZ(1.5*e),this.camera.updateNF()}renderScene(e){this.renderState=e,this.renderer.renderScene(),this.renderState={}}redraw(e,t,r){"zoom"===e&&(this.camera.zoom(t),this.renderer.needUpdateView=!0,this.renderer.needUpdateProjection=!0),"rotate"===e&&(this.camera.rotate(t,r),this.renderer.needUpdateView=!0),"pan"===e&&(this.camera.pan(t,r,this.canvas.offsetWidth,this.canvas.offsetHeight),this.renderer.needUpdateView=!0),"resize"===e&&(this.resize(),this.renderer.needUpdateProjection=!0),this.renderer.reflow=!0}setVariant(){console.warn("Not implemented")}draw(){console.warn("Not implemented")}getState(){return{stateBuffer:this.stateBuffer,renderState:this.renderState,lights:[],isIBL:this.isIBL,isDefaultLight:this.isDefaultLight,camera:this.camera,light:this.light,needUpdateView:this.renderer.needUpdateView,needUpdateProjection:this.renderer.needUpdateProjection}}}})(),s})());