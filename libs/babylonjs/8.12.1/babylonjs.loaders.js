(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("babylonjs"));
	else if(typeof define === 'function' && define.amd)
		define("babylonjs-loaders", ["babylonjs"], factory);
	else if(typeof exports === 'object')
		exports["babylonjs-loaders"] = factory(require("babylonjs"));
	else
		root["LOADERS"] = factory(root["BABYLON"]);
})((typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : this), (__WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_tools__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../../node_modules/tslib/tslib.es6.mjs":
/*!****************************************************!*\
  !*** ../../../../node_modules/tslib/tslib.es6.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ }),

/***/ "../../../dev/loaders/src/OBJ/index.ts":
/*!*********************************************!*\
  !*** ../../../dev/loaders/src/OBJ/index.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MTLFileLoader: () => (/* reexport safe */ _mtlFileLoader__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader),
/* harmony export */   OBJFileLoader: () => (/* reexport safe */ _objFileLoader__WEBPACK_IMPORTED_MODULE_3__.OBJFileLoader),
/* harmony export */   SolidParser: () => (/* reexport safe */ _solidParser__WEBPACK_IMPORTED_MODULE_2__.SolidParser)
/* harmony export */ });
/* harmony import */ var _mtlFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mtlFileLoader */ "../../../dev/loaders/src/OBJ/mtlFileLoader.ts");
/* harmony import */ var _objLoadingOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objLoadingOptions */ "../../../dev/loaders/src/OBJ/objLoadingOptions.ts");
/* harmony import */ var _solidParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./solidParser */ "../../../dev/loaders/src/OBJ/solidParser.ts");
/* harmony import */ var _objFileLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./objFileLoader */ "../../../dev/loaders/src/OBJ/objFileLoader.ts");






/***/ }),

/***/ "../../../dev/loaders/src/OBJ/mtlFileLoader.ts":
/*!*****************************************************!*\
  !*** ../../../dev/loaders/src/OBJ/mtlFileLoader.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MTLFileLoader: () => (/* binding */ MTLFileLoader)
/* harmony export */ });
/* harmony import */ var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/standardMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);



/**
 * Class reading and parsing the MTL file bundled with the obj file.
 */
var MTLFileLoader = /** @class */ (function () {
    function MTLFileLoader() {
        /**
         * All material loaded from the mtl will be set here
         */
        this.materials = [];
    }
    /**
     * This function will read the mtl file and create each material described inside
     * This function could be improve by adding :
     * -some component missing (Ni, Tf...)
     * -including the specific options available
     *
     * @param scene defines the scene the material will be created in
     * @param data defines the mtl data to parse
     * @param rootUrl defines the rooturl to use in order to load relative dependencies
     * @param assetContainer defines the asset container to store the material in (can be null)
     */
    MTLFileLoader.prototype.parseMTL = function (scene, data, rootUrl, assetContainer) {
        if (data instanceof ArrayBuffer) {
            return;
        }
        //Split the lines from the file
        var lines = data.split("\n");
        // whitespace char ie: [ \t\r\n\f]
        var delimiterPattern = /\s+/;
        //Array with RGB colors
        var color;
        //New material
        var material = null;
        //Look at each line
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            // Blank line or comment
            if (line.length === 0 || line.charAt(0) === "#") {
                continue;
            }
            //Get the first parameter (keyword)
            var pos = line.indexOf(" ");
            var key = pos >= 0 ? line.substring(0, pos) : line;
            key = key.toLowerCase();
            //Get the data following the key
            var value = pos >= 0 ? line.substring(pos + 1).trim() : "";
            //This mtl keyword will create the new material
            if (key === "newmtl") {
                //Check if it is the first material.
                // Materials specifications are described after this keyword.
                if (material) {
                    //Add the previous material in the material array.
                    this.materials.push(material);
                }
                //Create a new material.
                // value is the name of the material read in the mtl file
                scene._blockEntityCollection = !!assetContainer;
                material = new babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(value, scene);
                material._parentContainer = assetContainer;
                scene._blockEntityCollection = false;
            }
            else if (key === "kd" && material) {
                // Diffuse color (color under white light) using RGB values
                //value  = "r g b"
                color = value.split(delimiterPattern, 3).map(parseFloat);
                //color = [r,g,b]
                //Set tghe color into the material
                material.diffuseColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
            }
            else if (key === "ka" && material) {
                // Ambient color (color under shadow) using RGB values
                //value = "r g b"
                color = value.split(delimiterPattern, 3).map(parseFloat);
                //color = [r,g,b]
                //Set tghe color into the material
                material.ambientColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
            }
            else if (key === "ks" && material) {
                // Specular color (color when light is reflected from shiny surface) using RGB values
                //value = "r g b"
                color = value.split(delimiterPattern, 3).map(parseFloat);
                //color = [r,g,b]
                //Set the color into the material
                material.specularColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
            }
            else if (key === "ke" && material) {
                // Emissive color using RGB values
                color = value.split(delimiterPattern, 3).map(parseFloat);
                material.emissiveColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
            }
            else if (key === "ns" && material) {
                //value = "Integer"
                material.specularPower = parseFloat(value);
            }
            else if (key === "d" && material) {
                //d is dissolve for current material. It mean alpha for BABYLON
                material.alpha = parseFloat(value);
                //Texture
                //This part can be improved by adding the possible options of texture
            }
            else if (key === "map_ka" && material) {
                // ambient texture map with a loaded image
                //We must first get the folder of the image
                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);
            }
            else if (key === "map_kd" && material) {
                // Diffuse texture map with a loaded image
                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);
            }
            else if (key === "map_ks" && material) {
                // Specular texture map with a loaded image
                //We must first get the folder of the image
                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);
            }
            else if (key === "map_ns") {
                //Specular
                //Specular highlight component
                //We must first get the folder of the image
                //
                //Not supported by BABYLON
                //
                //    continue;
            }
            else if (key === "map_bump" && material) {
                //The bump texture
                var values = value.split(delimiterPattern);
                var bumpMultiplierIndex = values.indexOf("-bm");
                var bumpMultiplier = null;
                if (bumpMultiplierIndex >= 0) {
                    bumpMultiplier = values[bumpMultiplierIndex + 1];
                    values.splice(bumpMultiplierIndex, 2); // remove
                }
                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(" "), scene);
                if (material.bumpTexture && bumpMultiplier !== null) {
                    material.bumpTexture.level = parseFloat(bumpMultiplier);
                }
            }
            else if (key === "map_d" && material) {
                // The dissolve of the material
                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);
                //Options for illumination
            }
            else if (key === "illum") {
                //Illumination
                if (value === "0") {
                    //That mean Kd == Kd
                }
                else if (value === "1") {
                    //Color on and Ambient on
                }
                else if (value === "2") {
                    //Highlight on
                }
                else if (value === "3") {
                    //Reflection on and Ray trace on
                }
                else if (value === "4") {
                    //Transparency: Glass on, Reflection: Ray trace on
                }
                else if (value === "5") {
                    //Reflection: Fresnel on and Ray trace on
                }
                else if (value === "6") {
                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on
                }
                else if (value === "7") {
                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on
                }
                else if (value === "8") {
                    //Reflection on and Ray trace off
                }
                else if (value === "9") {
                    //Transparency: Glass on, Reflection: Ray trace off
                }
                else if (value === "10") {
                    //Casts shadows onto invisible surfaces
                }
            }
            else {
                // console.log("Unhandled expression at line : " + i +'\n' + "with value : " + line);
            }
        }
        //At the end of the file, add the last material
        if (material) {
            this.materials.push(material);
        }
    };
    /**
     * Gets the texture for the material.
     *
     * If the material is imported from input file,
     * We sanitize the url to ensure it takes the texture from aside the material.
     *
     * @param rootUrl The root url to load from
     * @param value The value stored in the mtl
     * @param scene
     * @returns The Texture
     */
    MTLFileLoader._GetTexture = function (rootUrl, value, scene) {
        if (!value) {
            return null;
        }
        var url = rootUrl;
        // Load from input file.
        if (rootUrl === "file:") {
            var lastDelimiter = value.lastIndexOf("\\");
            if (lastDelimiter === -1) {
                lastDelimiter = value.lastIndexOf("/");
            }
            if (lastDelimiter > -1) {
                url += value.substring(lastDelimiter + 1);
            }
            else {
                url += value;
            }
        }
        // Not from input file.
        else {
            url += value;
        }
        return new babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);
    };
    /**
     * Invert Y-Axis of referenced textures on load
     */
    MTLFileLoader.INVERT_TEXTURE_Y = true;
    return MTLFileLoader;
}());



/***/ }),

/***/ "../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts":
/*!**************************************************************!*\
  !*** ../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OBJFileLoaderMetadata: () => (/* binding */ OBJFileLoaderMetadata)
/* harmony export */ });
var OBJFileLoaderMetadata = {
    name: "obj",
    extensions: ".obj",
};


/***/ }),

/***/ "../../../dev/loaders/src/OBJ/objFileLoader.ts":
/*!*****************************************************!*\
  !*** ../../../dev/loaders/src/OBJ/objFileLoader.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OBJFileLoader: () => (/* binding */ OBJFileLoader)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/standardMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objFileLoader.metadata */ "../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts");
/* harmony import */ var _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mtlFileLoader */ "../../../dev/loaders/src/OBJ/mtlFileLoader.ts");
/* harmony import */ var _solidParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./solidParser */ "../../../dev/loaders/src/OBJ/solidParser.ts");









/**
 * OBJ file type loader.
 * This is a babylon scene loader plugin.
 */
var OBJFileLoader = /** @class */ (function () {
    /**
     * Creates loader for .OBJ files
     *
     * @param loadingOptions options for loading and parsing OBJ/MTL files.
     */
    function OBJFileLoader(loadingOptions) {
        /**
         * Defines the name of the plugin.
         */
        this.name = _objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoaderMetadata.name;
        /**
         * Defines the extension the plugin is able to load.
         */
        this.extensions = _objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoaderMetadata.extensions;
        this._assetContainer = null;
        this._loadingOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, OBJFileLoader._DefaultLoadingOptions), (loadingOptions !== null && loadingOptions !== void 0 ? loadingOptions : {}));
    }
    Object.defineProperty(OBJFileLoader, "INVERT_TEXTURE_Y", {
        /**
         * Invert Y-Axis of referenced textures on load
         */
        get: function () {
            return _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__.MTLFileLoader.INVERT_TEXTURE_Y;
        },
        set: function (value) {
            _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__.MTLFileLoader.INVERT_TEXTURE_Y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OBJFileLoader, "_DefaultLoadingOptions", {
        get: function () {
            return {
                computeNormals: OBJFileLoader.COMPUTE_NORMALS,
                optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,
                importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,
                invertY: OBJFileLoader.INVERT_Y,
                invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,
                // eslint-disable-next-line @typescript-eslint/naming-convention
                UVScaling: OBJFileLoader.UV_SCALING,
                materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,
                optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,
                skipMaterials: OBJFileLoader.SKIP_MATERIALS,
                useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Calls synchronously the MTL file attached to this obj.
     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.
     * Without this function materials are not displayed in the first frame (but displayed after).
     * In consequence it is impossible to get material information in your HTML file
     *
     * @param url The URL of the MTL file
     * @param rootUrl defines where to load data from
     * @param onSuccess Callback function to be called when the MTL file is loaded
     * @param onFailure
     */
    OBJFileLoader.prototype._loadMTL = function (url, rootUrl, onSuccess, onFailure) {
        //The complete path to the mtl file
        var pathOfFile = rootUrl + url;
        // Loads through the babylon tools to allow fileInput search.
        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, function (request, exception) {
            onFailure(pathOfFile, exception);
        });
    };
    /** @internal */
    OBJFileLoader.prototype.createPlugin = function (options) {
        return new OBJFileLoader(options[_objFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoaderMetadata.name]);
    };
    /**
     * If the data string can be loaded directly.
     * @returns if the data can be loaded directly
     */
    OBJFileLoader.prototype.canDirectLoad = function () {
        return false;
    };
    /**
     * Imports one or more meshes from the loaded OBJ data and adds them to the scene
     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
     * @param scene the scene the meshes should be added to
     * @param data the OBJ data to load
     * @param rootUrl root url to load from
     * @returns a promise containing the loaded meshes, particles, skeletons and animations
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    OBJFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl) {
        //get the meshes from OBJ file
        // eslint-disable-next-line github/no-then
        return this._parseSolidAsync(meshesNames, scene, data, rootUrl).then(function (meshes) {
            return {
                meshes: meshes,
                particleSystems: [],
                skeletons: [],
                animationGroups: [],
                transformNodes: [],
                geometries: [],
                lights: [],
                spriteManagers: [],
            };
        });
    };
    /**
     * Imports all objects from the loaded OBJ data and adds them to the scene
     * @param scene the scene the objects should be added to
     * @param data the OBJ data to load
     * @param rootUrl root url to load from
     * @returns a promise which completes when objects have been loaded to the scene
     */
    // eslint-disable-next-line no-restricted-syntax
    OBJFileLoader.prototype.loadAsync = function (scene, data, rootUrl) {
        //Get the 3D model
        // eslint-disable-next-line github/no-then
        return this.importMeshAsync(null, scene, data, rootUrl).then(function () {
            // return void
        });
    };
    /**
     * Load into an asset container.
     * @param scene The scene to load into
     * @param data The data to import
     * @param rootUrl The root url for scene and resources
     * @returns The loaded asset container
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    OBJFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl) {
        var _this = this;
        var container = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
        this._assetContainer = container;
        return (this.importMeshAsync(null, scene, data, rootUrl)
            // eslint-disable-next-line github/no-then
            .then(function (result) {
            result.meshes.forEach(function (mesh) { return container.meshes.push(mesh); });
            result.meshes.forEach(function (mesh) {
                var material = mesh.material;
                if (material) {
                    // Materials
                    if (container.materials.indexOf(material) == -1) {
                        container.materials.push(material);
                        // Textures
                        var textures = material.getActiveTextures();
                        textures.forEach(function (t) {
                            if (container.textures.indexOf(t) == -1) {
                                container.textures.push(t);
                            }
                        });
                    }
                }
            });
            _this._assetContainer = null;
            return container;
        })
            // eslint-disable-next-line github/no-then
            .catch(function (ex) {
            _this._assetContainer = null;
            throw ex;
        }));
    };
    /**
     * Read the OBJ file and create an Array of meshes.
     * Each mesh contains all information given by the OBJ and the MTL file.
     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material
     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file
     * @param scene defines the scene where are displayed the data
     * @param data defines the content of the obj file
     * @param rootUrl defines the path to the folder
     * @returns the list of loaded meshes
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    OBJFileLoader.prototype._parseSolidAsync = function (meshesNames, scene, data, rootUrl) {
        var _this = this;
        var fileToLoad = ""; //The name of the mtlFile to load
        var materialsFromMTLFile = new _mtlFileLoader__WEBPACK_IMPORTED_MODULE_2__.MTLFileLoader();
        var materialToUse = [];
        var babylonMeshesArray = []; //The mesh for babylon
        // Sanitize data
        data = data.replace(/#.*$/gm, "").trim();
        // Main function
        var solidParser = new _solidParser__WEBPACK_IMPORTED_MODULE_3__.SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);
        solidParser.parse(meshesNames, data, scene, this._assetContainer, function (fileName) {
            fileToLoad = fileName;
        });
        // load the materials
        var mtlPromises = [];
        // Check if we have a file to load
        if (fileToLoad !== "" && !this._loadingOptions.skipMaterials) {
            //Load the file synchronously
            mtlPromises.push(new Promise(function (resolve, reject) {
                _this._loadMTL(fileToLoad, rootUrl, function (dataLoaded) {
                    try {
                        //Create materials thanks MTLLoader function
                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, _this._assetContainer);
                        //Look at each material loaded in the mtl file
                        for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {
                            //Three variables to get all meshes with the same material
                            var startIndex = 0;
                            var _indices = [];
                            var _index = void 0;
                            //The material from MTL file is used in the meshes loaded
                            //Push the indice in an array
                            //Check if the material is not used for another mesh
                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {
                                _indices.push(_index);
                                startIndex = _index + 1;
                            }
                            //If the material is not used dispose it
                            if (_index === -1 && _indices.length === 0) {
                                //If the material is not needed, remove it
                                materialsFromMTLFile.materials[n].dispose();
                            }
                            else {
                                for (var o = 0; o < _indices.length; o++) {
                                    //Apply the material to the Mesh for each mesh with the material
                                    var mesh = babylonMeshesArray[_indices[o]];
                                    var material = materialsFromMTLFile.materials[n];
                                    mesh.material = material;
                                    if (!mesh.getTotalIndices()) {
                                        // No indices, we need to turn on point cloud
                                        material.pointsCloud = true;
                                    }
                                }
                            }
                        }
                        resolve();
                    }
                    catch (e) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Error processing MTL file: '".concat(fileToLoad, "'"));
                        if (_this._loadingOptions.materialLoadingFailsSilently) {
                            resolve();
                        }
                        else {
                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                            reject(e);
                        }
                    }
                }, function (pathOfFile, exception) {
                    babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Error downloading MTL file: '".concat(fileToLoad, "'"));
                    if (_this._loadingOptions.materialLoadingFailsSilently) {
                        resolve();
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                        reject(exception);
                    }
                });
            }));
        }
        //Return an array with all Mesh
        // eslint-disable-next-line github/no-then
        return Promise.all(mtlPromises).then(function () {
            var isLine = function (mesh) { var _a, _b; return Boolean((_b = (_a = mesh._internalMetadata) === null || _a === void 0 ? void 0 : _a["_isLine"]) !== null && _b !== void 0 ? _b : false); };
            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.
            babylonMeshesArray.forEach(function (mesh) {
                var _a, _b;
                if (isLine(mesh)) {
                    var mat = (_a = mesh.material) !== null && _a !== void 0 ? _a : new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(mesh.name + "_line", scene);
                    // If another mesh is using this material and it is not a line then we need to clone it.
                    var needClone = mat.getBindedMeshes().filter(function (e) { return !isLine(e); }).length > 0;
                    if (needClone) {
                        mat = (_b = mat.clone(mat.name + "_line")) !== null && _b !== void 0 ? _b : mat;
                    }
                    mat.wireframe = true;
                    mesh.material = mat;
                    if (mesh._internalMetadata) {
                        mesh._internalMetadata["_isLine"] = undefined;
                    }
                }
            });
            return babylonMeshesArray;
        });
    };
    /**
     * Defines if UVs are optimized by default during load.
     */
    OBJFileLoader.OPTIMIZE_WITH_UV = true;
    /**
     * Invert model on y-axis (does a model scaling inversion)
     */
    OBJFileLoader.INVERT_Y = false;
    /**
     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.
     */
    OBJFileLoader.IMPORT_VERTEX_COLORS = false;
    /**
     * Compute the normals for the model, even if normals are present in the file.
     */
    OBJFileLoader.COMPUTE_NORMALS = false;
    /**
     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.
     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.
     */
    OBJFileLoader.OPTIMIZE_NORMALS = false;
    /**
     * Defines custom scaling of UV coordinates of loaded meshes.
     */
    OBJFileLoader.UV_SCALING = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);
    /**
     * Skip loading the materials even if defined in the OBJ file (materials are ignored).
     */
    OBJFileLoader.SKIP_MATERIALS = false;
    /**
     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.
     *
     * Defaults to true for backwards compatibility.
     */
    OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;
    /**
     * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.
     */
    OBJFileLoader.USE_LEGACY_BEHAVIOR = false;
    return OBJFileLoader;
}());

//Add this loader into the register plugin
(0,babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new OBJFileLoader());


/***/ }),

/***/ "../../../dev/loaders/src/OBJ/objLoadingOptions.ts":
/*!*********************************************************!*\
  !*** ../../../dev/loaders/src/OBJ/objLoadingOptions.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../../../dev/loaders/src/OBJ/solidParser.ts":
/*!***************************************************!*\
  !*** ../../../dev/loaders/src/OBJ/solidParser.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SolidParser: () => (/* binding */ SolidParser)
/* harmony export */ });
/* harmony import */ var babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/logger */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__);








/**
 * Class used to load mesh data from OBJ content
 */
var SolidParser = /** @class */ (function () {
    /**
     * Creates a new SolidParser
     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)
     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)
     * @param loadingOptions defines the loading options to use
     */
    function SolidParser(materialToUse, babylonMeshesArray, loadingOptions) {
        this._positions = []; //values for the positions of vertices
        this._normals = []; //Values for the normals
        this._uvs = []; //Values for the textures
        this._colors = [];
        this._extColors = []; //Extension color
        this._meshesFromObj = []; //[mesh] Contains all the obj meshes
        this._indicesForBabylon = []; //The list of indices for VertexData
        this._wrappedPositionForBabylon = []; //The list of position in vectors
        this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices
        this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices
        this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices
        this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]
        this._curPositionInIndices = 0;
        this._hasMeshes = false; //Meshes are defined in the file
        this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]
        this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]
        this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]
        this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]
        this._triangles = []; //Indices from new triangles coming from polygons
        this._materialNameFromObj = ""; //The name of the current material
        this._objMeshName = ""; //The name of the current obj mesh
        this._increment = 1; //Id for meshes created by the multimaterial
        this._isFirstMaterial = true;
        this._grayColor = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(0.5, 0.5, 0.5, 1);
        this._hasLineData = false; //If this mesh has line segment(l) data
        this._materialToUse = materialToUse;
        this._babylonMeshesArray = babylonMeshesArray;
        this._loadingOptions = loadingOptions;
    }
    /**
     * Search for obj in the given array.
     * This function is called to check if a couple of data already exists in an array.
     *
     * If found, returns the index of the founded tuple index. Returns -1 if not found
     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>
     * @param obj Array<number>
     * @returns {boolean}
     */
    SolidParser.prototype._isInArray = function (arr, obj) {
        if (!arr[obj[0]]) {
            arr[obj[0]] = { normals: [], idx: [] };
        }
        var idx = arr[obj[0]].normals.indexOf(obj[1]);
        return idx === -1 ? -1 : arr[obj[0]].idx[idx];
    };
    SolidParser.prototype._isInArrayUV = function (arr, obj) {
        if (!arr[obj[0]]) {
            arr[obj[0]] = { normals: [], idx: [], uv: [] };
        }
        var idx = arr[obj[0]].normals.indexOf(obj[1]);
        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {
            return arr[obj[0]].idx[idx];
        }
        return -1;
    };
    /**
     * This function set the data for each triangle.
     * Data are position, normals and uvs
     * If a tuple of (position, normal) is not set, add the data into the corresponding array
     * If the tuple already exist, add only their indice
     *
     * @param indicePositionFromObj Integer The index in positions array
     * @param indiceUvsFromObj Integer The index in uvs array
     * @param indiceNormalFromObj Integer The index in normals array
     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice
     * @param textureVectorFromOBJ Vector3 The value of uvs
     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale
     * @param positionColorsFromOBJ
     */
    SolidParser.prototype._setData = function (indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {
        //Check if this tuple already exists in the list of tuples
        var _index;
        if (this._loadingOptions.optimizeWithUV) {
            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);
        }
        else {
            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);
        }
        //If it not exists
        if (_index === -1) {
            //Add an new indice.
            //The array of indices is only an array with his length equal to the number of triangles - 1.
            //We add vertices data in this order
            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);
            //Push the position of vertice for Babylon
            //Each element is a Vector3(x,y,z)
            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);
            //Push the uvs for Babylon
            //Each element is a Vector2(u,v)
            //If the UVs are missing, set (u,v)=(0,0)
            textureVectorFromOBJ = textureVectorFromOBJ !== null && textureVectorFromOBJ !== void 0 ? textureVectorFromOBJ : new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);
            //Push the normals for Babylon
            //Each element is a Vector3(x,y,z)
            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);
            if (positionColorsFromOBJ !== undefined) {
                //Push the colors for Babylon
                //Each element is a BABYLON.Color4(r,g,b,a)
                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);
            }
            //Add the tuple in the comparison list
            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);
            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);
            if (this._loadingOptions.optimizeWithUV) {
                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);
            }
        }
        else {
            //The tuple already exists
            //Add the index of the already existing tuple
            //At this index we can get the value of position, normal, color and uvs of vertex
            this._indicesForBabylon.push(_index);
        }
    };
    /**
     * Transform Vector() and BABYLON.Color() objects into numbers in an array
     */
    SolidParser.prototype._unwrapData = function () {
        try {
            //Every array has the same length
            for (var l = 0; l < this._wrappedPositionForBabylon.length; l++) {
                //Push the x, y, z values of each element in the unwrapped array
                this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x * this._handednessSign, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);
                this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x * this._handednessSign, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);
                this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON
                if (this._loadingOptions.importVertexColors) {
                    //Push the r, g, b, a values of each element in the unwrapped array
                    this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);
                }
            }
            // Reset arrays for the next new meshes
            this._wrappedPositionForBabylon.length = 0;
            this._wrappedNormalsForBabylon.length = 0;
            this._wrappedUvsForBabylon.length = 0;
            this._wrappedColorsForBabylon.length = 0;
            this._tuplePosNorm.length = 0;
            this._curPositionInIndices = 0;
        }
        catch (e) {
            throw new Error("Unable to unwrap data while parsing OBJ data.");
        }
    };
    /**
     * Create triangles from polygons
     * It is important to notice that a triangle is a polygon
     * We get 5 patterns of face defined in OBJ File :
     * facePattern1 = ["1","2","3","4","5","6"]
     * facePattern2 = ["1/1","2/2","3/3","4/4","5/5","6/6"]
     * facePattern3 = ["1/1/1","2/2/2","3/3/3","4/4/4","5/5/5","6/6/6"]
     * facePattern4 = ["1//1","2//2","3//3","4//4","5//5","6//6"]
     * facePattern5 = ["-1/-1/-1","-2/-2/-2","-3/-3/-3","-4/-4/-4","-5/-5/-5","-6/-6/-6"]
     * Each pattern is divided by the same method
     * @param faces Array[String] The indices of elements
     * @param v Integer The variable to increment
     */
    SolidParser.prototype._getTriangles = function (faces, v) {
        //Work for each element of the array
        for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {
            //Add on the triangle variable the indexes to obtain triangles
            this._pushTriangle(faces, faceIndex);
        }
        //Result obtained after 2 iterations:
        //Pattern1 => triangle = ["1","2","3","1","3","4"];
        //Pattern2 => triangle = ["1/1","2/2","3/3","1/1","3/3","4/4"];
        //Pattern3 => triangle = ["1/1/1","2/2/2","3/3/3","1/1/1","3/3/3","4/4/4"];
        //Pattern4 => triangle = ["1//1","2//2","3//3","1//1","3//3","4//4"];
        //Pattern5 => triangle = ["-1/-1/-1","-2/-2/-2","-3/-3/-3","-1/-1/-1","-3/-3/-3","-4/-4/-4"];
    };
    /**
     * To get color between color and extension color
     * @param index Integer The index of the element in the array
     * @returns value of target color
     */
    SolidParser.prototype._getColor = function (index) {
        var _a;
        if (this._loadingOptions.importVertexColors) {
            return (_a = this._extColors[index]) !== null && _a !== void 0 ? _a : this._colors[index];
        }
        else {
            return undefined;
        }
    };
    /**
     * Create triangles and push the data for each polygon for the pattern 1
     * In this pattern we get vertice positions
     * @param face
     * @param v
     */
    SolidParser.prototype._setDataForCurrentFaceWithPattern1 = function (face, v) {
        //Get the indices of triangles for each polygon
        this._getTriangles(face, v);
        //For each element in the triangles array.
        //This var could contains 1 to an infinity of triangles
        for (var k = 0; k < this._triangles.length; k++) {
            // Set position indice
            var indicePositionFromObj = parseInt(this._triangles[k]) - 1;
            this._setData(indicePositionFromObj, 0, 0, // In the pattern 1, normals and uvs are not defined
            this._positions[indicePositionFromObj], // Get the vectors data
            babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(), babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(), // Create default vectors
            this._getColor(indicePositionFromObj));
        }
        //Reset variable for the next line
        this._triangles.length = 0;
    };
    /**
     * Create triangles and push the data for each polygon for the pattern 2
     * In this pattern we get vertice positions and uvs
     * @param face
     * @param v
     */
    SolidParser.prototype._setDataForCurrentFaceWithPattern2 = function (face, v) {
        var _a;
        //Get the indices of triangles for each polygon
        this._getTriangles(face, v);
        for (var k = 0; k < this._triangles.length; k++) {
            //triangle[k] = "1/1"
            //Split the data for getting position and uv
            var point = this._triangles[k].split("/"); // ["1", "1"]
            //Set position indice
            var indicePositionFromObj = parseInt(point[0]) - 1;
            //Set uv indice
            var indiceUvsFromObj = parseInt(point[1]) - 1;
            this._setData(indicePositionFromObj, indiceUvsFromObj, 0, //Default value for normals
            this._positions[indicePositionFromObj], //Get the values for each element
            (_a = this._uvs[indiceUvsFromObj]) !== null && _a !== void 0 ? _a : babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(), babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(), //Default value for normals
            this._getColor(indicePositionFromObj));
        }
        //Reset variable for the next line
        this._triangles.length = 0;
    };
    /**
     * Create triangles and push the data for each polygon for the pattern 3
     * In this pattern we get vertice positions, uvs and normals
     * @param face
     * @param v
     */
    SolidParser.prototype._setDataForCurrentFaceWithPattern3 = function (face, v) {
        var _a, _b;
        //Get the indices of triangles for each polygon
        this._getTriangles(face, v);
        for (var k = 0; k < this._triangles.length; k++) {
            //triangle[k] = "1/1/1"
            //Split the data for getting position, uv, and normals
            var point = this._triangles[k].split("/"); // ["1", "1", "1"]
            // Set position indice
            var indicePositionFromObj = parseInt(point[0]) - 1;
            // Set uv indice
            var indiceUvsFromObj = parseInt(point[1]) - 1;
            // Set normal indice
            var indiceNormalFromObj = parseInt(point[2]) - 1;
            this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], (_a = this._uvs[indiceUvsFromObj]) !== null && _a !== void 0 ? _a : babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(), (_b = this._normals[indiceNormalFromObj]) !== null && _b !== void 0 ? _b : babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up() //Set the vector for each component
            );
        }
        //Reset variable for the next line
        this._triangles.length = 0;
    };
    /**
     * Create triangles and push the data for each polygon for the pattern 4
     * In this pattern we get vertice positions and normals
     * @param face
     * @param v
     */
    SolidParser.prototype._setDataForCurrentFaceWithPattern4 = function (face, v) {
        this._getTriangles(face, v);
        for (var k = 0; k < this._triangles.length; k++) {
            //triangle[k] = "1//1"
            //Split the data for getting position and normals
            var point = this._triangles[k].split("//"); // ["1", "1"]
            // We check indices, and normals
            var indicePositionFromObj = parseInt(point[0]) - 1;
            var indiceNormalFromObj = parseInt(point[1]) - 1;
            this._setData(indicePositionFromObj, 1, //Default value for uv
            indiceNormalFromObj, this._positions[indicePositionFromObj], //Get each vector of data
            babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(), this._normals[indiceNormalFromObj], this._getColor(indicePositionFromObj));
        }
        //Reset variable for the next line
        this._triangles.length = 0;
    };
    /*
     * Create triangles and push the data for each polygon for the pattern 3
     * In this pattern we get vertice positions, uvs and normals
     * @param face
     * @param v
     */
    SolidParser.prototype._setDataForCurrentFaceWithPattern5 = function (face, v) {
        //Get the indices of triangles for each polygon
        this._getTriangles(face, v);
        for (var k = 0; k < this._triangles.length; k++) {
            //triangle[k] = "-1/-1/-1"
            //Split the data for getting position, uv, and normals
            var point = this._triangles[k].split("/"); // ["-1", "-1", "-1"]
            // Set position indice
            var indicePositionFromObj = this._positions.length + parseInt(point[0]);
            // Set uv indice
            var indiceUvsFromObj = this._uvs.length + parseInt(point[1]);
            // Set normal indice
            var indiceNormalFromObj = this._normals.length + parseInt(point[2]);
            this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj], //Set the vector for each component
            this._getColor(indicePositionFromObj));
        }
        //Reset variable for the next line
        this._triangles.length = 0;
    };
    SolidParser.prototype._addPreviousObjMesh = function () {
        //Check if it is not the first mesh. Otherwise we don't have data.
        if (this._meshesFromObj.length > 0) {
            //Get the previous mesh for applying the data about the faces
            //=> in obj file, faces definition append after the name of the mesh
            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
            //Set the data into Array for the mesh
            this._unwrapData();
            if (this._loadingOptions.useLegacyBehavior) {
                // Reverse tab. Otherwise face are displayed in the wrong sens
                this._indicesForBabylon.reverse();
            }
            //Set the information for the mesh
            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited
            this._handledMesh.indices = this._indicesForBabylon.slice();
            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();
            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();
            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();
            this._handledMesh.hasLines = this._hasLineData;
            if (this._loadingOptions.importVertexColors) {
                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();
            }
            //Reset the array for the next mesh
            this._indicesForBabylon.length = 0;
            this._unwrappedPositionsForBabylon.length = 0;
            this._unwrappedColorsForBabylon.length = 0;
            this._unwrappedNormalsForBabylon.length = 0;
            this._unwrappedUVForBabylon.length = 0;
            this._hasLineData = false;
        }
    };
    SolidParser.prototype._optimizeNormals = function (mesh) {
        var positions = mesh.getVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
        var normals = mesh.getVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
        var mapVertices = {};
        if (!positions || !normals) {
            return;
        }
        for (var i = 0; i < positions.length / 3; i++) {
            var x = positions[i * 3 + 0];
            var y = positions[i * 3 + 1];
            var z = positions[i * 3 + 2];
            var key = x + "_" + y + "_" + z;
            var lst = mapVertices[key];
            if (!lst) {
                lst = [];
                mapVertices[key] = lst;
            }
            lst.push(i);
        }
        var normal = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
        for (var key in mapVertices) {
            var lst = mapVertices[key];
            if (lst.length < 2) {
                continue;
            }
            var v0Idx = lst[0];
            for (var i = 1; i < lst.length; ++i) {
                var vIdx = lst[i];
                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];
                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];
                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];
            }
            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);
            normal.normalize();
            for (var i = 0; i < lst.length; ++i) {
                var vIdx = lst[i];
                normals[vIdx * 3 + 0] = normal.x;
                normals[vIdx * 3 + 1] = normal.y;
                normals[vIdx * 3 + 2] = normal.z;
            }
        }
        mesh.setVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
    };
    SolidParser._IsLineElement = function (line) {
        return line.startsWith("l");
    };
    SolidParser._IsObjectElement = function (line) {
        return line.startsWith("o");
    };
    SolidParser._IsGroupElement = function (line) {
        return line.startsWith("g");
    };
    SolidParser._GetZbrushMRGB = function (line, notParse) {
        if (!line.startsWith("mrgb")) {
            return null;
        }
        line = line.replace("mrgb", "").trim();
        // if include vertex color , not load mrgb anymore
        if (notParse) {
            return [];
        }
        var regex = /[a-z0-9]/g;
        var regArray = line.match(regex);
        if (!regArray || regArray.length % 8 !== 0) {
            return [];
        }
        var array = [];
        for (var regIndex = 0; regIndex < regArray.length / 8; regIndex++) {
            //each item is MMRRGGBB, m is material index
            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];
            var r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];
            var g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];
            var b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];
            array.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));
        }
        return array;
    };
    /**
     * Function used to parse an OBJ string
     * @param meshesNames defines the list of meshes to load (all if not defined)
     * @param data defines the OBJ string
     * @param scene defines the hosting scene
     * @param assetContainer defines the asset container to load data in
     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found
     */
    SolidParser.prototype.parse = function (meshesNames, data, scene, assetContainer, onFileToLoadFound) {
        var _this = this;
        var _a, _b;
        //Move Santitize here to forbid delete zbrush data
        // Sanitize data
        data = data.replace(/#MRGB/g, "mrgb");
        data = data.replace(/#.*$/gm, "").trim();
        if (this._loadingOptions.useLegacyBehavior) {
            this._pushTriangle = function (faces, faceIndex) { return _this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]); };
            this._handednessSign = 1;
        }
        else if (scene.useRightHandedSystem) {
            this._pushTriangle = function (faces, faceIndex) { return _this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]); };
            this._handednessSign = 1;
        }
        else {
            this._pushTriangle = function (faces, faceIndex) { return _this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]); };
            this._handednessSign = -1;
        }
        // Split the file into lines
        // Preprocess line data
        var linesOBJ = data.split("\n");
        var lineLines = [];
        var currentGroup = [];
        lineLines.push(currentGroup);
        for (var i = 0; i < linesOBJ.length; i++) {
            var line = linesOBJ[i].trim().replace(/\s\s/g, " ");
            // Comment or newLine
            if (line.length === 0 || line.charAt(0) === "#") {
                continue;
            }
            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {
                currentGroup = [];
                lineLines.push(currentGroup);
            }
            if (SolidParser._IsLineElement(line)) {
                var lineValues = line.split(" ");
                // create line elements with two vertices only
                for (var i_1 = 1; i_1 < lineValues.length - 1; i_1++) {
                    currentGroup.push("l ".concat(lineValues[i_1], " ").concat(lineValues[i_1 + 1]));
                }
            }
            else {
                currentGroup.push(line);
            }
        }
        var lines = lineLines.flat();
        // Look at each line
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim().replace(/\s\s/g, " ");
            var result = void 0;
            // Comment or newLine
            if (line.length === 0 || line.charAt(0) === "#") {
                continue;
            }
            else if (SolidParser.VertexPattern.test(line)) {
                //Get information about one position possible for the vertices
                result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern
                // Value of result with line: "v 1.0 2.0 3.0"
                // ["v", "1.0", "2.0", "3.0"]
                // Create a Vector3 with the position x, y, z
                this._positions.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
                if (this._loadingOptions.importVertexColors) {
                    if (result.length >= 7) {
                        var r = parseFloat(result[4]);
                        var g = parseFloat(result[5]);
                        var b = parseFloat(result[6]);
                        this._colors.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));
                    }
                    else {
                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).
                        this._colors.push(this._grayColor);
                    }
                }
            }
            else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {
                //Create a Vector3 with the normals x, y, z
                //Value of result
                // ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
                //Add the Vector in the list of normals
                this._normals.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
            }
            else if ((result = SolidParser.UVPattern.exec(line)) !== null) {
                //Create a Vector2 with the normals u, v
                //Value of result
                // ["vt 0.1 0.2 0.3", "0.1", "0.2"]
                //Add the Vector in the list of uvs
                this._uvs.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));
                //Identify patterns of faces
                //Face could be defined in different type of pattern
            }
            else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {
                //Value of result:
                //["f 1/1/1 2/2/2 3/3/3", "1/1/1 2/2/2 3/3/3"...]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(" "), // ["1/1/1", "2/2/2", "3/3/3"]
                1);
            }
            else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {
                //Value of result:
                //["f 1//1 2//2 3//3", "1//1 2//2 3//3"...]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern4(result[1].trim().split(" "), // ["1//1", "2//2", "3//3"]
                1);
            }
            else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {
                //Value of result:
                //["f -1/-1/-1 -2/-2/-2 -3/-3/-3", "-1/-1/-1 -2/-2/-2 -3/-3/-3"...]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern5(result[1].trim().split(" "), // ["-1/-1/-1", "-2/-2/-2", "-3/-3/-3"]
                1);
            }
            else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {
                //Value of result:
                //["f 1/1 2/2 3/3", "1/1 2/2 3/3"...]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(" "), // ["1/1", "2/2", "3/3"]
                1);
            }
            else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {
                //Value of result
                //["f 1 2 3", "1 2 3"...]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(" "), // ["1", "2", "3"]
                1);
                // Define a mesh or an object
                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh
            }
            else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {
                //Value of result
                //["l 1 2"]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(" "), // ["1", "2"]
                0);
                this._hasLineData = true;
                // Define a mesh or an object
                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh
            }
            else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {
                //Value of result
                //["l 1/1 2/2"]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(" "), // ["1/1", "2/2"]
                0);
                this._hasLineData = true;
                // Define a mesh or an object
                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh
            }
            else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var element = result_1[_i];
                    this._extColors.push(element);
                }
            }
            else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {
                //Value of result
                //["l 1/1/1 2/2/2"]
                //Set the data for this face
                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(" "), // ["1/1/1", "2/2/2"]
                0);
                this._hasLineData = true;
                // Define a mesh or an object
                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh
            }
            else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {
                // Create a new mesh corresponding to the name of the group.
                // Definition of the mesh
                var objMesh = {
                    name: line.substring(2).trim(), //Set the name of the current obj mesh
                    indices: null,
                    positions: null,
                    normals: null,
                    uvs: null,
                    colors: null,
                    materialName: this._materialNameFromObj,
                    isObject: SolidParser.ObjectDescriptor.test(line),
                };
                this._addPreviousObjMesh();
                //Push the last mesh created with only the name
                this._meshesFromObj.push(objMesh);
                //Set this variable to indicate that now meshesFromObj has objects defined inside
                this._hasMeshes = true;
                this._isFirstMaterial = true;
                this._increment = 1;
                //Keyword for applying a material
            }
            else if (SolidParser.UseMtlDescriptor.test(line)) {
                //Get the name of the material
                this._materialNameFromObj = line.substring(7).trim();
                //If this new material is in the same mesh
                if (!this._isFirstMaterial || !this._hasMeshes) {
                    //Set the data for the previous mesh
                    this._addPreviousObjMesh();
                    //Create a new mesh
                    var objMesh = 
                    //Set the name of the current obj mesh
                    {
                        name: (this._objMeshName || "mesh") + "_mm" + this._increment.toString(), //Set the name of the current obj mesh
                        indices: null,
                        positions: null,
                        normals: null,
                        uvs: null,
                        colors: null,
                        materialName: this._materialNameFromObj,
                        isObject: false,
                    };
                    this._increment++;
                    //If meshes are already defined
                    this._meshesFromObj.push(objMesh);
                    this._hasMeshes = true;
                }
                //Set the material name if the previous line define a mesh
                if (this._hasMeshes && this._isFirstMaterial) {
                    //Set the material name to the previous mesh (1 material per mesh)
                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;
                    this._isFirstMaterial = false;
                }
                // Keyword for loading the mtl file
            }
            else if (SolidParser.MtlLibGroupDescriptor.test(line)) {
                // Get the name of mtl file
                onFileToLoadFound(line.substring(7).trim());
                // Apply smoothing
            }
            else if (SolidParser.SmoothDescriptor.test(line)) {
                // smooth shading => apply smoothing
                // Today I don't know it work with babylon and with obj.
                // With the obj file  an integer is set
            }
            else {
                //If there is another possibility
                babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Logger.Log("Unhandled expression at line : " + line);
            }
        }
        // At the end of the file, add the last mesh into the meshesFromObj array
        if (this._hasMeshes) {
            // Set the data for the last mesh
            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
            if (this._loadingOptions.useLegacyBehavior) {
                //Reverse indices for displaying faces in the good sense
                this._indicesForBabylon.reverse();
            }
            //Get the good array
            this._unwrapData();
            //Set array
            this._handledMesh.indices = this._indicesForBabylon;
            this._handledMesh.positions = this._unwrappedPositionsForBabylon;
            this._handledMesh.normals = this._unwrappedNormalsForBabylon;
            this._handledMesh.uvs = this._unwrappedUVForBabylon;
            this._handledMesh.hasLines = this._hasLineData;
            if (this._loadingOptions.importVertexColors) {
                this._handledMesh.colors = this._unwrappedColorsForBabylon;
            }
        }
        // If any o or g keyword not found, create a mesh with a random id
        if (!this._hasMeshes) {
            var newMaterial = null;
            if (this._indicesForBabylon.length) {
                if (this._loadingOptions.useLegacyBehavior) {
                    // reverse tab of indices
                    this._indicesForBabylon.reverse();
                }
                //Get positions normals uvs
                this._unwrapData();
            }
            else {
                // There is no indices in the file. We will have to switch to point cloud rendering
                for (var _c = 0, _d = this._positions; _c < _d.length; _c++) {
                    var pos = _d[_c];
                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);
                }
                if (this._normals.length) {
                    for (var _e = 0, _f = this._normals; _e < _f.length; _e++) {
                        var normal = _f[_e];
                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);
                    }
                }
                if (this._uvs.length) {
                    for (var _g = 0, _h = this._uvs; _g < _h.length; _g++) {
                        var uv = _h[_g];
                        this._unwrappedUVForBabylon.push(uv.x, uv.y);
                    }
                }
                if (this._extColors.length) {
                    for (var _j = 0, _k = this._extColors; _j < _k.length; _j++) {
                        var color = _k[_j];
                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
                    }
                }
                else {
                    if (this._colors.length) {
                        for (var _l = 0, _m = this._colors; _l < _m.length; _l++) {
                            var color = _m[_l];
                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
                        }
                    }
                }
                if (!this._materialNameFromObj) {
                    // Create a material with point cloud on
                    newMaterial = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Geometry.RandomId(), scene);
                    newMaterial.pointsCloud = true;
                    this._materialNameFromObj = newMaterial.name;
                    if (!this._normals.length) {
                        newMaterial.disableLighting = true;
                        newMaterial.emissiveColor = babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                    }
                }
            }
            //Set data for one mesh
            this._meshesFromObj.push({
                name: babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Geometry.RandomId(),
                indices: this._indicesForBabylon,
                positions: this._unwrappedPositionsForBabylon,
                colors: this._unwrappedColorsForBabylon,
                normals: this._unwrappedNormalsForBabylon,
                uvs: this._unwrappedUVForBabylon,
                materialName: this._materialNameFromObj,
                directMaterial: newMaterial,
                isObject: true,
                hasLines: this._hasLineData,
            });
        }
        //Set data for each mesh
        for (var j = 0; j < this._meshesFromObj.length; j++) {
            //check meshesNames (stlFileLoader)
            if (meshesNames && this._meshesFromObj[j].name) {
                if (meshesNames instanceof Array) {
                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {
                        continue;
                    }
                }
                else {
                    if (this._meshesFromObj[j].name !== meshesNames) {
                        continue;
                    }
                }
            }
            //Get the current mesh
            //Set the data with VertexBuffer for each mesh
            this._handledMesh = this._meshesFromObj[j];
            //Create a Mesh with the name of the obj mesh
            scene._blockEntityCollection = !!assetContainer;
            var babylonMesh = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Mesh(this._meshesFromObj[j].name, scene);
            babylonMesh._parentContainer = assetContainer;
            scene._blockEntityCollection = false;
            this._handledMesh._babylonMesh = babylonMesh;
            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.
            if (!this._handledMesh.isObject) {
                for (var k = j - 1; k >= 0; --k) {
                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {
                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh;
                        break;
                    }
                }
            }
            //Push the name of the material to an array
            //This is indispensable for the importMesh function
            this._materialToUse.push(this._meshesFromObj[j].materialName);
            //If the mesh is a line mesh
            if (this._handledMesh.hasLines) {
                (_a = babylonMesh._internalMetadata) !== null && _a !== void 0 ? _a : (babylonMesh._internalMetadata = {});
                babylonMesh._internalMetadata["_isLine"] = true; //this is a line mesh
            }
            if (((_b = this._handledMesh.positions) === null || _b === void 0 ? void 0 : _b.length) === 0) {
                //Push the mesh into an array
                this._babylonMeshesArray.push(babylonMesh);
                continue;
            }
            var vertexData = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexData(); //The container for the values
            //Set the data for the babylonMesh
            vertexData.uvs = this._handledMesh.uvs;
            vertexData.indices = this._handledMesh.indices;
            vertexData.positions = this._handledMesh.positions;
            if (this._loadingOptions.computeNormals) {
                var normals = new Array();
                babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);
                vertexData.normals = normals;
            }
            else {
                vertexData.normals = this._handledMesh.normals;
            }
            if (this._loadingOptions.importVertexColors) {
                vertexData.colors = this._handledMesh.colors;
            }
            //Set the data from the VertexBuffer to the current Mesh
            vertexData.applyToMesh(babylonMesh);
            if (this._loadingOptions.invertY) {
                babylonMesh.scaling.y *= -1;
            }
            if (this._loadingOptions.optimizeNormals) {
                this._optimizeNormals(babylonMesh);
            }
            //Push the mesh into an array
            this._babylonMeshesArray.push(babylonMesh);
            if (this._handledMesh.directMaterial) {
                babylonMesh.material = this._handledMesh.directMaterial;
            }
        }
    };
    // Descriptor
    /** Object descriptor */
    SolidParser.ObjectDescriptor = /^o/;
    /** Group descriptor */
    SolidParser.GroupDescriptor = /^g/;
    /** Material lib descriptor */
    SolidParser.MtlLibGroupDescriptor = /^mtllib /;
    /** Use a material descriptor */
    SolidParser.UseMtlDescriptor = /^usemtl /;
    /** Smooth descriptor */
    SolidParser.SmoothDescriptor = /^s /;
    // Patterns
    /** Pattern used to detect a vertex */
    SolidParser.VertexPattern = /^v(\s+[\d|.|+|\-|e|E]+){3,7}/;
    /** Pattern used to detect a normal */
    SolidParser.NormalPattern = /^vn(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
    /** Pattern used to detect a UV set */
    SolidParser.UVPattern = /^vt(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */
    SolidParser.FacePattern1 = /^f\s+(([\d]{1,}[\s]?){3,})+/;
    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */
    SolidParser.FacePattern2 = /^f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */
    SolidParser.FacePattern3 = /^f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/
    SolidParser.FacePattern4 = /^f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;
    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */
    SolidParser.FacePattern5 = /^f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/;
    /** Pattern used to detect a line(l vertex vertex) */
    SolidParser.LinePattern1 = /^l\s+(([\d]{1,}[\s]?){2,})+/;
    /** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */
    SolidParser.LinePattern2 = /^l\s+((([\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
    /** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */
    SolidParser.LinePattern3 = /^l\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
    return SolidParser;
}());



/***/ }),

/***/ "../../../dev/loaders/src/SPLAT/index.ts":
/*!***********************************************!*\
  !*** ../../../dev/loaders/src/SPLAT/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPLATFileLoader: () => (/* reexport safe */ _splatFileLoader__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoader)
/* harmony export */ });
/* harmony import */ var _splatLoadingOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./splatLoadingOptions */ "../../../dev/loaders/src/SPLAT/splatLoadingOptions.ts");
/* harmony import */ var _splatFileLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./splatFileLoader */ "../../../dev/loaders/src/SPLAT/splatFileLoader.ts");
/* eslint-disable import/no-internal-modules */




/***/ }),

/***/ "../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts":
/*!******************************************************************!*\
  !*** ../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPLATFileLoaderMetadata: () => (/* binding */ SPLATFileLoaderMetadata)
/* harmony export */ });
var SPLATFileLoaderMetadata = {
    name: "splat",
    extensions: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ".splat": { isBinary: true },
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ".ply": { isBinary: true },
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ".spz": { isBinary: true },
    },
};


/***/ }),

/***/ "../../../dev/loaders/src/SPLAT/splatFileLoader.ts":
/*!*********************************************************!*\
  !*** ../../../dev/loaders/src/SPLAT/splatFileLoader.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPLATFileLoader: () => (/* binding */ SPLATFileLoader)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Maths/math.scalar */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./splatFileLoader.metadata */ "../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts");












/**
 * Indicator of the parsed ply buffer. A standard ready to use splat or an array of positions for a point cloud
 */
var Mode;
(function (Mode) {
    Mode[Mode["Splat"] = 0] = "Splat";
    Mode[Mode["PointCloud"] = 1] = "PointCloud";
    Mode[Mode["Mesh"] = 2] = "Mesh";
    Mode[Mode["Reject"] = 3] = "Reject";
})(Mode || (Mode = {}));
/**
 * @experimental
 * SPLAT file type loader.
 * This is a babylon scene loader plugin.
 */
var SPLATFileLoader = /** @class */ (function () {
    /**
     * Creates loader for gaussian splatting files
     * @param loadingOptions options for loading and parsing splat and PLY files.
     */
    function SPLATFileLoader(loadingOptions) {
        if (loadingOptions === void 0) { loadingOptions = SPLATFileLoader._DefaultLoadingOptions; }
        /**
         * Defines the name of the plugin.
         */
        this.name = _splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoaderMetadata.name;
        this._assetContainer = null;
        /**
         * Defines the extensions the splat loader is able to load.
         * force data to come in as an ArrayBuffer
         */
        this.extensions = _splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoaderMetadata.extensions;
        this._loadingOptions = loadingOptions;
    }
    /** @internal */
    SPLATFileLoader.prototype.createPlugin = function (options) {
        return new SPLATFileLoader(options[_splatFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.SPLATFileLoaderMetadata.name]);
    };
    /**
     * Imports  from the loaded gaussian splatting data and adds them to the scene
     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
     * @param scene the scene the meshes should be added to
     * @param data the gaussian splatting data to load
     * @param rootUrl root url to load from
     * @param _onProgress callback called while file is loading
     * @param _fileName Defines the name of the file to load
     * @returns a promise containing the loaded meshes, particles, skeletons and animations
     */
    SPLATFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, _onProgress, _fileName) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._parseAsync(meshesNames, scene, data, rootUrl).then(function (meshes) {
                            return {
                                meshes: meshes,
                                particleSystems: [],
                                skeletons: [],
                                animationGroups: [],
                                transformNodes: [],
                                geometries: [],
                                lights: [],
                                spriteManagers: [],
                            };
                        })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    SPLATFileLoader._BuildPointCloud = function (pointcloud, data) {
        if (!data.byteLength) {
            return false;
        }
        var uBuffer = new Uint8Array(data);
        var fBuffer = new Float32Array(data);
        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)
        var rowLength = 3 * 4 + 3 * 4 + 4 + 4;
        var vertexCount = uBuffer.length / rowLength;
        var pointcloudfunc = function (particle, i) {
            var x = fBuffer[8 * i + 0];
            var y = fBuffer[8 * i + 1];
            var z = fBuffer[8 * i + 2];
            particle.position = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);
            var r = uBuffer[rowLength * i + 24 + 0] / 255;
            var g = uBuffer[rowLength * i + 24 + 1] / 255;
            var b = uBuffer[rowLength * i + 24 + 2] / 255;
            particle.color = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Color4(r, g, b, 1);
        };
        pointcloud.addPoints(vertexCount, pointcloudfunc);
        return true;
    };
    SPLATFileLoader._BuildMesh = function (scene, parsedPLY) {
        var mesh = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Mesh("PLYMesh", scene);
        var uBuffer = new Uint8Array(parsedPLY.data);
        var fBuffer = new Float32Array(parsedPLY.data);
        var rowLength = 3 * 4 + 3 * 4 + 4 + 4;
        var vertexCount = uBuffer.length / rowLength;
        var positions = [];
        var vertexData = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.VertexData();
        for (var i = 0; i < vertexCount; i++) {
            var x = fBuffer[8 * i + 0];
            var y = fBuffer[8 * i + 1];
            var z = fBuffer[8 * i + 2];
            positions.push(x, y, z);
        }
        if (parsedPLY.hasVertexColors) {
            var colors = new Float32Array(vertexCount * 4);
            for (var i = 0; i < vertexCount; i++) {
                var r = uBuffer[rowLength * i + 24 + 0] / 255;
                var g = uBuffer[rowLength * i + 24 + 1] / 255;
                var b = uBuffer[rowLength * i + 24 + 2] / 255;
                colors[i * 4 + 0] = r;
                colors[i * 4 + 1] = g;
                colors[i * 4 + 2] = b;
                colors[i * 4 + 3] = 1;
            }
            vertexData.colors = colors;
        }
        vertexData.positions = positions;
        vertexData.indices = parsedPLY.faces;
        vertexData.applyToMesh(mesh);
        return mesh;
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    SPLATFileLoader.prototype._parseSPZAsync = function (data, scene) {
        var ubuf = new Uint8Array(data);
        var ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]
        // debug infos
        var splatCount = ubufu32[2];
        var shDegree = ubuf[12];
        var fractionalBits = ubuf[13];
        var flags = ubuf[14];
        var reserved = ubuf[15];
        // check magic and version
        if (reserved || ubufu32[0] != 0x5053474e || ubufu32[1] != 2) {
            // reserved must be 0
            return new Promise(function (resolve) {
                resolve({ mode: 3 /* Mode.Reject */, data: buffer, hasVertexColors: false });
            });
        }
        var rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32
        var buffer = new ArrayBuffer(rowOutputLength * splatCount);
        var positionScale = 1.0 / (1 << fractionalBits);
        var int32View = new Int32Array(1);
        var uint8View = new Uint8Array(int32View.buffer);
        var read24bComponent = function (u8, offset) {
            uint8View[0] = u8[offset + 0];
            uint8View[1] = u8[offset + 1];
            uint8View[2] = u8[offset + 2];
            uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;
            return int32View[0] * positionScale;
        };
        var byteOffset = 16;
        var position = new Float32Array(buffer);
        var scale = new Float32Array(buffer);
        var rgba = new Uint8ClampedArray(buffer);
        var rot = new Uint8ClampedArray(buffer);
        var coordinateSign = 1;
        var quaternionOffset = 0;
        if (!this._loadingOptions.flipY) {
            coordinateSign = -1;
            quaternionOffset = 255;
        }
        // positions
        for (var i = 0; i < splatCount; i++) {
            position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);
            position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);
            position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);
            byteOffset += 9;
        }
        // colors
        var shC0 = 0.282;
        for (var i = 0; i < splatCount; i++) {
            for (var component = 0; component < 3; component++) {
                var byteValue = ubuf[byteOffset + splatCount + i * 3 + component];
                // 0.15 is hard coded value from spz
                // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can
                // be useful to represent base colors that are out of range if the higher spherical harmonics bands
                // bring them back into range so we multiply by a smaller value.
                var value = (byteValue - 127.5) / (0.15 * 255);
                rgba[i * 32 + 24 + component] = babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);
            }
            rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];
        }
        byteOffset += splatCount * 4;
        // scales
        for (var i = 0; i < splatCount; i++) {
            scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);
            scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);
            scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);
            byteOffset += 3;
        }
        // convert quaternion
        for (var i = 0; i < splatCount; i++) {
            var x = ubuf[byteOffset + 0];
            var y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;
            var z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;
            var nx = x / 127.5 - 1;
            var ny = y / 127.5 - 1;
            var nz = z / 127.5 - 1;
            rot[i * 32 + 28 + 1] = x;
            rot[i * 32 + 28 + 2] = y;
            rot[i * 32 + 28 + 3] = z;
            var v = 1 - (nx * nx + ny * ny + nz * nz);
            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;
            byteOffset += 3;
        }
        //SH
        if (shDegree) {
            // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3
            // number of vec3 vector needed per splat
            var shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color
            // number of component values : 3 per vector3 (45)
            var shComponentCount = shVectorCount * 3;
            var textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component
            var shIndexRead = byteOffset;
            // sh is an array of uint8array that will be used to create sh textures
            var sh_1 = [];
            var engine = scene.getEngine();
            var width = engine.getCaps().maxTextureSize;
            var height = Math.ceil(splatCount / width);
            // create array for the number of textures needed.
            for (var textureIndex = 0; textureIndex < textureCount; textureIndex++) {
                var texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component
                sh_1.push(texture);
            }
            for (var i = 0; i < splatCount; i++) {
                for (var shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {
                    var shValue = ubuf[shIndexRead++];
                    var textureIndex = Math.floor(shIndexWrite / 16);
                    var shArray = sh_1[textureIndex];
                    var byteIndexInTexture = shIndexWrite % 16; // [0..15]
                    var offsetPerSplat = i * 16; // 16 sh values per texture per splat.
                    shArray[byteIndexInTexture + offsetPerSplat] = shValue;
                }
            }
            return new Promise(function (resolve) {
                resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh_1, trainedWithAntialiasing: !!flags });
            });
        }
        return new Promise(function (resolve) {
            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });
        });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    SPLATFileLoader.prototype._parseAsync = function (meshesNames, scene, data, _rootUrl) {
        var _this = this;
        var babylonMeshesArray = []; //The mesh for babylon
        var readableStream = new ReadableStream({
            start: function (controller) {
                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array
                controller.close();
            },
        });
        // Use GZip DecompressionStream
        var decompressionStream = new DecompressionStream("gzip");
        var decompressedStream = readableStream.pipeThrough(decompressionStream);
        return new Promise(function (resolve) {
            new Response(decompressedStream)
                .arrayBuffer()
                // eslint-disable-next-line github/no-then
                .then(function (buffer) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                _this._parseSPZAsync(buffer, scene).then(function (parsedSPZ) {
                    scene._blockEntityCollection = !!_this._assetContainer;
                    var gaussianSplatting = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.GaussianSplattingMesh("GaussianSplatting", null, scene, _this._loadingOptions.keepInRam);
                    if (parsedSPZ.trainedWithAntialiasing) {
                        var gsMaterial = gaussianSplatting.material;
                        gsMaterial.kernelSize = 0.1;
                        gsMaterial.compensation = true;
                    }
                    gaussianSplatting._parentContainer = _this._assetContainer;
                    babylonMeshesArray.push(gaussianSplatting);
                    gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);
                    scene._blockEntityCollection = false;
                    resolve(babylonMeshesArray);
                });
            })
                // eslint-disable-next-line github/no-then
                .catch(function () {
                // Catch any decompression errors
                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                SPLATFileLoader._ConvertPLYToSplat(data).then(function (parsedPLY) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {
                    var _a, gaussianSplatting, pointcloud;
                    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                scene._blockEntityCollection = !!this._assetContainer;
                                _a = parsedPLY.mode;
                                switch (_a) {
                                    case 0 /* Mode.Splat */: return [3 /*break*/, 1];
                                    case 1 /* Mode.PointCloud */: return [3 /*break*/, 2];
                                    case 2 /* Mode.Mesh */: return [3 /*break*/, 6];
                                }
                                return [3 /*break*/, 7];
                            case 1:
                                {
                                    gaussianSplatting = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
                                    gaussianSplatting._parentContainer = this._assetContainer;
                                    babylonMeshesArray.push(gaussianSplatting);
                                    gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);
                                }
                                return [3 /*break*/, 8];
                            case 2:
                                pointcloud = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.PointsCloudSystem("PointCloud", 1, scene);
                                if (!SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) return [3 /*break*/, 4];
                                // eslint-disable-next-line github/no-then
                                return [4 /*yield*/, pointcloud.buildMeshAsync().then(function (mesh) {
                                        babylonMeshesArray.push(mesh);
                                    })];
                            case 3:
                                // eslint-disable-next-line github/no-then
                                _b.sent();
                                return [3 /*break*/, 5];
                            case 4:
                                pointcloud.dispose();
                                _b.label = 5;
                            case 5: return [3 /*break*/, 8];
                            case 6:
                                {
                                    if (parsedPLY.faces) {
                                        babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));
                                    }
                                    else {
                                        throw new Error("PLY mesh doesn't contain face informations.");
                                    }
                                }
                                return [3 /*break*/, 8];
                            case 7: throw new Error("Unsupported Splat mode");
                            case 8:
                                scene._blockEntityCollection = false;
                                resolve(babylonMeshesArray);
                                return [2 /*return*/];
                        }
                    });
                }); });
            });
        });
    };
    /**
     * Load into an asset container.
     * @param scene The scene to load into
     * @param data The data to import
     * @param rootUrl The root url for scene and resources
     * @returns The loaded asset container
     */
    // eslint-disable-next-line no-restricted-syntax
    SPLATFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl) {
        var _this = this;
        var container = new babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
        this._assetContainer = container;
        return (this.importMeshAsync(null, scene, data, rootUrl)
            // eslint-disable-next-line github/no-then
            .then(function (result) {
            for (var _i = 0, _a = result.meshes; _i < _a.length; _i++) {
                var mesh = _a[_i];
                container.meshes.push(mesh);
            }
            // mesh material will be null before 1st rendered frame.
            _this._assetContainer = null;
            return container;
        })
            // eslint-disable-next-line github/no-then
            .catch(function (ex) {
            _this._assetContainer = null;
            throw ex;
        }));
    };
    /**
     * Imports all objects from the loaded OBJ data and adds them to the scene
     * @param scene the scene the objects should be added to
     * @param data the OBJ data to load
     * @param rootUrl root url to load from
     * @returns a promise which completes when objects have been loaded to the scene
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    SPLATFileLoader.prototype.loadAsync = function (scene, data, rootUrl) {
        //Get the 3D model
        // eslint-disable-next-line github/no-then
        return this.importMeshAsync(null, scene, data, rootUrl).then(function () {
            // return void
        });
    };
    /**
     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license
     * Converts a .ply data array buffer to splat
     * if data array buffer is not ply, returns the original buffer
     * @param data the .ply data to load
     * @returns the loaded splat buffer
     */
    SPLATFileLoader._ConvertPLYToSplat = function (data) {
        var _this = this;
        var ubuf = new Uint8Array(data);
        var header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
        var headerEnd = "end_header\n";
        var headerEndIndex = header.indexOf(headerEnd);
        if (headerEndIndex < 0 || !header) {
            // standard splat
            return new Promise(function (resolve) {
                resolve({ mode: 0 /* Mode.Splat */, data: data });
            });
        }
        var vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
        var faceElement = /element face (\d+)\n/.exec(header);
        var faceCount = 0;
        if (faceElement) {
            faceCount = parseInt(faceElement[1]);
        }
        var chunkElement = /element chunk (\d+)\n/.exec(header);
        var chunkCount = 0;
        if (chunkElement) {
            chunkCount = parseInt(chunkElement[1]);
        }
        var rowVertexOffset = 0;
        var rowChunkOffset = 0;
        var offsets = {
            double: 8,
            int: 4,
            uint: 4,
            float: 4,
            short: 2,
            ushort: 2,
            uchar: 1,
            list: 0,
        };
        var ElementMode;
        (function (ElementMode) {
            ElementMode[ElementMode["Vertex"] = 0] = "Vertex";
            ElementMode[ElementMode["Chunk"] = 1] = "Chunk";
            ElementMode[ElementMode["SH"] = 2] = "SH";
        })(ElementMode || (ElementMode = {}));
        var chunkMode = 1 /* ElementMode.Chunk */;
        var vertexProperties = [];
        var chunkProperties = [];
        var filtered = header.slice(0, headerEndIndex).split("\n");
        for (var _i = 0, filtered_1 = filtered; _i < filtered_1.length; _i++) {
            var prop = filtered_1[_i];
            if (prop.startsWith("property ")) {
                var _a = prop.split(" "), type = _a[1], name_1 = _a[2];
                if (chunkMode == 1 /* ElementMode.Chunk */) {
                    chunkProperties.push({ name: name_1, type: type, offset: rowChunkOffset });
                    rowChunkOffset += offsets[type];
                }
                else if (chunkMode == 0 /* ElementMode.Vertex */) {
                    vertexProperties.push({ name: name_1, type: type, offset: rowVertexOffset });
                    rowVertexOffset += offsets[type];
                }
                else if (chunkMode == 2 /* ElementMode.SH */) {
                    vertexProperties.push({ name: name_1, type: type, offset: rowVertexOffset });
                }
                if (!offsets[type]) {
                    babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Unsupported property type: ".concat(type, "."));
                }
            }
            else if (prop.startsWith("element ")) {
                var _b = prop.split(" "), type = _b[1];
                if (type == "chunk") {
                    chunkMode = 1 /* ElementMode.Chunk */;
                }
                else if (type == "vertex") {
                    chunkMode = 0 /* ElementMode.Vertex */;
                }
                else if (type == "sh") {
                    chunkMode = 2 /* ElementMode.SH */;
                }
            }
        }
        var rowVertexLength = rowVertexOffset;
        var rowChunkLength = rowChunkOffset;
        // eslint-disable-next-line github/no-then
        return babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(function (splatsData) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {
            var dataView, offset, faces, i, faceVertexCount, j, vertexIndex, propertyCount, propertyColorCount, splatProperties, splatColorProperties, propertyIndex, property, hasMandatoryProperties, currentMode;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dataView = new DataView(data, headerEndIndex + headerEnd.length);
                        offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;
                        faces = [];
                        if (faceCount) {
                            for (i = 0; i < faceCount; i++) {
                                faceVertexCount = dataView.getUint8(offset);
                                if (faceVertexCount != 3) {
                                    continue; // only support triangles
                                }
                                offset += 1;
                                for (j = 0; j < faceVertexCount; j++) {
                                    vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true);
                                    faces.push(vertexIndex);
                                }
                                offset += 12;
                            }
                        }
                        if (!chunkCount) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolve) {
                                resolve({ mode: 0 /* Mode.Splat */, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false });
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        propertyCount = 0;
                        propertyColorCount = 0;
                        splatProperties = ["x", "y", "z", "scale_0", "scale_1", "scale_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3"];
                        splatColorProperties = ["red", "green", "blue", "f_dc_0", "f_dc_1", "f_dc_2"];
                        for (propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {
                            property = vertexProperties[propertyIndex];
                            if (splatProperties.includes(property.name)) {
                                propertyCount++;
                            }
                            if (splatColorProperties.includes(property.name)) {
                                propertyColorCount++;
                            }
                        }
                        hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;
                        currentMode = faceCount ? 2 /* Mode.Mesh */ : hasMandatoryProperties ? 0 /* Mode.Splat */ : 1 /* Mode.PointCloud */;
                        return [4 /*yield*/, new Promise(function (resolve) {
                                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount });
                            })];
                    case 3: 
                    // parsed ready ready to be used as a splat
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    SPLATFileLoader._DefaultLoadingOptions = {
        keepInRam: false,
        flipY: false,
    };
    return SPLATFileLoader;
}());

// Add this loader into the register plugin
(0,babylonjs_Loading_sceneLoader__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new SPLATFileLoader());


/***/ }),

/***/ "../../../dev/loaders/src/SPLAT/splatLoadingOptions.ts":
/*!*************************************************************!*\
  !*** ../../../dev/loaders/src/SPLAT/splatLoadingOptions.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../../../dev/loaders/src/STL/index.ts":
/*!*********************************************!*\
  !*** ../../../dev/loaders/src/STL/index.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STLFileLoader: () => (/* reexport safe */ _stlFileLoader__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader)
/* harmony export */ });
/* harmony import */ var _stlFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stlFileLoader */ "../../../dev/loaders/src/STL/stlFileLoader.ts");



/***/ }),

/***/ "../../../dev/loaders/src/STL/stlFileLoader.metadata.ts":
/*!**************************************************************!*\
  !*** ../../../dev/loaders/src/STL/stlFileLoader.metadata.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STLFileLoaderMetadata: () => (/* binding */ STLFileLoaderMetadata)
/* harmony export */ });
var STLFileLoaderMetadata = {
    name: "stl",
    extensions: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ".stl": { isBinary: true },
    },
};


/***/ }),

/***/ "../../../dev/loaders/src/STL/stlFileLoader.ts":
/*!*****************************************************!*\
  !*** ../../../dev/loaders/src/STL/stlFileLoader.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STLFileLoader: () => (/* binding */ STLFileLoader)
/* harmony export */ });
/* harmony import */ var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/standardMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _stlFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stlFileLoader.metadata */ "../../../dev/loaders/src/STL/stlFileLoader.metadata.ts");







/**
 * STL file type loader.
 * This is a babylon scene loader plugin.
 */
var STLFileLoader = /** @class */ (function () {
    function STLFileLoader() {
        /** @internal */
        this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g;
        /** @internal */
        this.facetsPattern = /facet([\s\S]*?)endfacet/g;
        /** @internal */
        this.normalPattern = /normal[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
        /** @internal */
        this.vertexPattern = /vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
        /**
         * Defines the name of the plugin.
         */
        this.name = _stlFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.STLFileLoaderMetadata.name;
        /**
         * Defines the extensions the stl loader is able to load.
         * force data to come in as an ArrayBuffer
         * we'll convert to string if it looks like it's an ASCII .stl
         */
        this.extensions = _stlFileLoader_metadata__WEBPACK_IMPORTED_MODULE_1__.STLFileLoaderMetadata.extensions;
    }
    /**
     * Import meshes into a scene.
     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
     * @param scene The scene to import into
     * @param data The data to import
     * @param rootUrl The root url for scene and resources
     * @param meshes The meshes array to import into
     * @returns True if successful or false otherwise
     */
    STLFileLoader.prototype.importMesh = function (meshesNames, scene, data, rootUrl, meshes) {
        var matches;
        if (typeof data !== "string") {
            if (this._isBinary(data)) {
                // binary .stl
                var babylonMesh = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Mesh("stlmesh", scene);
                this._parseBinary(babylonMesh, data);
                if (meshes) {
                    meshes.push(babylonMesh);
                }
                return true;
            }
            // ASCII .stl
            // convert to string
            data = new TextDecoder().decode(new Uint8Array(data));
        }
        //if arrived here, data is a string, containing the STLA data.
        while ((matches = this.solidPattern.exec(data))) {
            var meshName = matches[1];
            var meshNameFromEnd = matches[3];
            if (meshNameFromEnd && meshName != meshNameFromEnd) {
                babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.Error("Error in STL, solid name != endsolid name");
                return false;
            }
            // check meshesNames
            if (meshesNames && meshName) {
                if (meshesNames instanceof Array) {
                    if (!meshesNames.indexOf(meshName)) {
                        continue;
                    }
                }
                else {
                    if (meshName !== meshesNames) {
                        continue;
                    }
                }
            }
            // stl mesh name can be empty as well
            meshName = meshName || "stlmesh";
            var babylonMesh = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Mesh(meshName, scene);
            this._parseASCII(babylonMesh, matches[2]);
            if (meshes) {
                meshes.push(babylonMesh);
            }
        }
        return true;
    };
    /**
     * Load into a scene.
     * @param scene The scene to load into
     * @param data The data to import
     * @param rootUrl The root url for scene and resources
     * @returns true if successful or false otherwise
     */
    STLFileLoader.prototype.load = function (scene, data, rootUrl) {
        var result = this.importMesh(null, scene, data, rootUrl, null);
        return result;
    };
    /**
     * Load into an asset container.
     * @param scene The scene to load into
     * @param data The data to import
     * @param rootUrl The root url for scene and resources
     * @returns The loaded asset container
     */
    STLFileLoader.prototype.loadAssetContainer = function (scene, data, rootUrl) {
        var container = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
        scene._blockEntityCollection = true;
        this.importMesh(null, scene, data, rootUrl, container.meshes);
        scene._blockEntityCollection = false;
        return container;
    };
    STLFileLoader.prototype._isBinary = function (data) {
        // check if file size is correct for binary stl
        var reader = new DataView(data);
        // A Binary STL header is 80 bytes, if the data size is not great than
        // that then it's not a binary STL.
        if (reader.byteLength <= 80) {
            return false;
        }
        var faceSize = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8;
        var nFaces = reader.getUint32(80, true);
        if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {
            return true;
        }
        // US-ASCII begin with 's', 'o', 'l', 'i', 'd'
        var ascii = [115, 111, 108, 105, 100];
        for (var off = 0; off < 5; off++) {
            if (reader.getUint8(off) !== ascii[off]) {
                return true;
            }
        }
        return false;
    };
    STLFileLoader.prototype._parseBinary = function (mesh, data) {
        var reader = new DataView(data);
        var faces = reader.getUint32(80, true);
        var dataOffset = 84;
        var faceLength = 12 * 4 + 2;
        var offset = 0;
        var positions = new Float32Array(faces * 3 * 3);
        var normals = new Float32Array(faces * 3 * 3);
        var indices = new Uint32Array(faces * 3);
        var indicesCount = 0;
        for (var face = 0; face < faces; face++) {
            var start = dataOffset + face * faceLength;
            var normalX = reader.getFloat32(start, true);
            var normalY = reader.getFloat32(start + 4, true);
            var normalZ = reader.getFloat32(start + 8, true);
            for (var i = 1; i <= 3; i++) {
                var vertexstart = start + i * 12;
                // ordering is intentional to match ascii import
                positions[offset] = reader.getFloat32(vertexstart, true);
                normals[offset] = normalX;
                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
                    positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);
                    positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);
                    normals[offset + 2] = normalY;
                    normals[offset + 1] = normalZ;
                }
                else {
                    positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);
                    positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);
                    normals[offset + 1] = normalY;
                    normals[offset + 2] = normalZ;
                }
                offset += 3;
            }
            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
                indices[indicesCount] = indicesCount;
                indices[indicesCount + 1] = indicesCount + 2;
                indices[indicesCount + 2] = indicesCount + 1;
                indicesCount += 3;
            }
            else {
                indices[indicesCount] = indicesCount++;
                indices[indicesCount] = indicesCount++;
                indices[indicesCount] = indicesCount++;
            }
        }
        mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, positions);
        mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
        mesh.setIndices(indices);
        mesh.computeWorldMatrix(true);
    };
    STLFileLoader.prototype._parseASCII = function (mesh, solidData) {
        var positions = [];
        var normals = [];
        var indices = [];
        var indicesCount = 0;
        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices
        var matches;
        while ((matches = this.facetsPattern.exec(solidData))) {
            var facet = matches[1];
            //one normal per face
            var normalMatches = this.normalPattern.exec(facet);
            this.normalPattern.lastIndex = 0;
            if (!normalMatches) {
                continue;
            }
            var normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];
            var vertexMatch = void 0;
            while ((vertexMatch = this.vertexPattern.exec(facet))) {
                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));
                    normals.push(normal[0], normal[1], normal[2]);
                }
                else {
                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));
                    // Flipping the second and third component because inverted
                    // when normal was declared.
                    normals.push(normal[0], normal[2], normal[1]);
                }
            }
            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
                indices.push(indicesCount, indicesCount + 2, indicesCount + 1);
                indicesCount += 3;
            }
            else {
                indices.push(indicesCount++, indicesCount++, indicesCount++);
            }
            this.vertexPattern.lastIndex = 0;
        }
        this.facetsPattern.lastIndex = 0;
        mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, positions);
        mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
        mesh.setIndices(indices);
        mesh.computeWorldMatrix(true);
    };
    /**
     * Defines if Y and Z axes are swapped or not when loading an STL file.
     * The default is false to maintain backward compatibility. When set to
     * true, coordinates from the STL file are used without change.
     */
    STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = false;
    return STLFileLoader;
}());

(0,babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new STLFileLoader());


/***/ }),

/***/ "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts":
/*!****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFBinaryExtension: () => (/* binding */ GLTFBinaryExtension)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFLoader */ "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glTFLoaderUtils */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts");
/* harmony import */ var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glTFLoaderInterfaces */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts");




var BinaryExtensionBufferName = "binary_glTF";
/**
 * @internal
 * @deprecated
 */
var GLTFBinaryExtension = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(GLTFBinaryExtension, _super);
    function GLTFBinaryExtension() {
        return _super.call(this, "KHR_binary_glTF") || this;
    }
    // eslint-disable-next-line no-restricted-syntax
    GLTFBinaryExtension.prototype.loadRuntimeAsync = function (scene, data, rootUrl, onSuccess) {
        var extensionsUsed = data.json.extensionsUsed;
        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
            return false;
        }
        this._bin = data.bin;
        onSuccess(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
        return true;
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFBinaryExtension.prototype.loadBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
            return false;
        }
        if (id !== BinaryExtensionBufferName) {
            return false;
        }
        // eslint-disable-next-line github/no-then
        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, function (error) { return onError(error.message); });
        return true;
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFBinaryExtension.prototype.loadTextureBufferAsync = function (gltfRuntime, id, onSuccess) {
        var texture = gltfRuntime.textures[id];
        var source = gltfRuntime.images[texture.source];
        if (!source.extensions || !(this.name in source.extensions)) {
            return false;
        }
        var sourceExt = source.extensions[this.name];
        var bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
        var buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType.UNSIGNED_BYTE);
        onSuccess(buffer);
        return true;
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFBinaryExtension.prototype.loadShaderStringAsync = function (gltfRuntime, id, onSuccess) {
        var shader = gltfRuntime.shaders[id];
        if (!shader.extensions || !(this.name in shader.extensions)) {
            return false;
        }
        var binaryExtensionShader = shader.extensions[this.name];
        var bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
        var shaderBytes = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType.UNSIGNED_BYTE);
        setTimeout(function () {
            var shaderString = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.DecodeBufferToText(shaderBytes);
            onSuccess(shaderString);
        });
        return true;
    };
    return GLTFBinaryExtension;
}(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderExtension));

_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(new GLTFBinaryExtension());


/***/ }),

/***/ "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts":
/*!*******************************************************!*\
  !*** ../../../dev/loaders/src/glTF/1.0/glTFLoader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader),
/* harmony export */   GLTFLoaderBase: () => (/* binding */ GLTFLoaderBase),
/* harmony export */   GLTFLoaderExtension: () => (/* binding */ GLTFLoaderExtension)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFLoaderInterfaces */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babylonjs/Engines/constants */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glTFLoaderUtils */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts");
/* harmony import */ var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../glTFFileLoader */ "../../../dev/loaders/src/glTF/glTFFileLoader.ts");





























/**
 * Tokenizer. Used for shaders compatibility
 * Automatically map world, view, projection, worldViewProjection, attributes and so on
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var ETokenType;
(function (ETokenType) {
    ETokenType[ETokenType["IDENTIFIER"] = 1] = "IDENTIFIER";
    ETokenType[ETokenType["UNKNOWN"] = 2] = "UNKNOWN";
    ETokenType[ETokenType["END_OF_INPUT"] = 3] = "END_OF_INPUT";
})(ETokenType || (ETokenType = {}));
var Tokenizer = /** @class */ (function () {
    function Tokenizer(toParse) {
        this._pos = 0;
        this.currentToken = ETokenType.UNKNOWN;
        this.currentIdentifier = "";
        this.currentString = "";
        this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
        this._toParse = toParse;
        this._maxPos = toParse.length;
    }
    Tokenizer.prototype.getNextToken = function () {
        if (this.isEnd()) {
            return ETokenType.END_OF_INPUT;
        }
        this.currentString = this.read();
        this.currentToken = ETokenType.UNKNOWN;
        if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
            this.currentToken = ETokenType.IDENTIFIER;
            this.currentIdentifier = this.currentString;
            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === "_")) {
                this.currentIdentifier += this.currentString;
                this.forward();
            }
        }
        return this.currentToken;
    };
    Tokenizer.prototype.peek = function () {
        return this._toParse[this._pos];
    };
    Tokenizer.prototype.read = function () {
        return this._toParse[this._pos++];
    };
    Tokenizer.prototype.forward = function () {
        this._pos++;
    };
    Tokenizer.prototype.isEnd = function () {
        return this._pos >= this._maxPos;
    };
    return Tokenizer;
}());
/**
 * Values
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
var BabylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
// eslint-disable-next-line @typescript-eslint/naming-convention
var glTFAnimationPaths = ["translation", "rotation", "scale"];
var BabylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
/**
 * Parse
 * @param parsedBuffers
 * @param gltfRuntime
 */
var ParseBuffers = function (parsedBuffers, gltfRuntime) {
    for (var buf in parsedBuffers) {
        var parsedBuffer = parsedBuffers[buf];
        gltfRuntime.buffers[buf] = parsedBuffer;
        gltfRuntime.buffersCount++;
    }
};
var ParseShaders = function (parsedShaders, gltfRuntime) {
    for (var sha in parsedShaders) {
        var parsedShader = parsedShaders[sha];
        gltfRuntime.shaders[sha] = parsedShader;
        gltfRuntime.shaderscount++;
    }
};
var ParseObject = function (parsedObjects, runtimeProperty, gltfRuntime) {
    for (var object in parsedObjects) {
        var parsedObject = parsedObjects[object];
        gltfRuntime[runtimeProperty][object] = parsedObject;
    }
};
/**
 * Utils
 * @param buffer
 */
var NormalizeUVs = function (buffer) {
    if (!buffer) {
        return;
    }
    for (var i = 0; i < buffer.length / 2; i++) {
        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];
    }
};
var GetAttribute = function (attributeParameter) {
    if (attributeParameter.semantic === "NORMAL") {
        return "normal";
    }
    else if (attributeParameter.semantic === "POSITION") {
        return "position";
    }
    else if (attributeParameter.semantic === "JOINT") {
        return "matricesIndices";
    }
    else if (attributeParameter.semantic === "WEIGHT") {
        return "matricesWeights";
    }
    else if (attributeParameter.semantic === "COLOR") {
        return "color";
    }
    else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
        var channel = Number(attributeParameter.semantic.split("_")[1]);
        return "uv" + (channel === 0 ? "" : channel + 1);
    }
    return null;
};
/**
 * Loads and creates animations
 * @param gltfRuntime
 */
var LoadAnimations = function (gltfRuntime) {
    for (var anim in gltfRuntime.animations) {
        var animation = gltfRuntime.animations[anim];
        if (!animation.channels || !animation.samplers) {
            continue;
        }
        var lastAnimation = null;
        for (var i = 0; i < animation.channels.length; i++) {
            // Get parameters and load buffers
            var channel = animation.channels[i];
            var sampler = animation.samplers[channel.sampler];
            if (!sampler) {
                continue;
            }
            var inputData = null;
            var outputData = null;
            if (animation.parameters) {
                inputData = animation.parameters[sampler.input];
                outputData = animation.parameters[sampler.output];
            }
            else {
                inputData = sampler.input;
                outputData = sampler.output;
            }
            var bufferInput = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
            var bufferOutput = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
            var targetId = channel.target.id;
            var targetNode = gltfRuntime.scene.getNodeById(targetId);
            if (targetNode === null) {
                targetNode = gltfRuntime.scene.getNodeByName(targetId);
            }
            if (targetNode === null) {
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetId + " to attach to");
                continue;
            }
            var isBone = targetNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone;
            // Get target path (position, rotation or scaling)
            var targetPath = channel.target.path;
            var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
            if (targetPathIndex !== -1) {
                targetPath = BabylonAnimationPaths[targetPathIndex];
            }
            // Determine animation type
            var animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_MATRIX;
            if (!isBone) {
                if (targetPath === "rotationQuaternion") {
                    animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_QUATERNION;
                    targetNode.rotationQuaternion = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                }
                else {
                    animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_VECTOR3;
                }
            }
            // Create animation and key frames
            var babylonAnimation = null;
            var keys = [];
            var arrayOffset = 0;
            var modifyKey = false;
            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
                babylonAnimation = lastAnimation;
                modifyKey = true;
            }
            if (!modifyKey) {
                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                babylonAnimation = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONLOOPMODE_CYCLE);
                gltfRuntime.scene._blockEntityCollection = false;
            }
            // For each frame
            for (var j = 0; j < bufferInput.length; j++) {
                var value = null;
                if (targetPath === "rotationQuaternion") {
                    // VEC4
                    value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
                    arrayOffset += 4;
                }
                else {
                    // Position and scaling are VEC3
                    value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
                    arrayOffset += 3;
                }
                if (isBone) {
                    var bone = targetNode;
                    var translation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
                    var rotationQuaternion = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                    var scaling = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
                    // Warning on decompose
                    var mat = bone.getBaseMatrix();
                    if (modifyKey && lastAnimation) {
                        mat = lastAnimation.getKeys()[j].value;
                    }
                    mat.decompose(scaling, rotationQuaternion, translation);
                    if (targetPath === "position") {
                        translation = value;
                    }
                    else if (targetPath === "rotationQuaternion") {
                        rotationQuaternion = value;
                    }
                    else {
                        scaling = value;
                    }
                    value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Compose(scaling, rotationQuaternion, translation);
                }
                if (!modifyKey) {
                    keys.push({
                        frame: bufferInput[j],
                        value: value,
                    });
                }
                else if (lastAnimation) {
                    lastAnimation.getKeys()[j].value = value;
                }
            }
            // Finish
            if (!modifyKey && babylonAnimation) {
                babylonAnimation.setKeys(keys);
                targetNode.animations.push(babylonAnimation);
            }
            lastAnimation = babylonAnimation;
            gltfRuntime.scene.stopAnimation(targetNode);
            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);
        }
    }
};
/**
 * @returns the bones transformation matrix
 * @param node
 */
var ConfigureBoneTransformation = function (node) {
    var mat = null;
    if (node.translation || node.rotation || node.scale) {
        var scale = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.scale || [1, 1, 1]);
        var rotation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
        var position = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.translation || [0, 0, 0]);
        mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Compose(scale, rotation, position);
    }
    else {
        mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.FromArray(node.matrix);
    }
    return mat;
};
/**
 * Returns the parent bone
 * @param gltfRuntime
 * @param skins
 * @param jointName
 * @param newSkeleton
 * @returns the parent bone
 */
var GetParentBone = function (gltfRuntime, skins, jointName, newSkeleton) {
    // Try to find
    for (var i = 0; i < newSkeleton.bones.length; i++) {
        if (newSkeleton.bones[i].name === jointName) {
            return newSkeleton.bones[i];
        }
    }
    // Not found, search in gltf nodes
    var nodes = gltfRuntime.nodes;
    for (var nde in nodes) {
        var node = nodes[nde];
        if (!node.jointName) {
            continue;
        }
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
            var child = gltfRuntime.nodes[children[i]];
            if (!child.jointName) {
                continue;
            }
            if (child.jointName === jointName) {
                var mat = ConfigureBoneTransformation(node);
                var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.name || "", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
                bone.id = nde;
                return bone;
            }
        }
    }
    return null;
};
/**
 * Returns the appropriate root node
 * @param nodesToRoot
 * @param id
 * @returns the root node
 */
var GetNodeToRoot = function (nodesToRoot, id) {
    for (var i = 0; i < nodesToRoot.length; i++) {
        var nodeToRoot = nodesToRoot[i];
        for (var j = 0; j < nodeToRoot.node.children.length; j++) {
            var child = nodeToRoot.node.children[j];
            if (child === id) {
                return nodeToRoot.bone;
            }
        }
    }
    return null;
};
/**
 * Returns the node with the joint name
 * @param gltfRuntime
 * @param jointName
 * @returns the node with the joint name
 */
var GetJointNode = function (gltfRuntime, jointName) {
    var nodes = gltfRuntime.nodes;
    var node = nodes[jointName];
    if (node) {
        return {
            node: node,
            id: jointName,
        };
    }
    for (var nde in nodes) {
        node = nodes[nde];
        if (node.jointName === jointName) {
            return {
                node: node,
                id: nde,
            };
        }
    }
    return null;
};
/**
 * Checks if a nodes is in joints
 * @param skins
 * @param id
 * @returns true if the node is in joints, else false
 */
var NodeIsInJoints = function (skins, id) {
    for (var i = 0; i < skins.jointNames.length; i++) {
        if (skins.jointNames[i] === id) {
            return true;
        }
    }
    return false;
};
/**
 * Fills the nodes to root for bones and builds hierarchy
 * @param gltfRuntime
 * @param newSkeleton
 * @param skins
 * @param nodesToRoot
 */
var GetNodesToRoot = function (gltfRuntime, newSkeleton, skins, nodesToRoot) {
    // Creates nodes for root
    for (var nde in gltfRuntime.nodes) {
        var node = gltfRuntime.nodes[nde];
        var id = nde;
        if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {
            continue;
        }
        // Create node to root bone
        var mat = ConfigureBoneTransformation(node);
        var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.name || "", newSkeleton, null, mat);
        bone.id = id;
        nodesToRoot.push({ bone: bone, node: node, id: id });
    }
    // Parenting
    for (var i = 0; i < nodesToRoot.length; i++) {
        var nodeToRoot = nodesToRoot[i];
        var children = nodeToRoot.node.children;
        for (var j = 0; j < children.length; j++) {
            var child = null;
            for (var k = 0; k < nodesToRoot.length; k++) {
                if (nodesToRoot[k].id === children[j]) {
                    child = nodesToRoot[k];
                    break;
                }
            }
            if (child) {
                child.bone._parent = nodeToRoot.bone;
                nodeToRoot.bone.children.push(child.bone);
            }
        }
    }
};
/**
 * Imports a skeleton
 * @param gltfRuntime
 * @param skins
 * @param mesh
 * @param newSkeleton
 * @returns the bone name
 */
var ImportSkeleton = function (gltfRuntime, skins, mesh, newSkeleton) {
    if (!newSkeleton) {
        newSkeleton = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Skeleton(skins.name || "", "", gltfRuntime.scene);
    }
    if (!skins.babylonSkeleton) {
        return newSkeleton;
    }
    // Find the root bones
    var nodesToRoot = [];
    var nodesToRootToAdd = [];
    GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
    newSkeleton.bones = [];
    // Joints
    for (var i = 0; i < skins.jointNames.length; i++) {
        var jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);
        if (!jointNode) {
            continue;
        }
        var node = jointNode.node;
        if (!node) {
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
            continue;
        }
        var id = jointNode.id;
        // Optimize, if the bone already exists...
        var existingBone = gltfRuntime.scene.getBoneById(id);
        if (existingBone) {
            newSkeleton.bones.push(existingBone);
            continue;
        }
        // Search for parent bone
        var foundBone = false;
        var parentBone = null;
        for (var j = 0; j < i; j++) {
            var jointNode_1 = GetJointNode(gltfRuntime, skins.jointNames[j]);
            if (!jointNode_1) {
                continue;
            }
            var joint = jointNode_1.node;
            if (!joint) {
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
                continue;
            }
            var children = joint.children;
            if (!children) {
                continue;
            }
            foundBone = false;
            for (var k = 0; k < children.length; k++) {
                if (children[k] === id) {
                    parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
                    foundBone = true;
                    break;
                }
            }
            if (foundBone) {
                break;
            }
        }
        // Create bone
        var mat = ConfigureBoneTransformation(node);
        if (!parentBone && nodesToRoot.length > 0) {
            parentBone = GetNodeToRoot(nodesToRoot, id);
            if (parentBone) {
                if (nodesToRootToAdd.indexOf(parentBone) === -1) {
                    nodesToRootToAdd.push(parentBone);
                }
            }
        }
        var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.jointName || "", newSkeleton, parentBone, mat);
        bone.id = id;
    }
    // Polish
    var bones = newSkeleton.bones;
    newSkeleton.bones = [];
    for (var i = 0; i < skins.jointNames.length; i++) {
        var jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);
        if (!jointNode) {
            continue;
        }
        for (var j = 0; j < bones.length; j++) {
            if (bones[j].id === jointNode.id) {
                newSkeleton.bones.push(bones[j]);
                break;
            }
        }
    }
    newSkeleton.prepare();
    // Finish
    for (var i = 0; i < nodesToRootToAdd.length; i++) {
        newSkeleton.bones.push(nodesToRootToAdd[i]);
    }
    return newSkeleton;
};
/**
 * Imports a mesh and its geometries
 * @param gltfRuntime
 * @param node
 * @param meshes
 * @param id
 * @param newMesh
 * @returns the new mesh
 */
var ImportMesh = function (gltfRuntime, node, meshes, id, newMesh) {
    if (!newMesh) {
        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
        newMesh = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh(node.name || "", gltfRuntime.scene);
        newMesh._parentContainer = gltfRuntime.assetContainer;
        gltfRuntime.scene._blockEntityCollection = false;
        newMesh.id = id;
    }
    if (!node.babylonNode) {
        return newMesh;
    }
    var subMaterials = [];
    var vertexData = null;
    var verticesStarts = [];
    var verticesCounts = [];
    var indexStarts = [];
    var indexCounts = [];
    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        var meshId = meshes[meshIndex];
        var mesh = gltfRuntime.meshes[meshId];
        if (!mesh) {
            continue;
        }
        // Positions, normals and UVs
        for (var i = 0; i < mesh.primitives.length; i++) {
            // Temporary vertex data
            var tempVertexData = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.VertexData();
            var primitive = mesh.primitives[i];
            if (primitive.mode !== 4) {
                // continue;
            }
            var attributes = primitive.attributes;
            var accessor = null;
            var buffer = null;
            // Set positions, normal and uvs
            for (var semantic in attributes) {
                // Link accessor and buffer view
                accessor = gltfRuntime.accessors[attributes[semantic]];
                buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                if (semantic === "NORMAL") {
                    tempVertexData.normals = new Float32Array(buffer.length);
                    tempVertexData.normals.set(buffer);
                }
                else if (semantic === "POSITION") {
                    if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.HomogeneousCoordinates) {
                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
                        for (var j = 0; j < buffer.length; j += 4) {
                            tempVertexData.positions[j] = buffer[j];
                            tempVertexData.positions[j + 1] = buffer[j + 1];
                            tempVertexData.positions[j + 2] = buffer[j + 2];
                        }
                    }
                    else {
                        tempVertexData.positions = new Float32Array(buffer.length);
                        tempVertexData.positions.set(buffer);
                    }
                    verticesCounts.push(tempVertexData.positions.length);
                }
                else if (semantic.indexOf("TEXCOORD_") !== -1) {
                    var channel = Number(semantic.split("_")[1]);
                    var uvKind = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
                    var uvs = new Float32Array(buffer.length);
                    uvs.set(buffer);
                    NormalizeUVs(uvs);
                    tempVertexData.set(uvs, uvKind);
                }
                else if (semantic === "JOINT") {
                    tempVertexData.matricesIndices = new Float32Array(buffer.length);
                    tempVertexData.matricesIndices.set(buffer);
                }
                else if (semantic === "WEIGHT") {
                    tempVertexData.matricesWeights = new Float32Array(buffer.length);
                    tempVertexData.matricesWeights.set(buffer);
                }
                else if (semantic === "COLOR") {
                    tempVertexData.colors = new Float32Array(buffer.length);
                    tempVertexData.colors.set(buffer);
                }
            }
            // Indices
            accessor = gltfRuntime.accessors[primitive.indices];
            if (accessor) {
                buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                tempVertexData.indices = new Int32Array(buffer.length);
                tempVertexData.indices.set(buffer);
                indexCounts.push(tempVertexData.indices.length);
            }
            else {
                // Set indices on the fly
                var indices = [];
                for (var j = 0; j < tempVertexData.positions.length / 3; j++) {
                    indices.push(j);
                }
                tempVertexData.indices = new Int32Array(indices);
                indexCounts.push(tempVertexData.indices.length);
            }
            if (!vertexData) {
                vertexData = tempVertexData;
            }
            else {
                vertexData.merge(tempVertexData);
            }
            // Sub material
            var material_1 = gltfRuntime.scene.getMaterialById(primitive.material);
            subMaterials.push(material_1 === null ? _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1);
            // Update vertices start and index start
            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
        }
    }
    var material;
    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
    if (subMaterials.length > 1) {
        material = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.MultiMaterial("multimat" + id, gltfRuntime.scene);
        material.subMaterials = subMaterials;
    }
    else {
        material = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial("multimat" + id, gltfRuntime.scene);
    }
    if (subMaterials.length === 1) {
        material = subMaterials[0];
    }
    material._parentContainer = gltfRuntime.assetContainer;
    if (!newMesh.material) {
        newMesh.material = material;
    }
    // Apply geometry
    new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
    newMesh.computeWorldMatrix(true);
    gltfRuntime.scene._blockEntityCollection = false;
    // Apply submeshes
    newMesh.subMeshes = [];
    var index = 0;
    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        var meshId = meshes[meshIndex];
        var mesh = gltfRuntime.meshes[meshId];
        if (!mesh) {
            continue;
        }
        for (var i = 0; i < mesh.primitives.length; i++) {
            if (mesh.primitives[i].mode !== 4) {
                //continue;
            }
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
            index++;
        }
    }
    // Finish
    return newMesh;
};
/**
 * Configure node transformation from position, rotation and scaling
 * @param newNode
 * @param position
 * @param rotation
 * @param scaling
 */
var ConfigureNode = function (newNode, position, rotation, scaling) {
    if (newNode.position) {
        newNode.position = position;
    }
    if (newNode.rotationQuaternion || newNode.rotation) {
        newNode.rotationQuaternion = rotation;
    }
    if (newNode.scaling) {
        newNode.scaling = scaling;
    }
};
/**
 * Configures node from transformation matrix
 * @param newNode
 * @param node
 */
var ConfigureNodeFromMatrix = function (newNode, node) {
    if (node.matrix) {
        var position = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
        var rotation = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
        var scaling = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
        var mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.FromArray(node.matrix);
        mat.decompose(scaling, rotation, position);
        ConfigureNode(newNode, position, rotation, scaling);
    }
    else if (node.translation && node.rotation && node.scale) {
        ConfigureNode(newNode, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.translation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(node.rotation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.scale));
    }
    newNode.computeWorldMatrix(true);
};
/**
 * Imports a node
 * @param gltfRuntime
 * @param node
 * @param id
 * @returns the newly imported node
 */
var ImportNode = function (gltfRuntime, node, id) {
    var lastNode = null;
    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
            return null;
        }
    }
    // Meshes
    if (node.skin) {
        if (node.meshes) {
            var skin = gltfRuntime.skins[node.skin];
            var newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);
            if (newMesh.skeleton === null) {
                newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);
                if (!skin.babylonSkeleton) {
                    skin.babylonSkeleton = newMesh.skeleton;
                }
            }
            lastNode = newMesh;
        }
    }
    else if (node.meshes) {
        /**
         * Improve meshes property
         */
        var newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
        lastNode = newMesh;
    }
    // Lights
    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
        var light = gltfRuntime.lights[node.light];
        if (light) {
            if (light.type === "ambient") {
                var ambienLight = light[light.type];
                var hemiLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.HemisphericLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                hemiLight.name = node.name || "";
                if (ambienLight.color) {
                    hemiLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(ambienLight.color);
                }
                lastNode = hemiLight;
            }
            else if (light.type === "directional") {
                var directionalLight = light[light.type];
                var dirLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                dirLight.name = node.name || "";
                if (directionalLight.color) {
                    dirLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(directionalLight.color);
                }
                lastNode = dirLight;
            }
            else if (light.type === "point") {
                var pointLight = light[light.type];
                var ptLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.PointLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                ptLight.name = node.name || "";
                if (pointLight.color) {
                    ptLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(pointLight.color);
                }
                lastNode = ptLight;
            }
            else if (light.type === "spot") {
                var spotLight = light[light.type];
                var spLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SpotLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), 0, 0, gltfRuntime.scene);
                spLight.name = node.name || "";
                if (spotLight.color) {
                    spLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(spotLight.color);
                }
                if (spotLight.fallOfAngle) {
                    spLight.angle = spotLight.fallOfAngle;
                }
                if (spotLight.fallOffExponent) {
                    spLight.exponent = spotLight.fallOffExponent;
                }
                lastNode = spLight;
            }
        }
    }
    // Cameras
    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
        var camera = gltfRuntime.cameras[node.camera];
        if (camera) {
            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
            if (camera.type === "orthographic") {
                var orthoCamera = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.FreeCamera(node.camera, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene, false);
                orthoCamera.name = node.name || "";
                orthoCamera.mode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Camera.ORTHOGRAPHIC_CAMERA;
                orthoCamera.attachControl();
                lastNode = orthoCamera;
                orthoCamera._parentContainer = gltfRuntime.assetContainer;
            }
            else if (camera.type === "perspective") {
                var perspectiveCamera = camera[camera.type];
                var persCamera = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.FreeCamera(node.camera, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene, false);
                persCamera.name = node.name || "";
                persCamera.attachControl();
                if (!perspectiveCamera.aspectRatio) {
                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
                }
                if (perspectiveCamera.znear && perspectiveCamera.zfar) {
                    persCamera.maxZ = perspectiveCamera.zfar;
                    persCamera.minZ = perspectiveCamera.znear;
                }
                lastNode = persCamera;
                persCamera._parentContainer = gltfRuntime.assetContainer;
            }
            gltfRuntime.scene._blockEntityCollection = false;
        }
    }
    // Empty node
    if (!node.jointName) {
        if (node.babylonNode) {
            return node.babylonNode;
        }
        else if (lastNode === null) {
            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
            var dummy = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh(node.name || "", gltfRuntime.scene);
            dummy._parentContainer = gltfRuntime.assetContainer;
            gltfRuntime.scene._blockEntityCollection = false;
            node.babylonNode = dummy;
            lastNode = dummy;
        }
    }
    if (lastNode !== null) {
        if (node.matrix && lastNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
            ConfigureNodeFromMatrix(lastNode, node);
        }
        else {
            var translation = node.translation || [0, 0, 0];
            var rotation = node.rotation || [0, 0, 0, 1];
            var scale = node.scale || [1, 1, 1];
            ConfigureNode(lastNode, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(translation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(rotation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(scale));
        }
        lastNode.updateCache(true);
        node.babylonNode = lastNode;
    }
    return lastNode;
};
/**
 * Traverses nodes and creates them
 * @param gltfRuntime
 * @param id
 * @param parent
 * @param meshIncluded
 */
var TraverseNodes = function (gltfRuntime, id, parent, meshIncluded) {
    if (meshIncluded === void 0) { meshIncluded = false; }
    var node = gltfRuntime.nodes[id];
    var newNode = null;
    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
        if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
            meshIncluded = true;
        }
        else {
            meshIncluded = false;
        }
    }
    else {
        meshIncluded = true;
    }
    if (!node.jointName && meshIncluded) {
        newNode = ImportNode(gltfRuntime, node, id);
        if (newNode !== null) {
            newNode.id = id;
            newNode.parent = parent;
        }
    }
    if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
            TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
        }
    }
};
/**
 * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)
 * @param gltfRuntime
 */
var PostLoad = function (gltfRuntime) {
    // Nodes
    var currentScene = gltfRuntime.currentScene;
    if (currentScene) {
        for (var i = 0; i < currentScene.nodes.length; i++) {
            TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
        }
    }
    else {
        for (var thing in gltfRuntime.scenes) {
            currentScene = gltfRuntime.scenes[thing];
            for (var i = 0; i < currentScene.nodes.length; i++) {
                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
            }
        }
    }
    // Set animations
    LoadAnimations(gltfRuntime);
    for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
        var skeleton = gltfRuntime.scene.skeletons[i];
        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);
    }
};
/**
 * onBind shaderrs callback to set uniforms and matrices
 * @param mesh
 * @param gltfRuntime
 * @param unTreatedUniforms
 * @param shaderMaterial
 * @param technique
 * @param material
 * @param onSuccess
 */
var OnBindShaderMaterial = function (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {
    var materialValues = material.values || technique.parameters;
    for (var unif in unTreatedUniforms) {
        var uniform = unTreatedUniforms[unif];
        var type = uniform.type;
        if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT2 || type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT3 || type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT4) {
            if (uniform.semantic && !uniform.source && !uniform.node) {
                _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
            }
            else if (uniform.semantic && (uniform.source || uniform.node)) {
                var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
                if (source === null) {
                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || "");
                }
                if (source === null) {
                    continue;
                }
                _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
            }
        }
        else {
            var value = materialValues[technique.uniforms[unif]];
            if (!value) {
                continue;
            }
            if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
                if (texture === null || texture === undefined) {
                    continue;
                }
                shaderMaterial.getEffect().setTexture(unif, texture);
            }
            else {
                _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
            }
        }
    }
    onSuccess(shaderMaterial);
};
/**
 * Prepare uniforms to send the only one time
 * Loads the appropriate textures
 * @param gltfRuntime
 * @param shaderMaterial
 * @param technique
 * @param material
 */
var PrepareShaderMaterialUniforms = function (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {
    var materialValues = material.values || technique.parameters;
    var techniqueUniforms = technique.uniforms;
    var _loop_1 = function (unif) {
        var uniform = unTreatedUniforms[unif];
        var type = uniform.type;
        var value = materialValues[techniqueUniforms[unif]];
        if (value === undefined) {
            // In case the value is the same for all materials
            value = uniform.value;
        }
        if (!value) {
            return "continue";
        }
        var onLoadTexture = function (uniformName) {
            return function (texture) {
                if (uniform.value && uniformName) {
                    // Static uniform
                    shaderMaterial.setTexture(uniformName, texture);
                    delete unTreatedUniforms[uniformName];
                }
            };
        };
        // Texture (sampler2D)
        if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), function () { return onLoadTexture(null); });
        }
        // Others
        else {
            if (uniform.value && _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {
                // Static uniform
                delete unTreatedUniforms[unif];
            }
        }
    };
    /**
     * Prepare values here (not matrices)
     */
    for (var unif in unTreatedUniforms) {
        _loop_1(unif);
    }
};
/**
 * Shader compilation failed
 * @param program
 * @param shaderMaterial
 * @param onError
 * @returns callback when shader is compiled
 */
var OnShaderCompileError = function (program, shaderMaterial, onError) {
    return function (effect, error) {
        shaderMaterial.dispose(true);
        onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
    };
};
/**
 * Shader compilation success
 * @param gltfRuntime
 * @param shaderMaterial
 * @param technique
 * @param material
 * @param unTreatedUniforms
 * @param onSuccess
 * @returns callback when shader is compiled
 */
var OnShaderCompileSuccess = function (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {
    return function (_) {
        PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
        shaderMaterial.onBind = function (mesh) {
            OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
        };
    };
};
/**
 * Returns the appropriate uniform if already handled by babylon
 * @param tokenizer
 * @param technique
 * @param unTreatedUniforms
 * @returns the name of the uniform handled by babylon
 */
var ParseShaderUniforms = function (tokenizer, technique, unTreatedUniforms) {
    for (var unif in technique.uniforms) {
        var uniform = technique.uniforms[unif];
        var uniformParameter = technique.parameters[uniform];
        if (tokenizer.currentIdentifier === unif) {
            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                if (transformIndex !== -1) {
                    delete unTreatedUniforms[unif];
                    return BabylonTransforms[transformIndex];
                }
            }
        }
    }
    return tokenizer.currentIdentifier;
};
/**
 * All shaders loaded. Create materials one by one
 * @param gltfRuntime
 */
var ImportMaterials = function (gltfRuntime) {
    // Create materials
    for (var mat in gltfRuntime.materials) {
        GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function () { }, function () { });
    }
};
/**
 * Implementation of the base glTF spec
 * @internal
 */
var GLTFLoaderBase = /** @class */ (function () {
    function GLTFLoaderBase() {
    }
    GLTFLoaderBase.CreateRuntime = function (parsedData, scene, rootUrl) {
        var gltfRuntime = {
            extensions: {},
            accessors: {},
            buffers: {},
            bufferViews: {},
            meshes: {},
            lights: {},
            cameras: {},
            nodes: {},
            images: {},
            textures: {},
            shaders: {},
            programs: {},
            samplers: {},
            techniques: {},
            materials: {},
            animations: {},
            skins: {},
            extensionsUsed: [],
            scenes: {},
            buffersCount: 0,
            shaderscount: 0,
            scene: scene,
            rootUrl: rootUrl,
            loadedBufferCount: 0,
            loadedBufferViews: {},
            loadedShaderCount: 0,
            importOnlyMeshes: false,
            dummyNodes: [],
            assetContainer: null,
        };
        // Parse
        if (parsedData.extensions) {
            ParseObject(parsedData.extensions, "extensions", gltfRuntime);
        }
        if (parsedData.extensionsUsed) {
            ParseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
        }
        if (parsedData.buffers) {
            ParseBuffers(parsedData.buffers, gltfRuntime);
        }
        if (parsedData.bufferViews) {
            ParseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
        }
        if (parsedData.accessors) {
            ParseObject(parsedData.accessors, "accessors", gltfRuntime);
        }
        if (parsedData.meshes) {
            ParseObject(parsedData.meshes, "meshes", gltfRuntime);
        }
        if (parsedData.lights) {
            ParseObject(parsedData.lights, "lights", gltfRuntime);
        }
        if (parsedData.cameras) {
            ParseObject(parsedData.cameras, "cameras", gltfRuntime);
        }
        if (parsedData.nodes) {
            ParseObject(parsedData.nodes, "nodes", gltfRuntime);
        }
        if (parsedData.images) {
            ParseObject(parsedData.images, "images", gltfRuntime);
        }
        if (parsedData.textures) {
            ParseObject(parsedData.textures, "textures", gltfRuntime);
        }
        if (parsedData.shaders) {
            ParseShaders(parsedData.shaders, gltfRuntime);
        }
        if (parsedData.programs) {
            ParseObject(parsedData.programs, "programs", gltfRuntime);
        }
        if (parsedData.samplers) {
            ParseObject(parsedData.samplers, "samplers", gltfRuntime);
        }
        if (parsedData.techniques) {
            ParseObject(parsedData.techniques, "techniques", gltfRuntime);
        }
        if (parsedData.materials) {
            ParseObject(parsedData.materials, "materials", gltfRuntime);
        }
        if (parsedData.animations) {
            ParseObject(parsedData.animations, "animations", gltfRuntime);
        }
        if (parsedData.skins) {
            ParseObject(parsedData.skins, "skins", gltfRuntime);
        }
        if (parsedData.scenes) {
            gltfRuntime.scenes = parsedData.scenes;
        }
        if (parsedData.scene && parsedData.scenes) {
            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
        }
        return gltfRuntime;
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderBase.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {
        var buffer = gltfRuntime.buffers[id];
        if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(buffer.uri)) {
            setTimeout(function () { return onSuccess(new Uint8Array(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.DecodeBase64(buffer.uri))); });
        }
        else {
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function (data) { return onSuccess(new Uint8Array(data)); }, onProgress, undefined, true, function (request) {
                if (request) {
                    onError(request.status + " " + request.statusText);
                }
            });
        }
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderBase.LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        var texture = gltfRuntime.textures[id];
        if (!texture || !texture.source) {
            onError("");
            return;
        }
        if (texture.babylonTexture) {
            onSuccess(null);
            return;
        }
        var source = gltfRuntime.images[texture.source];
        if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(source.uri)) {
            setTimeout(function () { return onSuccess(new Uint8Array(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.DecodeBase64(source.uri))); });
        }
        else {
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function (data) { return onSuccess(new Uint8Array(data)); }, undefined, undefined, true, function (request) {
                if (request) {
                    onError(request.status + " " + request.statusText);
                }
            });
        }
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderBase.CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess) {
        var texture = gltfRuntime.textures[id];
        if (texture.babylonTexture) {
            onSuccess(texture.babylonTexture);
            return;
        }
        var sampler = gltfRuntime.samplers[texture.sampler];
        var createMipMaps = sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_NEAREST ||
            sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_LINEAR ||
            sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_NEAREST ||
            sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_LINEAR;
        var samplingMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.BILINEAR_SAMPLINGMODE;
        var blob = buffer == null ? new Blob() : new Blob([buffer]);
        var blobURL = URL.createObjectURL(blob);
        var revokeBlobURL = function () { return URL.revokeObjectURL(blobURL); };
        var newTexture = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
        if (sampler.wrapS !== undefined) {
            newTexture.wrapU = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetWrapMode(sampler.wrapS);
        }
        if (sampler.wrapT !== undefined) {
            newTexture.wrapV = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetWrapMode(sampler.wrapT);
        }
        newTexture.name = id;
        texture.babylonTexture = newTexture;
        onSuccess(newTexture);
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderBase.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        var shader = gltfRuntime.shaders[id];
        if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(shader.uri)) {
            var shaderString = atob(shader.uri.split(",")[1]);
            if (onSuccess) {
                onSuccess(shaderString);
            }
        }
        else {
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, function (request) {
                if (request && onError) {
                    onError(request.status + " " + request.statusText);
                }
            });
        }
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderBase.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        var material = gltfRuntime.materials[id];
        if (!material.technique) {
            if (onError) {
                onError("No technique found.");
            }
            return;
        }
        var technique = gltfRuntime.techniques[material.technique];
        if (!technique) {
            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
            var defaultMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial(id, gltfRuntime.scene);
            defaultMaterial._parentContainer = gltfRuntime.assetContainer;
            gltfRuntime.scene._blockEntityCollection = false;
            defaultMaterial.diffuseColor = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3(0.5, 0.5, 0.5);
            defaultMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
            onSuccess(defaultMaterial);
            return;
        }
        var program = gltfRuntime.programs[technique.program];
        var states = technique.states;
        var vertexShader = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.vertexShader + "VertexShader"];
        var pixelShader = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.fragmentShader + "PixelShader"];
        var newVertexShader = "";
        var newPixelShader = "";
        var vertexTokenizer = new Tokenizer(vertexShader);
        var pixelTokenizer = new Tokenizer(pixelShader);
        var unTreatedUniforms = {};
        var uniforms = [];
        var attributes = [];
        var samplers = [];
        // Fill uniform, sampler2D and attributes
        for (var unif in technique.uniforms) {
            var uniform = technique.uniforms[unif];
            var uniformParameter = technique.parameters[uniform];
            unTreatedUniforms[unif] = uniformParameter;
            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                if (transformIndex !== -1) {
                    uniforms.push(BabylonTransforms[transformIndex]);
                    delete unTreatedUniforms[unif];
                }
                else {
                    uniforms.push(unif);
                }
            }
            else if (uniformParameter.type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                samplers.push(unif);
            }
            else {
                uniforms.push(unif);
            }
        }
        for (var attr in technique.attributes) {
            var attribute = technique.attributes[attr];
            var attributeParameter = technique.parameters[attribute];
            if (attributeParameter.semantic) {
                var name_1 = GetAttribute(attributeParameter);
                if (name_1) {
                    attributes.push(name_1);
                }
            }
        }
        // Configure vertex shader
        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
            var tokenType = vertexTokenizer.currentToken;
            if (tokenType !== ETokenType.IDENTIFIER) {
                newVertexShader += vertexTokenizer.currentString;
                continue;
            }
            var foundAttribute = false;
            for (var attr in technique.attributes) {
                var attribute = technique.attributes[attr];
                var attributeParameter = technique.parameters[attribute];
                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
                    newVertexShader += GetAttribute(attributeParameter);
                    foundAttribute = true;
                    break;
                }
            }
            if (foundAttribute) {
                continue;
            }
            newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
        }
        // Configure pixel shader
        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
            var tokenType = pixelTokenizer.currentToken;
            if (tokenType !== ETokenType.IDENTIFIER) {
                newPixelShader += pixelTokenizer.currentString;
                continue;
            }
            newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
        }
        // Create shader material
        var shaderPath = {
            vertex: program.vertexShader + id,
            fragment: program.fragmentShader + id,
        };
        var options = {
            attributes: attributes,
            uniforms: uniforms,
            samplers: samplers,
            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,
        };
        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
        var shaderMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
        shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);
        shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
        shaderMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
        if (states && states.functions) {
            var functions = states.functions;
            if (functions.cullFace && functions.cullFace[0] !== _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ECullingType.BACK) {
                shaderMaterial.backFaceCulling = false;
            }
            var blendFunc = functions.blendFuncSeparate;
            if (blendFunc) {
                if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA &&
                    blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_ALPHA &&
                    blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_COMBINE;
                }
                else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO &&
                    blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_ONEONE;
                }
                else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA &&
                    blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO &&
                    blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_ADD;
                }
                else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO &&
                    blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_COLOR &&
                    blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_SUBTRACT;
                }
                else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.DST_COLOR &&
                    blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO &&
                    blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_MULTIPLY;
                }
                else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA &&
                    blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_COLOR &&
                    blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE &&
                    blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_MAXIMIZED;
                }
            }
        }
    };
    return GLTFLoaderBase;
}());

/**
 * glTF V1 Loader
 * @internal
 * @deprecated
 */
var GLTFLoader = /** @class */ (function () {
    function GLTFLoader() {
    }
    GLTFLoader.RegisterExtension = function (extension) {
        if (GLTFLoader.Extensions[extension.name]) {
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error('Tool with the same name "' + extension.name + '" already exists');
            return;
        }
        GLTFLoader.Extensions[extension.name] = extension;
    };
    GLTFLoader.prototype.dispose = function () {
        // do nothing
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._importMeshAsync = function (meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {
        var _this = this;
        scene.useRightHandedSystem = true;
        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {
            gltfRuntime.assetContainer = assetContainer;
            gltfRuntime.importOnlyMeshes = true;
            if (meshesNames === "") {
                gltfRuntime.importMeshesNames = [];
            }
            else if (typeof meshesNames === "string") {
                gltfRuntime.importMeshesNames = [meshesNames];
            }
            else if (meshesNames && !(meshesNames instanceof Array)) {
                gltfRuntime.importMeshesNames = [meshesNames];
            }
            else {
                gltfRuntime.importMeshesNames = [];
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Argument meshesNames must be of type string or string[]");
            }
            // Create nodes
            _this._createNodes(gltfRuntime);
            var meshes = [];
            var skeletons = [];
            // Fill arrays of meshes and skeletons
            for (var nde in gltfRuntime.nodes) {
                var node = gltfRuntime.nodes[nde];
                if (node.babylonNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.AbstractMesh) {
                    meshes.push(node.babylonNode);
                }
            }
            for (var skl in gltfRuntime.skins) {
                var skin = gltfRuntime.skins[skl];
                if (skin.babylonSkeleton instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Skeleton) {
                    skeletons.push(skin.babylonSkeleton);
                }
            }
            // Load buffers, shaders, materials, etc.
            _this._loadBuffersAsync(gltfRuntime, function () {
                _this._loadShadersAsync(gltfRuntime, function () {
                    ImportMaterials(gltfRuntime);
                    PostLoad(gltfRuntime);
                    if (!_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading && onSuccess) {
                        onSuccess(meshes, skeletons);
                    }
                });
            });
            if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading && onSuccess) {
                onSuccess(meshes, skeletons);
            }
        }, onError);
        return true;
    };
    /**
     * Imports one or more meshes from a loaded gltf file and adds them to the scene
     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
     * @param scene the scene the meshes should be added to
     * @param assetContainer defines the asset container to use (can be null)
     * @param data gltf data containing information of the meshes in a loaded file
     * @param rootUrl root url to load from
     * @param onProgress event that fires when loading progress has occured
     * @returns a promise containg the loaded meshes, particles, skeletons and animations
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype.importMeshAsync = function (meshesNames, scene, assetContainer, data, rootUrl, onProgress) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, function (meshes, skeletons) {
                resolve({
                    meshes: meshes,
                    particleSystems: [],
                    skeletons: skeletons,
                    animationGroups: [],
                    lights: [],
                    transformNodes: [],
                    geometries: [],
                    spriteManagers: [],
                });
            }, onProgress, function (message) {
                reject(new Error(message));
            });
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._loadAsync = function (scene, data, rootUrl, onSuccess, onProgress, onError) {
        var _this = this;
        scene.useRightHandedSystem = true;
        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {
            // Load runtime extensios
            GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function () {
                // Create nodes
                _this._createNodes(gltfRuntime);
                // Load buffers, shaders, materials, etc.
                _this._loadBuffersAsync(gltfRuntime, function () {
                    _this._loadShadersAsync(gltfRuntime, function () {
                        ImportMaterials(gltfRuntime);
                        PostLoad(gltfRuntime);
                        if (!_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading) {
                            onSuccess();
                        }
                    });
                });
                if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading) {
                    onSuccess();
                }
            }, onError);
        }, onError);
    };
    /**
     * Imports all objects from a loaded gltf file and adds them to the scene
     * @param scene the scene the objects should be added to
     * @param data gltf data containing information of the meshes in a loaded file
     * @param rootUrl root url to load from
     * @param onProgress event that fires when loading progress has occured
     * @returns a promise which completes when objects have been loaded to the scene
     */
    GLTFLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function () {
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            _this._loadAsync(scene, data, rootUrl, function () {
                                resolve();
                            }, onProgress, function (message) {
                                reject(new Error(message));
                            });
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._loadShadersAsync = function (gltfRuntime, onload) {
        var hasShaders = false;
        var processShader = function (sha, shader) {
            GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, function (shaderString) {
                if (shaderString instanceof ArrayBuffer) {
                    return;
                }
                gltfRuntime.loadedShaderCount++;
                if (shaderString) {
                    babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[sha + (shader.type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
                }
                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
                    onload();
                }
            }, function () {
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Error when loading shader program named " + sha + " located at " + shader.uri);
            });
        };
        for (var sha in gltfRuntime.shaders) {
            hasShaders = true;
            var shader = gltfRuntime.shaders[sha];
            if (shader) {
                processShader.bind(this, sha, shader)();
            }
            else {
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("No shader named: " + sha);
            }
        }
        if (!hasShaders) {
            onload();
        }
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._loadBuffersAsync = function (gltfRuntime, onLoad) {
        var hasBuffers = false;
        var processBuffer = function (buf, buffer) {
            GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, function (bufferView) {
                gltfRuntime.loadedBufferCount++;
                if (bufferView) {
                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Buffer named " + buf + " is length " + bufferView.byteLength + ". Expected: " + buffer.byteLength); // Improve error message
                    }
                    gltfRuntime.loadedBufferViews[buf] = bufferView;
                }
                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
                    onLoad();
                }
            }, function () {
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Error when loading buffer named " + buf + " located at " + buffer.uri);
            });
        };
        for (var buf in gltfRuntime.buffers) {
            hasBuffers = true;
            var buffer = gltfRuntime.buffers[buf];
            if (buffer) {
                processBuffer.bind(this, buf, buffer)();
            }
            else {
                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("No buffer named: " + buf);
            }
        }
        if (!hasBuffers) {
            onLoad();
        }
    };
    GLTFLoader.prototype._createNodes = function (gltfRuntime) {
        var currentScene = gltfRuntime.currentScene;
        if (currentScene) {
            // Only one scene even if multiple scenes are defined
            for (var i = 0; i < currentScene.nodes.length; i++) {
                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
            }
        }
        else {
            // Load all scenes
            for (var thing in gltfRuntime.scenes) {
                currentScene = gltfRuntime.scenes[thing];
                for (var i = 0; i < currentScene.nodes.length; i++) {
                    TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
                }
            }
        }
    };
    GLTFLoader.Extensions = {};
    return GLTFLoader;
}());

/** @internal */
var GLTFLoaderExtension = /** @class */ (function () {
    function GLTFLoaderExtension(name) {
        this._name = name;
    }
    Object.defineProperty(GLTFLoaderExtension.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Defines an override for loading the runtime
     * Return true to stop further extensions from loading the runtime
     * @param scene
     * @param data
     * @param rootUrl
     * @param onSuccess
     * @param onError
     * @returns true to stop further extensions from loading the runtime
     */
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.loadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {
        return false;
    };
    /**
     * Defines an onverride for creating gltf runtime
     * Return true to stop further extensions from creating the runtime
     * @param gltfRuntime
     * @param onSuccess
     * @param onError
     * @returns true to stop further extensions from creating the runtime
     */
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {
        return false;
    };
    /**
     * Defines an override for loading buffers
     * Return true to stop further extensions from loading this buffer
     * @param gltfRuntime
     * @param id
     * @param onSuccess
     * @param onError
     * @param onProgress
     * @returns true to stop further extensions from loading this buffer
     */
    // eslint-disable-next-line no-restricted-syntax
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.loadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {
        return false;
    };
    /**
     * Defines an override for loading texture buffers
     * Return true to stop further extensions from loading this texture data
     * @param gltfRuntime
     * @param id
     * @param onSuccess
     * @param onError
     * @returns true to stop further extensions from loading this texture data
     */
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.loadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        return false;
    };
    /**
     * Defines an override for creating textures
     * Return true to stop further extensions from loading this texture
     * @param gltfRuntime
     * @param id
     * @param buffer
     * @param onSuccess
     * @param onError
     * @returns true to stop further extensions from loading this texture
     */
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.createTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {
        return false;
    };
    /**
     * Defines an override for loading shader strings
     * Return true to stop further extensions from loading this shader data
     * @param gltfRuntime
     * @param id
     * @param onSuccess
     * @param onError
     * @returns true to stop further extensions from loading this shader data
     */
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.loadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        return false;
    };
    /**
     * Defines an override for loading materials
     * Return true to stop further extensions from loading this material
     * @param gltfRuntime
     * @param id
     * @param onSuccess
     * @param onError
     * @returns true to stop further extensions from loading this material
     */
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        return false;
    };
    // ---------
    // Utilities
    // ---------
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.LoadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
        }, function () {
            setTimeout(function () {
                if (!onSuccess) {
                    return;
                }
                onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
            });
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.LoadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
        }, function () {
            setTimeout(function () {
                onSuccess();
            });
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
        }, function () {
            GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.LoadTextureAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {
            if (buffer) {
                GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
            }
        }, onError);
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
        }, function () {
            GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
        }, function () {
            GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension._LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
        }, function () {
            GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
        });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoaderExtension._CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {
        GLTFLoaderExtension._ApplyExtensions(function (loaderExtension) {
            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
        }, function () {
            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);
        });
    };
    GLTFLoaderExtension._ApplyExtensions = function (func, defaultFunc) {
        for (var extensionName in GLTFLoader.Extensions) {
            var loaderExtension = GLTFLoader.Extensions[extensionName];
            if (func(loaderExtension)) {
                return;
            }
        }
        defaultFunc();
    };
    return GLTFLoaderExtension;
}());

_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader._CreateGLTF1Loader = function () { return new GLTFLoader(); };


/***/ }),

/***/ "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts":
/*!*****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EBlendingFunction: () => (/* binding */ EBlendingFunction),
/* harmony export */   EComponentType: () => (/* binding */ EComponentType),
/* harmony export */   ECullingType: () => (/* binding */ ECullingType),
/* harmony export */   EParameterType: () => (/* binding */ EParameterType),
/* harmony export */   EShaderType: () => (/* binding */ EShaderType),
/* harmony export */   ETextureFilterType: () => (/* binding */ ETextureFilterType),
/* harmony export */   ETextureFormat: () => (/* binding */ ETextureFormat),
/* harmony export */   ETextureWrapMode: () => (/* binding */ ETextureWrapMode)
/* harmony export */ });
/**
 * Enums
 * @internal
 */
var EComponentType;
(function (EComponentType) {
    EComponentType[EComponentType["BYTE"] = 5120] = "BYTE";
    EComponentType[EComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    EComponentType[EComponentType["SHORT"] = 5122] = "SHORT";
    EComponentType[EComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    EComponentType[EComponentType["FLOAT"] = 5126] = "FLOAT";
})(EComponentType || (EComponentType = {}));
/** @internal */
var EShaderType;
(function (EShaderType) {
    EShaderType[EShaderType["FRAGMENT"] = 35632] = "FRAGMENT";
    EShaderType[EShaderType["VERTEX"] = 35633] = "VERTEX";
})(EShaderType || (EShaderType = {}));
/** @internal */
var EParameterType;
(function (EParameterType) {
    EParameterType[EParameterType["BYTE"] = 5120] = "BYTE";
    EParameterType[EParameterType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    EParameterType[EParameterType["SHORT"] = 5122] = "SHORT";
    EParameterType[EParameterType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    EParameterType[EParameterType["INT"] = 5124] = "INT";
    EParameterType[EParameterType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    EParameterType[EParameterType["FLOAT"] = 5126] = "FLOAT";
    EParameterType[EParameterType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    EParameterType[EParameterType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    EParameterType[EParameterType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    EParameterType[EParameterType["INT_VEC2"] = 35667] = "INT_VEC2";
    EParameterType[EParameterType["INT_VEC3"] = 35668] = "INT_VEC3";
    EParameterType[EParameterType["INT_VEC4"] = 35669] = "INT_VEC4";
    EParameterType[EParameterType["BOOL"] = 35670] = "BOOL";
    EParameterType[EParameterType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    EParameterType[EParameterType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    EParameterType[EParameterType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    EParameterType[EParameterType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    EParameterType[EParameterType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    EParameterType[EParameterType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    EParameterType[EParameterType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
})(EParameterType || (EParameterType = {}));
/** @internal */
var ETextureWrapMode;
(function (ETextureWrapMode) {
    ETextureWrapMode[ETextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    ETextureWrapMode[ETextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    ETextureWrapMode[ETextureWrapMode["REPEAT"] = 10497] = "REPEAT";
})(ETextureWrapMode || (ETextureWrapMode = {}));
/** @internal */
var ETextureFilterType;
(function (ETextureFilterType) {
    ETextureFilterType[ETextureFilterType["NEAREST"] = 9728] = "NEAREST";
    ETextureFilterType[ETextureFilterType["LINEAR"] = 9728] = "LINEAR";
    ETextureFilterType[ETextureFilterType["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    ETextureFilterType[ETextureFilterType["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    ETextureFilterType[ETextureFilterType["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    ETextureFilterType[ETextureFilterType["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterType || (ETextureFilterType = {}));
/** @internal */
var ETextureFormat;
(function (ETextureFormat) {
    ETextureFormat[ETextureFormat["ALPHA"] = 6406] = "ALPHA";
    ETextureFormat[ETextureFormat["RGB"] = 6407] = "RGB";
    ETextureFormat[ETextureFormat["RGBA"] = 6408] = "RGBA";
    ETextureFormat[ETextureFormat["LUMINANCE"] = 6409] = "LUMINANCE";
    ETextureFormat[ETextureFormat["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
})(ETextureFormat || (ETextureFormat = {}));
/** @internal */
var ECullingType;
(function (ECullingType) {
    ECullingType[ECullingType["FRONT"] = 1028] = "FRONT";
    ECullingType[ECullingType["BACK"] = 1029] = "BACK";
    ECullingType[ECullingType["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(ECullingType || (ECullingType = {}));
/** @internal */
var EBlendingFunction;
(function (EBlendingFunction) {
    EBlendingFunction[EBlendingFunction["ZERO"] = 0] = "ZERO";
    EBlendingFunction[EBlendingFunction["ONE"] = 1] = "ONE";
    EBlendingFunction[EBlendingFunction["SRC_COLOR"] = 768] = "SRC_COLOR";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    EBlendingFunction[EBlendingFunction["DST_COLOR"] = 774] = "DST_COLOR";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    EBlendingFunction[EBlendingFunction["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    EBlendingFunction[EBlendingFunction["DST_ALPHA"] = 772] = "DST_ALPHA";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    EBlendingFunction[EBlendingFunction["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    EBlendingFunction[EBlendingFunction["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    EBlendingFunction[EBlendingFunction["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(EBlendingFunction || (EBlendingFunction = {}));


/***/ }),

/***/ "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts":
/*!************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFUtils: () => (/* binding */ GLTFUtils)
/* harmony export */ });
/* harmony import */ var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFLoaderInterfaces */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babylonjs/Materials/Textures/texture */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);






/**
 * Utils functions for GLTF
 * @internal
 * @deprecated
 */
var GLTFUtils = /** @class */ (function () {
    function GLTFUtils() {
    }
    /**
     * Sets the given "parameter" matrix
     * @param scene the Scene object
     * @param source the source node where to pick the matrix
     * @param parameter the GLTF technique parameter
     * @param uniformName the name of the shader's uniform
     * @param shaderMaterial the shader material
     */
    GLTFUtils.SetMatrix = function (scene, source, parameter, uniformName, shaderMaterial) {
        var mat = null;
        if (parameter.semantic === "MODEL") {
            mat = source.getWorldMatrix();
        }
        else if (parameter.semantic === "PROJECTION") {
            mat = scene.getProjectionMatrix();
        }
        else if (parameter.semantic === "VIEW") {
            mat = scene.getViewMatrix();
        }
        else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
            mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
        }
        else if (parameter.semantic === "MODELVIEW") {
            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
        }
        else if (parameter.semantic === "MODELVIEWPROJECTION") {
            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
        }
        else if (parameter.semantic === "MODELINVERSE") {
            mat = source.getWorldMatrix().invert();
        }
        else if (parameter.semantic === "VIEWINVERSE") {
            mat = scene.getViewMatrix().invert();
        }
        else if (parameter.semantic === "PROJECTIONINVERSE") {
            mat = scene.getProjectionMatrix().invert();
        }
        else if (parameter.semantic === "MODELVIEWINVERSE") {
            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
        }
        else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
        }
        else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
            mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Transpose(source.getWorldMatrix().invert());
        }
        if (mat) {
            switch (parameter.type) {
                case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT2:
                    shaderMaterial.setMatrix2x2(uniformName, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.GetAsMatrix2x2(mat));
                    break;
                case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT3:
                    shaderMaterial.setMatrix3x3(uniformName, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.GetAsMatrix3x3(mat));
                    break;
                case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT4:
                    shaderMaterial.setMatrix(uniformName, mat);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Sets the given "parameter" matrix
     * @param shaderMaterial the shader material
     * @param uniform the name of the shader's uniform
     * @param value the value of the uniform
     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)
     * @returns true if set, else false
     */
    GLTFUtils.SetUniform = function (shaderMaterial, uniform, value, type) {
        switch (type) {
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT:
                shaderMaterial.setFloat(uniform, value);
                return true;
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC2:
                shaderMaterial.setVector2(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2.FromArray(value));
                return true;
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC3:
                shaderMaterial.setVector3(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(value));
                return true;
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC4:
                shaderMaterial.setVector4(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector4.FromArray(value));
                return true;
            default:
                return false;
        }
    };
    /**
     * Returns the wrap mode of the texture
     * @param mode the mode value
     * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)
     */
    GLTFUtils.GetWrapMode = function (mode) {
        switch (mode) {
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.CLAMP_TO_EDGE:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_ADDRESSMODE;
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.MIRRORED_REPEAT:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.MIRROR_ADDRESSMODE;
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.REPEAT:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_ADDRESSMODE;
            default:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_ADDRESSMODE;
        }
    };
    /**
     * Returns the byte stride giving an accessor
     * @param accessor the GLTF accessor objet
     * @returns the byte stride
     */
    GLTFUtils.GetByteStrideFromType = function (accessor) {
        // Needs this function since "byteStride" isn't requiered in glTF format
        var type = accessor.type;
        switch (type) {
            case "VEC2":
                return 2;
            case "VEC3":
                return 3;
            case "VEC4":
                return 4;
            case "MAT2":
                return 4;
            case "MAT3":
                return 9;
            case "MAT4":
                return 16;
            default:
                return 1;
        }
    };
    /**
     * Returns the texture filter mode giving a mode value
     * @param mode the filter mode value
     * @returns the filter mode (TODO - needs to be a type?)
     */
    GLTFUtils.GetTextureFilterMode = function (mode) {
        switch (mode) {
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR:
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_NEAREST:
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_LINEAR:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.TRILINEAR_SAMPLINGMODE;
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST:
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_NEAREST:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.NEAREST_SAMPLINGMODE;
            default:
                return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.BILINEAR_SAMPLINGMODE;
        }
    };
    GLTFUtils.GetBufferFromBufferView = function (gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
        byteOffset = bufferView.byteOffset + byteOffset;
        var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
        if (byteOffset + byteLength > loadedBufferView.byteLength) {
            throw new Error("Buffer access is out of range");
        }
        var buffer = loadedBufferView.buffer;
        byteOffset += loadedBufferView.byteOffset;
        switch (componentType) {
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.BYTE:
                return new Int8Array(buffer, byteOffset, byteLength);
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.UNSIGNED_BYTE:
                return new Uint8Array(buffer, byteOffset, byteLength);
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.SHORT:
                return new Int16Array(buffer, byteOffset, byteLength);
            case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.UNSIGNED_SHORT:
                return new Uint16Array(buffer, byteOffset, byteLength);
            default:
                return new Float32Array(buffer, byteOffset, byteLength);
        }
    };
    /**
     * Returns a buffer from its accessor
     * @param gltfRuntime the GLTF runtime
     * @param accessor the GLTF accessor
     * @returns an array buffer view
     */
    GLTFUtils.GetBufferFromAccessor = function (gltfRuntime, accessor) {
        var bufferView = gltfRuntime.bufferViews[accessor.bufferView];
        var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);
        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
    };
    /**
     * Decodes a buffer view into a string
     * @param view the buffer view
     * @returns a string
     */
    GLTFUtils.DecodeBufferToText = function (view) {
        var result = "";
        var length = view.byteLength;
        for (var i = 0; i < length; ++i) {
            result += String.fromCharCode(view[i]);
        }
        return result;
    };
    /**
     * Returns the default material of gltf. Related to
     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material
     * @param scene the Babylon.js scene
     * @returns the default Babylon material
     */
    GLTFUtils.GetDefaultMaterial = function (scene) {
        if (!GLTFUtils._DefaultMaterial) {
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
                "precision highp float;",
                "",
                "uniform mat4 worldView;",
                "uniform mat4 projection;",
                "",
                "attribute vec3 position;",
                "",
                "void main(void)",
                "{",
                "    gl_Position = projection * worldView * vec4(position, 1.0);",
                "}",
            ].join("\n");
            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
                "precision highp float;",
                "",
                "uniform vec4 u_emission;",
                "",
                "void main(void)",
                "{",
                "    gl_FragColor = u_emission;",
                "}",
            ].join("\n");
            var shaderPath = {
                vertex: "GLTFDefaultMaterial",
                fragment: "GLTFDefaultMaterial",
            };
            var options = {
                attributes: ["position"],
                uniforms: ["worldView", "projection", "u_emission"],
                samplers: new Array(),
                needAlphaBlending: false,
            };
            GLTFUtils._DefaultMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
            GLTFUtils._DefaultMaterial.setColor4("u_emission", new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color4(0.5, 0.5, 0.5, 1.0));
        }
        return GLTFUtils._DefaultMaterial;
    };
    // The GLTF default material
    GLTFUtils._DefaultMaterial = null;
    return GLTFUtils;
}());



/***/ }),

/***/ "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts":
/*!*************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFMaterialsCommonExtension: () => (/* binding */ GLTFMaterialsCommonExtension)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFLoader */ "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babylonjs/Lights/spotLight */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);











/**
 * @internal
 * @deprecated
 */
var GLTFMaterialsCommonExtension = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(GLTFMaterialsCommonExtension, _super);
    function GLTFMaterialsCommonExtension() {
        return _super.call(this, "KHR_materials_common") || this;
    }
    // eslint-disable-next-line no-restricted-syntax
    GLTFMaterialsCommonExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime) {
        if (!gltfRuntime.extensions) {
            return false;
        }
        var extension = gltfRuntime.extensions[this.name];
        if (!extension) {
            return false;
        }
        // Create lights
        var lights = extension.lights;
        if (lights) {
            for (var thing in lights) {
                var light = lights[thing];
                switch (light.type) {
                    case "ambient": {
                        var ambientLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.HemisphericLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0), gltfRuntime.scene);
                        var ambient = light.ambient;
                        if (ambient) {
                            ambientLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(ambient.color || [1, 1, 1]);
                        }
                        break;
                    }
                    case "point": {
                        var pointLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.PointLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(10, 10, 10), gltfRuntime.scene);
                        var point = light.point;
                        if (point) {
                            pointLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(point.color || [1, 1, 1]);
                        }
                        break;
                    }
                    case "directional": {
                        var dirLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), gltfRuntime.scene);
                        var directional = light.directional;
                        if (directional) {
                            dirLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(directional.color || [1, 1, 1]);
                        }
                        break;
                    }
                    case "spot": {
                        var spot = light.spot;
                        if (spot) {
                            var spotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SpotLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 10, 0), new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0.0, gltfRuntime.scene);
                            spotLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(spot.color || [1, 1, 1]);
                        }
                        break;
                    }
                    default:
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn('GLTF Material Common extension: light type "' + light.type + "” not supported");
                        break;
                }
            }
        }
        return false;
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFMaterialsCommonExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        var material = gltfRuntime.materials[id];
        if (!material || !material.extensions) {
            return false;
        }
        var extension = material.extensions[this.name];
        if (!extension) {
            return false;
        }
        var standardMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial(id, gltfRuntime.scene);
        standardMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
        if (extension.technique === "CONSTANT") {
            standardMaterial.disableLighting = true;
        }
        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;
        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;
        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;
        // Ambient
        if (typeof extension.values.ambient === "string") {
            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
        }
        else {
            standardMaterial.ambientColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.ambient || [0, 0, 0]);
        }
        // Diffuse
        if (typeof extension.values.diffuse === "string") {
            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
        }
        else {
            standardMaterial.diffuseColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
        }
        // Emission
        if (typeof extension.values.emission === "string") {
            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
        }
        else {
            standardMaterial.emissiveColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.emission || [0, 0, 0]);
        }
        // Specular
        if (typeof extension.values.specular === "string") {
            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
        }
        else {
            standardMaterial.specularColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.specular || [0, 0, 0]);
        }
        return true;
    };
    GLTFMaterialsCommonExtension.prototype._loadTexture = function (gltfRuntime, id, material, propertyPath, onError) {
        // Create buffer from texture url
        _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {
            // Create texture from buffer
            _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function (texture) { return (material[propertyPath] = texture); });
        }, onError);
    };
    return GLTFMaterialsCommonExtension;
}(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderExtension));

_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());


/***/ }),

/***/ "../../../dev/loaders/src/glTF/1.0/index.ts":
/*!**************************************************!*\
  !*** ../../../dev/loaders/src/glTF/1.0/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EBlendingFunction: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EBlendingFunction),
/* harmony export */   EComponentType: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType),
/* harmony export */   ECullingType: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ECullingType),
/* harmony export */   EParameterType: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EParameterType),
/* harmony export */   EShaderType: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EShaderType),
/* harmony export */   ETextureFilterType: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureFilterType),
/* harmony export */   ETextureFormat: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureFormat),
/* harmony export */   ETextureWrapMode: () => (/* reexport safe */ _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureWrapMode),
/* harmony export */   GLTFBinaryExtension: () => (/* reexport safe */ _glTFBinaryExtension__WEBPACK_IMPORTED_MODULE_0__.GLTFBinaryExtension),
/* harmony export */   GLTFLoader: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader),
/* harmony export */   GLTFLoaderBase: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderBase),
/* harmony export */   GLTFLoaderExtension: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderExtension),
/* harmony export */   GLTFMaterialsCommonExtension: () => (/* reexport safe */ _glTFMaterialsCommonExtension__WEBPACK_IMPORTED_MODULE_4__.GLTFMaterialsCommonExtension),
/* harmony export */   GLTFUtils: () => (/* reexport safe */ _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_3__.GLTFUtils)
/* harmony export */ });
/* harmony import */ var _glTFBinaryExtension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFBinaryExtension */ "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glTFLoader */ "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glTFLoaderInterfaces */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts");
/* harmony import */ var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glTFLoaderUtils */ "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts");
/* harmony import */ var _glTFMaterialsCommonExtension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glTFMaterialsCommonExtension */ "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts");







/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts":
/*!**********************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_lights_ies: () => (/* binding */ EXT_lights_ies)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/Textures/texture */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");








var NAME = "EXT_lights_ies";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_lights_ies)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_lights_ies = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_lights_ies(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    EXT_lights_ies.prototype.dispose = function () {
        this._loader = null;
        delete this._lights;
    };
    /** @internal */
    EXT_lights_ies.prototype.onLoading = function () {
        var extensions = this._loader.gltf.extensions;
        if (extensions && extensions[this.name]) {
            var extension = extensions[this.name];
            this._lights = extension.lights;
            _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._lights);
        }
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    // eslint-disable-next-line no-restricted-syntax
    EXT_lights_ies.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var babylonSpotLight, light, transformNode, bufferData, bufferView;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._loader._allMaterialsDirtyRequired = true;
                        return [4 /*yield*/, this._loader.loadNodeAsync(context, node, function (babylonMesh) {
                                light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this._lights, extension.light);
                                var name = light.name || babylonMesh.name;
                                _this._loader.babylonScene._blockEntityCollection = !!_this._loader._assetContainer;
                                babylonSpotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), 0, 1, _this._loader.babylonScene);
                                babylonSpotLight.angle = Math.PI / 2;
                                babylonSpotLight.innerAngle = 0;
                                babylonSpotLight._parentContainer = _this._loader._assetContainer;
                                _this._loader.babylonScene._blockEntityCollection = false;
                                light._babylonLight = babylonSpotLight;
                                babylonSpotLight.falloffType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Light.FALLOFF_GLTF;
                                babylonSpotLight.diffuse = extension.color ? babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(extension.color) : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                                babylonSpotLight.intensity = extension.multiplier || 1;
                                babylonSpotLight.range = Number.MAX_VALUE;
                                babylonSpotLight.parent = babylonMesh;
                                _this._loader._babylonLights.push(babylonSpotLight);
                                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.AddPointerMetadata(babylonSpotLight, extensionContext);
                                assign(babylonMesh);
                            })];
                    case 1:
                        transformNode = _a.sent();
                        if (!light.uri) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._loader.loadUriAsync(context, light, light.uri)];
                    case 2:
                        bufferData = _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/bufferView"), this._loader.gltf.bufferViews, light.bufferView);
                        return [4 /*yield*/, this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView)];
                    case 4:
                        bufferData = _a.sent();
                        _a.label = 5;
                    case 5:
                        babylonSpotLight.iesProfileTexture = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Texture(name + "_iesProfile", this._loader.babylonScene, true, false, undefined, null, null, bufferData, true, undefined, undefined, undefined, undefined, ".ies");
                        return [2 /*return*/, transformNode];
                }
            });
        }); });
    };
    return EXT_lights_ies;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_lights_ies(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts":
/*!******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_lights_image_based: () => (/* binding */ EXT_lights_image_based)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/Textures/rawCubeTexture */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");






var NAME = "EXT_lights_image_based";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_lights_image_based = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_lights_image_based(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    EXT_lights_image_based.prototype.dispose = function () {
        this._loader = null;
        delete this._lights;
    };
    /** @internal */
    EXT_lights_image_based.prototype.onLoading = function () {
        var extensions = this._loader.gltf.extensions;
        if (extensions && extensions[this.name]) {
            var extension = extensions[this.name];
            this._lights = extension.lights;
        }
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    EXT_lights_image_based.prototype.loadSceneAsync = function (context, scene) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises, light;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._loader._allMaterialsDirtyRequired = true;
                        promises = new Array();
                        promises.push(this._loader.loadSceneAsync(context, scene));
                        this._loader.logOpen("".concat(extensionContext));
                        light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/light"), this._lights, extension.light);
                        promises.push(
                        // eslint-disable-next-line github/no-then
                        this._loadLightAsync("/extensions/".concat(this.name, "/lights/").concat(extension.light), light).then(function (texture) {
                            _this._loader.babylonScene.environmentTexture = texture;
                        }));
                        this._loader.logClose();
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    EXT_lights_image_based.prototype._loadLightAsync = function (context, light) {
        var _this = this;
        if (!light._loaded) {
            var promises = new Array();
            this._loader.logOpen("".concat(context));
            var imageData_1 = new Array(light.specularImages.length);
            var _loop_1 = function (mipmap) {
                var faces = light.specularImages[mipmap];
                imageData_1[mipmap] = new Array(faces.length);
                var _loop_2 = function (face) {
                    var specularImageContext = "".concat(context, "/specularImages/").concat(mipmap, "/").concat(face);
                    this_1._loader.logOpen("".concat(specularImageContext));
                    var index = faces[face];
                    var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(specularImageContext, this_1._loader.gltf.images, index);
                    promises.push(
                    // eslint-disable-next-line github/no-then
                    this_1._loader.loadImageAsync("/images/".concat(index), image).then(function (data) {
                        imageData_1[mipmap][face] = data;
                    }));
                    this_1._loader.logClose();
                };
                for (var face = 0; face < faces.length; face++) {
                    _loop_2(face);
                }
            };
            var this_1 = this;
            for (var mipmap = 0; mipmap < light.specularImages.length; mipmap++) {
                _loop_1(mipmap);
            }
            this._loader.logClose();
            // eslint-disable-next-line github/no-then
            light._loaded = Promise.all(promises).then(function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                var babylonTexture, rotation, sphericalHarmonics, sphericalPolynomial, lodGenerationScale;
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            babylonTexture = new babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);
                            babylonTexture.name = light.name || "environment";
                            light._babylonTexture = babylonTexture;
                            if (light.intensity != undefined) {
                                babylonTexture.level = light.intensity;
                            }
                            if (light.rotation) {
                                rotation = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(light.rotation);
                                // Invert the rotation so that positive rotation is counter-clockwise.
                                if (!this._loader.babylonScene.useRightHandedSystem) {
                                    rotation = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Inverse(rotation);
                                }
                                babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());
                            }
                            if (!light.irradianceCoefficients) {
                                throw new Error("".concat(context, ": Irradiance coefficients are missing"));
                            }
                            sphericalHarmonics = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics.FromArray(light.irradianceCoefficients);
                            sphericalHarmonics.scaleInPlace(light.intensity);
                            sphericalHarmonics.convertIrradianceToLambertianRadiance();
                            sphericalPolynomial = babylonjs_Maths_sphericalPolynomial__WEBPACK_IMPORTED_MODULE_0__.SphericalPolynomial.FromHarmonics(sphericalHarmonics);
                            lodGenerationScale = (imageData_1.length - 1) / Math.log2(light.specularImageSize);
                            return [4 /*yield*/, babylonTexture.updateRGBDAsync(imageData_1, sphericalPolynomial, lodGenerationScale)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            }); });
        }
        // eslint-disable-next-line github/no-then
        return light._loaded.then(function () {
            return light._babylonTexture;
        });
    };
    return EXT_lights_image_based;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_lights_image_based(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_materials_diffuse_roughness.ts":
/*!***************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_materials_diffuse_roughness.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_materials_diffuse_roughness: () => (/* binding */ EXT_materials_diffuse_roughness)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Engines/constants */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "EXT_materials_diffuse_roughness";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/fdee35425ae560ea378092e38977216d63a094ec/extensions/2.0/Khronos/EXT_materials_diffuse_roughness/README.md)
 * @experimental
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_materials_diffuse_roughness = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_materials_diffuse_roughness(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 190;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    EXT_materials_diffuse_roughness.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    EXT_materials_diffuse_roughness.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadDiffuseRoughnessPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    EXT_materials_diffuse_roughness.prototype._loadDiffuseRoughnessPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.brdf.baseDiffuseModel = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;
        if (properties.diffuseRoughnessFactor != undefined) {
            babylonMaterial.baseDiffuseRoughness = properties.diffuseRoughnessFactor;
        }
        else {
            babylonMaterial.baseDiffuseRoughness = 0;
        }
        if (properties.diffuseRoughnessTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseRoughnessTexture"), properties.diffuseRoughnessTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Diffuse Roughness)");
                babylonMaterial.baseDiffuseRoughnessTexture = texture;
            }));
        }
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return EXT_materials_diffuse_roughness;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_materials_diffuse_roughness(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts":
/*!*******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_mesh_gpu_instancing: () => (/* binding */ EXT_mesh_gpu_instancing)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Meshes/thinInstanceMesh */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "EXT_mesh_gpu_instancing";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)
 * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_mesh_gpu_instancing = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_mesh_gpu_instancing(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    EXT_mesh_gpu_instancing.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    EXT_mesh_gpu_instancing.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promise, promises, instanceCount, loadAttribute;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._loader._disableInstancedMesh++;
                        promise = this._loader.loadNodeAsync("/nodes/".concat(node.index), node, assign);
                        this._loader._disableInstancedMesh--;
                        if (!!node._primitiveBabylonMeshes) return [3 /*break*/, 2];
                        return [4 /*yield*/, promise];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        promises = new Array();
                        instanceCount = 0;
                        loadAttribute = function (attribute) {
                            if (extension.attributes[attribute] == undefined) {
                                promises.push(Promise.resolve(null));
                                return;
                            }
                            var accessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/attributes/").concat(attribute), _this._loader.gltf.accessors, extension.attributes[attribute]);
                            promises.push(_this._loader._loadFloatAccessorAsync("/accessors/".concat(accessor.bufferView), accessor));
                            if (instanceCount === 0) {
                                instanceCount = accessor.count;
                            }
                            else if (instanceCount !== accessor.count) {
                                throw new Error("".concat(extensionContext, "/attributes: Instance buffer accessors do not have the same count."));
                            }
                        };
                        loadAttribute("TRANSLATION");
                        loadAttribute("ROTATION");
                        loadAttribute("SCALE");
                        return [4 /*yield*/, promise.then(function (babylonTransformNode) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                                var _a, translationBuffer, rotationBuffer, scaleBuffer, matrices, i, _i, _b, babylonMesh;
                                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_c) {
                                    switch (_c.label) {
                                        case 0: return [4 /*yield*/, Promise.all(promises)];
                                        case 1:
                                            _a = _c.sent(), translationBuffer = _a[0], rotationBuffer = _a[1], scaleBuffer = _a[2];
                                            matrices = new Float32Array(instanceCount * 16);
                                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation
                                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation
                                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale
                                            for (i = 0; i < instanceCount; ++i) {
                                                translationBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(translationBuffer, i * 3, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0]);
                                                rotationBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArrayToRef(rotationBuffer, i * 4, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0]);
                                                scaleBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(scaleBuffer, i * 3, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1]);
                                                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.ComposeToRef(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]);
                                                babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0].copyToArray(matrices, i * 16);
                                            }
                                            for (_i = 0, _b = node._primitiveBabylonMeshes; _i < _b.length; _i++) {
                                                babylonMesh = _b[_i];
                                                babylonMesh.thinInstanceSetBuffer("matrix", matrices, 16, true);
                                            }
                                            return [2 /*return*/, babylonTransformNode];
                                    }
                                });
                            }); })];
                    case 3: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return EXT_mesh_gpu_instancing;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_mesh_gpu_instancing(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts":
/*!*******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_meshopt_compression: () => (/* binding */ EXT_meshopt_compression)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babylonjs/Meshes/Compression/meshoptCompression */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "EXT_meshopt_compression";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md)
 *
 * This extension uses a WebAssembly decoder module from https://github.com/zeux/meshoptimizer/tree/master/js
 * @since 5.0.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_meshopt_compression = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_meshopt_compression(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this.enabled = loader.isExtensionUsed(NAME);
        this._loader = loader;
    }
    /** @internal */
    EXT_meshopt_compression.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    EXT_meshopt_compression.prototype.loadBufferViewAsync = function (context, bufferView) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, bufferView, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var bufferViewMeshopt, buffer;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bufferViewMeshopt = bufferView;
                        if (!bufferViewMeshopt._meshOptData) return [3 /*break*/, 2];
                        return [4 /*yield*/, bufferViewMeshopt._meshOptData];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        buffer = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/buffer"), this._loader.gltf.buffers, extension.buffer);
                        bufferViewMeshopt._meshOptData = this._loader
                            .loadBufferAsync("/buffers/".concat(buffer.index), buffer, extension.byteOffset || 0, extension.byteLength)
                            // eslint-disable-next-line github/no-then
                            .then(function (buffer) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__.MeshoptCompression.Default.decodeGltfBufferAsync(buffer, extension.count, extension.byteStride, extension.mode, extension.filter)];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        }); });
                        return [4 /*yield*/, bufferViewMeshopt._meshOptData];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return EXT_meshopt_compression;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_meshopt_compression(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts":
/*!************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_texture_avif: () => (/* binding */ EXT_texture_avif)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");



var NAME = "EXT_texture_avif";
/**
 * [glTF PR](https://github.com/KhronosGroup/glTF/pull/2235)
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_avif/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_texture_avif = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_texture_avif(loader) {
        /** The name of this extension. */
        this.name = NAME;
        this._loader = loader;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    /** @internal */
    EXT_texture_avif.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    EXT_texture_avif.prototype._loadTextureAsync = function (context, texture, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {
            var sampler, image;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sampler = texture.sampler == undefined ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), this._loader.gltf.samplers, texture.sampler);
                        image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), this._loader.gltf.images, extension.source);
                        return [4 /*yield*/, this._loader._createTextureAsync(context, sampler, image, function (babylonTexture) {
                                assign(babylonTexture);
                            }, undefined, !texture._textureInfo.nonColorData)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return EXT_texture_avif;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_texture_avif(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts":
/*!************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXT_texture_webp: () => (/* binding */ EXT_texture_webp)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");



var NAME = "EXT_texture_webp";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var EXT_texture_webp = /** @class */ (function () {
    /**
     * @internal
     */
    function EXT_texture_webp(loader) {
        /** The name of this extension. */
        this.name = NAME;
        this._loader = loader;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    /** @internal */
    EXT_texture_webp.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    EXT_texture_webp.prototype._loadTextureAsync = function (context, texture, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {
            var sampler, image;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sampler = texture.sampler == undefined ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), this._loader.gltf.samplers, texture.sampler);
                        image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), this._loader.gltf.images, extension.source);
                        return [4 /*yield*/, this._loader._createTextureAsync(context, sampler, image, function (babylonTexture) {
                                assign(babylonTexture);
                            }, undefined, !texture._textureInfo.nonColorData)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return EXT_texture_webp;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function (loader) { return new EXT_texture_webp(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts":
/*!************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtrasAsMetadata: () => (/* binding */ ExtrasAsMetadata)
/* harmony export */ });
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");

var NAME = "ExtrasAsMetadata";
/**
 * Store glTF extras (if present) in BJS objects' metadata
 */
var ExtrasAsMetadata = /** @class */ (function () {
    /**
     * @internal
     */
    function ExtrasAsMetadata(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines whether this extension is enabled.
         */
        this.enabled = true;
        this._loader = loader;
    }
    ExtrasAsMetadata.prototype._assignExtras = function (babylonObject, gltfProp) {
        if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {
            var metadata = (babylonObject.metadata = babylonObject.metadata || {});
            var gltf = (metadata.gltf = metadata.gltf || {});
            gltf.extras = gltfProp.extras;
        }
    };
    /** @internal */
    ExtrasAsMetadata.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    ExtrasAsMetadata.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        return this._loader.loadNodeAsync(context, node, function (babylonTransformNode) {
            _this._assignExtras(babylonTransformNode, node);
            assign(babylonTransformNode);
        });
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    ExtrasAsMetadata.prototype.loadCameraAsync = function (context, camera, assign) {
        var _this = this;
        return this._loader.loadCameraAsync(context, camera, function (babylonCamera) {
            _this._assignExtras(babylonCamera, camera);
            assign(babylonCamera);
        });
    };
    /**
     * @internal
     */
    ExtrasAsMetadata.prototype.createMaterial = function (context, material, babylonDrawMode) {
        var babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);
        this._assignExtras(babylonMaterial, material);
        return babylonMaterial;
    };
    return ExtrasAsMetadata;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, false, function (loader) { return new ExtrasAsMetadata(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts":
/*!**********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Maths/math.color */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoaderAnimation */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts");
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");
/* eslint-disable @typescript-eslint/naming-convention */





function getColor3(_target, source, offset, scale) {
    return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(source, offset).scale(scale);
}
function getAlpha(_target, source, offset, scale) {
    return source[offset + 3] * scale;
}
function getFloat(_target, source, offset, scale) {
    return source[offset] * scale;
}
function getMinusFloat(_target, source, offset, scale) {
    return -source[offset] * scale;
}
function getNextFloat(_target, source, offset, scale) {
    return source[offset + 1] * scale;
}
function getFloatBy2(_target, source, offset, scale) {
    return source[offset] * scale * 2;
}
function getTextureTransformTree(textureName) {
    return {
        scale: [
            new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".uScale"), getFloat, function () { return 2; }),
            new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".vScale"), getNextFloat, function () { return 2; }),
        ],
        offset: [
            new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".uOffset"), getFloat, function () { return 2; }),
            new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".vOffset"), getNextFloat, function () { return 2; }),
        ],
        rotation: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".wAng"), getMinusFloat, function () { return 1; })],
    };
}
var CameraAnimationPropertyInfo = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(CameraAnimationPropertyInfo, _super);
    function CameraAnimationPropertyInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @internal */
    CameraAnimationPropertyInfo.prototype.buildAnimations = function (target, name, fps, keys) {
        return [{ babylonAnimatable: target._babylonCamera, babylonAnimation: this._buildAnimation(name, fps, keys) }];
    };
    return CameraAnimationPropertyInfo;
}(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo));
var MaterialAnimationPropertyInfo = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(MaterialAnimationPropertyInfo, _super);
    function MaterialAnimationPropertyInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @internal */
    MaterialAnimationPropertyInfo.prototype.buildAnimations = function (target, name, fps, keys) {
        var babylonAnimations = [];
        for (var fillMode in target._data) {
            babylonAnimations.push({
                babylonAnimatable: target._data[fillMode].babylonMaterial,
                babylonAnimation: this._buildAnimation(name, fps, keys),
            });
        }
        return babylonAnimations;
    };
    return MaterialAnimationPropertyInfo;
}(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo));
var LightAnimationPropertyInfo = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(LightAnimationPropertyInfo, _super);
    function LightAnimationPropertyInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @internal */
    LightAnimationPropertyInfo.prototype.buildAnimations = function (target, name, fps, keys) {
        return [{ babylonAnimatable: target._babylonLight, babylonAnimation: this._buildAnimation(name, fps, keys) }];
    };
    return LightAnimationPropertyInfo;
}(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo));
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/xmag", [
    new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoLeft", getMinusFloat, function () { return 1; }),
    new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoRight", getNextFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/ymag", [
    new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoBottom", getMinusFloat, function () { return 1; }),
    new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoTop", getNextFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/zfar", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/orthographic/znear", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/perspective/yfov", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "fov", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/perspective/zfar", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/cameras/{}/perspective/znear", [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, function () { return 1; })]);
// add interpolation to the materials mapping
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "albedoColor", getColor3, function () { return 4; }),
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "alpha", getAlpha, function () { return 4; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/metallicFactor", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "metallic", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/metallicFactor", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "roughness", getFloat, function () { return 1; })]);
var baseColorTextureInterpolation = getTextureTransformTree("albedoTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale", baseColorTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset", baseColorTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/rotation", baseColorTextureInterpolation.rotation);
var metallicRoughnessTextureInterpolation = getTextureTransformTree("metallicTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/scale", metallicRoughnessTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/offset", metallicRoughnessTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/rotation", metallicRoughnessTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveFactor", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "emissiveColor", getColor3, function () { return 3; })]);
var normalTextureInterpolation = getTextureTransformTree("bumpTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/scale", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "bumpTexture.level", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/extensions/KHR_texture_transform/scale", normalTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/extensions/KHR_texture_transform/offset", normalTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/normalTexture/extensions/KHR_texture_transform/rotation", normalTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/strength", [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "ambientTextureStrength", getFloat, function () { return 1; })]);
var occlusionTextureInterpolation = getTextureTransformTree("ambientTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/scale", occlusionTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/offset", occlusionTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/rotation", occlusionTextureInterpolation.rotation);
var emissiveTextureInterpolation = getTextureTransformTree("emissiveTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/scale", emissiveTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/offset", emissiveTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/rotation", emissiveTextureInterpolation.rotation);
// materials extensions
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyStrength", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "anisotropy.intensity", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyRotation", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "anisotropy.angle", getFloat, function () { return 1; }),
]);
var anisotropyTextureInterpolation = getTextureTransformTree("anisotropy.texture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/scale", anisotropyTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/offset", anisotropyTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/rotation", anisotropyTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.intensity", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.roughness", getFloat, function () { return 1; }),
]);
var clearcoatTextureInterpolation = getTextureTransformTree("clearCoat.texture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/scale", clearcoatTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/offset", clearcoatTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/rotation", clearcoatTextureInterpolation.rotation);
var clearcoatNormalTextureInterpolation = getTextureTransformTree("clearCoat.bumpTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/scale", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.bumpTexture.level", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/scale", clearcoatNormalTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/offset", clearcoatNormalTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/rotation", clearcoatNormalTextureInterpolation.rotation);
var clearcoatRoughnessTextureInterpolation = getTextureTransformTree("clearCoat.textureRoughness");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/scale", clearcoatRoughnessTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/offset", clearcoatRoughnessTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/rotation", clearcoatRoughnessTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_dispersion/dispersionFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.dispersion", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_emissive_strength/emissiveStrength", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "emissiveIntensity", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_ior/ior", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "indexOfRefraction", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.intensity", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceIor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMinimum", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMaximum", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness", getFloat, function () { return 1; }),
]);
var iridescenceTextureInterpolation = getTextureTransformTree("iridescence.texture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/scale", iridescenceTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/offset", iridescenceTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/rotation", iridescenceTextureInterpolation.rotation);
var iridescenceThicknessTextureInterpolation = getTextureTransformTree("iridescence.thicknessTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/scale", iridescenceThicknessTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/offset", iridescenceThicknessTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/rotation", iridescenceThicknessTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "sheen.color", getColor3, function () { return 3; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "sheen.roughness", getFloat, function () { return 1; }),
]);
var sheenTextureInterpolation = getTextureTransformTree("sheen.texture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/scale", sheenTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/offset", sheenTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/rotation", sheenTextureInterpolation.rotation);
var sheenRoughnessTextureInterpolation = getTextureTransformTree("sheen.textureRoughness");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/scale", sheenRoughnessTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/offset", sheenRoughnessTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/rotation", sheenRoughnessTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "metallicF0Factor", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", getColor3, function () { return 3; }),
]);
var specularTextureInterpolation = getTextureTransformTree("metallicReflectanceTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/scale", specularTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/offset", specularTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/rotation", specularTextureInterpolation.rotation);
var specularColorTextureInterpolation = getTextureTransformTree("reflectanceTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/scale", specularColorTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/offset", specularColorTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/rotation", specularColorTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity", getFloat, function () { return 1; }),
]);
var transmissionTextureInterpolation = getTextureTransformTree("subSurface.refractionIntensityTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/scale", transmissionTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/offset", transmissionTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/rotation", transmissionTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/attenuationColor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", getColor3, function () { return 3; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/attenuationDistance", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance", getFloat, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness", getFloat, function () { return 1; }),
]);
var thicknessTextureInterpolation = getTextureTransformTree("subSurface.thicknessTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/scale", thicknessTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/offset", thicknessTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/rotation", thicknessTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.translucencyIntensity", getFloat, function () { return 1; }),
]);
var diffuseTransmissionTextureInterpolation = getTextureTransformTree("subSurface.translucencyIntensityTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/scale", diffuseTransmissionTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/offset", diffuseTransmissionTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/rotation", diffuseTransmissionTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorFactor", [
    new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "subSurface.translucencyColor", getColor3, function () { return 3; }),
]);
var diffuseTransmissionColorTextureInterpolation = getTextureTransformTree("subSurface.translucencyColorTexture");
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/scale", diffuseTransmissionColorTextureInterpolation.scale);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/offset", diffuseTransmissionColorTextureInterpolation.offset);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/rotation", diffuseTransmissionColorTextureInterpolation.rotation);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/color", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, function () { return 3; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/intensity", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/range", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "range", getFloat, function () { return 1; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/spot/innerConeAngle", [
    new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "innerAngle", getFloatBy2, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/extensions/KHR_lights_punctual/lights/{}/spot/outerConeAngle", [
    new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "angle", getFloatBy2, function () { return 1; }),
]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/nodes/{}/extensions/EXT_lights_ies/color", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, function () { return 3; })]);
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.SetInterpolationForKey)("/nodes/{}/extensions/EXT_lights_ies/multiplier", [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, function () { return 1; })]);


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts":
/*!*****************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_animation_pointer: () => (/* binding */ KHR_animation_pointer)
/* harmony export */ });
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/logger */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");
/* harmony import */ var _KHR_animation_pointer_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KHR_animation_pointer.data */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts");




var NAME = "KHR_animation_pointer";
/**
 * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)
 * !!! Experimental Extension Subject to Changes !!!
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_animation_pointer = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_animation_pointer(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this._pathToObjectConverter = (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.GetPathToObjectConverter)(this._loader.gltf);
    }
    Object.defineProperty(KHR_animation_pointer.prototype, "enabled", {
        /**
         * Defines whether this extension is enabled.
         */
        get: function () {
            return this._loader.isExtensionUsed(NAME);
        },
        enumerable: false,
        configurable: true
    });
    /** @internal */
    KHR_animation_pointer.prototype.dispose = function () {
        this._loader = null;
        delete this._pathToObjectConverter; // GC
    };
    /**
     * Loads a glTF animation channel.
     * @param context The context when loading the asset
     * @param animationContext The context of the animation when loading the asset
     * @param animation The glTF animation property
     * @param channel The glTF animation channel property
     * @param onLoad Called for each animation loaded
     * @returns A void promise that resolves when the load is complete or null if not handled
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_animation_pointer.prototype._loadAnimationChannelAsync = function (context, animationContext, animation, channel, onLoad) {
        var _a;
        var extension = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer;
        if (!extension || !this._pathToObjectConverter) {
            return null;
        }
        if (channel.target.path !== "pointer" /* AnimationChannelTargetPath.POINTER */) {
            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/target/path: Value (").concat(channel.target.path, ") must be (").concat("pointer" /* AnimationChannelTargetPath.POINTER */, ") when using the ").concat(this.name, " extension"));
        }
        if (channel.target.node != undefined) {
            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/target/node: Value (").concat(channel.target.node, ") must not be present when using the ").concat(this.name, " extension"));
        }
        var extensionContext = "".concat(context, "/extensions/").concat(this.name);
        var pointer = extension.pointer;
        if (!pointer) {
            throw new Error("".concat(extensionContext, ": Pointer is missing"));
        }
        try {
            var obj = this._pathToObjectConverter.convert(pointer);
            if (!obj.info.interpolation) {
                throw new Error("".concat(extensionContext, "/pointer: Interpolation is missing"));
            }
            return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, {
                object: obj.object,
                info: obj.info.interpolation,
            }, onLoad);
        }
        catch (e) {
            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(extensionContext, "/pointer: Invalid pointer (").concat(pointer, ") skipped"));
            return null;
        }
    };
    return KHR_animation_pointer;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_animation_pointer(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts":
/*!**********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_draco_mesh_compression: () => (/* binding */ KHR_draco_mesh_compression)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Buffers/buffer */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");

/* eslint-disable github/no-then */




var NAME = "KHR_draco_mesh_compression";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_draco_mesh_compression = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_draco_mesh_compression(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines whether to use the normalized flag from the glTF accessor instead of the Draco data. Defaults to true.
         */
        this.useNormalizedFlagFromAccessor = true;
        this._loader = loader;
        this.enabled = babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_draco_mesh_compression.prototype.dispose = function () {
        delete this.dracoDecoder;
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_draco_mesh_compression.prototype._loadVertexDataAsync = function (context, primitive, babylonMesh) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var attributes, normalized, loadAttribute, bufferView;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (primitive.mode != undefined) {
                            if (primitive.mode !== 4 /* MeshPrimitiveMode.TRIANGLES */ && primitive.mode !== 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */) {
                                throw new Error("".concat(context, ": Unsupported mode ").concat(primitive.mode));
                            }
                        }
                        attributes = {};
                        normalized = {};
                        loadAttribute = function (name, kind) {
                            var uniqueId = extension.attributes[name];
                            if (uniqueId == undefined) {
                                return;
                            }
                            babylonMesh._delayInfo = babylonMesh._delayInfo || [];
                            if (babylonMesh._delayInfo.indexOf(kind) === -1) {
                                babylonMesh._delayInfo.push(kind);
                            }
                            attributes[kind] = uniqueId;
                            if (_this.useNormalizedFlagFromAccessor) {
                                var accessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.TryGet(_this._loader.gltf.accessors, primitive.attributes[name]);
                                if (accessor) {
                                    normalized[kind] = accessor.normalized || false;
                                }
                            }
                        };
                        loadAttribute("POSITION", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                        loadAttribute("NORMAL", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                        loadAttribute("TANGENT", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind);
                        loadAttribute("TEXCOORD_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind);
                        loadAttribute("TEXCOORD_1", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind);
                        loadAttribute("TEXCOORD_2", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV3Kind);
                        loadAttribute("TEXCOORD_3", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV4Kind);
                        loadAttribute("TEXCOORD_4", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV5Kind);
                        loadAttribute("TEXCOORD_5", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV6Kind);
                        loadAttribute("JOINTS_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesKind);
                        loadAttribute("WEIGHTS_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsKind);
                        loadAttribute("COLOR_0", babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind);
                        bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);
                        if (!bufferView._dracoBabylonGeometry) {
                            bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function (data) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                                var dracoDecoder, positionAccessor, babylonBoundingInfo;
                                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            dracoDecoder = this.dracoDecoder || babylonjs_Meshes_Compression_dracoDecoder__WEBPACK_IMPORTED_MODULE_0__.DracoDecoder.Default;
                                            positionAccessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes["POSITION"]);
                                            babylonBoundingInfo = !this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? (0,_glTFLoader__WEBPACK_IMPORTED_MODULE_1__.LoadBoundingInfoFromPositionAccessor)(positionAccessor) : null;
                                            return [4 /*yield*/, dracoDecoder
                                                    ._decodeMeshToGeometryForGltfAsync(babylonMesh.name, this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo)
                                                    .catch(function (error) {
                                                    throw new Error("".concat(context, ": ").concat(error.message));
                                                })];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); });
                        }
                        return [4 /*yield*/, bufferView._dracoBabylonGeometry];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return KHR_draco_mesh_compression;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_draco_mesh_compression(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts":
/*!*************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_interactivity: () => (/* binding */ KHR_interactivity),
/* harmony export */   _AddInteractivityObjectModel: () => (/* binding */ _AddInteractivityObjectModel)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Maths/math.vector */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");
/* harmony import */ var _KHR_interactivity_interactivityGraphParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KHR_interactivity/interactivityGraphParser */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts");








var NAME = "KHR_interactivity";
/**
 * Loader extension for KHR_interactivity
 */
var KHR_interactivity = /** @class */ (function () {
    /**
     * @internal
     * @param _loader
     */
    function KHR_interactivity(_loader) {
        this._loader = _loader;
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this.enabled = this._loader.isExtensionUsed(NAME);
        this._pathConverter = (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.GetPathToObjectConverter)(this._loader.gltf);
        // avoid starting animations automatically.
        _loader._skipStartAnimationStep = true;
        // Update object model with new pointers
        var scene = _loader.babylonScene;
        if (scene) {
            _AddInteractivityObjectModel(scene);
        }
    }
    KHR_interactivity.prototype.dispose = function () {
        this._loader = null;
        delete this._pathConverter;
    };
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises
    KHR_interactivity.prototype.onReady = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function () {
            var scene, interactivityDefinition, coordinator, graphs;
            var _this = this;
            var _a;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this._loader.babylonScene || !this._pathConverter) {
                            return [2 /*return*/];
                        }
                        scene = this._loader.babylonScene;
                        interactivityDefinition = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_interactivity;
                        if (!interactivityDefinition) {
                            // This can technically throw, but it's not a critical error
                            return [2 /*return*/];
                        }
                        coordinator = new babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.FlowGraphCoordinator({ scene: scene });
                        coordinator.dispatchEventsSynchronously = false; // glTF interactivity dispatches events asynchronously
                        graphs = interactivityDefinition.graphs.map(function (graph) {
                            var parser = new _KHR_interactivity_interactivityGraphParser__WEBPACK_IMPORTED_MODULE_3__.InteractivityGraphToFlowGraphParser(graph, _this._loader.gltf, _this._loader.parent.targetFps);
                            return parser.serializeToFlowGraph();
                        });
                        // parse each graph async
                        return [4 /*yield*/, Promise.all(graphs.map(function (graph) { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, (0,babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.ParseFlowGraphAsync)(graph, { coordinator: coordinator, pathConverter: this._pathConverter })];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); }))];
                    case 1:
                        // parse each graph async
                        _b.sent();
                        coordinator.start();
                        return [2 /*return*/];
                }
            });
        });
    };
    return KHR_interactivity;
}());

/**
 * @internal
 * populates the object model with the interactivity extension
 */
function _AddInteractivityObjectModel(scene) {
    // Note - all of those are read-only, as per the specs!
    // active camera rotation
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/extensions/KHR_interactivity/?/activeCamera/rotation", {
        get: function () {
            if (!scene.activeCamera) {
                return new babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.Quaternion(NaN, NaN, NaN, NaN);
            }
            var quat = babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();
            if (!scene.useRightHandedSystem) {
                quat.w *= -1; // glTF uses right-handed system, while babylon uses left-handed
                quat.x *= -1; // glTF uses right-handed system, while babylon uses left-handed
            }
            return quat;
        },
        type: "Quaternion",
        getTarget: function () { return scene.activeCamera; },
    });
    // activeCamera position
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/extensions/KHR_interactivity/?/activeCamera/position", {
        get: function () {
            if (!scene.activeCamera) {
                return new babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.Vector3(NaN, NaN, NaN);
            }
            var pos = scene.activeCamera.getWorldMatrix().getTranslation(); // not global position
            if (!scene.useRightHandedSystem) {
                pos.x *= -1; // glTF uses right-handed system, while babylon uses left-handed
            }
            return pos;
        },
        type: "Vector3",
        getTarget: function () { return scene.activeCamera; },
    });
    // /animations/{} pointers:
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/isPlaying", {
        get: function (animation) {
            var _a, _b;
            return (_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.isPlaying) !== null && _b !== void 0 ? _b : false;
        },
        type: "boolean",
        getTarget: function (animation) {
            return animation._babylonAnimationGroup;
        },
    });
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/minTime", {
        get: function (animation) {
            var _a, _b;
            return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.from) !== null && _b !== void 0 ? _b : 0) / 60; // fixed factor for duration-to-frames conversion
        },
        type: "number",
        getTarget: function (animation) {
            return animation._babylonAnimationGroup;
        },
    });
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/maxTime", {
        get: function (animation) {
            var _a, _b;
            return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.to) !== null && _b !== void 0 ? _b : 0) / 60; // fixed factor for duration-to-frames conversion
        },
        type: "number",
        getTarget: function (animation) {
            return animation._babylonAnimationGroup;
        },
    });
    // playhead
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/playhead", {
        get: function (animation) {
            var _a, _b;
            return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.getCurrentFrame()) !== null && _b !== void 0 ? _b : 0) / 60; // fixed factor for duration-to-frames conversion
        },
        type: "number",
        getTarget: function (animation) {
            return animation._babylonAnimationGroup;
        },
    });
    //virtualPlayhead - TODO, do we support this property in our animations? getCurrentFrame  is the only method we have for this.
    (0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/animations/{}/extensions/KHR_interactivity/virtualPlayhead", {
        get: function (animation) {
            var _a, _b;
            return ((_b = (_a = animation._babylonAnimationGroup) === null || _a === void 0 ? void 0 : _a.getCurrentFrame()) !== null && _b !== void 0 ? _b : 0) / 60; // fixed factor for duration-to-frames conversion
        },
        type: "number",
        getTarget: function (animation) {
            return animation._babylonAnimationGroup;
        },
    });
}
// Register flow graph blocks. Do it here so they are available when the extension is enabled.
(0,babylonjs_FlowGraph_flowGraphCoordinator__WEBPACK_IMPORTED_MODULE_0__.addToBlockFactory)(NAME, "FlowGraphGLTFDataProvider", function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(void 0, void 0, void 0, function () {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./KHR_interactivity/flowGraphGLTFDataProvider */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts"))];
            case 1: return [2 /*return*/, (_a.sent()).FlowGraphGLTFDataProvider];
        }
    });
}); });
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_interactivity(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts":
/*!*******************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addNewInteractivityFlowGraphMapping: () => (/* binding */ addNewInteractivityFlowGraphMapping),
/* harmony export */   getAllSupportedNativeNodeTypes: () => (/* binding */ getAllSupportedNativeNodeTypes),
/* harmony export */   getMappingForDeclaration: () => (/* binding */ getMappingForDeclaration),
/* harmony export */   getMappingForFullOperationName: () => (/* binding */ getMappingForFullOperationName)
/* harmony export */ });
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/FlowGraph/flowGraphRichTypes */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__);


function getMappingForFullOperationName(fullOperationName) {
    var _a = fullOperationName.split(":"), op = _a[0], extension = _a[1];
    return getMappingForDeclaration({ op: op, extension: extension });
}
function getMappingForDeclaration(declaration, returnNoOpIfNotAvailable) {
    var _a;
    if (returnNoOpIfNotAvailable === void 0) { returnNoOpIfNotAvailable = true; }
    var mapping = declaration.extension ? (_a = gltfExtensionsToFlowGraphMapping[declaration.extension]) === null || _a === void 0 ? void 0 : _a[declaration.op] : gltfToFlowGraphMapping[declaration.op];
    if (!mapping) {
        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("No mapping found for operation ".concat(declaration.op, " and extension ").concat(declaration.extension || "KHR_interactivity"));
        if (returnNoOpIfNotAvailable) {
            var inputs = {};
            var outputs_1 = {
                flows: {},
            };
            if (declaration.inputValueSockets) {
                inputs.values = {};
                for (var key in declaration.inputValueSockets) {
                    inputs.values[key] = {
                        name: key,
                    };
                }
            }
            if (declaration.outputValueSockets) {
                outputs_1.values = {};
                Object.keys(declaration.outputValueSockets).forEach(function (key) {
                    outputs_1.values[key] = {
                        name: key,
                    };
                });
            }
            return {
                blocks: [], // no blocks, just mapping
                inputs: inputs,
                outputs: outputs_1,
            };
        }
    }
    return mapping;
}
/**
 * This function will add new mapping to glTF interactivity.
 * Other extensions can define new types of blocks, this is the way to let interactivity know how to parse them.
 * @param key the type of node, i.e. "variable/get"
 * @param extension the extension of the interactivity operation, i.e. "KHR_selectability"
 * @param mapping The mapping object. See documentation or examples below.
 */
function addNewInteractivityFlowGraphMapping(key, extension, mapping) {
    gltfExtensionsToFlowGraphMapping[extension] || (gltfExtensionsToFlowGraphMapping[extension] = {});
    gltfExtensionsToFlowGraphMapping[extension][key] = mapping;
}
var gltfExtensionsToFlowGraphMapping = {
    /**
     * This is the BABYLON extension for glTF interactivity.
     * It defines babylon-specific blocks and operations.
     */
    BABYLON: {
        /**
         * flow/log is a flow node that logs input to the console.
         * It has "in" and "out" flows, and takes a message as input.
         * The message can be any type of value.
         * The message is logged to the console when the "in" flow is triggered.
         * The "out" flow is triggered when the message is logged.
         */
        "flow/log": {
            blocks: ["FlowGraphConsoleLogBlock" /* FlowGraphBlockNames.ConsoleLog */],
            inputs: {
                values: {
                    message: { name: "message" },
                },
            },
        },
    },
};
// this mapper is just a way to convert the glTF nodes to FlowGraph nodes in terms of input/output connection names and values.
var gltfToFlowGraphMapping = {
    "event/onStart": {
        blocks: ["FlowGraphSceneReadyEventBlock" /* FlowGraphBlockNames.SceneReadyEvent */],
        outputs: {
            flows: {
                out: { name: "done" },
            },
        },
    },
    "event/onTick": {
        blocks: ["FlowGraphSceneTickEventBlock" /* FlowGraphBlockNames.SceneTickEvent */],
        inputs: {},
        outputs: {
            values: {
                timeSinceLastTick: { name: "deltaTime", gltfType: "number" /*, dataTransformer: (time: number) => time / 1000*/ },
            },
            flows: {
                out: { name: "done" },
            },
        },
    },
    "event/send": {
        blocks: ["FlowGraphSendCustomEventBlock" /* FlowGraphBlockNames.SendCustomEvent */],
        extraProcessor: function (gltfBlock, declaration, _mapping, parser, serializedObjects) {
            // set eventId and eventData. The configuration object of the glTF should have a single object.
            // validate that we are running it on the right block.
            if (declaration.op !== "event/send" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
                throw new Error("Receive event should have a single configuration object, the event itself");
            }
            var eventConfiguration = gltfBlock.configuration["event"];
            var eventId = eventConfiguration.value[0];
            if (typeof eventId !== "number") {
                throw new Error("Event id should be a number");
            }
            var event = parser.arrays.events[eventId];
            var serializedObject = serializedObjects[0];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.eventId = event.eventId;
            serializedObject.config.eventData = event.eventData;
            return serializedObjects;
        },
    },
    "event/receive": {
        blocks: ["FlowGraphReceiveCustomEventBlock" /* FlowGraphBlockNames.ReceiveCustomEvent */],
        outputs: {
            flows: {
                out: { name: "done" },
            },
        },
        validation: function (gltfBlock, interactivityGraph) {
            var _a;
            if (!gltfBlock.configuration) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Receive event should have a configuration object");
                return { valid: false, error: "Receive event should have a configuration object" };
            }
            var eventConfiguration = gltfBlock.configuration["event"];
            if (!eventConfiguration) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Receive event should have a single configuration object, the event itself");
                return { valid: false, error: "Receive event should have a single configuration object, the event itself" };
            }
            var eventId = eventConfiguration.value[0];
            if (typeof eventId !== "number") {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Event id should be a number");
                return { valid: false, error: "Event id should be a number" };
            }
            var event = (_a = interactivityGraph.events) === null || _a === void 0 ? void 0 : _a[eventId];
            if (!event) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Event with id ".concat(eventId, " not found"));
                return { valid: false, error: "Event with id ".concat(eventId, " not found") };
            }
            return { valid: true };
        },
        extraProcessor: function (gltfBlock, declaration, _mapping, parser, serializedObjects) {
            // set eventId and eventData. The configuration object of the glTF should have a single object.
            // validate that we are running it on the right block.
            if (declaration.op !== "event/receive" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
                throw new Error("Receive event should have a single configuration object, the event itself");
            }
            var eventConfiguration = gltfBlock.configuration["event"];
            var eventId = eventConfiguration.value[0];
            if (typeof eventId !== "number") {
                throw new Error("Event id should be a number");
            }
            var event = parser.arrays.events[eventId];
            var serializedObject = serializedObjects[0];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.eventId = event.eventId;
            serializedObject.config.eventData = event.eventData;
            return serializedObjects;
        },
    },
    "math/e": getSimpleInputMapping("FlowGraphEBlock" /* FlowGraphBlockNames.E */),
    "math/pi": getSimpleInputMapping("FlowGraphPIBlock" /* FlowGraphBlockNames.PI */),
    "math/inf": getSimpleInputMapping("FlowGraphInfBlock" /* FlowGraphBlockNames.Inf */),
    "math/nan": getSimpleInputMapping("FlowGraphNaNBlock" /* FlowGraphBlockNames.NaN */),
    "math/abs": getSimpleInputMapping("FlowGraphAbsBlock" /* FlowGraphBlockNames.Abs */),
    "math/sign": getSimpleInputMapping("FlowGraphSignBlock" /* FlowGraphBlockNames.Sign */),
    "math/trunc": getSimpleInputMapping("FlowGraphTruncBlock" /* FlowGraphBlockNames.Trunc */),
    "math/floor": getSimpleInputMapping("FlowGraphFloorBlock" /* FlowGraphBlockNames.Floor */),
    "math/ceil": getSimpleInputMapping("FlowGraphCeilBlock" /* FlowGraphBlockNames.Ceil */),
    "math/round": {
        blocks: ["FlowGraphRoundBlock" /* FlowGraphBlockNames.Round */],
        configuration: {},
        inputs: {
            values: {
                a: { name: "a" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (gltfBlock, declaration, _mapping, parser, serializedObjects) {
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            serializedObjects[0].config.roundHalfAwayFromZero = true;
            return serializedObjects;
        },
    },
    "math/fract": getSimpleInputMapping("FlowGraphFractBlock" /* FlowGraphBlockNames.Fraction */),
    "math/neg": getSimpleInputMapping("FlowGraphNegationBlock" /* FlowGraphBlockNames.Negation */),
    "math/add": getSimpleInputMapping("FlowGraphAddBlock" /* FlowGraphBlockNames.Add */, ["a", "b"], true),
    "math/sub": getSimpleInputMapping("FlowGraphSubtractBlock" /* FlowGraphBlockNames.Subtract */, ["a", "b"], true),
    "math/mul": {
        blocks: ["FlowGraphMultiplyBlock" /* FlowGraphBlockNames.Multiply */],
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            serializedObjects[0].config.useMatrixPerComponent = true;
            serializedObjects[0].config.preventIntegerFloatArithmetic = true;
            // try to infer the type or fallback to Integer
            // check the gltf block for the inputs, see if they have a type
            var type = -1;
            Object.keys(_gltfBlock.values || {}).find(function (value) {
                var _a;
                if (((_a = _gltfBlock.values) === null || _a === void 0 ? void 0 : _a[value].type) !== undefined) {
                    type = _gltfBlock.values[value].type;
                    return true;
                }
                return false;
            });
            if (type !== -1) {
                serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;
            }
            return serializedObjects;
        },
        validation: function (gltfBlock) {
            // make sure types are the same
            if (gltfBlock.values) {
                // make sure types are the same
                return ValidateTypes(gltfBlock);
            }
            return { valid: true };
        },
    },
    "math/div": getSimpleInputMapping("FlowGraphDivideBlock" /* FlowGraphBlockNames.Divide */, ["a", "b"], true),
    "math/rem": getSimpleInputMapping("FlowGraphModuloBlock" /* FlowGraphBlockNames.Modulo */, ["a", "b"]),
    "math/min": getSimpleInputMapping("FlowGraphMinBlock" /* FlowGraphBlockNames.Min */, ["a", "b"]),
    "math/max": getSimpleInputMapping("FlowGraphMaxBlock" /* FlowGraphBlockNames.Max */, ["a", "b"]),
    "math/clamp": getSimpleInputMapping("FlowGraphClampBlock" /* FlowGraphBlockNames.Clamp */, ["a", "b", "c"]),
    "math/saturate": getSimpleInputMapping("FlowGraphSaturateBlock" /* FlowGraphBlockNames.Saturate */),
    "math/mix": getSimpleInputMapping("FlowGraphMathInterpolationBlock" /* FlowGraphBlockNames.MathInterpolation */, ["a", "b", "c"]),
    "math/eq": getSimpleInputMapping("FlowGraphEqualityBlock" /* FlowGraphBlockNames.Equality */, ["a", "b"]),
    "math/lt": getSimpleInputMapping("FlowGraphLessThanBlock" /* FlowGraphBlockNames.LessThan */, ["a", "b"]),
    "math/le": getSimpleInputMapping("FlowGraphLessThanOrEqualBlock" /* FlowGraphBlockNames.LessThanOrEqual */, ["a", "b"]),
    "math/gt": getSimpleInputMapping("FlowGraphGreaterThanBlock" /* FlowGraphBlockNames.GreaterThan */, ["a", "b"]),
    "math/ge": getSimpleInputMapping("FlowGraphGreaterThanOrEqualBlock" /* FlowGraphBlockNames.GreaterThanOrEqual */, ["a", "b"]),
    "math/isnan": getSimpleInputMapping("FlowGraphIsNaNBlock" /* FlowGraphBlockNames.IsNaN */),
    "math/isinf": getSimpleInputMapping("FlowGraphIsInfBlock" /* FlowGraphBlockNames.IsInfinity */),
    "math/select": {
        blocks: ["FlowGraphConditionalBlock" /* FlowGraphBlockNames.Conditional */],
        inputs: {
            values: {
                condition: { name: "condition" },
                // Should we validate those have the same type here, or assume it is already validated?
                a: { name: "onTrue" },
                b: { name: "onFalse" },
            },
        },
        outputs: {
            values: {
                value: { name: "output" },
            },
        },
    },
    "math/random": {
        blocks: ["FlowGraphRandomBlock" /* FlowGraphBlockNames.Random */],
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
    },
    "math/sin": getSimpleInputMapping("FlowGraphSinBlock" /* FlowGraphBlockNames.Sin */),
    "math/cos": getSimpleInputMapping("FlowGraphCosBlock" /* FlowGraphBlockNames.Cos */),
    "math/tan": getSimpleInputMapping("FlowGraphTanBlock" /* FlowGraphBlockNames.Tan */),
    "math/asin": getSimpleInputMapping("FlowGraphASinBlock" /* FlowGraphBlockNames.Asin */),
    "math/acos": getSimpleInputMapping("FlowGraphACosBlock" /* FlowGraphBlockNames.Acos */),
    "math/atan": getSimpleInputMapping("FlowGraphATanBlock" /* FlowGraphBlockNames.Atan */),
    "math/atan2": getSimpleInputMapping("FlowGraphATan2Block" /* FlowGraphBlockNames.Atan2 */, ["a", "b"]),
    "math/sinh": getSimpleInputMapping("FlowGraphSinhBlock" /* FlowGraphBlockNames.Sinh */),
    "math/cosh": getSimpleInputMapping("FlowGraphCoshBlock" /* FlowGraphBlockNames.Cosh */),
    "math/tanh": getSimpleInputMapping("FlowGraphTanhBlock" /* FlowGraphBlockNames.Tanh */),
    "math/asinh": getSimpleInputMapping("FlowGraphASinhBlock" /* FlowGraphBlockNames.Asinh */),
    "math/acosh": getSimpleInputMapping("FlowGraphACoshBlock" /* FlowGraphBlockNames.Acosh */),
    "math/atanh": getSimpleInputMapping("FlowGraphATanhBlock" /* FlowGraphBlockNames.Atanh */),
    "math/exp": getSimpleInputMapping("FlowGraphExponentialBlock" /* FlowGraphBlockNames.Exponential */),
    "math/log": getSimpleInputMapping("FlowGraphLogBlock" /* FlowGraphBlockNames.Log */),
    "math/log2": getSimpleInputMapping("FlowGraphLog2Block" /* FlowGraphBlockNames.Log2 */),
    "math/log10": getSimpleInputMapping("FlowGraphLog10Block" /* FlowGraphBlockNames.Log10 */),
    "math/sqrt": getSimpleInputMapping("FlowGraphSquareRootBlock" /* FlowGraphBlockNames.SquareRoot */),
    "math/cbrt": getSimpleInputMapping("FlowGraphCubeRootBlock" /* FlowGraphBlockNames.CubeRoot */),
    "math/pow": getSimpleInputMapping("FlowGraphPowerBlock" /* FlowGraphBlockNames.Power */, ["a", "b"]),
    "math/length": getSimpleInputMapping("FlowGraphLengthBlock" /* FlowGraphBlockNames.Length */),
    "math/normalize": getSimpleInputMapping("FlowGraphNormalizeBlock" /* FlowGraphBlockNames.Normalize */),
    "math/dot": getSimpleInputMapping("FlowGraphDotBlock" /* FlowGraphBlockNames.Dot */, ["a", "b"]),
    "math/cross": getSimpleInputMapping("FlowGraphCrossBlock" /* FlowGraphBlockNames.Cross */, ["a", "b"]),
    "math/rotate2D": getSimpleInputMapping("FlowGraphRotate2DBlock" /* FlowGraphBlockNames.Rotate2D */, ["a", "b"]),
    "math/rotate3D": getSimpleInputMapping("FlowGraphRotate3DBlock" /* FlowGraphBlockNames.Rotate3D */, ["a", "b"]),
    "math/transform": {
        // glTF transform is vectorN with matrixN
        blocks: ["FlowGraphTransformVectorBlock" /* FlowGraphBlockNames.TransformVector */],
        inputs: {
            values: {
                a: { name: "a" },
                b: { name: "b" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
    },
    "math/combine2": {
        blocks: ["FlowGraphCombineVector2Block" /* FlowGraphBlockNames.CombineVector2 */],
        inputs: {
            values: {
                a: { name: "input_0", gltfType: "number" },
                b: { name: "input_1", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
    },
    "math/combine3": {
        blocks: ["FlowGraphCombineVector3Block" /* FlowGraphBlockNames.CombineVector3 */],
        inputs: {
            values: {
                a: { name: "input_0", gltfType: "number" },
                b: { name: "input_1", gltfType: "number" },
                c: { name: "input_2", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
    },
    "math/combine4": {
        blocks: ["FlowGraphCombineVector4Block" /* FlowGraphBlockNames.CombineVector4 */],
        inputs: {
            values: {
                a: { name: "input_0", gltfType: "number" },
                b: { name: "input_1", gltfType: "number" },
                c: { name: "input_2", gltfType: "number" },
                d: { name: "input_3", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
    },
    // one input, N outputs! outputs named using numbers.
    "math/extract2": {
        blocks: ["FlowGraphExtractVector2Block" /* FlowGraphBlockNames.ExtractVector2 */],
        inputs: {
            values: {
                a: { name: "input", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                "0": { name: "output_0" },
                "1": { name: "output_1" },
            },
        },
    },
    "math/extract3": {
        blocks: ["FlowGraphExtractVector3Block" /* FlowGraphBlockNames.ExtractVector3 */],
        inputs: {
            values: {
                a: { name: "input", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                "0": { name: "output_0" },
                "1": { name: "output_1" },
                "2": { name: "output_2" },
            },
        },
    },
    "math/extract4": {
        blocks: ["FlowGraphExtractVector4Block" /* FlowGraphBlockNames.ExtractVector4 */],
        inputs: {
            values: {
                a: { name: "input", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                "0": { name: "output_0" },
                "1": { name: "output_1" },
                "2": { name: "output_2" },
                "3": { name: "output_3" },
            },
        },
    },
    "math/transpose": getSimpleInputMapping("FlowGraphTransposeBlock" /* FlowGraphBlockNames.Transpose */),
    "math/determinant": getSimpleInputMapping("FlowGraphDeterminantBlock" /* FlowGraphBlockNames.Determinant */),
    "math/inverse": getSimpleInputMapping("FlowGraphInvertMatrixBlock" /* FlowGraphBlockNames.InvertMatrix */),
    "math/matmul": getSimpleInputMapping("FlowGraphMatrixMultiplicationBlock" /* FlowGraphBlockNames.MatrixMultiplication */, ["a", "b"]),
    "math/matCompose": {
        blocks: ["FlowGraphMatrixCompose" /* FlowGraphBlockNames.MatrixCompose */],
        inputs: {
            values: {
                translation: { name: "position", gltfType: "float3" },
                rotation: { name: "rotationQuaternion", gltfType: "float4" },
                scale: { name: "scaling", gltfType: "float3" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
            // configure it to work the way glTF specifies
            var d = serializedObjects[0].dataInputs.find(function (input) { return input.name === "rotationQuaternion"; });
            if (!d) {
                throw new Error("Rotation quaternion input not found");
            }
            // if value is defined, set the type to quaternion
            if (context._connectionValues[d.uniqueId]) {
                context._connectionValues[d.uniqueId].type = "Quaternion" /* FlowGraphTypes.Quaternion */;
            }
            return serializedObjects;
        },
    },
    "math/matDecompose": {
        blocks: ["FlowGraphMatrixDecompose" /* FlowGraphBlockNames.MatrixDecompose */],
        inputs: {
            values: {
                a: { name: "input", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                translation: { name: "position" },
                rotation: { name: "rotationQuaternion" },
                scale: { name: "scaling" },
            },
        },
    },
    "math/combine2x2": {
        blocks: ["FlowGraphCombineMatrix2DBlock" /* FlowGraphBlockNames.CombineMatrix2D */],
        inputs: {
            values: {
                a: { name: "input_0", gltfType: "number" },
                b: { name: "input_1", gltfType: "number" },
                c: { name: "input_2", gltfType: "number" },
                d: { name: "input_3", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            serializedObjects[0].config.inputIsColumnMajor = true;
            return serializedObjects;
        },
    },
    "math/extract2x2": {
        blocks: ["FlowGraphExtractMatrix2DBlock" /* FlowGraphBlockNames.ExtractMatrix2D */],
        inputs: {
            values: {
                a: { name: "input", gltfType: "float2x2" },
            },
        },
        outputs: {
            values: {
                "0": { name: "output_0" },
                "1": { name: "output_1" },
                "2": { name: "output_2" },
                "3": { name: "output_3" },
            },
        },
    },
    "math/combine3x3": {
        blocks: ["FlowGraphCombineMatrix3DBlock" /* FlowGraphBlockNames.CombineMatrix3D */],
        inputs: {
            values: {
                a: { name: "input_0", gltfType: "number" },
                b: { name: "input_1", gltfType: "number" },
                c: { name: "input_2", gltfType: "number" },
                d: { name: "input_3", gltfType: "number" },
                e: { name: "input_4", gltfType: "number" },
                f: { name: "input_5", gltfType: "number" },
                g: { name: "input_6", gltfType: "number" },
                h: { name: "input_7", gltfType: "number" },
                i: { name: "input_8", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            serializedObjects[0].config.inputIsColumnMajor = true;
            return serializedObjects;
        },
    },
    "math/extract3x3": {
        blocks: ["FlowGraphExtractMatrix3DBlock" /* FlowGraphBlockNames.ExtractMatrix3D */],
        inputs: {
            values: {
                a: { name: "input", gltfType: "float3x3" },
            },
        },
        outputs: {
            values: {
                "0": { name: "output_0" },
                "1": { name: "output_1" },
                "2": { name: "output_2" },
                "3": { name: "output_3" },
                "4": { name: "output_4" },
                "5": { name: "output_5" },
                "6": { name: "output_6" },
                "7": { name: "output_7" },
                "8": { name: "output_8" },
            },
        },
    },
    "math/combine4x4": {
        blocks: ["FlowGraphCombineMatrixBlock" /* FlowGraphBlockNames.CombineMatrix */],
        inputs: {
            values: {
                a: { name: "input_0", gltfType: "number" },
                b: { name: "input_1", gltfType: "number" },
                c: { name: "input_2", gltfType: "number" },
                d: { name: "input_3", gltfType: "number" },
                e: { name: "input_4", gltfType: "number" },
                f: { name: "input_5", gltfType: "number" },
                g: { name: "input_6", gltfType: "number" },
                h: { name: "input_7", gltfType: "number" },
                i: { name: "input_8", gltfType: "number" },
                j: { name: "input_9", gltfType: "number" },
                k: { name: "input_10", gltfType: "number" },
                l: { name: "input_11", gltfType: "number" },
                m: { name: "input_12", gltfType: "number" },
                n: { name: "input_13", gltfType: "number" },
                o: { name: "input_14", gltfType: "number" },
                p: { name: "input_15", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            serializedObjects[0].config.inputIsColumnMajor = true;
            return serializedObjects;
        },
    },
    "math/extract4x4": {
        blocks: ["FlowGraphExtractMatrixBlock" /* FlowGraphBlockNames.ExtractMatrix */],
        configuration: {},
        inputs: {
            values: {
                a: { name: "input", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                "0": { name: "output_0" },
                "1": { name: "output_1" },
                "2": { name: "output_2" },
                "3": { name: "output_3" },
                "4": { name: "output_4" },
                "5": { name: "output_5" },
                "6": { name: "output_6" },
                "7": { name: "output_7" },
                "8": { name: "output_8" },
                "9": { name: "output_9" },
                "10": { name: "output_10" },
                "11": { name: "output_11" },
                "12": { name: "output_12" },
                "13": { name: "output_13" },
                "14": { name: "output_14" },
                "15": { name: "output_15" },
            },
        },
    },
    "math/compose": {
        blocks: ["FlowGraphMatrixCompose" /* FlowGraphBlockNames.MatrixCompose */],
        configuration: {},
        inputs: {
            values: {
                translation: { name: "position", gltfType: "float3" },
                rotation: { name: "rotationQuaternion", gltfType: "float4" },
                scale: { name: "scaling", gltfType: "float3" },
            },
        },
        outputs: {
            values: {
                value: { name: "output" },
            },
        },
    },
    "math/decompose": {
        blocks: ["FlowGraphMatrixDecompose" /* FlowGraphBlockNames.MatrixDecompose */],
        configuration: {},
        inputs: {
            values: {
                a: { name: "input" },
            },
        },
        outputs: {
            values: {
                translation: { name: "position" },
                rotation: { name: "rotationQuaternion" },
                scale: { name: "scaling" },
            },
        },
    },
    "math/not": {
        blocks: ["FlowGraphBitwiseNotBlock" /* FlowGraphBlockNames.BitwiseNot */],
        inputs: {
            values: {
                a: { name: "a" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
            var _a, _b;
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            // try to infer the type or fallback to Integer
            var socketIn = serializedObjects[0].dataInputs[0];
            serializedObjects[0].config.valueType = (_b = (_a = context._connectionValues[socketIn.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : "FlowGraphInteger" /* FlowGraphTypes.Integer */;
            return serializedObjects;
        },
    },
    "math/and": {
        blocks: ["FlowGraphBitwiseAndBlock" /* FlowGraphBlockNames.BitwiseAnd */],
        inputs: {
            values: {
                a: { name: "a" },
                b: { name: "b" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
            var _a, _b, _c, _d;
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            // try to infer the type or fallback to Integer
            var socketInA = serializedObjects[0].dataInputs[0];
            var socketInB = serializedObjects[0].dataInputs[1];
            serializedObjects[0].config.valueType =
                (_d = (_b = (_a = context._connectionValues[socketInA.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_c = context._connectionValues[socketInB.uniqueId]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : "FlowGraphInteger" /* FlowGraphTypes.Integer */;
            return serializedObjects;
        },
    },
    "math/or": {
        blocks: ["FlowGraphBitwiseOrBlock" /* FlowGraphBlockNames.BitwiseOr */],
        inputs: {
            values: {
                a: { name: "a" },
                b: { name: "b" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
            var _a, _b, _c, _d;
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            // try to infer the type or fallback to Integer
            var socketInA = serializedObjects[0].dataInputs[0];
            var socketInB = serializedObjects[0].dataInputs[1];
            serializedObjects[0].config.valueType =
                (_d = (_b = (_a = context._connectionValues[socketInA.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_c = context._connectionValues[socketInB.uniqueId]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : "FlowGraphInteger" /* FlowGraphTypes.Integer */;
            return serializedObjects;
        },
    },
    "math/xor": {
        blocks: ["FlowGraphBitwiseXorBlock" /* FlowGraphBlockNames.BitwiseXor */],
        inputs: {
            values: {
                a: { name: "a" },
                b: { name: "b" },
            },
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
            var _a, _b, _c, _d;
            // configure it to work the way glTF specifies
            serializedObjects[0].config = serializedObjects[0].config || {};
            // try to infer the type or fallback to Integer
            var socketInA = serializedObjects[0].dataInputs[0];
            var socketInB = serializedObjects[0].dataInputs[1];
            serializedObjects[0].config.valueType =
                (_d = (_b = (_a = context._connectionValues[socketInA.uniqueId]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : (_c = context._connectionValues[socketInB.uniqueId]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : "FlowGraphInteger" /* FlowGraphTypes.Integer */;
            return serializedObjects;
        },
    },
    "math/asr": getSimpleInputMapping("FlowGraphBitwiseRightShiftBlock" /* FlowGraphBlockNames.BitwiseRightShift */, ["a", "b"]),
    "math/lsl": getSimpleInputMapping("FlowGraphBitwiseLeftShiftBlock" /* FlowGraphBlockNames.BitwiseLeftShift */, ["a", "b"]),
    "math/clz": getSimpleInputMapping("FlowGraphLeadingZerosBlock" /* FlowGraphBlockNames.LeadingZeros */),
    "math/ctz": getSimpleInputMapping("FlowGraphTrailingZerosBlock" /* FlowGraphBlockNames.TrailingZeros */),
    "math/popcnt": getSimpleInputMapping("FlowGraphOneBitsCounterBlock" /* FlowGraphBlockNames.OneBitsCounter */),
    "math/rad": getSimpleInputMapping("FlowGraphDegToRadBlock" /* FlowGraphBlockNames.DegToRad */),
    "math/deg": getSimpleInputMapping("FlowGraphRadToDegBlock" /* FlowGraphBlockNames.RadToDeg */),
    "type/boolToInt": getSimpleInputMapping("FlowGraphBooleanToInt" /* FlowGraphBlockNames.BooleanToInt */),
    "type/boolToFloat": getSimpleInputMapping("FlowGraphBooleanToFloat" /* FlowGraphBlockNames.BooleanToFloat */),
    "type/intToBool": getSimpleInputMapping("FlowGraphIntToBoolean" /* FlowGraphBlockNames.IntToBoolean */),
    "type/intToFloat": getSimpleInputMapping("FlowGraphIntToFloat" /* FlowGraphBlockNames.IntToFloat */),
    "type/floatToInt": getSimpleInputMapping("FlowGraphFloatToInt" /* FlowGraphBlockNames.FloatToInt */),
    "type/floatToBool": getSimpleInputMapping("FlowGraphFloatToBoolean" /* FlowGraphBlockNames.FloatToBoolean */),
    // flows
    "flow/sequence": {
        blocks: ["FlowGraphSequenceBlock" /* FlowGraphBlockNames.Sequence */],
        extraProcessor: function (gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
            var serializedObject = serializedObjects[0];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;
            serializedObject.signalOutputs.forEach(function (output, index) {
                output.name = "out_" + index;
            });
            return serializedObjects;
        },
    },
    "flow/branch": {
        blocks: ["FlowGraphBranchBlock" /* FlowGraphBlockNames.Branch */],
        outputs: {
            flows: {
                true: { name: "onTrue" },
                false: { name: "onFalse" },
            },
        },
    },
    "flow/switch": {
        blocks: ["FlowGraphSwitchBlock" /* FlowGraphBlockNames.Switch */],
        configuration: {
            cases: { name: "cases", inOptions: true, defaultValue: [] },
        },
        inputs: {
            values: {
                selection: { name: "case" },
                default: { name: "default" },
            },
        },
        validation: function (gltfBlock) {
            if (gltfBlock.configuration && gltfBlock.configuration.cases) {
                var cases = gltfBlock.configuration.cases.value;
                var onlyIntegers = cases.every(function (caseValue) {
                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.
                    return typeof caseValue === "number" && /^-?\d+$/.test(caseValue.toString());
                });
                if (!onlyIntegers) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Switch cases should be integers. Using empty array instead.");
                    gltfBlock.configuration.cases.value = [];
                    return { valid: true };
                }
                // check for duplicates
                var uniqueCases = new Set(cases);
                gltfBlock.configuration.cases.value = Array.from(uniqueCases);
            }
            return { valid: true };
        },
        extraProcessor: function (gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
            // convert all names of output flow to out_$1 apart from "default"
            if (declaration.op !== "flow/switch" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
                throw new Error("Switch should have a single configuration object, the cases array");
            }
            var serializedObject = serializedObjects[0];
            serializedObject.signalOutputs.forEach(function (output) {
                if (output.name !== "default") {
                    output.name = "out_" + output.name;
                }
            });
            return serializedObjects;
        },
    },
    "flow/while": {
        blocks: ["FlowGraphWhileLoopBlock" /* FlowGraphBlockNames.WhileLoop */],
        outputs: {
            flows: {
                loopBody: { name: "executionFlow" },
            },
        },
    },
    "flow/for": {
        blocks: ["FlowGraphForLoopBlock" /* FlowGraphBlockNames.ForLoop */],
        configuration: {
            initialIndex: { name: "initialIndex", gltfType: "number", inOptions: true, defaultValue: 0 },
        },
        inputs: {
            values: {
                startIndex: { name: "startIndex", gltfType: "number" },
                endIndex: { name: "endIndex", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                index: { name: "index" },
            },
            flows: {
                loopBody: { name: "executionFlow" },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
            var serializedObject = serializedObjects[0];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.incrementIndexWhenLoopDone = true;
            return serializedObjects;
        },
    },
    "flow/doN": {
        blocks: ["FlowGraphDoNBlock" /* FlowGraphBlockNames.DoN */],
        configuration: {},
        inputs: {
            values: {
                n: { name: "maxExecutions", gltfType: "number" },
            },
        },
        outputs: {
            values: {
                currentCount: { name: "executionCount" },
            },
        },
    },
    "flow/multiGate": {
        blocks: ["FlowGraphMultiGateBlock" /* FlowGraphBlockNames.MultiGate */],
        configuration: {
            isRandom: { name: "isRandom", gltfType: "boolean", inOptions: true, defaultValue: false },
            isLoop: { name: "isLoop", gltfType: "boolean", inOptions: true, defaultValue: false },
        },
        extraProcessor: function (gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
            if (declaration.op !== "flow/multiGate" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
                throw new Error("MultiGate should have a single configuration object, the number of output flows");
            }
            var serializedObject = serializedObjects[0];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;
            serializedObject.signalOutputs.forEach(function (output, index) {
                output.name = "out_" + index;
            });
            return serializedObjects;
        },
    },
    "flow/waitAll": {
        blocks: ["FlowGraphWaitAllBlock" /* FlowGraphBlockNames.WaitAll */],
        configuration: {
            inputFlows: { name: "inputSignalCount", gltfType: "number", inOptions: true, defaultValue: 0 },
        },
        inputs: {
            flows: {
                reset: { name: "reset" },
                "[segment]": { name: "in_$1" },
            },
        },
        validation: function (gltfBlock) {
            var _a, _b;
            // check that the configuration value is an integer
            if (typeof ((_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a.inputFlows) === null || _b === void 0 ? void 0 : _b.value[0]) !== "number") {
                gltfBlock.configuration = gltfBlock.configuration || {
                    inputFlows: { value: [0] },
                };
                gltfBlock.configuration.inputFlows.value = [0];
            }
            return { valid: true };
        },
    },
    "flow/throttle": {
        blocks: ["FlowGraphThrottleBlock" /* FlowGraphBlockNames.Throttle */],
        outputs: {
            flows: {
                err: { name: "error" },
            },
        },
    },
    "flow/setDelay": {
        blocks: ["FlowGraphSetDelayBlock" /* FlowGraphBlockNames.SetDelay */],
        outputs: {
            flows: {
                err: { name: "error" },
            },
        },
    },
    "flow/cancelDelay": {
        blocks: ["FlowGraphCancelDelayBlock" /* FlowGraphBlockNames.CancelDelay */],
    },
    "variable/get": {
        blocks: ["FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */],
        validation: function (gltfBlock) {
            var _a, _b;
            if (!((_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a.variable) === null || _b === void 0 ? void 0 : _b.value)) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Variable get block should have a variable configuration");
                return { valid: false, error: "Variable get block should have a variable configuration" };
            }
            return { valid: true };
        },
        configuration: {
            variable: {
                name: "variable",
                gltfType: "number",
                flowGraphType: "string",
                inOptions: true,
                isVariable: true,
                dataTransformer: function (index, parser) {
                    return [parser.getVariableName(index[0])];
                },
            },
        },
    },
    "variable/set": {
        blocks: ["FlowGraphSetVariableBlock" /* FlowGraphBlockNames.SetVariable */],
        configuration: {
            variable: {
                name: "variable",
                gltfType: "number",
                flowGraphType: "string",
                inOptions: true,
                isVariable: true,
                dataTransformer: function (index, parser) {
                    return [parser.getVariableName(index[0])];
                },
            },
        },
    },
    "variable/setMultiple": {
        blocks: ["FlowGraphSetVariableBlock" /* FlowGraphBlockNames.SetVariable */],
        configuration: {
            variables: {
                name: "variables",
                gltfType: "number",
                flowGraphType: "string",
                inOptions: true,
                dataTransformer: function (index, parser) {
                    return [index[0].map(function (i) { return parser.getVariableName(i); })];
                },
            },
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, parser, serializedObjects) {
            // variable/get configuration
            var serializedGetVariable = serializedObjects[0];
            serializedGetVariable.dataInputs.forEach(function (input) {
                input.name = parser.getVariableName(+input.name);
            });
            return serializedObjects;
        },
    },
    "variable/interpolate": {
        blocks: [
            "FlowGraphInterpolationBlock" /* FlowGraphBlockNames.ValueInterpolation */,
            "FlowGraphContextBlock" /* FlowGraphBlockNames.Context */,
            "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */,
            "FlowGraphBezierCurveEasing" /* FlowGraphBlockNames.BezierCurveEasing */,
            "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */,
        ],
        configuration: {
            variable: {
                name: "propertyName",
                inOptions: true,
                isVariable: true,
                dataTransformer: function (index, parser) {
                    return [parser.getVariableName(index[0])];
                },
            },
            useSlerp: {
                name: "animationType",
                inOptions: true,
                defaultValue: false,
                dataTransformer: function (value) {
                    if (value[0] === true) {
                        return ["Quaternion" /* FlowGraphTypes.Quaternion */];
                    }
                    else {
                        return [undefined];
                    }
                },
            },
        },
        inputs: {
            values: {
                value: { name: "value_1" },
                duration: { name: "duration_1", gltfType: "number" },
                p1: { name: "controlPoint1", toBlock: "FlowGraphBezierCurveEasing" /* FlowGraphBlockNames.BezierCurveEasing */ },
                p2: { name: "controlPoint2", toBlock: "FlowGraphBezierCurveEasing" /* FlowGraphBlockNames.BezierCurveEasing */ },
            },
            flows: {
                in: { name: "in", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
            },
        },
        outputs: {
            flows: {
                err: { name: "error", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
                out: { name: "out", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
                done: { name: "done", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
            },
        },
        interBlockConnectors: [
            {
                input: "object",
                output: "userVariables",
                inputBlockIndex: 2,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "animation",
                output: "animation",
                inputBlockIndex: 2,
                outputBlockIndex: 0,
                isVariable: true,
            },
            {
                input: "easingFunction",
                output: "easingFunction",
                inputBlockIndex: 0,
                outputBlockIndex: 3,
                isVariable: true,
            },
            {
                input: "value_0",
                output: "value",
                inputBlockIndex: 0,
                outputBlockIndex: 4,
                isVariable: true,
            },
        ],
        extraProcessor: function (gltfBlock, _declaration, _mapping, parser, serializedObjects) {
            var _a;
            var _b, _c;
            // is useSlerp is used, animationType should be set to be quaternion!
            var serializedValueInterpolation = serializedObjects[0];
            var propertyIndex = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a.variable.value[0];
            if (typeof propertyIndex !== "number") {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Variable index is not defined for variable interpolation block");
                throw new Error("Variable index is not defined for variable interpolation block");
            }
            var variable = parser.arrays.staticVariables[propertyIndex];
            // if not set by useSlerp
            if (typeof serializedValueInterpolation.config.animationType.value === "undefined") {
                // get the value type
                parser.arrays.staticVariables;
                serializedValueInterpolation.config.animationType.value = (0,babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.getAnimationTypeByFlowGraphType)(variable.type);
            }
            // variable/get configuration
            var serializedGetVariable = serializedObjects[4];
            serializedGetVariable.config || (serializedGetVariable.config = {});
            (_b = serializedGetVariable.config).variable || (_b.variable = {});
            serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);
            // get the control points from the easing block
            (_c = serializedObjects[3]).config || (_c.config = {});
            return serializedObjects;
        },
    },
    "pointer/get": {
        blocks: ["FlowGraphGetPropertyBlock" /* FlowGraphBlockNames.GetProperty */, "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */],
        configuration: {
            pointer: { name: "jsonPointer", toBlock: "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */ },
        },
        inputs: {
            values: {
                "[segment]": { name: "$1", toBlock: "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */ },
            },
        },
        interBlockConnectors: [
            {
                input: "object",
                output: "object",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "propertyName",
                output: "propertyName",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "customGetFunction",
                output: "getFunction",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
        ],
        extraProcessor: function (gltfBlock, _declaration, _mapping, parser, serializedObjects) {
            serializedObjects.forEach(function (serializedObject) {
                // check if it is the json pointer block
                if (serializedObject.className === "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */) {
                    serializedObject.config || (serializedObject.config = {});
                    serializedObject.config.outputValue = true;
                }
            });
            return serializedObjects;
        },
    },
    "pointer/set": {
        blocks: ["FlowGraphSetPropertyBlock" /* FlowGraphBlockNames.SetProperty */, "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */],
        configuration: {
            pointer: { name: "jsonPointer", toBlock: "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */ },
        },
        inputs: {
            values: {
                // must be defined due to the array taking over
                value: { name: "value" },
                "[segment]": { name: "$1", toBlock: "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */ },
            },
        },
        outputs: {
            flows: {
                err: { name: "error" },
            },
        },
        interBlockConnectors: [
            {
                input: "object",
                output: "object",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "propertyName",
                output: "propertyName",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "customSetFunction",
                output: "setFunction",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
        ],
        extraProcessor: function (gltfBlock, _declaration, _mapping, parser, serializedObjects) {
            serializedObjects.forEach(function (serializedObject) {
                // check if it is the json pointer block
                if (serializedObject.className === "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */) {
                    serializedObject.config || (serializedObject.config = {});
                    serializedObject.config.outputValue = true;
                }
            });
            return serializedObjects;
        },
    },
    "pointer/interpolate": {
        // interpolate, parse the pointer and play the animation generated. 3 blocks!
        blocks: ["FlowGraphInterpolationBlock" /* FlowGraphBlockNames.ValueInterpolation */, "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */, "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */, "FlowGraphBezierCurveEasing" /* FlowGraphBlockNames.BezierCurveEasing */],
        configuration: {
            pointer: { name: "jsonPointer", toBlock: "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */ },
        },
        inputs: {
            values: {
                value: { name: "value_1" },
                "[segment]": { name: "$1", toBlock: "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */ },
                duration: { name: "duration_1", gltfType: "number" /*, inOptions: true */ },
                p1: { name: "controlPoint1", toBlock: "FlowGraphBezierCurveEasing" /* FlowGraphBlockNames.BezierCurveEasing */ },
                p2: { name: "controlPoint2", toBlock: "FlowGraphBezierCurveEasing" /* FlowGraphBlockNames.BezierCurveEasing */ },
            },
            flows: {
                in: { name: "in", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
            },
        },
        outputs: {
            flows: {
                err: { name: "error", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
                out: { name: "out", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
                done: { name: "done", toBlock: "FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */ },
            },
        },
        interBlockConnectors: [
            {
                input: "object",
                output: "object",
                inputBlockIndex: 2,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "propertyName",
                output: "propertyName",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "customBuildAnimation",
                output: "generateAnimationsFunction",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "animation",
                output: "animation",
                inputBlockIndex: 2,
                outputBlockIndex: 0,
                isVariable: true,
            },
            {
                input: "easingFunction",
                output: "easingFunction",
                inputBlockIndex: 0,
                outputBlockIndex: 3,
                isVariable: true,
            },
            {
                input: "value_0",
                output: "value",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
        ],
        extraProcessor: function (gltfBlock, _declaration, _mapping, parser, serializedObjects) {
            serializedObjects.forEach(function (serializedObject) {
                // check if it is the json pointer block
                if (serializedObject.className === "FlowGraphJsonPointerParserBlock" /* FlowGraphBlockNames.JsonPointerParser */) {
                    serializedObject.config || (serializedObject.config = {});
                    serializedObject.config.outputValue = true;
                }
                else if (serializedObject.className === "FlowGraphInterpolationBlock" /* FlowGraphBlockNames.ValueInterpolation */) {
                    serializedObject.config || (serializedObject.config = {});
                    Object.keys(gltfBlock.values || []).forEach(function (key) {
                        var _a;
                        var value = (_a = gltfBlock.values) === null || _a === void 0 ? void 0 : _a[key];
                        if (key === "value" && value) {
                            // get the type of the value
                            var type = value.type;
                            if (type !== undefined) {
                                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;
                            }
                        }
                    });
                }
            });
            return serializedObjects;
        },
    },
    "animation/start": {
        blocks: ["FlowGraphPlayAnimationBlock" /* FlowGraphBlockNames.PlayAnimation */, "FlowGraphArrayIndexBlock" /* FlowGraphBlockNames.ArrayIndex */, "KHR_interactivity/FlowGraphGLTFDataProvider"],
        inputs: {
            values: {
                animation: { name: "index", gltfType: "number", toBlock: "FlowGraphArrayIndexBlock" /* FlowGraphBlockNames.ArrayIndex */ },
                speed: { name: "speed", gltfType: "number" },
                startTime: { name: "from", gltfType: "number", dataTransformer: function (time, parser) { return [time[0] * parser._animationTargetFps]; } },
                endTime: { name: "to", gltfType: "number", dataTransformer: function (time, parser) { return [time[0] * parser._animationTargetFps]; } },
            },
        },
        outputs: {
            flows: {
                err: { name: "error" },
            },
        },
        interBlockConnectors: [
            {
                input: "animationGroup",
                output: "value",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "array",
                output: "animationGroups",
                inputBlockIndex: 1,
                outputBlockIndex: 2,
                isVariable: true,
            },
        ],
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
            // add the glTF to the configuration of the last serialized object
            var serializedObject = serializedObjects[serializedObjects.length - 1];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.glTF = globalGLTF;
            return serializedObjects;
        },
    },
    "animation/stop": {
        blocks: ["FlowGraphStopAnimationBlock" /* FlowGraphBlockNames.StopAnimation */, "FlowGraphArrayIndexBlock" /* FlowGraphBlockNames.ArrayIndex */, "KHR_interactivity/FlowGraphGLTFDataProvider"],
        inputs: {
            values: {
                animation: { name: "index", gltfType: "number", toBlock: "FlowGraphArrayIndexBlock" /* FlowGraphBlockNames.ArrayIndex */ },
            },
        },
        outputs: {
            flows: {
                err: { name: "error" },
            },
        },
        interBlockConnectors: [
            {
                input: "animationGroup",
                output: "value",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "array",
                output: "animationGroups",
                inputBlockIndex: 1,
                outputBlockIndex: 2,
                isVariable: true,
            },
        ],
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
            // add the glTF to the configuration of the last serialized object
            var serializedObject = serializedObjects[serializedObjects.length - 1];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.glTF = globalGLTF;
            return serializedObjects;
        },
    },
    "animation/stopAt": {
        blocks: ["FlowGraphStopAnimationBlock" /* FlowGraphBlockNames.StopAnimation */, "FlowGraphArrayIndexBlock" /* FlowGraphBlockNames.ArrayIndex */, "KHR_interactivity/FlowGraphGLTFDataProvider"],
        configuration: {},
        inputs: {
            values: {
                animation: { name: "index", gltfType: "number", toBlock: "FlowGraphArrayIndexBlock" /* FlowGraphBlockNames.ArrayIndex */ },
                stopTime: { name: "stopAtFrame", gltfType: "number", dataTransformer: function (time, parser) { return [time[0] * parser._animationTargetFps]; } },
            },
        },
        outputs: {
            flows: {
                err: { name: "error" },
            },
        },
        interBlockConnectors: [
            {
                input: "animationGroup",
                output: "value",
                inputBlockIndex: 0,
                outputBlockIndex: 1,
                isVariable: true,
            },
            {
                input: "array",
                output: "animationGroups",
                inputBlockIndex: 1,
                outputBlockIndex: 2,
                isVariable: true,
            },
        ],
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
            // add the glTF to the configuration of the last serialized object
            var serializedObject = serializedObjects[serializedObjects.length - 1];
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.glTF = globalGLTF;
            return serializedObjects;
        },
    },
    "math/switch": {
        blocks: ["FlowGraphDataSwitchBlock" /* FlowGraphBlockNames.DataSwitch */],
        configuration: {
            cases: { name: "cases", inOptions: true, defaultValue: [] },
        },
        inputs: {
            values: {
                selection: { name: "case" },
            },
        },
        validation: function (gltfBlock) {
            if (gltfBlock.configuration && gltfBlock.configuration.cases) {
                var cases = gltfBlock.configuration.cases.value;
                var onlyIntegers = cases.every(function (caseValue) {
                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.
                    return typeof caseValue === "number" && /^-?\d+$/.test(caseValue.toString());
                });
                if (!onlyIntegers) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Switch cases should be integers. Using empty array instead.");
                    gltfBlock.configuration.cases.value = [];
                    return { valid: true };
                }
                // check for duplicates
                var uniqueCases = new Set(cases);
                gltfBlock.configuration.cases.value = Array.from(uniqueCases);
            }
            return { valid: true };
        },
        extraProcessor: function (_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
            var serializedObject = serializedObjects[0];
            serializedObject.dataInputs.forEach(function (input) {
                if (input.name !== "default" && input.name !== "case") {
                    input.name = "in_" + input.name;
                }
            });
            serializedObject.config || (serializedObject.config = {});
            serializedObject.config.treatCasesAsIntegers = true;
            return serializedObjects;
        },
    },
    "debug/log": {
        blocks: ["FlowGraphConsoleLogBlock" /* FlowGraphBlockNames.ConsoleLog */],
        configuration: {
            message: { name: "messageTemplate", inOptions: true },
        },
    },
};
function getSimpleInputMapping(type, inputs, inferType) {
    if (inputs === void 0) { inputs = ["a"]; }
    return {
        blocks: [type],
        inputs: {
            values: inputs.reduce(function (acc, input) {
                acc[input] = { name: input };
                return acc;
            }, {}),
        },
        outputs: {
            values: {
                value: { name: "value" },
            },
        },
        extraProcessor: function (gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
            if (inferType) {
                // configure it to work the way glTF specifies
                serializedObjects[0].config = serializedObjects[0].config || {};
                serializedObjects[0].config.preventIntegerFloatArithmetic = true;
                // try to infer the type or fallback to Integer
                // check the gltf block for the inputs, see if they have a type
                var type_1 = -1;
                Object.keys(gltfBlock.values || {}).find(function (value) {
                    var _a;
                    if (((_a = gltfBlock.values) === null || _a === void 0 ? void 0 : _a[value].type) !== undefined) {
                        type_1 = gltfBlock.values[value].type;
                        return true;
                    }
                    return false;
                });
                if (type_1 !== -1) {
                    serializedObjects[0].config.type = _parser.arrays.types[type_1].flowGraphType;
                }
            }
            return serializedObjects;
        },
        validation: function (gltfBlock) {
            if (inferType) {
                // make sure types are the same
                return ValidateTypes(gltfBlock);
            }
            return { valid: true };
        },
    };
}
function ValidateTypes(gltfBlock) {
    if (gltfBlock.values) {
        var types_1 = Object.keys(gltfBlock.values)
            .map(function (key) { return gltfBlock.values[key].type; })
            .filter(function (type) { return type !== undefined; });
        var allSameType = types_1.every(function (type) { return type === types_1[0]; });
        if (!allSameType) {
            return { valid: false, error: "All inputs must be of the same type" };
        }
    }
    return { valid: true };
}
function getAllSupportedNativeNodeTypes() {
    return Object.keys(gltfToFlowGraphMapping);
}
/**
 *
 * These are the nodes from the specs:

### Math Nodes
1. **Constants**
   - E (`math/e`) FlowGraphBlockNames.E
   - Pi (`math/pi`) FlowGraphBlockNames.PI
   - Infinity (`math/inf`) FlowGraphBlockNames.Inf
   - Not a Number (`math/nan`) FlowGraphBlockNames.NaN
2. **Arithmetic Nodes**
   - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs
   - Sign (`math/sign`) FlowGraphBlockNames.Sign
   - Truncate (`math/trunc`) FlowGraphBlockNames.Trunc
   - Floor (`math/floor`) FlowGraphBlockNames.Floor
   - Ceil (`math/ceil`) FlowGraphBlockNames.Ceil
   - Round (`math/round`)  FlowGraphBlockNames.Round
   - Fraction (`math/fract`) FlowGraphBlockNames.Fract
   - Negation (`math/neg`) FlowGraphBlockNames.Negation
   - Addition (`math/add`) FlowGraphBlockNames.Add
   - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract
   - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply
   - Division (`math/div`) FlowGraphBlockNames.Divide
   - Remainder (`math/rem`) FlowGraphBlockNames.Modulo
   - Minimum (`math/min`) FlowGraphBlockNames.Min
   - Maximum (`math/max`) FlowGraphBlockNames.Max
   - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp
   - Saturate (`math/saturate`) FlowGraphBlockNames.Saturate
   - Interpolate (`math/mix`) FlowGraphBlockNames.MathInterpolation
3. **Comparison Nodes**
   - Equality (`math/eq`) FlowGraphBlockNames.Equality
   - Less Than (`math/lt`) FlowGraphBlockNames.LessThan
   - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual
   - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan
   - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual
4. **Special Nodes**
   - Is Not a Number (`math/isnan`) FlowGraphBlockNames.IsNaN
   - Is Infinity (`math/isinf`) FlowGraphBlockNames.IsInfinity
   - Select (`math/select`) FlowGraphBlockNames.Conditional
   - Random (`math/random`) FlowGraphBlockNames.Random
5. **Angle and Trigonometry Nodes**
   - Degrees-To-Radians (`math/rad`) FlowGraphBlockNames.DegToRad
   - Radians-To-Degrees (`math/deg`) FlowGraphBlockNames.RadToDeg
   - Sine (`math/sin`)  FlowGraphBlockNames.Sin
   - Cosine (`math/cos`) FlowGraphBlockNames.Cos
   - Tangent (`math/tan`) FlowGraphBlockNames.Tan
   - Arcsine (`math/asin`) FlowGraphBlockNames.Asin
   - Arccosine (`math/acos`) FlowGraphBlockNames.Acos
   - Arctangent (`math/atan`) FlowGraphBlockNames.Atan
   - Arctangent 2 (`math/atan2`) FlowGraphBlockNames.Atan2
6. **Hyperbolic Nodes**
   - Hyperbolic Sine (`math/sinh`) FlowGraphBlockNames.Sinh
   - Hyperbolic Cosine (`math/cosh`) FlowGraphBlockNames.Cosh
   - Hyperbolic Tangent (`math/tanh`) FlowGraphBlockNames.Tanh
   - Inverse Hyperbolic Sine (`math/asinh`) FlowGraphBlockNames.Asinh
   - Inverse Hyperbolic Cosine (`math/acosh`) FlowGraphBlockNames.Acosh
   - Inverse Hyperbolic Tangent (`math/atanh`) FlowGraphBlockNames.Atanh
7. **Exponential Nodes**
   - Exponent (`math/exp`) FlowGraphBlockNames.Exponential
   - Natural Logarithm (`math/log`) FlowGraphBlockNames.Log
   - Base-2 Logarithm (`math/log2`) FlowGraphBlockNames.Log2
   - Base-10 Logarithm (`math/log10`) FlowGraphBlockNames.Log10
   - Square Root (`math/sqrt`) FlowGraphBlockNames.SquareRoot
   - Cube Root (`math/cbrt`) FlowGraphBlockNames.CubeRoot
   - Power (`math/pow`) FlowGraphBlockNames.Power
8. **Vector Nodes**
   - Length (`math/length`) FlowGraphBlockNames.Length
   - Normalize (`math/normalize`) FlowGraphBlockNames.Normalize
   - Dot Product (`math/dot`) FlowGraphBlockNames.Dot
   - Cross Product (`math/cross`) FlowGraphBlockNames.Cross
   - Rotate 2D (`math/rotate2D`) FlowGraphBlockNames.Rotate2D
   - Rotate 3D (`math/rotate3D`) FlowGraphBlockNames.Rotate3D
   - Transform (`math/transform`) FlowGraphBlockNames.TransformVector
9. **Matrix Nodes**
   - Transpose (`math/transpose`) FlowGraphBlockNames.Transpose
   - Determinant (`math/determinant`) FlowGraphBlockNames.Determinant
   - Inverse (`math/inverse`) FlowGraphBlockNames.InvertMatrix
   - Multiplication (`math/matmul`) FlowGraphBlockNames.MatrixMultiplication
10. **Swizzle Nodes**
    - Combine (`math/combine2`, `math/combine3`, `math/combine4`, `math/combine2x2`, `math/combine3x3`, `math/combine4x4`)
        FlowGraphBlockNames.CombineVector2, FlowGraphBlockNames.CombineVector3, FlowGraphBlockNames.CombineVector4
        FlowGraphBlockNames.CombineMatrix2D, FlowGraphBlockNames.CombineMatrix3D, FlowGraphBlockNames.CombineMatrix
    - Extract (`math/extract2`, `math/extract3`, `math/extract4`, `math/extract2x2`, `math/extract3x3`, `math/extract4x4`)
        FlowGraphBlockNames.ExtractVector2, FlowGraphBlockNames.ExtractVector3, FlowGraphBlockNames.ExtractVector4
        FlowGraphBlockNames.ExtractMatrix2D, FlowGraphBlockNames.ExtractMatrix3D, FlowGraphBlockNames.ExtractMatrix
11. **Integer Arithmetic Nodes**
    - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs
    - Sign (`math/sign`) FlowGraphBlockNames.Sign
    - Negation (`math/neg`) FlowGraphBlockNames.Negation
    - Addition (`math/add`) FlowGraphBlockNames.Add
    - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract
    - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply
    - Division (`math/div`) FlowGraphBlockNames.Divide
    - Remainder (`math/rem`) FlowGraphBlockNames.Modulo
    - Minimum (`math/min`) FlowGraphBlockNames.Min
    - Maximum (`math/max`) FlowGraphBlockNames.Max
    - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp
12. **Integer Comparison Nodes**
    - Equality (`math/eq`) FlowGraphBlockNames.Equality
    - Less Than (`math/lt`) FlowGraphBlockNames.LessThan
    - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual
    - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan
    - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual
13. **Integer Bitwise Nodes**
    - Bitwise NOT (`math/not`) FlowGraphBlockNames.BitwiseNot
    - Bitwise AND (`math/and`) FlowGraphBlockNames.BitwiseAnd
    - Bitwise OR (`math/or`) FlowGraphBlockNames.BitwiseOr
    - Bitwise XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor
    - Right Shift (`math/asr`) FlowGraphBlockNames.BitwiseRightShift
    - Left Shift (`math/lsl`) FlowGraphBlockNames.BitwiseLeftShift
    - Count Leading Zeros (`math/clz`) FlowGraphBlockNames.LeadingZeros
    - Count Trailing Zeros (`math/ctz`) FlowGraphBlockNames.TrailingZeros
    - Count One Bits (`math/popcnt`) FlowGraphBlockNames.OneBitsCounter
14. **Boolean Arithmetic Nodes**
    - Equality (`math/eq`) FlowGraphBlockNames.Equality
    - Boolean NOT (`math/not`) FlowGraphBlockNames.BitwiseNot
    - Boolean AND (`math/and`) FlowGraphBlockNames.BitwiseAnd
    - Boolean OR (`math/or`) FlowGraphBlockNames.BitwiseOr
    - Boolean XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor

### Type Conversion Nodes
1. **Boolean Conversion Nodes**
   - Boolean to Integer (`type/boolToInt`) FlowGraphBlockNames.BooleanToInt
   - Boolean to Float (`type/boolToFloat`) FlowGraphBlockNames.BooleanToFloat
2. **Integer Conversion Nodes**
   - Integer to Boolean (`type/intToBool`) FlowGraphBlockNames.IntToBoolean
   - Integer to Float (`type/intToFloat`) FlowGraphBlockNames.IntToFloat
3. **Float Conversion Nodes**
   - Float to Boolean (`type/floatToBool`) FlowGraphBlockNames.FloatToBoolean
   - Float to Integer (`type/floatToInt`) FlowGraphBlockNames.FloatToInt

### Control Flow Nodes
1. **Sync Nodes**
   - Sequence (`flow/sequence`) FlowGraphBlockNames.Sequence
   - Branch (`flow/branch`) FlowGraphBlockNames.Branch
   - Switch (`flow/switch`) FlowGraphBlockNames.Switch
   - While Loop (`flow/while`) FlowGraphBlockNames.WhileLoop
   - For Loop (`flow/for`) FlowGraphBlockNames.ForLoop
   - Do N (`flow/doN`) FlowGraphBlockNames.DoN
   - Multi Gate (`flow/multiGate`) FlowGraphBlockNames.MultiGate
   - Wait All (`flow/waitAll`) FlowGraphBlockNames.WaitAll
   - Throttle (`flow/throttle`) FlowGraphBlockNames.Throttle
2. **Delay Nodes**
   - Set Delay (`flow/setDelay`) FlowGraphBlockNames.SetDelay
   - Cancel Delay (`flow/cancelDelay`) FlowGraphBlockNames.CancelDelay

### State Manipulation Nodes
1. **Custom Variable Access**
   - Variable Get (`variable/get`) FlowGraphBlockNames.GetVariable
   - Variable Set (`variable/set`) FlowGraphBlockNames.SetVariable
   - Variable Interpolate (`variable/interpolate`)
2. **Object Model Access** // TODO fully test this!!!
   - JSON Pointer Template Parsing (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]
   - Effective JSON Pointer Generation (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]
   - Pointer Get (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]
   - Pointer Set (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]
   - Pointer Interpolate (`pointer/interpolate`) [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.Easing]

### Animation Control Nodes
1. **Animation Play** (`animation/start`) FlowGraphBlockNames.PlayAnimation
2. **Animation Stop** (`animation/stop`) FlowGraphBlockNames.StopAnimation
3. **Animation Stop At** (`animation/stopAt`) FlowGraphBlockNames.StopAnimation

### Event Nodes
1. **Lifecycle Event Nodes**
   - On Start (`event/onStart`) FlowGraphBlockNames.SceneReadyEvent
   - On Tick (`event/onTick`) FlowGraphBlockNames.SceneTickEvent
2. **Custom Event Nodes**
   - Receive (`event/receive`) FlowGraphBlockNames.ReceiveCustomEvent
   - Send (`event/send`) FlowGraphBlockNames.SendCustomEvent

 */


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts":
/*!***************************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlowGraphGLTFDataProvider: () => (/* binding */ FlowGraphGLTFDataProvider)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/FlowGraph/flowGraphRichTypes */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__);



/**
 * a glTF-based FlowGraph block that provides arrays with babylon object, based on the glTF tree
 * Can be used, for example, to get animation index from a glTF animation
 */
var FlowGraphGLTFDataProvider = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(FlowGraphGLTFDataProvider, _super);
    function FlowGraphGLTFDataProvider(config) {
        var _a, _b;
        var _this = _super.call(this) || this;
        var glTF = config.glTF;
        var animationGroups = ((_a = glTF.animations) === null || _a === void 0 ? void 0 : _a.map(function (a) { return a._babylonAnimationGroup; })) || [];
        _this.animationGroups = _this.registerDataOutput("animationGroups", babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__.RichTypeAny, animationGroups);
        var nodes = ((_b = glTF.nodes) === null || _b === void 0 ? void 0 : _b.map(function (n) { return n._babylonTransformNode; })) || [];
        _this.nodes = _this.registerDataOutput("nodes", babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__.RichTypeAny, nodes);
        return _this;
    }
    FlowGraphGLTFDataProvider.prototype.getClassName = function () {
        return "FlowGraphGLTFDataProvider";
    };
    return FlowGraphGLTFDataProvider;
}(babylonjs_FlowGraph_flowGraphBlock__WEBPACK_IMPORTED_MODULE_0__.FlowGraphBlock));



/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/index.ts":
/*!*******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/index.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlowGraphGLTFDataProvider: () => (/* reexport safe */ _flowGraphGLTFDataProvider__WEBPACK_IMPORTED_MODULE_2__.FlowGraphGLTFDataProvider),
/* harmony export */   InteractivityGraphToFlowGraphParser: () => (/* reexport safe */ _interactivityGraphParser__WEBPACK_IMPORTED_MODULE_1__.InteractivityGraphToFlowGraphParser),
/* harmony export */   addNewInteractivityFlowGraphMapping: () => (/* reexport safe */ _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.addNewInteractivityFlowGraphMapping),
/* harmony export */   getAllSupportedNativeNodeTypes: () => (/* reexport safe */ _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getAllSupportedNativeNodeTypes),
/* harmony export */   getMappingForDeclaration: () => (/* reexport safe */ _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForDeclaration),
/* harmony export */   getMappingForFullOperationName: () => (/* reexport safe */ _declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForFullOperationName),
/* harmony export */   gltfTypeToBabylonType: () => (/* reexport safe */ _interactivityGraphParser__WEBPACK_IMPORTED_MODULE_1__.gltfTypeToBabylonType)
/* harmony export */ });
/* harmony import */ var _declarationMapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./declarationMapper */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts");
/* harmony import */ var _interactivityGraphParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interactivityGraphParser */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts");
/* harmony import */ var _flowGraphGLTFDataProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flowGraphGLTFDataProvider */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts");





/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts":
/*!**************************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InteractivityGraphToFlowGraphParser: () => (/* binding */ InteractivityGraphToFlowGraphParser),
/* harmony export */   gltfTypeToBabylonType: () => (/* binding */ gltfTypeToBabylonType)
/* harmony export */ });
/* harmony import */ var _declarationMapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./declarationMapper */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts");
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babylonjs/Misc/guid */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__);



// eslint-disable-next-line @typescript-eslint/naming-convention
var gltfTypeToBabylonType = {
    float: { length: 1, flowGraphType: "number" /* FlowGraphTypes.Number */, elementType: "number" },
    bool: { length: 1, flowGraphType: "boolean" /* FlowGraphTypes.Boolean */, elementType: "boolean" },
    float2: { length: 2, flowGraphType: "Vector2" /* FlowGraphTypes.Vector2 */, elementType: "number" },
    float3: { length: 3, flowGraphType: "Vector3" /* FlowGraphTypes.Vector3 */, elementType: "number" },
    float4: { length: 4, flowGraphType: "Vector4" /* FlowGraphTypes.Vector4 */, elementType: "number" },
    float4x4: { length: 16, flowGraphType: "Matrix" /* FlowGraphTypes.Matrix */, elementType: "number" },
    float2x2: { length: 4, flowGraphType: "Matrix2D" /* FlowGraphTypes.Matrix2D */, elementType: "number" },
    float3x3: { length: 9, flowGraphType: "Matrix3D" /* FlowGraphTypes.Matrix3D */, elementType: "number" },
    int: { length: 1, flowGraphType: "FlowGraphInteger" /* FlowGraphTypes.Integer */, elementType: "number" },
};
var InteractivityGraphToFlowGraphParser = /** @class */ (function () {
    function InteractivityGraphToFlowGraphParser(_interactivityGraph, _gltf, _animationTargetFps) {
        if (_animationTargetFps === void 0) { _animationTargetFps = 60; }
        this._interactivityGraph = _interactivityGraph;
        this._gltf = _gltf;
        this._animationTargetFps = _animationTargetFps;
        /**
         * Note - the graph should be rejected if the same type is defined twice.
         * We currently don't validate that.
         */
        this._types = [];
        this._mappings = [];
        this._staticVariables = [];
        this._events = [];
        this._internalEventsCounter = 0;
        this._nodes = [];
        // start with types
        this._parseTypes();
        // continue with declarations
        this._parseDeclarations();
        this._parseVariables();
        this._parseEvents();
        this._parseNodes();
    }
    Object.defineProperty(InteractivityGraphToFlowGraphParser.prototype, "arrays", {
        get: function () {
            return {
                types: this._types,
                mappings: this._mappings,
                staticVariables: this._staticVariables,
                events: this._events,
                nodes: this._nodes,
            };
        },
        enumerable: false,
        configurable: true
    });
    InteractivityGraphToFlowGraphParser.prototype._parseTypes = function () {
        if (!this._interactivityGraph.types) {
            return;
        }
        for (var _i = 0, _a = this._interactivityGraph.types; _i < _a.length; _i++) {
            var type = _a[_i];
            this._types.push(gltfTypeToBabylonType[type.signature]);
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._parseDeclarations = function () {
        if (!this._interactivityGraph.declarations) {
            return;
        }
        for (var _i = 0, _a = this._interactivityGraph.declarations; _i < _a.length; _i++) {
            var declaration = _a[_i];
            // make sure we have the mapping for this operation
            var mapping = (0,_declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForDeclaration)(declaration);
            // mapping is defined, because we generate an empty mapping if it's not found
            if (!mapping) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for declaration", declaration]);
                throw new Error("Error parsing declarations");
            }
            this._mappings.push({
                flowGraphMapping: mapping,
                fullOperationName: declaration.extension ? declaration.op + ":" + declaration.extension : declaration.op,
            });
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._parseVariables = function () {
        if (!this._interactivityGraph.variables) {
            return;
        }
        for (var _i = 0, _a = this._interactivityGraph.variables; _i < _a.length; _i++) {
            var variable = _a[_i];
            var parsed = this._parseVariable(variable);
            // set the default values here
            this._staticVariables.push(parsed);
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._parseVariable = function (variable, dataTransform) {
        var type = this._types[variable.type];
        if (!type) {
            babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No type found for variable", variable]);
            throw new Error("Error parsing variables");
        }
        if (variable.value) {
            if (variable.value.length !== type.length) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["Invalid value length for variable", variable, type]);
                throw new Error("Error parsing variables");
            }
        }
        var value = variable.value || [];
        if (!value.length) {
            switch (type.flowGraphType) {
                case "boolean" /* FlowGraphTypes.Boolean */:
                    value.push(false);
                    break;
                case "FlowGraphInteger" /* FlowGraphTypes.Integer */:
                    value.push(0);
                    break;
                case "number" /* FlowGraphTypes.Number */:
                    value.push(NaN);
                    break;
                case "Vector2" /* FlowGraphTypes.Vector2 */:
                    value.push(NaN, NaN);
                    break;
                case "Vector3" /* FlowGraphTypes.Vector3 */:
                    value.push(NaN, NaN, NaN);
                    break;
                case "Vector4" /* FlowGraphTypes.Vector4 */:
                case "Matrix2D" /* FlowGraphTypes.Matrix2D */:
                case "Quaternion" /* FlowGraphTypes.Quaternion */:
                    value.fill(NaN, 0, 4);
                    break;
                case "Matrix" /* FlowGraphTypes.Matrix */:
                    value.fill(NaN, 0, 16);
                    break;
                case "Matrix3D" /* FlowGraphTypes.Matrix3D */:
                    value.fill(NaN, 0, 9);
                    break;
                default:
                    break;
            }
        }
        // in case of NaN, Infinity, we need to parse the string to the object itself
        if (type.elementType === "number" && typeof value[0] === "string") {
            value[0] = parseFloat(value[0]);
        }
        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };
    };
    InteractivityGraphToFlowGraphParser.prototype._parseEvents = function () {
        var _this = this;
        if (!this._interactivityGraph.events) {
            return;
        }
        var _loop_1 = function (event_1) {
            var converted = {
                eventId: event_1.id || "internalEvent_" + this_1._internalEventsCounter++,
            };
            if (event_1.values) {
                converted.eventData = Object.keys(event_1.values).map(function (key) {
                    var _a;
                    var eventValue = (_a = event_1.values) === null || _a === void 0 ? void 0 : _a[key];
                    if (!eventValue) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No value found for event key", key]);
                        throw new Error("Error parsing events");
                    }
                    var type = _this._types[eventValue.type];
                    if (!type) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No type found for event value", eventValue]);
                        throw new Error("Error parsing events");
                    }
                    var value = typeof eventValue.value !== "undefined" ? _this._parseVariable(eventValue) : undefined;
                    return {
                        id: key,
                        type: type.flowGraphType,
                        eventData: true,
                        value: value,
                    };
                });
            }
            this_1._events.push(converted);
        };
        var this_1 = this;
        for (var _i = 0, _a = this._interactivityGraph.events; _i < _a.length; _i++) {
            var event_1 = _a[_i];
            _loop_1(event_1);
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._parseNodes = function () {
        var _a;
        if (!this._interactivityGraph.nodes) {
            return;
        }
        for (var _i = 0, _b = this._interactivityGraph.nodes; _i < _b.length; _i++) {
            var node = _b[_i];
            // some validation
            if (typeof node.declaration !== "number") {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No declaration found for node", node]);
                throw new Error("Error parsing nodes");
            }
            var mapping = this._mappings[node.declaration];
            if (!mapping) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for node", node]);
                throw new Error("Error parsing nodes");
            }
            if (mapping.flowGraphMapping.validation) {
                var validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);
                if (!validationResult.valid) {
                    throw new Error("Error validating interactivity node ".concat((_a = this._interactivityGraph.declarations) === null || _a === void 0 ? void 0 : _a[node.declaration].op, " - ").concat(validationResult.error));
                }
            }
            var blocks = [];
            // create block(s) for this node using the mapping
            for (var _c = 0, _d = mapping.flowGraphMapping.blocks; _c < _d.length; _c++) {
                var blockType = _d[_c];
                var block = this._getEmptyBlock(blockType, mapping.fullOperationName);
                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);
                blocks.push(block);
            }
            this._nodes.push({ blocks: blocks, fullOperationName: mapping.fullOperationName });
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._getEmptyBlock = function (className, type) {
        var uniqueId = (0,babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.RandomGUID)();
        var dataInputs = [];
        var dataOutputs = [];
        var signalInputs = [];
        var signalOutputs = [];
        var config = {};
        var metadata = {};
        return {
            uniqueId: uniqueId,
            className: className,
            dataInputs: dataInputs,
            dataOutputs: dataOutputs,
            signalInputs: signalInputs,
            signalOutputs: signalOutputs,
            config: config,
            type: type,
            metadata: metadata,
        };
    };
    InteractivityGraphToFlowGraphParser.prototype._parseNodeConfiguration = function (node, block, nodeMapping, blockType) {
        var _a, _b;
        var configuration = block.config;
        if (node.configuration) {
            var keys = Object.keys(node.configuration);
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                var value = (_a = node.configuration) === null || _a === void 0 ? void 0 : _a[key];
                // value is always an array, never a number or string
                if (!value) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No value found for node configuration", key]);
                    throw new Error("Error parsing node configuration");
                }
                var configMapping = (_b = nodeMapping.configuration) === null || _b === void 0 ? void 0 : _b[key];
                var belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;
                if (belongsToBlock) {
                    // get the right name for the configuration key
                    var configKey = (configMapping === null || configMapping === void 0 ? void 0 : configMapping.name) || key;
                    if ((!value || typeof value.value === "undefined") && typeof (configMapping === null || configMapping === void 0 ? void 0 : configMapping.defaultValue) !== "undefined") {
                        configuration[configKey] = {
                            value: configMapping.defaultValue,
                        };
                    }
                    else if (value.value.length >= 0) {
                        // supporting int[] and int/boolean/string
                        configuration[configKey] = {
                            value: value.value.length === 1 ? value.value[0] : value.value,
                        };
                    }
                    else {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn(["Invalid value for node configuration", value]);
                    }
                    // make sure we transform the data if needed
                    if (configMapping && configMapping.dataTransformer) {
                        configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];
                    }
                }
            }
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._parseNodeConnections = function (context) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        for (var i = 0; i < this._nodes.length; i++) {
            // get the corresponding gltf node
            var gltfNode = (_a = this._interactivityGraph.nodes) === null || _a === void 0 ? void 0 : _a[i];
            if (!gltfNode) {
                // should never happen but let's still check
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No node found for interactivity node", this._nodes[i]]);
                throw new Error("Error parsing node connections");
            }
            var flowGraphBlocks = this._nodes[i];
            var outputMapper = this._mappings[gltfNode.declaration];
            // validate
            if (!outputMapper) {
                babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for node", gltfNode]);
                throw new Error("Error parsing node connections");
            }
            var flowsFromGLTF = gltfNode.flows || {};
            var flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys
            var _loop_2 = function (flowKey) {
                var flow = flowsFromGLTF[flowKey];
                var flowMapping = (_c = (_b = outputMapper.flowGraphMapping.outputs) === null || _b === void 0 ? void 0 : _b.flows) === null || _c === void 0 ? void 0 : _c[flowKey];
                var socketOutName = (flowMapping === null || flowMapping === void 0 ? void 0 : flowMapping.name) || flowKey;
                // create a serialized socket
                var socketOut = this_2._createNewSocketConnection(socketOutName, true);
                var block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find(function (b) { return b.className === flowMapping.toBlock; })) || flowGraphBlocks.blocks[0];
                block.signalOutputs.push(socketOut);
                // get the input node of this block
                var inputNodeId = flow.node;
                var nodeIn = this_2._nodes[inputNodeId];
                if (!nodeIn) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No node found for input node id", inputNodeId]);
                    throw new Error("Error parsing node connections");
                }
                // get the mapper for the input node - in case it mapped to multiple blocks
                var inputMapper = (0,_declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForFullOperationName)(nodeIn.fullOperationName);
                if (!inputMapper) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for input node", nodeIn]);
                    throw new Error("Error parsing node connections");
                }
                var flowInMapping = (_e = (_d = inputMapper.inputs) === null || _d === void 0 ? void 0 : _d.flows) === null || _e === void 0 ? void 0 : _e[flow.socket || "in"];
                var arrayMapping = false;
                if (!flowInMapping) {
                    for (var key in (_f = inputMapper.inputs) === null || _f === void 0 ? void 0 : _f.flows) {
                        if (key.startsWith("[") && key.endsWith("]")) {
                            arrayMapping = true;
                            flowInMapping = (_h = (_g = inputMapper.inputs) === null || _g === void 0 ? void 0 : _g.flows) === null || _h === void 0 ? void 0 : _h[key];
                        }
                    }
                }
                var nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace("$1", flow.socket || "") : flowInMapping.name) : flow.socket || "in";
                var inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find(function (b) { return b.className === flowInMapping.toBlock; })) || nodeIn.blocks[0];
                // in all of the flow graph input connections, find the one with the same name as the socket
                var socketIn = inputBlock.signalInputs.find(function (s) { return s.name === nodeInSocketName; });
                // if the socket doesn't exist, create the input socket for the connection
                if (!socketIn) {
                    socketIn = this_2._createNewSocketConnection(nodeInSocketName);
                    inputBlock.signalInputs.push(socketIn);
                }
                // connect the sockets
                socketIn.connectedPointIds.push(socketOut.uniqueId);
                socketOut.connectedPointIds.push(socketIn.uniqueId);
            };
            var this_2 = this;
            // connect the flows
            for (var _i = 0, flowsKeys_1 = flowsKeys; _i < flowsKeys_1.length; _i++) {
                var flowKey = flowsKeys_1[_i];
                _loop_2(flowKey);
            }
            // connect the values
            var valuesFromGLTF = gltfNode.values || {};
            var valuesKeys = Object.keys(valuesFromGLTF);
            var _loop_3 = function (valueKey) {
                var value = valuesFromGLTF[valueKey];
                var valueMapping = (_k = (_j = outputMapper.flowGraphMapping.inputs) === null || _j === void 0 ? void 0 : _j.values) === null || _k === void 0 ? void 0 : _k[valueKey];
                var arrayMapping = false;
                if (!valueMapping) {
                    for (var key in (_l = outputMapper.flowGraphMapping.inputs) === null || _l === void 0 ? void 0 : _l.values) {
                        if (key.startsWith("[") && key.endsWith("]")) {
                            arrayMapping = true;
                            valueMapping = (_o = (_m = outputMapper.flowGraphMapping.inputs) === null || _m === void 0 ? void 0 : _m.values) === null || _o === void 0 ? void 0 : _o[key];
                        }
                    }
                }
                var socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace("$1", valueKey) : valueMapping.name) : valueKey;
                // create a serialized socket
                var socketIn = this_3._createNewSocketConnection(socketInName);
                var block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find(function (b) { return b.className === valueMapping.toBlock; })) || flowGraphBlocks.blocks[0];
                block.dataInputs.push(socketIn);
                if (value.value !== undefined) {
                    var convertedValue = this_3._parseVariable(value, valueMapping && valueMapping.dataTransformer);
                    context._connectionValues[socketIn.uniqueId] = convertedValue;
                }
                else if (typeof value.node !== "undefined") {
                    var nodeOutId = value.node;
                    var nodeOutSocketName = value.socket || "value";
                    var nodeOut = this_3._nodes[nodeOutId];
                    if (!nodeOut) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No node found for output socket reference", value]);
                        throw new Error("Error parsing node connections");
                    }
                    var outputMapper_1 = (0,_declarationMapper__WEBPACK_IMPORTED_MODULE_0__.getMappingForFullOperationName)(nodeOut.fullOperationName);
                    if (!outputMapper_1) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No mapping found for output socket reference", value]);
                        throw new Error("Error parsing node connections");
                    }
                    var valueMapping_1 = (_q = (_p = outputMapper_1.outputs) === null || _p === void 0 ? void 0 : _p.values) === null || _q === void 0 ? void 0 : _q[nodeOutSocketName];
                    var arrayMapping_1 = false;
                    // check if there is an array mapping defined
                    if (!valueMapping_1) {
                        // search for a value mapping that has an array mapping
                        for (var key in (_r = outputMapper_1.outputs) === null || _r === void 0 ? void 0 : _r.values) {
                            if (key.startsWith("[") && key.endsWith("]")) {
                                arrayMapping_1 = true;
                                valueMapping_1 = (_t = (_s = outputMapper_1.outputs) === null || _s === void 0 ? void 0 : _s.values) === null || _t === void 0 ? void 0 : _t[key];
                            }
                        }
                    }
                    var socketOutName_1 = valueMapping_1 ? (arrayMapping_1 ? valueMapping_1.name.replace("$1", nodeOutSocketName) : valueMapping_1 === null || valueMapping_1 === void 0 ? void 0 : valueMapping_1.name) : nodeOutSocketName;
                    var outBlock = (valueMapping_1 && valueMapping_1.toBlock && nodeOut.blocks.find(function (b) { return b.className === valueMapping_1.toBlock; })) || nodeOut.blocks[0];
                    var socketOut = outBlock.dataOutputs.find(function (s) { return s.name === socketOutName_1; });
                    // if the socket doesn't exist, create it
                    if (!socketOut) {
                        socketOut = this_3._createNewSocketConnection(socketOutName_1, true);
                        outBlock.dataOutputs.push(socketOut);
                    }
                    // connect the sockets
                    socketIn.connectedPointIds.push(socketOut.uniqueId);
                    socketOut.connectedPointIds.push(socketIn.uniqueId);
                }
                else {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["Invalid value for value connection", value]);
                    throw new Error("Error parsing node connections");
                }
            };
            var this_3 = this;
            for (var _v = 0, valuesKeys_1 = valuesKeys; _v < valuesKeys_1.length; _v++) {
                var valueKey = valuesKeys_1[_v];
                _loop_3(valueKey);
            }
            // inter block connections
            if (outputMapper.flowGraphMapping.interBlockConnectors) {
                for (var _w = 0, _x = outputMapper.flowGraphMapping.interBlockConnectors; _w < _x.length; _w++) {
                    var connector = _x[_w];
                    var input = connector.input;
                    var output = connector.output;
                    var isVariable = connector.isVariable;
                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);
                }
            }
            if (outputMapper.flowGraphMapping.extraProcessor) {
                var declaration = (_u = this._interactivityGraph.declarations) === null || _u === void 0 ? void 0 : _u[gltfNode.declaration];
                if (!declaration) {
                    babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["No declaration found for extra processor", gltfNode]);
                    throw new Error("Error parsing node connections");
                }
                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(gltfNode, declaration, outputMapper.flowGraphMapping, this, flowGraphBlocks.blocks, context, this._gltf);
            }
        }
    };
    InteractivityGraphToFlowGraphParser.prototype._createNewSocketConnection = function (name, isOutput) {
        return {
            uniqueId: (0,babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.RandomGUID)(),
            name: name,
            _connectionType: isOutput ? 1 /* FlowGraphConnectionType.Output */ : 0 /* FlowGraphConnectionType.Input */,
            connectedPointIds: [],
        };
    };
    InteractivityGraphToFlowGraphParser.prototype._connectFlowGraphNodes = function (input, output, serializedInput, serializedOutput, isVariable) {
        var inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;
        var outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;
        var inputConnection = inputArray.find(function (s) { return s.name === input; }) || this._createNewSocketConnection(input);
        var outputConnection = outputArray.find(function (s) { return s.name === output; }) || this._createNewSocketConnection(output, true);
        // of not found add it to the array
        if (!inputArray.find(function (s) { return s.name === input; })) {
            inputArray.push(inputConnection);
        }
        if (!outputArray.find(function (s) { return s.name === output; })) {
            outputArray.push(outputConnection);
        }
        // connect the sockets
        inputConnection.connectedPointIds.push(outputConnection.uniqueId);
        outputConnection.connectedPointIds.push(inputConnection.uniqueId);
    };
    InteractivityGraphToFlowGraphParser.prototype.getVariableName = function (index) {
        return "staticVariable_" + index;
    };
    InteractivityGraphToFlowGraphParser.prototype.serializeToFlowGraph = function () {
        var context = {
            uniqueId: (0,babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.RandomGUID)(),
            _userVariables: {},
            _connectionValues: {},
        };
        this._parseNodeConnections(context);
        for (var i = 0; i < this._staticVariables.length; i++) {
            var variable = this._staticVariables[i];
            context._userVariables[this.getVariableName(i)] = variable;
        }
        var allBlocks = this._nodes.reduce(function (acc, val) { return acc.concat(val.blocks); }, []);
        return {
            rightHanded: true,
            allBlocks: allBlocks,
            executionContexts: [context],
        };
    };
    return InteractivityGraphToFlowGraphParser;
}());



/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts":
/*!***************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_lights: () => (/* binding */ KHR_lights)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Lights/light */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");









var NAME = "KHR_lights_punctual";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_lights = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_lights(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_lights.prototype.dispose = function () {
        this._loader = null;
        delete this._lights;
    };
    /** @internal */
    KHR_lights.prototype.onLoading = function () {
        var extensions = this._loader.gltf.extensions;
        if (extensions && extensions[this.name]) {
            var extension = extensions[this.name];
            this._lights = extension.lights;
            _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._lights);
        }
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_lights.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._loader._allMaterialsDirtyRequired = true;
                        return [4 /*yield*/, this._loader.loadNodeAsync(context, node, function (babylonMesh) {
                                var babylonLight;
                                var light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this._lights, extension.light);
                                var name = light.name || babylonMesh.name;
                                _this._loader.babylonScene._blockEntityCollection = !!_this._loader._assetContainer;
                                switch (light.type) {
                                    case "directional" /* KHRLightsPunctual_LightType.DIRECTIONAL */: {
                                        var babylonDirectionalLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), _this._loader.babylonScene);
                                        babylonDirectionalLight.position.setAll(0);
                                        babylonLight = babylonDirectionalLight;
                                        break;
                                    }
                                    case "point" /* KHRLightsPunctual_LightType.POINT */: {
                                        babylonLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.PointLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), _this._loader.babylonScene);
                                        break;
                                    }
                                    case "spot" /* KHRLightsPunctual_LightType.SPOT */: {
                                        var babylonSpotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), 0, 1, _this._loader.babylonScene);
                                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;
                                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;
                                        babylonLight = babylonSpotLight;
                                        break;
                                    }
                                    default: {
                                        _this._loader.babylonScene._blockEntityCollection = false;
                                        throw new Error("".concat(extensionContext, ": Invalid light type (").concat(light.type, ")"));
                                    }
                                }
                                babylonLight._parentContainer = _this._loader._assetContainer;
                                _this._loader.babylonScene._blockEntityCollection = false;
                                light._babylonLight = babylonLight;
                                babylonLight.falloffType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Light.FALLOFF_GLTF;
                                babylonLight.diffuse = light.color ? babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(light.color) : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;
                                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;
                                babylonLight.parent = babylonMesh;
                                _this._loader._babylonLights.push(babylonLight);
                                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);
                                assign(babylonMesh);
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return KHR_lights;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_lights(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts":
/*!********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_anisotropy: () => (/* binding */ KHR_materials_anisotropy)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_anisotropy";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_anisotropy = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_anisotropy(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 195;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_anisotropy.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_anisotropy.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
    };
    KHR_materials_anisotropy.prototype._loadIridescencePropertiesAsync = function (context, properties, babylonMaterial) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function () {
            var promises;
            var _a, _b;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(context, ": Material type not supported"));
                        }
                        promises = new Array();
                        babylonMaterial.anisotropy.isEnabled = true;
                        babylonMaterial.anisotropy.intensity = (_a = properties.anisotropyStrength) !== null && _a !== void 0 ? _a : 0;
                        babylonMaterial.anisotropy.angle = (_b = properties.anisotropyRotation) !== null && _b !== void 0 ? _b : 0;
                        if (properties.anisotropyTexture) {
                            properties.anisotropyTexture.nonColorData = true;
                            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/anisotropyTexture"), properties.anisotropyTexture, function (texture) {
                                texture.name = "".concat(babylonMaterial.name, " (Anisotropy Intensity)");
                                babylonMaterial.anisotropy.texture = texture;
                            }));
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _c.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return KHR_materials_anisotropy;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_anisotropy(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts":
/*!*******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_clearcoat: () => (/* binding */ KHR_materials_clearcoat)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_clearcoat";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)
 * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_clearcoat = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_clearcoat(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 190;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_clearcoat.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_clearcoat.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_clearcoat.prototype._loadClearCoatPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.clearCoat.isEnabled = true;
        babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;
        babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;
        if (properties.clearcoatFactor != undefined) {
            babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;
        }
        else {
            babylonMaterial.clearCoat.intensity = 0;
        }
        if (properties.clearcoatTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatTexture"), properties.clearcoatTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (ClearCoat)");
                babylonMaterial.clearCoat.texture = texture;
            }));
        }
        if (properties.clearcoatRoughnessFactor != undefined) {
            babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;
        }
        else {
            babylonMaterial.clearCoat.roughness = 0;
        }
        if (properties.clearcoatRoughnessTexture) {
            properties.clearcoatRoughnessTexture.nonColorData = true;
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatRoughnessTexture"), properties.clearcoatRoughnessTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (ClearCoat Roughness)");
                babylonMaterial.clearCoat.textureRoughness = texture;
            }));
        }
        if (properties.clearcoatNormalTexture) {
            properties.clearcoatNormalTexture.nonColorData = true;
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatNormalTexture"), properties.clearcoatNormalTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (ClearCoat Normal)");
                babylonMaterial.clearCoat.bumpTexture = texture;
            }));
            babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;
            babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;
            if (properties.clearcoatNormalTexture.scale != undefined) {
                babylonMaterial.clearCoat.bumpTexture.level = properties.clearcoatNormalTexture.scale;
            }
        }
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_clearcoat;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_clearcoat(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts":
/*!******************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_diffuse_transmission: () => (/* binding */ KHR_materials_diffuse_transmission)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Maths/math.color */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "KHR_materials_diffuse_transmission";
/**
 * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)
 * !!! Experimental Extension Subject to Changes !!!
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_diffuse_transmission = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_diffuse_transmission(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 174;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
        if (this.enabled) {
            loader.parent.transparencyAsCoverage = true;
        }
    }
    /** @internal */
    KHR_materials_diffuse_transmission.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_diffuse_transmission.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
    KHR_materials_diffuse_transmission.prototype._loadTranslucentPropertiesAsync = function (context, material, babylonMaterial, extension) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var pbrMaterial = babylonMaterial;
        // Enables "translucency" texture which represents diffusely-transmitted light.
        pbrMaterial.subSurface.isTranslucencyEnabled = true;
        // Since this extension models thin-surface transmission only, we must make the
        // internal IOR == 1.0 and set the thickness to 0.
        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;
        pbrMaterial.subSurface.minimumThickness = 0.0;
        pbrMaterial.subSurface.maximumThickness = 0.0;
        // Tint color will be used for transmission.
        pbrMaterial.subSurface.useAlbedoToTintTranslucency = false;
        if (extension.diffuseTransmissionFactor !== undefined) {
            pbrMaterial.subSurface.translucencyIntensity = extension.diffuseTransmissionFactor;
        }
        else {
            pbrMaterial.subSurface.translucencyIntensity = 0.0;
            pbrMaterial.subSurface.isTranslucencyEnabled = false;
            return Promise.resolve();
        }
        var promises = new Array();
        pbrMaterial.subSurface.useGltfStyleTextures = true;
        if (extension.diffuseTransmissionTexture) {
            extension.diffuseTransmissionTexture.nonColorData = true;
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTransmissionTexture"), extension.diffuseTransmissionTexture).then(function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Diffuse Transmission)");
                pbrMaterial.subSurface.translucencyIntensityTexture = texture;
            }));
        }
        if (extension.diffuseTransmissionColorFactor !== undefined) {
            pbrMaterial.subSurface.translucencyColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(extension.diffuseTransmissionColorFactor);
        }
        else {
            pbrMaterial.subSurface.translucencyColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
        }
        if (extension.diffuseTransmissionColorTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTransmissionColorTexture"), extension.diffuseTransmissionColorTexture).then(function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Diffuse Transmission Color)");
                pbrMaterial.subSurface.translucencyColorTexture = texture;
            }));
        }
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_diffuse_transmission;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_diffuse_transmission(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts":
/*!********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_dispersion: () => (/* binding */ KHR_materials_dispersion)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_dispersion";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/87bd64a7f5e23c84b6aef2e6082069583ed0ddb4/extensions/2.0/Khronos/KHR_materials_dispersion/README.md)
 * @experimental
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_dispersion = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_dispersion(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 174;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_dispersion.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_dispersion.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadDispersionPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_dispersion.prototype._loadDispersionPropertiesAsync = function (context, material, babylonMaterial, extension) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        // If transparency isn't enabled already, this extension shouldn't do anything.
        // i.e. it requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.
        if (!babylonMaterial.subSurface.isRefractionEnabled || !extension.dispersion) {
            return Promise.resolve();
        }
        babylonMaterial.subSurface.isDispersionEnabled = true;
        babylonMaterial.subSurface.dispersion = extension.dispersion;
        return Promise.resolve();
    };
    return KHR_materials_dispersion;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_dispersion(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts":
/*!***************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_emissive_strength: () => (/* binding */ KHR_materials_emissive_strength)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_emissive_strength";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_emissive_strength = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_emissive_strength(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 170;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_emissive_strength.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_emissive_strength.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(function () {
                            _this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);
                        })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    KHR_materials_emissive_strength.prototype._loadEmissiveProperties = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        if (properties.emissiveStrength !== undefined) {
            babylonMaterial.emissiveIntensity = properties.emissiveStrength;
        }
    };
    return KHR_materials_emissive_strength;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_emissive_strength(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts":
/*!*************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_ior: () => (/* binding */ KHR_materials_ior)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_ior";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_ior = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_ior(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 180;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_ior.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_ior.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_ior.prototype._loadIorPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        if (properties.ior !== undefined) {
            babylonMaterial.indexOfRefraction = properties.ior;
        }
        else {
            babylonMaterial.indexOfRefraction = KHR_materials_ior._DEFAULT_IOR;
        }
        return Promise.resolve();
    };
    /**
     * Default ior Value from the spec.
     */
    KHR_materials_ior._DEFAULT_IOR = 1.5;
    return KHR_materials_ior;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_ior(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts":
/*!*********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_iridescence: () => (/* binding */ KHR_materials_iridescence)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_iridescence";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_iridescence = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_iridescence(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 195;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_iridescence.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_iridescence.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_iridescence.prototype._loadIridescencePropertiesAsync = function (context, properties, babylonMaterial) {
        var _a, _b, _c, _d, _e;
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.iridescence.isEnabled = true;
        babylonMaterial.iridescence.intensity = (_a = properties.iridescenceFactor) !== null && _a !== void 0 ? _a : 0;
        babylonMaterial.iridescence.indexOfRefraction = (_c = (_b = properties.iridescenceIor) !== null && _b !== void 0 ? _b : properties.iridescenceIOR) !== null && _c !== void 0 ? _c : 1.3;
        babylonMaterial.iridescence.minimumThickness = (_d = properties.iridescenceThicknessMinimum) !== null && _d !== void 0 ? _d : 100;
        babylonMaterial.iridescence.maximumThickness = (_e = properties.iridescenceThicknessMaximum) !== null && _e !== void 0 ? _e : 400;
        if (properties.iridescenceTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/iridescenceTexture"), properties.iridescenceTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Iridescence)");
                babylonMaterial.iridescence.texture = texture;
            }));
        }
        if (properties.iridescenceThicknessTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/iridescenceThicknessTexture"), properties.iridescenceThicknessTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Iridescence Thickness)");
                babylonMaterial.iridescence.thicknessTexture = texture;
            }));
        }
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_iridescence;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_iridescence(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts":
/*!*******************************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_pbrSpecularGlossiness: () => (/* binding */ KHR_materials_pbrSpecularGlossiness)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "KHR_materials_pbrSpecularGlossiness";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_pbrSpecularGlossiness = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_pbrSpecularGlossiness(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 200;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_pbrSpecularGlossiness.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_pbrSpecularGlossiness.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, extension, babylonMaterial));
                        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_pbrSpecularGlossiness.prototype._loadSpecularGlossinessPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.metallic = null;
        babylonMaterial.roughness = null;
        if (properties.diffuseFactor) {
            babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.diffuseFactor);
            babylonMaterial.alpha = properties.diffuseFactor[3];
        }
        else {
            babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
        }
        babylonMaterial.reflectivityColor = properties.specularFactor ? babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.specularFactor) : babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;
        if (properties.diffuseTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTexture"), properties.diffuseTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Diffuse)");
                babylonMaterial.albedoTexture = texture;
            }));
        }
        if (properties.specularGlossinessTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularGlossinessTexture"), properties.specularGlossinessTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Specular Glossiness)");
                babylonMaterial.reflectivityTexture = texture;
                babylonMaterial.reflectivityTexture.hasAlpha = true;
            }));
            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;
        }
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_pbrSpecularGlossiness;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_pbrSpecularGlossiness(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts":
/*!***************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_sheen: () => (/* binding */ KHR_materials_sheen)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Maths/math.color */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "KHR_materials_sheen";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)
 * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_sheen = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_sheen(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 190;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_sheen.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_sheen.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_sheen.prototype._loadSheenPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.sheen.isEnabled = true;
        babylonMaterial.sheen.intensity = 1;
        if (properties.sheenColorFactor != undefined) {
            babylonMaterial.sheen.color = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.sheenColorFactor);
        }
        else {
            babylonMaterial.sheen.color = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.Black();
        }
        if (properties.sheenColorTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/sheenColorTexture"), properties.sheenColorTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Sheen Color)");
                babylonMaterial.sheen.texture = texture;
            }));
        }
        if (properties.sheenRoughnessFactor !== undefined) {
            babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;
        }
        else {
            babylonMaterial.sheen.roughness = 0;
        }
        if (properties.sheenRoughnessTexture) {
            properties.sheenRoughnessTexture.nonColorData = true;
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/sheenRoughnessTexture"), properties.sheenRoughnessTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Sheen Roughness)");
                babylonMaterial.sheen.textureRoughness = texture;
            }));
        }
        babylonMaterial.sheen.albedoScaling = true;
        babylonMaterial.sheen.useRoughnessFromMainTexture = false;
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_sheen;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_sheen(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts":
/*!******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_specular: () => (/* binding */ KHR_materials_specular)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Engines/constants */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");






var NAME = "KHR_materials_specular";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_specular = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_specular(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 190;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_specular.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_specular.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises, specularEdgeColorExtension;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));
                        // Handle the EXT_materials_specular_edge_color sub-extension
                        // https://github.com/KhronosGroup/glTF/blob/2a1111b88f052cbd3e2d82abb9faee56e7494904/extensions/2.0/Vendor/EXT_materials_specular_edge_color/README.md
                        if (extension.extensions && extension.extensions.EXT_materials_specular_edge_color && babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial) {
                            specularEdgeColorExtension = extension.extensions.EXT_materials_specular_edge_color;
                            if (specularEdgeColorExtension.specularEdgeColorEnabled) {
                                babylonMaterial.brdf.dielectricSpecularModel = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR;
                                babylonMaterial.brdf.conductorSpecularModel = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR;
                            }
                        }
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_specular.prototype._loadSpecularPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        if (properties.specularFactor !== undefined) {
            babylonMaterial.metallicF0Factor = properties.specularFactor;
        }
        if (properties.specularColorFactor !== undefined) {
            babylonMaterial.metallicReflectanceColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.specularColorFactor);
        }
        if (properties.specularTexture) {
            properties.specularTexture.nonColorData = true;
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularTexture"), properties.specularTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Specular)");
                babylonMaterial.metallicReflectanceTexture = texture;
                babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;
            }));
        }
        if (properties.specularColorTexture) {
            promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularColorTexture"), properties.specularColorTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Specular Color)");
                babylonMaterial.reflectanceTexture = texture;
            }));
        }
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_specular;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_specular(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts":
/*!**********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_transmission: () => (/* binding */ KHR_materials_transmission)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/tools */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");








/**
 * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.
 */
var TransmissionHelper = /** @class */ (function () {
    /**
     * constructor
     * @param options Defines the options we want to customize the helper
     * @param scene The scene to add the material to
     */
    function TransmissionHelper(options, scene) {
        var _this = this;
        this._opaqueRenderTarget = null;
        this._opaqueMeshesCache = [];
        this._transparentMeshesCache = [];
        this._materialObservers = {};
        this._options = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, TransmissionHelper._GetDefaultOptions()), options);
        this._scene = scene;
        this._scene._transmissionHelper = this;
        this.onErrorObservable = new babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Observable();
        this._scene.onDisposeObservable.addOnce(function () {
            _this.dispose();
        });
        this._parseScene();
        this._setupRenderTargets();
    }
    /**
     * Creates the default options for the helper.
     * @returns the default options
     */
    TransmissionHelper._GetDefaultOptions = function () {
        return {
            renderSize: 1024,
            samples: 4,
            lodGenerationScale: 1,
            lodGenerationOffset: -4,
            renderTargetTextureType: babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Constants.TEXTURETYPE_HALF_FLOAT,
            generateMipmaps: true,
        };
    };
    /**
     * Updates the background according to the new options
     * @param options
     */
    TransmissionHelper.prototype.updateOptions = function (options) {
        var _this = this;
        // First check if any options are actually being changed. If not, exit.
        var newValues = Object.keys(options).filter(function (key) { return _this._options[key] !== options[key]; });
        if (!newValues.length) {
            return;
        }
        var newOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this._options), options);
        var oldOptions = this._options;
        this._options = newOptions;
        // If size changes, recreate everything
        if (newOptions.renderSize !== oldOptions.renderSize ||
            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||
            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||
            !this._opaqueRenderTarget) {
            this._setupRenderTargets();
        }
        else {
            this._opaqueRenderTarget.samples = newOptions.samples;
            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;
            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;
        }
    };
    /**
     * @returns the opaque render target texture or null if not available.
     */
    TransmissionHelper.prototype.getOpaqueTarget = function () {
        return this._opaqueRenderTarget;
    };
    TransmissionHelper.prototype._shouldRenderAsTransmission = function (material) {
        if (!material) {
            return false;
        }
        if (material instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial && material.subSurface.isRefractionEnabled) {
            return true;
        }
        return false;
    };
    TransmissionHelper.prototype._addMesh = function (mesh) {
        var _this = this;
        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));
        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some
        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)
        babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Tools.SetImmediate(function () {
            if (_this._shouldRenderAsTransmission(mesh.material)) {
                mesh.material.refractionTexture = _this._opaqueRenderTarget;
                if (_this._transparentMeshesCache.indexOf(mesh) === -1) {
                    _this._transparentMeshesCache.push(mesh);
                }
            }
            else {
                if (_this._opaqueMeshesCache.indexOf(mesh) === -1) {
                    _this._opaqueMeshesCache.push(mesh);
                }
            }
        });
    };
    TransmissionHelper.prototype._removeMesh = function (mesh) {
        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);
        delete this._materialObservers[mesh.uniqueId];
        var idx = this._transparentMeshesCache.indexOf(mesh);
        if (idx !== -1) {
            this._transparentMeshesCache.splice(idx, 1);
        }
        idx = this._opaqueMeshesCache.indexOf(mesh);
        if (idx !== -1) {
            this._opaqueMeshesCache.splice(idx, 1);
        }
    };
    TransmissionHelper.prototype._parseScene = function () {
        this._scene.meshes.forEach(this._addMesh.bind(this));
        // Listen for when a mesh is added to the scene and add it to our cache lists.
        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));
        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.
        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
    };
    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.
    TransmissionHelper.prototype._onMeshMaterialChanged = function (mesh) {
        var transparentIdx = this._transparentMeshesCache.indexOf(mesh);
        var opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);
        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list
        var useTransmission = this._shouldRenderAsTransmission(mesh.material);
        if (useTransmission) {
            if (mesh.material instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial) {
                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;
            }
            if (opaqueIdx !== -1) {
                this._opaqueMeshesCache.splice(opaqueIdx, 1);
                this._transparentMeshesCache.push(mesh);
            }
            else if (transparentIdx === -1) {
                this._transparentMeshesCache.push(mesh);
            }
            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list
        }
        else {
            if (transparentIdx !== -1) {
                this._transparentMeshesCache.splice(transparentIdx, 1);
                this._opaqueMeshesCache.push(mesh);
            }
            else if (opaqueIdx === -1) {
                this._opaqueMeshesCache.push(mesh);
            }
        }
    };
    /**
     * @internal
     * Check if the opaque render target has not been disposed and can still be used.
     * @returns
     */
    TransmissionHelper.prototype._isRenderTargetValid = function () {
        var _a;
        return ((_a = this._opaqueRenderTarget) === null || _a === void 0 ? void 0 : _a.getInternalTexture()) !== null;
    };
    /**
     * @internal
     * Setup the render targets according to the specified options.
     */
    TransmissionHelper.prototype._setupRenderTargets = function () {
        var _this = this;
        var _a, _b;
        if (this._opaqueRenderTarget) {
            this._opaqueRenderTarget.dispose();
        }
        this._opaqueRenderTarget = new babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, this._options.generateMipmaps, undefined, this._options.renderTargetTextureType);
        this._opaqueRenderTarget.ignoreCameraViewport = true;
        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;
        this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();
        this._opaqueRenderTarget.gammaSpace = false;
        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;
        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;
        this._opaqueRenderTarget.samples = this._options.samples;
        this._opaqueRenderTarget.renderSprites = true;
        this._opaqueRenderTarget.renderParticles = true;
        this._opaqueRenderTarget.disableImageProcessing = true;
        var saveSceneEnvIntensity;
        this._opaqueRenderTarget.onBeforeBindObservable.add(function (opaqueRenderTarget) {
            saveSceneEnvIntensity = _this._scene.environmentIntensity;
            _this._scene.environmentIntensity = 1.0;
            if (!_this._options.clearColor) {
                _this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, _this._scene.getEngine().useExactSrgbConversions);
            }
            else {
                opaqueRenderTarget.clearColor.copyFrom(_this._options.clearColor);
            }
        });
        this._opaqueRenderTarget.onAfterUnbindObservable.add(function () {
            _this._scene.environmentIntensity = saveSceneEnvIntensity;
        });
        for (var _i = 0, _c = this._transparentMeshesCache; _i < _c.length; _i++) {
            var mesh = _c[_i];
            if (this._shouldRenderAsTransmission(mesh.material)) {
                mesh.material.refractionTexture = this._opaqueRenderTarget;
            }
        }
    };
    /**
     * Dispose all the elements created by the Helper.
     */
    TransmissionHelper.prototype.dispose = function () {
        this._scene._transmissionHelper = undefined;
        if (this._opaqueRenderTarget) {
            this._opaqueRenderTarget.dispose();
            this._opaqueRenderTarget = null;
        }
        this._transparentMeshesCache = [];
        this._opaqueMeshesCache = [];
    };
    return TransmissionHelper;
}());
var NAME = "KHR_materials_transmission";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_transmission = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_transmission(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 175;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
        if (this.enabled) {
            loader.parent.transparencyAsCoverage = true;
        }
    }
    /** @internal */
    KHR_materials_transmission.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_transmission.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
    KHR_materials_transmission.prototype._loadTransparentPropertiesAsync = function (context, material, babylonMaterial, extension) {
        var _a, _b;
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var pbrMaterial = babylonMaterial;
        // Enables "refraction" texture which represents transmitted light.
        pbrMaterial.subSurface.isRefractionEnabled = true;
        // Since this extension models thin-surface transmission only, we must make IOR = 1.0
        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;
        // Albedo colour will tint transmission.
        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;
        if (extension.transmissionFactor !== undefined) {
            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;
            var scene = pbrMaterial.getScene();
            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {
                new TransmissionHelper({}, pbrMaterial.getScene());
            }
            else if (pbrMaterial.subSurface.refractionIntensity && !((_a = scene._transmissionHelper) === null || _a === void 0 ? void 0 : _a._isRenderTargetValid())) {
                // If the render target is not valid, recreate it.
                (_b = scene._transmissionHelper) === null || _b === void 0 ? void 0 : _b._setupRenderTargets();
            }
        }
        else {
            pbrMaterial.subSurface.refractionIntensity = 0.0;
            pbrMaterial.subSurface.isRefractionEnabled = false;
            return Promise.resolve();
        }
        pbrMaterial.subSurface.minimumThickness = 0.0;
        pbrMaterial.subSurface.maximumThickness = 0.0;
        if (extension.transmissionTexture) {
            extension.transmissionTexture.nonColorData = true;
            // eslint-disable-next-line github/no-then
            return this._loader.loadTextureInfoAsync("".concat(context, "/transmissionTexture"), extension.transmissionTexture, undefined).then(function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Transmission)");
                pbrMaterial.subSurface.refractionIntensityTexture = texture;
                pbrMaterial.subSurface.useGltfStyleTextures = true;
            });
        }
        else {
            return Promise.resolve();
        }
    };
    return KHR_materials_transmission;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_transmission(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts":
/*!***************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_unlit: () => (/* binding */ KHR_materials_unlit)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "KHR_materials_unlit";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_unlit = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_unlit(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 210;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_unlit.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_unlit.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._loadUnlitPropertiesAsync(context, material, babylonMaterial)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_unlit.prototype._loadUnlitPropertiesAsync = function (context, material, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.unlit = true;
        var properties = material.pbrMetallicRoughness;
        if (properties) {
            if (properties.baseColorFactor) {
                babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.baseColorFactor);
                babylonMaterial.alpha = properties.baseColorFactor[3];
            }
            else {
                babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
            }
            if (properties.baseColorTexture) {
                promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/baseColorTexture"), properties.baseColorTexture, function (texture) {
                    texture.name = "".concat(babylonMaterial.name, " (Base Color)");
                    babylonMaterial.albedoTexture = texture;
                }));
            }
        }
        if (material.doubleSided) {
            babylonMaterial.backFaceCulling = false;
            babylonMaterial.twoSidedLighting = true;
        }
        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
        // eslint-disable-next-line github/no-then
        return Promise.all(promises).then(function () { });
    };
    return KHR_materials_unlit;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_unlit(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts":
/*!******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_variants: () => (/* binding */ KHR_materials_variants)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babylonjs/Meshes/mesh */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_variants";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_variants = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_variants(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_materials_variants.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * Gets the list of available variant names for this asset.
     * @param rootNode The glTF root node
     * @returns the list of all the variant names for this model
     */
    KHR_materials_variants.GetAvailableVariants = function (rootNode) {
        var extensionMetadata = this._GetExtensionMetadata(rootNode);
        if (!extensionMetadata) {
            return [];
        }
        return Object.keys(extensionMetadata.variants);
    };
    /**
     * Gets the list of available variant names for this asset.
     * @param rootNode The glTF root node
     * @returns the list of all the variant names for this model
     */
    KHR_materials_variants.prototype.getAvailableVariants = function (rootNode) {
        return KHR_materials_variants.GetAvailableVariants(rootNode);
    };
    /**
     * Select a variant given a variant name or a list of variant names.
     * @param rootNode The glTF root node
     * @param variantName The variant name(s) to select.
     */
    KHR_materials_variants.SelectVariant = function (rootNode, variantName) {
        var extensionMetadata = this._GetExtensionMetadata(rootNode);
        if (!extensionMetadata) {
            throw new Error("Cannot select variant on a glTF mesh that does not have the ".concat(NAME, " extension"));
        }
        var select = function (variantName) {
            var entries = extensionMetadata.variants[variantName];
            if (entries) {
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var entry = entries_1[_i];
                    entry.mesh.material = entry.material;
                }
            }
        };
        if (variantName instanceof Array) {
            for (var _i = 0, variantName_1 = variantName; _i < variantName_1.length; _i++) {
                var name_1 = variantName_1[_i];
                select(name_1);
            }
        }
        else {
            select(variantName);
        }
        extensionMetadata.lastSelected = variantName;
    };
    /**
     * Select a variant given a variant name or a list of variant names.
     * @param rootNode The glTF root node
     * @param variantName The variant name(s) to select.
     */
    KHR_materials_variants.prototype.selectVariant = function (rootNode, variantName) {
        KHR_materials_variants.SelectVariant(rootNode, variantName);
    };
    /**
     * Reset back to the original before selecting a variant.
     * @param rootNode The glTF root node
     */
    KHR_materials_variants.Reset = function (rootNode) {
        var extensionMetadata = this._GetExtensionMetadata(rootNode);
        if (!extensionMetadata) {
            throw new Error("Cannot reset on a glTF mesh that does not have the ".concat(NAME, " extension"));
        }
        for (var _i = 0, _a = extensionMetadata.original; _i < _a.length; _i++) {
            var entry = _a[_i];
            entry.mesh.material = entry.material;
        }
        extensionMetadata.lastSelected = null;
    };
    /**
     * Reset back to the original before selecting a variant.
     * @param rootNode The glTF root node
     */
    KHR_materials_variants.prototype.reset = function (rootNode) {
        KHR_materials_variants.Reset(rootNode);
    };
    /**
     * Gets the last selected variant name(s) or null if original.
     * @param rootNode The glTF root node
     * @returns The selected variant name(s).
     */
    KHR_materials_variants.GetLastSelectedVariant = function (rootNode) {
        var extensionMetadata = this._GetExtensionMetadata(rootNode);
        if (!extensionMetadata) {
            throw new Error("Cannot get the last selected variant on a glTF mesh that does not have the ".concat(NAME, " extension"));
        }
        return extensionMetadata.lastSelected;
    };
    /**
     * Gets the last selected variant name(s) or null if original.
     * @param rootNode The glTF root node
     * @returns The selected variant name(s).
     */
    KHR_materials_variants.prototype.getLastSelectedVariant = function (rootNode) {
        return KHR_materials_variants.GetLastSelectedVariant(rootNode);
    };
    KHR_materials_variants._GetExtensionMetadata = function (rootNode) {
        var _a, _b;
        return ((_b = (_a = rootNode === null || rootNode === void 0 ? void 0 : rootNode._internalMetadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME]) || null;
    };
    /** @internal */
    KHR_materials_variants.prototype.onLoading = function () {
        var extensions = this._loader.gltf.extensions;
        if (extensions && extensions[this.name]) {
            var extension = extensions[this.name];
            this._variants = extension.variants;
        }
    };
    /** @internal */
    KHR_materials_variants.prototype.onReady = function () {
        var _a;
        var rootNode = this._loader.rootBabylonMesh;
        if (rootNode) {
            var options = this._loader.parent.extensionOptions[NAME];
            if (options === null || options === void 0 ? void 0 : options.defaultVariant) {
                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);
            }
            (_a = options === null || options === void 0 ? void 0 : options.onLoaded) === null || _a === void 0 ? void 0 : _a.call(options, {
                get variants() {
                    return KHR_materials_variants.GetAvailableVariants(rootNode);
                },
                get selectedVariant() {
                    var lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);
                    if (!lastSelectedVariant) {
                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];
                    }
                    if (Array.isArray(lastSelectedVariant)) {
                        return lastSelectedVariant[0];
                    }
                    return lastSelectedVariant;
                },
                set selectedVariant(variantName) {
                    KHR_materials_variants.SelectVariant(rootNode, variantName);
                },
            });
        }
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_variants.prototype._loadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, function (babylonMesh) {
                            assign(babylonMesh);
                            if (babylonMesh instanceof babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
                                var babylonDrawMode = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader._GetDrawMode(context, primitive.mode);
                                var root_1 = _this._loader.rootBabylonMesh;
                                var metadata = root_1 ? (root_1._internalMetadata = root_1._internalMetadata || {}) : {};
                                var gltf = (metadata.gltf = metadata.gltf || {});
                                var extensionMetadata_1 = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });
                                // Store the original material.
                                extensionMetadata_1.original.push({ mesh: babylonMesh, material: babylonMesh.material });
                                var _loop_1 = function (mappingIndex) {
                                    var mapping = extension.mappings[mappingIndex];
                                    var material = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/mappings/").concat(mappingIndex, "/material"), _this._loader.gltf.materials, mapping.material);
                                    promises.push(_this._loader._loadMaterialAsync("#/materials/".concat(mapping.material), material, babylonMesh, babylonDrawMode, function (babylonMaterial) {
                                        var _loop_2 = function (mappingVariantIndex) {
                                            var variantIndex = mapping.variants[mappingVariantIndex];
                                            var variant = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("/extensions/".concat(NAME, "/variants/").concat(variantIndex), _this._variants, variantIndex);
                                            extensionMetadata_1.variants[variant.name] = extensionMetadata_1.variants[variant.name] || [];
                                            extensionMetadata_1.variants[variant.name].push({
                                                mesh: babylonMesh,
                                                material: babylonMaterial,
                                            });
                                            // Replace the target when original mesh is cloned
                                            babylonMesh.onClonedObservable.add(function (newOne) {
                                                var newMesh = newOne;
                                                var metadata = null;
                                                var newRoot = newMesh;
                                                // Find root to get medata
                                                do {
                                                    newRoot = newRoot.parent;
                                                    if (!newRoot) {
                                                        return;
                                                    }
                                                    metadata = KHR_materials_variants._GetExtensionMetadata(newRoot);
                                                } while (metadata === null);
                                                // Need to clone the metadata on the root (first time only)
                                                if (root_1 && metadata === KHR_materials_variants._GetExtensionMetadata(root_1)) {
                                                    // Copy main metadata
                                                    newRoot._internalMetadata = {};
                                                    for (var key in root_1._internalMetadata) {
                                                        newRoot._internalMetadata[key] = root_1._internalMetadata[key];
                                                    }
                                                    // Copy the gltf metadata
                                                    newRoot._internalMetadata.gltf = [];
                                                    for (var key in root_1._internalMetadata.gltf) {
                                                        newRoot._internalMetadata.gltf[key] = root_1._internalMetadata.gltf[key];
                                                    }
                                                    // Duplicate the extension specific metadata
                                                    newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };
                                                    for (var _i = 0, _a = metadata.original; _i < _a.length; _i++) {
                                                        var original = _a[_i];
                                                        newRoot._internalMetadata.gltf[NAME].original.push({
                                                            mesh: original.mesh,
                                                            material: original.material,
                                                        });
                                                    }
                                                    for (var key in metadata.variants) {
                                                        if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {
                                                            newRoot._internalMetadata.gltf[NAME].variants[key] = [];
                                                            for (var _b = 0, _c = metadata.variants[key]; _b < _c.length; _b++) {
                                                                var variantEntry = _c[_b];
                                                                newRoot._internalMetadata.gltf[NAME].variants[key].push({
                                                                    mesh: variantEntry.mesh,
                                                                    material: variantEntry.material,
                                                                });
                                                            }
                                                        }
                                                    }
                                                    metadata = newRoot._internalMetadata.gltf[NAME];
                                                }
                                                // Relocate
                                                for (var _d = 0, _e = metadata.original; _d < _e.length; _d++) {
                                                    var target = _e[_d];
                                                    if (target.mesh === babylonMesh) {
                                                        target.mesh = newMesh;
                                                    }
                                                }
                                                for (var _f = 0, _g = metadata.variants[variant.name]; _f < _g.length; _f++) {
                                                    var target = _g[_f];
                                                    if (target.mesh === babylonMesh) {
                                                        target.mesh = newMesh;
                                                    }
                                                }
                                            });
                                        };
                                        for (var mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {
                                            _loop_2(mappingVariantIndex);
                                        }
                                    }));
                                };
                                // For each mapping, look at the variants and make a new entry for them.
                                for (var mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {
                                    _loop_1(mappingIndex);
                                }
                            }
                        }));
                        return [4 /*yield*/, Promise.all(promises).then(function (_a) {
                                var babylonMesh = _a[0];
                                return babylonMesh;
                            })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return KHR_materials_variants;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_variants(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts":
/*!****************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_materials_volume: () => (/* binding */ KHR_materials_volume)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_materials_volume";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)
 * @since 5.0.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_materials_volume = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_materials_volume(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 173;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
        if (this.enabled) {
            // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh
            this._loader._disableInstancedMesh++;
        }
    }
    /** @internal */
    KHR_materials_volume.prototype.dispose = function () {
        if (this.enabled) {
            this._loader._disableInstancedMesh--;
        }
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_materials_volume.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    KHR_materials_volume.prototype._loadVolumePropertiesAsync = function (context, material, babylonMaterial, extension) {
        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        // If transparency isn't enabled already, this extension shouldn't do anything.
        // i.e. it requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.
        if ((!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled) || !extension.thicknessFactor) {
            return Promise.resolve();
        }
        // IOR in this extension only affects interior.
        babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;
        var attenuationDistance = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;
        babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;
        if (extension.attenuationColor !== undefined && extension.attenuationColor.length == 3) {
            babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);
        }
        babylonMaterial.subSurface.minimumThickness = 0.0;
        babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;
        babylonMaterial.subSurface.useThicknessAsDepth = true;
        if (extension.thicknessTexture) {
            extension.thicknessTexture.nonColorData = true;
            // eslint-disable-next-line github/no-then
            return this._loader.loadTextureInfoAsync("".concat(context, "/thicknessTexture"), extension.thicknessTexture).then(function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Thickness)");
                babylonMaterial.subSurface.thicknessTexture = texture;
                babylonMaterial.subSurface.useGltfStyleTextures = true;
            });
        }
        else {
            return Promise.resolve();
        }
    };
    return KHR_materials_volume;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_materials_volume(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts":
/*!*****************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_mesh_quantization: () => (/* binding */ KHR_mesh_quantization)
/* harmony export */ });
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");

var NAME = "KHR_mesh_quantization";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_mesh_quantization = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_mesh_quantization(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_mesh_quantization.prototype.dispose = function () { };
    return KHR_mesh_quantization;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_mesh_quantization(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts":
/*!*****************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_node_hoverability: () => (/* binding */ KHR_node_hoverability)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KHR_interactivity/declarationMapper */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts");
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");




var NAME = "KHR_node_hoverability";
// interactivity
var MeshPointerOverPrefix = "targetMeshPointerOver_";
(0,_KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__.addNewInteractivityFlowGraphMapping)("event/onHoverIn", NAME, {
    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
    blocks: ["FlowGraphPointerOverEventBlock" /* FlowGraphBlockNames.PointerOverEvent */, "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */, "FlowGraphIndexOfBlock" /* FlowGraphBlockNames.IndexOf */, "KHR_interactivity/FlowGraphGLTFDataProvider"],
    configuration: {
        stopPropagation: { name: "stopPropagation" },
        nodeIndex: {
            name: "variable",
            toBlock: "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */,
            dataTransformer: function (data) {
                return [MeshPointerOverPrefix + data[0]];
            },
        },
    },
    outputs: {
        values: {
            hoverNodeIndex: { name: "index", toBlock: "FlowGraphIndexOfBlock" /* FlowGraphBlockNames.IndexOf */ },
            controllerIndex: { name: "pointerId" },
        },
        flows: {
            out: { name: "done" },
        },
    },
    interBlockConnectors: [
        {
            input: "targetMesh",
            output: "value",
            inputBlockIndex: 0,
            outputBlockIndex: 1,
            isVariable: true,
        },
        {
            input: "array",
            output: "nodes",
            inputBlockIndex: 2,
            outputBlockIndex: 3,
            isVariable: true,
        },
        {
            input: "object",
            output: "meshUnderPointer",
            inputBlockIndex: 2,
            outputBlockIndex: 0,
            isVariable: true,
        },
    ],
    extraProcessor: function (gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
        var _a, _b, _c, _d, _e, _f;
        // add the glTF to the configuration of the last serialized object
        var serializedObject = serializedObjects[serializedObjects.length - 1];
        serializedObject.config = serializedObject.config || {};
        serializedObject.config.glTF = globalGLTF;
        // find the listener nodeIndex value
        var nodeIndex = (_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a["nodeIndex"]) === null || _b === void 0 ? void 0 : _b.value[0];
        if (nodeIndex === undefined || typeof nodeIndex !== "number") {
            throw new Error("nodeIndex not found in configuration");
        }
        var variableName = MeshPointerOverPrefix + nodeIndex;
        // find the nodeIndex value
        serializedObjects[1].config.variable = variableName;
        context._userVariables[variableName] = {
            className: "Mesh",
            id: (_d = (_c = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _c === void 0 ? void 0 : _c[nodeIndex]._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.id,
            uniqueId: (_f = (_e = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _e === void 0 ? void 0 : _e[nodeIndex]._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.uniqueId,
        };
        return serializedObjects;
    },
});
var MeshPointerOutPrefix = "targetMeshPointerOut_";
(0,_KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__.addNewInteractivityFlowGraphMapping)("event/onHoverOut", NAME, {
    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
    blocks: ["FlowGraphPointerOutEventBlock" /* FlowGraphBlockNames.PointerOutEvent */, "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */, "FlowGraphIndexOfBlock" /* FlowGraphBlockNames.IndexOf */, "KHR_interactivity/FlowGraphGLTFDataProvider"],
    configuration: {
        stopPropagation: { name: "stopPropagation" },
        nodeIndex: {
            name: "variable",
            toBlock: "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */,
            dataTransformer: function (data) {
                return [MeshPointerOutPrefix + data[0]];
            },
        },
    },
    outputs: {
        values: {
            hoverNodeIndex: { name: "index", toBlock: "FlowGraphIndexOfBlock" /* FlowGraphBlockNames.IndexOf */ },
            controllerIndex: { name: "pointerId" },
        },
        flows: {
            out: { name: "done" },
        },
    },
    interBlockConnectors: [
        {
            input: "targetMesh",
            output: "value",
            inputBlockIndex: 0,
            outputBlockIndex: 1,
            isVariable: true,
        },
        {
            input: "array",
            output: "nodes",
            inputBlockIndex: 2,
            outputBlockIndex: 3,
            isVariable: true,
        },
        {
            input: "object",
            output: "meshOutOfPointer",
            inputBlockIndex: 2,
            outputBlockIndex: 0,
            isVariable: true,
        },
    ],
    extraProcessor: function (gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
        var _a, _b, _c, _d, _e, _f;
        // add the glTF to the configuration of the last serialized object
        var serializedObject = serializedObjects[serializedObjects.length - 1];
        serializedObject.config = serializedObject.config || {};
        serializedObject.config.glTF = globalGLTF;
        var nodeIndex = (_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a["nodeIndex"]) === null || _b === void 0 ? void 0 : _b.value[0];
        if (nodeIndex === undefined || typeof nodeIndex !== "number") {
            throw new Error("nodeIndex not found in configuration");
        }
        var variableName = MeshPointerOutPrefix + nodeIndex;
        // find the nodeIndex value
        serializedObjects[1].config.variable = variableName;
        context._userVariables[variableName] = {
            className: "Mesh",
            id: (_d = (_c = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _c === void 0 ? void 0 : _c[nodeIndex]._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.id,
            uniqueId: (_f = (_e = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _e === void 0 ? void 0 : _e[nodeIndex]._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.uniqueId,
        };
        return serializedObjects;
    },
});
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/nodes/{}/extensions/KHR_node_hoverability/hoverable", {
    get: function (node) {
        var tn = node._babylonTransformNode;
        if (tn && tn.pointerOverDisableMeshTesting !== undefined) {
            return tn.pointerOverDisableMeshTesting;
        }
        return true;
    },
    set: function (value, node) {
        var _a;
        (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function (mesh) {
            mesh.pointerOverDisableMeshTesting = !value;
        });
    },
    getTarget: function (node) { return node._babylonTransformNode; },
    getPropertyName: [function () { return "pointerOverDisableMeshTesting"; }],
    type: "boolean",
});
/**
 * Loader extension for KHR_node_hoverability
 * @see https://github.com/KhronosGroup/glTF/pull/2426
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_node_hoverability = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_node_hoverability(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises
    KHR_node_hoverability.prototype.onReady = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function () {
            var _a;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_b) {
                (_a = this._loader.gltf.nodes) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {
                    var _a, _b, _c;
                    // default is true, so only apply if false
                    if (((_a = node.extensions) === null || _a === void 0 ? void 0 : _a.KHR_node_hoverability) && ((_b = node.extensions) === null || _b === void 0 ? void 0 : _b.KHR_node_hoverability.hoverable) === false) {
                        (_c = node._babylonTransformNode) === null || _c === void 0 ? void 0 : _c.getChildMeshes().forEach(function (mesh) {
                            mesh.pointerOverDisableMeshTesting = true;
                        });
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    KHR_node_hoverability.prototype.dispose = function () {
        this._loader = null;
    };
    return KHR_node_hoverability;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_node_hoverability(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts":
/*!******************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_node_selectability: () => (/* binding */ KHR_node_selectability)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KHR_interactivity/declarationMapper */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts");
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");




var NAME = "KHR_node_selectability";
// add the interactivity mapping for the onSelect event
(0,_KHR_interactivity_declarationMapper__WEBPACK_IMPORTED_MODULE_1__.addNewInteractivityFlowGraphMapping)("event/onSelect", NAME, {
    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
    blocks: ["FlowGraphMeshPickEventBlock" /* FlowGraphBlockNames.MeshPickEvent */, "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */, "FlowGraphIndexOfBlock" /* FlowGraphBlockNames.IndexOf */, "KHR_interactivity/FlowGraphGLTFDataProvider"],
    configuration: {
        stopPropagation: { name: "stopPropagation" },
        nodeIndex: {
            name: "variable",
            toBlock: "FlowGraphGetVariableBlock" /* FlowGraphBlockNames.GetVariable */,
            dataTransformer: function (data) {
                return ["pickedMesh_" + data[0]];
            },
        },
    },
    outputs: {
        values: {
            selectedNodeIndex: { name: "index", toBlock: "FlowGraphIndexOfBlock" /* FlowGraphBlockNames.IndexOf */ },
            controllerIndex: { name: "pointerId" },
            selectionPoint: { name: "pickedPoint" },
            selectionRayOrigin: { name: "pickOrigin" },
        },
        flows: {
            out: { name: "done" },
        },
    },
    interBlockConnectors: [
        {
            input: "asset",
            output: "value",
            inputBlockIndex: 0,
            outputBlockIndex: 1,
            isVariable: true,
        },
        {
            input: "array",
            output: "nodes",
            inputBlockIndex: 2,
            outputBlockIndex: 3,
            isVariable: true,
        },
        {
            input: "object",
            output: "pickedMesh",
            inputBlockIndex: 2,
            outputBlockIndex: 0,
            isVariable: true,
        },
    ],
    extraProcessor: function (gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
        var _a, _b, _c, _d, _e, _f;
        // add the glTF to the configuration of the last serialized object
        var serializedObject = serializedObjects[serializedObjects.length - 1];
        serializedObject.config = serializedObject.config || {};
        serializedObject.config.glTF = globalGLTF;
        // find the listener nodeIndex value
        var nodeIndex = (_b = (_a = gltfBlock.configuration) === null || _a === void 0 ? void 0 : _a["nodeIndex"]) === null || _b === void 0 ? void 0 : _b.value[0];
        if (nodeIndex === undefined || typeof nodeIndex !== "number") {
            throw new Error("nodeIndex not found in configuration");
        }
        var variableName = "pickedMesh_" + nodeIndex;
        // find the nodeIndex value
        serializedObjects[1].config.variable = variableName;
        context._userVariables[variableName] = {
            className: "Mesh",
            id: (_d = (_c = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _c === void 0 ? void 0 : _c[nodeIndex]._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.id,
            uniqueId: (_f = (_e = globalGLTF === null || globalGLTF === void 0 ? void 0 : globalGLTF.nodes) === null || _e === void 0 ? void 0 : _e[nodeIndex]._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.uniqueId,
        };
        return serializedObjects;
    },
});
// object model extension for selectable
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_2__.AddObjectAccessorToKey)("/nodes/{}/extensions/KHR_node_selectability/selectable", {
    get: function (node) {
        var tn = node._babylonTransformNode;
        if (tn && tn.isPickable !== undefined) {
            return tn.isPickable;
        }
        return true;
    },
    set: function (value, node) {
        var _a;
        (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function (mesh) {
            mesh.isPickable = value;
        });
    },
    getTarget: function (node) { return node._babylonTransformNode; },
    getPropertyName: [function () { return "isPickable"; }],
    type: "boolean",
});
/**
 * Loader extension for KHR_selectability
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_node_selectability = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_node_selectability(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises
    KHR_node_selectability.prototype.onReady = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function () {
            var _a;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_b) {
                (_a = this._loader.gltf.nodes) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {
                    var _a, _b, _c;
                    if (((_a = node.extensions) === null || _a === void 0 ? void 0 : _a.KHR_node_selectability) && ((_b = node.extensions) === null || _b === void 0 ? void 0 : _b.KHR_node_selectability.selectable) === false) {
                        (_c = node._babylonTransformNode) === null || _c === void 0 ? void 0 : _c.getChildMeshes().forEach(function (mesh) {
                            mesh.isPickable = false;
                        });
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    KHR_node_selectability.prototype.dispose = function () {
        this._loader = null;
    };
    return KHR_node_selectability;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_node_selectability(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts":
/*!***************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_node_visibility: () => (/* binding */ KHR_node_visibility)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");



var NAME = "KHR_node_visibility";
// object model extension for visibility
(0,_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.AddObjectAccessorToKey)("/nodes/{}/extensions/KHR_node_visibility/visible", {
    get: function (node) {
        var tn = node._babylonTransformNode;
        if (tn && tn.isVisible !== undefined) {
            return tn.isVisible;
        }
        return true;
    },
    set: function (value, node) {
        var _a, _b;
        (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function (mesh) {
            mesh.inheritVisibility = true;
        });
        if (node._babylonTransformNode) {
            node._babylonTransformNode.isVisible = value;
        }
        (_b = node._primitiveBabylonMeshes) === null || _b === void 0 ? void 0 : _b.forEach(function (mesh) {
            mesh.isVisible = value;
        });
    },
    getTarget: function (node) { return node._babylonTransformNode; },
    getPropertyName: [function () { return "isVisible"; }],
    type: "boolean",
});
/**
 * Loader extension for KHR_node_visibility
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_node_visibility = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_node_visibility(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises
    KHR_node_visibility.prototype.onReady = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function () {
            var _a;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_b) {
                (_a = this._loader.gltf.nodes) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {
                    var _a, _b, _c, _d;
                    (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a.forEach(function (mesh) {
                        mesh.inheritVisibility = true;
                    });
                    // When the JSON Pointer is used we need to change both the transform node and the primitive meshes to the new value.
                    if ((_b = node.extensions) === null || _b === void 0 ? void 0 : _b.KHR_node_visibility) {
                        if (((_c = node.extensions) === null || _c === void 0 ? void 0 : _c.KHR_node_visibility.visible) === false) {
                            if (node._babylonTransformNode) {
                                node._babylonTransformNode.isVisible = false;
                            }
                            (_d = node._primitiveBabylonMeshes) === null || _d === void 0 ? void 0 : _d.forEach(function (mesh) {
                                mesh.isVisible = false;
                            });
                        }
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    KHR_node_visibility.prototype.dispose = function () {
        this._loader = null;
    };
    return KHR_node_visibility;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_node_visibility(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts":
/*!**************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_texture_basisu: () => (/* binding */ KHR_texture_basisu)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");



var NAME = "KHR_texture_basisu";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_texture_basisu = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_texture_basisu(loader) {
        /** The name of this extension. */
        this.name = NAME;
        this._loader = loader;
        this.enabled = loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_texture_basisu.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_texture_basisu.prototype._loadTextureAsync = function (context, texture, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(_this, void 0, void 0, function () {
            var sampler, image;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sampler = texture.sampler == undefined ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), this._loader.gltf.samplers, texture.sampler);
                        image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), this._loader.gltf.images, extension.source);
                        return [4 /*yield*/, this._loader._createTextureAsync(context, sampler, image, function (babylonTexture) {
                                assign(babylonTexture);
                            }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : undefined, !texture._textureInfo.nonColorData)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return KHR_texture_basisu;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_1__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_texture_basisu(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts":
/*!*****************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_texture_transform: () => (/* binding */ KHR_texture_transform)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/Textures/texture */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "KHR_texture_transform";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_texture_transform = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_texture_transform(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_texture_transform.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    KHR_texture_transform.prototype.loadTextureInfoAsync = function (context, textureInfo, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, textureInfo, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._loader.loadTextureInfoAsync(context, textureInfo, function (babylonTexture) {
                            if (!(babylonTexture instanceof babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__.Texture)) {
                                throw new Error("".concat(extensionContext, ": Texture type not supported"));
                            }
                            if (extension.offset) {
                                babylonTexture.uOffset = extension.offset[0];
                                babylonTexture.vOffset = extension.offset[1];
                            }
                            // Always rotate around the origin.
                            babylonTexture.uRotationCenter = 0;
                            babylonTexture.vRotationCenter = 0;
                            if (extension.rotation) {
                                babylonTexture.wAng = -extension.rotation;
                            }
                            if (extension.scale) {
                                babylonTexture.uScale = extension.scale[0];
                                babylonTexture.vScale = extension.scale[1];
                            }
                            if (extension.texCoord != undefined) {
                                babylonTexture.coordinatesIndex = extension.texCoord;
                            }
                            assign(babylonTexture);
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    return KHR_texture_transform;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_texture_transform(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts":
/*!***********************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KHR_xmp_json_ld: () => (/* binding */ KHR_xmp_json_ld)
/* harmony export */ });
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");

var NAME = "KHR_xmp_json_ld";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/README.md)
 * @since 5.0.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_xmp_json_ld = /** @class */ (function () {
    /**
     * @internal
     */
    function KHR_xmp_json_ld(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 100;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    KHR_xmp_json_ld.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * Called after the loader state changes to LOADING.
     */
    KHR_xmp_json_ld.prototype.onLoading = function () {
        var _a, _b, _c;
        if (this._loader.rootBabylonMesh === null) {
            return;
        }
        var xmpGltf = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_xmp_json_ld;
        var xmpNode = (_c = (_b = this._loader.gltf.asset) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.KHR_xmp_json_ld;
        if (xmpGltf && xmpNode) {
            var packet = +xmpNode.packet;
            if (xmpGltf.packets && packet < xmpGltf.packets.length) {
                this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};
                this._loader.rootBabylonMesh.metadata.xmp = xmpGltf.packets[packet];
            }
        }
    };
    return KHR_xmp_json_ld;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_0__.registerGLTFExtension)(NAME, true, function (loader) { return new KHR_xmp_json_ld(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts":
/*!**************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MSFT_audio_emitter: () => (/* binding */ MSFT_audio_emitter)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Audio/audioSceneComponent */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");









var NAME = "MSFT_audio_emitter";
/**
 * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)
 * !!! Experimental Extension Subject to Changes !!!
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var MSFT_audio_emitter = /** @class */ (function () {
    /**
     * @internal
     */
    function MSFT_audio_emitter(loader) {
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    MSFT_audio_emitter.prototype.dispose = function () {
        this._loader = null;
        this._clips = null;
        this._emitters = null;
    };
    /** @internal */
    MSFT_audio_emitter.prototype.onLoading = function () {
        var extensions = this._loader.gltf.extensions;
        if (extensions && extensions[this.name]) {
            var extension = extensions[this.name];
            this._clips = extension.clips;
            this._emitters = extension.emitters;
            _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._clips);
            _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._emitters);
        }
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_audio_emitter.prototype.loadSceneAsync = function (context, scene) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises, _i, _a, emitterIndex, emitter;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        promises = new Array();
                        promises.push(this._loader.loadSceneAsync(context, scene));
                        for (_i = 0, _a = extension.emitters; _i < _a.length; _i++) {
                            emitterIndex = _a[_i];
                            emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/emitters"), this._emitters, emitterIndex);
                            if (emitter.refDistance != undefined ||
                                emitter.maxDistance != undefined ||
                                emitter.rolloffFactor != undefined ||
                                emitter.distanceModel != undefined ||
                                emitter.innerAngle != undefined ||
                                emitter.outerAngle != undefined) {
                                throw new Error("".concat(extensionContext, ": Direction or Distance properties are not allowed on emitters attached to a scene"));
                            }
                            promises.push(this._loadEmitterAsync("".concat(extensionContext, "/emitters/").concat(emitter.index), emitter));
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_audio_emitter.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promises, babylonMesh;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        return [4 /*yield*/, this._loader.loadNodeAsync(extensionContext, node, function (babylonMesh) {
                                var _loop_1 = function (emitterIndex) {
                                    var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/emitters"), _this._emitters, emitterIndex);
                                    promises.push(
                                    // eslint-disable-next-line github/no-then
                                    _this._loadEmitterAsync("".concat(extensionContext, "/emitters/").concat(emitter.index), emitter).then(function () {
                                        for (var _i = 0, _a = emitter._babylonSounds; _i < _a.length; _i++) {
                                            var sound = _a[_i];
                                            sound.attachToMesh(babylonMesh);
                                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {
                                                sound.setLocalDirectionToMesh(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Forward());
                                                sound.setDirectionalCone(2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);
                                            }
                                        }
                                    }));
                                };
                                for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
                                    var emitterIndex = _a[_i];
                                    _loop_1(emitterIndex);
                                }
                                assign(babylonMesh);
                            })];
                    case 1:
                        babylonMesh = _a.sent();
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, babylonMesh];
                }
            });
        }); });
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_audio_emitter.prototype.loadAnimationAsync = function (context, animation) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, animation, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var babylonAnimationGroup, promises, _i, _a, event_1;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._loader.loadAnimationAsync(context, animation)];
                    case 1:
                        babylonAnimationGroup = _b.sent();
                        promises = new Array();
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(extension.events);
                        for (_i = 0, _a = extension.events; _i < _a.length; _i++) {
                            event_1 = _a[_i];
                            promises.push(this._loadAnimationEventAsync("".concat(extensionContext, "/events/").concat(event_1.index), context, animation, event_1, babylonAnimationGroup));
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, babylonAnimationGroup];
                }
            });
        }); });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    MSFT_audio_emitter.prototype._loadClipAsync = function (context, clip) {
        if (clip._objectURL) {
            return clip._objectURL;
        }
        var promise;
        if (clip.uri) {
            promise = this._loader.loadUriAsync(context, clip, clip.uri);
        }
        else {
            var bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/bufferView"), this._loader.gltf.bufferViews, clip.bufferView);
            promise = this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView);
        }
        // eslint-disable-next-line github/no-then
        clip._objectURL = promise.then(function (data) {
            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));
        });
        return clip._objectURL;
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    MSFT_audio_emitter.prototype._loadEmitterAsync = function (context, emitter) {
        var _this = this;
        emitter._babylonSounds = emitter._babylonSounds || [];
        if (!emitter._babylonData) {
            var clipPromises = new Array();
            var name_1 = emitter.name || "emitter".concat(emitter.index);
            var options_1 = {
                loop: false,
                autoplay: false,
                volume: emitter.volume == undefined ? 1 : emitter.volume,
            };
            var _loop_2 = function (i) {
                var clipContext = "/extensions/".concat(this_1.name, "/clips");
                var clip = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i].clip);
                clipPromises.push(
                // eslint-disable-next-line github/no-then
                this_1._loadClipAsync("".concat(clipContext, "/").concat(emitter.clips[i].clip), clip).then(function (objectURL) {
                    var sound = (emitter._babylonSounds[i] = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1));
                    sound.refDistance = emitter.refDistance || 1;
                    sound.maxDistance = emitter.maxDistance || 256;
                    sound.rolloffFactor = emitter.rolloffFactor || 1;
                    sound.distanceModel = emitter.distanceModel || "exponential";
                }));
            };
            var this_1 = this;
            for (var i = 0; i < emitter.clips.length; i++) {
                _loop_2(i);
            }
            // eslint-disable-next-line github/no-then
            var promise = Promise.all(clipPromises).then(function () {
                var weights = emitter.clips.map(function (clip) {
                    return clip.weight || 1;
                });
                var weightedSound = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);
                if (emitter.innerAngle) {
                    weightedSound.directionalConeInnerAngle = 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.innerAngle);
                }
                if (emitter.outerAngle) {
                    weightedSound.directionalConeOuterAngle = 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.outerAngle);
                }
                if (emitter.volume) {
                    weightedSound.volume = emitter.volume;
                }
                emitter._babylonData.sound = weightedSound;
            });
            emitter._babylonData = {
                loaded: promise,
            };
        }
        return emitter._babylonData.loaded;
    };
    MSFT_audio_emitter.prototype._getEventAction = function (context, sound, action, time, startOffset) {
        switch (action) {
            case "play" /* IMSFTAudioEmitter_AnimationEventAction.play */: {
                return function (currentFrame) {
                    var frameOffset = (startOffset || 0) + (currentFrame - time);
                    sound.play(frameOffset);
                };
            }
            case "stop" /* IMSFTAudioEmitter_AnimationEventAction.stop */: {
                return function () {
                    sound.stop();
                };
            }
            case "pause" /* IMSFTAudioEmitter_AnimationEventAction.pause */: {
                return function () {
                    sound.pause();
                };
            }
            default: {
                throw new Error("".concat(context, ": Unsupported action ").concat(action));
            }
        }
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    MSFT_audio_emitter.prototype._loadAnimationEventAsync = function (context, animationContext, animation, event, babylonAnimationGroup) {
        var _this = this;
        if (babylonAnimationGroup.targetedAnimations.length == 0) {
            return Promise.resolve();
        }
        var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];
        var emitterIndex = event.emitter;
        var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("/extensions/".concat(this.name, "/emitters"), this._emitters, emitterIndex);
        // eslint-disable-next-line github/no-then
        return this._loadEmitterAsync(context, emitter).then(function () {
            var sound = emitter._babylonData.sound;
            if (sound) {
                var babylonAnimationEvent = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));
                babylonAnimation.animation.addEvent(babylonAnimationEvent);
                // Make sure all started audio stops when this animation is terminated.
                babylonAnimationGroup.onAnimationGroupEndObservable.add(function () {
                    sound.stop();
                });
                babylonAnimationGroup.onAnimationGroupPauseObservable.add(function () {
                    sound.pause();
                });
            }
        });
    };
    return MSFT_audio_emitter;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new MSFT_audio_emitter(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts":
/*!****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MSFT_lod: () => (/* binding */ MSFT_lod)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/deferred */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");





var NAME = "MSFT_lod";
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var MSFT_lod = /** @class */ (function () {
    /**
     * @internal
     */
    function MSFT_lod(loader) {
        var _a, _b;
        /**
         * The name of this extension.
         */
        this.name = NAME;
        /**
         * Defines a number that determines the order the extensions are applied.
         */
        this.order = 100;
        /**
         * Maximum number of LODs to load, starting from the lowest LOD.
         */
        this.maxLODsToLoad = 10;
        /**
         * Observable raised when all node LODs of one level are loaded.
         * The event data is the index of the loaded LOD starting from zero.
         * Dispose the loader to cancel the loading of the next level of LODs.
         */
        this.onNodeLODsLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when all material LODs of one level are loaded.
         * The event data is the index of the loaded LOD starting from zero.
         * Dispose the loader to cancel the loading of the next level of LODs.
         */
        this.onMaterialLODsLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        this._bufferLODs = new Array();
        this._nodeIndexLOD = null;
        this._nodeSignalLODs = new Array();
        this._nodePromiseLODs = new Array();
        this._nodeBufferLODs = new Array();
        this._materialIndexLOD = null;
        this._materialSignalLODs = new Array();
        this._materialPromiseLODs = new Array();
        this._materialBufferLODs = new Array();
        this._loader = loader;
        // Options takes precedence. The maxLODsToLoad extension property is retained for back compat.
        // For new extensions, they should only use options.
        this.maxLODsToLoad = (_b = (_a = this._loader.parent.extensionOptions[NAME]) === null || _a === void 0 ? void 0 : _a.maxLODsToLoad) !== null && _b !== void 0 ? _b : this.maxLODsToLoad;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    MSFT_lod.prototype.dispose = function () {
        this._loader = null;
        this._nodeIndexLOD = null;
        this._nodeSignalLODs.length = 0;
        this._nodePromiseLODs.length = 0;
        this._nodeBufferLODs.length = 0;
        this._materialIndexLOD = null;
        this._materialSignalLODs.length = 0;
        this._materialPromiseLODs.length = 0;
        this._materialBufferLODs.length = 0;
        this.onMaterialLODsLoadedObservable.clear();
        this.onNodeLODsLoadedObservable.clear();
    };
    /** @internal */
    MSFT_lod.prototype.onReady = function () {
        var _this = this;
        var _loop_1 = function (indexLOD) {
            var promise = Promise.all(this_1._nodePromiseLODs[indexLOD]).then(function () {
                if (indexLOD !== 0) {
                    _this._loader.endPerformanceCounter("Node LOD ".concat(indexLOD));
                    _this._loader.log("Loaded node LOD ".concat(indexLOD));
                }
                _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);
                if (indexLOD !== _this._nodePromiseLODs.length - 1) {
                    _this._loader.startPerformanceCounter("Node LOD ".concat(indexLOD + 1));
                    _this._loadBufferLOD(_this._nodeBufferLODs, indexLOD + 1);
                    if (_this._nodeSignalLODs[indexLOD]) {
                        _this._nodeSignalLODs[indexLOD].resolve();
                    }
                }
            });
            this_1._loader._completePromises.push(promise);
        };
        var this_1 = this;
        for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {
            _loop_1(indexLOD);
        }
        var _loop_2 = function (indexLOD) {
            var promise = Promise.all(this_2._materialPromiseLODs[indexLOD]).then(function () {
                if (indexLOD !== 0) {
                    _this._loader.endPerformanceCounter("Material LOD ".concat(indexLOD));
                    _this._loader.log("Loaded material LOD ".concat(indexLOD));
                }
                _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);
                if (indexLOD !== _this._materialPromiseLODs.length - 1) {
                    _this._loader.startPerformanceCounter("Material LOD ".concat(indexLOD + 1));
                    _this._loadBufferLOD(_this._materialBufferLODs, indexLOD + 1);
                    if (_this._materialSignalLODs[indexLOD]) {
                        _this._materialSignalLODs[indexLOD].resolve();
                    }
                }
            });
            this_2._loader._completePromises.push(promise);
        };
        var this_2 = this;
        for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {
            _loop_2(indexLOD);
        }
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_lod.prototype.loadSceneAsync = function (context, scene) {
        var promise = this._loader.loadSceneAsync(context, scene);
        this._loadBufferLOD(this._bufferLODs, 0);
        return promise;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_lod.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var firstPromise, nodeLODs, _loop_3, this_3, indexLOD;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);
                        this._loader.logOpen("".concat(extensionContext));
                        _loop_3 = function (indexLOD) {
                            var nodeLOD = nodeLODs[indexLOD];
                            if (indexLOD !== 0) {
                                this_3._nodeIndexLOD = indexLOD;
                                this_3._nodeSignalLODs[indexLOD] = this_3._nodeSignalLODs[indexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                            }
                            var assignWrap = function (babylonTransformNode) {
                                assign(babylonTransformNode);
                                babylonTransformNode.setEnabled(false);
                            };
                            var promise = this_3._loader.loadNodeAsync("/nodes/".concat(nodeLOD.index), nodeLOD, assignWrap).then(function (babylonMesh) {
                                if (indexLOD !== 0) {
                                    // TODO: should not rely on _babylonTransformNode
                                    var previousNodeLOD = nodeLODs[indexLOD - 1];
                                    if (previousNodeLOD._babylonTransformNode) {
                                        _this._disposeTransformNode(previousNodeLOD._babylonTransformNode);
                                        delete previousNodeLOD._babylonTransformNode;
                                    }
                                }
                                babylonMesh.setEnabled(true);
                                return babylonMesh;
                            });
                            this_3._nodePromiseLODs[indexLOD] = this_3._nodePromiseLODs[indexLOD] || [];
                            if (indexLOD === 0) {
                                firstPromise = promise;
                            }
                            else {
                                this_3._nodeIndexLOD = null;
                                this_3._nodePromiseLODs[indexLOD].push(promise);
                            }
                        };
                        this_3 = this;
                        for (indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {
                            _loop_3(indexLOD);
                        }
                        this._loader.logClose();
                        return [4 /*yield*/, firstPromise];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_lod.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {
        var _this = this;
        // Don't load material LODs if already loading a node LOD.
        if (this._nodeIndexLOD) {
            return null;
        }
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var firstPromise, materialLODs, _loop_4, this_4, indexLOD;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);
                        this._loader.logOpen("".concat(extensionContext));
                        _loop_4 = function (indexLOD) {
                            var materialLOD = materialLODs[indexLOD];
                            if (indexLOD !== 0) {
                                this_4._materialIndexLOD = indexLOD;
                            }
                            var promise = this_4._loader
                                ._loadMaterialAsync("/materials/".concat(materialLOD.index), materialLOD, babylonMesh, babylonDrawMode, function (babylonMaterial) {
                                if (indexLOD === 0) {
                                    assign(babylonMaterial);
                                }
                            })
                                .then(function (babylonMaterial) {
                                if (indexLOD !== 0) {
                                    assign(babylonMaterial);
                                    // TODO: should not rely on _data
                                    var previousDataLOD = materialLODs[indexLOD - 1]._data;
                                    if (previousDataLOD[babylonDrawMode]) {
                                        _this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);
                                        delete previousDataLOD[babylonDrawMode];
                                    }
                                }
                                return babylonMaterial;
                            });
                            this_4._materialPromiseLODs[indexLOD] = this_4._materialPromiseLODs[indexLOD] || [];
                            if (indexLOD === 0) {
                                firstPromise = promise;
                            }
                            else {
                                this_4._materialIndexLOD = null;
                                this_4._materialPromiseLODs[indexLOD].push(promise);
                            }
                        };
                        this_4 = this;
                        for (indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {
                            _loop_4(indexLOD);
                        }
                        this._loader.logClose();
                        return [4 /*yield*/, firstPromise];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); });
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_lod.prototype._loadUriAsync = function (context, property, uri) {
        var _this = this;
        // Defer the loading of uris if loading a node or material LOD.
        if (this._nodeIndexLOD !== null) {
            this._loader.log("deferred");
            var previousIndexLOD = this._nodeIndexLOD - 1;
            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._loader.loadUriAsync(context, property, uri)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            }); });
        }
        else if (this._materialIndexLOD !== null) {
            this._loader.log("deferred");
            var previousIndexLOD = this._materialIndexLOD - 1;
            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
            return this._materialSignalLODs[previousIndexLOD].promise.then(function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._loader.loadUriAsync(context, property, uri)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            }); });
        }
        return null;
    };
    /**
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_lod.prototype.loadBufferAsync = function (context, buffer, byteOffset, byteLength) {
        var _this = this;
        if (this._loader.parent.useRangeRequests && !buffer.uri) {
            if (!this._loader.bin) {
                throw new Error("".concat(context, ": Uri is missing or the binary glTF is missing its binary chunk"));
            }
            var loadAsync = function (bufferLODs, indexLOD) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
                var start, end, bufferLOD;
                return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            start = byteOffset;
                            end = start + byteLength - 1;
                            bufferLOD = bufferLODs[indexLOD];
                            if (bufferLOD) {
                                bufferLOD.start = Math.min(bufferLOD.start, start);
                                bufferLOD.end = Math.max(bufferLOD.end, end);
                            }
                            else {
                                bufferLOD = { start: start, end: end, loaded: new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred() };
                                bufferLODs[indexLOD] = bufferLOD;
                            }
                            return [4 /*yield*/, bufferLOD.loaded.promise.then(function (data) {
                                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);
                                })];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            }); };
            this._loader.log("deferred");
            if (this._nodeIndexLOD !== null) {
                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);
            }
            else if (this._materialIndexLOD !== null) {
                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);
            }
            else {
                return loadAsync(this._bufferLODs, 0);
            }
        }
        return null;
    };
    MSFT_lod.prototype._loadBufferLOD = function (bufferLODs, indexLOD) {
        var bufferLOD = bufferLODs[indexLOD];
        if (bufferLOD) {
            this._loader.log("Loading buffer range [".concat(bufferLOD.start, "-").concat(bufferLOD.end, "]"));
            this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(function (data) {
                bufferLOD.loaded.resolve(data);
            }, function (error) {
                bufferLOD.loaded.reject(error);
            });
        }
    };
    /**
     * @returns an array of LOD properties from lowest to highest.
     * @param context
     * @param property
     * @param array
     * @param ids
     */
    MSFT_lod.prototype._getLODs = function (context, property, array, ids) {
        if (this.maxLODsToLoad <= 0) {
            throw new Error("maxLODsToLoad must be greater than zero");
        }
        var properties = [];
        for (var i = ids.length - 1; i >= 0; i--) {
            properties.push(_glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/ids/").concat(ids[i]), array, ids[i]));
            if (properties.length === this.maxLODsToLoad) {
                return properties;
            }
        }
        properties.push(property);
        return properties;
    };
    MSFT_lod.prototype._disposeTransformNode = function (babylonTransformNode) {
        var _this = this;
        var babylonMaterials = [];
        var babylonMaterial = babylonTransformNode.material;
        if (babylonMaterial) {
            babylonMaterials.push(babylonMaterial);
        }
        for (var _i = 0, _a = babylonTransformNode.getChildMeshes(); _i < _a.length; _i++) {
            var babylonMesh = _a[_i];
            if (babylonMesh.material) {
                babylonMaterials.push(babylonMesh.material);
            }
        }
        babylonTransformNode.dispose();
        var babylonMaterialsToDispose = babylonMaterials.filter(function (babylonMaterial) { return _this._loader.babylonScene.meshes.every(function (mesh) { return mesh.material != babylonMaterial; }); });
        this._disposeMaterials(babylonMaterialsToDispose);
    };
    MSFT_lod.prototype._disposeMaterials = function (babylonMaterials) {
        var babylonTextures = {};
        for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {
            var babylonMaterial = babylonMaterials_1[_i];
            for (var _a = 0, _b = babylonMaterial.getActiveTextures(); _a < _b.length; _a++) {
                var babylonTexture = _b[_a];
                babylonTextures[babylonTexture.uniqueId] = babylonTexture;
            }
            babylonMaterial.dispose();
        }
        for (var uniqueId in babylonTextures) {
            for (var _c = 0, _d = this._loader.babylonScene.materials; _c < _d.length; _c++) {
                var babylonMaterial = _d[_c];
                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {
                    delete babylonTextures[uniqueId];
                }
            }
        }
        for (var uniqueId in babylonTextures) {
            babylonTextures[uniqueId].dispose();
        }
    };
    return MSFT_lod;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new MSFT_lod(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts":
/*!**************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MSFT_minecraftMesh: () => (/* binding */ MSFT_minecraftMesh)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "MSFT_minecraftMesh";
/** @internal */
// eslint-disable-next-line @typescript-eslint/naming-convention
var MSFT_minecraftMesh = /** @class */ (function () {
    /** @internal */
    function MSFT_minecraftMesh(loader) {
        /** @internal */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    MSFT_minecraftMesh.prototype.dispose = function () {
        this._loader = null;
    };
    /** @internal */
    // eslint-disable-next-line no-restricted-syntax
    MSFT_minecraftMesh.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtraAsync(context, material, this.name, function (extraContext, extra) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promise;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!extra) return [3 /*break*/, 2];
                        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(extraContext, ": Material type not supported"));
                        }
                        promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                        if (babylonMaterial.needAlphaBlending()) {
                            babylonMaterial.forceDepthWrite = true;
                            babylonMaterial.separateCullingPass = true;
                        }
                        babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;
                        babylonMaterial.twoSidedLighting = true;
                        return [4 /*yield*/, promise];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/];
                }
            });
        }); });
    };
    return MSFT_minecraftMesh;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new MSFT_minecraftMesh(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts":
/*!************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MSFT_sRGBFactors: () => (/* binding */ MSFT_sRGBFactors)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Materials/PBR/pbrMaterial */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");




var NAME = "MSFT_sRGBFactors";
/** @internal */
// eslint-disable-next-line @typescript-eslint/naming-convention
var MSFT_sRGBFactors = /** @class */ (function () {
    /** @internal */
    function MSFT_sRGBFactors(loader) {
        /** @internal */
        this.name = NAME;
        this._loader = loader;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    /** @internal */
    MSFT_sRGBFactors.prototype.dispose = function () {
        this._loader = null;
    };
    /** @internal*/
    // eslint-disable-next-line no-restricted-syntax
    MSFT_sRGBFactors.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var _this = this;
        return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtraAsync(context, material, this.name, function (extraContext, extra) { return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(_this, void 0, void 0, function () {
            var promise, useExactSrgbConversions;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!extra) return [3 /*break*/, 2];
                        if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(extraContext, ": Material type not supported"));
                        }
                        promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                        useExactSrgbConversions = babylonMaterial.getScene().getEngine().useExactSrgbConversions;
                        if (!babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor, useExactSrgbConversions);
                        }
                        if (!babylonMaterial.reflectivityTexture) {
                            babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor, useExactSrgbConversions);
                        }
                        return [4 /*yield*/, promise];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/];
                }
            });
        }); });
    };
    return MSFT_sRGBFactors;
}());

(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(NAME);
(0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(NAME, true, function (loader) { return new MSFT_sRGBFactors(loader); });


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts":
/*!*********************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFPathToObjectConverter: () => (/* binding */ GLTFPathToObjectConverter),
/* harmony export */   OptionalPathExceptionsList: () => (/* binding */ OptionalPathExceptionsList)
/* harmony export */ });
/**
 * Adding an exception here will break traversing through the glTF object tree.
 * This is used for properties that might not be in the glTF object model, but are optional and have a default value.
 * For example, the path /nodes/\{\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.
 */
var OptionalPathExceptionsList = [
    {
        // get the node as object when reading an extension
        regex: new RegExp("^/nodes/\\d+/extensions/"),
    },
];
/**
 * A converter that takes a glTF Object Model JSON Pointer
 * and transforms it into an ObjectAccessorContainer, allowing
 * objects referenced in the glTF to be associated with their
 * respective Babylon.js objects.
 */
var GLTFPathToObjectConverter = /** @class */ (function () {
    function GLTFPathToObjectConverter(_gltf, _infoTree) {
        this._gltf = _gltf;
        this._infoTree = _infoTree;
    }
    /**
     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).
     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers
     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>
     * <rootNode> := "nodes" | "materials" | "meshes" | "cameras" | "extensions"
     * <assetIndex> := <digit> | <name>
     * <propertyPath> := <extensionPath> | <standardPath>
     * <extensionPath> := "extensions"/<name>/<standardPath>
     * <standardPath> := <name> | <name>/<standardPath>
     * <name> := W+
     * <digit> := D+
     *
     * Examples:
     *  - "/nodes/0/rotation"
     * - "/nodes.length"
     *  - "/materials/2/emissiveFactor"
     *  - "/materials/2/pbrMetallicRoughness/baseColorFactor"
     *  - "/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength"
     *
     * @param path The path to convert
     * @returns The object and info associated with the path
     */
    GLTFPathToObjectConverter.prototype.convert = function (path) {
        var objectTree = this._gltf;
        var infoTree = this._infoTree;
        var target = undefined;
        if (!path.startsWith("/")) {
            throw new Error("Path must start with a /");
        }
        var parts = path.split("/");
        parts.shift();
        //if the last part has ".length" in it, separate that as an extra part
        if (parts[parts.length - 1].includes(".length")) {
            var lastPart = parts[parts.length - 1];
            var split = lastPart.split(".");
            parts.pop();
            parts.push.apply(parts, split);
        }
        var ignoreObjectTree = false;
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var part = parts_1[_i];
            var isLength = part === "length";
            if (isLength && !infoTree.__array__) {
                throw new Error("Path ".concat(path, " is invalid"));
            }
            if (infoTree.__ignoreObjectTree__) {
                ignoreObjectTree = true;
            }
            if (infoTree.__array__ && !isLength) {
                infoTree = infoTree.__array__;
            }
            else {
                infoTree = infoTree[part];
                if (!infoTree) {
                    throw new Error("Path ".concat(path, " is invalid"));
                }
            }
            if (!ignoreObjectTree) {
                if (objectTree === undefined) {
                    // check if the path is in the exception list. If it is, break and return the last object that was found
                    var exception = OptionalPathExceptionsList.find(function (e) { return e.regex.test(path); });
                    if (!exception) {
                        throw new Error("Path ".concat(path, " is invalid"));
                    }
                }
                else if (!isLength) {
                    objectTree = objectTree === null || objectTree === void 0 ? void 0 : objectTree[part];
                }
            }
            if (infoTree.__target__ || isLength) {
                target = objectTree;
            }
        }
        return {
            object: target,
            info: infoTree,
        };
    };
    return GLTFPathToObjectConverter;
}());



/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts":
/*!*************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/index.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddObjectAccessorToKey: () => (/* reexport safe */ _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.AddObjectAccessorToKey),
/* harmony export */   EXT_lights_ies: () => (/* reexport safe */ _EXT_lights_ies__WEBPACK_IMPORTED_MODULE_6__.EXT_lights_ies),
/* harmony export */   EXT_lights_image_based: () => (/* reexport safe */ _EXT_lights_image_based__WEBPACK_IMPORTED_MODULE_1__.EXT_lights_image_based),
/* harmony export */   EXT_materials_diffuse_roughness: () => (/* reexport safe */ _EXT_materials_diffuse_roughness__WEBPACK_IMPORTED_MODULE_23__.EXT_materials_diffuse_roughness),
/* harmony export */   EXT_mesh_gpu_instancing: () => (/* reexport safe */ _EXT_mesh_gpu_instancing__WEBPACK_IMPORTED_MODULE_2__.EXT_mesh_gpu_instancing),
/* harmony export */   EXT_meshopt_compression: () => (/* reexport safe */ _EXT_meshopt_compression__WEBPACK_IMPORTED_MODULE_3__.EXT_meshopt_compression),
/* harmony export */   EXT_texture_avif: () => (/* reexport safe */ _EXT_texture_avif__WEBPACK_IMPORTED_MODULE_5__.EXT_texture_avif),
/* harmony export */   EXT_texture_webp: () => (/* reexport safe */ _EXT_texture_webp__WEBPACK_IMPORTED_MODULE_4__.EXT_texture_webp),
/* harmony export */   ExtrasAsMetadata: () => (/* reexport safe */ _ExtrasAsMetadata__WEBPACK_IMPORTED_MODULE_37__.ExtrasAsMetadata),
/* harmony export */   FlowGraphGLTFDataProvider: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.FlowGraphGLTFDataProvider),
/* harmony export */   GetMappingForKey: () => (/* reexport safe */ _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.GetMappingForKey),
/* harmony export */   GetPathToObjectConverter: () => (/* reexport safe */ _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.GetPathToObjectConverter),
/* harmony export */   InteractivityGraphToFlowGraphParser: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.InteractivityGraphToFlowGraphParser),
/* harmony export */   KHR_animation_pointer: () => (/* reexport safe */ _KHR_animation_pointer__WEBPACK_IMPORTED_MODULE_28__.KHR_animation_pointer),
/* harmony export */   KHR_draco_mesh_compression: () => (/* reexport safe */ _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_7__.KHR_draco_mesh_compression),
/* harmony export */   KHR_interactivity: () => (/* reexport safe */ _KHR_interactivity__WEBPACK_IMPORTED_MODULE_33__.KHR_interactivity),
/* harmony export */   KHR_lights: () => (/* reexport safe */ _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_8__.KHR_lights),
/* harmony export */   KHR_materials_anisotropy: () => (/* reexport safe */ _KHR_materials_anisotropy__WEBPACK_IMPORTED_MODULE_13__.KHR_materials_anisotropy),
/* harmony export */   KHR_materials_clearcoat: () => (/* reexport safe */ _KHR_materials_clearcoat__WEBPACK_IMPORTED_MODULE_11__.KHR_materials_clearcoat),
/* harmony export */   KHR_materials_diffuse_transmission: () => (/* reexport safe */ _KHR_materials_diffuse_transmission__WEBPACK_IMPORTED_MODULE_20__.KHR_materials_diffuse_transmission),
/* harmony export */   KHR_materials_dispersion: () => (/* reexport safe */ _KHR_materials_dispersion__WEBPACK_IMPORTED_MODULE_22__.KHR_materials_dispersion),
/* harmony export */   KHR_materials_emissive_strength: () => (/* reexport safe */ _KHR_materials_emissive_strength__WEBPACK_IMPORTED_MODULE_14__.KHR_materials_emissive_strength),
/* harmony export */   KHR_materials_ior: () => (/* reexport safe */ _KHR_materials_ior__WEBPACK_IMPORTED_MODULE_17__.KHR_materials_ior),
/* harmony export */   KHR_materials_iridescence: () => (/* reexport safe */ _KHR_materials_iridescence__WEBPACK_IMPORTED_MODULE_12__.KHR_materials_iridescence),
/* harmony export */   KHR_materials_pbrSpecularGlossiness: () => (/* reexport safe */ _KHR_materials_pbrSpecularGlossiness__WEBPACK_IMPORTED_MODULE_9__.KHR_materials_pbrSpecularGlossiness),
/* harmony export */   KHR_materials_sheen: () => (/* reexport safe */ _KHR_materials_sheen__WEBPACK_IMPORTED_MODULE_15__.KHR_materials_sheen),
/* harmony export */   KHR_materials_specular: () => (/* reexport safe */ _KHR_materials_specular__WEBPACK_IMPORTED_MODULE_16__.KHR_materials_specular),
/* harmony export */   KHR_materials_transmission: () => (/* reexport safe */ _KHR_materials_transmission__WEBPACK_IMPORTED_MODULE_19__.KHR_materials_transmission),
/* harmony export */   KHR_materials_unlit: () => (/* reexport safe */ _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_10__.KHR_materials_unlit),
/* harmony export */   KHR_materials_variants: () => (/* reexport safe */ _KHR_materials_variants__WEBPACK_IMPORTED_MODULE_18__.KHR_materials_variants),
/* harmony export */   KHR_materials_volume: () => (/* reexport safe */ _KHR_materials_volume__WEBPACK_IMPORTED_MODULE_21__.KHR_materials_volume),
/* harmony export */   KHR_mesh_quantization: () => (/* reexport safe */ _KHR_mesh_quantization__WEBPACK_IMPORTED_MODULE_24__.KHR_mesh_quantization),
/* harmony export */   KHR_node_hoverability: () => (/* reexport safe */ _KHR_node_hoverability__WEBPACK_IMPORTED_MODULE_36__.KHR_node_hoverability),
/* harmony export */   KHR_node_selectability: () => (/* reexport safe */ _KHR_node_selectability__WEBPACK_IMPORTED_MODULE_35__.KHR_node_selectability),
/* harmony export */   KHR_node_visibility: () => (/* reexport safe */ _KHR_node_visibility__WEBPACK_IMPORTED_MODULE_34__.KHR_node_visibility),
/* harmony export */   KHR_texture_basisu: () => (/* reexport safe */ _KHR_texture_basisu__WEBPACK_IMPORTED_MODULE_25__.KHR_texture_basisu),
/* harmony export */   KHR_texture_transform: () => (/* reexport safe */ _KHR_texture_transform__WEBPACK_IMPORTED_MODULE_26__.KHR_texture_transform),
/* harmony export */   KHR_xmp_json_ld: () => (/* reexport safe */ _KHR_xmp_json_ld__WEBPACK_IMPORTED_MODULE_27__.KHR_xmp_json_ld),
/* harmony export */   MSFT_audio_emitter: () => (/* reexport safe */ _MSFT_audio_emitter__WEBPACK_IMPORTED_MODULE_29__.MSFT_audio_emitter),
/* harmony export */   MSFT_lod: () => (/* reexport safe */ _MSFT_lod__WEBPACK_IMPORTED_MODULE_30__.MSFT_lod),
/* harmony export */   MSFT_minecraftMesh: () => (/* reexport safe */ _MSFT_minecraftMesh__WEBPACK_IMPORTED_MODULE_31__.MSFT_minecraftMesh),
/* harmony export */   MSFT_sRGBFactors: () => (/* reexport safe */ _MSFT_sRGBFactors__WEBPACK_IMPORTED_MODULE_32__.MSFT_sRGBFactors),
/* harmony export */   SetInterpolationForKey: () => (/* reexport safe */ _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__.SetInterpolationForKey),
/* harmony export */   _AddInteractivityObjectModel: () => (/* reexport safe */ _KHR_interactivity__WEBPACK_IMPORTED_MODULE_33__._AddInteractivityObjectModel),
/* harmony export */   addNewInteractivityFlowGraphMapping: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.addNewInteractivityFlowGraphMapping),
/* harmony export */   getAllSupportedNativeNodeTypes: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.getAllSupportedNativeNodeTypes),
/* harmony export */   getMappingForDeclaration: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.getMappingForDeclaration),
/* harmony export */   getMappingForFullOperationName: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.getMappingForFullOperationName),
/* harmony export */   gltfTypeToBabylonType: () => (/* reexport safe */ _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__.gltfTypeToBabylonType)
/* harmony export */ });
/* harmony import */ var _objectModelMapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");
/* harmony import */ var _EXT_lights_image_based__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EXT_lights_image_based */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts");
/* harmony import */ var _EXT_mesh_gpu_instancing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EXT_mesh_gpu_instancing */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts");
/* harmony import */ var _EXT_meshopt_compression__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EXT_meshopt_compression */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts");
/* harmony import */ var _EXT_texture_webp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EXT_texture_webp */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts");
/* harmony import */ var _EXT_texture_avif__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EXT_texture_avif */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts");
/* harmony import */ var _EXT_lights_ies__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EXT_lights_ies */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts");
/* harmony import */ var _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./KHR_draco_mesh_compression */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts");
/* harmony import */ var _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./KHR_lights_punctual */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts");
/* harmony import */ var _KHR_materials_pbrSpecularGlossiness__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./KHR_materials_pbrSpecularGlossiness */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts");
/* harmony import */ var _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./KHR_materials_unlit */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts");
/* harmony import */ var _KHR_materials_clearcoat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./KHR_materials_clearcoat */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts");
/* harmony import */ var _KHR_materials_iridescence__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./KHR_materials_iridescence */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts");
/* harmony import */ var _KHR_materials_anisotropy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./KHR_materials_anisotropy */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts");
/* harmony import */ var _KHR_materials_emissive_strength__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./KHR_materials_emissive_strength */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts");
/* harmony import */ var _KHR_materials_sheen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./KHR_materials_sheen */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts");
/* harmony import */ var _KHR_materials_specular__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./KHR_materials_specular */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts");
/* harmony import */ var _KHR_materials_ior__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./KHR_materials_ior */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts");
/* harmony import */ var _KHR_materials_variants__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./KHR_materials_variants */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts");
/* harmony import */ var _KHR_materials_transmission__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./KHR_materials_transmission */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts");
/* harmony import */ var _KHR_materials_diffuse_transmission__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./KHR_materials_diffuse_transmission */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts");
/* harmony import */ var _KHR_materials_volume__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./KHR_materials_volume */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts");
/* harmony import */ var _KHR_materials_dispersion__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./KHR_materials_dispersion */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts");
/* harmony import */ var _EXT_materials_diffuse_roughness__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./EXT_materials_diffuse_roughness */ "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_materials_diffuse_roughness.ts");
/* harmony import */ var _KHR_mesh_quantization__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./KHR_mesh_quantization */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts");
/* harmony import */ var _KHR_texture_basisu__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./KHR_texture_basisu */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts");
/* harmony import */ var _KHR_texture_transform__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./KHR_texture_transform */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts");
/* harmony import */ var _KHR_xmp_json_ld__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./KHR_xmp_json_ld */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts");
/* harmony import */ var _KHR_animation_pointer__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./KHR_animation_pointer */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts");
/* harmony import */ var _MSFT_audio_emitter__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./MSFT_audio_emitter */ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts");
/* harmony import */ var _MSFT_lod__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./MSFT_lod */ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts");
/* harmony import */ var _MSFT_minecraftMesh__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./MSFT_minecraftMesh */ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts");
/* harmony import */ var _MSFT_sRGBFactors__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./MSFT_sRGBFactors */ "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts");
/* harmony import */ var _KHR_interactivity__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./KHR_interactivity */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts");
/* harmony import */ var _KHR_node_visibility__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./KHR_node_visibility */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts");
/* harmony import */ var _KHR_node_selectability__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./KHR_node_selectability */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts");
/* harmony import */ var _KHR_node_hoverability__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./KHR_node_hoverability */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts");
/* harmony import */ var _ExtrasAsMetadata__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./ExtrasAsMetadata */ "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts");
/* harmony import */ var _KHR_interactivity_index__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./KHR_interactivity/index */ "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/index.ts");






































// eslint-disable-next-line import/no-internal-modules



/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts":
/*!**************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddObjectAccessorToKey: () => (/* binding */ AddObjectAccessorToKey),
/* harmony export */   GetMappingForKey: () => (/* binding */ GetMappingForKey),
/* harmony export */   GetPathToObjectConverter: () => (/* binding */ GetPathToObjectConverter),
/* harmony export */   SetInterpolationForKey: () => (/* binding */ SetInterpolationForKey)
/* harmony export */ });
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Lights/spotLight */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gltfPathToObjectConverter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltfPathToObjectConverter */ "../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts");
/* eslint-disable @typescript-eslint/naming-convention */





var nodesTree = {
    length: {
        type: "number",
        get: function (nodes) { return nodes.length; },
        getTarget: function (nodes) { return nodes.map(function (node) { return node._babylonTransformNode; }); },
        getPropertyName: [function () { return "length"; }],
    },
    __array__: {
        __target__: true,
        translation: {
            type: "Vector3",
            get: function (node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.position; },
            set: function (value, node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.position.copyFrom(value); },
            getTarget: function (node) { return node._babylonTransformNode; },
            getPropertyName: [function () { return "position"; }],
        },
        rotation: {
            type: "Quaternion",
            get: function (node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.rotationQuaternion; },
            set: function (value, node) { var _a, _b; return (_b = (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.rotationQuaternion) === null || _b === void 0 ? void 0 : _b.copyFrom(value); },
            getTarget: function (node) { return node._babylonTransformNode; },
            getPropertyName: [function () { return "rotationQuaternion"; }],
        },
        scale: {
            type: "Vector3",
            get: function (node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.scaling; },
            set: function (value, node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.scaling.copyFrom(value); },
            getTarget: function (node) { return node._babylonTransformNode; },
            getPropertyName: [function () { return "scaling"; }],
        },
        weights: {
            length: {
                type: "number",
                get: function (node) { return node._numMorphTargets; },
                getTarget: function (node) { return node._babylonTransformNode; },
                getPropertyName: [function () { return "influence"; }],
            },
            __array__: {
                __target__: true,
                type: "number",
                get: function (node, index) { var _a, _b; return (index !== undefined ? (_b = (_a = node._primitiveBabylonMeshes) === null || _a === void 0 ? void 0 : _a[0].morphTargetManager) === null || _b === void 0 ? void 0 : _b.getTarget(index).influence : undefined); },
                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),
                getTarget: function (node) { return node._babylonTransformNode; },
                getPropertyName: [function () { return "influence"; }],
            },
            type: "number[]",
            get: function (node, index) { return [0]; }, // TODO: get the weights correctly
            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),
            getTarget: function (node) { return node._babylonTransformNode; },
            getPropertyName: [function () { return "influence"; }],
        },
        // readonly!
        matrix: {
            type: "Matrix",
            get: function (node) { var _a, _b, _c; return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.Compose((_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.scaling, (_b = node._babylonTransformNode) === null || _b === void 0 ? void 0 : _b.rotationQuaternion, (_c = node._babylonTransformNode) === null || _c === void 0 ? void 0 : _c.position); },
            getTarget: function (node) { return node._babylonTransformNode; },
            isReadOnly: true,
        },
        globalMatrix: {
            type: "Matrix",
            get: function (node) {
                var _a, _b, _c, _d, _e, _f, _g;
                var matrix = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.Identity();
                // RHS/LHS support
                var rootNode = node.parent;
                while (rootNode && rootNode.parent) {
                    rootNode = rootNode.parent;
                }
                var forceUpdate = ((_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.position._isDirty) || ((_c = (_b = node._babylonTransformNode) === null || _b === void 0 ? void 0 : _b.rotationQuaternion) === null || _c === void 0 ? void 0 : _c._isDirty) || ((_d = node._babylonTransformNode) === null || _d === void 0 ? void 0 : _d.scaling._isDirty);
                if (rootNode) {
                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix
                    // This will provide the global matrix, ignoring the RHS->LHS conversion
                    var rootMatrix = (_e = rootNode._babylonTransformNode) === null || _e === void 0 ? void 0 : _e.computeWorldMatrix(true).invert();
                    if (rootMatrix) {
                        (_g = (_f = node._babylonTransformNode) === null || _f === void 0 ? void 0 : _f.computeWorldMatrix(forceUpdate)) === null || _g === void 0 ? void 0 : _g.multiplyToRef(rootMatrix, matrix);
                    }
                }
                else if (node._babylonTransformNode) {
                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));
                }
                return matrix;
            },
            getTarget: function (node) { return node._babylonTransformNode; },
            isReadOnly: true,
        },
        extensions: {
            EXT_lights_ies: {
                multiplier: {
                    type: "number",
                    get: function (node) {
                        var _a, _b;
                        return (_b = (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function (child) { return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight; }, true)[0]) === null || _b === void 0 ? void 0 : _b.intensity;
                    },
                    getTarget: function (node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function (child) { return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight; }, true)[0]; },
                    set: function (value, node) {
                        if (node._babylonTransformNode) {
                            var light = node._babylonTransformNode.getChildren(function (child) { return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight; }, true)[0];
                            if (light) {
                                light.intensity = value;
                            }
                        }
                    },
                },
                color: {
                    type: "Color3",
                    get: function (node) {
                        var _a, _b;
                        return (_b = (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function (child) { return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight; }, true)[0]) === null || _b === void 0 ? void 0 : _b.diffuse;
                    },
                    getTarget: function (node) { var _a; return (_a = node._babylonTransformNode) === null || _a === void 0 ? void 0 : _a.getChildren(function (child) { return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight; }, true)[0]; },
                    set: function (value, node) {
                        if (node._babylonTransformNode) {
                            var light = node._babylonTransformNode.getChildren(function (child) { return child instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight; }, true)[0];
                            if (light) {
                                light.diffuse = value;
                            }
                        }
                    },
                },
            },
        },
    },
};
var animationsTree = {
    length: {
        type: "number",
        get: function (animations) { return animations.length; },
        getTarget: function (animations) { return animations.map(function (animation) { return animation._babylonAnimationGroup; }); },
        getPropertyName: [function () { return "length"; }],
    },
    __array__: {},
};
var meshesTree = {
    length: {
        type: "number",
        get: function (meshes) { return meshes.length; },
        getTarget: function (meshes) { return meshes.map(function (mesh) { var _a; return (_a = mesh.primitives[0]._instanceData) === null || _a === void 0 ? void 0 : _a.babylonSourceMesh; }); },
        getPropertyName: [function () { return "length"; }],
    },
    __array__: {},
};
var camerasTree = {
    __array__: {
        __target__: true,
        orthographic: {
            xmag: {
                componentsCount: 2,
                type: "Vector2",
                get: function (camera) { var _a, _b, _c, _d; return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2((_b = (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.orthoLeft) !== null && _b !== void 0 ? _b : 0, (_d = (_c = camera._babylonCamera) === null || _c === void 0 ? void 0 : _c.orthoRight) !== null && _d !== void 0 ? _d : 0); },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.orthoLeft = value.x;
                        camera._babylonCamera.orthoRight = value.y;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "orthoLeft"; }, function () { return "orthoRight"; }],
            },
            ymag: {
                componentsCount: 2,
                type: "Vector2",
                get: function (camera) { var _a, _b, _c, _d; return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2((_b = (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.orthoBottom) !== null && _b !== void 0 ? _b : 0, (_d = (_c = camera._babylonCamera) === null || _c === void 0 ? void 0 : _c.orthoTop) !== null && _d !== void 0 ? _d : 0); },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.orthoBottom = value.x;
                        camera._babylonCamera.orthoTop = value.y;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "orthoBottom"; }, function () { return "orthoTop"; }],
            },
            zfar: {
                type: "number",
                get: function (camera) { var _a; return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.maxZ; },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.maxZ = value;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "maxZ"; }],
            },
            znear: {
                type: "number",
                get: function (camera) { var _a; return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.minZ; },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.minZ = value;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "minZ"; }],
            },
        },
        perspective: {
            aspectRatio: {
                type: "number",
                get: function (camera) { var _a; return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.getEngine().getAspectRatio(camera._babylonCamera); },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "aspectRatio"; }],
                isReadOnly: true, // might not be the case for glTF?
            },
            yfov: {
                type: "number",
                get: function (camera) { var _a; return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.fov; },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.fov = value;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "fov"; }],
            },
            zfar: {
                type: "number",
                get: function (camera) { var _a; return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.maxZ; },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.maxZ = value;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "maxZ"; }],
            },
            znear: {
                type: "number",
                get: function (camera) { var _a; return (_a = camera._babylonCamera) === null || _a === void 0 ? void 0 : _a.minZ; },
                set: function (value, camera) {
                    if (camera._babylonCamera) {
                        camera._babylonCamera.minZ = value;
                    }
                },
                getTarget: function (camera) { return camera; },
                getPropertyName: [function () { return "minZ"; }],
            },
        },
    },
};
var materialsTree = {
    __array__: {
        __target__: true,
        emissiveFactor: {
            type: "Color3",
            get: function (material, index, payload) { return GetMaterial(material, index, payload).emissiveColor; },
            set: function (value, material, index, payload) { return GetMaterial(material, index, payload).emissiveColor.copyFrom(value); },
            getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
            getPropertyName: [function () { return "emissiveColor"; }],
        },
        emissiveTexture: {
            extensions: {
                KHR_texture_transform: GenerateTextureMap("emissiveTexture"),
            },
        },
        normalTexture: {
            scale: {
                type: "number",
                get: function (material, index, payload) { var _a; return (_a = GetTexture(material, payload, "bumpTexture")) === null || _a === void 0 ? void 0 : _a.level; },
                set: function (value, material, index, payload) {
                    var texture = GetTexture(material, payload, "bumpTexture");
                    if (texture) {
                        texture.level = value;
                    }
                },
                getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                getPropertyName: [function () { return "level"; }],
            },
            extensions: {
                KHR_texture_transform: GenerateTextureMap("bumpTexture"),
            },
        },
        occlusionTexture: {
            strength: {
                type: "number",
                get: function (material, index, payload) { return GetMaterial(material, index, payload).ambientTextureStrength; },
                set: function (value, material, index, payload) {
                    var mat = GetMaterial(material, index, payload);
                    if (mat) {
                        mat.ambientTextureStrength = value;
                    }
                },
                getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                getPropertyName: [function () { return "ambientTextureStrength"; }],
            },
            extensions: {
                KHR_texture_transform: GenerateTextureMap("ambientTexture"),
            },
        },
        pbrMetallicRoughness: {
            baseColorFactor: {
                type: "Color4",
                get: function (material, index, payload) {
                    var mat = GetMaterial(material, index, payload);
                    return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color4.FromColor3(mat.albedoColor, mat.alpha);
                },
                set: function (value, material, index, payload) {
                    var mat = GetMaterial(material, index, payload);
                    mat.albedoColor.set(value.r, value.g, value.b);
                    mat.alpha = value.a;
                },
                getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                // This is correct on the animation level, but incorrect as a single property of a type Color4
                getPropertyName: [function () { return "albedoColor"; }, function () { return "alpha"; }],
            },
            baseColorTexture: {
                extensions: {
                    KHR_texture_transform: GenerateTextureMap("albedoTexture"),
                },
            },
            metallicFactor: {
                type: "number",
                get: function (material, index, payload) { return GetMaterial(material, index, payload).metallic; },
                set: function (value, material, index, payload) {
                    var mat = GetMaterial(material, index, payload);
                    if (mat) {
                        mat.metallic = value;
                    }
                },
                getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                getPropertyName: [function () { return "metallic"; }],
            },
            roughnessFactor: {
                type: "number",
                get: function (material, index, payload) { return GetMaterial(material, index, payload).roughness; },
                set: function (value, material, index, payload) {
                    var mat = GetMaterial(material, index, payload);
                    if (mat) {
                        mat.roughness = value;
                    }
                },
                getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                getPropertyName: [function () { return "roughness"; }],
            },
            metallicRoughnessTexture: {
                extensions: {
                    KHR_texture_transform: GenerateTextureMap("metallicTexture"),
                },
            },
        },
        extensions: {
            KHR_materials_anisotropy: {
                anisotropyStrength: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).anisotropy.intensity; },
                    set: function (value, material, index, payload) {
                        GetMaterial(material, index, payload).anisotropy.intensity = value;
                    },
                    getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                    getPropertyName: [function () { return "anisotropy.intensity"; }],
                },
                anisotropyRotation: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).anisotropy.angle; },
                    set: function (value, material, index, payload) {
                        GetMaterial(material, index, payload).anisotropy.angle = value;
                    },
                    getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                    getPropertyName: [function () { return "anisotropy.angle"; }],
                },
                anisotropyTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("anisotropy", "texture"),
                    },
                },
            },
            KHR_materials_clearcoat: {
                clearcoatFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).clearCoat.intensity; },
                    set: function (value, material, index, payload) {
                        GetMaterial(material, index, payload).clearCoat.intensity = value;
                    },
                    getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                    getPropertyName: [function () { return "clearCoat.intensity"; }],
                },
                clearcoatRoughnessFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).clearCoat.roughness; },
                    set: function (value, material, index, payload) {
                        GetMaterial(material, index, payload).clearCoat.roughness = value;
                    },
                    getTarget: function (material, index, payload) { return GetMaterial(material, index, payload); },
                    getPropertyName: [function () { return "clearCoat.roughness"; }],
                },
                clearcoatTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("clearCoat", "texture"),
                    },
                },
                clearcoatNormalTexture: {
                    scale: {
                        type: "number",
                        get: function (material, index, payload) { var _a; return (_a = GetMaterial(material, index, payload).clearCoat.bumpTexture) === null || _a === void 0 ? void 0 : _a.level; },
                        getTarget: GetMaterial,
                        set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value); },
                    },
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("clearCoat", "bumpTexture"),
                    },
                },
                clearcoatRoughnessTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("clearCoat", "textureRoughness"),
                    },
                },
            },
            KHR_materials_dispersion: {
                dispersion: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.dispersion; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).subSurface.dispersion = value); },
                },
            },
            KHR_materials_emissive_strength: {
                emissiveStrength: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).emissiveIntensity; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).emissiveIntensity = value); },
                },
            },
            KHR_materials_ior: {
                ior: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).indexOfRefraction; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).indexOfRefraction = value); },
                },
            },
            KHR_materials_iridescence: {
                iridescenceFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).iridescence.intensity; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).iridescence.intensity = value); },
                },
                iridescenceIor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).iridescence.indexOfRefraction; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value); },
                },
                iridescenceTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("iridescence", "texture"),
                    },
                },
                iridescenceThicknessMaximum: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).iridescence.maximumThickness; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).iridescence.maximumThickness = value); },
                },
                iridescenceThicknessMinimum: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).iridescence.minimumThickness; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).iridescence.minimumThickness = value); },
                },
                iridescenceThicknessTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("iridescence", "thicknessTexture"),
                    },
                },
            },
            KHR_materials_sheen: {
                sheenColorFactor: {
                    type: "Color3",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).sheen.color; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return GetMaterial(material, index, payload).sheen.color.copyFrom(value); },
                },
                sheenColorTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("sheen", "texture"),
                    },
                },
                sheenRoughnessFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).sheen.intensity; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).sheen.intensity = value); },
                },
                sheenRoughnessTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("sheen", "thicknessTexture"),
                    },
                },
            },
            KHR_materials_specular: {
                specularFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).metallicF0Factor; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).metallicF0Factor = value); },
                    getPropertyName: [function () { return "metallicF0Factor"; }],
                },
                specularColorFactor: {
                    type: "Color3",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).metallicReflectanceColor; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value); },
                    getPropertyName: [function () { return "metallicReflectanceColor"; }],
                },
                specularTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("metallicReflectanceTexture"),
                    },
                },
                specularColorTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("reflectanceTexture"),
                    },
                },
            },
            KHR_materials_transmission: {
                transmissionFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.refractionIntensity; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).subSurface.refractionIntensity = value); },
                    getPropertyName: [function () { return "subSurface.refractionIntensity"; }],
                },
                transmissionTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("subSurface", "refractionIntensityTexture"),
                    },
                },
            },
            KHR_materials_diffuse_transmission: {
                diffuseTransmissionFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.translucencyIntensity; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value); },
                },
                diffuseTransmissionTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("subSurface", "translucencyIntensityTexture"),
                    },
                },
                diffuseTransmissionColorFactor: {
                    type: "Color3",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.translucencyColor; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { var _a; return value && ((_a = GetMaterial(material, index, payload).subSurface.translucencyColor) === null || _a === void 0 ? void 0 : _a.copyFrom(value)); },
                },
                diffuseTransmissionColorTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("subSurface", "translucencyColorTexture"),
                    },
                },
            },
            KHR_materials_volume: {
                attenuationColor: {
                    type: "Color3",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.tintColor; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value); },
                },
                attenuationDistance: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.tintColorAtDistance; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value); },
                },
                thicknessFactor: {
                    type: "number",
                    get: function (material, index, payload) { return GetMaterial(material, index, payload).subSurface.maximumThickness; },
                    getTarget: GetMaterial,
                    set: function (value, material, index, payload) { return (GetMaterial(material, index, payload).subSurface.maximumThickness = value); },
                },
                thicknessTexture: {
                    extensions: {
                        KHR_texture_transform: GenerateTextureMap("subSurface", "thicknessTexture"),
                    },
                },
            },
        },
    },
};
var extensionsTree = {
    KHR_lights_punctual: {
        lights: {
            length: {
                type: "number",
                get: function (lights) { return lights.length; },
                getTarget: function (lights) { return lights.map(function (light) { return light._babylonLight; }); },
                getPropertyName: [function (_lights) { return "length"; }],
            },
            __array__: {
                __target__: true,
                color: {
                    type: "Color3",
                    get: function (light) { var _a; return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.diffuse; },
                    set: function (value, light) { var _a; return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.diffuse.copyFrom(value); },
                    getTarget: function (light) { return light._babylonLight; },
                    getPropertyName: [function (_light) { return "diffuse"; }],
                },
                intensity: {
                    type: "number",
                    get: function (light) { var _a; return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.intensity; },
                    set: function (value, light) { return (light._babylonLight ? (light._babylonLight.intensity = value) : undefined); },
                    getTarget: function (light) { return light._babylonLight; },
                    getPropertyName: [function (_light) { return "intensity"; }],
                },
                range: {
                    type: "number",
                    get: function (light) { var _a; return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.range; },
                    set: function (value, light) { return (light._babylonLight ? (light._babylonLight.range = value) : undefined); },
                    getTarget: function (light) { return light._babylonLight; },
                    getPropertyName: [function (_light) { return "range"; }],
                },
                spot: {
                    innerConeAngle: {
                        type: "number",
                        get: function (light) { var _a; return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.innerAngle; },
                        set: function (value, light) { return (light._babylonLight ? (light._babylonLight.innerAngle = value) : undefined); },
                        getTarget: function (light) { return light._babylonLight; },
                        getPropertyName: [function (_light) { return "innerConeAngle"; }],
                    },
                    outerConeAngle: {
                        type: "number",
                        get: function (light) { var _a; return (_a = light._babylonLight) === null || _a === void 0 ? void 0 : _a.angle; },
                        set: function (value, light) { return (light._babylonLight ? (light._babylonLight.angle = value) : undefined); },
                        getTarget: function (light) { return light._babylonLight; },
                        getPropertyName: [function (_light) { return "outerConeAngle"; }],
                    },
                },
            },
        },
    },
    EXT_lights_ies: {
        lights: {
            length: {
                type: "number",
                get: function (lights) { return lights.length; },
                getTarget: function (lights) { return lights.map(function (light) { return light._babylonLight; }); },
                getPropertyName: [function (_lights) { return "length"; }],
            },
        },
    },
    EXT_lights_image_based: {
        lights: {
            length: {
                type: "number",
                get: function (lights) { return lights.length; },
                getTarget: function (lights) { return lights.map(function (light) { return light._babylonTexture; }); },
                getPropertyName: [function (_lights) { return "length"; }],
            },
            __array__: {
                __target__: true,
                intensity: {
                    type: "number",
                    get: function (light) { var _a; return (_a = light._babylonTexture) === null || _a === void 0 ? void 0 : _a.level; },
                    set: function (value, light) {
                        if (light._babylonTexture) {
                            light._babylonTexture.level = value;
                        }
                    },
                    getTarget: function (light) { return light._babylonTexture; },
                },
                rotation: {
                    type: "Quaternion",
                    get: function (light) { var _a; return light._babylonTexture && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromRotationMatrix((_a = light._babylonTexture) === null || _a === void 0 ? void 0 : _a.getReflectionTextureMatrix()); },
                    set: function (value, light) {
                        var _a;
                        if (!light._babylonTexture) {
                            return;
                        }
                        // Invert the rotation so that positive rotation is counter-clockwise.
                        if (!((_a = light._babylonTexture.getScene()) === null || _a === void 0 ? void 0 : _a.useRightHandedSystem)) {
                            value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Inverse(value);
                        }
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());
                    },
                    getTarget: function (light) { return light._babylonTexture; },
                },
            },
        },
    },
};
function GetTexture(material, payload, textureType, textureInObject) {
    var babylonMaterial = GetMaterial(material, payload);
    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];
}
function GetMaterial(material, _index, payload) {
    var _a, _b, _c;
    return (_c = (_a = material._data) === null || _a === void 0 ? void 0 : _a[(_b = payload === null || payload === void 0 ? void 0 : payload.fillMode) !== null && _b !== void 0 ? _b : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Constants.MATERIAL_TriangleFillMode]) === null || _c === void 0 ? void 0 : _c.babylonMaterial;
}
function GenerateTextureMap(textureType, textureInObject) {
    return {
        offset: {
            componentsCount: 2,
            // assuming two independent values for u and v, and NOT a Vector2
            type: "Vector2",
            get: function (material, _index, payload) {
                var texture = GetTexture(material, payload, textureType, textureInObject);
                return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(texture === null || texture === void 0 ? void 0 : texture.uOffset, texture === null || texture === void 0 ? void 0 : texture.vOffset);
            },
            getTarget: GetMaterial,
            set: function (value, material, _index, payload) {
                var texture = GetTexture(material, payload, textureType, textureInObject);
                (texture.uOffset = value.x), (texture.vOffset = value.y);
            },
            getPropertyName: [
                function () { return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".uOffset"); },
                function () { return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".vOffset"); },
            ],
        },
        rotation: {
            type: "number",
            get: function (material, _index, payload) { var _a; return (_a = GetTexture(material, payload, textureType, textureInObject)) === null || _a === void 0 ? void 0 : _a.wAng; },
            getTarget: GetMaterial,
            set: function (value, material, _index, payload) { return (GetTexture(material, payload, textureType, textureInObject).wAng = value); },
            getPropertyName: [function () { return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".wAng"); }],
        },
        scale: {
            componentsCount: 2,
            type: "Vector2",
            get: function (material, _index, payload) {
                var texture = GetTexture(material, payload, textureType, textureInObject);
                return new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(texture === null || texture === void 0 ? void 0 : texture.uScale, texture === null || texture === void 0 ? void 0 : texture.vScale);
            },
            getTarget: GetMaterial,
            set: function (value, material, index, payload) {
                var texture = GetTexture(material, payload, textureType, textureInObject);
                (texture.uScale = value.x), (texture.vScale = value.y);
            },
            getPropertyName: [
                function () { return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".uScale"); },
                function () { return "".concat(textureType).concat(textureInObject ? "." + textureInObject : "", ".vScale"); },
            ],
        },
    };
}
var objectModelMapping = {
    cameras: camerasTree,
    nodes: nodesTree,
    materials: materialsTree,
    extensions: extensionsTree,
    animations: animationsTree,
    meshes: meshesTree,
};
/**
 * get a path-to-object converter for the given glTF tree
 * @param gltf the glTF tree to use
 * @returns a path-to-object converter for the given glTF tree
 */
function GetPathToObjectConverter(gltf) {
    return new _gltfPathToObjectConverter__WEBPACK_IMPORTED_MODULE_1__.GLTFPathToObjectConverter(gltf, objectModelMapping);
}
/**
 * This function will return the object accessor for the given key in the object model
 * If the key is not found, it will return undefined
 * @param key the key to get the mapping for, for example /materials/\{\}/emissiveFactor
 * @returns an object accessor for the given key, or undefined if the key is not found
 */
function GetMappingForKey(key) {
    // replace every `{}` in key with __array__ to match the object model
    var keyParts = key.split("/").map(function (part) { return part.replace(/{}/g, "__array__"); });
    var current = objectModelMapping;
    for (var _i = 0, keyParts_1 = keyParts; _i < keyParts_1.length; _i++) {
        var part = keyParts_1[_i];
        // make sure part is not empty
        if (!part) {
            continue;
        }
        current = current[part];
    }
    // validate that current is an object accessor
    if (current && current.type && current.get) {
        return current;
    }
    return undefined;
}
/**
 * Set interpolation for a specific key in the object model
 * @param key the key to set, for example /materials/\{\}/emissiveFactor
 * @param interpolation the interpolation elements array
 */
function SetInterpolationForKey(key, interpolation) {
    // replace every `{}` in key with __array__ to match the object model
    var keyParts = key.split("/").map(function (part) { return part.replace(/{}/g, "__array__"); });
    var current = objectModelMapping;
    for (var _i = 0, keyParts_2 = keyParts; _i < keyParts_2.length; _i++) {
        var part = keyParts_2[_i];
        // make sure part is not empty
        if (!part) {
            continue;
        }
        current = current[part];
    }
    // validate that the current object is an object accessor
    if (current && current.type && current.get) {
        current.interpolation = interpolation;
    }
}
/**
 * This will ad a new object accessor in the object model at the given key.
 * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)
 * @param key the key to add the object accessor at. For example /cameras/\{\}/perspective/aspectRatio
 * @param accessor the object accessor to add
 */
function AddObjectAccessorToKey(key, accessor) {
    // replace every `{}` in key with __array__ to match the object model
    var keyParts = key.split("/").map(function (part) { return part.replace(/{}/g, "__array__"); });
    var current = objectModelMapping;
    for (var _i = 0, keyParts_3 = keyParts; _i < keyParts_3.length; _i++) {
        var part = keyParts_3[_i];
        // make sure part is not empty
        if (!part) {
            continue;
        }
        if (!current[part]) {
            if (part === "?") {
                current.__ignoreObjectTree__ = true;
                continue;
            }
            current[part] = {};
            // if the part is __array__ then add the __target__ property
            if (part === "__array__") {
                current[part].__target__ = true;
            }
        }
        current = current[part];
    }
    Object.assign(current, accessor);
}


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts":
/*!*******************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/glTFLoader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayItem: () => (/* binding */ ArrayItem),
/* harmony export */   GLTFFileLoader: () => (/* reexport safe */ _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFFileLoader),
/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader),
/* harmony export */   LoadBoundingInfoFromPositionAccessor: () => (/* binding */ LoadBoundingInfoFromPositionAccessor)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Buffers/bufferUtils */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glTFFileLoader */ "../../../dev/loaders/src/glTF/glTFFileLoader.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Extensions/objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");




























/**
 * Helper class for working with arrays when loading the glTF asset
 */
var ArrayItem = /** @class */ (function () {
    function ArrayItem() {
    }
    /**
     * Gets an item from the given array.
     * @param context The context when loading the asset
     * @param array The array to get the item from
     * @param index The index to the array
     * @returns The array item
     */
    ArrayItem.Get = function (context, array, index) {
        if (!array || index == undefined || !array[index]) {
            throw new Error("".concat(context, ": Failed to find index (").concat(index, ")"));
        }
        return array[index];
    };
    /**
     * Gets an item from the given array or returns null if not available.
     * @param array The array to get the item from
     * @param index The index to the array
     * @returns The array item or null
     */
    ArrayItem.TryGet = function (array, index) {
        if (!array || index == undefined || !array[index]) {
            return null;
        }
        return array[index];
    };
    /**
     * Assign an `index` field to each item of the given array.
     * @param array The array of items
     */
    ArrayItem.Assign = function (array) {
        if (array) {
            for (var index = 0; index < array.length; index++) {
                array[index].index = index;
            }
        }
    };
    return ArrayItem;
}());

/** @internal */
function LoadBoundingInfoFromPositionAccessor(accessor) {
    if (accessor.min && accessor.max) {
        var minArray = accessor.min;
        var maxArray = accessor.max;
        var minVector = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0].copyFromFloats(minArray[0], minArray[1], minArray[2]);
        var maxVector = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1].copyFromFloats(maxArray[0], maxArray[1], maxArray[2]);
        if (accessor.normalized && accessor.componentType !== 5126 /* AccessorComponentType.FLOAT */) {
            var divider = 1;
            switch (accessor.componentType) {
                case 5120 /* AccessorComponentType.BYTE */:
                    divider = 127.0;
                    break;
                case 5121 /* AccessorComponentType.UNSIGNED_BYTE */:
                    divider = 255.0;
                    break;
                case 5122 /* AccessorComponentType.SHORT */:
                    divider = 32767.0;
                    break;
                case 5123 /* AccessorComponentType.UNSIGNED_SHORT */:
                    divider = 65535.0;
                    break;
            }
            var oneOverDivider = 1 / divider;
            minVector.scaleInPlace(oneOverDivider);
            maxVector.scaleInPlace(oneOverDivider);
        }
        return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.BoundingInfo(minVector, maxVector);
    }
    return null;
}
/**
 * The glTF 2.0 loader
 */
var GLTFLoader = /** @class */ (function () {
    /**
     * @internal
     */
    function GLTFLoader(parent) {
        /** @internal */
        this._completePromises = new Array();
        /** @internal */
        this._assetContainer = null;
        /** Storage */
        this._babylonLights = [];
        /** @internal */
        this._disableInstancedMesh = 0;
        /** @internal */
        this._allMaterialsDirtyRequired = false;
        /** @internal */
        this._skipStartAnimationStep = false;
        this._extensions = new Array();
        this._disposed = false;
        this._rootUrl = null;
        this._fileName = null;
        this._uniqueRootUrl = null;
        this._bin = null;
        this._rootBabylonMesh = null;
        this._defaultBabylonMaterialData = {};
        this._postSceneLoadActions = new Array();
        this._parent = parent;
    }
    /**
     * Registers a loader extension.
     * @param name The name of the loader extension.
     * @param factory The factory function that creates the loader extension.
     * @deprecated Please use registerGLTFExtension instead.
     */
    GLTFLoader.RegisterExtension = function (name, factory) {
        (0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension)(name, false, factory);
    };
    /**
     * Unregisters a loader extension.
     * @param name The name of the loader extension.
     * @returns A boolean indicating whether the extension has been unregistered
     * @deprecated Please use unregisterGLTFExtension instead.
     */
    GLTFLoader.UnregisterExtension = function (name) {
        return (0,_glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)(name);
    };
    Object.defineProperty(GLTFLoader.prototype, "gltf", {
        /**
         * The object that represents the glTF JSON.
         */
        get: function () {
            if (!this._gltf) {
                throw new Error("glTF JSON is not available");
            }
            return this._gltf;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "bin", {
        /**
         * The BIN chunk of a binary glTF.
         */
        get: function () {
            return this._bin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "parent", {
        /**
         * The parent file loader.
         */
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "babylonScene", {
        /**
         * The Babylon scene when loading the asset.
         */
        get: function () {
            if (!this._babylonScene) {
                throw new Error("Scene is not available");
            }
            return this._babylonScene;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "rootBabylonMesh", {
        /**
         * The root Babylon node when loading the asset.
         */
        get: function () {
            return this._rootBabylonMesh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFLoader.prototype, "rootUrl", {
        /**
         * The root url when loading the asset.
         */
        get: function () {
            return this._rootUrl;
        },
        enumerable: false,
        configurable: true
    });
    /** @internal */
    GLTFLoader.prototype.dispose = function () {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this._completePromises.length = 0;
        this._extensions.forEach(function (extension) { return extension.dispose && extension.dispose(); });
        this._extensions.length = 0;
        this._gltf = null; // TODO
        this._bin = null;
        this._babylonScene = null; // TODO
        this._rootBabylonMesh = null;
        this._defaultBabylonMaterialData = {};
        this._postSceneLoadActions.length = 0;
        this._parent.dispose();
    };
    /**
     * @internal
     */
    GLTFLoader.prototype.importMeshAsync = function (meshesNames_1, scene_1, container_1, data_1, rootUrl_1, onProgress_1) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, arguments, void 0, function (meshesNames, scene, container, data, rootUrl, onProgress, fileName) {
            var _this = this;
            if (fileName === void 0) { fileName = ""; }
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.resolve().then(function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function () {
                            var nodes, nodeMap_1, _i, _a, node, names;
                            var _this = this;
                            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        this._babylonScene = scene;
                                        this._assetContainer = container;
                                        this._loadData(data);
                                        nodes = null;
                                        if (meshesNames) {
                                            nodeMap_1 = {};
                                            if (this._gltf.nodes) {
                                                for (_i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {
                                                    node = _a[_i];
                                                    if (node.name) {
                                                        nodeMap_1[node.name] = node.index;
                                                    }
                                                }
                                            }
                                            names = meshesNames instanceof Array ? meshesNames : [meshesNames];
                                            nodes = names.map(function (name) {
                                                var node = nodeMap_1[name];
                                                if (node === undefined) {
                                                    throw new Error("Failed to find node '".concat(name, "'"));
                                                }
                                                return node;
                                            });
                                        }
                                        return [4 /*yield*/, this._loadAsync(rootUrl, fileName, nodes, function () {
                                                return {
                                                    meshes: _this._getMeshes(),
                                                    particleSystems: [],
                                                    skeletons: _this._getSkeletons(),
                                                    animationGroups: _this._getAnimationGroups(),
                                                    lights: _this._babylonLights,
                                                    transformNodes: _this._getTransformNodes(),
                                                    geometries: _this._getGeometries(),
                                                    spriteManagers: [],
                                                };
                                            })];
                                    case 1: return [2 /*return*/, _b.sent()];
                                }
                            });
                        }); })];
                    case 1: 
                    // eslint-disable-next-line github/no-then
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * @internal
     */
    GLTFLoader.prototype.loadAsync = function (scene_1, data_1, rootUrl_1, onProgress_1) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, arguments, void 0, function (scene, data, rootUrl, onProgress, fileName) {
            if (fileName === void 0) { fileName = ""; }
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._babylonScene = scene;
                        this._loadData(data);
                        return [4 /*yield*/, this._loadAsync(rootUrl, fileName, null, function () { return undefined; })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    GLTFLoader.prototype._loadAsync = function (rootUrl, fileName, nodes, resultFunc) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function () {
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.resolve()
                            .then(function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function () {
                            var loadingToReadyCounterName, loadingToCompleteCounterName, promises, oldBlockMaterialDirtyMechanism, scene, m, material, context_1, babylonDrawMode, resultPromise;
                            var _this = this;
                            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        this._rootUrl = rootUrl;
                                        this._uniqueRootUrl = !rootUrl.startsWith("file:") && fileName ? rootUrl : "".concat(rootUrl).concat(Date.now(), "/");
                                        this._fileName = fileName;
                                        this._allMaterialsDirtyRequired = false;
                                        return [4 /*yield*/, this._loadExtensionsAsync()];
                                    case 1:
                                        _a.sent();
                                        loadingToReadyCounterName = "".concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING], " => ").concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.READY]);
                                        loadingToCompleteCounterName = "".concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING], " => ").concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.COMPLETE]);
                                        this._parent._startPerformanceCounter(loadingToReadyCounterName);
                                        this._parent._startPerformanceCounter(loadingToCompleteCounterName);
                                        this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING);
                                        this._extensionsOnLoading();
                                        promises = new Array();
                                        oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;
                                        this._babylonScene.blockMaterialDirtyMechanism = true;
                                        if (!this.parent.loadOnlyMaterials) {
                                            if (nodes) {
                                                promises.push(this.loadSceneAsync("/nodes", { nodes: nodes, index: -1 }));
                                            }
                                            else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {
                                                scene = ArrayItem.Get("/scene", this._gltf.scenes, this._gltf.scene || 0);
                                                promises.push(this.loadSceneAsync("/scenes/".concat(scene.index), scene));
                                            }
                                        }
                                        if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {
                                            for (m = 0; m < this._gltf.materials.length; ++m) {
                                                material = this._gltf.materials[m];
                                                context_1 = "/materials/" + m;
                                                babylonDrawMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFillMode;
                                                promises.push(this._loadMaterialAsync(context_1, material, null, babylonDrawMode, function () { }));
                                            }
                                        }
                                        // Restore the blocking of material dirty.
                                        if (this._allMaterialsDirtyRequired) {
                                            // This can happen if we add a light for instance as it will impact the whole scene.
                                            // This automatically resets everything if needed.
                                            this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;
                                        }
                                        else {
                                            // By default a newly created material is dirty so there is no need to flag the full scene as dirty.
                                            // For perf reasons, we then bypass blockMaterialDirtyMechanism as this would "dirty" the entire scene.
                                            this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);
                                        }
                                        if (this._parent.compileMaterials) {
                                            promises.push(this._compileMaterialsAsync());
                                        }
                                        if (this._parent.compileShadowGenerators) {
                                            promises.push(this._compileShadowGeneratorsAsync());
                                        }
                                        resultPromise = Promise.all(promises).then(function () {
                                            if (_this._rootBabylonMesh && _this._rootBabylonMesh !== _this._parent.customRootNode) {
                                                _this._rootBabylonMesh.setEnabled(true);
                                            }
                                            // Making sure we enable enough lights to have all lights together
                                            for (var _i = 0, _a = _this._babylonScene.materials; _i < _a.length; _i++) {
                                                var material = _a[_i];
                                                var mat = material;
                                                if (mat.maxSimultaneousLights !== undefined) {
                                                    mat.maxSimultaneousLights = Math.max(mat.maxSimultaneousLights, _this._babylonScene.lights.length);
                                                }
                                            }
                                            _this._extensionsOnReady();
                                            _this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.READY);
                                            if (!_this._skipStartAnimationStep) {
                                                _this._startAnimations();
                                            }
                                            return resultFunc();
                                        });
                                        return [4 /*yield*/, resultPromise.then(function (result) {
                                                _this._parent._endPerformanceCounter(loadingToReadyCounterName);
                                                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Tools.SetImmediate(function () {
                                                    if (!_this._disposed) {
                                                        Promise.all(_this._completePromises).then(function () {
                                                            _this._parent._endPerformanceCounter(loadingToCompleteCounterName);
                                                            _this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.COMPLETE);
                                                            _this._parent.onCompleteObservable.notifyObservers(undefined);
                                                            _this._parent.onCompleteObservable.clear();
                                                            _this.dispose();
                                                        }, function (error) {
                                                            _this._parent.onErrorObservable.notifyObservers(error);
                                                            _this._parent.onErrorObservable.clear();
                                                            _this.dispose();
                                                        });
                                                    }
                                                });
                                                return result;
                                            })];
                                    case 2: return [2 /*return*/, _a.sent()];
                                }
                            });
                        }); })
                            .catch(function (error) {
                            if (!_this._disposed) {
                                _this._parent.onErrorObservable.notifyObservers(error);
                                _this._parent.onErrorObservable.clear();
                                _this.dispose();
                            }
                            throw error;
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    GLTFLoader.prototype._loadData = function (data) {
        this._gltf = data.json;
        this._setupData();
        if (data.bin) {
            var buffers = this._gltf.buffers;
            if (buffers && buffers[0] && !buffers[0].uri) {
                var binaryBuffer = buffers[0];
                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {
                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Binary buffer length (".concat(binaryBuffer.byteLength, ") from JSON does not match chunk length (").concat(data.bin.byteLength, ")"));
                }
                this._bin = data.bin;
            }
            else {
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Unexpected BIN chunk");
            }
        }
    };
    GLTFLoader.prototype._setupData = function () {
        ArrayItem.Assign(this._gltf.accessors);
        ArrayItem.Assign(this._gltf.animations);
        ArrayItem.Assign(this._gltf.buffers);
        ArrayItem.Assign(this._gltf.bufferViews);
        ArrayItem.Assign(this._gltf.cameras);
        ArrayItem.Assign(this._gltf.images);
        ArrayItem.Assign(this._gltf.materials);
        ArrayItem.Assign(this._gltf.meshes);
        ArrayItem.Assign(this._gltf.nodes);
        ArrayItem.Assign(this._gltf.samplers);
        ArrayItem.Assign(this._gltf.scenes);
        ArrayItem.Assign(this._gltf.skins);
        ArrayItem.Assign(this._gltf.textures);
        if (this._gltf.nodes) {
            var nodeParents = {};
            for (var _i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.children) {
                    for (var _b = 0, _c = node.children; _b < _c.length; _b++) {
                        var index = _c[_b];
                        nodeParents[index] = node.index;
                    }
                }
            }
            var rootNode = this._createRootNode();
            for (var _d = 0, _e = this._gltf.nodes; _d < _e.length; _d++) {
                var node = _e[_d];
                var parentIndex = nodeParents[node.index];
                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];
            }
        }
    };
    GLTFLoader.prototype._loadExtensionsAsync = function () {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function () {
            var extensionPromises, _a, _b, _c, _loop_1, this_1, _i, _d, name_1;
            var _e;
            var _this = this;
            var _f;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        extensionPromises = [];
                        _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registeredGLTFExtensions.forEach(function (registeredExtension, name) {
                            var _a;
                            // Don't load explicitly disabled extensions.
                            if (((_a = _this.parent.extensionOptions[name]) === null || _a === void 0 ? void 0 : _a.enabled) === false) {
                                // But warn if the disabled extension is used by the model.
                                if (registeredExtension.isGLTFExtension && _this.isExtensionUsed(name)) {
                                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Extension ".concat(name, " is used but has been explicitly disabled."));
                                }
                            }
                            // Load loader extensions that are not a glTF extension, as well as extensions that are glTF extensions and are used by the model.
                            else if (!registeredExtension.isGLTFExtension || _this.isExtensionUsed(name)) {
                                extensionPromises.push((function () { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function () {
                                    var extension;
                                    return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, registeredExtension.factory(this)];
                                            case 1:
                                                extension = _a.sent();
                                                if (extension.name !== name) {
                                                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("The name of the glTF loader extension instance does not match the registered name: ".concat(extension.name, " !== ").concat(name));
                                                }
                                                this._parent.onExtensionLoadedObservable.notifyObservers(extension);
                                                return [2 /*return*/, extension];
                                        }
                                    });
                                }); })());
                            }
                        });
                        _b = (_a = (_e = this._extensions).push).apply;
                        _c = [_e];
                        return [4 /*yield*/, Promise.all(extensionPromises)];
                    case 1:
                        _b.apply(_a, _c.concat([(_g.sent())]));
                        this._extensions.sort(function (a, b) { return (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE); });
                        this._parent.onExtensionLoadedObservable.clear();
                        if (this._gltf.extensionsRequired) {
                            _loop_1 = function (name_1) {
                                var available = this_1._extensions.some(function (extension) { return extension.name === name_1 && extension.enabled; });
                                if (!available) {
                                    if (((_f = this_1.parent.extensionOptions[name_1]) === null || _f === void 0 ? void 0 : _f.enabled) === false) {
                                        throw new Error("Required extension ".concat(name_1, " is disabled"));
                                    }
                                    throw new Error("Required extension ".concat(name_1, " is not available"));
                                }
                            };
                            this_1 = this;
                            for (_i = 0, _d = this._gltf.extensionsRequired; _i < _d.length; _i++) {
                                name_1 = _d[_i];
                                _loop_1(name_1);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GLTFLoader.prototype._createRootNode = function () {
        if (this._parent.customRootNode !== undefined) {
            this._rootBabylonMesh = this._parent.customRootNode;
            return {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                _babylonTransformNode: this._rootBabylonMesh === null ? undefined : this._rootBabylonMesh,
                index: -1,
            };
        }
        this._babylonScene._blockEntityCollection = !!this._assetContainer;
        var rootMesh = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Mesh("__root__", this._babylonScene);
        this._rootBabylonMesh = rootMesh;
        this._rootBabylonMesh._parentContainer = this._assetContainer;
        this._babylonScene._blockEntityCollection = false;
        this._rootBabylonMesh.setEnabled(false);
        var rootNode = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            _babylonTransformNode: this._rootBabylonMesh,
            index: -1,
        };
        switch (this._parent.coordinateSystemMode) {
            case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderCoordinateSystemMode.AUTO: {
                if (!this._babylonScene.useRightHandedSystem) {
                    rootNode.rotation = [0, 1, 0, 0];
                    rootNode.scale = [1, 1, -1];
                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);
                }
                break;
            }
            case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {
                this._babylonScene.useRightHandedSystem = true;
                break;
            }
            default: {
                throw new Error("Invalid coordinate system mode (".concat(this._parent.coordinateSystemMode, ")"));
            }
        }
        this._parent.onMeshLoadedObservable.notifyObservers(rootMesh);
        return rootNode;
    };
    /**
     * Loads a glTF scene.
     * @param context The context when loading the asset
     * @param scene The glTF scene property
     * @returns A promise that resolves when the load is complete
     */
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
    GLTFLoader.prototype.loadSceneAsync = function (context, scene) {
        var _this = this;
        var extensionPromise = this._extensionsLoadSceneAsync(context, scene);
        if (extensionPromise) {
            return extensionPromise;
        }
        var promises = new Array();
        this.logOpen("".concat(context, " ").concat(scene.name || ""));
        if (scene.nodes) {
            for (var _i = 0, _a = scene.nodes; _i < _a.length; _i++) {
                var index = _a[_i];
                var node = ArrayItem.Get("".concat(context, "/nodes/").concat(index), this._gltf.nodes, index);
                promises.push(this.loadNodeAsync("/nodes/".concat(node.index), node, function (babylonMesh) {
                    babylonMesh.parent = _this._rootBabylonMesh;
                }));
            }
        }
        for (var _b = 0, _c = this._postSceneLoadActions; _b < _c.length; _b++) {
            var action = _c[_b];
            action();
        }
        promises.push(this._loadAnimationsAsync());
        this.logClose();
        return Promise.all(promises).then(function () { });
    };
    GLTFLoader.prototype._forEachPrimitive = function (node, callback) {
        if (node._primitiveBabylonMeshes) {
            for (var _i = 0, _a = node._primitiveBabylonMeshes; _i < _a.length; _i++) {
                var babylonMesh = _a[_i];
                callback(babylonMesh);
            }
        }
    };
    GLTFLoader.prototype._getGeometries = function () {
        var geometries = [];
        var nodes = this._gltf.nodes;
        if (nodes) {
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                this._forEachPrimitive(node, function (babylonMesh) {
                    var geometry = babylonMesh.geometry;
                    if (geometry && geometries.indexOf(geometry) === -1) {
                        geometries.push(geometry);
                    }
                });
            }
        }
        return geometries;
    };
    GLTFLoader.prototype._getMeshes = function () {
        var meshes = [];
        // Root mesh is always first, if available.
        if (this._rootBabylonMesh instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.AbstractMesh) {
            meshes.push(this._rootBabylonMesh);
        }
        var nodes = this._gltf.nodes;
        if (nodes) {
            for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                var node = nodes_2[_i];
                this._forEachPrimitive(node, function (babylonMesh) {
                    meshes.push(babylonMesh);
                });
            }
        }
        return meshes;
    };
    GLTFLoader.prototype._getTransformNodes = function () {
        var transformNodes = [];
        var nodes = this._gltf.nodes;
        if (nodes) {
            for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
                var node = nodes_3[_i];
                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === "TransformNode") {
                    transformNodes.push(node._babylonTransformNode);
                }
                if (node._babylonTransformNodeForSkin) {
                    transformNodes.push(node._babylonTransformNodeForSkin);
                }
            }
        }
        return transformNodes;
    };
    GLTFLoader.prototype._getSkeletons = function () {
        var skeletons = [];
        var skins = this._gltf.skins;
        if (skins) {
            for (var _i = 0, skins_1 = skins; _i < skins_1.length; _i++) {
                var skin = skins_1[_i];
                if (skin._data) {
                    skeletons.push(skin._data.babylonSkeleton);
                }
            }
        }
        return skeletons;
    };
    GLTFLoader.prototype._getAnimationGroups = function () {
        var animationGroups = [];
        var animations = this._gltf.animations;
        if (animations) {
            for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                var animation = animations_1[_i];
                if (animation._babylonAnimationGroup) {
                    animationGroups.push(animation._babylonAnimationGroup);
                }
            }
        }
        return animationGroups;
    };
    GLTFLoader.prototype._startAnimations = function () {
        switch (this._parent.animationStartMode) {
            case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.NONE: {
                // do nothing
                break;
            }
            case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.FIRST: {
                var babylonAnimationGroups = this._getAnimationGroups();
                if (babylonAnimationGroups.length !== 0) {
                    babylonAnimationGroups[0].start(true);
                }
                break;
            }
            case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.ALL: {
                var babylonAnimationGroups = this._getAnimationGroups();
                for (var _i = 0, babylonAnimationGroups_1 = babylonAnimationGroups; _i < babylonAnimationGroups_1.length; _i++) {
                    var babylonAnimationGroup = babylonAnimationGroups_1[_i];
                    babylonAnimationGroup.start(true);
                }
                break;
            }
            default: {
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Invalid animation start mode (".concat(this._parent.animationStartMode, ")"));
                return;
            }
        }
    };
    /**
     * Loads a glTF node.
     * @param context The context when loading the asset
     * @param node The glTF node property
     * @param assign A function called synchronously after parsing the glTF properties
     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype.loadNodeAsync = function (context, node, assign) {
        var _this = this;
        if (assign === void 0) { assign = function () { }; }
        var extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);
        if (extensionPromise) {
            return extensionPromise;
        }
        if (node._babylonTransformNode) {
            throw new Error("".concat(context, ": Invalid recursive node hierarchy"));
        }
        var promises = new Array();
        this.logOpen("".concat(context, " ").concat(node.name || ""));
        var loadNode = function (babylonTransformNode) {
            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);
            GLTFLoader._LoadTransform(node, babylonTransformNode);
            if (node.camera != undefined) {
                var camera = ArrayItem.Get("".concat(context, "/camera"), _this._gltf.cameras, node.camera);
                promises.push(_this.loadCameraAsync("/cameras/".concat(camera.index), camera, function (babylonCamera) {
                    babylonCamera.parent = babylonTransformNode;
                    if (!_this._babylonScene.useRightHandedSystem) {
                        babylonTransformNode.scaling.x = -1; // Cancelling root node scaling for handedness so the view matrix does not end up flipped.
                    }
                }));
            }
            if (node.children) {
                for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                    var index = _a[_i];
                    var childNode = ArrayItem.Get("".concat(context, "/children/").concat(index), _this._gltf.nodes, index);
                    promises.push(_this.loadNodeAsync("/nodes/".concat(childNode.index), childNode, function (childBabylonMesh) {
                        childBabylonMesh.parent = babylonTransformNode;
                    }));
                }
            }
            assign(babylonTransformNode);
        };
        var hasMesh = node.mesh != undefined;
        var hasSkin = this._parent.loadSkins && node.skin != undefined;
        if (!hasMesh || hasSkin) {
            var nodeName = node.name || "node".concat(node.index);
            this._babylonScene._blockEntityCollection = !!this._assetContainer;
            var transformNode = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TransformNode(nodeName, this._babylonScene);
            transformNode._parentContainer = this._assetContainer;
            this._babylonScene._blockEntityCollection = false;
            if (node.mesh == undefined) {
                node._babylonTransformNode = transformNode;
            }
            else {
                node._babylonTransformNodeForSkin = transformNode;
            }
            loadNode(transformNode);
        }
        if (hasMesh) {
            if (hasSkin) {
                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)
                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the
                // transform, which effectively ignores the transform of the skinned mesh, as per spec.
                var mesh = ArrayItem.Get("".concat(context, "/mesh"), this._gltf.meshes, node.mesh);
                promises.push(this._loadMeshAsync("/meshes/".concat(mesh.index), node, mesh, function (babylonTransformNode) {
                    var babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;
                    // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.
                    babylonTransformNode.metadata = (0,babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.deepMerge)(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});
                    var skin = ArrayItem.Get("".concat(context, "/skin"), _this._gltf.skins, node.skin);
                    promises.push(_this._loadSkinAsync("/skins/".concat(skin.index), node, skin, function (babylonSkeleton) {
                        _this._forEachPrimitive(node, function (babylonMesh) {
                            babylonMesh.skeleton = babylonSkeleton;
                        });
                        // Wait until all the nodes are parented before parenting the skinned mesh.
                        _this._postSceneLoadActions.push(function () {
                            if (skin.skeleton != undefined) {
                                // Place the skinned mesh node as a sibling of the skeleton root node.
                                // Handle special case when the parent of the skeleton root is the skinned mesh.
                                var parentNode = ArrayItem.Get("/skins/".concat(skin.index, "/skeleton"), _this._gltf.nodes, skin.skeleton).parent;
                                if (node.index === parentNode.index) {
                                    babylonTransformNode.parent = babylonTransformNodeForSkin.parent;
                                }
                                else {
                                    babylonTransformNode.parent = parentNode._babylonTransformNode;
                                }
                            }
                            else {
                                babylonTransformNode.parent = _this._rootBabylonMesh;
                            }
                            _this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });
                        });
                    }));
                }));
            }
            else {
                var mesh = ArrayItem.Get("".concat(context, "/mesh"), this._gltf.meshes, node.mesh);
                promises.push(this._loadMeshAsync("/meshes/".concat(mesh.index), node, mesh, loadNode));
            }
        }
        this.logClose();
        return Promise.all(promises).then(function () {
            _this._forEachPrimitive(node, function (babylonMesh) {
                var asMesh = babylonMesh;
                if (!asMesh.isAnInstance && asMesh.geometry && asMesh.geometry.useBoundingInfoFromGeometry) {
                    // simply apply the world matrices to the bounding info - the extends are already ok
                    babylonMesh._updateBoundingInfo();
                }
                else {
                    babylonMesh.refreshBoundingInfo(true, true);
                }
            });
            return node._babylonTransformNode;
        });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype._loadMeshAsync = function (context, node, mesh, assign) {
        var primitives = mesh.primitives;
        if (!primitives || !primitives.length) {
            throw new Error("".concat(context, ": Primitives are missing"));
        }
        if (primitives[0].index == undefined) {
            ArrayItem.Assign(primitives);
        }
        var promises = new Array();
        this.logOpen("".concat(context, " ").concat(mesh.name || ""));
        var name = node.name || "node".concat(node.index);
        if (primitives.length === 1) {
            var primitive = mesh.primitives[0];
            promises.push(this._loadMeshPrimitiveAsync("".concat(context, "/primitives/").concat(primitive.index), name, node, mesh, primitive, function (babylonMesh) {
                node._babylonTransformNode = babylonMesh;
                node._primitiveBabylonMeshes = [babylonMesh];
            }));
        }
        else {
            this._babylonScene._blockEntityCollection = !!this._assetContainer;
            node._babylonTransformNode = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TransformNode(name, this._babylonScene);
            node._babylonTransformNode._parentContainer = this._assetContainer;
            this._babylonScene._blockEntityCollection = false;
            node._primitiveBabylonMeshes = [];
            for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
                var primitive = primitives_1[_i];
                promises.push(this._loadMeshPrimitiveAsync("".concat(context, "/primitives/").concat(primitive.index), "".concat(name, "_primitive").concat(primitive.index), node, mesh, primitive, function (babylonMesh) {
                    babylonMesh.parent = node._babylonTransformNode;
                    node._primitiveBabylonMeshes.push(babylonMesh);
                }));
            }
        }
        assign(node._babylonTransformNode);
        this.logClose();
        return Promise.all(promises).then(function () {
            return node._babylonTransformNode;
        });
    };
    /**
     * @internal Define this method to modify the default behavior when loading data for mesh primitives.
     * @param context The context when loading the asset
     * @param name The mesh name when loading the asset
     * @param node The glTF node when loading the asset
     * @param mesh The glTF mesh when loading the asset
     * @param primitive The glTF mesh primitive property
     * @param assign A function called synchronously after parsing the glTF properties
     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype._loadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {
        var _this = this;
        var extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);
        if (extensionPromise) {
            return extensionPromise;
        }
        this.logOpen("".concat(context));
        var shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;
        var babylonAbstractMesh;
        var promise;
        if (shouldInstance && primitive._instanceData) {
            this._babylonScene._blockEntityCollection = !!this._assetContainer;
            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);
            babylonAbstractMesh._parentContainer = this._assetContainer;
            this._babylonScene._blockEntityCollection = false;
            promise = primitive._instanceData.promise;
        }
        else {
            var promises = new Array();
            this._babylonScene._blockEntityCollection = !!this._assetContainer;
            var babylonMesh_1 = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Mesh(name, this._babylonScene);
            babylonMesh_1._parentContainer = this._assetContainer;
            this._babylonScene._blockEntityCollection = false;
            babylonMesh_1.sideOrientation = this._babylonScene.useRightHandedSystem ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.CounterClockWiseSideOrientation : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.ClockWiseSideOrientation;
            this._createMorphTargets(context, node, mesh, primitive, babylonMesh_1);
            promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh_1).then(function (babylonGeometry) { return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(_this, void 0, void 0, function () {
                var _this = this;
                return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._loadMorphTargetsAsync(context, primitive, babylonMesh_1, babylonGeometry).then(function () {
                                if (_this._disposed) {
                                    return;
                                }
                                _this._babylonScene._blockEntityCollection = !!_this._assetContainer;
                                babylonGeometry.applyToMesh(babylonMesh_1);
                                babylonGeometry._parentContainer = _this._assetContainer;
                                _this._babylonScene._blockEntityCollection = false;
                            })];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            }); }));
            var babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);
            if (primitive.material == undefined) {
                var babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];
                if (!babylonMaterial) {
                    babylonMaterial = this._createDefaultMaterial("__GLTFLoader._default", babylonDrawMode);
                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;
                }
                babylonMesh_1.material = babylonMaterial;
            }
            else if (!this.parent.skipMaterials) {
                var material = ArrayItem.Get("".concat(context, "/material"), this._gltf.materials, primitive.material);
                promises.push(this._loadMaterialAsync("/materials/".concat(material.index), material, babylonMesh_1, babylonDrawMode, function (babylonMaterial) {
                    babylonMesh_1.material = babylonMaterial;
                }));
            }
            promise = Promise.all(promises);
            if (shouldInstance) {
                primitive._instanceData = {
                    babylonSourceMesh: babylonMesh_1,
                    promise: promise,
                };
            }
            babylonAbstractMesh = babylonMesh_1;
        }
        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);
        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);
        assign(babylonAbstractMesh);
        this.logClose();
        return promise.then(function () {
            return babylonAbstractMesh;
        });
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype._loadVertexDataAsync = function (context, primitive, babylonMesh) {
        var _this = this;
        var extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);
        if (extensionPromise) {
            return extensionPromise;
        }
        var attributes = primitive.attributes;
        if (!attributes) {
            throw new Error("".concat(context, ": Attributes are missing"));
        }
        var promises = new Array();
        var babylonGeometry = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Geometry(babylonMesh.name, this._babylonScene);
        if (primitive.indices == undefined) {
            babylonMesh.isUnIndexed = true;
        }
        else {
            var accessor = ArrayItem.Get("".concat(context, "/indices"), this._gltf.accessors, primitive.indices);
            promises.push(this._loadIndicesAccessorAsync("/accessors/".concat(accessor.index), accessor).then(function (data) {
                babylonGeometry.setIndices(data);
            }));
        }
        var loadAttribute = function (name, kind, callback) {
            if (attributes[name] == undefined) {
                return;
            }
            babylonMesh._delayInfo = babylonMesh._delayInfo || [];
            if (babylonMesh._delayInfo.indexOf(kind) === -1) {
                babylonMesh._delayInfo.push(kind);
            }
            var accessor = ArrayItem.Get("".concat(context, "/attributes/").concat(name), _this._gltf.accessors, attributes[name]);
            promises.push(_this._loadVertexAccessorAsync("/accessors/".concat(accessor.index), accessor, kind).then(function (babylonVertexBuffer) {
                if (babylonVertexBuffer.getKind() === babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind && !_this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {
                    var babylonBoundingInfo = LoadBoundingInfoFromPositionAccessor(accessor);
                    if (babylonBoundingInfo) {
                        babylonGeometry._boundingInfo = babylonBoundingInfo;
                        babylonGeometry.useBoundingInfoFromGeometry = true;
                    }
                }
                babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);
            }));
            if (kind == babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesExtraKind) {
                babylonMesh.numBoneInfluencers = 8;
            }
            if (callback) {
                callback(accessor);
            }
        };
        loadAttribute("POSITION", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
        loadAttribute("NORMAL", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
        loadAttribute("TANGENT", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind);
        loadAttribute("TEXCOORD_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind);
        loadAttribute("TEXCOORD_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind);
        loadAttribute("TEXCOORD_2", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV3Kind);
        loadAttribute("TEXCOORD_3", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV4Kind);
        loadAttribute("TEXCOORD_4", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV5Kind);
        loadAttribute("TEXCOORD_5", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV6Kind);
        loadAttribute("JOINTS_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesKind);
        loadAttribute("WEIGHTS_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsKind);
        loadAttribute("JOINTS_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesExtraKind);
        loadAttribute("WEIGHTS_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsExtraKind);
        loadAttribute("COLOR_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind, function (accessor) {
            if (accessor.type === "VEC4" /* AccessorType.VEC4 */) {
                babylonMesh.hasVertexAlpha = true;
            }
        });
        return Promise.all(promises).then(function () {
            return babylonGeometry;
        });
    };
    GLTFLoader.prototype._createMorphTargets = function (context, node, mesh, primitive, babylonMesh) {
        if (!primitive.targets || !this._parent.loadMorphTargets) {
            return;
        }
        if (node._numMorphTargets == undefined) {
            node._numMorphTargets = primitive.targets.length;
        }
        else if (primitive.targets.length !== node._numMorphTargets) {
            throw new Error("".concat(context, ": Primitives do not have the same number of targets"));
        }
        var targetNames = mesh.extras ? mesh.extras.targetNames : null;
        this._babylonScene._blockEntityCollection = !!this._assetContainer;
        babylonMesh.morphTargetManager = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.MorphTargetManager(this._babylonScene);
        babylonMesh.morphTargetManager._parentContainer = this._assetContainer;
        this._babylonScene._blockEntityCollection = false;
        babylonMesh.morphTargetManager.areUpdatesFrozen = true;
        for (var index = 0; index < primitive.targets.length; index++) {
            var weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;
            var name_2 = targetNames ? targetNames[index] : "morphTarget".concat(index);
            babylonMesh.morphTargetManager.addTarget(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.MorphTarget(name_2, weight, babylonMesh.getScene()));
            // TODO: tell the target whether it has positions, normals, tangents
        }
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype._loadMorphTargetsAsync = function (context, primitive, babylonMesh, babylonGeometry) {
        if (!primitive.targets || !this._parent.loadMorphTargets) {
            return Promise.resolve();
        }
        var promises = new Array();
        var morphTargetManager = babylonMesh.morphTargetManager;
        for (var index = 0; index < morphTargetManager.numTargets; index++) {
            var babylonMorphTarget = morphTargetManager.getTarget(index);
            promises.push(this._loadMorphTargetVertexDataAsync("".concat(context, "/targets/").concat(index), babylonGeometry, primitive.targets[index], babylonMorphTarget));
        }
        return Promise.all(promises).then(function () {
            morphTargetManager.areUpdatesFrozen = false;
        });
    };
    GLTFLoader.prototype._loadMorphTargetVertexDataAsync = function (context, babylonGeometry, attributes, babylonMorphTarget) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function () {
            var promises, loadAttribute;
            var _this = this;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = new Array();
                        loadAttribute = function (attribute, kind, setData) {
                            if (attributes[attribute] == undefined) {
                                return;
                            }
                            var babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);
                            if (!babylonVertexBuffer) {
                                return;
                            }
                            var accessor = ArrayItem.Get("".concat(context, "/").concat(attribute), _this._gltf.accessors, attributes[attribute]);
                            promises.push(_this._loadFloatAccessorAsync("/accessors/".concat(accessor.index), accessor).then(function (data) {
                                setData(babylonVertexBuffer, data);
                            }));
                        };
                        loadAttribute("POSITION", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, function (babylonVertexBuffer, data) {
                            var positions = new Float32Array(data.length);
                            babylonVertexBuffer.forEach(data.length, function (value, index) {
                                positions[index] = data[index] + value;
                            });
                            babylonMorphTarget.setPositions(positions);
                        });
                        loadAttribute("NORMAL", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, function (babylonVertexBuffer, data) {
                            var normals = new Float32Array(data.length);
                            babylonVertexBuffer.forEach(normals.length, function (value, index) {
                                normals[index] = data[index] + value;
                            });
                            babylonMorphTarget.setNormals(normals);
                        });
                        loadAttribute("TANGENT", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind, function (babylonVertexBuffer, data) {
                            var tangents = new Float32Array((data.length / 3) * 4);
                            var dataIndex = 0;
                            babylonVertexBuffer.forEach((data.length / 3) * 4, function (value, index) {
                                // Tangent data for morph targets is stored as xyz delta.
                                // The vertexData.tangent is stored as xyzw.
                                // So we need to skip every fourth vertexData.tangent.
                                if ((index + 1) % 4 !== 0) {
                                    tangents[dataIndex] = data[dataIndex] + value;
                                    dataIndex++;
                                }
                            });
                            babylonMorphTarget.setTangents(tangents);
                        });
                        loadAttribute("TEXCOORD_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind, function (babylonVertexBuffer, data) {
                            var uvs = new Float32Array(data.length);
                            babylonVertexBuffer.forEach(data.length, function (value, index) {
                                uvs[index] = data[index] + value;
                            });
                            babylonMorphTarget.setUVs(uvs);
                        });
                        loadAttribute("TEXCOORD_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind, function (babylonVertexBuffer, data) {
                            var uvs = new Float32Array(data.length);
                            babylonVertexBuffer.forEach(data.length, function (value, index) {
                                uvs[index] = data[index] + value;
                            });
                            babylonMorphTarget.setUV2s(uvs);
                        });
                        loadAttribute("COLOR_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind, function (babylonVertexBuffer, data) {
                            var colors = null;
                            var componentSize = babylonVertexBuffer.getSize();
                            if (componentSize === 3) {
                                colors = new Float32Array((data.length / 3) * 4);
                                babylonVertexBuffer.forEach(data.length, function (value, index) {
                                    var pixid = Math.floor(index / 3);
                                    var channel = index % 3;
                                    colors[4 * pixid + channel] = data[3 * pixid + channel] + value;
                                });
                                for (var i = 0; i < data.length / 3; ++i) {
                                    colors[4 * i + 3] = 1;
                                }
                            }
                            else if (componentSize === 4) {
                                colors = new Float32Array(data.length);
                                babylonVertexBuffer.forEach(data.length, function (value, index) {
                                    colors[index] = data[index] + value;
                                });
                            }
                            else {
                                throw new Error("".concat(context, ": Invalid number of components (").concat(componentSize, ") for COLOR_0 attribute"));
                            }
                            babylonMorphTarget.setColors(colors);
                        });
                        return [4 /*yield*/, Promise.all(promises).then(function () { })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    GLTFLoader._LoadTransform = function (node, babylonNode) {
        // Ignore the TRS of skinned nodes.
        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)
        if (node.skin != undefined) {
            return;
        }
        var position = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        var rotation = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity();
        var scaling = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.One();
        if (node.matrix) {
            var matrix = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArray(node.matrix);
            matrix.decompose(scaling, rotation, position);
        }
        else {
            if (node.translation) {
                position = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.translation);
            }
            if (node.rotation) {
                rotation = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(node.rotation);
            }
            if (node.scale) {
                scaling = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.scale);
            }
        }
        babylonNode.position = position;
        babylonNode.rotationQuaternion = rotation;
        babylonNode.scaling = scaling;
    };
    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    GLTFLoader.prototype._loadSkinAsync = function (context, node, skin, assign) {
        var _this = this;
        if (!this._parent.loadSkins) {
            return Promise.resolve();
        }
        var extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);
        if (extensionPromise) {
            return extensionPromise;
        }
        if (skin._data) {
            assign(skin._data.babylonSkeleton);
            return skin._data.promise;
        }
        var skeletonId = "skeleton".concat(skin.index);
        this._babylonScene._blockEntityCollection = !!this._assetContainer;
        var babylonSkeleton = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);
        babylonSkeleton._parentContainer = this._assetContainer;
        this._babylonScene._blockEntityCollection = false;
        this._loadBones(context, skin, babylonSkeleton);
        var promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(function (inverseBindMatricesData) {
            _this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);
        });
        skin._data = {
            babylonSkeleton: babylonSkeleton,
            promise: promise,
        };
        assign(babylonSkeleton);
        return promise;
    };
    GLTFLoader.prototype._loadBones = function (context, skin, babylonSkeleton) {
        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {
            var rootNode = this._findSkeletonRootNode("".concat(context, "/joints"), skin.joints);
            if (rootNode) {
                if (skin.skeleton === undefined) {
                    skin.skeleton = rootNode.index;
                }
                else {
                    var isParent = function (a, b) {
                        for (; b.parent; b = b.parent) {
                            if (b.parent === a) {
                                return true;
                            }
                        }
                        return false;
                    };
                    var skeletonNode = ArrayItem.Get("".concat(context, "/skeleton"), this._gltf.nodes, skin.skeleton);
                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {
                        babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root"));
                        skin.skeleton = rootNode.index;
                    }
                }
            }
            else {
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Failed to find common root"));
            }
        }
        var babylonBones = {};
        for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
            var index = _a[_i];
            var node = ArrayItem.Get("".concat(context, "/joints/").concat(index), this._gltf.nodes, index);
            this._loadBone(node, skin, babylonSkeleton, babylonBones);
        }
    };
    GLTFLoader.prototype._findSkeletonRootNode = function (context, joints) {
        if (joints.length === 0) {
            return null;
        }
        var paths = {};
        for (var _i = 0, joints_1 = joints; _i < joints_1.length; _i++) {
            var index = joints_1[_i];
            var path = [];
            var node = ArrayItem.Get("".concat(context, "/").concat(index), this._gltf.nodes, index);
            while (node.index !== -1) {
                path.unshift(node);
                node = node.parent;
            }
            paths[index] = path;
        }
        var rootNode = null;
        for (var i = 0;; ++i) {
            var path = paths[joints[0]];
            if (i >= path.length) {
                return rootNode;
            }
            var node = path[i];
            for (var j = 1; j < joints.length; ++j) {
                path = paths[joints[j]];
                if (i >= path.length || node !== path[i]) {
                    return rootNode;
                }
            }
            rootNode = node;
        }
    };
    GLTFLoader.prototype._loadBone = function (node, skin, babylonSkeleton, babylonBones) {
        node._isJoint = true;
        var babylonBone = babylonBones[node.index];
        if (babylonBone) {
            return babylonBone;
        }
        var parentBabylonBone = null;
        if (node.index !== skin.skeleton) {
            if (node.parent && node.parent.index !== -1) {
                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);
            }
            else if (skin.skeleton !== undefined) {
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("/skins/".concat(skin.index, "/skeleton: Skeleton node is not a common root"));
            }
        }
        var boneIndex = skin.joints.indexOf(node.index);
        babylonBone = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Bone(node.name || "joint".concat(node.index), babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);
        babylonBones[node.index] = babylonBone;
        // Wait until the scene is loaded to ensure the transform nodes are loaded.
        this._postSceneLoadActions.push(function () {
            // Link the Babylon bone with the corresponding Babylon transform node.
            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.
            babylonBone.linkTransformNode(node._babylonTransformNode);
        });
        return babylonBone;
    };
    GLTFLoader.prototype._loadSkinInverseBindMatricesDataAsync = function (context, skin) {
        if (skin.inverseBindMatrices == undefined) {
            return Promise.resolve(null);
        }
        var accessor = ArrayItem.Get("".concat(context, "/inverseBindMatrices"), this._gltf.accessors, skin.inverseBindMatrices);
        return this._loadFloatAccessorAsync("/accessors/".concat(accessor.index), accessor);
    };
    GLTFLoader.prototype._updateBoneMatrices = function (babylonSkeleton, inverseBindMatricesData) {
        for (var _i = 0, _a = babylonSkeleton.bones; _i < _a.length; _i++) {
            var babylonBone = _a[_i];
            var baseMatrix = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.Identity();
            var boneIndex = babylonBone._index;
            if (inverseBindMatricesData && boneIndex !== -1) {
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);
                baseMatrix.invertToRef(baseMatrix);
            }
            var babylonParentBone = babylonBone.getParent();
            if (babylonParentBone) {
                baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);
            }
            babylonBone.updateMatrix(baseMatrix, false, false);
            babylonBone._updateAbsoluteBindMatrices(undefined, false);
        }
    };
    GLTFLoader.prototype._getNodeMatrix = function (node) {
        return node.matrix
            ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArray(node.matrix)
            : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.Compose(node.scale ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.scale) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.One(), node.rotation ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(node.rotation) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity(), node.translation ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.translation) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero());
    };
    /**
     * Loads a glTF camera.
     * @param context The context when loading the asset
     * @param camera The glTF camera property
     * @param assign A function called synchronously after parsing the glTF properties
     * @returns A promise that resolves with the loaded Babylon camera when the load is complete
     */
    GLTFLoader.prototype.loadCameraAsync = function (context, camera, assign) {
        if (assign === void 0) { assign = function () { }; }
        var extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);
        if (extensionPromise) {
            return extensionPromise;
        }
        var promises = new Array();
        this.logOpen("".concat(context, " ").concat(camera.name || ""));
        this._babylonScene._blockEntityCollection = !!this._assetContainer;
        var babylonCamera = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.FreeCamera(camera.name || "camera".concat(camera.index), babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), this._babylonScene, false);
        babylonCamera._parentContainer = this._assetContainer;
        this._babylonScene._blockEntityCollection = false;
        camera._babylonCamera = babylonCamera;
        // glTF cameras look towards the local -Z axis.
        babylonCamera.setTarget(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1));
        switch (camera.type) {
            case "perspective" /* CameraType.PERSPECTIVE */: {
                var perspective = camera.perspective;
                if (!perspective) {
                    throw new Error("".concat(context, ": Camera perspective properties are missing"));
                }
                babylonCamera.fov = perspective.yfov;
                babylonCamera.minZ = perspective.znear;
                babylonCamera.maxZ = perspective.zfar || 0;
                break;
            }
            case "orthographic" /* CameraType.ORTHOGRAPHIC */: {
                if (!camera.orthographic) {
                    throw new Error("".concat(context, ": Camera orthographic properties are missing"));
                }
                babylonCamera.mode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Camera.ORTHOGRAPHIC_CAMERA;
                babylonCamera.orthoLeft = -camera.orthographic.xmag;
                babylonCamera.orthoRight = camera.orthographic.xmag;
                babylonCamera.orthoBottom = -camera.orthographic.ymag;
                babylonCamera.orthoTop = camera.orthographic.ymag;
                babylonCamera.minZ = camera.orthographic.znear;
                babylonCamera.maxZ = camera.orthographic.zfar;
                break;
            }
            default: {
                throw new Error("".concat(context, ": Invalid camera type (").concat(camera.type, ")"));
            }
        }
        GLTFLoader.AddPointerMetadata(babylonCamera, context);
        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);
        assign(babylonCamera);
        this.logClose();
        return Promise.all(promises).then(function () {
            return babylonCamera;
        });
    };
    GLTFLoader.prototype._loadAnimationsAsync = function () {
        var animations = this._gltf.animations;
        if (!animations) {
            return Promise.resolve();
        }
        var promises = new Array();
        for (var index = 0; index < animations.length; index++) {
            var animation = animations[index];
            promises.push(this.loadAnimationAsync("/animations/".concat(animation.index), animation).then(function (animationGroup) {
                // Delete the animation group if it ended up not having any animations in it.
                if (animationGroup.targetedAnimations.length === 0) {
                    animationGroup.dispose();
                }
            }));
        }
        return Promise.all(promises).then(function () { });
    };
    /**
     * Loads a glTF animation.
     * @param context The context when loading the asset
     * @param animation The glTF animation property
     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete
     */
    GLTFLoader.prototype.loadAnimationAsync = function (context, animation) {
        var _this = this;
        var promise = this._extensionsLoadAnimationAsync(context, animation);
        if (promise) {
            return promise;
        }
        // eslint-disable-next-line @typescript-eslint/naming-convention
        return Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! babylonjs/Animations/animationGroup */ "babylonjs/Misc/tools", 23)).then(function (_a) {
            var AnimationGroup = _a.AnimationGroup;
            _this._babylonScene._blockEntityCollection = !!_this._assetContainer;
            var babylonAnimationGroup = new AnimationGroup(animation.name || "animation".concat(animation.index), _this._babylonScene);
            babylonAnimationGroup._parentContainer = _this._assetContainer;
            _this._babylonScene._blockEntityCollection = false;
            animation._babylonAnimationGroup = babylonAnimationGroup;
            var promises = new Array();
            ArrayItem.Assign(animation.channels);
            ArrayItem.Assign(animation.samplers);
            for (var _i = 0, _b = animation.channels; _i < _b.length; _i++) {
                var channel = _b[_i];
                promises.push(_this._loadAnimationChannelAsync("".concat(context, "/channels/").concat(channel.index), context, animation, channel, function (babylonTarget, babylonAnimation) {
                    babylonTarget.animations = babylonTarget.animations || [];
                    babylonTarget.animations.push(babylonAnimation);
                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);
                }));
            }
            return Promise.all(promises).then(function () {
                babylonAnimationGroup.normalize(0);
                return babylonAnimationGroup;
            });
        });
    };
    /**
     * @hidden
     * Loads a glTF animation channel.
     * @param context The context when loading the asset
     * @param animationContext The context of the animation when loading the asset
     * @param animation The glTF animation property
     * @param channel The glTF animation channel property
     * @param onLoad Called for each animation loaded
     * @returns A void promise that resolves when the load is complete
     */
    GLTFLoader.prototype._loadAnimationChannelAsync = function (context, animationContext, animation, channel, onLoad) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__awaiter)(this, void 0, void 0, function () {
            var promise, targetNode, channelTargetPath, pathIsWeights, properties, targetInfo;
            var _a, _b, _c, _d;
            return (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
                        if (!promise) return [3 /*break*/, 2];
                        return [4 /*yield*/, promise];
                    case 1: return [2 /*return*/, _e.sent()];
                    case 2:
                        if (!(channel.target.node == undefined)) return [3 /*break*/, 4];
                        return [4 /*yield*/, Promise.resolve()];
                    case 3: return [2 /*return*/, _e.sent()];
                    case 4:
                        targetNode = ArrayItem.Get("".concat(context, "/target/node"), this._gltf.nodes, channel.target.node);
                        channelTargetPath = channel.target.path;
                        pathIsWeights = channelTargetPath === "weights" /* AnimationChannelTargetPath.WEIGHTS */;
                        if (!((pathIsWeights && !targetNode._numMorphTargets) || (!pathIsWeights && !targetNode._babylonTransformNode))) return [3 /*break*/, 6];
                        return [4 /*yield*/, Promise.resolve()];
                    case 5: return [2 /*return*/, _e.sent()];
                    case 6:
                        if (!(!this._parent.loadNodeAnimations && !pathIsWeights && !targetNode._isJoint)) return [3 /*break*/, 8];
                        return [4 /*yield*/, Promise.resolve()];
                    case 7: return [2 /*return*/, _e.sent()];
                    case 8: 
                    // async-load the animation sampler to provide the interpolation of the channelTargetPath
                    return [4 /*yield*/, Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./glTFLoaderAnimation */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"))];
                    case 9:
                        // async-load the animation sampler to provide the interpolation of the channelTargetPath
                        _e.sent();
                        switch (channelTargetPath) {
                            case "translation" /* AnimationChannelTargetPath.TRANSLATION */: {
                                properties = (_a = (0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/translation")) === null || _a === void 0 ? void 0 : _a.interpolation;
                                break;
                            }
                            case "rotation" /* AnimationChannelTargetPath.ROTATION */: {
                                properties = (_b = (0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/rotation")) === null || _b === void 0 ? void 0 : _b.interpolation;
                                break;
                            }
                            case "scale" /* AnimationChannelTargetPath.SCALE */: {
                                properties = (_c = (0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/scale")) === null || _c === void 0 ? void 0 : _c.interpolation;
                                break;
                            }
                            case "weights" /* AnimationChannelTargetPath.WEIGHTS */: {
                                properties = (_d = (0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_3__.GetMappingForKey)("/nodes/{}/weights")) === null || _d === void 0 ? void 0 : _d.interpolation;
                                break;
                            }
                            default: {
                                throw new Error("".concat(context, "/target/path: Invalid value (").concat(channel.target.path, ")"));
                            }
                        }
                        // stay safe
                        if (!properties) {
                            throw new Error("".concat(context, "/target/path: Could not find interpolation properties for target path (").concat(channel.target.path, ")"));
                        }
                        targetInfo = {
                            object: targetNode,
                            info: properties,
                        };
                        return [4 /*yield*/, this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad)];
                    case 10: return [2 /*return*/, _e.sent()];
                }
            });
        });
    };
    /**
     * @hidden
     * Loads a glTF animation channel.
     * @param context The context when loading the asset
     * @param animationContext The context of the animation when loading the asset
     * @param animation The glTF animation property
     * @param channel The glTF animation channel property
     * @param targetInfo The glTF target and properties
     * @param onLoad Called for each animation loaded
     * @returns A void promise that resolves when the load is complete
     */
    GLTFLoader.prototype._loadAnimationChannelFromTargetInfoAsync = function (context, animationContext, animation, channel, targetInfo, onLoad) {
        var fps = this.parent.targetFps;
        var invfps = 1 / fps;
        var sampler = ArrayItem.Get("".concat(context, "/sampler"), animation.samplers, channel.sampler);
        return this._loadAnimationSamplerAsync("".concat(animationContext, "/samplers/").concat(channel.sampler), sampler).then(function (data) {
            var numAnimations = 0;
            var target = targetInfo.object;
            var propertyInfos = targetInfo.info;
            // Extract the corresponding values from the read value.
            // GLTF values may be dispatched to several Babylon properties.
            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to
            // - albedoColor as Color3(`r`, `g`, `b`)
            // - alpha as `a`
            for (var _i = 0, propertyInfos_1 = propertyInfos; _i < propertyInfos_1.length; _i++) {
                var propertyInfo = propertyInfos_1[_i];
                var stride = propertyInfo.getStride(target);
                var input = data.input;
                var output = data.output;
                var keys = new Array(input.length);
                var outputOffset = 0;
                switch (data.interpolation) {
                    case "STEP" /* AnimationSamplerInterpolation.STEP */: {
                        for (var index = 0; index < input.length; index++) {
                            var value = propertyInfo.getValue(target, output, outputOffset, 1);
                            outputOffset += stride;
                            keys[index] = {
                                frame: input[index] * fps,
                                value: value,
                                interpolation: 1 /* AnimationKeyInterpolation.STEP */,
                            };
                        }
                        break;
                    }
                    case "CUBICSPLINE" /* AnimationSamplerInterpolation.CUBICSPLINE */: {
                        for (var index = 0; index < input.length; index++) {
                            var inTangent = propertyInfo.getValue(target, output, outputOffset, invfps);
                            outputOffset += stride;
                            var value = propertyInfo.getValue(target, output, outputOffset, 1);
                            outputOffset += stride;
                            var outTangent = propertyInfo.getValue(target, output, outputOffset, invfps);
                            outputOffset += stride;
                            keys[index] = {
                                frame: input[index] * fps,
                                inTangent: inTangent,
                                value: value,
                                outTangent: outTangent,
                            };
                        }
                        break;
                    }
                    case "LINEAR" /* AnimationSamplerInterpolation.LINEAR */: {
                        for (var index = 0; index < input.length; index++) {
                            var value = propertyInfo.getValue(target, output, outputOffset, 1);
                            outputOffset += stride;
                            keys[index] = {
                                frame: input[index] * fps,
                                value: value,
                            };
                        }
                        break;
                    }
                }
                if (outputOffset > 0) {
                    var name_3 = "".concat(animation.name || "animation".concat(animation.index), "_channel").concat(channel.index, "_").concat(numAnimations);
                    var babylonAnimations = propertyInfo.buildAnimations(target, name_3, fps, keys);
                    for (var _a = 0, babylonAnimations_1 = babylonAnimations; _a < babylonAnimations_1.length; _a++) {
                        var babylonAnimation = babylonAnimations_1[_a];
                        numAnimations++;
                        onLoad(babylonAnimation.babylonAnimatable, babylonAnimation.babylonAnimation);
                    }
                }
            }
        });
    };
    GLTFLoader.prototype._loadAnimationSamplerAsync = function (context, sampler) {
        if (sampler._data) {
            return sampler._data;
        }
        var interpolation = sampler.interpolation || "LINEAR" /* AnimationSamplerInterpolation.LINEAR */;
        switch (interpolation) {
            case "STEP" /* AnimationSamplerInterpolation.STEP */:
            case "LINEAR" /* AnimationSamplerInterpolation.LINEAR */:
            case "CUBICSPLINE" /* AnimationSamplerInterpolation.CUBICSPLINE */: {
                break;
            }
            default: {
                throw new Error("".concat(context, "/interpolation: Invalid value (").concat(sampler.interpolation, ")"));
            }
        }
        var inputAccessor = ArrayItem.Get("".concat(context, "/input"), this._gltf.accessors, sampler.input);
        var outputAccessor = ArrayItem.Get("".concat(context, "/output"), this._gltf.accessors, sampler.output);
        sampler._data = Promise.all([
            this._loadFloatAccessorAsync("/accessors/".concat(inputAccessor.index), inputAccessor),
            this._loadFloatAccessorAsync("/accessors/".concat(outputAccessor.index), outputAccessor),
        ]).then(function (_a) {
            var inputData = _a[0], outputData = _a[1];
            return {
                input: inputData,
                interpolation: interpolation,
                output: outputData,
            };
        });
        return sampler._data;
    };
    /**
     * Loads a glTF buffer.
     * @param context The context when loading the asset
     * @param buffer The glTF buffer property
     * @param byteOffset The byte offset to use
     * @param byteLength The byte length to use
     * @returns A promise that resolves with the loaded data when the load is complete
     */
    GLTFLoader.prototype.loadBufferAsync = function (context, buffer, byteOffset, byteLength) {
        var extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);
        if (extensionPromise) {
            return extensionPromise;
        }
        if (!buffer._data) {
            if (buffer.uri) {
                buffer._data = this.loadUriAsync("".concat(context, "/uri"), buffer, buffer.uri);
            }
            else {
                if (!this._bin) {
                    throw new Error("".concat(context, ": Uri is missing or the binary glTF is missing its binary chunk"));
                }
                buffer._data = this._bin.readAsync(0, buffer.byteLength);
            }
        }
        return buffer._data.then(function (data) {
            try {
                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
            }
            catch (e) {
                throw new Error("".concat(context, ": ").concat(e.message));
            }
        });
    };
    /**
     * Loads a glTF buffer view.
     * @param context The context when loading the asset
     * @param bufferView The glTF buffer view property
     * @returns A promise that resolves with the loaded data when the load is complete
     */
    GLTFLoader.prototype.loadBufferViewAsync = function (context, bufferView) {
        var extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);
        if (extensionPromise) {
            return extensionPromise;
        }
        if (bufferView._data) {
            return bufferView._data;
        }
        var buffer = ArrayItem.Get("".concat(context, "/buffer"), this._gltf.buffers, bufferView.buffer);
        bufferView._data = this.loadBufferAsync("/buffers/".concat(buffer.index), buffer, bufferView.byteOffset || 0, bufferView.byteLength);
        return bufferView._data;
    };
    GLTFLoader.prototype._loadAccessorAsync = function (context, accessor, constructor) {
        var _this = this;
        if (accessor._data) {
            return accessor._data;
        }
        var numComponents = GLTFLoader._GetNumComponents(context, accessor.type);
        var byteStride = numComponents * babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.GetTypeByteLength(accessor.componentType);
        var length = numComponents * accessor.count;
        if (accessor.bufferView == undefined) {
            accessor._data = Promise.resolve(new constructor(length));
        }
        else {
            var bufferView_1 = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
            accessor._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView_1.index), bufferView_1).then(function (data) {
                if (accessor.componentType === 5126 /* AccessorComponentType.FLOAT */ && !accessor.normalized && (!bufferView_1.byteStride || bufferView_1.byteStride === byteStride)) {
                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);
                }
                else {
                    var typedArray_1 = new constructor(length);
                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView_1.byteStride || byteStride, numComponents, accessor.componentType, typedArray_1.length, accessor.normalized || false, function (value, index) {
                        typedArray_1[index] = value;
                    });
                    return typedArray_1;
                }
            });
        }
        if (accessor.sparse) {
            var sparse_1 = accessor.sparse;
            accessor._data = accessor._data.then(function (data) {
                var typedArray = data;
                var indicesBufferView = ArrayItem.Get("".concat(context, "/sparse/indices/bufferView"), _this._gltf.bufferViews, sparse_1.indices.bufferView);
                var valuesBufferView = ArrayItem.Get("".concat(context, "/sparse/values/bufferView"), _this._gltf.bufferViews, sparse_1.values.bufferView);
                return Promise.all([
                    _this.loadBufferViewAsync("/bufferViews/".concat(indicesBufferView.index), indicesBufferView),
                    _this.loadBufferViewAsync("/bufferViews/".concat(valuesBufferView.index), valuesBufferView),
                ]).then(function (_a) {
                    var indicesData = _a[0], valuesData = _a[1];
                    var indices = GLTFLoader._GetTypedArray("".concat(context, "/sparse/indices"), sparse_1.indices.componentType, indicesData, sparse_1.indices.byteOffset, sparse_1.count);
                    var sparseLength = numComponents * sparse_1.count;
                    var values;
                    if (accessor.componentType === 5126 /* AccessorComponentType.FLOAT */ && !accessor.normalized) {
                        values = GLTFLoader._GetTypedArray("".concat(context, "/sparse/values"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
                    }
                    else {
                        var sparseData = GLTFLoader._GetTypedArray("".concat(context, "/sparse/values"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
                        values = new constructor(sparseLength);
                        babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, function (value, index) {
                            values[index] = value;
                        });
                    }
                    var valuesIndex = 0;
                    for (var indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {
                        var dataIndex = indices[indicesIndex] * numComponents;
                        for (var componentIndex = 0; componentIndex < numComponents; componentIndex++) {
                            typedArray[dataIndex++] = values[valuesIndex++];
                        }
                    }
                    return typedArray;
                });
            });
        }
        return accessor._data;
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._loadFloatAccessorAsync = function (context, accessor) {
        return this._loadAccessorAsync(context, accessor, Float32Array);
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._loadIndicesAccessorAsync = function (context, accessor) {
        if (accessor.type !== "SCALAR" /* AccessorType.SCALAR */) {
            throw new Error("".concat(context, "/type: Invalid value ").concat(accessor.type));
        }
        if (accessor.componentType !== 5121 /* AccessorComponentType.UNSIGNED_BYTE */ &&
            accessor.componentType !== 5123 /* AccessorComponentType.UNSIGNED_SHORT */ &&
            accessor.componentType !== 5125 /* AccessorComponentType.UNSIGNED_INT */) {
            throw new Error("".concat(context, "/componentType: Invalid value ").concat(accessor.componentType));
        }
        if (accessor._data) {
            return accessor._data;
        }
        if (accessor.sparse) {
            var constructor = GLTFLoader._GetTypedArrayConstructor("".concat(context, "/componentType"), accessor.componentType);
            accessor._data = this._loadAccessorAsync(context, accessor, constructor);
        }
        else {
            var bufferView = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
            accessor._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function (data) {
                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);
            });
        }
        return accessor._data;
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._loadVertexBufferViewAsync = function (bufferView) {
        if (bufferView._babylonBuffer) {
            return bufferView._babylonBuffer;
        }
        var engine = this._babylonScene.getEngine();
        bufferView._babylonBuffer = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function (data) {
            return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Buffer(engine, data, false);
        });
        return bufferView._babylonBuffer;
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._loadVertexAccessorAsync = function (context, accessor, kind) {
        var _a;
        if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {
            return accessor._babylonVertexBuffer[kind];
        }
        if (!accessor._babylonVertexBuffer) {
            accessor._babylonVertexBuffer = {};
        }
        var engine = this._babylonScene.getEngine();
        if (accessor.sparse || accessor.bufferView == undefined) {
            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(function (data) {
                return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, data, kind, false);
            });
        }
        else {
            var bufferView_2 = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView_2).then(function (babylonBuffer) {
                var numComponents = GLTFLoader._GetNumComponents(context, accessor.type);
                return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, babylonBuffer, kind, false, undefined, bufferView_2.byteStride, undefined, accessor.byteOffset, numComponents, accessor.componentType, accessor.normalized, true, undefined, true);
            });
        }
        return accessor._babylonVertexBuffer[kind];
    };
    GLTFLoader.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function (context, properties, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        if (properties) {
            if (properties.baseColorFactor) {
                babylonMaterial.albedoColor = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.baseColorFactor);
                babylonMaterial.alpha = properties.baseColorFactor[3];
            }
            else {
                babylonMaterial.albedoColor = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
            }
            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;
            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;
            if (properties.baseColorTexture) {
                promises.push(this.loadTextureInfoAsync("".concat(context, "/baseColorTexture"), properties.baseColorTexture, function (texture) {
                    texture.name = "".concat(babylonMaterial.name, " (Base Color)");
                    babylonMaterial.albedoTexture = texture;
                }));
            }
            if (properties.metallicRoughnessTexture) {
                properties.metallicRoughnessTexture.nonColorData = true;
                promises.push(this.loadTextureInfoAsync("".concat(context, "/metallicRoughnessTexture"), properties.metallicRoughnessTexture, function (texture) {
                    texture.name = "".concat(babylonMaterial.name, " (Metallic Roughness)");
                    babylonMaterial.metallicTexture = texture;
                }));
                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;
                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;
                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;
            }
        }
        return Promise.all(promises).then(function () { });
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {
        if (assign === void 0) { assign = function () { }; }
        var extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
        if (extensionPromise) {
            return extensionPromise;
        }
        material._data = material._data || {};
        var babylonData = material._data[babylonDrawMode];
        if (!babylonData) {
            this.logOpen("".concat(context, " ").concat(material.name || ""));
            var babylonMaterial = this.createMaterial(context, material, babylonDrawMode);
            babylonData = {
                babylonMaterial: babylonMaterial,
                babylonMeshes: [],
                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),
            };
            material._data[babylonDrawMode] = babylonData;
            GLTFLoader.AddPointerMetadata(babylonMaterial, context);
            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
            this.logClose();
        }
        if (babylonMesh) {
            babylonData.babylonMeshes.push(babylonMesh);
            babylonMesh.onDisposeObservable.addOnce(function () {
                var index = babylonData.babylonMeshes.indexOf(babylonMesh);
                if (index !== -1) {
                    babylonData.babylonMeshes.splice(index, 1);
                }
            });
        }
        assign(babylonData.babylonMaterial);
        return babylonData.promise.then(function () {
            return babylonData.babylonMaterial;
        });
    };
    GLTFLoader.prototype._createDefaultMaterial = function (name, babylonDrawMode) {
        this._babylonScene._blockEntityCollection = !!this._assetContainer;
        var babylonMaterial = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial(name, this._babylonScene);
        babylonMaterial._parentContainer = this._assetContainer;
        this._babylonScene._blockEntityCollection = false;
        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
        babylonMaterial.fillMode = babylonDrawMode;
        babylonMaterial.enableSpecularAntiAliasing = true;
        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;
        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;
        babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_OPAQUE;
        babylonMaterial.metallic = 1;
        babylonMaterial.roughness = 1;
        return babylonMaterial;
    };
    /**
     * Creates a Babylon material from a glTF material.
     * @param context The context when loading the asset
     * @param material The glTF material property
     * @param babylonDrawMode The draw mode for the Babylon material
     * @returns The Babylon material
     */
    GLTFLoader.prototype.createMaterial = function (context, material, babylonDrawMode) {
        var extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);
        if (extensionPromise) {
            return extensionPromise;
        }
        var name = material.name || "material".concat(material.index);
        var babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);
        return babylonMaterial;
    };
    /**
     * Loads properties from a glTF material into a Babylon material.
     * @param context The context when loading the asset
     * @param material The glTF material property
     * @param babylonMaterial The Babylon material
     * @returns A promise that resolves when the load is complete
     */
    GLTFLoader.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        var extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);
        if (extensionPromise) {
            return extensionPromise;
        }
        var promises = new Array();
        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
        if (material.pbrMetallicRoughness) {
            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync("".concat(context, "/pbrMetallicRoughness"), material.pbrMetallicRoughness, babylonMaterial));
        }
        this.loadMaterialAlphaProperties(context, material, babylonMaterial);
        return Promise.all(promises).then(function () { });
    };
    /**
     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.
     * @param context The context when loading the asset
     * @param material The glTF material property
     * @param babylonMaterial The Babylon material
     * @returns A promise that resolves when the load is complete
     */
    GLTFLoader.prototype.loadMaterialBasePropertiesAsync = function (context, material, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var promises = new Array();
        babylonMaterial.emissiveColor = material.emissiveFactor ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(material.emissiveFactor) : new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3(0, 0, 0);
        if (material.doubleSided) {
            babylonMaterial.backFaceCulling = false;
            babylonMaterial.twoSidedLighting = true;
        }
        if (material.normalTexture) {
            material.normalTexture.nonColorData = true;
            promises.push(this.loadTextureInfoAsync("".concat(context, "/normalTexture"), material.normalTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Normal)");
                babylonMaterial.bumpTexture = texture;
            }));
            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;
            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;
            if (material.normalTexture.scale != undefined && babylonMaterial.bumpTexture) {
                babylonMaterial.bumpTexture.level = material.normalTexture.scale;
            }
            babylonMaterial.forceIrradianceInFragment = true;
        }
        if (material.occlusionTexture) {
            material.occlusionTexture.nonColorData = true;
            promises.push(this.loadTextureInfoAsync("".concat(context, "/occlusionTexture"), material.occlusionTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Occlusion)");
                babylonMaterial.ambientTexture = texture;
            }));
            babylonMaterial.useAmbientInGrayScale = true;
            if (material.occlusionTexture.strength != undefined) {
                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;
            }
        }
        if (material.emissiveTexture) {
            promises.push(this.loadTextureInfoAsync("".concat(context, "/emissiveTexture"), material.emissiveTexture, function (texture) {
                texture.name = "".concat(babylonMaterial.name, " (Emissive)");
                babylonMaterial.emissiveTexture = texture;
            }));
        }
        return Promise.all(promises).then(function () { });
    };
    /**
     * Loads the alpha properties from a glTF material into a Babylon material.
     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.
     * @param context The context when loading the asset
     * @param material The glTF material property
     * @param babylonMaterial The Babylon material
     */
    GLTFLoader.prototype.loadMaterialAlphaProperties = function (context, material, babylonMaterial) {
        if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
            throw new Error("".concat(context, ": Material type not supported"));
        }
        var alphaMode = material.alphaMode || "OPAQUE" /* MaterialAlphaMode.OPAQUE */;
        switch (alphaMode) {
            case "OPAQUE" /* MaterialAlphaMode.OPAQUE */: {
                babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_OPAQUE;
                babylonMaterial.alpha = 1.0; // Force alpha to 1.0 for opaque mode.
                break;
            }
            case "MASK" /* MaterialAlphaMode.MASK */: {
                babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_ALPHATEST;
                babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;
                if (babylonMaterial.albedoTexture) {
                    babylonMaterial.albedoTexture.hasAlpha = true;
                }
                break;
            }
            case "BLEND" /* MaterialAlphaMode.BLEND */: {
                babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_ALPHABLEND;
                if (babylonMaterial.albedoTexture) {
                    babylonMaterial.albedoTexture.hasAlpha = true;
                    babylonMaterial.useAlphaFromAlbedoTexture = true;
                }
                break;
            }
            default: {
                throw new Error("".concat(context, "/alphaMode: Invalid value (").concat(material.alphaMode, ")"));
            }
        }
    };
    /**
     * Loads a glTF texture info.
     * @param context The context when loading the asset
     * @param textureInfo The glTF texture info property
     * @param assign A function called synchronously after parsing the glTF properties
     * @returns A promise that resolves with the loaded Babylon texture when the load is complete
     */
    GLTFLoader.prototype.loadTextureInfoAsync = function (context, textureInfo, assign) {
        var _this = this;
        if (assign === void 0) { assign = function () { }; }
        var extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);
        if (extensionPromise) {
            return extensionPromise;
        }
        this.logOpen("".concat(context));
        if (textureInfo.texCoord >= 6) {
            throw new Error("".concat(context, "/texCoord: Invalid value (").concat(textureInfo.texCoord, ")"));
        }
        var texture = ArrayItem.Get("".concat(context, "/index"), this._gltf.textures, textureInfo.index);
        texture._textureInfo = textureInfo;
        var promise = this._loadTextureAsync("/textures/".concat(textureInfo.index), texture, function (babylonTexture) {
            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;
            GLTFLoader.AddPointerMetadata(babylonTexture, context);
            _this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);
            assign(babylonTexture);
        });
        this.logClose();
        return promise;
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._loadTextureAsync = function (context, texture, assign) {
        if (assign === void 0) { assign = function () { }; }
        var extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);
        if (extensionPromise) {
            return extensionPromise;
        }
        this.logOpen("".concat(context, " ").concat(texture.name || ""));
        var sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get("".concat(context, "/sampler"), this._gltf.samplers, texture.sampler);
        var image = ArrayItem.Get("".concat(context, "/source"), this._gltf.images, texture.source);
        var promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);
        this.logClose();
        return promise;
    };
    /**
     * @internal
     */
    GLTFLoader.prototype._createTextureAsync = function (context, sampler, image, assign, textureLoaderOptions, useSRGBBuffer) {
        var _this = this;
        var _a, _b;
        if (assign === void 0) { assign = function () { }; }
        var samplerData = this._loadSampler("/samplers/".concat(sampler.index), sampler);
        var promises = new Array();
        var deferred = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this._babylonScene._blockEntityCollection = !!this._assetContainer;
        var textureCreationOptions = {
            noMipmap: samplerData.noMipMaps,
            invertY: false,
            samplingMode: samplerData.samplingMode,
            onLoad: function () {
                if (!_this._disposed) {
                    deferred.resolve();
                }
            },
            onError: function (message, exception) {
                if (!_this._disposed) {
                    deferred.reject(new Error("".concat(context, ": ").concat(exception && exception.message ? exception.message : message || "Failed to load texture")));
                }
            },
            mimeType: (_a = image.mimeType) !== null && _a !== void 0 ? _a : (0,babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.GetMimeType)((_b = image.uri) !== null && _b !== void 0 ? _b : ""),
            loaderOptions: textureLoaderOptions,
            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,
        };
        var babylonTexture = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture(null, this._babylonScene, textureCreationOptions);
        babylonTexture._parentContainer = this._assetContainer;
        this._babylonScene._blockEntityCollection = false;
        promises.push(deferred.promise);
        promises.push(this.loadImageAsync("/images/".concat(image.index), image).then(function (data) {
            var name = image.uri || "".concat(_this._fileName, "#image").concat(image.index);
            var dataUrl = "data:".concat(_this._uniqueRootUrl).concat(name);
            babylonTexture.updateURL(dataUrl, data);
            // Set the internal texture label.
            var internalTexture = babylonTexture.getInternalTexture();
            if (internalTexture) {
                internalTexture.label = image.name;
            }
        }));
        babylonTexture.wrapU = samplerData.wrapU;
        babylonTexture.wrapV = samplerData.wrapV;
        assign(babylonTexture);
        if (this._parent.useGltfTextureNames) {
            babylonTexture.name = image.name || image.uri || "image".concat(image.index);
        }
        return Promise.all(promises).then(function () {
            return babylonTexture;
        });
    };
    GLTFLoader.prototype._loadSampler = function (context, sampler) {
        if (!sampler._data) {
            sampler._data = {
                noMipMaps: sampler.minFilter === 9728 /* TextureMinFilter.NEAREST */ || sampler.minFilter === 9729 /* TextureMinFilter.LINEAR */,
                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),
                wrapU: GLTFLoader._GetTextureWrapMode("".concat(context, "/wrapS"), sampler.wrapS),
                wrapV: GLTFLoader._GetTextureWrapMode("".concat(context, "/wrapT"), sampler.wrapT),
            };
        }
        return sampler._data;
    };
    /**
     * Loads a glTF image.
     * @param context The context when loading the asset
     * @param image The glTF image property
     * @returns A promise that resolves with the loaded data when the load is complete
     */
    GLTFLoader.prototype.loadImageAsync = function (context, image) {
        if (!image._data) {
            this.logOpen("".concat(context, " ").concat(image.name || ""));
            if (image.uri) {
                image._data = this.loadUriAsync("".concat(context, "/uri"), image, image.uri);
            }
            else {
                var bufferView = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, image.bufferView);
                image._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView);
            }
            this.logClose();
        }
        return image._data;
    };
    /**
     * Loads a glTF uri.
     * @param context The context when loading the asset
     * @param property The glTF property associated with the uri
     * @param uri The base64 or relative uri
     * @returns A promise that resolves with the loaded data when the load is complete
     */
    GLTFLoader.prototype.loadUriAsync = function (context, property, uri) {
        var _this = this;
        var extensionPromise = this._extensionsLoadUriAsync(context, property, uri);
        if (extensionPromise) {
            return extensionPromise;
        }
        if (!GLTFLoader._ValidateUri(uri)) {
            throw new Error("".concat(context, ": '").concat(uri, "' is invalid"));
        }
        if ((0,babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.IsBase64DataUrl)(uri)) {
            var data = new Uint8Array((0,babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.DecodeBase64UrlToBinary)(uri));
            this.log("".concat(context, ": Decoded ").concat(uri.substring(0, 64), "... (").concat(data.length, " bytes)"));
            return Promise.resolve(data);
        }
        this.log("".concat(context, ": Loading ").concat(uri));
        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(function (url) {
            return new Promise(function (resolve, reject) {
                _this._parent._loadFile(_this._babylonScene, url, function (data) {
                    if (!_this._disposed) {
                        _this.log("".concat(context, ": Loaded ").concat(uri, " (").concat(data.byteLength, " bytes)"));
                        resolve(new Uint8Array(data));
                    }
                }, true, function (request) {
                    reject(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.LoadFileError("".concat(context, ": Failed to load '").concat(uri, "'").concat(request ? ": " + request.status + " " + request.statusText : ""), request));
                });
            });
        });
    };
    /**
     * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.
     * @param babylonObject the Babylon object with _internalMetadata
     * @param pointer the JSON pointer
     */
    GLTFLoader.AddPointerMetadata = function (babylonObject, pointer) {
        babylonObject.metadata = babylonObject.metadata || {};
        var metadata = (babylonObject._internalMetadata = babylonObject._internalMetadata || {});
        var gltf = (metadata.gltf = metadata.gltf || {});
        var pointers = (gltf.pointers = gltf.pointers || []);
        pointers.push(pointer);
    };
    GLTFLoader._GetTextureWrapMode = function (context, mode) {
        // Set defaults if undefined
        mode = mode == undefined ? 10497 /* TextureWrapMode.REPEAT */ : mode;
        switch (mode) {
            case 33071 /* TextureWrapMode.CLAMP_TO_EDGE */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.CLAMP_ADDRESSMODE;
            case 33648 /* TextureWrapMode.MIRRORED_REPEAT */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.MIRROR_ADDRESSMODE;
            case 10497 /* TextureWrapMode.REPEAT */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_ADDRESSMODE;
            default:
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Invalid value (").concat(mode, ")"));
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_ADDRESSMODE;
        }
    };
    GLTFLoader._GetTextureSamplingMode = function (context, sampler) {
        // Set defaults if undefined
        var magFilter = sampler.magFilter == undefined ? 9729 /* TextureMagFilter.LINEAR */ : sampler.magFilter;
        var minFilter = sampler.minFilter == undefined ? 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */ : sampler.minFilter;
        if (magFilter === 9729 /* TextureMagFilter.LINEAR */) {
            switch (minFilter) {
                case 9728 /* TextureMinFilter.NEAREST */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST;
                case 9729 /* TextureMinFilter.LINEAR */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR;
                case 9984 /* TextureMinFilter.NEAREST_MIPMAP_NEAREST */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST_MIPNEAREST;
                case 9985 /* TextureMinFilter.LINEAR_MIPMAP_NEAREST */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPNEAREST;
                case 9986 /* TextureMinFilter.NEAREST_MIPMAP_LINEAR */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST_MIPLINEAR;
                case 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPLINEAR;
                default:
                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/minFilter: Invalid value (").concat(minFilter, ")"));
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPLINEAR;
            }
        }
        else {
            if (magFilter !== 9728 /* TextureMagFilter.NEAREST */) {
                babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/magFilter: Invalid value (").concat(magFilter, ")"));
            }
            switch (minFilter) {
                case 9728 /* TextureMinFilter.NEAREST */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST;
                case 9729 /* TextureMinFilter.LINEAR */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR;
                case 9984 /* TextureMinFilter.NEAREST_MIPMAP_NEAREST */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST;
                case 9985 /* TextureMinFilter.LINEAR_MIPMAP_NEAREST */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR_MIPNEAREST;
                case 9986 /* TextureMinFilter.NEAREST_MIPMAP_LINEAR */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPLINEAR;
                case 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */:
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR_MIPLINEAR;
                default:
                    babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/minFilter: Invalid value (").concat(minFilter, ")"));
                    return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST;
            }
        }
    };
    GLTFLoader._GetTypedArrayConstructor = function (context, componentType) {
        try {
            return (0,babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.GetTypedArrayConstructor)(componentType);
        }
        catch (e) {
            throw new Error("".concat(context, ": ").concat(e.message));
        }
    };
    GLTFLoader._GetTypedArray = function (context, componentType, bufferView, byteOffset, length) {
        var buffer = bufferView.buffer;
        byteOffset = bufferView.byteOffset + (byteOffset || 0);
        var constructor = GLTFLoader._GetTypedArrayConstructor("".concat(context, "/componentType"), componentType);
        var componentTypeLength = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.GetTypeByteLength(componentType);
        if (byteOffset % componentTypeLength !== 0) {
            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.
            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Copying buffer as byte offset (").concat(byteOffset, ") is not a multiple of component type byte length (").concat(componentTypeLength, ")"));
            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);
        }
        return new constructor(buffer, byteOffset, length);
    };
    GLTFLoader._GetNumComponents = function (context, type) {
        switch (type) {
            case "SCALAR":
                return 1;
            case "VEC2":
                return 2;
            case "VEC3":
                return 3;
            case "VEC4":
                return 4;
            case "MAT2":
                return 4;
            case "MAT3":
                return 9;
            case "MAT4":
                return 16;
        }
        throw new Error("".concat(context, ": Invalid type (").concat(type, ")"));
    };
    GLTFLoader._ValidateUri = function (uri) {
        return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Tools.IsBase64(uri) || uri.indexOf("..") === -1;
    };
    /**
     * @internal
     */
    GLTFLoader._GetDrawMode = function (context, mode) {
        if (mode == undefined) {
            mode = 4 /* MeshPrimitiveMode.TRIANGLES */;
        }
        switch (mode) {
            case 0 /* MeshPrimitiveMode.POINTS */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.PointListDrawMode;
            case 1 /* MeshPrimitiveMode.LINES */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineListDrawMode;
            case 2 /* MeshPrimitiveMode.LINE_LOOP */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineLoopDrawMode;
            case 3 /* MeshPrimitiveMode.LINE_STRIP */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineStripDrawMode;
            case 4 /* MeshPrimitiveMode.TRIANGLES */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFillMode;
            case 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleStripDrawMode;
            case 6 /* MeshPrimitiveMode.TRIANGLE_FAN */:
                return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFanDrawMode;
        }
        throw new Error("".concat(context, ": Invalid mesh primitive mode (").concat(mode, ")"));
    };
    GLTFLoader.prototype._compileMaterialsAsync = function () {
        var _this = this;
        this._parent._startPerformanceCounter("Compile materials");
        var promises = new Array();
        if (this._gltf.materials) {
            for (var _i = 0, _a = this._gltf.materials; _i < _a.length; _i++) {
                var material = _a[_i];
                if (material._data) {
                    for (var babylonDrawMode in material._data) {
                        var babylonData = material._data[babylonDrawMode];
                        for (var _b = 0, _c = babylonData.babylonMeshes; _b < _c.length; _b++) {
                            var babylonMesh = _c[_b];
                            // Ensure nonUniformScaling is set if necessary.
                            babylonMesh.computeWorldMatrix(true);
                            var babylonMaterial = babylonData.babylonMaterial;
                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));
                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));
                            if (this._parent.useClipPlane) {
                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));
                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));
                            }
                        }
                    }
                }
            }
        }
        return Promise.all(promises).then(function () {
            _this._parent._endPerformanceCounter("Compile materials");
        });
    };
    GLTFLoader.prototype._compileShadowGeneratorsAsync = function () {
        var _this = this;
        this._parent._startPerformanceCounter("Compile shadow generators");
        var promises = new Array();
        var lights = this._babylonScene.lights;
        for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
            var light = lights_1[_i];
            var generator = light.getShadowGenerator();
            if (generator) {
                promises.push(generator.forceCompilationAsync());
            }
        }
        return Promise.all(promises).then(function () {
            _this._parent._endPerformanceCounter("Compile shadow generators");
        });
    };
    GLTFLoader.prototype._forEachExtensions = function (action) {
        for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
            var extension = _a[_i];
            if (extension.enabled) {
                action(extension);
            }
        }
    };
    GLTFLoader.prototype._applyExtensions = function (property, functionName, actionAsync) {
        for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
            var extension = _a[_i];
            if (extension.enabled) {
                var id = "".concat(extension.name, ".").concat(functionName);
                var loaderProperty = property;
                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};
                var activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;
                if (!activeLoaderExtensionFunctions[id]) {
                    activeLoaderExtensionFunctions[id] = true;
                    try {
                        var result = actionAsync(extension);
                        if (result) {
                            return result;
                        }
                    }
                    finally {
                        delete activeLoaderExtensionFunctions[id];
                    }
                }
            }
        }
        return null;
    };
    GLTFLoader.prototype._extensionsOnLoading = function () {
        this._forEachExtensions(function (extension) { return extension.onLoading && extension.onLoading(); });
    };
    GLTFLoader.prototype._extensionsOnReady = function () {
        this._forEachExtensions(function (extension) { return extension.onReady && extension.onReady(); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadSceneAsync = function (context, scene) {
        return this._applyExtensions(scene, "loadScene", function (extension) { return extension.loadSceneAsync && extension.loadSceneAsync(context, scene); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadNodeAsync = function (context, node, assign) {
        return this._applyExtensions(node, "loadNode", function (extension) { return extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadCameraAsync = function (context, camera, assign) {
        return this._applyExtensions(camera, "loadCamera", function (extension) { return extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadVertexDataAsync = function (context, primitive, babylonMesh) {
        return this._applyExtensions(primitive, "loadVertexData", function (extension) { return extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {
        return this._applyExtensions(primitive, "loadMeshPrimitive", function (extension) { return extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {
        return this._applyExtensions(material, "loadMaterial", function (extension) { return extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign); });
    };
    GLTFLoader.prototype._extensionsCreateMaterial = function (context, material, babylonDrawMode) {
        return this._applyExtensions(material, "createMaterial", function (extension) { return extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadMaterialPropertiesAsync = function (context, material, babylonMaterial) {
        return this._applyExtensions(material, "loadMaterialProperties", function (extension) { return extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadTextureInfoAsync = function (context, textureInfo, assign) {
        return this._applyExtensions(textureInfo, "loadTextureInfo", function (extension) { return extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadTextureAsync = function (context, texture, assign) {
        return this._applyExtensions(texture, "loadTexture", function (extension) { return extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadAnimationAsync = function (context, animation) {
        return this._applyExtensions(animation, "loadAnimation", function (extension) { return extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadAnimationChannelAsync = function (context, animationContext, animation, channel, onLoad) {
        return this._applyExtensions(animation, "loadAnimationChannel", function (extension) { return extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadSkinAsync = function (context, node, skin) {
        return this._applyExtensions(skin, "loadSkin", function (extension) { return extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadUriAsync = function (context, property, uri) {
        return this._applyExtensions(property, "loadUri", function (extension) { return extension._loadUriAsync && extension._loadUriAsync(context, property, uri); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadBufferViewAsync = function (context, bufferView) {
        return this._applyExtensions(bufferView, "loadBufferView", function (extension) { return extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView); });
    };
    // eslint-disable-next-line no-restricted-syntax
    GLTFLoader.prototype._extensionsLoadBufferAsync = function (context, buffer, byteOffset, byteLength) {
        return this._applyExtensions(buffer, "loadBuffer", function (extension) { return extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength); });
    };
    /**
     * Helper method called by a loader extension to load an glTF extension.
     * @param context The context when loading the asset
     * @param property The glTF property to load the extension from
     * @param extensionName The name of the extension to load
     * @param actionAsync The action to run
     * @returns The promise returned by actionAsync or null if the extension does not exist
     */
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention
    GLTFLoader.LoadExtensionAsync = function (context, property, extensionName, actionAsync) {
        if (!property.extensions) {
            return null;
        }
        var extensions = property.extensions;
        var extension = extensions[extensionName];
        if (!extension) {
            return null;
        }
        return actionAsync("".concat(context, "/extensions/").concat(extensionName), extension);
    };
    /**
     * Helper method called by a loader extension to load a glTF extra.
     * @param context The context when loading the asset
     * @param property The glTF property to load the extra from
     * @param extensionName The name of the extension to load
     * @param actionAsync The action to run
     * @returns The promise returned by actionAsync or null if the extra does not exist
     */
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention
    GLTFLoader.LoadExtraAsync = function (context, property, extensionName, actionAsync) {
        if (!property.extras) {
            return null;
        }
        var extras = property.extras;
        var extra = extras[extensionName];
        if (!extra) {
            return null;
        }
        return actionAsync("".concat(context, "/extras/").concat(extensionName), extra);
    };
    /**
     * Checks for presence of an extension.
     * @param name The name of the extension to check
     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`
     */
    GLTFLoader.prototype.isExtensionUsed = function (name) {
        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;
    };
    /**
     * Increments the indentation level and logs a message.
     * @param message The message to log
     */
    GLTFLoader.prototype.logOpen = function (message) {
        this._parent._logOpen(message);
    };
    /**
     * Decrements the indentation level.
     */
    GLTFLoader.prototype.logClose = function () {
        this._parent._logClose();
    };
    /**
     * Logs a message
     * @param message The message to log
     */
    GLTFLoader.prototype.log = function (message) {
        this._parent._log(message);
    };
    /**
     * Starts a performance counter.
     * @param counterName The name of the performance counter
     */
    GLTFLoader.prototype.startPerformanceCounter = function (counterName) {
        this._parent._startPerformanceCounter(counterName);
    };
    /**
     * Ends a performance counter.
     * @param counterName The name of the performance counter
     */
    GLTFLoader.prototype.endPerformanceCounter = function (counterName) {
        this._parent._endPerformanceCounter(counterName);
    };
    /**
     * The default glTF sampler.
     */
    GLTFLoader.DefaultSampler = { index: -1 };
    return GLTFLoader;
}());

_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFFileLoader._CreateGLTF2Loader = function (parent) { return new GLTFLoader(parent); };


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts":
/*!****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimationPropertyInfo: () => (/* binding */ AnimationPropertyInfo),
/* harmony export */   TransformNodeAnimationPropertyInfo: () => (/* binding */ TransformNodeAnimationPropertyInfo),
/* harmony export */   WeightAnimationPropertyInfo: () => (/* binding */ WeightAnimationPropertyInfo),
/* harmony export */   getQuaternion: () => (/* binding */ getQuaternion),
/* harmony export */   getVector3: () => (/* binding */ getVector3),
/* harmony export */   getWeights: () => (/* binding */ getWeights)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Maths/math.vector */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Extensions/objectModelMapping */ "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts");




/** @internal */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getVector3(_target, source, offset, scale) {
    return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(source, offset).scaleInPlace(scale);
}
/** @internal */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getQuaternion(_target, source, offset, scale) {
    return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(source, offset).scaleInPlace(scale);
}
/** @internal */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getWeights(target, source, offset, scale) {
    var value = new Array(target._numMorphTargets);
    for (var i = 0; i < value.length; i++) {
        value[i] = source[offset++] * scale;
    }
    return value;
}
/** @internal */
var AnimationPropertyInfo = /** @class */ (function () {
    /** @internal */
    function AnimationPropertyInfo(type, name, getValue, getStride) {
        this.type = type;
        this.name = name;
        this.getValue = getValue;
        this.getStride = getStride;
    }
    AnimationPropertyInfo.prototype._buildAnimation = function (name, fps, keys) {
        var babylonAnimation = new babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation(name, this.name, fps, this.type);
        babylonAnimation.setKeys(keys);
        return babylonAnimation;
    };
    return AnimationPropertyInfo;
}());

/** @internal */
var TransformNodeAnimationPropertyInfo = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TransformNodeAnimationPropertyInfo, _super);
    function TransformNodeAnimationPropertyInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @internal */
    TransformNodeAnimationPropertyInfo.prototype.buildAnimations = function (target, name, fps, keys) {
        var babylonAnimations = [];
        babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode, babylonAnimation: this._buildAnimation(name, fps, keys) });
        return babylonAnimations;
    };
    return TransformNodeAnimationPropertyInfo;
}(AnimationPropertyInfo));

/** @internal */
var WeightAnimationPropertyInfo = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(WeightAnimationPropertyInfo, _super);
    function WeightAnimationPropertyInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WeightAnimationPropertyInfo.prototype.buildAnimations = function (target, name, fps, keys) {
        var babylonAnimations = [];
        if (target._numMorphTargets) {
            var _loop_1 = function (targetIndex) {
                var babylonAnimation = new babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation("".concat(name, "_").concat(targetIndex), this_1.name, fps, this_1.type);
                babylonAnimation.setKeys(keys.map(function (key) { return ({
                    frame: key.frame,
                    inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,
                    value: key.value[targetIndex],
                    outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,
                    interpolation: key.interpolation,
                }); }));
                if (target._primitiveBabylonMeshes) {
                    for (var _i = 0, _a = target._primitiveBabylonMeshes; _i < _a.length; _i++) {
                        var babylonMesh = _a[_i];
                        if (babylonMesh.morphTargetManager) {
                            var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);
                            var babylonAnimationClone = babylonAnimation.clone();
                            morphTarget.animations.push(babylonAnimationClone);
                            babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });
                        }
                    }
                }
            };
            var this_1 = this;
            for (var targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {
                _loop_1(targetIndex);
            }
        }
        return babylonAnimations;
    };
    return WeightAnimationPropertyInfo;
}(AnimationPropertyInfo));

(0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/translation", [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_VECTOR3, "position", getVector3, function () { return 3; })]);
(0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/rotation", [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_QUATERNION, "rotationQuaternion", getQuaternion, function () { return 4; })]);
(0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/scale", [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_VECTOR3, "scaling", getVector3, function () { return 3; })]);
(0,_Extensions_objectModelMapping__WEBPACK_IMPORTED_MODULE_1__.SetInterpolationForKey)("/nodes/{}/weights", [new WeightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "influence", getWeights, function (target) { return target._numMorphTargets; })]);


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts":
/*!****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts":
/*!************************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerGLTFExtension: () => (/* binding */ registerGLTFExtension),
/* harmony export */   registeredGLTFExtensions: () => (/* binding */ registeredGLTFExtensions),
/* harmony export */   unregisterGLTFExtension: () => (/* binding */ unregisterGLTFExtension)
/* harmony export */ });
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/logger */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__);

var RegisteredGLTFExtensions = new Map();
/**
 * All currently registered glTF 2.0 loader extensions.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var registeredGLTFExtensions = RegisteredGLTFExtensions;
/**
 * Registers a loader extension.
 * @param name The name of the loader extension.
 * @param isGLTFExtension If the loader extension is a glTF extension, then it will only be used for glTF files that use the corresponding glTF extension. Otherwise, it will be used for all loaded glTF files.
 * @param factory The factory function that creates the loader extension.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function registerGLTFExtension(name, isGLTFExtension, factory) {
    if (unregisterGLTFExtension(name)) {
        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Extension with the name '".concat(name, "' already exists"));
    }
    RegisteredGLTFExtensions.set(name, {
        isGLTFExtension: isGLTFExtension,
        factory: factory,
    });
}
/**
 * Unregisters a loader extension.
 * @param name The name of the loader extension.
 * @returns A boolean indicating whether the extension has been unregistered
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function unregisterGLTFExtension(name) {
    return RegisteredGLTFExtensions.delete(name);
}


/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts":
/*!*****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../../../dev/loaders/src/glTF/2.0/index.ts":
/*!**************************************************!*\
  !*** ../../../dev/loaders/src/glTF/2.0/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddObjectAccessorToKey: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.AddObjectAccessorToKey),
/* harmony export */   AnimationPropertyInfo: () => (/* reexport safe */ _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.AnimationPropertyInfo),
/* harmony export */   ArrayItem: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem),
/* harmony export */   EXT_lights_ies: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_lights_ies),
/* harmony export */   EXT_lights_image_based: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_lights_image_based),
/* harmony export */   EXT_materials_diffuse_roughness: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_materials_diffuse_roughness),
/* harmony export */   EXT_mesh_gpu_instancing: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_mesh_gpu_instancing),
/* harmony export */   EXT_meshopt_compression: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_meshopt_compression),
/* harmony export */   EXT_texture_avif: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_texture_avif),
/* harmony export */   EXT_texture_webp: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.EXT_texture_webp),
/* harmony export */   ExtrasAsMetadata: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.ExtrasAsMetadata),
/* harmony export */   FlowGraphGLTFDataProvider: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.FlowGraphGLTFDataProvider),
/* harmony export */   GLTFFileLoader: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader),
/* harmony export */   GLTFLoader: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader),
/* harmony export */   GetMappingForKey: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.GetMappingForKey),
/* harmony export */   GetPathToObjectConverter: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.GetPathToObjectConverter),
/* harmony export */   InteractivityGraphToFlowGraphParser: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.InteractivityGraphToFlowGraphParser),
/* harmony export */   KHR_animation_pointer: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_animation_pointer),
/* harmony export */   KHR_draco_mesh_compression: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_draco_mesh_compression),
/* harmony export */   KHR_interactivity: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_interactivity),
/* harmony export */   KHR_lights: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_lights),
/* harmony export */   KHR_materials_anisotropy: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_anisotropy),
/* harmony export */   KHR_materials_clearcoat: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_clearcoat),
/* harmony export */   KHR_materials_diffuse_transmission: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_diffuse_transmission),
/* harmony export */   KHR_materials_dispersion: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_dispersion),
/* harmony export */   KHR_materials_emissive_strength: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_emissive_strength),
/* harmony export */   KHR_materials_ior: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_ior),
/* harmony export */   KHR_materials_iridescence: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_iridescence),
/* harmony export */   KHR_materials_pbrSpecularGlossiness: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_pbrSpecularGlossiness),
/* harmony export */   KHR_materials_sheen: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_sheen),
/* harmony export */   KHR_materials_specular: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_specular),
/* harmony export */   KHR_materials_transmission: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_transmission),
/* harmony export */   KHR_materials_unlit: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_unlit),
/* harmony export */   KHR_materials_variants: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_variants),
/* harmony export */   KHR_materials_volume: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_materials_volume),
/* harmony export */   KHR_mesh_quantization: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_mesh_quantization),
/* harmony export */   KHR_node_hoverability: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_node_hoverability),
/* harmony export */   KHR_node_selectability: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_node_selectability),
/* harmony export */   KHR_node_visibility: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_node_visibility),
/* harmony export */   KHR_texture_basisu: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_texture_basisu),
/* harmony export */   KHR_texture_transform: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_texture_transform),
/* harmony export */   KHR_xmp_json_ld: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.KHR_xmp_json_ld),
/* harmony export */   LoadBoundingInfoFromPositionAccessor: () => (/* reexport safe */ _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.LoadBoundingInfoFromPositionAccessor),
/* harmony export */   MSFT_audio_emitter: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_audio_emitter),
/* harmony export */   MSFT_lod: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_lod),
/* harmony export */   MSFT_minecraftMesh: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_minecraftMesh),
/* harmony export */   MSFT_sRGBFactors: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.MSFT_sRGBFactors),
/* harmony export */   SetInterpolationForKey: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.SetInterpolationForKey),
/* harmony export */   TransformNodeAnimationPropertyInfo: () => (/* reexport safe */ _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.TransformNodeAnimationPropertyInfo),
/* harmony export */   WeightAnimationPropertyInfo: () => (/* reexport safe */ _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.WeightAnimationPropertyInfo),
/* harmony export */   _AddInteractivityObjectModel: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__._AddInteractivityObjectModel),
/* harmony export */   addNewInteractivityFlowGraphMapping: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.addNewInteractivityFlowGraphMapping),
/* harmony export */   getAllSupportedNativeNodeTypes: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.getAllSupportedNativeNodeTypes),
/* harmony export */   getMappingForDeclaration: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.getMappingForDeclaration),
/* harmony export */   getMappingForFullOperationName: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.getMappingForFullOperationName),
/* harmony export */   getQuaternion: () => (/* reexport safe */ _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.getQuaternion),
/* harmony export */   getVector3: () => (/* reexport safe */ _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.getVector3),
/* harmony export */   getWeights: () => (/* reexport safe */ _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__.getWeights),
/* harmony export */   gltfTypeToBabylonType: () => (/* reexport safe */ _Extensions_index__WEBPACK_IMPORTED_MODULE_5__.gltfTypeToBabylonType),
/* harmony export */   registerGLTFExtension: () => (/* reexport safe */ _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registerGLTFExtension),
/* harmony export */   registeredGLTFExtensions: () => (/* reexport safe */ _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.registeredGLTFExtensions),
/* harmony export */   unregisterGLTFExtension: () => (/* reexport safe */ _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__.unregisterGLTFExtension)
/* harmony export */ });
/* harmony import */ var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFLoader */ "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts");
/* harmony import */ var _glTFLoaderExtension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glTFLoaderExtension */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts");
/* harmony import */ var _glTFLoaderExtensionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glTFLoaderExtensionRegistry */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts");
/* harmony import */ var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glTFLoaderInterfaces */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts");
/* harmony import */ var _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glTFLoaderAnimation */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts");
/* harmony import */ var _Extensions_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Extensions/index */ "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts");
/* eslint-disable import/no-internal-modules */








/***/ }),

/***/ "../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts":
/*!****************************************************************!*\
  !*** ../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFFileLoaderMetadata: () => (/* binding */ GLTFFileLoaderMetadata),
/* harmony export */   GLTFMagicBase64Encoded: () => (/* binding */ GLTFMagicBase64Encoded)
/* harmony export */ });
var GLTFMagicBase64Encoded = "Z2xURg"; // "glTF" base64 encoded (without the quotes!)
var GLTFFileLoaderMetadata = {
    name: "gltf",
    extensions: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ".gltf": { isBinary: false, mimeType: "model/gltf+json" },
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ".glb": { isBinary: true, mimeType: "model/gltf-binary" },
    },
    canDirectLoad: function (data) {
        return ((data.indexOf("asset") !== -1 && data.indexOf("version") !== -1) ||
            data.startsWith("data:base64," + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
            data.startsWith("data:;base64," + GLTFMagicBase64Encoded) ||
            data.startsWith("data:application/octet-stream;base64," + GLTFMagicBase64Encoded) ||
            data.startsWith("data:model/gltf-binary;base64," + GLTFMagicBase64Encoded));
    },
};


/***/ }),

/***/ "../../../dev/loaders/src/glTF/glTFFileLoader.ts":
/*!*******************************************************!*\
  !*** ../../../dev/loaders/src/glTF/glTFFileLoader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFFileLoader: () => (/* binding */ GLTFFileLoader),
/* harmony export */   GLTFLoaderAnimationStartMode: () => (/* binding */ GLTFLoaderAnimationStartMode),
/* harmony export */   GLTFLoaderCoordinateSystemMode: () => (/* binding */ GLTFLoaderCoordinateSystemMode),
/* harmony export */   GLTFLoaderState: () => (/* binding */ GLTFLoaderState)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "../../../../node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/error */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glTFValidation */ "../../../dev/loaders/src/glTF/glTFValidation.ts");
/* harmony import */ var _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glTFFileLoader.metadata */ "../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts");











function readAsync(arrayBuffer, byteOffset, byteLength) {
    try {
        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
    }
    catch (e) {
        return Promise.reject(e);
    }
}
function readViewAsync(arrayBufferView, byteOffset, byteLength) {
    try {
        if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {
            throw new RangeError("Offset is out of range.");
        }
        if (byteOffset + byteLength > arrayBufferView.byteLength) {
            throw new RangeError("Length is out of range.");
        }
        return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));
    }
    catch (e) {
        return Promise.reject(e);
    }
}
/**
 * Mode that determines the coordinate system to use.
 */
var GLTFLoaderCoordinateSystemMode;
(function (GLTFLoaderCoordinateSystemMode) {
    /**
     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.
     */
    GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode["AUTO"] = 0] = "AUTO";
    /**
     * Sets the useRightHandedSystem flag on the scene.
     */
    GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));
/**
 * Mode that determines what animations will start.
 */
var GLTFLoaderAnimationStartMode;
(function (GLTFLoaderAnimationStartMode) {
    /**
     * No animation will start.
     */
    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode["NONE"] = 0] = "NONE";
    /**
     * The first animation will start.
     */
    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode["FIRST"] = 1] = "FIRST";
    /**
     * All animations will start.
     */
    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode["ALL"] = 2] = "ALL";
})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));
/**
 * Loader state.
 */
var GLTFLoaderState;
(function (GLTFLoaderState) {
    /**
     * The asset is loading.
     */
    GLTFLoaderState[GLTFLoaderState["LOADING"] = 0] = "LOADING";
    /**
     * The asset is ready for rendering.
     */
    GLTFLoaderState[GLTFLoaderState["READY"] = 1] = "READY";
    /**
     * The asset is completely loaded.
     */
    GLTFLoaderState[GLTFLoaderState["COMPLETE"] = 2] = "COMPLETE";
})(GLTFLoaderState || (GLTFLoaderState = {}));
var GLTFLoaderOptions = /** @class */ (function () {
    function GLTFLoaderOptions() {
        // ----------
        // V2 options
        // ----------
        /**
         * The coordinate system mode. Defaults to AUTO.
         */
        this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
        /**
         * The animation start mode. Defaults to FIRST.
         */
        this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
        /**
         * Defines if the loader should load node animations. Defaults to true.
         * NOTE: The animation of this node will still load if the node is also a joint of a skin and `loadSkins` is true.
         */
        this.loadNodeAnimations = true;
        /**
         * Defines if the loader should load skins. Defaults to true.
         */
        this.loadSkins = true;
        /**
         * Defines if the loader should load morph targets. Defaults to true.
         */
        this.loadMorphTargets = true;
        /**
         * Defines if the loader should compile materials before raising the success callback. Defaults to false.
         */
        this.compileMaterials = false;
        /**
         * Defines if the loader should also compile materials with clip planes. Defaults to false.
         */
        this.useClipPlane = false;
        /**
         * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.
         */
        this.compileShadowGenerators = false;
        /**
         * Defines if the Alpha blended materials are only applied as coverage.
         * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.
         * If true, no extra effects are applied to transparent pixels.
         */
        this.transparencyAsCoverage = false;
        /**
         * Defines if the loader should use range requests when load binary glTF files from HTTP.
         * Enabling will disable offline support and glTF validator.
         * Defaults to false.
         */
        this.useRangeRequests = false;
        /**
         * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.
         */
        this.createInstances = true;
        /**
         * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.
         */
        this.alwaysComputeBoundingBox = false;
        /**
         * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.
         */
        this.loadAllMaterials = false;
        /**
         * If true, load only the materials defined in the file. Defaults to false.
         */
        this.loadOnlyMaterials = false;
        /**
         * If true, do not load any materials defined in the file. Defaults to false.
         */
        this.skipMaterials = false;
        /**
         * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.
         */
        this.useSRGBBuffers = true;
        /**
         * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.
         */
        this.targetFps = 60;
        /**
         * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.
         * Set this to true if loading assets with invalid `skin.skeleton` values.
         */
        this.alwaysComputeSkeletonRootNode = false;
        /**
         * If true, the loader will derive the name for Babylon textures from the glTF texture name, image name, or image url. Defaults to false.
         * Note that it is possible for multiple Babylon textures to share the same name when the Babylon textures load from the same glTF texture or image.
         */
        this.useGltfTextureNames = false;
        /**
         * Function called before loading a url referenced by the asset.
         * @param url url referenced by the asset
         * @returns Async url to load
         */
        this.preprocessUrlAsync = function (url) { return Promise.resolve(url); };
        /**
         * Defines options for glTF extensions.
         */
        this.extensionOptions = {};
    }
    // eslint-disable-next-line babylonjs/available
    GLTFLoaderOptions.prototype.copyFrom = function (options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        if (options) {
            this.onParsed = options.onParsed;
            this.coordinateSystemMode = (_a = options.coordinateSystemMode) !== null && _a !== void 0 ? _a : this.coordinateSystemMode;
            this.animationStartMode = (_b = options.animationStartMode) !== null && _b !== void 0 ? _b : this.animationStartMode;
            this.loadNodeAnimations = (_c = options.loadNodeAnimations) !== null && _c !== void 0 ? _c : this.loadNodeAnimations;
            this.loadSkins = (_d = options.loadSkins) !== null && _d !== void 0 ? _d : this.loadSkins;
            this.loadMorphTargets = (_e = options.loadMorphTargets) !== null && _e !== void 0 ? _e : this.loadMorphTargets;
            this.compileMaterials = (_f = options.compileMaterials) !== null && _f !== void 0 ? _f : this.compileMaterials;
            this.useClipPlane = (_g = options.useClipPlane) !== null && _g !== void 0 ? _g : this.useClipPlane;
            this.compileShadowGenerators = (_h = options.compileShadowGenerators) !== null && _h !== void 0 ? _h : this.compileShadowGenerators;
            this.transparencyAsCoverage = (_j = options.transparencyAsCoverage) !== null && _j !== void 0 ? _j : this.transparencyAsCoverage;
            this.useRangeRequests = (_k = options.useRangeRequests) !== null && _k !== void 0 ? _k : this.useRangeRequests;
            this.createInstances = (_l = options.createInstances) !== null && _l !== void 0 ? _l : this.createInstances;
            this.alwaysComputeBoundingBox = (_m = options.alwaysComputeBoundingBox) !== null && _m !== void 0 ? _m : this.alwaysComputeBoundingBox;
            this.loadAllMaterials = (_o = options.loadAllMaterials) !== null && _o !== void 0 ? _o : this.loadAllMaterials;
            this.loadOnlyMaterials = (_p = options.loadOnlyMaterials) !== null && _p !== void 0 ? _p : this.loadOnlyMaterials;
            this.skipMaterials = (_q = options.skipMaterials) !== null && _q !== void 0 ? _q : this.skipMaterials;
            this.useSRGBBuffers = (_r = options.useSRGBBuffers) !== null && _r !== void 0 ? _r : this.useSRGBBuffers;
            this.targetFps = (_s = options.targetFps) !== null && _s !== void 0 ? _s : this.targetFps;
            this.alwaysComputeSkeletonRootNode = (_t = options.alwaysComputeSkeletonRootNode) !== null && _t !== void 0 ? _t : this.alwaysComputeSkeletonRootNode;
            this.useGltfTextureNames = (_u = options.useGltfTextureNames) !== null && _u !== void 0 ? _u : this.useGltfTextureNames;
            this.preprocessUrlAsync = (_v = options.preprocessUrlAsync) !== null && _v !== void 0 ? _v : this.preprocessUrlAsync;
            this.customRootNode = options.customRootNode;
            this.onMeshLoaded = options.onMeshLoaded;
            this.onSkinLoaded = options.onSkinLoaded;
            this.onTextureLoaded = options.onTextureLoaded;
            this.onMaterialLoaded = options.onMaterialLoaded;
            this.onCameraLoaded = options.onCameraLoaded;
            this.extensionOptions = (_w = options.extensionOptions) !== null && _w !== void 0 ? _w : this.extensionOptions;
        }
    };
    return GLTFLoaderOptions;
}());
/**
 * File loader for loading glTF files into a scene.
 */
var GLTFFileLoader = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(GLTFFileLoader, _super);
    /**
     * Creates a new glTF file loader.
     * @param options The options for the loader
     */
    function GLTFFileLoader(options) {
        var _this = _super.call(this) || this;
        // --------------------
        // Begin Common options
        // --------------------
        /**
         * Raised when the asset has been parsed
         */
        _this.onParsedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        // --------------
        // End V1 options
        // --------------
        /**
         * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.
         * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
         */
        _this.onMeshLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when the loader creates a skin after parsing the glTF properties of the skin node.
         * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh
         * @param node - the transform node that corresponds to the original glTF skin node used for animations
         * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes
         */
        _this.onSkinLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.
         */
        _this.onTextureLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when the loader creates a material after parsing the glTF properties of the material.
         */
        _this.onMaterialLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.
         */
        _this.onCameraLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when the asset is completely loaded, immediately before the loader is disposed.
         * For assets with LODs, raised when all of the LODs are complete.
         * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
         */
        _this.onCompleteObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised when an error occurs.
         */
        _this.onErrorObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised after the loader is disposed.
         */
        _this.onDisposeObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Observable raised after a loader extension is created.
         * Set additional options for a loader extension in this event.
         */
        _this.onExtensionLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * Defines if the loader should validate the asset.
         */
        _this.validate = false;
        /**
         * Observable raised after validation when validate is set to true. The event data is the result of the validation.
         */
        _this.onValidatedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        _this._loader = null;
        _this._state = null;
        _this._requests = new Array();
        /**
         * Name of the loader ("gltf")
         */
        _this.name = _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.name;
        /** @internal */
        _this.extensions = _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.extensions;
        /**
         * Observable raised when the loader state changes.
         */
        _this.onLoaderStateChangedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
        _this._logIndentLevel = 0;
        _this._loggingEnabled = false;
        /** @internal */
        _this._log = _this._logDisabled;
        _this._capturePerformanceCounters = false;
        /** @internal */
        _this._startPerformanceCounter = _this._startPerformanceCounterDisabled;
        /** @internal */
        _this._endPerformanceCounter = _this._endPerformanceCounterDisabled;
        _this.copyFrom(options);
        return _this;
    }
    Object.defineProperty(GLTFFileLoader.prototype, "onParsed", {
        /**
         * Raised when the asset has been parsed
         */
        set: function (callback) {
            if (this._onParsedObserver) {
                this.onParsedObservable.remove(this._onParsedObserver);
            }
            if (callback) {
                this._onParsedObserver = this.onParsedObservable.add(callback);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onMeshLoaded", {
        /**
         * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
         * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
         */
        set: function (callback) {
            if (this._onMeshLoadedObserver) {
                this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
            }
            if (callback) {
                this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onSkinLoaded", {
        /**
         * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.
         * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh
         */
        set: function (callback) {
            if (this._onSkinLoadedObserver) {
                this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);
            }
            if (callback) {
                this._onSkinLoadedObserver = this.onSkinLoadedObservable.add(function (data) { return callback(data.node, data.skinnedNode); });
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onTextureLoaded", {
        /**
         * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
         */
        set: function (callback) {
            if (this._onTextureLoadedObserver) {
                this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
            }
            if (callback) {
                this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onMaterialLoaded", {
        /**
         * Callback raised when the loader creates a material after parsing the glTF properties of the material.
         */
        set: function (callback) {
            if (this._onMaterialLoadedObserver) {
                this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
            }
            if (callback) {
                this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onCameraLoaded", {
        /**
         * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
         */
        set: function (callback) {
            if (this._onCameraLoadedObserver) {
                this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
            }
            if (callback) {
                this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onComplete", {
        /**
         * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
         * For assets with LODs, raised when all of the LODs are complete.
         * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
         */
        set: function (callback) {
            if (this._onCompleteObserver) {
                this.onCompleteObservable.remove(this._onCompleteObserver);
            }
            this._onCompleteObserver = this.onCompleteObservable.add(callback);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onError", {
        /**
         * Callback raised when an error occurs.
         */
        set: function (callback) {
            if (this._onErrorObserver) {
                this.onErrorObservable.remove(this._onErrorObserver);
            }
            this._onErrorObserver = this.onErrorObservable.add(callback);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onDispose", {
        /**
         * Callback raised after the loader is disposed.
         */
        set: function (callback) {
            if (this._onDisposeObserver) {
                this.onDisposeObservable.remove(this._onDisposeObserver);
            }
            this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onExtensionLoaded", {
        /**
         * Callback raised after a loader extension is created.
         */
        set: function (callback) {
            if (this._onExtensionLoadedObserver) {
                this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
            }
            this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "loggingEnabled", {
        /**
         * Defines if the loader logging is enabled.
         */
        get: function () {
            return this._loggingEnabled;
        },
        set: function (value) {
            if (this._loggingEnabled === value) {
                return;
            }
            this._loggingEnabled = value;
            if (this._loggingEnabled) {
                this._log = this._logEnabled;
            }
            else {
                this._log = this._logDisabled;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "capturePerformanceCounters", {
        /**
         * Defines if the loader should capture performance counters.
         */
        get: function () {
            return this._capturePerformanceCounters;
        },
        set: function (value) {
            if (this._capturePerformanceCounters === value) {
                return;
            }
            this._capturePerformanceCounters = value;
            if (this._capturePerformanceCounters) {
                this._startPerformanceCounter = this._startPerformanceCounterEnabled;
                this._endPerformanceCounter = this._endPerformanceCounterEnabled;
            }
            else {
                this._startPerformanceCounter = this._startPerformanceCounterDisabled;
                this._endPerformanceCounter = this._endPerformanceCounterDisabled;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onValidated", {
        /**
         * Callback raised after a loader extension is created.
         */
        set: function (callback) {
            if (this._onValidatedObserver) {
                this.onValidatedObservable.remove(this._onValidatedObserver);
            }
            this._onValidatedObserver = this.onValidatedObservable.add(callback);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Disposes the loader, releases resources during load, and cancels any outstanding requests.
     */
    GLTFFileLoader.prototype.dispose = function () {
        if (this._loader) {
            this._loader.dispose();
            this._loader = null;
        }
        for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
            var request = _a[_i];
            request.abort();
        }
        this._requests.length = 0;
        delete this._progressCallback;
        this.preprocessUrlAsync = function (url) { return Promise.resolve(url); };
        this.onMeshLoadedObservable.clear();
        this.onSkinLoadedObservable.clear();
        this.onTextureLoadedObservable.clear();
        this.onMaterialLoadedObservable.clear();
        this.onCameraLoadedObservable.clear();
        this.onCompleteObservable.clear();
        this.onExtensionLoadedObservable.clear();
        this.onDisposeObservable.notifyObservers(undefined);
        this.onDisposeObservable.clear();
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype.loadFile = function (scene, fileOrUrl, rootUrl, onSuccess, onProgress, useArrayBuffer, onError, name) {
        var _this = this;
        if (ArrayBuffer.isView(fileOrUrl)) {
            this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name);
            return null;
        }
        this._progressCallback = onProgress;
        var fileName = fileOrUrl.name || babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.GetFilename(fileOrUrl);
        if (useArrayBuffer) {
            if (this.useRangeRequests) {
                if (this.validate) {
                    babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("glTF validation is not supported when range requests are enabled");
                }
                var fileRequest_1 = {
                    abort: function () { },
                    onCompleteObservable: new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable(),
                };
                var dataBuffer = {
                    readAsync: function (byteOffset, byteLength) {
                        return new Promise(function (resolve, reject) {
                            _this._loadFile(scene, fileOrUrl, function (data) {
                                resolve(new Uint8Array(data));
                            }, true, function (error) {
                                reject(error);
                            }, function (webRequest) {
                                webRequest.setRequestHeader("Range", "bytes=".concat(byteOffset, "-").concat(byteOffset + byteLength - 1));
                            });
                        });
                    },
                    byteLength: 0,
                };
                this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader(dataBuffer)).then(function (loaderData) {
                    fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
                    onSuccess(loaderData);
                }, onError ? function (error) { return onError(undefined, error); } : undefined);
                return fileRequest_1;
            }
            return this._loadFile(scene, fileOrUrl, function (data) {
                _this._validate(scene, new Uint8Array(data, 0, data.byteLength), rootUrl, fileName);
                _this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                    readAsync: function (byteOffset, byteLength) { return readAsync(data, byteOffset, byteLength); },
                    byteLength: data.byteLength,
                })).then(function (loaderData) {
                    onSuccess(loaderData);
                }, onError ? function (error) { return onError(undefined, error); } : undefined);
            }, true, onError);
        }
        else {
            return this._loadFile(scene, fileOrUrl, function (data) {
                try {
                    _this._validate(scene, data, rootUrl, fileName);
                    onSuccess({ json: _this._parseJson(data) });
                }
                catch (_a) {
                    if (onError) {
                        onError();
                    }
                }
            }, false, onError);
        }
    };
    GLTFFileLoader.prototype._loadBinary = function (scene, data, rootUrl, onSuccess, onError, fileName) {
        this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);
        this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
            readAsync: function (byteOffset, byteLength) { return readViewAsync(data, byteOffset, byteLength); },
            byteLength: data.byteLength,
        })).then(function (loaderData) {
            onSuccess(loaderData);
        }, onError ? function (error) { return onError(undefined, error); } : undefined);
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, onProgress, fileName) {
        var _this = this;
        return Promise.resolve().then(function () {
            _this.onParsedObservable.notifyObservers(data);
            _this.onParsedObservable.clear();
            _this._log("Loading ".concat(fileName || ""));
            _this._loader = _this._getLoader(data);
            return _this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);
        });
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {
        var _this = this;
        return Promise.resolve().then(function () {
            _this.onParsedObservable.notifyObservers(data);
            _this.onParsedObservable.clear();
            _this._log("Loading ".concat(fileName || ""));
            _this._loader = _this._getLoader(data);
            return _this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);
        });
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl, onProgress, fileName) {
        var _this = this;
        return Promise.resolve().then(function () {
            _this.onParsedObservable.notifyObservers(data);
            _this.onParsedObservable.clear();
            _this._log("Loading ".concat(fileName || ""));
            _this._loader = _this._getLoader(data);
            // Prepare the asset container.
            var container = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
            // Get materials/textures when loading to add to container
            var materials = [];
            _this.onMaterialLoadedObservable.add(function (material) {
                materials.push(material);
            });
            var textures = [];
            _this.onTextureLoadedObservable.add(function (texture) {
                textures.push(texture);
            });
            var cameras = [];
            _this.onCameraLoadedObservable.add(function (camera) {
                cameras.push(camera);
            });
            var morphTargetManagers = [];
            _this.onMeshLoadedObservable.add(function (mesh) {
                if (mesh.morphTargetManager) {
                    morphTargetManagers.push(mesh.morphTargetManager);
                }
            });
            return _this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then(function (result) {
                Array.prototype.push.apply(container.geometries, result.geometries);
                Array.prototype.push.apply(container.meshes, result.meshes);
                Array.prototype.push.apply(container.particleSystems, result.particleSystems);
                Array.prototype.push.apply(container.skeletons, result.skeletons);
                Array.prototype.push.apply(container.animationGroups, result.animationGroups);
                Array.prototype.push.apply(container.materials, materials);
                Array.prototype.push.apply(container.textures, textures);
                Array.prototype.push.apply(container.lights, result.lights);
                Array.prototype.push.apply(container.transformNodes, result.transformNodes);
                Array.prototype.push.apply(container.cameras, cameras);
                Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);
                return container;
            });
        });
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype.canDirectLoad = function (data) {
        return _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.canDirectLoad(data);
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype.directLoad = function (scene, data) {
        if (data.startsWith("base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
            data.startsWith(";base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded) ||
            data.startsWith("application/octet-stream;base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded) ||
            data.startsWith("model/gltf-binary;base64," + _glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFMagicBase64Encoded)) {
            var arrayBuffer_1 = (0,babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DecodeBase64UrlToBinary)(data);
            this._validate(scene, new Uint8Array(arrayBuffer_1, 0, arrayBuffer_1.byteLength));
            return this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                readAsync: function (byteOffset, byteLength) { return readAsync(arrayBuffer_1, byteOffset, byteLength); },
                byteLength: arrayBuffer_1.byteLength,
            }));
        }
        this._validate(scene, data);
        return Promise.resolve({ json: this._parseJson(data) });
    };
    /** @internal */
    GLTFFileLoader.prototype.createPlugin = function (options) {
        return new GLTFFileLoader(options[_glTFFileLoader_metadata__WEBPACK_IMPORTED_MODULE_2__.GLTFFileLoaderMetadata.name]);
    };
    Object.defineProperty(GLTFFileLoader.prototype, "loaderState", {
        /**
         * The loader state or null if the loader is not active.
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a promise that resolves when the asset is completely loaded.
     * @returns a promise that resolves when the asset is completely loaded.
     */
    GLTFFileLoader.prototype.whenCompleteAsync = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.onCompleteObservable.addOnce(function () {
                resolve();
            });
            _this.onErrorObservable.addOnce(function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype._setState = function (state) {
        if (this._state === state) {
            return;
        }
        this._state = state;
        this.onLoaderStateChangedObservable.notifyObservers(this._state);
        this._log(GLTFLoaderState[this._state]);
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype._loadFile = function (scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {
        var _this = this;
        var request = scene._loadFile(fileOrUrl, onSuccess, function (event) {
            _this._onProgress(event, request);
        }, true, useArrayBuffer, onError, onOpened);
        request.onCompleteObservable.add(function () {
            // Force the length computable to be true since we can guarantee the data is loaded.
            request._lengthComputable = true;
            request._total = request._loaded;
        });
        this._requests.push(request);
        return request;
    };
    GLTFFileLoader.prototype._onProgress = function (event, request) {
        if (!this._progressCallback) {
            return;
        }
        request._lengthComputable = event.lengthComputable;
        request._loaded = event.loaded;
        request._total = event.total;
        var lengthComputable = true;
        var loaded = 0;
        var total = 0;
        for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
            var request_1 = _a[_i];
            if (request_1._lengthComputable === undefined || request_1._loaded === undefined || request_1._total === undefined) {
                return;
            }
            lengthComputable = lengthComputable && request_1._lengthComputable;
            loaded += request_1._loaded;
            total += request_1._total;
        }
        this._progressCallback({
            lengthComputable: lengthComputable,
            loaded: loaded,
            total: lengthComputable ? total : 0,
        });
    };
    GLTFFileLoader.prototype._validate = function (scene, data, rootUrl, fileName) {
        var _this = this;
        if (rootUrl === void 0) { rootUrl = ""; }
        if (fileName === void 0) { fileName = ""; }
        if (!this.validate) {
            return;
        }
        this._startPerformanceCounter("Validate JSON");
        _glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation.ValidateAsync(data, rootUrl, fileName, function (uri) {
            return _this.preprocessUrlAsync(rootUrl + uri).then(function (url) {
                return scene._loadFileAsync(url, undefined, true, true).then(function (data) {
                    return new Uint8Array(data, 0, data.byteLength);
                });
            });
        }).then(function (result) {
            _this._endPerformanceCounter("Validate JSON");
            _this.onValidatedObservable.notifyObservers(result);
            _this.onValidatedObservable.clear();
        }, function (reason) {
            _this._endPerformanceCounter("Validate JSON");
            babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Failed to validate: ".concat(reason.message));
            _this.onValidatedObservable.clear();
        });
    };
    GLTFFileLoader.prototype._getLoader = function (loaderData) {
        var asset = loaderData.json.asset || {};
        this._log("Asset version: ".concat(asset.version));
        asset.minVersion && this._log("Asset minimum version: ".concat(asset.minVersion));
        asset.generator && this._log("Asset generator: ".concat(asset.generator));
        var version = GLTFFileLoader._parseVersion(asset.version);
        if (!version) {
            throw new Error("Invalid version: " + asset.version);
        }
        if (asset.minVersion !== undefined) {
            var minVersion = GLTFFileLoader._parseVersion(asset.minVersion);
            if (!minVersion) {
                throw new Error("Invalid minimum version: " + asset.minVersion);
            }
            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
                throw new Error("Incompatible minimum version: " + asset.minVersion);
            }
        }
        var createLoaders = {
            1: GLTFFileLoader._CreateGLTF1Loader,
            2: GLTFFileLoader._CreateGLTF2Loader,
        };
        var createLoader = createLoaders[version.major];
        if (!createLoader) {
            throw new Error("Unsupported version: " + asset.version);
        }
        return createLoader(this);
    };
    GLTFFileLoader.prototype._parseJson = function (json) {
        this._startPerformanceCounter("Parse JSON");
        this._log("JSON length: ".concat(json.length));
        var parsed = JSON.parse(json);
        this._endPerformanceCounter("Parse JSON");
        return parsed;
    };
    GLTFFileLoader.prototype._unpackBinaryAsync = function (dataReader) {
        var _this = this;
        this._startPerformanceCounter("Unpack Binary");
        // Read magic + version + length + json length + json format
        return dataReader.loadAsync(20).then(function () {
            var Binary = {
                Magic: 0x46546c67,
            };
            var magic = dataReader.readUint32();
            if (magic !== Binary.Magic) {
                throw new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.RuntimeError("Unexpected magic: " + magic, babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes.GLTFLoaderUnexpectedMagicError);
            }
            var version = dataReader.readUint32();
            if (_this.loggingEnabled) {
                _this._log("Binary version: ".concat(version));
            }
            var length = dataReader.readUint32();
            if (!_this.useRangeRequests && length !== dataReader.buffer.byteLength) {
                babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Length in header does not match actual data length: ".concat(length, " != ").concat(dataReader.buffer.byteLength));
            }
            var unpacked;
            switch (version) {
                case 1: {
                    unpacked = _this._unpackBinaryV1Async(dataReader, length);
                    break;
                }
                case 2: {
                    unpacked = _this._unpackBinaryV2Async(dataReader, length);
                    break;
                }
                default: {
                    throw new Error("Unsupported version: " + version);
                }
            }
            _this._endPerformanceCounter("Unpack Binary");
            return unpacked;
        });
    };
    GLTFFileLoader.prototype._unpackBinaryV1Async = function (dataReader, length) {
        var ContentFormat = {
            JSON: 0,
        };
        var contentLength = dataReader.readUint32();
        var contentFormat = dataReader.readUint32();
        if (contentFormat !== ContentFormat.JSON) {
            throw new Error("Unexpected content format: ".concat(contentFormat));
        }
        var bodyLength = length - dataReader.byteOffset;
        var data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };
        if (bodyLength !== 0) {
            var startByteOffset_1 = dataReader.byteOffset;
            data.bin = {
                readAsync: function (byteOffset, byteLength) { return dataReader.buffer.readAsync(startByteOffset_1 + byteOffset, byteLength); },
                byteLength: bodyLength,
            };
        }
        return Promise.resolve(data);
    };
    GLTFFileLoader.prototype._unpackBinaryV2Async = function (dataReader, length) {
        var _this = this;
        var ChunkFormat = {
            JSON: 0x4e4f534a,
            BIN: 0x004e4942,
        };
        // Read the JSON chunk header.
        var chunkLength = dataReader.readUint32();
        var chunkFormat = dataReader.readUint32();
        if (chunkFormat !== ChunkFormat.JSON) {
            throw new Error("First chunk format is not JSON");
        }
        // Bail if there are no other chunks.
        if (dataReader.byteOffset + chunkLength === length) {
            return dataReader.loadAsync(chunkLength).then(function () {
                return { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
            });
        }
        // Read the JSON chunk and the length and type of the next chunk.
        return dataReader.loadAsync(chunkLength + 8).then(function () {
            var data = { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
            var readAsync = function () {
                var chunkLength = dataReader.readUint32();
                var chunkFormat = dataReader.readUint32();
                switch (chunkFormat) {
                    case ChunkFormat.JSON: {
                        throw new Error("Unexpected JSON chunk");
                    }
                    case ChunkFormat.BIN: {
                        var startByteOffset_2 = dataReader.byteOffset;
                        data.bin = {
                            readAsync: function (byteOffset, byteLength) { return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength); },
                            byteLength: chunkLength,
                        };
                        dataReader.skipBytes(chunkLength);
                        break;
                    }
                    default: {
                        // ignore unrecognized chunkFormat
                        dataReader.skipBytes(chunkLength);
                        break;
                    }
                }
                if (dataReader.byteOffset !== length) {
                    return dataReader.loadAsync(8).then(readAsync);
                }
                return Promise.resolve(data);
            };
            return readAsync();
        });
    };
    GLTFFileLoader._parseVersion = function (version) {
        if (version === "1.0" || version === "1.0.1") {
            return {
                major: 1,
                minor: 0,
            };
        }
        var match = (version + "").match(/^(\d+)\.(\d+)/);
        if (!match) {
            return null;
        }
        return {
            major: parseInt(match[1]),
            minor: parseInt(match[2]),
        };
    };
    GLTFFileLoader._compareVersion = function (a, b) {
        if (a.major > b.major) {
            return 1;
        }
        if (a.major < b.major) {
            return -1;
        }
        if (a.minor > b.minor) {
            return 1;
        }
        if (a.minor < b.minor) {
            return -1;
        }
        return 0;
    };
    /**
     * @internal
     */
    GLTFFileLoader.prototype._logOpen = function (message) {
        this._log(message);
        this._logIndentLevel++;
    };
    /** @internal */
    GLTFFileLoader.prototype._logClose = function () {
        --this._logIndentLevel;
    };
    GLTFFileLoader.prototype._logEnabled = function (message) {
        var spaces = GLTFFileLoader._logSpaces.substring(0, this._logIndentLevel * 2);
        babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Log("".concat(spaces).concat(message));
    };
    GLTFFileLoader.prototype._logDisabled = function (message) { };
    GLTFFileLoader.prototype._startPerformanceCounterEnabled = function (counterName) {
        babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.StartPerformanceCounter(counterName);
    };
    GLTFFileLoader.prototype._startPerformanceCounterDisabled = function (counterName) { };
    GLTFFileLoader.prototype._endPerformanceCounterEnabled = function (counterName) {
        babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.EndPerformanceCounter(counterName);
    };
    GLTFFileLoader.prototype._endPerformanceCounterDisabled = function (counterName) { };
    // ------------------
    // End Common options
    // ------------------
    // ----------------
    // Begin V1 options
    // ----------------
    /**
     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.
     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.
     * Defaults to true.
     * @internal
     */
    GLTFFileLoader.IncrementalLoading = true;
    /**
     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.
     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.
     * @internal
     */
    GLTFFileLoader.HomogeneousCoordinates = false;
    GLTFFileLoader._logSpaces = "                                ";
    return GLTFFileLoader;
}(GLTFLoaderOptions));

(0,babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.RegisterSceneLoaderPlugin)(new GLTFFileLoader());


/***/ }),

/***/ "../../../dev/loaders/src/glTF/glTFValidation.ts":
/*!*******************************************************!*\
  !*** ../../../dev/loaders/src/glTF/glTFValidation.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFValidation: () => (/* binding */ GLTFValidation)
/* harmony export */ });
/* harmony import */ var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylonjs/Misc/tools */ "babylonjs/Misc/tools");
/* harmony import */ var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__);

function ValidateAsync(data, rootUrl, fileName, getExternalResource) {
    var options = {
        externalResourceFunction: getExternalResource,
    };
    if (fileName) {
        options.uri = rootUrl === "file:" ? fileName : rootUrl + fileName;
    }
    return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);
}
/**
 * The worker function that gets converted to a blob url to pass into a worker.
 */
function WorkerFunc() {
    var pendingExternalResources = [];
    onmessage = function (message) {
        var data = message.data;
        switch (data.id) {
            case "init": {
                importScripts(data.url);
                break;
            }
            case "validate": {
                ValidateAsync(data.data, data.rootUrl, data.fileName, function (uri) {
                    return new Promise(function (resolve, reject) {
                        var index = pendingExternalResources.length;
                        pendingExternalResources.push({ resolve: resolve, reject: reject });
                        postMessage({ id: "getExternalResource", index: index, uri: uri });
                    });
                }).then(function (value) {
                    postMessage({ id: "validate.resolve", value: value });
                }, function (reason) {
                    postMessage({ id: "validate.reject", reason: reason });
                });
                break;
            }
            case "getExternalResource.resolve": {
                pendingExternalResources[data.index].resolve(data.value);
                break;
            }
            case "getExternalResource.reject": {
                pendingExternalResources[data.index].reject(data.reason);
                break;
            }
        }
    };
}
/**
 * glTF validation
 */
var GLTFValidation = /** @class */ (function () {
    function GLTFValidation() {
    }
    /**
     * Validate a glTF asset using the glTF-Validator.
     * @param data The JSON of a glTF or the array buffer of a binary glTF
     * @param rootUrl The root url for the glTF
     * @param fileName The file name for the glTF
     * @param getExternalResource The callback to get external resources for the glTF validator
     * @returns A promise that resolves with the glTF validation results once complete
     */
    GLTFValidation.ValidateAsync = function (data, rootUrl, fileName, getExternalResource) {
        var _this = this;
        if (typeof Worker === "function") {
            return new Promise(function (resolve, reject) {
                var workerContent = "".concat(ValidateAsync, "(").concat(WorkerFunc, ")()");
                var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
                var worker = new Worker(workerBlobUrl);
                var onError = function (error) {
                    worker.removeEventListener("error", onError);
                    worker.removeEventListener("message", onMessage);
                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                    reject(error);
                };
                var onMessage = function (message) {
                    var data = message.data;
                    switch (data.id) {
                        case "getExternalResource": {
                            getExternalResource(data.uri).then(function (value) {
                                worker.postMessage({ id: "getExternalResource.resolve", index: data.index, value: value }, [value.buffer]);
                            }, function (reason) {
                                worker.postMessage({ id: "getExternalResource.reject", index: data.index, reason: reason });
                            });
                            break;
                        }
                        case "validate.resolve": {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            resolve(data.value);
                            worker.terminate();
                            break;
                        }
                        case "validate.reject": {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                            reject(data.reason);
                            worker.terminate();
                        }
                    }
                };
                worker.addEventListener("error", onError);
                worker.addEventListener("message", onMessage);
                worker.postMessage({ id: "init", url: babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.GetBabylonScriptURL(_this.Configuration.url) });
                if (ArrayBuffer.isView(data)) {
                    // Slice the data to avoid copying the whole array buffer.
                    var slicedData = data.slice();
                    worker.postMessage({ id: "validate", data: slicedData, rootUrl: rootUrl, fileName: fileName }, [slicedData.buffer]);
                }
                else {
                    worker.postMessage({ id: "validate", data: data, rootUrl: rootUrl, fileName: fileName });
                }
            });
        }
        else {
            if (!this._LoadScriptPromise) {
                this._LoadScriptPromise = babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadBabylonScriptAsync(this.Configuration.url);
            }
            return this._LoadScriptPromise.then(function () {
                return ValidateAsync(data, rootUrl, fileName, getExternalResource);
            });
        }
    };
    /**
     * The configuration. Defaults to `{ url: "https://cdn.babylonjs.com/gltf_validator.js" }`.
     */
    GLTFValidation.Configuration = {
        url: "".concat(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools._DefaultCdnUrl, "/gltf_validator.js"),
    };
    return GLTFValidation;
}());



/***/ }),

/***/ "../../../dev/loaders/src/glTF/index.ts":
/*!**********************************************!*\
  !*** ../../../dev/loaders/src/glTF/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTF1: () => (/* reexport module object */ _1_0_index__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   GLTF2: () => (/* reexport module object */ _2_0_index__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   GLTFFileLoader: () => (/* reexport safe */ _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader),
/* harmony export */   GLTFLoaderAnimationStartMode: () => (/* reexport safe */ _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode),
/* harmony export */   GLTFLoaderCoordinateSystemMode: () => (/* reexport safe */ _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode),
/* harmony export */   GLTFLoaderState: () => (/* reexport safe */ _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState),
/* harmony export */   GLTFValidation: () => (/* reexport safe */ _glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation)
/* harmony export */ });
/* harmony import */ var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFFileLoader */ "../../../dev/loaders/src/glTF/glTFFileLoader.ts");
/* harmony import */ var _glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glTFValidation */ "../../../dev/loaders/src/glTF/glTFValidation.ts");
/* harmony import */ var _1_0_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./1.0/index */ "../../../dev/loaders/src/glTF/1.0/index.ts");
/* harmony import */ var _2_0_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2.0/index */ "../../../dev/loaders/src/glTF/2.0/index.ts");
/* eslint-disable import/no-internal-modules */







/***/ }),

/***/ "../../../dev/loaders/src/index.ts":
/*!*****************************************!*\
  !*** ../../../dev/loaders/src/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTF1: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTF1),
/* harmony export */   GLTF2: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTF2),
/* harmony export */   GLTFFileLoader: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader),
/* harmony export */   GLTFLoaderAnimationStartMode: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode),
/* harmony export */   GLTFLoaderCoordinateSystemMode: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode),
/* harmony export */   GLTFLoaderState: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState),
/* harmony export */   GLTFValidation: () => (/* reexport safe */ _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFValidation),
/* harmony export */   MTLFileLoader: () => (/* reexport safe */ _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.MTLFileLoader),
/* harmony export */   OBJFileLoader: () => (/* reexport safe */ _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoader),
/* harmony export */   SPLATFileLoader: () => (/* reexport safe */ _SPLAT_index__WEBPACK_IMPORTED_MODULE_3__.SPLATFileLoader),
/* harmony export */   STLFileLoader: () => (/* reexport safe */ _STL_index__WEBPACK_IMPORTED_MODULE_2__.STLFileLoader),
/* harmony export */   SolidParser: () => (/* reexport safe */ _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.SolidParser)
/* harmony export */ });
/* harmony import */ var _glTF_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTF/index */ "../../../dev/loaders/src/glTF/index.ts");
/* harmony import */ var _OBJ_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OBJ/index */ "../../../dev/loaders/src/OBJ/index.ts");
/* harmony import */ var _STL_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./STL/index */ "../../../dev/loaders/src/STL/index.ts");
/* harmony import */ var _SPLAT_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SPLAT/index */ "../../../dev/loaders/src/SPLAT/index.ts");
/* eslint-disable import/no-internal-modules */






/***/ }),

/***/ "../../../lts/loaders/src/legacy/legacy-glTF.ts":
/*!******************************************************!*\
  !*** ../../../lts/loaders/src/legacy/legacy-glTF.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFFileLoader: () => (/* reexport safe */ loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader),
/* harmony export */   GLTFLoaderAnimationStartMode: () => (/* reexport safe */ loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode),
/* harmony export */   GLTFLoaderCoordinateSystemMode: () => (/* reexport safe */ loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode),
/* harmony export */   GLTFLoaderState: () => (/* reexport safe */ loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState),
/* harmony export */   GLTFValidation: () => (/* reexport safe */ loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation)
/* harmony export */ });
/* harmony import */ var loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loaders/glTF/glTFFileLoader */ "../../../dev/loaders/src/glTF/glTFFileLoader.ts");
/* harmony import */ var loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! loaders/glTF/glTFValidation */ "../../../dev/loaders/src/glTF/glTFValidation.ts");


/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var GlobalObject = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : undefined;
if (typeof GlobalObject !== "undefined") {
    GlobalObject.BABYLON = GlobalObject.BABYLON || {};
    for (var key in loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__) {
        GlobalObject.BABYLON[key] = loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__[key];
    }
    for (var key in loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__) {
        GlobalObject.BABYLON[key] = loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__[key];
    }
}




/***/ }),

/***/ "../../../lts/loaders/src/legacy/legacy-glTF1.ts":
/*!*******************************************************!*\
  !*** ../../../lts/loaders/src/legacy/legacy-glTF1.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTF1: () => (/* reexport module object */ loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loaders/glTF/1.0/index */ "../../../dev/loaders/src/glTF/1.0/index.ts");
/* eslint-disable import/no-internal-modules */

/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var GlobalObject = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : undefined;
if (typeof GlobalObject !== "undefined") {
    GlobalObject.BABYLON = GlobalObject.BABYLON || {};
    GlobalObject.BABYLON.GLTF1 = GlobalObject.BABYLON.GLTF1 || {};
    for (var key in loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__) {
        GlobalObject.BABYLON.GLTF1[key] = loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__[key];
    }
}



/***/ }),

/***/ "../../../lts/loaders/src/legacy/legacy-glTF2.ts":
/*!*******************************************************!*\
  !*** ../../../lts/loaders/src/legacy/legacy-glTF2.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTF2: () => (/* reexport module object */ loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__)
/* harmony export */ });
/* harmony import */ var loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loaders/glTF/2.0/Extensions/index */ "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts");
/* harmony import */ var loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! loaders/glTF/2.0/glTFLoaderInterfaces */ "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts");
/* harmony import */ var loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loaders/glTF/2.0/index */ "../../../dev/loaders/src/glTF/2.0/index.ts");
/* eslint-disable import/no-internal-modules */



/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var GlobalObject = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : undefined;
if (typeof GlobalObject !== "undefined") {
    GlobalObject.BABYLON = GlobalObject.BABYLON || {};
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var BABYLON_1 = GlobalObject.BABYLON;
    BABYLON_1.GLTF2 = BABYLON_1.GLTF2 || {};
    BABYLON_1.GLTF2.Loader = BABYLON_1.GLTF2.Loader || {};
    BABYLON_1.GLTF2.Loader.Extensions = BABYLON_1.GLTF2.Loader.Extensions || {};
    var keys = [];
    for (var key in loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__) {
        BABYLON_1.GLTF2.Loader.Extensions[key] = loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__[key];
        keys.push(key);
    }
    for (var key in loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__) {
        BABYLON_1.GLTF2.Loader[key] = loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__[key];
        keys.push(key);
    }
    for (var key in loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__) {
        // Prevent Reassignment.
        if (keys.indexOf(key) > -1) {
            continue;
        }
        BABYLON_1.GLTF2[key] = loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__[key];
    }
}



/***/ }),

/***/ "../../../lts/loaders/src/legacy/legacy-objFileLoader.ts":
/*!***************************************************************!*\
  !*** ../../../lts/loaders/src/legacy/legacy-objFileLoader.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MTLFileLoader: () => (/* reexport safe */ loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader),
/* harmony export */   OBJFileLoader: () => (/* reexport safe */ loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.OBJFileLoader),
/* harmony export */   SolidParser: () => (/* reexport safe */ loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.SolidParser)
/* harmony export */ });
/* harmony import */ var loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loaders/OBJ/index */ "../../../dev/loaders/src/OBJ/index.ts");
/* eslint-disable import/no-internal-modules */

/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var GlobalObject = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : undefined;
if (typeof GlobalObject !== "undefined") {
    for (var key in loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__) {
        if (!GlobalObject.BABYLON[key]) {
            GlobalObject.BABYLON[key] = loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__[key];
        }
    }
}



/***/ }),

/***/ "../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts":
/*!***************************************************************!*\
  !*** ../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STLFileLoader: () => (/* reexport safe */ loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader)
/* harmony export */ });
/* harmony import */ var loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loaders/STL/index */ "../../../dev/loaders/src/STL/index.ts");
/* eslint-disable import/no-internal-modules */

/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var GlobalObject = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : undefined;
if (typeof GlobalObject !== "undefined") {
    for (var key in loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__) {
        if (!GlobalObject.BABYLON[key]) {
            GlobalObject.BABYLON[key] = loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__[key];
        }
    }
}



/***/ }),

/***/ "../../../lts/loaders/src/legacy/legacy.ts":
/*!*************************************************!*\
  !*** ../../../lts/loaders/src/legacy/legacy.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTF1: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTF1),
/* harmony export */   GLTF2: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTF2),
/* harmony export */   GLTFFileLoader: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader),
/* harmony export */   GLTFLoaderAnimationStartMode: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode),
/* harmony export */   GLTFLoaderCoordinateSystemMode: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode),
/* harmony export */   GLTFLoaderState: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState),
/* harmony export */   GLTFValidation: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFValidation),
/* harmony export */   MTLFileLoader: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader),
/* harmony export */   OBJFileLoader: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.OBJFileLoader),
/* harmony export */   SPLATFileLoader: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.SPLATFileLoader),
/* harmony export */   STLFileLoader: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader),
/* harmony export */   SolidParser: () => (/* reexport safe */ loaders_index__WEBPACK_IMPORTED_MODULE_0__.SolidParser)
/* harmony export */ });
/* harmony import */ var loaders_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loaders/index */ "../../../dev/loaders/src/index.ts");
/* harmony import */ var _legacy_glTF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legacy-glTF */ "../../../lts/loaders/src/legacy/legacy-glTF.ts");
/* harmony import */ var _legacy_glTF1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legacy-glTF1 */ "../../../lts/loaders/src/legacy/legacy-glTF1.ts");
/* harmony import */ var _legacy_glTF2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legacy-glTF2 */ "../../../lts/loaders/src/legacy/legacy-glTF2.ts");
/* harmony import */ var _legacy_objFileLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./legacy-objFileLoader */ "../../../lts/loaders/src/legacy/legacy-objFileLoader.ts");
/* harmony import */ var _legacy_stlFileLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./legacy-stlFileLoader */ "../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts");
/* eslint-disable import/export */
/* eslint-disable import/no-internal-modules */








/***/ }),

/***/ "babylonjs/Misc/tools":
/*!****************************************************************************************************!*\
  !*** external {"root":"BABYLON","commonjs":"babylonjs","commonjs2":"babylonjs","amd":"babylonjs"} ***!
  \****************************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_tools__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   loaders: () => (/* reexport module object */ _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lts/loaders/legacy/legacy */ "../../../lts/loaders/src/legacy/legacy.ts");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__);

})();

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFieWxvbmpzLmxvYWRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2haQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQUE7QUFNQTs7QUFFQTtBQUNBO0FBK01BO0FBN01BOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUF0TkE7O0FBRUE7QUFDQTtBQW9OQTtBQUFBO0FBeE5BOzs7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFZQTs7O0FBR0E7QUFDQTtBQW1FQTs7OztBQUlBO0FBQ0E7QUFsQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQVVBO0FBQ0E7QUE5REE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBSkE7QUE4REE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWxWQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFnU0E7QUFBQTtBQXBWQTtBQXNWQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRXJYQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBZ0JBOztBQUVBO0FBQ0E7QUFxRUE7Ozs7O0FBS0E7QUFDQTtBQXJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNjdCQTtBQUFBO0FBaCtCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFhQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7Ozs7QUFJQTtBQUNBO0FBZUE7OztBQUdBO0FBQ0E7QUFBQTtBQWxCQTs7QUFFQTtBQUNBO0FBRUE7QUFHQTs7O0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBQ0E7Ozs7QUFZQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFRQTtBQWFBOzs7O0FBcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQUNBOzs7QUFJQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUhBO0FBQ0E7OztBQUdBO0FBQ0E7QUE3Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBMmdCQTtBQUFBO0FBcmlCQTtBQXVpQkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRWhtQkE7Ozs7Ozs7Ozs7Ozs7OztBQ0dBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVlBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQTZPQTtBQXBPQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMU9BOzs7O0FBSUE7QUFDQTtBQXNPQTtBQUFBO0FBbFFBO0FBb1FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9SQTtBQUNBO0FBSUE7QUFJQTtBQWFBOzs7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQVVBO0FBUkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBT0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckNBOztBQUVBO0FBQ0E7QUFBQTtBQW1DQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFBQTtBQTZhQTtBQTVhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUErVEE7QUE1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFVQTtBQUVBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQVFBO0FBRUE7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7Ozs7Ozs7QUFPQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBYkE7Ozs7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdUQTtBQThUQTtBQUFBO0FBL1RBO0FBaVVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQUE7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcnlFQTs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7O0FBSUE7QUFDQTtBQUFBO0FBbVFBO0FBbFFBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFuUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0RBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFhQTs7QUFFQTtBQUNBO0FBQ0E7QUFlQTs7QUFFQTtBQUNBO0FBakJBOztBQUVBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBOztBQXpCQTtBQTZCQTtBQUNBOztBQUFBOzs7QUFFQTtBQUNBOztBQUFBOzs7QUFFQTtBQWlCQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQXNCQTs7QUFFQTtBQUNBO0FBQ0E7QUFjQTs7QUFFQTtBQUNBO0FBaEJBOztBQUVBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTs7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQWJBO0FBQUE7QUFjQTs7O0FBakJBO0FBQUE7QUFrQkE7QUFFQTtBQUVBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbExBO0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFhQTs7O0FBR0E7QUFDQTtBQUNBO0FBa0JBOztBQUVBO0FBQ0E7QUFwQkE7O0FBRUE7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBREE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6R0E7QUFJQTtBQUlBO0FBRUE7QUFFQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFhQTs7QUFFQTtBQUNBO0FBZkE7O0FBRUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7Ozs7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFwQkE7QUFDQTs7O0FBb0JBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZIQTtBQUdBO0FBQ0E7QUFFQTtBQWlCQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFhQTs7QUFFQTtBQUNBO0FBZkE7O0FBRUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTs7O0FBQ0E7QUFFQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBO0FBS0E7QUFFQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFTQTs7QUFFQTtBQUNBO0FBWEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBTkE7OztBQVVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RUE7QUFLQTtBQUVBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBU0E7O0FBRUE7QUFDQTtBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQU5BOzs7QUFVQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0RBO0FBRUE7QUFpQkE7O0FBRUE7QUFDQTtBQXFCQTs7QUFFQTtBQUNBO0FBdkJBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBZ0JBO0FBQ0E7QUFiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pHQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBOztBQUtBO0FBSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBOztBQVlBO0FBWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7O0FBS0E7QUFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUlBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1RBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFhQTs7O0FBR0E7QUFDQTtBQUNBO0FBU0E7O0FBRUE7QUFDQTtBQVhBOztBQUVBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFLQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUVBO0FBaUJBOztBQUVBO0FBQ0E7QUFDQTtBQXVCQTs7QUFFQTtBQUNBO0FBekJBOztBQUVBO0FBQ0E7QUFZQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7OztBQUtBO0FBQ0E7QUFFQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBYUE7O0FBRUE7QUFDQTtBQVlBOzs7QUFHQTtBQUNBO0FBQUE7QUFmQTs7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUFBOztBQUFBOztBQURBO0FBQ0E7QUFFQTs7Ozs7QUFDQTtBQUNBO0FBQUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQUE7OztBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TEE7QUFJQTtBQStKQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMktBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL3hEQTtBQUtBO0FBWUE7OztBQUdBO0FBQ0E7QUFBQTtBQWFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQ0E7QUFDQTtBQUVBO0FBZ0JBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWUE7QUFHQTtBQUZBO0FBQ0E7QUFDQTtBQWRBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQXpCQTtBQUFBO0FBQUE7QUEwQkE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBM0NBO0FBQ0E7QUFBQTtBQUFBO0FBMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBM0RBO0FBQUE7QUFBQTtBQTREQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQWVBOztBQUVBO0FBQ0E7QUFqQkE7O0FBRUE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUEvQ0E7OztBQWdEQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNySUE7QUFLQTtBQUVBO0FBRUE7QUFhQTs7QUFFQTtBQUNBO0FBQ0E7QUFrQkE7O0FBRUE7QUFDQTtBQXBCQTs7QUFFQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTs7OztBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFBQTs7Ozs7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakdBO0FBS0E7QUFFQTtBQUVBO0FBYUE7OztBQUdBO0FBQ0E7QUFDQTtBQWtCQTs7QUFFQTtBQUNBO0FBcEJBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2SUE7QUFLQTtBQUVBO0FBQ0E7QUFFQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFrQkE7O0FBRUE7QUFDQTtBQXBCQTs7QUFFQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pJQTtBQUlBO0FBRUE7QUFFQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFrQkE7O0FBRUE7QUFDQTtBQXBCQTs7QUFFQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUZBO0FBS0E7QUFFQTtBQUVBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBa0JBOztBQUVBO0FBQ0E7QUFwQkE7O0FBRUE7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7O0FBSEE7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUtBO0FBRUE7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQXVCQTs7QUFFQTtBQUNBO0FBcEJBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTlEQTs7QUFFQTtBQUNBO0FBNERBO0FBQUE7QUFoRUE7QUFrRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0ZBO0FBS0E7QUFFQTtBQUVBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBa0JBOztBQUVBO0FBQ0E7QUFwQkE7O0FBRUE7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBREE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUtBO0FBRUE7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQWtCQTs7QUFFQTtBQUNBO0FBcEJBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBREE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6SEE7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFrQkE7O0FBRUE7QUFDQTtBQXBCQTs7QUFFQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFEQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUhBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQWtCQTs7QUFFQTtBQUNBO0FBcEJBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SEE7QUFLQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUErQ0E7O0FBRUE7QUFDQTtBQWtDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQWhCQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBckRBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMENBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQWtCQTs7QUFFQTtBQUNBO0FBcEJBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3phQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBa0JBOztBQUVBO0FBQ0E7QUFwQkE7O0FBRUE7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0dBO0FBR0E7QUFNQTtBQUdBO0FBbURBOztBQUVBO0FBQ0E7QUFDQTtBQWVBOztBQUVBO0FBQ0E7QUFqQkE7O0FBRUE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFRQTs7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEVBO0FBQUE7QUF5RUE7QUFDQTs7QUFoRkE7QUFDQTtBQUFBO0FBaUZBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBOztBQUhBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JYQTtBQUtBO0FBRUE7QUFFQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFrQkE7O0FBRUE7QUFDQTtBQXBCQTs7QUFFQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNySEE7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQVdBOztBQUVBO0FBQ0E7QUFiQTs7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFFQTtBQUVBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBWUE7O0FBRUE7QUFDQTtBQWRBOztBQUVBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4TkE7QUFDQTtBQUVBO0FBRUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQVlBOztBQUVBO0FBQ0E7QUFkQTs7QUFFQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEpBO0FBRUE7QUFFQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFZQTs7QUFFQTtBQUNBO0FBZEE7O0FBRUE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlGQTtBQUtBO0FBRUE7QUFhQTs7QUFFQTtBQUNBO0FBQ0E7QUFTQTs7QUFFQTtBQUNBO0FBWEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBTkE7OztBQVVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUlBO0FBRUE7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQWFBOztBQUVBO0FBQ0E7QUFmQTs7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBNUJBOzs7QUE2QkE7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzFGQTtBQUVBO0FBYUE7OztBQUdBO0FBQ0E7QUFDQTtBQWtCQTs7QUFFQTtBQUNBO0FBcEJBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBR0E7QUFFQTtBQUVBO0FBb0NBOzs7QUFHQTtBQUNBO0FBQ0E7QUFlQTs7QUFFQTtBQUNBO0FBakJBOztBQUVBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFBQTs7OztBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7QUFoQkE7QUFBQTtBQUFBO0FBa0JBO0FBRUE7QUFDQTs7QUF0QkE7QUF1QkE7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBWEE7QUFBQTtBQWFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFVBO0FBQ0E7QUFPQTtBQUVBO0FBRUE7QUF3QkE7O0FBRUE7QUFDQTtBQUNBO0FBaURBOztBQUVBO0FBQ0E7O0FBbkRBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBbEJBO0FBQUE7QUFtQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBbEJBO0FBQUE7QUFtQkE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBbENBO0FBQUE7QUFtQ0E7QUFFQTtBQUNBO0FBQUE7OztBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBbkNBO0FBQUE7QUFvQ0E7QUFFQTtBQUNBO0FBQUE7OztBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7O0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6YkE7QUFJQTtBQUNBO0FBRUE7QUFhQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBVEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUlBO0FBQ0E7QUFFQTtBQWFBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFUQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBOzs7O0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUtBO0FBQ0E7QUFFQTtBQUlBO0FBSUE7QUErUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9rQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMENBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQWFBOztBQUVBO0FBQ0E7QUFBQTtBQXlDQTtBQXhDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUEyR0E7O0FBRUE7QUFDQTtBQTdHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFpRkE7QUFDQTtBQTNFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQUE7QUFLQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUtBO0FBSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBS0E7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQUE7QUFLQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUtBO0FBSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFNQTs7O0FBR0E7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTs7O0FBWUE7O0FBekNBO0FBQ0E7Ozs7QUF5Q0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7O0FBQ0E7QUFFQTs7Ozs7QUFDQTtBQUNBOzs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBM0JBOzs7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBM0hBOzs7O0FBNEhBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQVBBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7Ozs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTs7O0FBVUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7O0FBSUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7O0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOzs7O0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTs7QUFJQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFLQTtBQUVBO0FBQ0E7QUFPQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUF4eEZBOztBQUVBO0FBQ0E7QUFzeEZBO0FBQUE7QUF6ekZBO0FBMnpGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3gvRkE7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFPQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBOEJBO0FBN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQXJCQTtBQUFBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRS9GQTtBQVNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBRTlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFNQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBc0NBOztBQUVBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBMEJBO0FBQUE7QUE0Q0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFtQ0E7O0FBRUE7QUFDQTtBQVFBO0FBeE1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3S0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQU9BOzs7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBdUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBaUJBOzs7OztBQUtBO0FBQ0E7QUFpQkE7O0FBRUE7QUFDQTtBQWdCQTs7QUFFQTtBQUNBO0FBZ0JBOztBQUVBO0FBQ0E7QUFnQkE7Ozs7QUFJQTtBQUNBO0FBZ0JBOztBQUVBO0FBQ0E7QUFjQTs7QUFFQTtBQUNBO0FBY0E7OztBQUdBO0FBQ0E7QUEwREE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFjQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQWtUQTs7QUFFQTtBQUNBO0FBdVVBO0FBQ0E7QUFFQTtBQUNBO0FBc0JBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUE1OEJBOztBQUNBO0FBZ0JBO0FBSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQXlDQTtBQUpBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBZ0JBO0FBSkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFZQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFZQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFZQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFnQkE7QUFMQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQVlBO0FBSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBWUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFhQTtBQUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUtBO0FBSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQWRBO0FBbUJBO0FBSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFoQkE7QUFpQ0E7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFlQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUlBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFPQTs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBUUE7QUFJQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQTk3QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQTQzQkE7QUE4Q0E7QUFBQTtBQXQrQkE7QUF3K0JBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ24zQ0E7QUFXQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7O0FBRUE7QUFDQTtBQUFBO0FBMkZBO0FBakZBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBcUZBO0FBQUE7QUEzRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUEE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNQQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xPQURFUlMvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvT0JKL2luZGV4LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL09CSi9tdGxGaWxlTG9hZGVyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL09CSi9vYmpGaWxlTG9hZGVyLm1ldGFkYXRhLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL09CSi9vYmpGaWxlTG9hZGVyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL09CSi9vYmpMb2FkaW5nT3B0aW9ucy50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9PQkovc29saWRQYXJzZXIudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvU1BMQVQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvU1BMQVQvc3BsYXRGaWxlTG9hZGVyLm1ldGFkYXRhLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL1NQTEFUL3NwbGF0RmlsZUxvYWRlci50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9TUExBVC9zcGxhdExvYWRpbmdPcHRpb25zLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL1NUTC9pbmRleC50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9TVEwvc3RsRmlsZUxvYWRlci5tZXRhZGF0YS50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9TVEwvc3RsRmlsZUxvYWRlci50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzEuMC9nbFRGQmluYXJ5RXh0ZW5zaW9uLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMS4wL2dsVEZMb2FkZXIudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8xLjAvZ2xURkxvYWRlckludGVyZmFjZXMudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8xLjAvZ2xURkxvYWRlclV0aWxzLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMS4wL2dsVEZNYXRlcmlhbHNDb21tb25FeHRlbnNpb24udHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8xLjAvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9FWFRfbGlnaHRzX2llcy50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0VYVF9saWdodHNfaW1hZ2VfYmFzZWQudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9FWFRfbWF0ZXJpYWxzX2RpZmZ1c2Vfcm91Z2huZXNzLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvRVhUX21lc2hfZ3B1X2luc3RhbmNpbmcudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9FWFRfbWVzaG9wdF9jb21wcmVzc2lvbi50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0VYVF90ZXh0dXJlX2F2aWYudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9FWFRfdGV4dHVyZV93ZWJwLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvRXh0cmFzQXNNZXRhZGF0YS50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9hbmltYXRpb25fcG9pbnRlci5kYXRhLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX2FuaW1hdGlvbl9wb2ludGVyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24udHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfaW50ZXJhY3Rpdml0eS50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9pbnRlcmFjdGl2aXR5L2RlY2xhcmF0aW9uTWFwcGVyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX2ludGVyYWN0aXZpdHkvZmxvd0dyYXBoR0xURkRhdGFQcm92aWRlci50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9pbnRlcmFjdGl2aXR5L2luZGV4LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX2ludGVyYWN0aXZpdHkvaW50ZXJhY3Rpdml0eUdyYXBoUGFyc2VyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX2xpZ2h0c19wdW5jdHVhbC50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfYW5pc290cm9weS50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19kaWZmdXNlX3RyYW5zbWlzc2lvbi50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfZGlzcGVyc2lvbi50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGgudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2lvci50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2UudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcy50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc2hlZW4udHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc190cmFuc21pc3Npb24udHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3VubGl0LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc192YXJpYW50cy50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfdm9sdW1lLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX21lc2hfcXVhbnRpemF0aW9uLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX25vZGVfaG92ZXJhYmlsaXR5LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvS0hSX25vZGVfc2VsZWN0YWJpbGl0eS50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL0tIUl9ub2RlX3Zpc2liaWxpdHkudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV9iYXNpc3UudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9LSFJfeG1wX2pzb25fbGQudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9NU0ZUX2F1ZGlvX2VtaXR0ZXIudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9NU0ZUX2xvZC50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL01TRlRfbWluZWNyYWZ0TWVzaC50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9FeHRlbnNpb25zL01TRlRfc1JHQkZhY3RvcnMudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9nbHRmUGF0aFRvT2JqZWN0Q29udmVydGVyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL0V4dGVuc2lvbnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvRXh0ZW5zaW9ucy9vYmplY3RNb2RlbE1hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvZ2xURkxvYWRlci50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGLzIuMC9nbFRGTG9hZGVyQW5pbWF0aW9uLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL2dsVEZMb2FkZXJFeHRlbnNpb24udHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi8yLjAvZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL2dsVEZMb2FkZXJJbnRlcmZhY2VzLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvMi4wL2luZGV4LnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvZ2xURkZpbGVMb2FkZXIubWV0YWRhdGEudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvZ2xURi9nbFRGRmlsZUxvYWRlci50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2Rldi9sb2FkZXJzL3NyYy9nbFRGL2dsVEZWYWxpZGF0aW9uLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vZGV2L2xvYWRlcnMvc3JjL2dsVEYvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9kZXYvbG9hZGVycy9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9sdHMvbG9hZGVycy9zcmMvbGVnYWN5L2xlZ2FjeS1nbFRGLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vbHRzL2xvYWRlcnMvc3JjL2xlZ2FjeS9sZWdhY3ktZ2xURjEudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9sdHMvbG9hZGVycy9zcmMvbGVnYWN5L2xlZ2FjeS1nbFRGMi50cyIsIndlYnBhY2s6Ly9MT0FERVJTLy4uLy4uLy4uL2x0cy9sb2FkZXJzL3NyYy9sZWdhY3kvbGVnYWN5LW9iakZpbGVMb2FkZXIudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy8uLi8uLi8uLi9sdHMvbG9hZGVycy9zcmMvbGVnYWN5L2xlZ2FjeS1zdGxGaWxlTG9hZGVyLnRzIiwid2VicGFjazovL0xPQURFUlMvLi4vLi4vLi4vbHRzL2xvYWRlcnMvc3JjL2xlZ2FjeS9sZWdhY3kudHMiLCJ3ZWJwYWNrOi8vTE9BREVSUy9leHRlcm5hbCB1bWQge1wicm9vdFwiOlwiQkFCWUxPTlwiLFwiY29tbW9uanNcIjpcImJhYnlsb25qc1wiLFwiY29tbW9uanMyXCI6XCJiYWJ5bG9uanNcIixcImFtZFwiOlwiYmFieWxvbmpzXCJ9Iiwid2VicGFjazovL0xPQURFUlMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vTE9BREVSUy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9MT0FERVJTL3dlYnBhY2svcnVudGltZS9jcmVhdGUgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0xPQURFUlMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0xPQURFUlMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9MT0FERVJTL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vTE9BREVSUy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0xPQURFUlMvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiYmFieWxvbmpzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiYmFieWxvbmpzLWxvYWRlcnNcIiwgW1wiYmFieWxvbmpzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImJhYnlsb25qcy1sb2FkZXJzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiYmFieWxvbmpzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJMT0FERVJTXCJdID0gZmFjdG9yeShyb290W1wiQkFCWUxPTlwiXSk7XG59KSgodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMpLCAoX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9iYWJ5bG9uanNfTWlzY190b29sc19fKSA9PiB7XG5yZXR1cm4gIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vbXRsRmlsZUxvYWRlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9vYmpMb2FkaW5nT3B0aW9uc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9zb2xpZFBhcnNlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9vYmpGaWxlTG9hZGVyXCI7XHJcbiIsImltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZVwiO1xyXG5pbXBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL3N0YW5kYXJkTWF0ZXJpYWxcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgU2NlbmUgfSBmcm9tIFwiY29yZS9zY2VuZVwiO1xyXG5pbXBvcnQgdHlwZSB7IEFzc2V0Q29udGFpbmVyIH0gZnJvbSBcImNvcmUvYXNzZXRDb250YWluZXJcIjtcclxuLyoqXHJcbiAqIENsYXNzIHJlYWRpbmcgYW5kIHBhcnNpbmcgdGhlIE1UTCBmaWxlIGJ1bmRsZWQgd2l0aCB0aGUgb2JqIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTVRMRmlsZUxvYWRlciB7XHJcbiAgICAvKipcclxuICAgICAqIEludmVydCBZLUF4aXMgb2YgcmVmZXJlbmNlZCB0ZXh0dXJlcyBvbiBsb2FkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJUX1RFWFRVUkVfWSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgbWF0ZXJpYWwgbG9hZGVkIGZyb20gdGhlIG10bCB3aWxsIGJlIHNldCBoZXJlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXRlcmlhbHM6IFN0YW5kYXJkTWF0ZXJpYWxbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJlYWQgdGhlIG10bCBmaWxlIGFuZCBjcmVhdGUgZWFjaCBtYXRlcmlhbCBkZXNjcmliZWQgaW5zaWRlXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIGltcHJvdmUgYnkgYWRkaW5nIDpcclxuICAgICAqIC1zb21lIGNvbXBvbmVudCBtaXNzaW5nIChOaSwgVGYuLi4pXHJcbiAgICAgKiAtaW5jbHVkaW5nIHRoZSBzcGVjaWZpYyBvcHRpb25zIGF2YWlsYWJsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzY2VuZSBkZWZpbmVzIHRoZSBzY2VuZSB0aGUgbWF0ZXJpYWwgd2lsbCBiZSBjcmVhdGVkIGluXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSBtdGwgZGF0YSB0byBwYXJzZVxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgZGVmaW5lcyB0aGUgcm9vdHVybCB0byB1c2UgaW4gb3JkZXIgdG8gbG9hZCByZWxhdGl2ZSBkZXBlbmRlbmNpZXNcclxuICAgICAqIEBwYXJhbSBhc3NldENvbnRhaW5lciBkZWZpbmVzIHRoZSBhc3NldCBjb250YWluZXIgdG8gc3RvcmUgdGhlIG1hdGVyaWFsIGluIChjYW4gYmUgbnVsbClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBhcnNlTVRMKHNjZW5lOiBTY2VuZSwgZGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXIsIHJvb3RVcmw6IHN0cmluZywgYXNzZXRDb250YWluZXI6IE51bGxhYmxlPEFzc2V0Q29udGFpbmVyPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TcGxpdCB0aGUgbGluZXMgZnJvbSB0aGUgZmlsZVxyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAvLyB3aGl0ZXNwYWNlIGNoYXIgaWU6IFsgXFx0XFxyXFxuXFxmXVxyXG4gICAgICAgIGNvbnN0IGRlbGltaXRlclBhdHRlcm4gPSAvXFxzKy87XHJcbiAgICAgICAgLy9BcnJheSB3aXRoIFJHQiBjb2xvcnNcclxuICAgICAgICBsZXQgY29sb3I6IG51bWJlcltdO1xyXG4gICAgICAgIC8vTmV3IG1hdGVyaWFsXHJcbiAgICAgICAgbGV0IG1hdGVyaWFsOiBOdWxsYWJsZTxTdGFuZGFyZE1hdGVyaWFsPiA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vTG9vayBhdCBlYWNoIGxpbmVcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBCbGFuayBsaW5lIG9yIGNvbW1lbnRcclxuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KDApID09PSBcIiNcIikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBmaXJzdCBwYXJhbWV0ZXIgKGtleXdvcmQpXHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxpbmUuaW5kZXhPZihcIiBcIik7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBwb3MgPj0gMCA/IGxpbmUuc3Vic3RyaW5nKDAsIHBvcykgOiBsaW5lO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBkYXRhIGZvbGxvd2luZyB0aGUga2V5XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlOiBzdHJpbmcgPSBwb3MgPj0gMCA/IGxpbmUuc3Vic3RyaW5nKHBvcyArIDEpLnRyaW0oKSA6IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAvL1RoaXMgbXRsIGtleXdvcmQgd2lsbCBjcmVhdGUgdGhlIG5ldyBtYXRlcmlhbFxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIm5ld210bFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIGl0IGlzIHRoZSBmaXJzdCBtYXRlcmlhbC5cclxuICAgICAgICAgICAgICAgIC8vIE1hdGVyaWFscyBzcGVjaWZpY2F0aW9ucyBhcmUgZGVzY3JpYmVkIGFmdGVyIHRoaXMga2V5d29yZC5cclxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vQWRkIHRoZSBwcmV2aW91cyBtYXRlcmlhbCBpbiB0aGUgbWF0ZXJpYWwgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBtYXRlcmlhbC5cclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIGlzIHRoZSBuYW1lIG9mIHRoZSBtYXRlcmlhbCByZWFkIGluIHRoZSBtdGwgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIWFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgU3RhbmRhcmRNYXRlcmlhbCh2YWx1ZSwgc2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuX3BhcmVudENvbnRhaW5lciA9IGFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgc2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJrZFwiICYmIG1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaWZmdXNlIGNvbG9yIChjb2xvciB1bmRlciB3aGl0ZSBsaWdodCkgdXNpbmcgUkdCIHZhbHVlc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFsdWUgID0gXCJyIGcgYlwiXHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IHZhbHVlLnNwbGl0KGRlbGltaXRlclBhdHRlcm4sIDMpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgICAgICAgICAgICAgIC8vY29sb3IgPSBbcixnLGJdXHJcbiAgICAgICAgICAgICAgICAvL1NldCB0Z2hlIGNvbG9yIGludG8gdGhlIG1hdGVyaWFsXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBDb2xvcjMuRnJvbUFycmF5KGNvbG9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwia2FcIiAmJiBtYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQW1iaWVudCBjb2xvciAoY29sb3IgdW5kZXIgc2hhZG93KSB1c2luZyBSR0IgdmFsdWVzXHJcblxyXG4gICAgICAgICAgICAgICAgLy92YWx1ZSA9IFwiciBnIGJcIlxyXG4gICAgICAgICAgICAgICAgY29sb3IgPSB2YWx1ZS5zcGxpdChkZWxpbWl0ZXJQYXR0ZXJuLCAzKS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbG9yID0gW3IsZyxiXVxyXG4gICAgICAgICAgICAgICAgLy9TZXQgdGdoZSBjb2xvciBpbnRvIHRoZSBtYXRlcmlhbFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuYW1iaWVudENvbG9yID0gQ29sb3IzLkZyb21BcnJheShjb2xvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImtzXCIgJiYgbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNwZWN1bGFyIGNvbG9yIChjb2xvciB3aGVuIGxpZ2h0IGlzIHJlZmxlY3RlZCBmcm9tIHNoaW55IHN1cmZhY2UpIHVzaW5nIFJHQiB2YWx1ZXNcclxuXHJcbiAgICAgICAgICAgICAgICAvL3ZhbHVlID0gXCJyIGcgYlwiXHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IHZhbHVlLnNwbGl0KGRlbGltaXRlclBhdHRlcm4sIDMpLm1hcChwYXJzZUZsb2F0KTtcclxuICAgICAgICAgICAgICAgIC8vY29sb3IgPSBbcixnLGJdXHJcbiAgICAgICAgICAgICAgICAvL1NldCB0aGUgY29sb3IgaW50byB0aGUgbWF0ZXJpYWxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBDb2xvcjMuRnJvbUFycmF5KGNvbG9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwia2VcIiAmJiBtYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW1pc3NpdmUgY29sb3IgdXNpbmcgUkdCIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSB2YWx1ZS5zcGxpdChkZWxpbWl0ZXJQYXR0ZXJuLCAzKS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5lbWlzc2l2ZUNvbG9yID0gQ29sb3IzLkZyb21BcnJheShjb2xvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm5zXCIgJiYgbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIC8vdmFsdWUgPSBcIkludGVnZXJcIlxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXJQb3dlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJkXCIgJiYgbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIC8vZCBpcyBkaXNzb2x2ZSBmb3IgY3VycmVudCBtYXRlcmlhbC4gSXQgbWVhbiBhbHBoYSBmb3IgQkFCWUxPTlxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuYWxwaGEgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1RleHR1cmVcclxuICAgICAgICAgICAgICAgIC8vVGhpcyBwYXJ0IGNhbiBiZSBpbXByb3ZlZCBieSBhZGRpbmcgdGhlIHBvc3NpYmxlIG9wdGlvbnMgb2YgdGV4dHVyZVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJtYXBfa2FcIiAmJiBtYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYW1iaWVudCB0ZXh0dXJlIG1hcCB3aXRoIGEgbG9hZGVkIGltYWdlXHJcbiAgICAgICAgICAgICAgICAvL1dlIG11c3QgZmlyc3QgZ2V0IHRoZSBmb2xkZXIgb2YgdGhlIGltYWdlXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5hbWJpZW50VGV4dHVyZSA9IE1UTEZpbGVMb2FkZXIuX0dldFRleHR1cmUocm9vdFVybCwgdmFsdWUsIHNjZW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWFwX2tkXCIgJiYgbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIERpZmZ1c2UgdGV4dHVyZSBtYXAgd2l0aCBhIGxvYWRlZCBpbWFnZVxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZVRleHR1cmUgPSBNVExGaWxlTG9hZGVyLl9HZXRUZXh0dXJlKHJvb3RVcmwsIHZhbHVlLCBzY2VuZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1hcF9rc1wiICYmIG1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTcGVjdWxhciB0ZXh0dXJlIG1hcCB3aXRoIGEgbG9hZGVkIGltYWdlXHJcbiAgICAgICAgICAgICAgICAvL1dlIG11c3QgZmlyc3QgZ2V0IHRoZSBmb2xkZXIgb2YgdGhlIGltYWdlXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5zcGVjdWxhclRleHR1cmUgPSBNVExGaWxlTG9hZGVyLl9HZXRUZXh0dXJlKHJvb3RVcmwsIHZhbHVlLCBzY2VuZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1hcF9uc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvL1NwZWN1bGFyXHJcbiAgICAgICAgICAgICAgICAvL1NwZWN1bGFyIGhpZ2hsaWdodCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIC8vV2UgbXVzdCBmaXJzdCBnZXQgdGhlIGZvbGRlciBvZiB0aGUgaW1hZ2VcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvL05vdCBzdXBwb3J0ZWQgYnkgQkFCWUxPTlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJtYXBfYnVtcFwiICYmIG1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RoZSBidW1wIHRleHR1cmVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlLnNwbGl0KGRlbGltaXRlclBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVtcE11bHRpcGxpZXJJbmRleCA9IHZhbHVlcy5pbmRleE9mKFwiLWJtXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJ1bXBNdWx0aXBsaWVyOiBOdWxsYWJsZTxzdHJpbmc+ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYnVtcE11bHRpcGxpZXJJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVtcE11bHRpcGxpZXIgPSB2YWx1ZXNbYnVtcE11bHRpcGxpZXJJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zcGxpY2UoYnVtcE11bHRpcGxpZXJJbmRleCwgMik7IC8vIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmJ1bXBUZXh0dXJlID0gTVRMRmlsZUxvYWRlci5fR2V0VGV4dHVyZShyb290VXJsLCB2YWx1ZXMuam9pbihcIiBcIiksIHNjZW5lKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5idW1wVGV4dHVyZSAmJiBidW1wTXVsdGlwbGllciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmJ1bXBUZXh0dXJlLmxldmVsID0gcGFyc2VGbG9hdChidW1wTXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1hcF9kXCIgJiYgbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkaXNzb2x2ZSBvZiB0aGUgbWF0ZXJpYWxcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLm9wYWNpdHlUZXh0dXJlID0gTVRMRmlsZUxvYWRlci5fR2V0VGV4dHVyZShyb290VXJsLCB2YWx1ZSwgc2NlbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vT3B0aW9ucyBmb3IgaWxsdW1pbmF0aW9uXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImlsbHVtXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vSWxsdW1pbmF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiMFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGF0IG1lYW4gS2QgPT0gS2RcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiMVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Db2xvciBvbiBhbmQgQW1iaWVudCBvblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCIyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0hpZ2hsaWdodCBvblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCIzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1JlZmxlY3Rpb24gb24gYW5kIFJheSB0cmFjZSBvblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCI0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zcGFyZW5jeTogR2xhc3Mgb24sIFJlZmxlY3Rpb246IFJheSB0cmFjZSBvblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCI1XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1JlZmxlY3Rpb246IEZyZXNuZWwgb24gYW5kIFJheSB0cmFjZSBvblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCI2XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zcGFyZW5jeTogUmVmcmFjdGlvbiBvbiwgUmVmbGVjdGlvbjogRnJlc25lbCBvZmYgYW5kIFJheSB0cmFjZSBvblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCI3XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zcGFyZW5jeTogUmVmcmFjdGlvbiBvbiwgUmVmbGVjdGlvbjogRnJlc25lbCBvbiBhbmQgUmF5IHRyYWNlIG9uXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIjhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vUmVmbGVjdGlvbiBvbiBhbmQgUmF5IHRyYWNlIG9mZlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCI5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zcGFyZW5jeTogR2xhc3Mgb24sIFJlZmxlY3Rpb246IFJheSB0cmFjZSBvZmZcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiMTBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vQ2FzdHMgc2hhZG93cyBvbnRvIGludmlzaWJsZSBzdXJmYWNlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJVbmhhbmRsZWQgZXhwcmVzc2lvbiBhdCBsaW5lIDogXCIgKyBpICsnXFxuJyArIFwid2l0aCB2YWx1ZSA6IFwiICsgbGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9BdCB0aGUgZW5kIG9mIHRoZSBmaWxlLCBhZGQgdGhlIGxhc3QgbWF0ZXJpYWxcclxuICAgICAgICBpZiAobWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGV4dHVyZSBmb3IgdGhlIG1hdGVyaWFsLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBtYXRlcmlhbCBpcyBpbXBvcnRlZCBmcm9tIGlucHV0IGZpbGUsXHJcbiAgICAgKiBXZSBzYW5pdGl6ZSB0aGUgdXJsIHRvIGVuc3VyZSBpdCB0YWtlcyB0aGUgdGV4dHVyZSBmcm9tIGFzaWRlIHRoZSBtYXRlcmlhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBUaGUgcm9vdCB1cmwgdG8gbG9hZCBmcm9tXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHN0b3JlZCBpbiB0aGUgbXRsXHJcbiAgICAgKiBAcGFyYW0gc2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBUZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9HZXRUZXh0dXJlKHJvb3RVcmw6IHN0cmluZywgdmFsdWU6IHN0cmluZywgc2NlbmU6IFNjZW5lKTogTnVsbGFibGU8VGV4dHVyZT4ge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdXJsID0gcm9vdFVybDtcclxuICAgICAgICAvLyBMb2FkIGZyb20gaW5wdXQgZmlsZS5cclxuICAgICAgICBpZiAocm9vdFVybCA9PT0gXCJmaWxlOlwiKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0RGVsaW1pdGVyID0gdmFsdWUubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xyXG4gICAgICAgICAgICBpZiAobGFzdERlbGltaXRlciA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxhc3REZWxpbWl0ZXIgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi9cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsYXN0RGVsaW1pdGVyID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHVybCArPSB2YWx1ZS5zdWJzdHJpbmcobGFzdERlbGltaXRlciArIDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXJsICs9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdCBmcm9tIGlucHV0IGZpbGUuXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVybCArPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZSh1cmwsIHNjZW5lLCBmYWxzZSwgTVRMRmlsZUxvYWRlci5JTlZFUlRfVEVYVFVSRV9ZKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXNcclxuaW1wb3J0IHR5cGUgeyBJU2NlbmVMb2FkZXJQbHVnaW5NZXRhZGF0YSB9IGZyb20gXCJjb3JlL2luZGV4XCI7XHJcblxyXG5leHBvcnQgY29uc3QgT0JKRmlsZUxvYWRlck1ldGFkYXRhID0ge1xyXG4gICAgbmFtZTogXCJvYmpcIixcclxuICAgIGV4dGVuc2lvbnM6IFwiLm9ialwiLFxyXG59IGFzIGNvbnN0IHNhdGlzZmllcyBJU2NlbmVMb2FkZXJQbHVnaW5NZXRhZGF0YTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgeyBUb29scyB9IGZyb20gXCJjb3JlL01pc2MvdG9vbHNcIjtcclxuaW1wb3J0IHR5cGUgeyBBYnN0cmFjdE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvYWJzdHJhY3RNZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgSVNjZW5lTG9hZGVyUGx1Z2luQXN5bmMsIElTY2VuZUxvYWRlclBsdWdpbkZhY3RvcnksIElTY2VuZUxvYWRlclBsdWdpbiwgSVNjZW5lTG9hZGVyQXN5bmNSZXN1bHQsIFNjZW5lTG9hZGVyUGx1Z2luT3B0aW9ucyB9IGZyb20gXCJjb3JlL0xvYWRpbmcvc2NlbmVMb2FkZXJcIjtcclxuaW1wb3J0IHsgUmVnaXN0ZXJTY2VuZUxvYWRlclBsdWdpbiB9IGZyb20gXCJjb3JlL0xvYWRpbmcvc2NlbmVMb2FkZXJcIjtcclxuaW1wb3J0IHsgQXNzZXRDb250YWluZXIgfSBmcm9tIFwiY29yZS9hc3NldENvbnRhaW5lclwiO1xyXG5pbXBvcnQgdHlwZSB7IFNjZW5lIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuaW1wb3J0IHR5cGUgeyBXZWJSZXF1ZXN0IH0gZnJvbSBcImNvcmUvTWlzYy93ZWJSZXF1ZXN0XCI7XHJcbmltcG9ydCB7IE9CSkZpbGVMb2FkZXJNZXRhZGF0YSB9IGZyb20gXCIuL29iakZpbGVMb2FkZXIubWV0YWRhdGFcIjtcclxuaW1wb3J0IHsgTVRMRmlsZUxvYWRlciB9IGZyb20gXCIuL210bEZpbGVMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBPQkpMb2FkaW5nT3B0aW9ucyB9IGZyb20gXCIuL29iakxvYWRpbmdPcHRpb25zXCI7XHJcbmltcG9ydCB7IFNvbGlkUGFyc2VyIH0gZnJvbSBcIi4vc29saWRQYXJzZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL21lc2hcIjtcclxuaW1wb3J0IHsgU3RhbmRhcmRNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9zdGFuZGFyZE1hdGVyaWFsXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcImNvcmUvTG9hZGluZy9zY2VuZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2NlbmVMb2FkZXJQbHVnaW5PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBvYmogbG9hZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFtPQkpGaWxlTG9hZGVyTWV0YWRhdGEubmFtZV06IFBhcnRpYWw8T0JKTG9hZGluZ09wdGlvbnM+O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogT0JKIGZpbGUgdHlwZSBsb2FkZXIuXHJcbiAqIFRoaXMgaXMgYSBiYWJ5bG9uIHNjZW5lIGxvYWRlciBwbHVnaW4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT0JKRmlsZUxvYWRlciBpbXBsZW1lbnRzIElTY2VuZUxvYWRlclBsdWdpbkFzeW5jLCBJU2NlbmVMb2FkZXJQbHVnaW5GYWN0b3J5IHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiBVVnMgYXJlIG9wdGltaXplZCBieSBkZWZhdWx0IGR1cmluZyBsb2FkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9QVElNSVpFX1dJVEhfVVYgPSB0cnVlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnQgbW9kZWwgb24geS1heGlzIChkb2VzIGEgbW9kZWwgc2NhbGluZyBpbnZlcnNpb24pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJUX1kgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0IFktQXhpcyBvZiByZWZlcmVuY2VkIHRleHR1cmVzIG9uIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgSU5WRVJUX1RFWFRVUkVfWSgpIHtcclxuICAgICAgICByZXR1cm4gTVRMRmlsZUxvYWRlci5JTlZFUlRfVEVYVFVSRV9ZO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0IElOVkVSVF9URVhUVVJFX1kodmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICBNVExGaWxlTG9hZGVyLklOVkVSVF9URVhUVVJFX1kgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY2x1ZGUgaW4gbWVzaGVzIHRoZSB2ZXJ0ZXggY29sb3JzIGF2YWlsYWJsZSBpbiBzb21lIE9CSiBmaWxlcy4gIFRoaXMgaXMgbm90IHBhcnQgb2YgT0JKIHN0YW5kYXJkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIElNUE9SVF9WRVJURVhfQ09MT1JTID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIG5vcm1hbHMgZm9yIHRoZSBtb2RlbCwgZXZlbiBpZiBub3JtYWxzIGFyZSBwcmVzZW50IGluIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENPTVBVVEVfTk9STUFMUyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpbWl6ZSB0aGUgbm9ybWFscyBmb3IgdGhlIG1vZGVsLiBMaWdodGluZyBjYW4gYmUgdW5ldmVuIGlmIHlvdSB1c2UgT3B0aW1pemVXaXRoVVYgPSB0cnVlIGJlY2F1c2UgbmV3IHZlcnRpY2VzIGNhbiBiZSBjcmVhdGVkIGZvciB0aGUgc2FtZSBsb2NhdGlvbiBpZiB0aGV5IHBlcnRhaW4gdG8gZGlmZmVyZW50IGZhY2VzLlxyXG4gICAgICogVXNpbmcgT3B0aW1pemVoTm9ybWFscyA9IHRydWUgd2lsbCBoZWxwIHNtb290aGluZyB0aGUgbGlnaHRpbmcgYnkgYXZlcmFnaW5nIHRoZSBub3JtYWxzIG9mIHRob3NlIHZlcnRpY2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9QVElNSVpFX05PUk1BTFMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBjdXN0b20gc2NhbGluZyBvZiBVViBjb29yZGluYXRlcyBvZiBsb2FkZWQgbWVzaGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFVWX1NDQUxJTkcgPSBuZXcgVmVjdG9yMigxLCAxKTtcclxuICAgIC8qKlxyXG4gICAgICogU2tpcCBsb2FkaW5nIHRoZSBtYXRlcmlhbHMgZXZlbiBpZiBkZWZpbmVkIGluIHRoZSBPQkogZmlsZSAobWF0ZXJpYWxzIGFyZSBpZ25vcmVkKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTS0lQX01BVEVSSUFMUyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBhIG1hdGVyaWFsIGZhaWxzIHRvIGxvYWQgT0JKIGxvYWRlciB3aWxsIHNpbGVudGx5IGZhaWwgYW5kIG9uU3VjY2VzcygpIGNhbGxiYWNrIHdpbGwgYmUgdHJpZ2dlcmVkLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHRzIHRvIHRydWUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE1BVEVSSUFMX0xPQURJTkdfRkFJTFNfU0lMRU5UTFkgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYXNzZXRzIHdpdGhvdXQgaGFuZGVkbmVzcyBjb252ZXJzaW9ucy4gVGhpcyBmbGFnIGlzIGZvciBjb21wYXRpYmlsaXR5LiBVc2UgaXQgb25seSBpZiBhYnNvbHV0ZWx5IHJlcXVpcmVkLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBVU0VfTEVHQUNZX0JFSEFWSU9SID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gT0JKRmlsZUxvYWRlck1ldGFkYXRhLm5hbWU7XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgdGhlIGV4dGVuc2lvbiB0aGUgcGx1Z2luIGlzIGFibGUgdG8gbG9hZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGV4dGVuc2lvbnMgPSBPQkpGaWxlTG9hZGVyTWV0YWRhdGEuZXh0ZW5zaW9ucztcclxuXHJcbiAgICBwcml2YXRlIF9hc3NldENvbnRhaW5lcjogTnVsbGFibGU8QXNzZXRDb250YWluZXI+ID0gbnVsbDtcclxuXHJcbiAgICBwcml2YXRlIF9sb2FkaW5nT3B0aW9uczogT0JKTG9hZGluZ09wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGxvYWRlciBmb3IgLk9CSiBmaWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2FkaW5nT3B0aW9ucyBvcHRpb25zIGZvciBsb2FkaW5nIGFuZCBwYXJzaW5nIE9CSi9NVEwgZmlsZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRpbmdPcHRpb25zPzogUGFydGlhbDxSZWFkb25seTxPQkpMb2FkaW5nT3B0aW9ucz4+KSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ09wdGlvbnMgPSB7IC4uLk9CSkZpbGVMb2FkZXIuX0RlZmF1bHRMb2FkaW5nT3B0aW9ucywgLi4uKGxvYWRpbmdPcHRpb25zID8/IHt9KSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldCBfRGVmYXVsdExvYWRpbmdPcHRpb25zKCk6IE9CSkxvYWRpbmdPcHRpb25zIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb21wdXRlTm9ybWFsczogT0JKRmlsZUxvYWRlci5DT01QVVRFX05PUk1BTFMsXHJcbiAgICAgICAgICAgIG9wdGltaXplTm9ybWFsczogT0JKRmlsZUxvYWRlci5PUFRJTUlaRV9OT1JNQUxTLFxyXG4gICAgICAgICAgICBpbXBvcnRWZXJ0ZXhDb2xvcnM6IE9CSkZpbGVMb2FkZXIuSU1QT1JUX1ZFUlRFWF9DT0xPUlMsXHJcbiAgICAgICAgICAgIGludmVydFk6IE9CSkZpbGVMb2FkZXIuSU5WRVJUX1ksXHJcbiAgICAgICAgICAgIGludmVydFRleHR1cmVZOiBPQkpGaWxlTG9hZGVyLklOVkVSVF9URVhUVVJFX1ksXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgICAgICAgICAgVVZTY2FsaW5nOiBPQkpGaWxlTG9hZGVyLlVWX1NDQUxJTkcsXHJcbiAgICAgICAgICAgIG1hdGVyaWFsTG9hZGluZ0ZhaWxzU2lsZW50bHk6IE9CSkZpbGVMb2FkZXIuTUFURVJJQUxfTE9BRElOR19GQUlMU19TSUxFTlRMWSxcclxuICAgICAgICAgICAgb3B0aW1pemVXaXRoVVY6IE9CSkZpbGVMb2FkZXIuT1BUSU1JWkVfV0lUSF9VVixcclxuICAgICAgICAgICAgc2tpcE1hdGVyaWFsczogT0JKRmlsZUxvYWRlci5TS0lQX01BVEVSSUFMUyxcclxuICAgICAgICAgICAgdXNlTGVnYWN5QmVoYXZpb3I6IE9CSkZpbGVMb2FkZXIuVVNFX0xFR0FDWV9CRUhBVklPUixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgc3luY2hyb25vdXNseSB0aGUgTVRMIGZpbGUgYXR0YWNoZWQgdG8gdGhpcyBvYmouXHJcbiAgICAgKiBMb2FkIGZ1bmN0aW9uIG9yIGltcG9ydE1lc2ggZnVuY3Rpb24gZG9uJ3QgZW5hYmxlIHRvIGxvYWQgMiBmaWxlcyBpbiB0aGUgc2FtZSB0aW1lIGFzeW5jaHJvbm91c2x5LlxyXG4gICAgICogV2l0aG91dCB0aGlzIGZ1bmN0aW9uIG1hdGVyaWFscyBhcmUgbm90IGRpc3BsYXllZCBpbiB0aGUgZmlyc3QgZnJhbWUgKGJ1dCBkaXNwbGF5ZWQgYWZ0ZXIpLlxyXG4gICAgICogSW4gY29uc2VxdWVuY2UgaXQgaXMgaW1wb3NzaWJsZSB0byBnZXQgbWF0ZXJpYWwgaW5mb3JtYXRpb24gaW4geW91ciBIVE1MIGZpbGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgb2YgdGhlIE1UTCBmaWxlXHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBkZWZpbmVzIHdoZXJlIHRvIGxvYWQgZGF0YSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gb25TdWNjZXNzIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBNVEwgZmlsZSBpcyBsb2FkZWRcclxuICAgICAqIEBwYXJhbSBvbkZhaWx1cmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfbG9hZE1UTChcclxuICAgICAgICB1cmw6IHN0cmluZyxcclxuICAgICAgICByb290VXJsOiBzdHJpbmcsXHJcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2U6IHN0cmluZyB8IEFycmF5QnVmZmVyLCByZXNwb25zZVVybD86IHN0cmluZykgPT4gYW55LFxyXG4gICAgICAgIG9uRmFpbHVyZTogKHBhdGhPZkZpbGU6IHN0cmluZywgZXhjZXB0aW9uPzogYW55KSA9PiB2b2lkXHJcbiAgICApIHtcclxuICAgICAgICAvL1RoZSBjb21wbGV0ZSBwYXRoIHRvIHRoZSBtdGwgZmlsZVxyXG4gICAgICAgIGNvbnN0IHBhdGhPZkZpbGUgPSByb290VXJsICsgdXJsO1xyXG5cclxuICAgICAgICAvLyBMb2FkcyB0aHJvdWdoIHRoZSBiYWJ5bG9uIHRvb2xzIHRvIGFsbG93IGZpbGVJbnB1dCBzZWFyY2guXHJcbiAgICAgICAgVG9vbHMuTG9hZEZpbGUocGF0aE9mRmlsZSwgb25TdWNjZXNzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UsIChyZXF1ZXN0PzogV2ViUmVxdWVzdCwgZXhjZXB0aW9uPzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIG9uRmFpbHVyZShwYXRoT2ZGaWxlLCBleGNlcHRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNyZWF0ZVBsdWdpbihvcHRpb25zOiBTY2VuZUxvYWRlclBsdWdpbk9wdGlvbnMpOiBJU2NlbmVMb2FkZXJQbHVnaW5Bc3luYyB8IElTY2VuZUxvYWRlclBsdWdpbiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPQkpGaWxlTG9hZGVyKG9wdGlvbnNbT0JKRmlsZUxvYWRlck1ldGFkYXRhLm5hbWVdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBkYXRhIHN0cmluZyBjYW4gYmUgbG9hZGVkIGRpcmVjdGx5LlxyXG4gICAgICogQHJldHVybnMgaWYgdGhlIGRhdGEgY2FuIGJlIGxvYWRlZCBkaXJlY3RseVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2FuRGlyZWN0TG9hZCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBvcnRzIG9uZSBvciBtb3JlIG1lc2hlcyBmcm9tIHRoZSBsb2FkZWQgT0JKIGRhdGEgYW5kIGFkZHMgdGhlbSB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBtZXNoZXNOYW1lcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIG9mIHRoZSBtZXNoIG5hbWVzIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBmcm9tIHRoZSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgdGhlIHNjZW5lIHRoZSBtZXNoZXMgc2hvdWxkIGJlIGFkZGVkIHRvXHJcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgT0JKIGRhdGEgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgcm9vdCB1cmwgdG8gbG9hZCBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyB0aGUgbG9hZGVkIG1lc2hlcywgcGFydGljbGVzLCBza2VsZXRvbnMgYW5kIGFuaW1hdGlvbnNcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGltcG9ydE1lc2hBc3luYyhtZXNoZXNOYW1lczogYW55LCBzY2VuZTogU2NlbmUsIGRhdGE6IGFueSwgcm9vdFVybDogc3RyaW5nKTogUHJvbWlzZTxJU2NlbmVMb2FkZXJBc3luY1Jlc3VsdD4ge1xyXG4gICAgICAgIC8vZ2V0IHRoZSBtZXNoZXMgZnJvbSBPQkogZmlsZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVNvbGlkQXN5bmMobWVzaGVzTmFtZXMsIHNjZW5lLCBkYXRhLCByb290VXJsKS50aGVuKChtZXNoZXMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1lc2hlczogbWVzaGVzLFxyXG4gICAgICAgICAgICAgICAgcGFydGljbGVTeXN0ZW1zOiBbXSxcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uczogW10sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25Hcm91cHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllczogW10sXHJcbiAgICAgICAgICAgICAgICBsaWdodHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgc3ByaXRlTWFuYWdlcnM6IFtdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW1wb3J0cyBhbGwgb2JqZWN0cyBmcm9tIHRoZSBsb2FkZWQgT0JKIGRhdGEgYW5kIGFkZHMgdGhlbSB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBzY2VuZSB0aGUgc2NlbmUgdGhlIG9iamVjdHMgc2hvdWxkIGJlIGFkZGVkIHRvXHJcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgT0JKIGRhdGEgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgcm9vdCB1cmwgdG8gbG9hZCBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggY29tcGxldGVzIHdoZW4gb2JqZWN0cyBoYXZlIGJlZW4gbG9hZGVkIHRvIHRoZSBzY2VuZVxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkQXN5bmMoc2NlbmU6IFNjZW5lLCBkYXRhOiBzdHJpbmcsIHJvb3RVcmw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vR2V0IHRoZSAzRCBtb2RlbFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydE1lc2hBc3luYyhudWxsLCBzY2VuZSwgZGF0YSwgcm9vdFVybCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB2b2lkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGludG8gYW4gYXNzZXQgY29udGFpbmVyLlxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBsb2FkIGludG9cclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGltcG9ydFxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgVGhlIHJvb3QgdXJsIGZvciBzY2VuZSBhbmQgcmVzb3VyY2VzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIGFzc2V0IGNvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZEFzc2V0Q29udGFpbmVyQXN5bmMoc2NlbmU6IFNjZW5lLCBkYXRhOiBzdHJpbmcsIHJvb3RVcmw6IHN0cmluZyk6IFByb21pc2U8QXNzZXRDb250YWluZXI+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQXNzZXRDb250YWluZXIoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuX2Fzc2V0Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmltcG9ydE1lc2hBc3luYyhudWxsLCBzY2VuZSwgZGF0YSwgcm9vdFVybClcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZXNoZXMuZm9yRWFjaCgobWVzaCkgPT4gY29udGFpbmVyLm1lc2hlcy5wdXNoKG1lc2gpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWVzaGVzLmZvckVhY2goKG1lc2gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGVyaWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5tYXRlcmlhbHMuaW5kZXhPZihtYXRlcmlhbCkgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIubWF0ZXJpYWxzLnB1c2gobWF0ZXJpYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXh0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVzID0gbWF0ZXJpYWwuZ2V0QWN0aXZlVGV4dHVyZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5mb3JFYWNoKCh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIudGV4dHVyZXMuaW5kZXhPZih0KSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnRleHR1cmVzLnB1c2godCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fzc2V0Q29udGFpbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fzc2V0Q29udGFpbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgdGhlIE9CSiBmaWxlIGFuZCBjcmVhdGUgYW4gQXJyYXkgb2YgbWVzaGVzLlxyXG4gICAgICogRWFjaCBtZXNoIGNvbnRhaW5zIGFsbCBpbmZvcm1hdGlvbiBnaXZlbiBieSB0aGUgT0JKIGFuZCB0aGUgTVRMIGZpbGUuXHJcbiAgICAgKiBpLmUuIHZlcnRpY2VzIHBvc2l0aW9ucyBhbmQgaW5kaWNlcywgb3B0aW9uYWwgbm9ybWFscyB2YWx1ZXMsIG9wdGlvbmFsIFVWIHZhbHVlcywgb3B0aW9uYWwgbWF0ZXJpYWxcclxuICAgICAqIEBwYXJhbSBtZXNoZXNOYW1lcyBkZWZpbmVzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3Mgb2YgdGhlIG1lc2ggbmFtZXMgdGhhdCBzaG91bGQgYmUgbG9hZGVkIGZyb20gdGhlIGZpbGVcclxuICAgICAqIEBwYXJhbSBzY2VuZSBkZWZpbmVzIHRoZSBzY2VuZSB3aGVyZSBhcmUgZGlzcGxheWVkIHRoZSBkYXRhXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSBjb250ZW50IG9mIHRoZSBvYmogZmlsZVxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgZGVmaW5lcyB0aGUgcGF0aCB0byB0aGUgZm9sZGVyXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbGlzdCBvZiBsb2FkZWQgbWVzaGVzXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX3BhcnNlU29saWRBc3luYyhtZXNoZXNOYW1lczogYW55LCBzY2VuZTogU2NlbmUsIGRhdGE6IHN0cmluZywgcm9vdFVybDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxBYnN0cmFjdE1lc2g+PiB7XHJcbiAgICAgICAgbGV0IGZpbGVUb0xvYWQ6IHN0cmluZyA9IFwiXCI7IC8vVGhlIG5hbWUgb2YgdGhlIG10bEZpbGUgdG8gbG9hZFxyXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsc0Zyb21NVExGaWxlOiBNVExGaWxlTG9hZGVyID0gbmV3IE1UTEZpbGVMb2FkZXIoKTtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbFRvVXNlOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGJhYnlsb25NZXNoZXNBcnJheTogQXJyYXk8TWVzaD4gPSBbXTsgLy9UaGUgbWVzaCBmb3IgYmFieWxvblxyXG5cclxuICAgICAgICAvLyBTYW5pdGl6ZSBkYXRhXHJcbiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvIy4qJC9nbSwgXCJcIikudHJpbSgpO1xyXG5cclxuICAgICAgICAvLyBNYWluIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3Qgc29saWRQYXJzZXIgPSBuZXcgU29saWRQYXJzZXIobWF0ZXJpYWxUb1VzZSwgYmFieWxvbk1lc2hlc0FycmF5LCB0aGlzLl9sb2FkaW5nT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHNvbGlkUGFyc2VyLnBhcnNlKG1lc2hlc05hbWVzLCBkYXRhLCBzY2VuZSwgdGhpcy5fYXNzZXRDb250YWluZXIsIChmaWxlTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGZpbGVUb0xvYWQgPSBmaWxlTmFtZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gbG9hZCB0aGUgbWF0ZXJpYWxzXHJcbiAgICAgICAgY29uc3QgbXRsUHJvbWlzZXM6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGZpbGUgdG8gbG9hZFxyXG4gICAgICAgIGlmIChmaWxlVG9Mb2FkICE9PSBcIlwiICYmICF0aGlzLl9sb2FkaW5nT3B0aW9ucy5za2lwTWF0ZXJpYWxzKSB7XHJcbiAgICAgICAgICAgIC8vTG9hZCB0aGUgZmlsZSBzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgICAgIG10bFByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZE1UTChcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVRvTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGFMb2FkZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9DcmVhdGUgbWF0ZXJpYWxzIHRoYW5rcyBNVExMb2FkZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbHNGcm9tTVRMRmlsZS5wYXJzZU1UTChzY2VuZSwgZGF0YUxvYWRlZCwgcm9vdFVybCwgdGhpcy5fYXNzZXRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTG9vayBhdCBlYWNoIG1hdGVyaWFsIGxvYWRlZCBpbiB0aGUgbXRsIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGVyaWFsc0Zyb21NVExGaWxlLm1hdGVyaWFscy5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RocmVlIHZhcmlhYmxlcyB0byBnZXQgYWxsIG1lc2hlcyB3aXRoIHRoZSBzYW1lIG1hdGVyaWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2luZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9pbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlIG1hdGVyaWFsIGZyb20gTVRMIGZpbGUgaXMgdXNlZCBpbiB0aGUgbWVzaGVzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1B1c2ggdGhlIGluZGljZSBpbiBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIHRoZSBtYXRlcmlhbCBpcyBub3QgdXNlZCBmb3IgYW5vdGhlciBtZXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoX2luZGV4ID0gbWF0ZXJpYWxUb1VzZS5pbmRleE9mKG1hdGVyaWFsc0Zyb21NVExGaWxlLm1hdGVyaWFsc1tuXS5uYW1lLCBzdGFydEluZGV4KSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2luZGljZXMucHVzaChfaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IF9pbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgbWF0ZXJpYWwgaXMgbm90IHVzZWQgZGlzcG9zZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2luZGV4ID09PSAtMSAmJiBfaW5kaWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIG1hdGVyaWFsIGlzIG5vdCBuZWVkZWQsIHJlbW92ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxzRnJvbU1UTEZpbGUubWF0ZXJpYWxzW25dLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgX2luZGljZXMubGVuZ3RoOyBvKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0FwcGx5IHRoZSBtYXRlcmlhbCB0byB0aGUgTWVzaCBmb3IgZWFjaCBtZXNoIHdpdGggdGhlIG1hdGVyaWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IGJhYnlsb25NZXNoZXNBcnJheVtfaW5kaWNlc1tvXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNGcm9tTVRMRmlsZS5tYXRlcmlhbHNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc2guZ2V0VG90YWxJbmRpY2VzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gaW5kaWNlcywgd2UgbmVlZCB0byB0dXJuIG9uIHBvaW50IGNsb3VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnBvaW50c0Nsb3VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvb2xzLldhcm4oYEVycm9yIHByb2Nlc3NpbmcgTVRMIGZpbGU6ICcke2ZpbGVUb0xvYWR9J2ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nT3B0aW9ucy5tYXRlcmlhbExvYWRpbmdGYWlsc1NpbGVudGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhdGhPZkZpbGU6IHN0cmluZywgZXhjZXB0aW9uPzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb29scy5XYXJuKGBFcnJvciBkb3dubG9hZGluZyBNVEwgZmlsZTogJyR7ZmlsZVRvTG9hZH0nYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9hZGluZ09wdGlvbnMubWF0ZXJpYWxMb2FkaW5nRmFpbHNTaWxlbnRseSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9SZXR1cm4gYW4gYXJyYXkgd2l0aCBhbGwgTWVzaFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtdGxQcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTGluZSA9IChtZXNoOiBBYnN0cmFjdE1lc2gpID0+IEJvb2xlYW4obWVzaC5faW50ZXJuYWxNZXRhZGF0YT8uW1wiX2lzTGluZVwiXSA/PyBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIG1lc2gsIGRldGVybWluZSBpZiBpdCBpcyBhIGxpbmUgbWVzaCwgY2xvbmUgb3IgbW9kaWZ5IHRoZSBtYXRlcmlhbCB0byBsaW5lIHJlbmRlcmluZy5cclxuICAgICAgICAgICAgYmFieWxvbk1lc2hlc0FycmF5LmZvckVhY2goKG1lc2gpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmUobWVzaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0ID0gbWVzaC5tYXRlcmlhbCA/PyBuZXcgU3RhbmRhcmRNYXRlcmlhbChtZXNoLm5hbWUgKyBcIl9saW5lXCIsIHNjZW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbm90aGVyIG1lc2ggaXMgdXNpbmcgdGhpcyBtYXRlcmlhbCBhbmQgaXQgaXMgbm90IGEgbGluZSB0aGVuIHdlIG5lZWQgdG8gY2xvbmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZENsb25lID0gbWF0LmdldEJpbmRlZE1lc2hlcygpLmZpbHRlcigoZSkgPT4gIWlzTGluZShlKSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZENsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdCA9IG1hdC5jbG9uZShtYXQubmFtZSArIFwiX2xpbmVcIikgPz8gbWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYXQud2lyZWZyYW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsID0gbWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNoLl9pbnRlcm5hbE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guX2ludGVybmFsTWV0YWRhdGFbXCJfaXNMaW5lXCJdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFieWxvbk1lc2hlc0FycmF5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vL0FkZCB0aGlzIGxvYWRlciBpbnRvIHRoZSByZWdpc3RlciBwbHVnaW5cclxuUmVnaXN0ZXJTY2VuZUxvYWRlclBsdWdpbihuZXcgT0JKRmlsZUxvYWRlcigpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBWZWN0b3IyIH0gZnJvbSBcImNvcmUvTWF0aHMvbWF0aC52ZWN0b3JcIjtcclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBsb2FkaW5nIE9CSi9NVEwgZmlsZXNcclxuICovXHJcbmV4cG9ydCB0eXBlIE9CSkxvYWRpbmdPcHRpb25zID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIFVWcyBhcmUgb3B0aW1pemVkIGJ5IGRlZmF1bHQgZHVyaW5nIGxvYWQuXHJcbiAgICAgKi9cclxuICAgIG9wdGltaXplV2l0aFVWOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGN1c3RvbSBzY2FsaW5nIG9mIFVWIGNvb3JkaW5hdGVzIG9mIGxvYWRlZCBtZXNoZXMuXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIFVWU2NhbGluZzogVmVjdG9yMjtcclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0IG1vZGVsIG9uIHktYXhpcyAoZG9lcyBhIG1vZGVsIHNjYWxpbmcgaW52ZXJzaW9uKVxyXG4gICAgICovXHJcbiAgICBpbnZlcnRZOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnQgWS1BeGlzIG9mIHJlZmVyZW5jZWQgdGV4dHVyZXMgb24gbG9hZFxyXG4gICAgICovXHJcbiAgICBpbnZlcnRUZXh0dXJlWTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogSW5jbHVkZSBpbiBtZXNoZXMgdGhlIHZlcnRleCBjb2xvcnMgYXZhaWxhYmxlIGluIHNvbWUgT0JKIGZpbGVzLiAgVGhpcyBpcyBub3QgcGFydCBvZiBPQkogc3RhbmRhcmQuXHJcbiAgICAgKi9cclxuICAgIGltcG9ydFZlcnRleENvbG9yczogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgbm9ybWFscyBmb3IgdGhlIG1vZGVsLCBldmVuIGlmIG5vcm1hbHMgYXJlIHByZXNlbnQgaW4gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVOb3JtYWxzOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpbWl6ZSB0aGUgbm9ybWFscyBmb3IgdGhlIG1vZGVsLiBMaWdodGluZyBjYW4gYmUgdW5ldmVuIGlmIHlvdSB1c2UgT3B0aW1pemVXaXRoVVYgPSB0cnVlIGJlY2F1c2UgbmV3IHZlcnRpY2VzIGNhbiBiZSBjcmVhdGVkIGZvciB0aGUgc2FtZSBsb2NhdGlvbiBpZiB0aGV5IHBlcnRhaW4gdG8gZGlmZmVyZW50IGZhY2VzLlxyXG4gICAgICogVXNpbmcgT3B0aW1pemVoTm9ybWFscyA9IHRydWUgd2lsbCBoZWxwIHNtb290aGluZyB0aGUgbGlnaHRpbmcgYnkgYXZlcmFnaW5nIHRoZSBub3JtYWxzIG9mIHRob3NlIHZlcnRpY2VzLlxyXG4gICAgICovXHJcbiAgICBvcHRpbWl6ZU5vcm1hbHM6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNraXAgbG9hZGluZyB0aGUgbWF0ZXJpYWxzIGV2ZW4gaWYgZGVmaW5lZCBpbiB0aGUgT0JKIGZpbGUgKG1hdGVyaWFscyBhcmUgaWdub3JlZCkuXHJcbiAgICAgKi9cclxuICAgIHNraXBNYXRlcmlhbHM6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYSBtYXRlcmlhbCBmYWlscyB0byBsb2FkIE9CSiBsb2FkZXIgd2lsbCBzaWxlbnRseSBmYWlsIGFuZCBvblN1Y2Nlc3MoKSBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZC5cclxuICAgICAqL1xyXG4gICAgbWF0ZXJpYWxMb2FkaW5nRmFpbHNTaWxlbnRseTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYXNzZXRzIHdpdGhvdXQgaGFuZGVkbmVzcyBjb252ZXJzaW9ucy4gVGhpcyBmbGFnIGlzIGZvciBjb21wYXRpYmlsaXR5LiBVc2UgaXQgb25seSBpZiBhYnNvbHV0ZWx5IHJlcXVpcmVkLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgdXNlTGVnYWN5QmVoYXZpb3I6IGJvb2xlYW47XHJcbn07XHJcbiIsImltcG9ydCB0eXBlIHsgQXNzZXRDb250YWluZXIgfSBmcm9tIFwiY29yZS9hc3NldENvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBWZXJ0ZXhCdWZmZXIgfSBmcm9tIFwiY29yZS9CdWZmZXJzL2J1ZmZlclwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvc3RhbmRhcmRNYXRlcmlhbFwiO1xyXG5pbXBvcnQgeyBDb2xvcjMsIENvbG9yNCB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgVmVjdG9yMiwgVmVjdG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XHJcbmltcG9ydCB0eXBlIHsgQWJzdHJhY3RNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL2Fic3RyYWN0TWVzaFwiO1xyXG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCJjb3JlL01lc2hlcy9nZW9tZXRyeVwiO1xyXG5pbXBvcnQgeyBNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL21lc2hcIjtcclxuaW1wb3J0IHsgVmVydGV4RGF0YSB9IGZyb20gXCJjb3JlL01lc2hlcy9tZXNoLnZlcnRleERhdGFcIjtcclxuaW1wb3J0IHR5cGUgeyBTY2VuZSB9IGZyb20gXCJjb3JlL3NjZW5lXCI7XHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IE9CSkxvYWRpbmdPcHRpb25zIH0gZnJvbSBcIi4vb2JqTG9hZGluZ09wdGlvbnNcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNvcmUvTWlzYy9sb2dnZXJcIjtcclxuXHJcbnR5cGUgTWVzaE9iamVjdCA9IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGluZGljZXM6IE51bGxhYmxlPEFycmF5PG51bWJlcj4+O1xyXG4gICAgcG9zaXRpb25zOiBOdWxsYWJsZTxBcnJheTxudW1iZXI+PjtcclxuICAgIG5vcm1hbHM6IE51bGxhYmxlPEFycmF5PG51bWJlcj4+O1xyXG4gICAgY29sb3JzOiBOdWxsYWJsZTxBcnJheTxudW1iZXI+PjtcclxuICAgIHV2czogTnVsbGFibGU8QXJyYXk8bnVtYmVyPj47XHJcbiAgICBtYXRlcmlhbE5hbWU6IHN0cmluZztcclxuICAgIGRpcmVjdE1hdGVyaWFsPzogTnVsbGFibGU8TWF0ZXJpYWw+O1xyXG4gICAgaXNPYmplY3Q6IGJvb2xlYW47IC8vIElmIHRoZSBlbnRpdHkgaXMgZGVmaW5lZCBhcyBhbiBvYmplY3QgKFwib1wiKSwgb3IgZ3JvdXAgKFwiZ1wiKVxyXG4gICAgX2JhYnlsb25NZXNoPzogQWJzdHJhY3RNZXNoOyAvLyBUaGUgY29ycmVzcG9uZGluZyBCYWJ5bG9uIG1lc2hcclxuICAgIGhhc0xpbmVzPzogYm9vbGVhbjsgLy8gSWYgdGhlIG1lc2ggaGFzIGxpbmVzXHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgdXNlZCB0byBsb2FkIG1lc2ggZGF0YSBmcm9tIE9CSiBjb250ZW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU29saWRQYXJzZXIge1xyXG4gICAgLy8gRGVzY3JpcHRvclxyXG4gICAgLyoqIE9iamVjdCBkZXNjcmlwdG9yICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9iamVjdERlc2NyaXB0b3IgPSAvXm8vO1xyXG4gICAgLyoqIEdyb3VwIGRlc2NyaXB0b3IgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR3JvdXBEZXNjcmlwdG9yID0gL15nLztcclxuICAgIC8qKiBNYXRlcmlhbCBsaWIgZGVzY3JpcHRvciAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBNdGxMaWJHcm91cERlc2NyaXB0b3IgPSAvXm10bGxpYiAvO1xyXG4gICAgLyoqIFVzZSBhIG1hdGVyaWFsIGRlc2NyaXB0b3IgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVXNlTXRsRGVzY3JpcHRvciA9IC9edXNlbXRsIC87XHJcbiAgICAvKiogU21vb3RoIGRlc2NyaXB0b3IgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU21vb3RoRGVzY3JpcHRvciA9IC9ecyAvO1xyXG5cclxuICAgIC8vIFBhdHRlcm5zXHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIHZlcnRleCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBWZXJ0ZXhQYXR0ZXJuID0gL152KFxccytbXFxkfC58K3xcXC18ZXxFXSspezMsN30vO1xyXG4gICAgLyoqIFBhdHRlcm4gdXNlZCB0byBkZXRlY3QgYSBub3JtYWwgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTm9ybWFsUGF0dGVybiA9IC9edm4oXFxzK1tcXGR8LnwrfFxcLXxlfEVdKykoICtbXFxkfC58K3xcXC18ZXxFXSspKCArW1xcZHwufCt8XFwtfGV8RV0rKS87XHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIFVWIHNldCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBVVlBhdHRlcm4gPSAvXnZ0KFxccytbXFxkfC58K3xcXC18ZXxFXSspKCArW1xcZHwufCt8XFwtfGV8RV0rKS87XHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIGZpcnN0IGtpbmQgb2YgZmFjZSAoZiB2ZXJ0ZXggdmVydGV4IHZlcnRleCkgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRmFjZVBhdHRlcm4xID0gL15mXFxzKygoW1xcZF17MSx9W1xcc10/KXszLH0pKy87XHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIHNlY29uZCBraW5kIG9mIGZhY2UgKGYgdmVydGV4L3V2cyB2ZXJ0ZXgvdXZzIHZlcnRleC91dnMpICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEZhY2VQYXR0ZXJuMiA9IC9eZlxccysoKChbXFxkXXsxLH1cXC9bXFxkXXsxLH1bXFxzXT8pezMsfSkrKS87XHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIHRoaXJkIGtpbmQgb2YgZmFjZSAoZiB2ZXJ0ZXgvdXZzL25vcm1hbCB2ZXJ0ZXgvdXZzL25vcm1hbCB2ZXJ0ZXgvdXZzL25vcm1hbCkgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRmFjZVBhdHRlcm4zID0gL15mXFxzKygoKFtcXGRdezEsfVxcL1tcXGRdezEsfVxcL1tcXGRdezEsfVtcXHNdPyl7Myx9KSspLztcclxuICAgIC8qKiBQYXR0ZXJuIHVzZWQgdG8gZGV0ZWN0IGEgZm91cnRoIGtpbmQgb2YgZmFjZSAoZiB2ZXJ0ZXgvL25vcm1hbCB2ZXJ0ZXgvL25vcm1hbCB2ZXJ0ZXgvL25vcm1hbCkqL1xyXG4gICAgcHVibGljIHN0YXRpYyBGYWNlUGF0dGVybjQgPSAvXmZcXHMrKCgoW1xcZF17MSx9XFwvXFwvW1xcZF17MSx9W1xcc10/KXszLH0pKykvO1xyXG4gICAgLyoqIFBhdHRlcm4gdXNlZCB0byBkZXRlY3QgYSBmaWZ0aCBraW5kIG9mIGZhY2UgKGYgLXZlcnRleC8tdXZzLy1ub3JtYWwgLXZlcnRleC8tdXZzLy1ub3JtYWwgLXZlcnRleC8tdXZzLy1ub3JtYWwpICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEZhY2VQYXR0ZXJuNSA9IC9eZlxccysoKCgtW1xcZF17MSx9XFwvLVtcXGRdezEsfVxcLy1bXFxkXXsxLH1bXFxzXT8pezMsfSkrKS87XHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIGxpbmUobCB2ZXJ0ZXggdmVydGV4KSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBMaW5lUGF0dGVybjEgPSAvXmxcXHMrKChbXFxkXXsxLH1bXFxzXT8pezIsfSkrLztcclxuICAgIC8qKiBQYXR0ZXJuIHVzZWQgdG8gZGV0ZWN0IGEgc2Vjb25kIGtpbmQgb2YgbGluZSAobCB2ZXJ0ZXgvdXZzIHZlcnRleC91dnMpICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExpbmVQYXR0ZXJuMiA9IC9ebFxccysoKChbXFxkXXsxLH1cXC9bXFxkXXsxLH1bXFxzXT8pezIsfSkrKS87XHJcbiAgICAvKiogUGF0dGVybiB1c2VkIHRvIGRldGVjdCBhIHRoaXJkIGtpbmQgb2YgbGluZSAobCB2ZXJ0ZXgvdXZzL25vcm1hbCB2ZXJ0ZXgvdXZzL25vcm1hbCkgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTGluZVBhdHRlcm4zID0gL15sXFxzKygoKFtcXGRdezEsfVxcL1tcXGRdezEsfVxcL1tcXGRdezEsfVtcXHNdPyl7Mix9KSspLztcclxuXHJcbiAgICBwcml2YXRlIF9sb2FkaW5nT3B0aW9uczogT0JKTG9hZGluZ09wdGlvbnM7XHJcbiAgICBwcml2YXRlIF9wb3NpdGlvbnM6IEFycmF5PFZlY3RvcjM+ID0gW107IC8vdmFsdWVzIGZvciB0aGUgcG9zaXRpb25zIG9mIHZlcnRpY2VzXHJcbiAgICBwcml2YXRlIF9ub3JtYWxzOiBBcnJheTxWZWN0b3IzPiA9IFtdOyAvL1ZhbHVlcyBmb3IgdGhlIG5vcm1hbHNcclxuICAgIHByaXZhdGUgX3V2czogQXJyYXk8VmVjdG9yMj4gPSBbXTsgLy9WYWx1ZXMgZm9yIHRoZSB0ZXh0dXJlc1xyXG4gICAgcHJpdmF0ZSBfY29sb3JzOiBBcnJheTxDb2xvcjQ+ID0gW107XHJcbiAgICBwcml2YXRlIF9leHRDb2xvcnM6IEFycmF5PENvbG9yND4gPSBbXTsgLy9FeHRlbnNpb24gY29sb3JcclxuICAgIHByaXZhdGUgX21lc2hlc0Zyb21PYmo6IEFycmF5PE1lc2hPYmplY3Q+ID0gW107IC8vW21lc2hdIENvbnRhaW5zIGFsbCB0aGUgb2JqIG1lc2hlc1xyXG4gICAgcHJpdmF0ZSBfaGFuZGxlZE1lc2g6IE1lc2hPYmplY3Q7IC8vVGhlIGN1cnJlbnQgbWVzaCBvZiBtZXNoZXMgYXJyYXlcclxuICAgIHByaXZhdGUgX2luZGljZXNGb3JCYWJ5bG9uOiBBcnJheTxudW1iZXI+ID0gW107IC8vVGhlIGxpc3Qgb2YgaW5kaWNlcyBmb3IgVmVydGV4RGF0YVxyXG4gICAgcHJpdmF0ZSBfd3JhcHBlZFBvc2l0aW9uRm9yQmFieWxvbjogQXJyYXk8VmVjdG9yMz4gPSBbXTsgLy9UaGUgbGlzdCBvZiBwb3NpdGlvbiBpbiB2ZWN0b3JzXHJcbiAgICBwcml2YXRlIF93cmFwcGVkVXZzRm9yQmFieWxvbjogQXJyYXk8VmVjdG9yMj4gPSBbXTsgLy9BcnJheSB3aXRoIGFsbCB2YWx1ZSBvZiB1dnMgdG8gbWF0Y2ggd2l0aCB0aGUgaW5kaWNlc1xyXG4gICAgcHJpdmF0ZSBfd3JhcHBlZENvbG9yc0ZvckJhYnlsb246IEFycmF5PENvbG9yND4gPSBbXTsgLy8gQXJyYXkgd2l0aCBhbGwgY29sb3IgdmFsdWVzIHRvIG1hdGNoIHdpdGggdGhlIGluZGljZXNcclxuICAgIHByaXZhdGUgX3dyYXBwZWROb3JtYWxzRm9yQmFieWxvbjogQXJyYXk8VmVjdG9yMz4gPSBbXTsgLy9BcnJheSB3aXRoIGFsbCB2YWx1ZSBvZiBub3JtYWxzIHRvIG1hdGNoIHdpdGggdGhlIGluZGljZXNcclxuICAgIHByaXZhdGUgX3R1cGxlUG9zTm9ybTogQXJyYXk8eyBub3JtYWxzOiBBcnJheTxudW1iZXI+OyBpZHg6IEFycmF5PG51bWJlcj47IHV2OiBBcnJheTxudW1iZXI+IH0+ID0gW107IC8vQ3JlYXRlIGEgdHVwbGUgd2l0aCBpbmRpY2Ugb2YgUG9zaXRpb24sIE5vcm1hbCwgVVYgIFtwb3MsIG5vcm0sIHV2c11cclxuICAgIHByaXZhdGUgX2N1clBvc2l0aW9uSW5JbmRpY2VzID0gMDtcclxuICAgIHByaXZhdGUgX2hhc01lc2hlczogYm9vbGVhbiA9IGZhbHNlOyAvL01lc2hlcyBhcmUgZGVmaW5lZCBpbiB0aGUgZmlsZVxyXG4gICAgcHJpdmF0ZSBfdW53cmFwcGVkUG9zaXRpb25zRm9yQmFieWxvbjogQXJyYXk8bnVtYmVyPiA9IFtdOyAvL1ZhbHVlIG9mIHBvc2l0aW9uRm9yQmFieWxvbiB3L28gVmVjdG9yMygpIFt4LHksel1cclxuICAgIHByaXZhdGUgX3Vud3JhcHBlZENvbG9yc0ZvckJhYnlsb246IEFycmF5PG51bWJlcj4gPSBbXTsgLy8gVmFsdWUgb2YgY29sb3JGb3JCYWJ5bG9uIHcvbyBDb2xvcjQoKSBbcixnLGIsYV1cclxuICAgIHByaXZhdGUgX3Vud3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uOiBBcnJheTxudW1iZXI+ID0gW107IC8vVmFsdWUgb2Ygbm9ybWFsc0ZvckJhYnlsb24gdy9vIFZlY3RvcjMoKSAgW3gseSx6XVxyXG4gICAgcHJpdmF0ZSBfdW53cmFwcGVkVVZGb3JCYWJ5bG9uOiBBcnJheTxudW1iZXI+ID0gW107IC8vVmFsdWUgb2YgdXZzRm9yQmFieWxvbiB3L28gVmVjdG9yMygpICAgICAgW3gseSx6XVxyXG4gICAgcHJpdmF0ZSBfdHJpYW5nbGVzOiBBcnJheTxzdHJpbmc+ID0gW107IC8vSW5kaWNlcyBmcm9tIG5ldyB0cmlhbmdsZXMgY29taW5nIGZyb20gcG9seWdvbnNcclxuICAgIHByaXZhdGUgX21hdGVyaWFsTmFtZUZyb21PYmo6IHN0cmluZyA9IFwiXCI7IC8vVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbWF0ZXJpYWxcclxuICAgIHByaXZhdGUgX29iak1lc2hOYW1lOiBzdHJpbmcgPSBcIlwiOyAvL1RoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG9iaiBtZXNoXHJcbiAgICBwcml2YXRlIF9pbmNyZW1lbnQ6IG51bWJlciA9IDE7IC8vSWQgZm9yIG1lc2hlcyBjcmVhdGVkIGJ5IHRoZSBtdWx0aW1hdGVyaWFsXHJcbiAgICBwcml2YXRlIF9pc0ZpcnN0TWF0ZXJpYWw6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHJpdmF0ZSBfZ3JheUNvbG9yID0gbmV3IENvbG9yNCgwLjUsIDAuNSwgMC41LCAxKTtcclxuICAgIHByaXZhdGUgX21hdGVyaWFsVG9Vc2U6IHN0cmluZ1tdO1xyXG4gICAgcHJpdmF0ZSBfYmFieWxvbk1lc2hlc0FycmF5OiBBcnJheTxNZXNoPjtcclxuICAgIHByaXZhdGUgX3B1c2hUcmlhbmdsZTogKGZhY2VzOiBBcnJheTxzdHJpbmc+LCBmYWNlSW5kZXg6IG51bWJlcikgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgX2hhbmRlZG5lc3NTaWduOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9oYXNMaW5lRGF0YTogYm9vbGVhbiA9IGZhbHNlOyAvL0lmIHRoaXMgbWVzaCBoYXMgbGluZSBzZWdtZW50KGwpIGRhdGFcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU29saWRQYXJzZXJcclxuICAgICAqIEBwYXJhbSBtYXRlcmlhbFRvVXNlIGRlZmluZXMgdGhlIGFycmF5IHRvIGZpbGwgd2l0aCB0aGUgbGlzdCBvZiBtYXRlcmlhbHMgdG8gdXNlIChpdCB3aWxsIGJlIGZpbGxlZCBieSB0aGUgcGFyc2UgZnVuY3Rpb24pXHJcbiAgICAgKiBAcGFyYW0gYmFieWxvbk1lc2hlc0FycmF5IGRlZmluZXMgdGhlIGFycmF5IHRvIGZpbGwgd2l0aCB0aGUgbGlzdCBvZiBsb2FkZWQgbWVzaGVzIChpdCB3aWxsIGJlIGZpbGxlZCBieSB0aGUgcGFyc2UgZnVuY3Rpb24pXHJcbiAgICAgKiBAcGFyYW0gbG9hZGluZ09wdGlvbnMgZGVmaW5lcyB0aGUgbG9hZGluZyBvcHRpb25zIHRvIHVzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IobWF0ZXJpYWxUb1VzZTogc3RyaW5nW10sIGJhYnlsb25NZXNoZXNBcnJheTogQXJyYXk8TWVzaD4sIGxvYWRpbmdPcHRpb25zOiBPQkpMb2FkaW5nT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX21hdGVyaWFsVG9Vc2UgPSBtYXRlcmlhbFRvVXNlO1xyXG4gICAgICAgIHRoaXMuX2JhYnlsb25NZXNoZXNBcnJheSA9IGJhYnlsb25NZXNoZXNBcnJheTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nT3B0aW9ucyA9IGxvYWRpbmdPcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoIGZvciBvYmogaW4gdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gY2hlY2sgaWYgYSBjb3VwbGUgb2YgZGF0YSBhbHJlYWR5IGV4aXN0cyBpbiBhbiBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBmb3VuZCwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kZWQgdHVwbGUgaW5kZXguIFJldHVybnMgLTEgaWYgbm90IGZvdW5kXHJcbiAgICAgKiBAcGFyYW0gYXJyIEFycmF5PHsgbm9ybWFsczogQXJyYXk8bnVtYmVyPiwgaWR4OiBBcnJheTxudW1iZXI+IH0+XHJcbiAgICAgKiBAcGFyYW0gb2JqIEFycmF5PG51bWJlcj5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pc0luQXJyYXkoYXJyOiBBcnJheTx7IG5vcm1hbHM6IEFycmF5PG51bWJlcj47IGlkeDogQXJyYXk8bnVtYmVyPiB9Piwgb2JqOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgaWYgKCFhcnJbb2JqWzBdXSkge1xyXG4gICAgICAgICAgICBhcnJbb2JqWzBdXSA9IHsgbm9ybWFsczogW10sIGlkeDogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaWR4ID0gYXJyW29ialswXV0ubm9ybWFscy5pbmRleE9mKG9ialsxXSk7XHJcblxyXG4gICAgICAgIHJldHVybiBpZHggPT09IC0xID8gLTEgOiBhcnJbb2JqWzBdXS5pZHhbaWR4XTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9pc0luQXJyYXlVVihhcnI6IEFycmF5PHsgbm9ybWFsczogQXJyYXk8bnVtYmVyPjsgaWR4OiBBcnJheTxudW1iZXI+OyB1djogQXJyYXk8bnVtYmVyPiB9Piwgb2JqOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgaWYgKCFhcnJbb2JqWzBdXSkge1xyXG4gICAgICAgICAgICBhcnJbb2JqWzBdXSA9IHsgbm9ybWFsczogW10sIGlkeDogW10sIHV2OiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZHggPSBhcnJbb2JqWzBdXS5ub3JtYWxzLmluZGV4T2Yob2JqWzFdKTtcclxuXHJcbiAgICAgICAgaWYgKGlkeCAhPSAxICYmIG9ialsyXSA9PT0gYXJyW29ialswXV0udXZbaWR4XSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyW29ialswXV0uaWR4W2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2V0IHRoZSBkYXRhIGZvciBlYWNoIHRyaWFuZ2xlLlxyXG4gICAgICogRGF0YSBhcmUgcG9zaXRpb24sIG5vcm1hbHMgYW5kIHV2c1xyXG4gICAgICogSWYgYSB0dXBsZSBvZiAocG9zaXRpb24sIG5vcm1hbCkgaXMgbm90IHNldCwgYWRkIHRoZSBkYXRhIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJyYXlcclxuICAgICAqIElmIHRoZSB0dXBsZSBhbHJlYWR5IGV4aXN0LCBhZGQgb25seSB0aGVpciBpbmRpY2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlUG9zaXRpb25Gcm9tT2JqIEludGVnZXIgVGhlIGluZGV4IGluIHBvc2l0aW9ucyBhcnJheVxyXG4gICAgICogQHBhcmFtIGluZGljZVV2c0Zyb21PYmogSW50ZWdlciBUaGUgaW5kZXggaW4gdXZzIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlTm9ybWFsRnJvbU9iaiBJbnRlZ2VyIFRoZSBpbmRleCBpbiBub3JtYWxzIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25WZWN0b3JGcm9tT0JKIFZlY3RvcjMgVGhlIHZhbHVlIG9mIHBvc2l0aW9uIGF0IGluZGV4IG9iakluZGljZVxyXG4gICAgICogQHBhcmFtIHRleHR1cmVWZWN0b3JGcm9tT0JKIFZlY3RvcjMgVGhlIHZhbHVlIG9mIHV2c1xyXG4gICAgICogQHBhcmFtIG5vcm1hbHNWZWN0b3JGcm9tT0JKIFZlY3RvcjMgVGhlIHZhbHVlIG9mIG5vcm1hbHMgYXQgaW5kZXggb2JqTm9ybWFsZVxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uQ29sb3JzRnJvbU9CSlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9zZXREYXRhKFxyXG4gICAgICAgIGluZGljZVBvc2l0aW9uRnJvbU9iajogbnVtYmVyLFxyXG4gICAgICAgIGluZGljZVV2c0Zyb21PYmo6IG51bWJlcixcclxuICAgICAgICBpbmRpY2VOb3JtYWxGcm9tT2JqOiBudW1iZXIsXHJcbiAgICAgICAgcG9zaXRpb25WZWN0b3JGcm9tT0JKOiBWZWN0b3IzLFxyXG4gICAgICAgIHRleHR1cmVWZWN0b3JGcm9tT0JKOiBWZWN0b3IyLFxyXG4gICAgICAgIG5vcm1hbHNWZWN0b3JGcm9tT0JKOiBWZWN0b3IzLFxyXG4gICAgICAgIHBvc2l0aW9uQ29sb3JzRnJvbU9CSj86IENvbG9yNFxyXG4gICAgKSB7XHJcbiAgICAgICAgLy9DaGVjayBpZiB0aGlzIHR1cGxlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBsaXN0IG9mIHR1cGxlc1xyXG4gICAgICAgIGxldCBfaW5kZXg6IG51bWJlcjtcclxuICAgICAgICBpZiAodGhpcy5fbG9hZGluZ09wdGlvbnMub3B0aW1pemVXaXRoVVYpIHtcclxuICAgICAgICAgICAgX2luZGV4ID0gdGhpcy5faXNJbkFycmF5VVYodGhpcy5fdHVwbGVQb3NOb3JtLCBbaW5kaWNlUG9zaXRpb25Gcm9tT2JqLCBpbmRpY2VOb3JtYWxGcm9tT2JqLCBpbmRpY2VVdnNGcm9tT2JqXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2luZGV4ID0gdGhpcy5faXNJbkFycmF5KHRoaXMuX3R1cGxlUG9zTm9ybSwgW2luZGljZVBvc2l0aW9uRnJvbU9iaiwgaW5kaWNlTm9ybWFsRnJvbU9ial0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9JZiBpdCBub3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKF9pbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy9BZGQgYW4gbmV3IGluZGljZS5cclxuICAgICAgICAgICAgLy9UaGUgYXJyYXkgb2YgaW5kaWNlcyBpcyBvbmx5IGFuIGFycmF5IHdpdGggaGlzIGxlbmd0aCBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcyAtIDEuXHJcbiAgICAgICAgICAgIC8vV2UgYWRkIHZlcnRpY2VzIGRhdGEgaW4gdGhpcyBvcmRlclxyXG4gICAgICAgICAgICB0aGlzLl9pbmRpY2VzRm9yQmFieWxvbi5wdXNoKHRoaXMuX3dyYXBwZWRQb3NpdGlvbkZvckJhYnlsb24ubGVuZ3RoKTtcclxuICAgICAgICAgICAgLy9QdXNoIHRoZSBwb3NpdGlvbiBvZiB2ZXJ0aWNlIGZvciBCYWJ5bG9uXHJcbiAgICAgICAgICAgIC8vRWFjaCBlbGVtZW50IGlzIGEgVmVjdG9yMyh4LHkseilcclxuICAgICAgICAgICAgdGhpcy5fd3JhcHBlZFBvc2l0aW9uRm9yQmFieWxvbi5wdXNoKHBvc2l0aW9uVmVjdG9yRnJvbU9CSik7XHJcbiAgICAgICAgICAgIC8vUHVzaCB0aGUgdXZzIGZvciBCYWJ5bG9uXHJcbiAgICAgICAgICAgIC8vRWFjaCBlbGVtZW50IGlzIGEgVmVjdG9yMih1LHYpXHJcbiAgICAgICAgICAgIC8vSWYgdGhlIFVWcyBhcmUgbWlzc2luZywgc2V0ICh1LHYpPSgwLDApXHJcbiAgICAgICAgICAgIHRleHR1cmVWZWN0b3JGcm9tT0JKID0gdGV4dHVyZVZlY3RvckZyb21PQkogPz8gbmV3IFZlY3RvcjIoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRVdnNGb3JCYWJ5bG9uLnB1c2godGV4dHVyZVZlY3RvckZyb21PQkopO1xyXG4gICAgICAgICAgICAvL1B1c2ggdGhlIG5vcm1hbHMgZm9yIEJhYnlsb25cclxuICAgICAgICAgICAgLy9FYWNoIGVsZW1lbnQgaXMgYSBWZWN0b3IzKHgseSx6KVxyXG4gICAgICAgICAgICB0aGlzLl93cmFwcGVkTm9ybWFsc0ZvckJhYnlsb24ucHVzaChub3JtYWxzVmVjdG9yRnJvbU9CSik7XHJcblxyXG4gICAgICAgICAgICBpZiAocG9zaXRpb25Db2xvcnNGcm9tT0JKICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vUHVzaCB0aGUgY29sb3JzIGZvciBCYWJ5bG9uXHJcbiAgICAgICAgICAgICAgICAvL0VhY2ggZWxlbWVudCBpcyBhIEJBQllMT04uQ29sb3I0KHIsZyxiLGEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwcGVkQ29sb3JzRm9yQmFieWxvbi5wdXNoKHBvc2l0aW9uQ29sb3JzRnJvbU9CSik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQWRkIHRoZSB0dXBsZSBpbiB0aGUgY29tcGFyaXNvbiBsaXN0XHJcbiAgICAgICAgICAgIHRoaXMuX3R1cGxlUG9zTm9ybVtpbmRpY2VQb3NpdGlvbkZyb21PYmpdLm5vcm1hbHMucHVzaChpbmRpY2VOb3JtYWxGcm9tT2JqKTtcclxuICAgICAgICAgICAgdGhpcy5fdHVwbGVQb3NOb3JtW2luZGljZVBvc2l0aW9uRnJvbU9ial0uaWR4LnB1c2godGhpcy5fY3VyUG9zaXRpb25JbkluZGljZXMrKyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nT3B0aW9ucy5vcHRpbWl6ZVdpdGhVVikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHVwbGVQb3NOb3JtW2luZGljZVBvc2l0aW9uRnJvbU9ial0udXYucHVzaChpbmRpY2VVdnNGcm9tT2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVGhlIHR1cGxlIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgIC8vQWRkIHRoZSBpbmRleCBvZiB0aGUgYWxyZWFkeSBleGlzdGluZyB0dXBsZVxyXG4gICAgICAgICAgICAvL0F0IHRoaXMgaW5kZXggd2UgY2FuIGdldCB0aGUgdmFsdWUgb2YgcG9zaXRpb24sIG5vcm1hbCwgY29sb3IgYW5kIHV2cyBvZiB2ZXJ0ZXhcclxuICAgICAgICAgICAgdGhpcy5faW5kaWNlc0ZvckJhYnlsb24ucHVzaChfaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBWZWN0b3IoKSBhbmQgQkFCWUxPTi5Db2xvcigpIG9iamVjdHMgaW50byBudW1iZXJzIGluIGFuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3Vud3JhcERhdGEoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy9FdmVyeSBhcnJheSBoYXMgdGhlIHNhbWUgbGVuZ3RoXHJcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgdGhpcy5fd3JhcHBlZFBvc2l0aW9uRm9yQmFieWxvbi5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgLy9QdXNoIHRoZSB4LCB5LCB6IHZhbHVlcyBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIHVud3JhcHBlZCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkUG9zaXRpb25zRm9yQmFieWxvbi5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRQb3NpdGlvbkZvckJhYnlsb25bbF0ueCAqIHRoaXMuX2hhbmRlZG5lc3NTaWduLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRQb3NpdGlvbkZvckJhYnlsb25bbF0ueSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwcGVkUG9zaXRpb25Gb3JCYWJ5bG9uW2xdLnpcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXBwZWROb3JtYWxzRm9yQmFieWxvbi5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBwZWROb3JtYWxzRm9yQmFieWxvbltsXS54ICogdGhpcy5faGFuZGVkbmVzc1NpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uW2xdLnksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uW2xdLnpcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkVVZGb3JCYWJ5bG9uLnB1c2godGhpcy5fd3JhcHBlZFV2c0ZvckJhYnlsb25bbF0ueCwgdGhpcy5fd3JhcHBlZFV2c0ZvckJhYnlsb25bbF0ueSk7IC8veiBpcyBhbiBvcHRpb25hbCB2YWx1ZSBub3Qgc3VwcG9ydGVkIGJ5IEJBQllMT05cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nT3B0aW9ucy5pbXBvcnRWZXJ0ZXhDb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1B1c2ggdGhlIHIsIGcsIGIsIGEgdmFsdWVzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgdW53cmFwcGVkIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkQ29sb3JzRm9yQmFieWxvbi5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwcGVkQ29sb3JzRm9yQmFieWxvbltsXS5yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwcGVkQ29sb3JzRm9yQmFieWxvbltsXS5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwcGVkQ29sb3JzRm9yQmFieWxvbltsXS5iLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwcGVkQ29sb3JzRm9yQmFieWxvbltsXS5hXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXNldCBhcnJheXMgZm9yIHRoZSBuZXh0IG5ldyBtZXNoZXNcclxuICAgICAgICAgICAgdGhpcy5fd3JhcHBlZFBvc2l0aW9uRm9yQmFieWxvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl93cmFwcGVkTm9ybWFsc0ZvckJhYnlsb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fd3JhcHBlZFV2c0ZvckJhYnlsb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fd3JhcHBlZENvbG9yc0ZvckJhYnlsb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdHVwbGVQb3NOb3JtLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1clBvc2l0aW9uSW5JbmRpY2VzID0gMDtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byB1bndyYXAgZGF0YSB3aGlsZSBwYXJzaW5nIE9CSiBkYXRhLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdHJpYW5nbGVzIGZyb20gcG9seWdvbnNcclxuICAgICAqIEl0IGlzIGltcG9ydGFudCB0byBub3RpY2UgdGhhdCBhIHRyaWFuZ2xlIGlzIGEgcG9seWdvblxyXG4gICAgICogV2UgZ2V0IDUgcGF0dGVybnMgb2YgZmFjZSBkZWZpbmVkIGluIE9CSiBGaWxlIDpcclxuICAgICAqIGZhY2VQYXR0ZXJuMSA9IFtcIjFcIixcIjJcIixcIjNcIixcIjRcIixcIjVcIixcIjZcIl1cclxuICAgICAqIGZhY2VQYXR0ZXJuMiA9IFtcIjEvMVwiLFwiMi8yXCIsXCIzLzNcIixcIjQvNFwiLFwiNS81XCIsXCI2LzZcIl1cclxuICAgICAqIGZhY2VQYXR0ZXJuMyA9IFtcIjEvMS8xXCIsXCIyLzIvMlwiLFwiMy8zLzNcIixcIjQvNC80XCIsXCI1LzUvNVwiLFwiNi82LzZcIl1cclxuICAgICAqIGZhY2VQYXR0ZXJuNCA9IFtcIjEvLzFcIixcIjIvLzJcIixcIjMvLzNcIixcIjQvLzRcIixcIjUvLzVcIixcIjYvLzZcIl1cclxuICAgICAqIGZhY2VQYXR0ZXJuNSA9IFtcIi0xLy0xLy0xXCIsXCItMi8tMi8tMlwiLFwiLTMvLTMvLTNcIixcIi00Ly00Ly00XCIsXCItNS8tNS8tNVwiLFwiLTYvLTYvLTZcIl1cclxuICAgICAqIEVhY2ggcGF0dGVybiBpcyBkaXZpZGVkIGJ5IHRoZSBzYW1lIG1ldGhvZFxyXG4gICAgICogQHBhcmFtIGZhY2VzIEFycmF5W1N0cmluZ10gVGhlIGluZGljZXMgb2YgZWxlbWVudHNcclxuICAgICAqIEBwYXJhbSB2IEludGVnZXIgVGhlIHZhcmlhYmxlIHRvIGluY3JlbWVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRUcmlhbmdsZXMoZmFjZXM6IEFycmF5PHN0cmluZz4sIHY6IG51bWJlcikge1xyXG4gICAgICAgIC8vV29yayBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheVxyXG4gICAgICAgIGZvciAobGV0IGZhY2VJbmRleCA9IHY7IGZhY2VJbmRleCA8IGZhY2VzLmxlbmd0aCAtIDE7IGZhY2VJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIC8vQWRkIG9uIHRoZSB0cmlhbmdsZSB2YXJpYWJsZSB0aGUgaW5kZXhlcyB0byBvYnRhaW4gdHJpYW5nbGVzXHJcbiAgICAgICAgICAgIHRoaXMuX3B1c2hUcmlhbmdsZShmYWNlcywgZmFjZUluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vUmVzdWx0IG9idGFpbmVkIGFmdGVyIDIgaXRlcmF0aW9uczpcclxuICAgICAgICAvL1BhdHRlcm4xID0+IHRyaWFuZ2xlID0gW1wiMVwiLFwiMlwiLFwiM1wiLFwiMVwiLFwiM1wiLFwiNFwiXTtcclxuICAgICAgICAvL1BhdHRlcm4yID0+IHRyaWFuZ2xlID0gW1wiMS8xXCIsXCIyLzJcIixcIjMvM1wiLFwiMS8xXCIsXCIzLzNcIixcIjQvNFwiXTtcclxuICAgICAgICAvL1BhdHRlcm4zID0+IHRyaWFuZ2xlID0gW1wiMS8xLzFcIixcIjIvMi8yXCIsXCIzLzMvM1wiLFwiMS8xLzFcIixcIjMvMy8zXCIsXCI0LzQvNFwiXTtcclxuICAgICAgICAvL1BhdHRlcm40ID0+IHRyaWFuZ2xlID0gW1wiMS8vMVwiLFwiMi8vMlwiLFwiMy8vM1wiLFwiMS8vMVwiLFwiMy8vM1wiLFwiNC8vNFwiXTtcclxuICAgICAgICAvL1BhdHRlcm41ID0+IHRyaWFuZ2xlID0gW1wiLTEvLTEvLTFcIixcIi0yLy0yLy0yXCIsXCItMy8tMy8tM1wiLFwiLTEvLTEvLTFcIixcIi0zLy0zLy0zXCIsXCItNC8tNC8tNFwiXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvIGdldCBjb2xvciBiZXR3ZWVuIGNvbG9yIGFuZCBleHRlbnNpb24gY29sb3JcclxuICAgICAqIEBwYXJhbSBpbmRleCBJbnRlZ2VyIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIHZhbHVlIG9mIHRhcmdldCBjb2xvclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRDb2xvcihpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdPcHRpb25zLmltcG9ydFZlcnRleENvbG9ycykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXh0Q29sb3JzW2luZGV4XSA/PyB0aGlzLl9jb2xvcnNbaW5kZXhdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyaWFuZ2xlcyBhbmQgcHVzaCB0aGUgZGF0YSBmb3IgZWFjaCBwb2x5Z29uIGZvciB0aGUgcGF0dGVybiAxXHJcbiAgICAgKiBJbiB0aGlzIHBhdHRlcm4gd2UgZ2V0IHZlcnRpY2UgcG9zaXRpb25zXHJcbiAgICAgKiBAcGFyYW0gZmFjZVxyXG4gICAgICogQHBhcmFtIHZcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc2V0RGF0YUZvckN1cnJlbnRGYWNlV2l0aFBhdHRlcm4xKGZhY2U6IEFycmF5PHN0cmluZz4sIHY6IG51bWJlcikge1xyXG4gICAgICAgIC8vR2V0IHRoZSBpbmRpY2VzIG9mIHRyaWFuZ2xlcyBmb3IgZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgdGhpcy5fZ2V0VHJpYW5nbGVzKGZhY2UsIHYpO1xyXG4gICAgICAgIC8vRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgdHJpYW5nbGVzIGFycmF5LlxyXG4gICAgICAgIC8vVGhpcyB2YXIgY291bGQgY29udGFpbnMgMSB0byBhbiBpbmZpbml0eSBvZiB0cmlhbmdsZXNcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMuX3RyaWFuZ2xlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAvLyBTZXQgcG9zaXRpb24gaW5kaWNlXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZVBvc2l0aW9uRnJvbU9iaiA9IHBhcnNlSW50KHRoaXMuX3RyaWFuZ2xlc1trXSkgLSAxO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2V0RGF0YShcclxuICAgICAgICAgICAgICAgIGluZGljZVBvc2l0aW9uRnJvbU9iaixcclxuICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAvLyBJbiB0aGUgcGF0dGVybiAxLCBub3JtYWxzIGFuZCB1dnMgYXJlIG5vdCBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbnNbaW5kaWNlUG9zaXRpb25Gcm9tT2JqXSwgLy8gR2V0IHRoZSB2ZWN0b3JzIGRhdGFcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIuWmVybygpLFxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMy5VcCgpLCAvLyBDcmVhdGUgZGVmYXVsdCB2ZWN0b3JzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRDb2xvcihpbmRpY2VQb3NpdGlvbkZyb21PYmopXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vUmVzZXQgdmFyaWFibGUgZm9yIHRoZSBuZXh0IGxpbmVcclxuICAgICAgICB0aGlzLl90cmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0cmlhbmdsZXMgYW5kIHB1c2ggdGhlIGRhdGEgZm9yIGVhY2ggcG9seWdvbiBmb3IgdGhlIHBhdHRlcm4gMlxyXG4gICAgICogSW4gdGhpcyBwYXR0ZXJuIHdlIGdldCB2ZXJ0aWNlIHBvc2l0aW9ucyBhbmQgdXZzXHJcbiAgICAgKiBAcGFyYW0gZmFjZVxyXG4gICAgICogQHBhcmFtIHZcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc2V0RGF0YUZvckN1cnJlbnRGYWNlV2l0aFBhdHRlcm4yKGZhY2U6IEFycmF5PHN0cmluZz4sIHY6IG51bWJlcikge1xyXG4gICAgICAgIC8vR2V0IHRoZSBpbmRpY2VzIG9mIHRyaWFuZ2xlcyBmb3IgZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgdGhpcy5fZ2V0VHJpYW5nbGVzKGZhY2UsIHYpO1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fdHJpYW5nbGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vdHJpYW5nbGVba10gPSBcIjEvMVwiXHJcbiAgICAgICAgICAgIC8vU3BsaXQgdGhlIGRhdGEgZm9yIGdldHRpbmcgcG9zaXRpb24gYW5kIHV2XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fdHJpYW5nbGVzW2tdLnNwbGl0KFwiL1wiKTsgLy8gW1wiMVwiLCBcIjFcIl1cclxuICAgICAgICAgICAgLy9TZXQgcG9zaXRpb24gaW5kaWNlXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZVBvc2l0aW9uRnJvbU9iaiA9IHBhcnNlSW50KHBvaW50WzBdKSAtIDE7XHJcbiAgICAgICAgICAgIC8vU2V0IHV2IGluZGljZVxyXG4gICAgICAgICAgICBjb25zdCBpbmRpY2VVdnNGcm9tT2JqID0gcGFyc2VJbnQocG9pbnRbMV0pIC0gMTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEoXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VQb3NpdGlvbkZyb21PYmosXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VVdnNGcm9tT2JqLFxyXG4gICAgICAgICAgICAgICAgMCwgLy9EZWZhdWx0IHZhbHVlIGZvciBub3JtYWxzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbnNbaW5kaWNlUG9zaXRpb25Gcm9tT2JqXSwgLy9HZXQgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91dnNbaW5kaWNlVXZzRnJvbU9ial0gPz8gVmVjdG9yMi5aZXJvKCksXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzLlVwKCksIC8vRGVmYXVsdCB2YWx1ZSBmb3Igbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Q29sb3IoaW5kaWNlUG9zaXRpb25Gcm9tT2JqKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9SZXNldCB2YXJpYWJsZSBmb3IgdGhlIG5leHQgbGluZVxyXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyaWFuZ2xlcyBhbmQgcHVzaCB0aGUgZGF0YSBmb3IgZWFjaCBwb2x5Z29uIGZvciB0aGUgcGF0dGVybiAzXHJcbiAgICAgKiBJbiB0aGlzIHBhdHRlcm4gd2UgZ2V0IHZlcnRpY2UgcG9zaXRpb25zLCB1dnMgYW5kIG5vcm1hbHNcclxuICAgICAqIEBwYXJhbSBmYWNlXHJcbiAgICAgKiBAcGFyYW0gdlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9zZXREYXRhRm9yQ3VycmVudEZhY2VXaXRoUGF0dGVybjMoZmFjZTogQXJyYXk8c3RyaW5nPiwgdjogbnVtYmVyKSB7XHJcbiAgICAgICAgLy9HZXQgdGhlIGluZGljZXMgb2YgdHJpYW5nbGVzIGZvciBlYWNoIHBvbHlnb25cclxuICAgICAgICB0aGlzLl9nZXRUcmlhbmdsZXMoZmFjZSwgdik7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fdHJpYW5nbGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vdHJpYW5nbGVba10gPSBcIjEvMS8xXCJcclxuICAgICAgICAgICAgLy9TcGxpdCB0aGUgZGF0YSBmb3IgZ2V0dGluZyBwb3NpdGlvbiwgdXYsIGFuZCBub3JtYWxzXHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fdHJpYW5nbGVzW2tdLnNwbGl0KFwiL1wiKTsgLy8gW1wiMVwiLCBcIjFcIiwgXCIxXCJdXHJcbiAgICAgICAgICAgIC8vIFNldCBwb3NpdGlvbiBpbmRpY2VcclxuICAgICAgICAgICAgY29uc3QgaW5kaWNlUG9zaXRpb25Gcm9tT2JqID0gcGFyc2VJbnQocG9pbnRbMF0pIC0gMTtcclxuICAgICAgICAgICAgLy8gU2V0IHV2IGluZGljZVxyXG4gICAgICAgICAgICBjb25zdCBpbmRpY2VVdnNGcm9tT2JqID0gcGFyc2VJbnQocG9pbnRbMV0pIC0gMTtcclxuICAgICAgICAgICAgLy8gU2V0IG5vcm1hbCBpbmRpY2VcclxuICAgICAgICAgICAgY29uc3QgaW5kaWNlTm9ybWFsRnJvbU9iaiA9IHBhcnNlSW50KHBvaW50WzJdKSAtIDE7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zZXREYXRhKFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlUG9zaXRpb25Gcm9tT2JqLFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlVXZzRnJvbU9iaixcclxuICAgICAgICAgICAgICAgIGluZGljZU5vcm1hbEZyb21PYmosXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbnNbaW5kaWNlUG9zaXRpb25Gcm9tT2JqXSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3V2c1tpbmRpY2VVdnNGcm9tT2JqXSA/PyBWZWN0b3IyLlplcm8oKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbHNbaW5kaWNlTm9ybWFsRnJvbU9ial0gPz8gVmVjdG9yMy5VcCgpIC8vU2V0IHRoZSB2ZWN0b3IgZm9yIGVhY2ggY29tcG9uZW50XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vUmVzZXQgdmFyaWFibGUgZm9yIHRoZSBuZXh0IGxpbmVcclxuICAgICAgICB0aGlzLl90cmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0cmlhbmdsZXMgYW5kIHB1c2ggdGhlIGRhdGEgZm9yIGVhY2ggcG9seWdvbiBmb3IgdGhlIHBhdHRlcm4gNFxyXG4gICAgICogSW4gdGhpcyBwYXR0ZXJuIHdlIGdldCB2ZXJ0aWNlIHBvc2l0aW9ucyBhbmQgbm9ybWFsc1xyXG4gICAgICogQHBhcmFtIGZhY2VcclxuICAgICAqIEBwYXJhbSB2XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3NldERhdGFGb3JDdXJyZW50RmFjZVdpdGhQYXR0ZXJuNChmYWNlOiBBcnJheTxzdHJpbmc+LCB2OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9nZXRUcmlhbmdsZXMoZmFjZSwgdik7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fdHJpYW5nbGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vdHJpYW5nbGVba10gPSBcIjEvLzFcIlxyXG4gICAgICAgICAgICAvL1NwbGl0IHRoZSBkYXRhIGZvciBnZXR0aW5nIHBvc2l0aW9uIGFuZCBub3JtYWxzXHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fdHJpYW5nbGVzW2tdLnNwbGl0KFwiLy9cIik7IC8vIFtcIjFcIiwgXCIxXCJdXHJcbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIGluZGljZXMsIGFuZCBub3JtYWxzXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZVBvc2l0aW9uRnJvbU9iaiA9IHBhcnNlSW50KHBvaW50WzBdKSAtIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZU5vcm1hbEZyb21PYmogPSBwYXJzZUludChwb2ludFsxXSkgLSAxO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2V0RGF0YShcclxuICAgICAgICAgICAgICAgIGluZGljZVBvc2l0aW9uRnJvbU9iaixcclxuICAgICAgICAgICAgICAgIDEsIC8vRGVmYXVsdCB2YWx1ZSBmb3IgdXZcclxuICAgICAgICAgICAgICAgIGluZGljZU5vcm1hbEZyb21PYmosXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbnNbaW5kaWNlUG9zaXRpb25Gcm9tT2JqXSwgLy9HZXQgZWFjaCB2ZWN0b3Igb2YgZGF0YVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMi5aZXJvKCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzW2luZGljZU5vcm1hbEZyb21PYmpdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Q29sb3IoaW5kaWNlUG9zaXRpb25Gcm9tT2JqKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1Jlc2V0IHZhcmlhYmxlIGZvciB0aGUgbmV4dCBsaW5lXHJcbiAgICAgICAgdGhpcy5fdHJpYW5nbGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIENyZWF0ZSB0cmlhbmdsZXMgYW5kIHB1c2ggdGhlIGRhdGEgZm9yIGVhY2ggcG9seWdvbiBmb3IgdGhlIHBhdHRlcm4gM1xyXG4gICAgICogSW4gdGhpcyBwYXR0ZXJuIHdlIGdldCB2ZXJ0aWNlIHBvc2l0aW9ucywgdXZzIGFuZCBub3JtYWxzXHJcbiAgICAgKiBAcGFyYW0gZmFjZVxyXG4gICAgICogQHBhcmFtIHZcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc2V0RGF0YUZvckN1cnJlbnRGYWNlV2l0aFBhdHRlcm41KGZhY2U6IEFycmF5PHN0cmluZz4sIHY6IG51bWJlcikge1xyXG4gICAgICAgIC8vR2V0IHRoZSBpbmRpY2VzIG9mIHRyaWFuZ2xlcyBmb3IgZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgdGhpcy5fZ2V0VHJpYW5nbGVzKGZhY2UsIHYpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMuX3RyaWFuZ2xlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAvL3RyaWFuZ2xlW2tdID0gXCItMS8tMS8tMVwiXHJcbiAgICAgICAgICAgIC8vU3BsaXQgdGhlIGRhdGEgZm9yIGdldHRpbmcgcG9zaXRpb24sIHV2LCBhbmQgbm9ybWFsc1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX3RyaWFuZ2xlc1trXS5zcGxpdChcIi9cIik7IC8vIFtcIi0xXCIsIFwiLTFcIiwgXCItMVwiXVxyXG4gICAgICAgICAgICAvLyBTZXQgcG9zaXRpb24gaW5kaWNlXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZVBvc2l0aW9uRnJvbU9iaiA9IHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggKyBwYXJzZUludChwb2ludFswXSk7XHJcbiAgICAgICAgICAgIC8vIFNldCB1diBpbmRpY2VcclxuICAgICAgICAgICAgY29uc3QgaW5kaWNlVXZzRnJvbU9iaiA9IHRoaXMuX3V2cy5sZW5ndGggKyBwYXJzZUludChwb2ludFsxXSk7XHJcbiAgICAgICAgICAgIC8vIFNldCBub3JtYWwgaW5kaWNlXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZU5vcm1hbEZyb21PYmogPSB0aGlzLl9ub3JtYWxzLmxlbmd0aCArIHBhcnNlSW50KHBvaW50WzJdKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEoXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VQb3NpdGlvbkZyb21PYmosXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VVdnNGcm9tT2JqLFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlTm9ybWFsRnJvbU9iaixcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uc1tpbmRpY2VQb3NpdGlvbkZyb21PYmpdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXZzW2luZGljZVV2c0Zyb21PYmpdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsc1tpbmRpY2VOb3JtYWxGcm9tT2JqXSwgLy9TZXQgdGhlIHZlY3RvciBmb3IgZWFjaCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldENvbG9yKGluZGljZVBvc2l0aW9uRnJvbU9iailcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9SZXNldCB2YXJpYWJsZSBmb3IgdGhlIG5leHQgbGluZVxyXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2FkZFByZXZpb3VzT2JqTWVzaCgpIHtcclxuICAgICAgICAvL0NoZWNrIGlmIGl0IGlzIG5vdCB0aGUgZmlyc3QgbWVzaC4gT3RoZXJ3aXNlIHdlIGRvbid0IGhhdmUgZGF0YS5cclxuICAgICAgICBpZiAodGhpcy5fbWVzaGVzRnJvbU9iai5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBwcmV2aW91cyBtZXNoIGZvciBhcHBseWluZyB0aGUgZGF0YSBhYm91dCB0aGUgZmFjZXNcclxuICAgICAgICAgICAgLy89PiBpbiBvYmogZmlsZSwgZmFjZXMgZGVmaW5pdGlvbiBhcHBlbmQgYWZ0ZXIgdGhlIG5hbWUgb2YgdGhlIG1lc2hcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlZE1lc2ggPSB0aGlzLl9tZXNoZXNGcm9tT2JqW3RoaXMuX21lc2hlc0Zyb21PYmoubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgICAgICAvL1NldCB0aGUgZGF0YSBpbnRvIEFycmF5IGZvciB0aGUgbWVzaFxyXG4gICAgICAgICAgICB0aGlzLl91bndyYXBEYXRhKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbG9hZGluZ09wdGlvbnMudXNlTGVnYWN5QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgdGFiLiBPdGhlcndpc2UgZmFjZSBhcmUgZGlzcGxheWVkIGluIHRoZSB3cm9uZyBzZW5zXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRpY2VzRm9yQmFieWxvbi5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vU2V0IHRoZSBpbmZvcm1hdGlvbiBmb3IgdGhlIG1lc2hcclxuICAgICAgICAgICAgLy9TbGljZSB0aGUgYXJyYXkgdG8gYXZvaWQgcmV3cml0aW5nIGJlY2F1c2Ugb2YgdGhlIGZhY3QgdGhpcyBpcyB0aGUgc2FtZSB2YXIgd2hpY2ggYmUgcmV3cml0ZWRcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlZE1lc2guaW5kaWNlcyA9IHRoaXMuX2luZGljZXNGb3JCYWJ5bG9uLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoLnBvc2l0aW9ucyA9IHRoaXMuX3Vud3JhcHBlZFBvc2l0aW9uc0ZvckJhYnlsb24uc2xpY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlZE1lc2gubm9ybWFscyA9IHRoaXMuX3Vud3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoLnV2cyA9IHRoaXMuX3Vud3JhcHBlZFVWRm9yQmFieWxvbi5zbGljZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVkTWVzaC5oYXNMaW5lcyA9IHRoaXMuX2hhc0xpbmVEYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdPcHRpb25zLmltcG9ydFZlcnRleENvbG9ycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlZE1lc2guY29sb3JzID0gdGhpcy5fdW53cmFwcGVkQ29sb3JzRm9yQmFieWxvbi5zbGljZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1Jlc2V0IHRoZSBhcnJheSBmb3IgdGhlIG5leHQgbWVzaFxyXG4gICAgICAgICAgICB0aGlzLl9pbmRpY2VzRm9yQmFieWxvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl91bndyYXBwZWRQb3NpdGlvbnNGb3JCYWJ5bG9uLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcHBlZENvbG9yc0ZvckJhYnlsb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkTm9ybWFsc0ZvckJhYnlsb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkVVZGb3JCYWJ5bG9uLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0xpbmVEYXRhID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX29wdGltaXplTm9ybWFscyhtZXNoOiBBYnN0cmFjdE1lc2gpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBtZXNoLmdldFZlcnRpY2VzRGF0YShWZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTtcclxuICAgICAgICBjb25zdCBub3JtYWxzID0gbWVzaC5nZXRWZXJ0aWNlc0RhdGEoVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpO1xyXG4gICAgICAgIGNvbnN0IG1hcFZlcnRpY2VzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlcltdIH0gPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCFwb3NpdGlvbnMgfHwgIW5vcm1hbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBwb3NpdGlvbnNbaSAqIDMgKyAwXTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICogMyArIDFdO1xyXG4gICAgICAgICAgICBjb25zdCB6ID0gcG9zaXRpb25zW2kgKiAzICsgMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHggKyBcIl9cIiArIHkgKyBcIl9cIiArIHo7XHJcblxyXG4gICAgICAgICAgICBsZXQgbHN0ID0gbWFwVmVydGljZXNba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFsc3QpIHtcclxuICAgICAgICAgICAgICAgIGxzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbWFwVmVydGljZXNba2V5XSA9IGxzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsc3QucHVzaChpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFwVmVydGljZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbHN0ID0gbWFwVmVydGljZXNba2V5XTtcclxuICAgICAgICAgICAgaWYgKGxzdC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdjBJZHggPSBsc3RbMF07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbHN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2SWR4ID0gbHN0W2ldO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsc1t2MElkeCAqIDMgKyAwXSArPSBub3JtYWxzW3ZJZHggKiAzICsgMF07XHJcbiAgICAgICAgICAgICAgICBub3JtYWxzW3YwSWR4ICogMyArIDFdICs9IG5vcm1hbHNbdklkeCAqIDMgKyAxXTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHNbdjBJZHggKiAzICsgMl0gKz0gbm9ybWFsc1t2SWR4ICogMyArIDJdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBub3JtYWwuY29weUZyb21GbG9hdHMobm9ybWFsc1t2MElkeCAqIDMgKyAwXSwgbm9ybWFsc1t2MElkeCAqIDMgKyAxXSwgbm9ybWFsc1t2MElkeCAqIDMgKyAyXSk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2SWR4ID0gbHN0W2ldO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsc1t2SWR4ICogMyArIDBdID0gbm9ybWFsLng7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxzW3ZJZHggKiAzICsgMV0gPSBub3JtYWwueTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHNbdklkeCAqIDMgKyAyXSA9IG5vcm1hbC56O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc2guc2V0VmVydGljZXNEYXRhKFZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLCBub3JtYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfSXNMaW5lRWxlbWVudChsaW5lOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gbGluZS5zdGFydHNXaXRoKFwibFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfSXNPYmplY3RFbGVtZW50KGxpbmU6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBsaW5lLnN0YXJ0c1dpdGgoXCJvXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9Jc0dyb3VwRWxlbWVudChsaW5lOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gbGluZS5zdGFydHNXaXRoKFwiZ1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfR2V0WmJydXNoTVJHQihsaW5lOiBzdHJpbmcsIG5vdFBhcnNlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKCFsaW5lLnN0YXJ0c1dpdGgoXCJtcmdiXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFwibXJnYlwiLCBcIlwiKS50cmltKCk7XHJcbiAgICAgICAgLy8gaWYgaW5jbHVkZSB2ZXJ0ZXggY29sb3IgLCBub3QgbG9hZCBtcmdiIGFueW1vcmVcclxuICAgICAgICBpZiAobm90UGFyc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZWdleCA9IC9bYS16MC05XS9nO1xyXG4gICAgICAgIGNvbnN0IHJlZ0FycmF5ID0gbGluZS5tYXRjaChyZWdleCk7XHJcbiAgICAgICAgaWYgKCFyZWdBcnJheSB8fCByZWdBcnJheS5sZW5ndGggJSA4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJyYXk6IENvbG9yNFtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcmVnSW5kZXggPSAwOyByZWdJbmRleCA8IHJlZ0FycmF5Lmxlbmd0aCAvIDg7IHJlZ0luZGV4KyspIHtcclxuICAgICAgICAgICAgLy9lYWNoIGl0ZW0gaXMgTU1SUkdHQkIsIG0gaXMgbWF0ZXJpYWwgaW5kZXhcclxuICAgICAgICAgICAgLy8gY29uc3QgbSA9IHJlZ0FycmF5W3JlZ0luZGV4ICogOCArIDBdICsgcmVnQXJyYXlbcmVnSW5kZXggKiA4ICsgMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSByZWdBcnJheVtyZWdJbmRleCAqIDggKyAyXSArIHJlZ0FycmF5W3JlZ0luZGV4ICogOCArIDNdO1xyXG4gICAgICAgICAgICBjb25zdCBnID0gcmVnQXJyYXlbcmVnSW5kZXggKiA4ICsgNF0gKyByZWdBcnJheVtyZWdJbmRleCAqIDggKyA1XTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IHJlZ0FycmF5W3JlZ0luZGV4ICogOCArIDZdICsgcmVnQXJyYXlbcmVnSW5kZXggKiA4ICsgN107XHJcbiAgICAgICAgICAgIGFycmF5LnB1c2gobmV3IENvbG9yNChwYXJzZUludChyLCAxNikgLyAyNTUsIHBhcnNlSW50KGcsIDE2KSAvIDI1NSwgcGFyc2VJbnQoYiwgMTYpIC8gMjU1LCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gcGFyc2UgYW4gT0JKIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIG1lc2hlc05hbWVzIGRlZmluZXMgdGhlIGxpc3Qgb2YgbWVzaGVzIHRvIGxvYWQgKGFsbCBpZiBub3QgZGVmaW5lZClcclxuICAgICAqIEBwYXJhbSBkYXRhIGRlZmluZXMgdGhlIE9CSiBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBzY2VuZSBkZWZpbmVzIHRoZSBob3N0aW5nIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gYXNzZXRDb250YWluZXIgZGVmaW5lcyB0aGUgYXNzZXQgY29udGFpbmVyIHRvIGxvYWQgZGF0YSBpblxyXG4gICAgICogQHBhcmFtIG9uRmlsZVRvTG9hZEZvdW5kIGRlZmluZXMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGlmIGEgTVRMIGZpbGUgaXMgZm91bmRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBhcnNlKG1lc2hlc05hbWVzOiBhbnksIGRhdGE6IHN0cmluZywgc2NlbmU6IFNjZW5lLCBhc3NldENvbnRhaW5lcjogTnVsbGFibGU8QXNzZXRDb250YWluZXI+LCBvbkZpbGVUb0xvYWRGb3VuZDogKGZpbGVUb0xvYWQ6IHN0cmluZykgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIC8vTW92ZSBTYW50aXRpemUgaGVyZSB0byBmb3JiaWQgZGVsZXRlIHpicnVzaCBkYXRhXHJcbiAgICAgICAgLy8gU2FuaXRpemUgZGF0YVxyXG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyNNUkdCL2csIFwibXJnYlwiKTtcclxuICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8jLiokL2dtLCBcIlwiKS50cmltKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdPcHRpb25zLnVzZUxlZ2FjeUJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3B1c2hUcmlhbmdsZSA9IChmYWNlcywgZmFjZUluZGV4KSA9PiB0aGlzLl90cmlhbmdsZXMucHVzaChmYWNlc1swXSwgZmFjZXNbZmFjZUluZGV4XSwgZmFjZXNbZmFjZUluZGV4ICsgMV0pO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kZWRuZXNzU2lnbiA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzY2VuZS51c2VSaWdodEhhbmRlZFN5c3RlbSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wdXNoVHJpYW5nbGUgPSAoZmFjZXMsIGZhY2VJbmRleCkgPT4gdGhpcy5fdHJpYW5nbGVzLnB1c2goZmFjZXNbMF0sIGZhY2VzW2ZhY2VJbmRleCArIDFdLCBmYWNlc1tmYWNlSW5kZXhdKTtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGVkbmVzc1NpZ24gPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3B1c2hUcmlhbmdsZSA9IChmYWNlcywgZmFjZUluZGV4KSA9PiB0aGlzLl90cmlhbmdsZXMucHVzaChmYWNlc1swXSwgZmFjZXNbZmFjZUluZGV4XSwgZmFjZXNbZmFjZUluZGV4ICsgMV0pO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kZWRuZXNzU2lnbiA9IC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3BsaXQgdGhlIGZpbGUgaW50byBsaW5lc1xyXG4gICAgICAgIC8vIFByZXByb2Nlc3MgbGluZSBkYXRhXHJcbiAgICAgICAgY29uc3QgbGluZXNPQkogPSBkYXRhLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVMaW5lczogc3RyaW5nW11bXSA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50R3JvdXA6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgIGxpbmVMaW5lcy5wdXNoKGN1cnJlbnRHcm91cCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNPQkoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzT0JKW2ldLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMvZywgXCIgXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tbWVudCBvciBuZXdMaW5lXHJcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCB8fCBsaW5lLmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU29saWRQYXJzZXIuX0lzR3JvdXBFbGVtZW50KGxpbmUpIHx8IFNvbGlkUGFyc2VyLl9Jc09iamVjdEVsZW1lbnQobGluZSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGluZUxpbmVzLnB1c2goY3VycmVudEdyb3VwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNvbGlkUGFyc2VyLl9Jc0xpbmVFbGVtZW50KGxpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lVmFsdWVzID0gbGluZS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbGluZSBlbGVtZW50cyB3aXRoIHR3byB2ZXJ0aWNlcyBvbmx5XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVWYWx1ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnB1c2goYGwgJHtsaW5lVmFsdWVzW2ldfSAke2xpbmVWYWx1ZXNbaSArIDFdfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnB1c2gobGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gbGluZUxpbmVzLmZsYXQoKTtcclxuICAgICAgICAvLyBMb29rIGF0IGVhY2ggbGluZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMvZywgXCIgXCIpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICAvLyBDb21tZW50IG9yIG5ld0xpbmVcclxuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KDApID09PSBcIiNcIikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoU29saWRQYXJzZXIuVmVydGV4UGF0dGVybi50ZXN0KGxpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCBpbmZvcm1hdGlvbiBhYm91dCBvbmUgcG9zaXRpb24gcG9zc2libGUgZm9yIHRoZSB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGluZS5tYXRjaCgvW14gXSsvZykhOyAvLyBtYXRjaCB3aWxsIHJldHVybiBub24tbnVsbCBkdWUgdG8gcGFzc2luZyByZWdleCBwYXR0ZXJuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVmFsdWUgb2YgcmVzdWx0IHdpdGggbGluZTogXCJ2IDEuMCAyLjAgMy4wXCJcclxuICAgICAgICAgICAgICAgIC8vIFtcInZcIiwgXCIxLjBcIiwgXCIyLjBcIiwgXCIzLjBcIl1cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIFZlY3RvcjMgd2l0aCB0aGUgcG9zaXRpb24geCwgeSwgelxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjMocGFyc2VGbG9hdChyZXN1bHRbMV0pLCBwYXJzZUZsb2F0KHJlc3VsdFsyXSksIHBhcnNlRmxvYXQocmVzdWx0WzNdKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nT3B0aW9ucy5pbXBvcnRWZXJ0ZXhDb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSA3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBwYXJzZUZsb2F0KHJlc3VsdFs0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBwYXJzZUZsb2F0KHJlc3VsdFs1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBwYXJzZUZsb2F0KHJlc3VsdFs2XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDb2xvcjQociA+IDEgPyByIC8gMjU1IDogciwgZyA+IDEgPyBnIC8gMjU1IDogZywgYiA+IDEgPyBiIC8gMjU1IDogYiwgcmVzdWx0Lmxlbmd0aCA9PT0gNyB8fCByZXN1bHRbN10gPT09IHVuZGVmaW5lZCA/IDEgOiBwYXJzZUZsb2F0KHJlc3VsdFs3XSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgcHVzaCBOVUxMIGFuZCBpZiBhbGwgYXJlIE5VTEwgdG8gc2tpcCAoYW5kIHJlbW92ZSBncmF5Q29sb3IgdmFyKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sb3JzLnB1c2godGhpcy5fZ3JheUNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IFNvbGlkUGFyc2VyLk5vcm1hbFBhdHRlcm4uZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vQ3JlYXRlIGEgVmVjdG9yMyB3aXRoIHRoZSBub3JtYWxzIHgsIHksIHpcclxuICAgICAgICAgICAgICAgIC8vVmFsdWUgb2YgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBbXCJ2biAxLjAgMi4wIDMuMFwiLCBcIjEuMFwiLCBcIjIuMFwiLCBcIjMuMFwiXVxyXG4gICAgICAgICAgICAgICAgLy9BZGQgdGhlIFZlY3RvciBpbiB0aGUgbGlzdCBvZiBub3JtYWxzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzLnB1c2gobmV3IFZlY3RvcjMocGFyc2VGbG9hdChyZXN1bHRbMV0pLCBwYXJzZUZsb2F0KHJlc3VsdFsyXSksIHBhcnNlRmxvYXQocmVzdWx0WzNdKSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBTb2xpZFBhcnNlci5VVlBhdHRlcm4uZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vQ3JlYXRlIGEgVmVjdG9yMiB3aXRoIHRoZSBub3JtYWxzIHUsIHZcclxuICAgICAgICAgICAgICAgIC8vVmFsdWUgb2YgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBbXCJ2dCAwLjEgMC4yIDAuM1wiLCBcIjAuMVwiLCBcIjAuMlwiXVxyXG4gICAgICAgICAgICAgICAgLy9BZGQgdGhlIFZlY3RvciBpbiB0aGUgbGlzdCBvZiB1dnNcclxuICAgICAgICAgICAgICAgIHRoaXMuX3V2cy5wdXNoKG5ldyBWZWN0b3IyKHBhcnNlRmxvYXQocmVzdWx0WzFdKSAqIHRoaXMuX2xvYWRpbmdPcHRpb25zLlVWU2NhbGluZy54LCBwYXJzZUZsb2F0KHJlc3VsdFsyXSkgKiB0aGlzLl9sb2FkaW5nT3B0aW9ucy5VVlNjYWxpbmcueSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vSWRlbnRpZnkgcGF0dGVybnMgb2YgZmFjZXNcclxuICAgICAgICAgICAgICAgIC8vRmFjZSBjb3VsZCBiZSBkZWZpbmVkIGluIGRpZmZlcmVudCB0eXBlIG9mIHBhdHRlcm5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gU29saWRQYXJzZXIuRmFjZVBhdHRlcm4zLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvL1ZhbHVlIG9mIHJlc3VsdDpcclxuICAgICAgICAgICAgICAgIC8vW1wiZiAxLzEvMSAyLzIvMiAzLzMvM1wiLCBcIjEvMS8xIDIvMi8yIDMvMy8zXCIuLi5dXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TZXQgdGhlIGRhdGEgZm9yIHRoaXMgZmFjZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YUZvckN1cnJlbnRGYWNlV2l0aFBhdHRlcm4zKFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsxXS50cmltKCkuc3BsaXQoXCIgXCIpLCAvLyBbXCIxLzEvMVwiLCBcIjIvMi8yXCIsIFwiMy8zLzNcIl1cclxuICAgICAgICAgICAgICAgICAgICAxXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBTb2xpZFBhcnNlci5GYWNlUGF0dGVybjQuZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vVmFsdWUgb2YgcmVzdWx0OlxyXG4gICAgICAgICAgICAgICAgLy9bXCJmIDEvLzEgMi8vMiAzLy8zXCIsIFwiMS8vMSAyLy8yIDMvLzNcIi4uLl1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1NldCB0aGUgZGF0YSBmb3IgdGhpcyBmYWNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREYXRhRm9yQ3VycmVudEZhY2VXaXRoUGF0dGVybjQoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzFdLnRyaW0oKS5zcGxpdChcIiBcIiksIC8vIFtcIjEvLzFcIiwgXCIyLy8yXCIsIFwiMy8vM1wiXVxyXG4gICAgICAgICAgICAgICAgICAgIDFcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IFNvbGlkUGFyc2VyLkZhY2VQYXR0ZXJuNS5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy9WYWx1ZSBvZiByZXN1bHQ6XHJcbiAgICAgICAgICAgICAgICAvL1tcImYgLTEvLTEvLTEgLTIvLTIvLTIgLTMvLTMvLTNcIiwgXCItMS8tMS8tMSAtMi8tMi8tMiAtMy8tMy8tM1wiLi4uXVxyXG5cclxuICAgICAgICAgICAgICAgIC8vU2V0IHRoZSBkYXRhIGZvciB0aGlzIGZhY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldERhdGFGb3JDdXJyZW50RmFjZVdpdGhQYXR0ZXJuNShcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0udHJpbSgpLnNwbGl0KFwiIFwiKSwgLy8gW1wiLTEvLTEvLTFcIiwgXCItMi8tMi8tMlwiLCBcIi0zLy0zLy0zXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgMVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gU29saWRQYXJzZXIuRmFjZVBhdHRlcm4yLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvL1ZhbHVlIG9mIHJlc3VsdDpcclxuICAgICAgICAgICAgICAgIC8vW1wiZiAxLzEgMi8yIDMvM1wiLCBcIjEvMSAyLzIgMy8zXCIuLi5dXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TZXQgdGhlIGRhdGEgZm9yIHRoaXMgZmFjZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YUZvckN1cnJlbnRGYWNlV2l0aFBhdHRlcm4yKFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsxXS50cmltKCkuc3BsaXQoXCIgXCIpLCAvLyBbXCIxLzFcIiwgXCIyLzJcIiwgXCIzLzNcIl1cclxuICAgICAgICAgICAgICAgICAgICAxXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBTb2xpZFBhcnNlci5GYWNlUGF0dGVybjEuZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vVmFsdWUgb2YgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvL1tcImYgMSAyIDNcIiwgXCIxIDIgM1wiLi4uXVxyXG5cclxuICAgICAgICAgICAgICAgIC8vU2V0IHRoZSBkYXRhIGZvciB0aGlzIGZhY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldERhdGFGb3JDdXJyZW50RmFjZVdpdGhQYXR0ZXJuMShcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0udHJpbSgpLnNwbGl0KFwiIFwiKSwgLy8gW1wiMVwiLCBcIjJcIiwgXCIzXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgMVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZpbmUgYSBtZXNoIG9yIGFuIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgLy8gRWFjaCB0aW1lIHRoaXMga2V5d29yZCBpcyBhbmFseXplZCwgY3JlYXRlIGEgbmV3IE9iamVjdCB3aXRoIGFsbCBkYXRhIGZvciBjcmVhdGluZyBhIGJhYnlsb25NZXNoXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IFNvbGlkUGFyc2VyLkxpbmVQYXR0ZXJuMS5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy9WYWx1ZSBvZiByZXN1bHRcclxuICAgICAgICAgICAgICAgIC8vW1wibCAxIDJcIl1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1NldCB0aGUgZGF0YSBmb3IgdGhpcyBmYWNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREYXRhRm9yQ3VycmVudEZhY2VXaXRoUGF0dGVybjEoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzFdLnRyaW0oKS5zcGxpdChcIiBcIiksIC8vIFtcIjFcIiwgXCIyXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgMFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0xpbmVEYXRhID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZpbmUgYSBtZXNoIG9yIGFuIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgLy8gRWFjaCB0aW1lIHRoaXMga2V5d29yZCBpcyBhbmFseXplZCwgY3JlYXRlIGEgbmV3IE9iamVjdCB3aXRoIGFsbCBkYXRhIGZvciBjcmVhdGluZyBhIGJhYnlsb25NZXNoXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IFNvbGlkUGFyc2VyLkxpbmVQYXR0ZXJuMi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy9WYWx1ZSBvZiByZXN1bHRcclxuICAgICAgICAgICAgICAgIC8vW1wibCAxLzEgMi8yXCJdXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TZXQgdGhlIGRhdGEgZm9yIHRoaXMgZmFjZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YUZvckN1cnJlbnRGYWNlV2l0aFBhdHRlcm4yKFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsxXS50cmltKCkuc3BsaXQoXCIgXCIpLCAvLyBbXCIxLzFcIiwgXCIyLzJcIl1cclxuICAgICAgICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzTGluZURhdGEgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBhIG1lc2ggb3IgYW4gb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHRpbWUgdGhpcyBrZXl3b3JkIGlzIGFuYWx5emVkLCBjcmVhdGUgYSBuZXcgT2JqZWN0IHdpdGggYWxsIGRhdGEgZm9yIGNyZWF0aW5nIGEgYmFieWxvbk1lc2hcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gU29saWRQYXJzZXIuX0dldFpicnVzaE1SR0IobGluZSwgIXRoaXMuX2xvYWRpbmdPcHRpb25zLmltcG9ydFZlcnRleENvbG9ycykpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXh0Q29sb3JzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IFNvbGlkUGFyc2VyLkxpbmVQYXR0ZXJuMy5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy9WYWx1ZSBvZiByZXN1bHRcclxuICAgICAgICAgICAgICAgIC8vW1wibCAxLzEvMSAyLzIvMlwiXVxyXG5cclxuICAgICAgICAgICAgICAgIC8vU2V0IHRoZSBkYXRhIGZvciB0aGlzIGZhY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldERhdGFGb3JDdXJyZW50RmFjZVdpdGhQYXR0ZXJuMyhcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0udHJpbSgpLnNwbGl0KFwiIFwiKSwgLy8gW1wiMS8xLzFcIiwgXCIyLzIvMlwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNMaW5lRGF0YSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVmaW5lIGEgbWVzaCBvciBhbiBvYmplY3RcclxuICAgICAgICAgICAgICAgIC8vIEVhY2ggdGltZSB0aGlzIGtleXdvcmQgaXMgYW5hbHl6ZWQsIGNyZWF0ZSBhIG5ldyBPYmplY3Qgd2l0aCBhbGwgZGF0YSBmb3IgY3JlYXRpbmcgYSBiYWJ5bG9uTWVzaFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFNvbGlkUGFyc2VyLkdyb3VwRGVzY3JpcHRvci50ZXN0KGxpbmUpIHx8IFNvbGlkUGFyc2VyLk9iamVjdERlc2NyaXB0b3IudGVzdChsaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1lc2ggY29ycmVzcG9uZGluZyB0byB0aGUgbmFtZSBvZiB0aGUgZ3JvdXAuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZpbml0aW9uIG9mIHRoZSBtZXNoXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpNZXNoOiBNZXNoT2JqZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGxpbmUuc3Vic3RyaW5nKDIpLnRyaW0oKSwgLy9TZXQgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgb2JqIG1lc2hcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHV2czogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxOYW1lOiB0aGlzLl9tYXRlcmlhbE5hbWVGcm9tT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0OiBTb2xpZFBhcnNlci5PYmplY3REZXNjcmlwdG9yLnRlc3QobGluZSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUHJldmlvdXNPYmpNZXNoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9QdXNoIHRoZSBsYXN0IG1lc2ggY3JlYXRlZCB3aXRoIG9ubHkgdGhlIG5hbWVcclxuICAgICAgICAgICAgICAgIHRoaXMuX21lc2hlc0Zyb21PYmoucHVzaChvYmpNZXNoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1NldCB0aGlzIHZhcmlhYmxlIHRvIGluZGljYXRlIHRoYXQgbm93IG1lc2hlc0Zyb21PYmogaGFzIG9iamVjdHMgZGVmaW5lZCBpbnNpZGVcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc01lc2hlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpcnN0TWF0ZXJpYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50ID0gMTtcclxuICAgICAgICAgICAgICAgIC8vS2V5d29yZCBmb3IgYXBwbHlpbmcgYSBtYXRlcmlhbFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFNvbGlkUGFyc2VyLlVzZU10bERlc2NyaXB0b3IudGVzdChsaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGhlIG5hbWUgb2YgdGhlIG1hdGVyaWFsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRlcmlhbE5hbWVGcm9tT2JqID0gbGluZS5zdWJzdHJpbmcoNykudHJpbSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vSWYgdGhpcyBuZXcgbWF0ZXJpYWwgaXMgaW4gdGhlIHNhbWUgbWVzaFxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNGaXJzdE1hdGVyaWFsIHx8ICF0aGlzLl9oYXNNZXNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1NldCB0aGUgZGF0YSBmb3IgdGhlIHByZXZpb3VzIG1lc2hcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRQcmV2aW91c09iak1lc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBtZXNoXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqTWVzaDogTWVzaE9iamVjdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU2V0IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG9iaiBtZXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICh0aGlzLl9vYmpNZXNoTmFtZSB8fCBcIm1lc2hcIikgKyBcIl9tbVwiICsgdGhpcy5faW5jcmVtZW50LnRvU3RyaW5nKCksIC8vU2V0IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG9iaiBtZXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2czogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsTmFtZTogdGhpcy5fbWF0ZXJpYWxOYW1lRnJvbU9iaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQrKztcclxuICAgICAgICAgICAgICAgICAgICAvL0lmIG1lc2hlcyBhcmUgYWxyZWFkeSBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzaGVzRnJvbU9iai5wdXNoKG9iak1lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc01lc2hlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL1NldCB0aGUgbWF0ZXJpYWwgbmFtZSBpZiB0aGUgcHJldmlvdXMgbGluZSBkZWZpbmUgYSBtZXNoXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01lc2hlcyAmJiB0aGlzLl9pc0ZpcnN0TWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1NldCB0aGUgbWF0ZXJpYWwgbmFtZSB0byB0aGUgcHJldmlvdXMgbWVzaCAoMSBtYXRlcmlhbCBwZXIgbWVzaClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNoZXNGcm9tT2JqW3RoaXMuX21lc2hlc0Zyb21PYmoubGVuZ3RoIC0gMV0ubWF0ZXJpYWxOYW1lID0gdGhpcy5fbWF0ZXJpYWxOYW1lRnJvbU9iajtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpcnN0TWF0ZXJpYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEtleXdvcmQgZm9yIGxvYWRpbmcgdGhlIG10bCBmaWxlXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoU29saWRQYXJzZXIuTXRsTGliR3JvdXBEZXNjcmlwdG9yLnRlc3QobGluZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmFtZSBvZiBtdGwgZmlsZVxyXG4gICAgICAgICAgICAgICAgb25GaWxlVG9Mb2FkRm91bmQobGluZS5zdWJzdHJpbmcoNykudHJpbSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBzbW9vdGhpbmdcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChTb2xpZFBhcnNlci5TbW9vdGhEZXNjcmlwdG9yLnRlc3QobGluZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNtb290aCBzaGFkaW5nID0+IGFwcGx5IHNtb290aGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gVG9kYXkgSSBkb24ndCBrbm93IGl0IHdvcmsgd2l0aCBiYWJ5bG9uIGFuZCB3aXRoIG9iai5cclxuICAgICAgICAgICAgICAgIC8vIFdpdGggdGhlIG9iaiBmaWxlICBhbiBpbnRlZ2VyIGlzIHNldFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyBhbm90aGVyIHBvc3NpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTG9nKFwiVW5oYW5kbGVkIGV4cHJlc3Npb24gYXQgbGluZSA6IFwiICsgbGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiB0aGUgZmlsZSwgYWRkIHRoZSBsYXN0IG1lc2ggaW50byB0aGUgbWVzaGVzRnJvbU9iaiBhcnJheVxyXG4gICAgICAgIGlmICh0aGlzLl9oYXNNZXNoZXMpIHtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBkYXRhIGZvciB0aGUgbGFzdCBtZXNoXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoID0gdGhpcy5fbWVzaGVzRnJvbU9ialt0aGlzLl9tZXNoZXNGcm9tT2JqLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdPcHRpb25zLnVzZUxlZ2FjeUJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgICAgICAvL1JldmVyc2UgaW5kaWNlcyBmb3IgZGlzcGxheWluZyBmYWNlcyBpbiB0aGUgZ29vZCBzZW5zZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNlc0ZvckJhYnlsb24ucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0dldCB0aGUgZ29vZCBhcnJheVxyXG4gICAgICAgICAgICB0aGlzLl91bndyYXBEYXRhKCk7XHJcbiAgICAgICAgICAgIC8vU2V0IGFycmF5XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoLmluZGljZXMgPSB0aGlzLl9pbmRpY2VzRm9yQmFieWxvbjtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlZE1lc2gucG9zaXRpb25zID0gdGhpcy5fdW53cmFwcGVkUG9zaXRpb25zRm9yQmFieWxvbjtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlZE1lc2gubm9ybWFscyA9IHRoaXMuX3Vud3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVkTWVzaC51dnMgPSB0aGlzLl91bndyYXBwZWRVVkZvckJhYnlsb247XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoLmhhc0xpbmVzID0gdGhpcy5faGFzTGluZURhdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nT3B0aW9ucy5pbXBvcnRWZXJ0ZXhDb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoLmNvbG9ycyA9IHRoaXMuX3Vud3JhcHBlZENvbG9yc0ZvckJhYnlsb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBvIG9yIGcga2V5d29yZCBub3QgZm91bmQsIGNyZWF0ZSBhIG1lc2ggd2l0aCBhIHJhbmRvbSBpZFxyXG4gICAgICAgIGlmICghdGhpcy5faGFzTWVzaGVzKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdNYXRlcmlhbDogTnVsbGFibGU8U3RhbmRhcmRNYXRlcmlhbD4gPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5kaWNlc0ZvckJhYnlsb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9hZGluZ09wdGlvbnMudXNlTGVnYWN5QmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnNlIHRhYiBvZiBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kaWNlc0ZvckJhYnlsb24ucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vR2V0IHBvc2l0aW9ucyBub3JtYWxzIHV2c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwRGF0YSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gaW5kaWNlcyBpbiB0aGUgZmlsZS4gV2Ugd2lsbCBoYXZlIHRvIHN3aXRjaCB0byBwb2ludCBjbG91ZCByZW5kZXJpbmdcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9zIG9mIHRoaXMuX3Bvc2l0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcHBlZFBvc2l0aW9uc0ZvckJhYnlsb24ucHVzaChwb3MueCwgcG9zLnksIHBvcy56KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbm9ybWFscy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbCBvZiB0aGlzLl9ub3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91dnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB1diBvZiB0aGlzLl91dnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkVVZGb3JCYWJ5bG9uLnB1c2godXYueCwgdXYueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9leHRDb2xvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2xvciBvZiB0aGlzLl9leHRDb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwcGVkQ29sb3JzRm9yQmFieWxvbi5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbG9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2xvciBvZiB0aGlzLl9jb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcHBlZENvbG9yc0ZvckJhYnlsb24ucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21hdGVyaWFsTmFtZUZyb21PYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBtYXRlcmlhbCB3aXRoIHBvaW50IGNsb3VkIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0ZXJpYWwgPSBuZXcgU3RhbmRhcmRNYXRlcmlhbChHZW9tZXRyeS5SYW5kb21JZCgpLCBzY2VuZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGVyaWFsLnBvaW50c0Nsb3VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxOYW1lRnJvbU9iaiA9IG5ld01hdGVyaWFsLm5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbm9ybWFscy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWF0ZXJpYWwuZGlzYWJsZUxpZ2h0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWF0ZXJpYWwuZW1pc3NpdmVDb2xvciA9IENvbG9yMy5XaGl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9TZXQgZGF0YSBmb3Igb25lIG1lc2hcclxuICAgICAgICAgICAgdGhpcy5fbWVzaGVzRnJvbU9iai5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IEdlb21ldHJ5LlJhbmRvbUlkKCksXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzOiB0aGlzLl9pbmRpY2VzRm9yQmFieWxvbixcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogdGhpcy5fdW53cmFwcGVkUG9zaXRpb25zRm9yQmFieWxvbixcclxuICAgICAgICAgICAgICAgIGNvbG9yczogdGhpcy5fdW53cmFwcGVkQ29sb3JzRm9yQmFieWxvbixcclxuICAgICAgICAgICAgICAgIG5vcm1hbHM6IHRoaXMuX3Vud3JhcHBlZE5vcm1hbHNGb3JCYWJ5bG9uLFxyXG4gICAgICAgICAgICAgICAgdXZzOiB0aGlzLl91bndyYXBwZWRVVkZvckJhYnlsb24sXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbE5hbWU6IHRoaXMuX21hdGVyaWFsTmFtZUZyb21PYmosXHJcbiAgICAgICAgICAgICAgICBkaXJlY3RNYXRlcmlhbDogbmV3TWF0ZXJpYWwsXHJcbiAgICAgICAgICAgICAgICBpc09iamVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhhc0xpbmVzOiB0aGlzLl9oYXNMaW5lRGF0YSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1NldCBkYXRhIGZvciBlYWNoIG1lc2hcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX21lc2hlc0Zyb21PYmoubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgLy9jaGVjayBtZXNoZXNOYW1lcyAoc3RsRmlsZUxvYWRlcilcclxuICAgICAgICAgICAgaWYgKG1lc2hlc05hbWVzICYmIHRoaXMuX21lc2hlc0Zyb21PYmpbal0ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc2hlc05hbWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWVzaGVzTmFtZXMuaW5kZXhPZih0aGlzLl9tZXNoZXNGcm9tT2JqW2pdLm5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZXNoZXNGcm9tT2JqW2pdLm5hbWUgIT09IG1lc2hlc05hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9HZXQgdGhlIGN1cnJlbnQgbWVzaFxyXG4gICAgICAgICAgICAvL1NldCB0aGUgZGF0YSB3aXRoIFZlcnRleEJ1ZmZlciBmb3IgZWFjaCBtZXNoXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoID0gdGhpcy5fbWVzaGVzRnJvbU9ialtqXTtcclxuICAgICAgICAgICAgLy9DcmVhdGUgYSBNZXNoIHdpdGggdGhlIG5hbWUgb2YgdGhlIG9iaiBtZXNoXHJcblxyXG4gICAgICAgICAgICBzY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISFhc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29uc3QgYmFieWxvbk1lc2ggPSBuZXcgTWVzaCh0aGlzLl9tZXNoZXNGcm9tT2JqW2pdLm5hbWUsIHNjZW5lKTtcclxuICAgICAgICAgICAgYmFieWxvbk1lc2guX3BhcmVudENvbnRhaW5lciA9IGFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBzY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRNZXNoLl9iYWJ5bG9uTWVzaCA9IGJhYnlsb25NZXNoO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZ3JvdXAgbWVzaCwgaXQgc2hvdWxkIGhhdmUgYW4gb2JqZWN0IG1lc2ggYXMgYSBwYXJlbnQuIFNvIGxvb2sgZm9yIHRoZSBmaXJzdCBvYmplY3QgbWVzaCB0aGF0IGFwcGVhcnMgYmVmb3JlIGl0LlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZWRNZXNoLmlzT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gaiAtIDE7IGsgPj0gMDsgLS1rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21lc2hlc0Zyb21PYmpba10uaXNPYmplY3QgJiYgdGhpcy5fbWVzaGVzRnJvbU9ialtrXS5fYmFieWxvbk1lc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1lc2gucGFyZW50ID0gdGhpcy5fbWVzaGVzRnJvbU9ialtrXS5fYmFieWxvbk1lc2ghO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vUHVzaCB0aGUgbmFtZSBvZiB0aGUgbWF0ZXJpYWwgdG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgLy9UaGlzIGlzIGluZGlzcGVuc2FibGUgZm9yIHRoZSBpbXBvcnRNZXNoIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsVG9Vc2UucHVzaCh0aGlzLl9tZXNoZXNGcm9tT2JqW2pdLm1hdGVyaWFsTmFtZSk7XHJcbiAgICAgICAgICAgIC8vSWYgdGhlIG1lc2ggaXMgYSBsaW5lIG1lc2hcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZWRNZXNoLmhhc0xpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5faW50ZXJuYWxNZXRhZGF0YSA/Pz0ge307XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5faW50ZXJuYWxNZXRhZGF0YVtcIl9pc0xpbmVcIl0gPSB0cnVlOyAvL3RoaXMgaXMgYSBsaW5lIG1lc2hcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZWRNZXNoLnBvc2l0aW9ucz8ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL1B1c2ggdGhlIG1lc2ggaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFieWxvbk1lc2hlc0FycmF5LnB1c2goYmFieWxvbk1lc2gpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleERhdGE6IFZlcnRleERhdGEgPSBuZXcgVmVydGV4RGF0YSgpOyAvL1RoZSBjb250YWluZXIgZm9yIHRoZSB2YWx1ZXNcclxuICAgICAgICAgICAgLy9TZXQgdGhlIGRhdGEgZm9yIHRoZSBiYWJ5bG9uTWVzaFxyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhLnV2cyA9IHRoaXMuX2hhbmRsZWRNZXNoLnV2cztcclxuICAgICAgICAgICAgdmVydGV4RGF0YS5pbmRpY2VzID0gdGhpcy5faGFuZGxlZE1lc2guaW5kaWNlcztcclxuICAgICAgICAgICAgdmVydGV4RGF0YS5wb3NpdGlvbnMgPSB0aGlzLl9oYW5kbGVkTWVzaC5wb3NpdGlvbnM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nT3B0aW9ucy5jb21wdXRlTm9ybWFscykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsczogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheTxudW1iZXI+KCk7XHJcbiAgICAgICAgICAgICAgICBWZXJ0ZXhEYXRhLkNvbXB1dGVOb3JtYWxzKHRoaXMuX2hhbmRsZWRNZXNoLnBvc2l0aW9ucywgdGhpcy5faGFuZGxlZE1lc2guaW5kaWNlcywgbm9ybWFscyk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4RGF0YS5ub3JtYWxzID0gdGhpcy5faGFuZGxlZE1lc2gubm9ybWFscztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbG9hZGluZ09wdGlvbnMuaW1wb3J0VmVydGV4Q29sb3JzKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhLmNvbG9ycyA9IHRoaXMuX2hhbmRsZWRNZXNoLmNvbG9ycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1NldCB0aGUgZGF0YSBmcm9tIHRoZSBWZXJ0ZXhCdWZmZXIgdG8gdGhlIGN1cnJlbnQgTWVzaFxyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhLmFwcGx5VG9NZXNoKGJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdPcHRpb25zLmludmVydFkpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoLnNjYWxpbmcueSAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbG9hZGluZ09wdGlvbnMub3B0aW1pemVOb3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZU5vcm1hbHMoYmFieWxvbk1lc2gpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1B1c2ggdGhlIG1lc2ggaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICB0aGlzLl9iYWJ5bG9uTWVzaGVzQXJyYXkucHVzaChiYWJ5bG9uTWVzaCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlZE1lc2guZGlyZWN0TWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoLm1hdGVyaWFsID0gdGhpcy5faGFuZGxlZE1lc2guZGlyZWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cclxuZXhwb3J0ICogZnJvbSBcIi4vc3BsYXRMb2FkaW5nT3B0aW9uc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9zcGxhdEZpbGVMb2FkZXJcIjtcclxuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1pbnRlcm5hbC1tb2R1bGVzXHJcbmltcG9ydCB0eXBlIHsgSVNjZW5lTG9hZGVyUGx1Z2luRXh0ZW5zaW9ucywgSVNjZW5lTG9hZGVyUGx1Z2luTWV0YWRhdGEgfSBmcm9tIFwiY29yZS9pbmRleFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNQTEFURmlsZUxvYWRlck1ldGFkYXRhID0ge1xyXG4gICAgbmFtZTogXCJzcGxhdFwiLFxyXG5cclxuICAgIGV4dGVuc2lvbnM6IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICAgICAgXCIuc3BsYXRcIjogeyBpc0JpbmFyeTogdHJ1ZSB9LFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgICAgICBcIi5wbHlcIjogeyBpc0JpbmFyeTogdHJ1ZSB9LFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgICAgICBcIi5zcHpcIjogeyBpc0JpbmFyeTogdHJ1ZSB9LFxyXG4gICAgfSBhcyBjb25zdCBzYXRpc2ZpZXMgSVNjZW5lTG9hZGVyUGx1Z2luRXh0ZW5zaW9ucyxcclxufSBhcyBjb25zdCBzYXRpc2ZpZXMgSVNjZW5lTG9hZGVyUGx1Z2luTWV0YWRhdGE7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jICovXHJcbmltcG9ydCB0eXBlIHsgSVNjZW5lTG9hZGVyUGx1Z2luQXN5bmMsIElTY2VuZUxvYWRlclBsdWdpbkZhY3RvcnksIElTY2VuZUxvYWRlckFzeW5jUmVzdWx0LCBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50LCBTY2VuZUxvYWRlclBsdWdpbk9wdGlvbnMgfSBmcm9tIFwiY29yZS9Mb2FkaW5nL3NjZW5lTG9hZGVyXCI7XHJcbmltcG9ydCB7IFJlZ2lzdGVyU2NlbmVMb2FkZXJQbHVnaW4gfSBmcm9tIFwiY29yZS9Mb2FkaW5nL3NjZW5lTG9hZGVyXCI7XHJcbmltcG9ydCB7IFNQTEFURmlsZUxvYWRlck1ldGFkYXRhIH0gZnJvbSBcIi4vc3BsYXRGaWxlTG9hZGVyLm1ldGFkYXRhXCI7XHJcbmltcG9ydCB7IEdhdXNzaWFuU3BsYXR0aW5nTWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9HYXVzc2lhblNwbGF0dGluZy9nYXVzc2lhblNwbGF0dGluZ01lc2hcIjtcclxuaW1wb3J0IHsgQXNzZXRDb250YWluZXIgfSBmcm9tIFwiY29yZS9hc3NldENvbnRhaW5lclwiO1xyXG5pbXBvcnQgdHlwZSB7IFNjZW5lIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB0eXBlIHsgQWJzdHJhY3RNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL2Fic3RyYWN0TWVzaFwiO1xyXG5pbXBvcnQgeyBNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL21lc2hcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNvcmUvTWlzYy9sb2dnZXJcIjtcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XHJcbmltcG9ydCB7IFBvaW50c0Nsb3VkU3lzdGVtIH0gZnJvbSBcImNvcmUvUGFydGljbGVzL3BvaW50c0Nsb3VkU3lzdGVtXCI7XHJcbmltcG9ydCB7IENvbG9yNCB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgVmVydGV4RGF0YSB9IGZyb20gXCJjb3JlL01lc2hlcy9tZXNoLnZlcnRleERhdGFcIjtcclxuaW1wb3J0IHR5cGUgeyBTUExBVExvYWRpbmdPcHRpb25zIH0gZnJvbSBcIi4vc3BsYXRMb2FkaW5nT3B0aW9uc1wiO1xyXG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnNjYWxhclwiO1xyXG5pbXBvcnQgdHlwZSB7IEdhdXNzaWFuU3BsYXR0aW5nTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvR2F1c3NpYW5TcGxhdHRpbmcvZ2F1c3NpYW5TcGxhdHRpbmdNYXRlcmlhbFwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCJjb3JlL0xvYWRpbmcvc2NlbmVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFNjZW5lTG9hZGVyUGx1Z2luT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgc3BsYXQgbG9hZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFtTUExBVEZpbGVMb2FkZXJNZXRhZGF0YS5uYW1lXTogUGFydGlhbDxTUExBVExvYWRpbmdPcHRpb25zPjtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGljYXRvciBvZiB0aGUgcGFyc2VkIHBseSBidWZmZXIuIEEgc3RhbmRhcmQgcmVhZHkgdG8gdXNlIHNwbGF0IG9yIGFuIGFycmF5IG9mIHBvc2l0aW9ucyBmb3IgYSBwb2ludCBjbG91ZFxyXG4gKi9cclxuY29uc3QgZW51bSBNb2RlIHtcclxuICAgIFNwbGF0ID0gMCxcclxuICAgIFBvaW50Q2xvdWQgPSAxLFxyXG4gICAgTWVzaCA9IDIsXHJcbiAgICBSZWplY3QgPSAzLFxyXG59XHJcblxyXG4vKipcclxuICogQSBwYXJzZWQgYnVmZmVyIGFuZCBob3cgdG8gdXNlIGl0XHJcbiAqL1xyXG5pbnRlcmZhY2UgSVBhcnNlZFBMWSB7XHJcbiAgICBkYXRhOiBBcnJheUJ1ZmZlcjtcclxuICAgIG1vZGU6IE1vZGU7XHJcbiAgICBmYWNlcz86IG51bWJlcltdO1xyXG4gICAgaGFzVmVydGV4Q29sb3JzPzogYm9vbGVhbjtcclxuICAgIHNoPzogVWludDhBcnJheVtdO1xyXG4gICAgdHJhaW5lZFdpdGhBbnRpYWxpYXNpbmc/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogQGV4cGVyaW1lbnRhbFxyXG4gKiBTUExBVCBmaWxlIHR5cGUgbG9hZGVyLlxyXG4gKiBUaGlzIGlzIGEgYmFieWxvbiBzY2VuZSBsb2FkZXIgcGx1Z2luLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNQTEFURmlsZUxvYWRlciBpbXBsZW1lbnRzIElTY2VuZUxvYWRlclBsdWdpbkFzeW5jLCBJU2NlbmVMb2FkZXJQbHVnaW5GYWN0b3J5IHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IFNQTEFURmlsZUxvYWRlck1ldGFkYXRhLm5hbWU7XHJcblxyXG4gICAgcHJpdmF0ZSBfYXNzZXRDb250YWluZXI6IE51bGxhYmxlPEFzc2V0Q29udGFpbmVyPiA9IG51bGw7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfbG9hZGluZ09wdGlvbnM6IFJlYWRvbmx5PFNQTEFUTG9hZGluZ09wdGlvbnM+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBleHRlbnNpb25zIHRoZSBzcGxhdCBsb2FkZXIgaXMgYWJsZSB0byBsb2FkLlxyXG4gICAgICogZm9yY2UgZGF0YSB0byBjb21lIGluIGFzIGFuIEFycmF5QnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBleHRlbnNpb25zID0gU1BMQVRGaWxlTG9hZGVyTWV0YWRhdGEuZXh0ZW5zaW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbG9hZGVyIGZvciBnYXVzc2lhbiBzcGxhdHRpbmcgZmlsZXNcclxuICAgICAqIEBwYXJhbSBsb2FkaW5nT3B0aW9ucyBvcHRpb25zIGZvciBsb2FkaW5nIGFuZCBwYXJzaW5nIHNwbGF0IGFuZCBQTFkgZmlsZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRpbmdPcHRpb25zOiBQYXJ0aWFsPFJlYWRvbmx5PFNQTEFUTG9hZGluZ09wdGlvbnM+PiA9IFNQTEFURmlsZUxvYWRlci5fRGVmYXVsdExvYWRpbmdPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ09wdGlvbnMgPSBsb2FkaW5nT3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBfRGVmYXVsdExvYWRpbmdPcHRpb25zID0ge1xyXG4gICAgICAgIGtlZXBJblJhbTogZmFsc2UsXHJcbiAgICAgICAgZmxpcFk6IGZhbHNlLFxyXG4gICAgfSBhcyBjb25zdCBzYXRpc2ZpZXMgU1BMQVRMb2FkaW5nT3B0aW9ucztcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjcmVhdGVQbHVnaW4ob3B0aW9uczogU2NlbmVMb2FkZXJQbHVnaW5PcHRpb25zKTogSVNjZW5lTG9hZGVyUGx1Z2luQXN5bmMge1xyXG4gICAgICAgIHJldHVybiBuZXcgU1BMQVRGaWxlTG9hZGVyKG9wdGlvbnNbU1BMQVRGaWxlTG9hZGVyTWV0YWRhdGEubmFtZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW1wb3J0cyAgZnJvbSB0aGUgbG9hZGVkIGdhdXNzaWFuIHNwbGF0dGluZyBkYXRhIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gbWVzaGVzTmFtZXMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBvZiB0aGUgbWVzaCBuYW1lcyB0aGF0IHNob3VsZCBiZSBsb2FkZWQgZnJvbSB0aGUgZmlsZVxyXG4gICAgICogQHBhcmFtIHNjZW5lIHRoZSBzY2VuZSB0aGUgbWVzaGVzIHNob3VsZCBiZSBhZGRlZCB0b1xyXG4gICAgICogQHBhcmFtIGRhdGEgdGhlIGdhdXNzaWFuIHNwbGF0dGluZyBkYXRhIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSByb290VXJsIHJvb3QgdXJsIHRvIGxvYWQgZnJvbVxyXG4gICAgICogQHBhcmFtIF9vblByb2dyZXNzIGNhbGxiYWNrIGNhbGxlZCB3aGlsZSBmaWxlIGlzIGxvYWRpbmdcclxuICAgICAqIEBwYXJhbSBfZmlsZU5hbWUgRGVmaW5lcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBsb2FkXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyB0aGUgbG9hZGVkIG1lc2hlcywgcGFydGljbGVzLCBza2VsZXRvbnMgYW5kIGFuaW1hdGlvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGltcG9ydE1lc2hBc3luYyhcclxuICAgICAgICBtZXNoZXNOYW1lczogYW55LFxyXG4gICAgICAgIHNjZW5lOiBTY2VuZSxcclxuICAgICAgICBkYXRhOiBhbnksXHJcbiAgICAgICAgcm9vdFVybDogc3RyaW5nLFxyXG4gICAgICAgIF9vblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLFxyXG4gICAgICAgIF9maWxlTmFtZT86IHN0cmluZ1xyXG4gICAgKTogUHJvbWlzZTxJU2NlbmVMb2FkZXJBc3luY1Jlc3VsdD4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wYXJzZUFzeW5jKG1lc2hlc05hbWVzLCBzY2VuZSwgZGF0YSwgcm9vdFVybCkudGhlbigobWVzaGVzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtZXNoZXM6IG1lc2hlcyxcclxuICAgICAgICAgICAgICAgIHBhcnRpY2xlU3lzdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uR3JvdXBzOiBbXSxcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgIGdlb21ldHJpZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgbGlnaHRzOiBbXSxcclxuICAgICAgICAgICAgICAgIHNwcml0ZU1hbmFnZXJzOiBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfQnVpbGRQb2ludENsb3VkKHBvaW50Y2xvdWQ6IFBvaW50c0Nsb3VkU3lzdGVtLCBkYXRhOiBBcnJheUJ1ZmZlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICghZGF0YS5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGZCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xyXG5cclxuICAgICAgICAvLyBwYXJzZWQgYXJyYXkgY29udGFpbnMgcm9vbSBmb3IgcG9zaXRpb24oM2Zsb2F0cyksIG5vcm1hbCgzZmxvYXRzKSwgY29sb3IgKDRiKSwgcXVhbnRpemVkIHF1YXRlcm5pb24gKDRiKVxyXG4gICAgICAgIGNvbnN0IHJvd0xlbmd0aCA9IDMgKiA0ICsgMyAqIDQgKyA0ICsgNDtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IHVCdWZmZXIubGVuZ3RoIC8gcm93TGVuZ3RoO1xyXG5cclxuICAgICAgICBjb25zdCBwb2ludGNsb3VkZnVuYyA9IGZ1bmN0aW9uIChwYXJ0aWNsZTogYW55LCBpOiBudW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGZCdWZmZXJbOCAqIGkgKyAwXTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IGZCdWZmZXJbOCAqIGkgKyAxXTtcclxuICAgICAgICAgICAgY29uc3QgeiA9IGZCdWZmZXJbOCAqIGkgKyAyXTtcclxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24gPSBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSB1QnVmZmVyW3Jvd0xlbmd0aCAqIGkgKyAyNCArIDBdIC8gMjU1O1xyXG4gICAgICAgICAgICBjb25zdCBnID0gdUJ1ZmZlcltyb3dMZW5ndGggKiBpICsgMjQgKyAxXSAvIDI1NTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IHVCdWZmZXJbcm93TGVuZ3RoICogaSArIDI0ICsgMl0gLyAyNTU7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlLmNvbG9yID0gbmV3IENvbG9yNChyLCBnLCBiLCAxKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwb2ludGNsb3VkLmFkZFBvaW50cyh2ZXJ0ZXhDb3VudCwgcG9pbnRjbG91ZGZ1bmMpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9CdWlsZE1lc2goc2NlbmU6IFNjZW5lLCBwYXJzZWRQTFk6IElQYXJzZWRQTFkpOiBNZXNoIHtcclxuICAgICAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goXCJQTFlNZXNoXCIsIHNjZW5lKTtcclxuXHJcbiAgICAgICAgY29uc3QgdUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHBhcnNlZFBMWS5kYXRhKTtcclxuICAgICAgICBjb25zdCBmQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShwYXJzZWRQTFkuZGF0YSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvd0xlbmd0aCA9IDMgKiA0ICsgMyAqIDQgKyA0ICsgNDtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IHVCdWZmZXIubGVuZ3RoIC8gcm93TGVuZ3RoO1xyXG5cclxuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4RGF0YSA9IG5ldyBWZXJ0ZXhEYXRhKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBmQnVmZmVyWzggKiBpICsgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBmQnVmZmVyWzggKiBpICsgMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHogPSBmQnVmZmVyWzggKiBpICsgMl07XHJcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZFBMWS5oYXNWZXJ0ZXhDb2xvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhDb3VudCAqIDQpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB1QnVmZmVyW3Jvd0xlbmd0aCAqIGkgKyAyNCArIDBdIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IHVCdWZmZXJbcm93TGVuZ3RoICogaSArIDI0ICsgMV0gLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gdUJ1ZmZlcltyb3dMZW5ndGggKiBpICsgMjQgKyAyXSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tpICogNCArIDBdID0gcjtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tpICogNCArIDFdID0gZztcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tpICogNCArIDJdID0gYjtcclxuICAgICAgICAgICAgICAgIGNvbG9yc1tpICogNCArIDNdID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhLmNvbG9ycyA9IGNvbG9ycztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZlcnRleERhdGEucG9zaXRpb25zID0gcG9zaXRpb25zO1xyXG4gICAgICAgIHZlcnRleERhdGEuaW5kaWNlcyA9IHBhcnNlZFBMWS5mYWNlcyE7XHJcblxyXG4gICAgICAgIHZlcnRleERhdGEuYXBwbHlUb01lc2gobWVzaCk7XHJcbiAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfcGFyc2VTUFpBc3luYyhkYXRhOiBBcnJheUJ1ZmZlciwgc2NlbmU6IFNjZW5lKTogUHJvbWlzZTxJUGFyc2VkUExZPiB7XHJcbiAgICAgICAgY29uc3QgdWJ1ZiA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHVidWZ1MzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5zbGljZSgwLCAxMikpOyAvLyBPbmx5IG5lZWQgdWJ1ZnUzMlswXSB0byBbMl1cclxuICAgICAgICAvLyBkZWJ1ZyBpbmZvc1xyXG4gICAgICAgIGNvbnN0IHNwbGF0Q291bnQgPSB1YnVmdTMyWzJdO1xyXG5cclxuICAgICAgICBjb25zdCBzaERlZ3JlZSA9IHVidWZbMTJdO1xyXG4gICAgICAgIGNvbnN0IGZyYWN0aW9uYWxCaXRzID0gdWJ1ZlsxM107XHJcbiAgICAgICAgY29uc3QgZmxhZ3MgPSB1YnVmWzE0XTtcclxuICAgICAgICBjb25zdCByZXNlcnZlZCA9IHVidWZbMTVdO1xyXG5cclxuICAgICAgICAvLyBjaGVjayBtYWdpYyBhbmQgdmVyc2lvblxyXG4gICAgICAgIGlmIChyZXNlcnZlZCB8fCB1YnVmdTMyWzBdICE9IDB4NTA1MzQ3NGUgfHwgdWJ1ZnUzMlsxXSAhPSAyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2VydmVkIG11c3QgYmUgMFxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBtb2RlOiBNb2RlLlJlamVjdCwgZGF0YTogYnVmZmVyLCBoYXNWZXJ0ZXhDb2xvcnM6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJvd091dHB1dExlbmd0aCA9IDMgKiA0ICsgMyAqIDQgKyA0ICsgNDsgLy8gMzJcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIocm93T3V0cHV0TGVuZ3RoICogc3BsYXRDb3VudCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uU2NhbGUgPSAxLjAgLyAoMSA8PCBmcmFjdGlvbmFsQml0cyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGludDMyVmlldyA9IG5ldyBJbnQzMkFycmF5KDEpO1xyXG4gICAgICAgIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGludDMyVmlldy5idWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IHJlYWQyNGJDb21wb25lbnQgPSBmdW5jdGlvbiAodTg6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHVpbnQ4Vmlld1swXSA9IHU4W29mZnNldCArIDBdO1xyXG4gICAgICAgICAgICB1aW50OFZpZXdbMV0gPSB1OFtvZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgdWludDhWaWV3WzJdID0gdThbb2Zmc2V0ICsgMl07XHJcbiAgICAgICAgICAgIHVpbnQ4Vmlld1szXSA9IHU4W29mZnNldCArIDJdICYgMHg4MCA/IDB4ZmYgOiAweDAwO1xyXG4gICAgICAgICAgICByZXR1cm4gaW50MzJWaWV3WzBdICogcG9zaXRpb25TY2FsZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IDE2O1xyXG5cclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCByZ2JhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3Qgcm90ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGJ1ZmZlcik7XHJcblxyXG4gICAgICAgIGxldCBjb29yZGluYXRlU2lnbiA9IDE7XHJcbiAgICAgICAgbGV0IHF1YXRlcm5pb25PZmZzZXQgPSAwO1xyXG4gICAgICAgIGlmICghdGhpcy5fbG9hZGluZ09wdGlvbnMuZmxpcFkpIHtcclxuICAgICAgICAgICAgY29vcmRpbmF0ZVNpZ24gPSAtMTtcclxuICAgICAgICAgICAgcXVhdGVybmlvbk9mZnNldCA9IDI1NTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcG9zaXRpb25zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxhdENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgcG9zaXRpb25baSAqIDggKyAwXSA9IHJlYWQyNGJDb21wb25lbnQodWJ1ZiwgYnl0ZU9mZnNldCArIDApO1xyXG4gICAgICAgICAgICBwb3NpdGlvbltpICogOCArIDFdID0gY29vcmRpbmF0ZVNpZ24gKiByZWFkMjRiQ29tcG9uZW50KHVidWYsIGJ5dGVPZmZzZXQgKyAzKTtcclxuICAgICAgICAgICAgcG9zaXRpb25baSAqIDggKyAyXSA9IGNvb3JkaW5hdGVTaWduICogcmVhZDI0YkNvbXBvbmVudCh1YnVmLCBieXRlT2Zmc2V0ICsgNik7XHJcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gOTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbG9yc1xyXG4gICAgICAgIGNvbnN0IHNoQzAgPSAwLjI4MjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGF0Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb21wb25lbnQgPSAwOyBjb21wb25lbnQgPCAzOyBjb21wb25lbnQrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZVZhbHVlID0gdWJ1ZltieXRlT2Zmc2V0ICsgc3BsYXRDb3VudCArIGkgKiAzICsgY29tcG9uZW50XTtcclxuICAgICAgICAgICAgICAgIC8vIDAuMTUgaXMgaGFyZCBjb2RlZCB2YWx1ZSBmcm9tIHNwelxyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgZmFjdG9yIGZvciBEQyBjb2xvciBjb21wb25lbnRzLiBUbyBjb252ZXJ0IHRvIFJHQiwgd2Ugc2hvdWxkIG11bHRpcGx5IGJ5IDAuMjgyLCBidXQgaXQgY2FuXHJcbiAgICAgICAgICAgICAgICAvLyBiZSB1c2VmdWwgdG8gcmVwcmVzZW50IGJhc2UgY29sb3JzIHRoYXQgYXJlIG91dCBvZiByYW5nZSBpZiB0aGUgaGlnaGVyIHNwaGVyaWNhbCBoYXJtb25pY3MgYmFuZHNcclxuICAgICAgICAgICAgICAgIC8vIGJyaW5nIHRoZW0gYmFjayBpbnRvIHJhbmdlIHNvIHdlIG11bHRpcGx5IGJ5IGEgc21hbGxlciB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGJ5dGVWYWx1ZSAtIDEyNy41KSAvICgwLjE1ICogMjU1KTtcclxuICAgICAgICAgICAgICAgIHJnYmFbaSAqIDMyICsgMjQgKyBjb21wb25lbnRdID0gU2NhbGFyLkNsYW1wKCgwLjUgKyBzaEMwICogdmFsdWUpICogMjU1LCAwLCAyNTUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZ2JhW2kgKiAzMiArIDI0ICsgM10gPSB1YnVmW2J5dGVPZmZzZXQgKyBpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnl0ZU9mZnNldCArPSBzcGxhdENvdW50ICogNDtcclxuXHJcbiAgICAgICAgLy8gc2NhbGVzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxhdENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgc2NhbGVbaSAqIDggKyAzICsgMF0gPSBNYXRoLmV4cCh1YnVmW2J5dGVPZmZzZXQgKyAwXSAvIDE2LjAgLSAxMC4wKTtcclxuICAgICAgICAgICAgc2NhbGVbaSAqIDggKyAzICsgMV0gPSBNYXRoLmV4cCh1YnVmW2J5dGVPZmZzZXQgKyAxXSAvIDE2LjAgLSAxMC4wKTtcclxuICAgICAgICAgICAgc2NhbGVbaSAqIDggKyAzICsgMl0gPSBNYXRoLmV4cCh1YnVmW2J5dGVPZmZzZXQgKyAyXSAvIDE2LjAgLSAxMC4wKTtcclxuICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29udmVydCBxdWF0ZXJuaW9uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxhdENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IHVidWZbYnl0ZU9mZnNldCArIDBdO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gdWJ1ZltieXRlT2Zmc2V0ICsgMV0gKiBjb29yZGluYXRlU2lnbiArIHF1YXRlcm5pb25PZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHogPSB1YnVmW2J5dGVPZmZzZXQgKyAyXSAqIGNvb3JkaW5hdGVTaWduICsgcXVhdGVybmlvbk9mZnNldDtcclxuICAgICAgICAgICAgY29uc3QgbnggPSB4IC8gMTI3LjUgLSAxO1xyXG4gICAgICAgICAgICBjb25zdCBueSA9IHkgLyAxMjcuNSAtIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IG56ID0geiAvIDEyNy41IC0gMTtcclxuICAgICAgICAgICAgcm90W2kgKiAzMiArIDI4ICsgMV0gPSB4O1xyXG4gICAgICAgICAgICByb3RbaSAqIDMyICsgMjggKyAyXSA9IHk7XHJcbiAgICAgICAgICAgIHJvdFtpICogMzIgKyAyOCArIDNdID0gejtcclxuICAgICAgICAgICAgY29uc3QgdiA9IDEgLSAobnggKiBueCArIG55ICogbnkgKyBueiAqIG56KTtcclxuICAgICAgICAgICAgcm90W2kgKiAzMiArIDI4ICsgMF0gPSAxMjcuNSArIE1hdGguc3FydCh2IDwgMCA/IDAgOiB2KSAqIDEyNy41O1xyXG5cclxuICAgICAgICAgICAgYnl0ZU9mZnNldCArPSAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TSFxyXG4gICAgICAgIGlmIChzaERlZ3JlZSkge1xyXG4gICAgICAgICAgICAvLyBzaFZlY3RvckNvdW50IGlzIDogMyBmb3IgZGltID0gMSwgOCBmb3IgZGltID0gMiBhbmQgMTUgZm9yIGRpbSA9IDNcclxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHZlYzMgdmVjdG9yIG5lZWRlZCBwZXIgc3BsYXRcclxuICAgICAgICAgICAgY29uc3Qgc2hWZWN0b3JDb3VudCA9IChzaERlZ3JlZSArIDEpICogKHNoRGVncmVlICsgMSkgLSAxOyAvLyBtaW51cyAxIGJlY2F1c2Ugc2gwIGlzIGNvbG9yXHJcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBjb21wb25lbnQgdmFsdWVzIDogMyBwZXIgdmVjdG9yMyAoNDUpXHJcbiAgICAgICAgICAgIGNvbnN0IHNoQ29tcG9uZW50Q291bnQgPSBzaFZlY3RvckNvdW50ICogMztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVDb3VudCA9IE1hdGguY2VpbChzaENvbXBvbmVudENvdW50IC8gMTYpOyAvLyA0IGNvbXBvbmVudHMgY2FuIGJlIHN0b3JlZCBwZXIgdGV4dHVyZSwgNCBzaCBwZXIgY29tcG9uZW50XHJcbiAgICAgICAgICAgIGxldCBzaEluZGV4UmVhZCA9IGJ5dGVPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBzaCBpcyBhbiBhcnJheSBvZiB1aW50OGFycmF5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBzaCB0ZXh0dXJlc1xyXG4gICAgICAgICAgICBjb25zdCBzaDogVWludDhBcnJheVtdID0gW107XHJcblxyXG4gICAgICAgICAgICBjb25zdCBlbmdpbmUgPSBzY2VuZS5nZXRFbmdpbmUoKTtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBlbmdpbmUuZ2V0Q2FwcygpLm1heFRleHR1cmVTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoc3BsYXRDb3VudCAvIHdpZHRoKTtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGFycmF5IGZvciB0aGUgbnVtYmVyIG9mIHRleHR1cmVzIG5lZWRlZC5cclxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dHVyZUluZGV4ID0gMDsgdGV4dHVyZUluZGV4IDwgdGV4dHVyZUNvdW50OyB0ZXh0dXJlSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBVaW50OEFycmF5KGhlaWdodCAqIHdpZHRoICogNCAqIDQpOyAvLyA0IGNvbXBvbmVudHMgcGVyIHRleHR1cmUsIDQgc2ggcGVyIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgc2gucHVzaCh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxhdENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNoSW5kZXhXcml0ZSA9IDA7IHNoSW5kZXhXcml0ZSA8IHNoQ29tcG9uZW50Q291bnQ7IHNoSW5kZXhXcml0ZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hWYWx1ZSA9IHVidWZbc2hJbmRleFJlYWQrK107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVJbmRleCA9IE1hdGguZmxvb3Ioc2hJbmRleFdyaXRlIC8gMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoQXJyYXkgPSBzaFt0ZXh0dXJlSW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlSW5kZXhJblRleHR1cmUgPSBzaEluZGV4V3JpdGUgJSAxNjsgLy8gWzAuLjE1XVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFBlclNwbGF0ID0gaSAqIDE2OyAvLyAxNiBzaCB2YWx1ZXMgcGVyIHRleHR1cmUgcGVyIHNwbGF0LlxyXG4gICAgICAgICAgICAgICAgICAgIHNoQXJyYXlbYnl0ZUluZGV4SW5UZXh0dXJlICsgb2Zmc2V0UGVyU3BsYXRdID0gc2hWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgbW9kZTogTW9kZS5TcGxhdCwgZGF0YTogYnVmZmVyLCBoYXNWZXJ0ZXhDb2xvcnM6IGZhbHNlLCBzaDogc2gsIHRyYWluZWRXaXRoQW50aWFsaWFzaW5nOiAhIWZsYWdzIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKHsgbW9kZTogTW9kZS5TcGxhdCwgZGF0YTogYnVmZmVyLCBoYXNWZXJ0ZXhDb2xvcnM6IGZhbHNlLCB0cmFpbmVkV2l0aEFudGlhbGlhc2luZzogISFmbGFncyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9wYXJzZUFzeW5jKG1lc2hlc05hbWVzOiBhbnksIHNjZW5lOiBTY2VuZSwgZGF0YTogYW55LCBfcm9vdFVybDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxBYnN0cmFjdE1lc2g+PiB7XHJcbiAgICAgICAgY29uc3QgYmFieWxvbk1lc2hlc0FycmF5OiBBcnJheTxNZXNoPiA9IFtdOyAvL1RoZSBtZXNoIGZvciBiYWJ5bG9uXHJcblxyXG4gICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcclxuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGRhdGEpKTsgLy8gRW5xdWV1ZSB0aGUgQXJyYXlCdWZmZXIgYXMgYSBVaW50OEFycmF5XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFVzZSBHWmlwIERlY29tcHJlc3Npb25TdHJlYW1cclxuICAgICAgICBjb25zdCBkZWNvbXByZXNzaW9uU3RyZWFtID0gbmV3IERlY29tcHJlc3Npb25TdHJlYW0oXCJnemlwXCIpO1xyXG4gICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZFN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtLnBpcGVUaHJvdWdoKGRlY29tcHJlc3Npb25TdHJlYW0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgbmV3IFJlc3BvbnNlKGRlY29tcHJlc3NlZFN0cmVhbSlcclxuICAgICAgICAgICAgICAgIC5hcnJheUJ1ZmZlcigpXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgICAgIC50aGVuKChidWZmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzLCBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU1BaQXN5bmMoYnVmZmVyLCBzY2VuZSkudGhlbigocGFyc2VkU1BaKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIXRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXVzc2lhblNwbGF0dGluZyA9IG5ldyBHYXVzc2lhblNwbGF0dGluZ01lc2goXCJHYXVzc2lhblNwbGF0dGluZ1wiLCBudWxsLCBzY2VuZSwgdGhpcy5fbG9hZGluZ09wdGlvbnMua2VlcEluUmFtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFNQWi50cmFpbmVkV2l0aEFudGlhbGlhc2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3NNYXRlcmlhbCA9IGdhdXNzaWFuU3BsYXR0aW5nLm1hdGVyaWFsIGFzIEdhdXNzaWFuU3BsYXR0aW5nTWF0ZXJpYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnc01hdGVyaWFsLmtlcm5lbFNpemUgPSAwLjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnc01hdGVyaWFsLmNvbXBlbnNhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2F1c3NpYW5TcGxhdHRpbmcuX3BhcmVudENvbnRhaW5lciA9IHRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaGVzQXJyYXkucHVzaChnYXVzc2lhblNwbGF0dGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhdXNzaWFuU3BsYXR0aW5nLnVwZGF0ZURhdGEocGFyc2VkU1BaLmRhdGEsIHBhcnNlZFNQWi5zaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShiYWJ5bG9uTWVzaGVzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCBhbnkgZGVjb21wcmVzc2lvbiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzLCBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgICAgIFNQTEFURmlsZUxvYWRlci5fQ29udmVydFBMWVRvU3BsYXQoZGF0YSBhcyBBcnJheUJ1ZmZlcikudGhlbihhc3luYyAocGFyc2VkUExZKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIXRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnNlZFBMWS5tb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuU3BsYXQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXVzc2lhblNwbGF0dGluZyA9IG5ldyBHYXVzc2lhblNwbGF0dGluZ01lc2goXCJHYXVzc2lhblNwbGF0dGluZ1wiLCBudWxsLCBzY2VuZSwgdGhpcy5fbG9hZGluZ09wdGlvbnMua2VlcEluUmFtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2F1c3NpYW5TcGxhdHRpbmcuX3BhcmVudENvbnRhaW5lciA9IHRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaGVzQXJyYXkucHVzaChnYXVzc2lhblNwbGF0dGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhdXNzaWFuU3BsYXR0aW5nLnVwZGF0ZURhdGEocGFyc2VkUExZLmRhdGEsIHBhcnNlZFBMWS5zaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLlBvaW50Q2xvdWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGNsb3VkID0gbmV3IFBvaW50c0Nsb3VkU3lzdGVtKFwiUG9pbnRDbG91ZFwiLCAxLCBzY2VuZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTUExBVEZpbGVMb2FkZXIuX0J1aWxkUG9pbnRDbG91ZChwb2ludGNsb3VkLCBwYXJzZWRQTFkuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcG9pbnRjbG91ZC5idWlsZE1lc2hBc3luYygpLnRoZW4oKG1lc2gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaGVzQXJyYXkucHVzaChtZXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRjbG91ZC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuTWVzaDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRQTFkuZmFjZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoZXNBcnJheS5wdXNoKFNQTEFURmlsZUxvYWRlci5fQnVpbGRNZXNoKHNjZW5lLCBwYXJzZWRQTFkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBMWSBtZXNoIGRvZXNuJ3QgY29udGFpbiBmYWNlIGluZm9ybWF0aW9ucy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFNwbGF0IG1vZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJhYnlsb25NZXNoZXNBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgaW50byBhbiBhc3NldCBjb250YWluZXIuXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGxvYWQgaW50b1xyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gaW1wb3J0XHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBUaGUgcm9vdCB1cmwgZm9yIHNjZW5lIGFuZCByZXNvdXJjZXNcclxuICAgICAqIEByZXR1cm5zIFRoZSBsb2FkZWQgYXNzZXQgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRBc3NldENvbnRhaW5lckFzeW5jKHNjZW5lOiBTY2VuZSwgZGF0YTogc3RyaW5nLCByb290VXJsOiBzdHJpbmcpOiBQcm9taXNlPEFzc2V0Q29udGFpbmVyPiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3IEFzc2V0Q29udGFpbmVyKHNjZW5lKTtcclxuICAgICAgICB0aGlzLl9hc3NldENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pbXBvcnRNZXNoQXN5bmMobnVsbCwgc2NlbmUsIGRhdGEsIHJvb3RVcmwpXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgcmVzdWx0Lm1lc2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIubWVzaGVzLnB1c2gobWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lc2ggbWF0ZXJpYWwgd2lsbCBiZSBudWxsIGJlZm9yZSAxc3QgcmVuZGVyZWQgZnJhbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXNzZXRDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXNzZXRDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW1wb3J0cyBhbGwgb2JqZWN0cyBmcm9tIHRoZSBsb2FkZWQgT0JKIGRhdGEgYW5kIGFkZHMgdGhlbSB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBzY2VuZSB0aGUgc2NlbmUgdGhlIG9iamVjdHMgc2hvdWxkIGJlIGFkZGVkIHRvXHJcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgT0JKIGRhdGEgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgcm9vdCB1cmwgdG8gbG9hZCBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggY29tcGxldGVzIHdoZW4gb2JqZWN0cyBoYXZlIGJlZW4gbG9hZGVkIHRvIHRoZSBzY2VuZVxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZEFzeW5jKHNjZW5lOiBTY2VuZSwgZGF0YTogc3RyaW5nLCByb290VXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvL0dldCB0aGUgM0QgbW9kZWxcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRNZXNoQXN5bmMobnVsbCwgc2NlbmUsIGRhdGEsIHJvb3RVcmwpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gdm9pZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29kZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9keWxhbmViZXJ0L2dzcGxhdC5qcy9ibG9iL21haW4vc3JjL2xvYWRlcnMvUExZTG9hZGVyLnRzIFVuZGVyIE1JVCBsaWNlbnNlXHJcbiAgICAgKiBDb252ZXJ0cyBhIC5wbHkgZGF0YSBhcnJheSBidWZmZXIgdG8gc3BsYXRcclxuICAgICAqIGlmIGRhdGEgYXJyYXkgYnVmZmVyIGlzIG5vdCBwbHksIHJldHVybnMgdGhlIG9yaWdpbmFsIGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIGRhdGEgdGhlIC5wbHkgZGF0YSB0byBsb2FkXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbG9hZGVkIHNwbGF0IGJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfQ29udmVydFBMWVRvU3BsYXQoZGF0YTogQXJyYXlCdWZmZXIpOiBQcm9taXNlPElQYXJzZWRQTFk+IHtcclxuICAgICAgICBjb25zdCB1YnVmID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVidWYuc2xpY2UoMCwgMTAyNCAqIDEwKSk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyRW5kID0gXCJlbmRfaGVhZGVyXFxuXCI7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyRW5kSW5kZXggPSBoZWFkZXIuaW5kZXhPZihoZWFkZXJFbmQpO1xyXG4gICAgICAgIGlmIChoZWFkZXJFbmRJbmRleCA8IDAgfHwgIWhlYWRlcikge1xyXG4gICAgICAgICAgICAvLyBzdGFuZGFyZCBzcGxhdFxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBtb2RlOiBNb2RlLlNwbGF0LCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvdW50ID0gcGFyc2VJbnQoL2VsZW1lbnQgdmVydGV4IChcXGQrKVxcbi8uZXhlYyhoZWFkZXIpIVsxXSk7XHJcbiAgICAgICAgY29uc3QgZmFjZUVsZW1lbnQgPSAvZWxlbWVudCBmYWNlIChcXGQrKVxcbi8uZXhlYyhoZWFkZXIpO1xyXG4gICAgICAgIGxldCBmYWNlQ291bnQgPSAwO1xyXG4gICAgICAgIGlmIChmYWNlRWxlbWVudCkge1xyXG4gICAgICAgICAgICBmYWNlQ291bnQgPSBwYXJzZUludChmYWNlRWxlbWVudFsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNodW5rRWxlbWVudCA9IC9lbGVtZW50IGNodW5rIChcXGQrKVxcbi8uZXhlYyhoZWFkZXIpO1xyXG4gICAgICAgIGxldCBjaHVua0NvdW50ID0gMDtcclxuICAgICAgICBpZiAoY2h1bmtFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNodW5rQ291bnQgPSBwYXJzZUludChjaHVua0VsZW1lbnRbMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJvd1ZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHJvd0NodW5rT2Zmc2V0ID0gMDtcclxuICAgICAgICBjb25zdCBvZmZzZXRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xyXG4gICAgICAgICAgICBkb3VibGU6IDgsXHJcbiAgICAgICAgICAgIGludDogNCxcclxuICAgICAgICAgICAgdWludDogNCxcclxuICAgICAgICAgICAgZmxvYXQ6IDQsXHJcbiAgICAgICAgICAgIHNob3J0OiAyLFxyXG4gICAgICAgICAgICB1c2hvcnQ6IDIsXHJcbiAgICAgICAgICAgIHVjaGFyOiAxLFxyXG4gICAgICAgICAgICBsaXN0OiAwLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHR5cGUgUGx5UHJvcGVydHkgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgICAgICAgdHlwZTogc3RyaW5nO1xyXG4gICAgICAgICAgICBvZmZzZXQ6IG51bWJlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBlbnVtIEVsZW1lbnRNb2RlIHtcclxuICAgICAgICAgICAgVmVydGV4ID0gMCxcclxuICAgICAgICAgICAgQ2h1bmsgPSAxLFxyXG4gICAgICAgICAgICBTSCA9IDIsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY2h1bmtNb2RlID0gRWxlbWVudE1vZGUuQ2h1bms7XHJcbiAgICAgICAgY29uc3QgdmVydGV4UHJvcGVydGllczogUGx5UHJvcGVydHlbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNodW5rUHJvcGVydGllczogUGx5UHJvcGVydHlbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gaGVhZGVyLnNsaWNlKDAsIGhlYWRlckVuZEluZGV4KS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgZmlsdGVyZWQpIHtcclxuICAgICAgICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aChcInByb3BlcnR5IFwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgWywgdHlwZSwgbmFtZV0gPSBwcm9wLnNwbGl0KFwiIFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtNb2RlID09IEVsZW1lbnRNb2RlLkNodW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQcm9wZXJ0aWVzLnB1c2goeyBuYW1lLCB0eXBlLCBvZmZzZXQ6IHJvd0NodW5rT2Zmc2V0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd0NodW5rT2Zmc2V0ICs9IG9mZnNldHNbdHlwZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNodW5rTW9kZSA9PSBFbGVtZW50TW9kZS5WZXJ0ZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhQcm9wZXJ0aWVzLnB1c2goeyBuYW1lLCB0eXBlLCBvZmZzZXQ6IHJvd1ZlcnRleE9mZnNldCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByb3dWZXJ0ZXhPZmZzZXQgKz0gb2Zmc2V0c1t0eXBlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2h1bmtNb2RlID09IEVsZW1lbnRNb2RlLlNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4UHJvcGVydGllcy5wdXNoKHsgbmFtZSwgdHlwZSwgb2Zmc2V0OiByb3dWZXJ0ZXhPZmZzZXQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9mZnNldHNbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihgVW5zdXBwb3J0ZWQgcHJvcGVydHkgdHlwZTogJHt0eXBlfS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wLnN0YXJ0c1dpdGgoXCJlbGVtZW50IFwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgWywgdHlwZV0gPSBwcm9wLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwiY2h1bmtcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rTW9kZSA9IEVsZW1lbnRNb2RlLkNodW5rO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwidmVydGV4XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaHVua01vZGUgPSBFbGVtZW50TW9kZS5WZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJzaFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtNb2RlID0gRWxlbWVudE1vZGUuU0g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJvd1ZlcnRleExlbmd0aCA9IHJvd1ZlcnRleE9mZnNldDtcclxuICAgICAgICBjb25zdCByb3dDaHVua0xlbmd0aCA9IHJvd0NodW5rT2Zmc2V0O1xyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICByZXR1cm4gKEdhdXNzaWFuU3BsYXR0aW5nTWVzaC5Db252ZXJ0UExZV2l0aFNIVG9TcGxhdEFzeW5jKGRhdGEpIGFzIGFueSkudGhlbihhc3luYyAoc3BsYXRzRGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIGhlYWRlckVuZEluZGV4ICsgaGVhZGVyRW5kLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByb3dDaHVua0xlbmd0aCAqIGNodW5rQ291bnQgKyByb3dWZXJ0ZXhMZW5ndGggKiB2ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgLy8gZmFjZXNcclxuICAgICAgICAgICAgY29uc3QgZmFjZXM6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgICAgIGlmIChmYWNlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFjZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWNlVmVydGV4Q291bnQgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWNlVmVydGV4Q291bnQgIT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gb25seSBzdXBwb3J0IHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlVmVydGV4Q291bnQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0ZXhJbmRleCA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgKyAoMiAtIGopICogNCwgdHJ1ZSk7IC8vIGNoYW5nZSBmYWNlIHdpbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaCh2ZXJ0ZXhJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAxMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZWFybHkgZXhpdCBmb3IgY2h1bmtlZC9xdWFudGl6ZWQgcGx5XHJcbiAgICAgICAgICAgIGlmIChjaHVua0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgbW9kZTogTW9kZS5TcGxhdCwgZGF0YTogc3BsYXRzRGF0YS5idWZmZXIsIHNoOiBzcGxhdHNEYXRhLnNoLCBmYWNlczogZmFjZXMsIGhhc1ZlcnRleENvbG9yczogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb3VudCBhdmFpbGFibGUgcHJvcGVydGllcy4gaWYgYWxsIG5lY2Vzc2FyeSBhcmUgcHJlc2VudCB0aGVuIGl0J3MgYSBzcGxhdC4gT3RoZXJ3aXNlLCBpdCdzIGEgcG9pbnQgY2xvdWRcclxuICAgICAgICAgICAgLy8gaWYgZmFjZXMgYXJlIGZvdW5kLCB0aGVuIGl0J3MgYSBzdGFuZGFyZCBtZXNoXHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eUNvdW50ID0gMDtcclxuICAgICAgICAgICAgbGV0IHByb3BlcnR5Q29sb3JDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwbGF0UHJvcGVydGllcyA9IFtcInhcIiwgXCJ5XCIsIFwielwiLCBcInNjYWxlXzBcIiwgXCJzY2FsZV8xXCIsIFwic2NhbGVfMlwiLCBcIm9wYWNpdHlcIiwgXCJyb3RfMFwiLCBcInJvdF8xXCIsIFwicm90XzJcIiwgXCJyb3RfM1wiXTtcclxuICAgICAgICAgICAgY29uc3Qgc3BsYXRDb2xvclByb3BlcnRpZXMgPSBbXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIiwgXCJmX2RjXzBcIiwgXCJmX2RjXzFcIiwgXCJmX2RjXzJcIl07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5SW5kZXggPSAwOyBwcm9wZXJ0eUluZGV4IDwgdmVydGV4UHJvcGVydGllcy5sZW5ndGg7IHByb3BlcnR5SW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSB2ZXJ0ZXhQcm9wZXJ0aWVzW3Byb3BlcnR5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwbGF0UHJvcGVydGllcy5pbmNsdWRlcyhwcm9wZXJ0eS5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzcGxhdENvbG9yUHJvcGVydGllcy5pbmNsdWRlcyhwcm9wZXJ0eS5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q29sb3JDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc01hbmRhdG9yeVByb3BlcnRpZXMgPSBwcm9wZXJ0eUNvdW50ID09IHNwbGF0UHJvcGVydGllcy5sZW5ndGggJiYgcHJvcGVydHlDb2xvckNvdW50ID09IDM7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gZmFjZUNvdW50ID8gTW9kZS5NZXNoIDogaGFzTWFuZGF0b3J5UHJvcGVydGllcyA/IE1vZGUuU3BsYXQgOiBNb2RlLlBvaW50Q2xvdWQ7XHJcbiAgICAgICAgICAgIC8vIHBhcnNlZCByZWFkeSByZWFkeSB0byBiZSB1c2VkIGFzIGEgc3BsYXRcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgbW9kZTogY3VycmVudE1vZGUsIGRhdGE6IHNwbGF0c0RhdGEuYnVmZmVyLCBzaDogc3BsYXRzRGF0YS5zaCwgZmFjZXM6IGZhY2VzLCBoYXNWZXJ0ZXhDb2xvcnM6ICEhcHJvcGVydHlDb2xvckNvdW50IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gQWRkIHRoaXMgbG9hZGVyIGludG8gdGhlIHJlZ2lzdGVyIHBsdWdpblxyXG5SZWdpc3RlclNjZW5lTG9hZGVyUGx1Z2luKG5ldyBTUExBVEZpbGVMb2FkZXIoKSk7XHJcbiIsIi8qKlxyXG4gKiBPcHRpb25zIGZvciBsb2FkaW5nIEdhdXNzaWFuIFNwbGF0dGluZyBhbmQgUExZIGZpbGVzXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTUExBVExvYWRpbmdPcHRpb25zID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIGJ1ZmZlcnMgc2hvdWxkIGJlIGtlcHQgaW4gbWVtb3J5IGZvciBlZGl0aW5nIHB1cnBvc2VzXHJcbiAgICAgKi9cclxuICAgIGtlZXBJblJhbT86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNwYXRpYWwgWSBGbGlwIGZvciBzcGxhdCBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgZmxpcFk/OiBib29sZWFuO1xyXG59O1xyXG4iLCJleHBvcnQgKiBmcm9tIFwiLi9zdGxGaWxlTG9hZGVyXCI7XHJcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8taW50ZXJuYWwtbW9kdWxlc1xyXG5pbXBvcnQgdHlwZSB7IElTY2VuZUxvYWRlclBsdWdpbkV4dGVuc2lvbnMsIElTY2VuZUxvYWRlclBsdWdpbk1ldGFkYXRhIH0gZnJvbSBcImNvcmUvaW5kZXhcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBTVExGaWxlTG9hZGVyTWV0YWRhdGEgPSB7XHJcbiAgICBuYW1lOiBcInN0bFwiLFxyXG5cclxuICAgIGV4dGVuc2lvbnM6IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICAgICAgXCIuc3RsXCI6IHsgaXNCaW5hcnk6IHRydWUgfSxcclxuICAgIH0gYXMgY29uc3Qgc2F0aXNmaWVzIElTY2VuZUxvYWRlclBsdWdpbkV4dGVuc2lvbnMsXHJcbn0gYXMgY29uc3Qgc2F0aXNmaWVzIElTY2VuZUxvYWRlclBsdWdpbk1ldGFkYXRhO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5pbXBvcnQgeyBWZXJ0ZXhCdWZmZXIgfSBmcm9tIFwiY29yZS9CdWZmZXJzL2J1ZmZlclwiO1xyXG5pbXBvcnQgdHlwZSB7IEFic3RyYWN0TWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9hYnN0cmFjdE1lc2hcIjtcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9tZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgSVNjZW5lTG9hZGVyUGx1Z2luIH0gZnJvbSBcImNvcmUvTG9hZGluZy9zY2VuZUxvYWRlclwiO1xyXG5pbXBvcnQgeyBSZWdpc3RlclNjZW5lTG9hZGVyUGx1Z2luIH0gZnJvbSBcImNvcmUvTG9hZGluZy9zY2VuZUxvYWRlclwiO1xyXG5pbXBvcnQgeyBBc3NldENvbnRhaW5lciB9IGZyb20gXCJjb3JlL2Fzc2V0Q29udGFpbmVyXCI7XHJcbmltcG9ydCB0eXBlIHsgU2NlbmUgfSBmcm9tIFwiY29yZS9zY2VuZVwiO1xyXG5pbXBvcnQgeyBTVExGaWxlTG9hZGVyTWV0YWRhdGEgfSBmcm9tIFwiLi9zdGxGaWxlTG9hZGVyLm1ldGFkYXRhXCI7XHJcbmltcG9ydCBcImNvcmUvTWF0ZXJpYWxzL3N0YW5kYXJkTWF0ZXJpYWxcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiY29yZS9Mb2FkaW5nL3NjZW5lTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2NlbmVMb2FkZXJQbHVnaW5PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBzdGwgbG9hZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFtTVExGaWxlTG9hZGVyTWV0YWRhdGEubmFtZV06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU1RMIGZpbGUgdHlwZSBsb2FkZXIuXHJcbiAqIFRoaXMgaXMgYSBiYWJ5bG9uIHNjZW5lIGxvYWRlciBwbHVnaW4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU1RMRmlsZUxvYWRlciBpbXBsZW1lbnRzIElTY2VuZUxvYWRlclBsdWdpbiB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgc29saWRQYXR0ZXJuID0gL3NvbGlkIChcXFMqKShbXFxTXFxzXSo/KWVuZHNvbGlkWyBdKihcXFMqKS9nO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBmYWNldHNQYXR0ZXJuID0gL2ZhY2V0KFtcXHNcXFNdKj8pZW5kZmFjZXQvZztcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBub3JtYWxQYXR0ZXJuID0gL25vcm1hbFtcXHNdKyhbLStdP1swLTldK1xcLj9bMC05XSooW2VFXVstK10/WzAtOV0rKT8pK1tcXHNdKyhbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT8pK1tcXHNdKyhbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT8pKy9nO1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIHZlcnRleFBhdHRlcm4gPSAvdmVydGV4W1xcc10rKFstK10/WzAtOV0rXFwuP1swLTldKihbZUVdWy0rXT9bMC05XSspPykrW1xcc10rKFstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspPykrW1xcc10rKFstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspPykrL2c7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gU1RMRmlsZUxvYWRlck1ldGFkYXRhLm5hbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBleHRlbnNpb25zIHRoZSBzdGwgbG9hZGVyIGlzIGFibGUgdG8gbG9hZC5cclxuICAgICAqIGZvcmNlIGRhdGEgdG8gY29tZSBpbiBhcyBhbiBBcnJheUJ1ZmZlclxyXG4gICAgICogd2UnbGwgY29udmVydCB0byBzdHJpbmcgaWYgaXQgbG9va3MgbGlrZSBpdCdzIGFuIEFTQ0lJIC5zdGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGV4dGVuc2lvbnMgPSBTVExGaWxlTG9hZGVyTWV0YWRhdGEuZXh0ZW5zaW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgWSBhbmQgWiBheGVzIGFyZSBzd2FwcGVkIG9yIG5vdCB3aGVuIGxvYWRpbmcgYW4gU1RMIGZpbGUuXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBmYWxzZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBXaGVuIHNldCB0b1xyXG4gICAgICogdHJ1ZSwgY29vcmRpbmF0ZXMgZnJvbSB0aGUgU1RMIGZpbGUgYXJlIHVzZWQgd2l0aG91dCBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRE9fTk9UX0FMVEVSX0ZJTEVfQ09PUkRJTkFURVMgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEltcG9ydCBtZXNoZXMgaW50byBhIHNjZW5lLlxyXG4gICAgICogQHBhcmFtIG1lc2hlc05hbWVzIEFuIGFycmF5IG9mIG1lc2ggbmFtZXMsIGEgc2luZ2xlIG1lc2ggbmFtZSwgb3IgZW1wdHkgc3RyaW5nIGZvciBhbGwgbWVzaGVzIHRoYXQgZmlsdGVyIHdoYXQgbWVzaGVzIGFyZSBpbXBvcnRlZFxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBpbXBvcnQgaW50b1xyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gaW1wb3J0XHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBUaGUgcm9vdCB1cmwgZm9yIHNjZW5lIGFuZCByZXNvdXJjZXNcclxuICAgICAqIEBwYXJhbSBtZXNoZXMgVGhlIG1lc2hlcyBhcnJheSB0byBpbXBvcnQgaW50b1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBzdWNjZXNzZnVsIG9yIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW1wb3J0TWVzaChtZXNoZXNOYW1lczogYW55LCBzY2VuZTogU2NlbmUsIGRhdGE6IGFueSwgcm9vdFVybDogc3RyaW5nLCBtZXNoZXM6IE51bGxhYmxlPEFic3RyYWN0TWVzaFtdPik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBtYXRjaGVzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQmluYXJ5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBiaW5hcnkgLnN0bFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFieWxvbk1lc2ggPSBuZXcgTWVzaChcInN0bG1lc2hcIiwgc2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VCaW5hcnkoYmFieWxvbk1lc2gsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc2hlcy5wdXNoKGJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBU0NJSSAuc3RsXHJcblxyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHN0cmluZ1xyXG4gICAgICAgICAgICBkYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgYXJyaXZlZCBoZXJlLCBkYXRhIGlzIGEgc3RyaW5nLCBjb250YWluaW5nIHRoZSBTVExBIGRhdGEuXHJcblxyXG4gICAgICAgIHdoaWxlICgobWF0Y2hlcyA9IHRoaXMuc29saWRQYXR0ZXJuLmV4ZWMoZGF0YSkpKSB7XHJcbiAgICAgICAgICAgIGxldCBtZXNoTmFtZSA9IG1hdGNoZXNbMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc2hOYW1lRnJvbUVuZCA9IG1hdGNoZXNbM107XHJcbiAgICAgICAgICAgIGlmIChtZXNoTmFtZUZyb21FbmQgJiYgbWVzaE5hbWUgIT0gbWVzaE5hbWVGcm9tRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBUb29scy5FcnJvcihcIkVycm9yIGluIFNUTCwgc29saWQgbmFtZSAhPSBlbmRzb2xpZCBuYW1lXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBtZXNoZXNOYW1lc1xyXG4gICAgICAgICAgICBpZiAobWVzaGVzTmFtZXMgJiYgbWVzaE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNoZXNOYW1lcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNoZXNOYW1lcy5pbmRleE9mKG1lc2hOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNoTmFtZSAhPT0gbWVzaGVzTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzdGwgbWVzaCBuYW1lIGNhbiBiZSBlbXB0eSBhcyB3ZWxsXHJcbiAgICAgICAgICAgIG1lc2hOYW1lID0gbWVzaE5hbWUgfHwgXCJzdGxtZXNoXCI7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBiYWJ5bG9uTWVzaCA9IG5ldyBNZXNoKG1lc2hOYW1lLCBzY2VuZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQVNDSUkoYmFieWxvbk1lc2gsIG1hdGNoZXNbMl0pO1xyXG4gICAgICAgICAgICBpZiAobWVzaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNoZXMucHVzaChiYWJ5bG9uTWVzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBpbnRvIGEgc2NlbmUuXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGxvYWQgaW50b1xyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gaW1wb3J0XHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBUaGUgcm9vdCB1cmwgZm9yIHNjZW5lIGFuZCByZXNvdXJjZXNcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgc3VjY2Vzc2Z1bCBvciBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWQoc2NlbmU6IFNjZW5lLCBkYXRhOiBhbnksIHJvb3RVcmw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaW1wb3J0TWVzaChudWxsLCBzY2VuZSwgZGF0YSwgcm9vdFVybCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgaW50byBhbiBhc3NldCBjb250YWluZXIuXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGxvYWQgaW50b1xyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gaW1wb3J0XHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBUaGUgcm9vdCB1cmwgZm9yIHNjZW5lIGFuZCByZXNvdXJjZXNcclxuICAgICAqIEByZXR1cm5zIFRoZSBsb2FkZWQgYXNzZXQgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb2FkQXNzZXRDb250YWluZXIoc2NlbmU6IFNjZW5lLCBkYXRhOiBzdHJpbmcsIHJvb3RVcmw6IHN0cmluZyk6IEFzc2V0Q29udGFpbmVyIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQXNzZXRDb250YWluZXIoc2NlbmUpO1xyXG4gICAgICAgIHNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaW1wb3J0TWVzaChudWxsLCBzY2VuZSwgZGF0YSwgcm9vdFVybCwgY29udGFpbmVyLm1lc2hlcyk7XHJcbiAgICAgICAgc2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfaXNCaW5hcnkoZGF0YTogYW55KSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgZmlsZSBzaXplIGlzIGNvcnJlY3QgZm9yIGJpbmFyeSBzdGxcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRGF0YVZpZXcoZGF0YSk7XHJcblxyXG4gICAgICAgIC8vIEEgQmluYXJ5IFNUTCBoZWFkZXIgaXMgODAgYnl0ZXMsIGlmIHRoZSBkYXRhIHNpemUgaXMgbm90IGdyZWF0IHRoYW5cclxuICAgICAgICAvLyB0aGF0IHRoZW4gaXQncyBub3QgYSBiaW5hcnkgU1RMLlxyXG4gICAgICAgIGlmIChyZWFkZXIuYnl0ZUxlbmd0aCA8PSA4MCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmYWNlU2l6ZSA9ICgzMiAvIDgpICogMyArICgzMiAvIDgpICogMyAqIDMgKyAxNiAvIDg7XHJcbiAgICAgICAgY29uc3QgbkZhY2VzID0gcmVhZGVyLmdldFVpbnQzMig4MCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmICg4MCArIDMyIC8gOCArIG5GYWNlcyAqIGZhY2VTaXplID09PSByZWFkZXIuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVTLUFTQ0lJIGJlZ2luIHdpdGggJ3MnLCAnbycsICdsJywgJ2knLCAnZCdcclxuICAgICAgICBjb25zdCBhc2NpaSA9IFsxMTUsIDExMSwgMTA4LCAxMDUsIDEwMF07XHJcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gMDsgb2ZmIDwgNTsgb2ZmKyspIHtcclxuICAgICAgICAgICAgaWYgKHJlYWRlci5nZXRVaW50OChvZmYpICE9PSBhc2NpaVtvZmZdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3BhcnNlQmluYXJ5KG1lc2g6IE1lc2gsIGRhdGE6IEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IERhdGFWaWV3KGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGZhY2VzID0gcmVhZGVyLmdldFVpbnQzMig4MCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGFPZmZzZXQgPSA4NDtcclxuICAgICAgICBjb25zdCBmYWNlTGVuZ3RoID0gMTIgKiA0ICsgMjtcclxuXHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoZmFjZXMgKiAzICogMyk7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoZmFjZXMgKiAzICogMyk7XHJcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShmYWNlcyAqIDMpO1xyXG4gICAgICAgIGxldCBpbmRpY2VzQ291bnQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IGZhY2VzOyBmYWNlKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBkYXRhT2Zmc2V0ICsgZmFjZSAqIGZhY2VMZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbFggPSByZWFkZXIuZ2V0RmxvYXQzMihzdGFydCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbFkgPSByZWFkZXIuZ2V0RmxvYXQzMihzdGFydCArIDQsIHRydWUpO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxaID0gcmVhZGVyLmdldEZsb2F0MzIoc3RhcnQgKyA4LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGV4c3RhcnQgPSBzdGFydCArIGkgKiAxMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBvcmRlcmluZyBpcyBpbnRlbnRpb25hbCB0byBtYXRjaCBhc2NpaSBpbXBvcnRcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tvZmZzZXRdID0gcmVhZGVyLmdldEZsb2F0MzIodmVydGV4c3RhcnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsc1tvZmZzZXRdID0gbm9ybWFsWDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIVNUTEZpbGVMb2FkZXIuRE9fTk9UX0FMVEVSX0ZJTEVfQ09PUkRJTkFURVMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbb2Zmc2V0ICsgMl0gPSByZWFkZXIuZ2V0RmxvYXQzMih2ZXJ0ZXhzdGFydCArIDQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tvZmZzZXQgKyAxXSA9IHJlYWRlci5nZXRGbG9hdDMyKHZlcnRleHN0YXJ0ICsgOCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbb2Zmc2V0ICsgMl0gPSBub3JtYWxZO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbb2Zmc2V0ICsgMV0gPSBub3JtYWxaO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbb2Zmc2V0ICsgMV0gPSByZWFkZXIuZ2V0RmxvYXQzMih2ZXJ0ZXhzdGFydCArIDQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tvZmZzZXQgKyAyXSA9IHJlYWRlci5nZXRGbG9hdDMyKHZlcnRleHN0YXJ0ICsgOCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbb2Zmc2V0ICsgMV0gPSBub3JtYWxZO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbb2Zmc2V0ICsgMl0gPSBub3JtYWxaO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU1RMRmlsZUxvYWRlci5ET19OT1RfQUxURVJfRklMRV9DT09SRElOQVRFUykge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzQ291bnRdID0gaW5kaWNlc0NvdW50O1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzQ291bnQgKyAxXSA9IGluZGljZXNDb3VudCArIDI7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGljZXNDb3VudCArIDJdID0gaW5kaWNlc0NvdW50ICsgMTtcclxuICAgICAgICAgICAgICAgIGluZGljZXNDb3VudCArPSAzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzQ291bnRdID0gaW5kaWNlc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGljZXNDb3VudF0gPSBpbmRpY2VzQ291bnQrKztcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kaWNlc0NvdW50XSA9IGluZGljZXNDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZXNoLnNldFZlcnRpY2VzRGF0YShWZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLCBwb3NpdGlvbnMpO1xyXG4gICAgICAgIG1lc2guc2V0VmVydGljZXNEYXRhKFZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLCBub3JtYWxzKTtcclxuICAgICAgICBtZXNoLnNldEluZGljZXMoaW5kaWNlcyk7XHJcbiAgICAgICAgbWVzaC5jb21wdXRlV29ybGRNYXRyaXgodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcGFyc2VBU0NJSShtZXNoOiBNZXNoLCBzb2xpZERhdGE6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuICAgICAgICBjb25zdCBpbmRpY2VzID0gW107XHJcbiAgICAgICAgbGV0IGluZGljZXNDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIC8vbG9hZCBmYWNldHMsIGlnbm9yaW5nIGxvb3AgYXMgdGhlIHN0YW5kYXJkIGRvZXNuJ3QgZGVmaW5lIGl0IGNhbiBjb250YWluIG1vcmUgdGhhbiB2ZXJ0aWNlc1xyXG4gICAgICAgIGxldCBtYXRjaGVzO1xyXG4gICAgICAgIHdoaWxlICgobWF0Y2hlcyA9IHRoaXMuZmFjZXRzUGF0dGVybi5leGVjKHNvbGlkRGF0YSkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZhY2V0ID0gbWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgLy9vbmUgbm9ybWFsIHBlciBmYWNlXHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbE1hdGNoZXMgPSB0aGlzLm5vcm1hbFBhdHRlcm4uZXhlYyhmYWNldCk7XHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsUGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBpZiAoIW5vcm1hbE1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IFtOdW1iZXIobm9ybWFsTWF0Y2hlc1sxXSksIE51bWJlcihub3JtYWxNYXRjaGVzWzVdKSwgTnVtYmVyKG5vcm1hbE1hdGNoZXNbM10pXTtcclxuXHJcbiAgICAgICAgICAgIGxldCB2ZXJ0ZXhNYXRjaDtcclxuICAgICAgICAgICAgd2hpbGUgKCh2ZXJ0ZXhNYXRjaCA9IHRoaXMudmVydGV4UGF0dGVybi5leGVjKGZhY2V0KSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghU1RMRmlsZUxvYWRlci5ET19OT1RfQUxURVJfRklMRV9DT09SRElOQVRFUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKE51bWJlcih2ZXJ0ZXhNYXRjaFsxXSksIE51bWJlcih2ZXJ0ZXhNYXRjaFs1XSksIE51bWJlcih2ZXJ0ZXhNYXRjaFszXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaChub3JtYWxbMF0sIG5vcm1hbFsxXSwgbm9ybWFsWzJdKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goTnVtYmVyKHZlcnRleE1hdGNoWzFdKSwgTnVtYmVyKHZlcnRleE1hdGNoWzNdKSwgTnVtYmVyKHZlcnRleE1hdGNoWzVdKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZsaXBwaW5nIHRoZSBzZWNvbmQgYW5kIHRoaXJkIGNvbXBvbmVudCBiZWNhdXNlIGludmVydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBub3JtYWwgd2FzIGRlY2xhcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaChub3JtYWxbMF0sIG5vcm1hbFsyXSwgbm9ybWFsWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoU1RMRmlsZUxvYWRlci5ET19OT1RfQUxURVJfRklMRV9DT09SRElOQVRFUykge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGljZXNDb3VudCwgaW5kaWNlc0NvdW50ICsgMiwgaW5kaWNlc0NvdW50ICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzQ291bnQgKz0gMztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpbmRpY2VzQ291bnQrKywgaW5kaWNlc0NvdW50KyssIGluZGljZXNDb3VudCsrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZlcnRleFBhdHRlcm4ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZmFjZXRzUGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIG1lc2guc2V0VmVydGljZXNEYXRhKFZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsIHBvc2l0aW9ucyk7XHJcbiAgICAgICAgbWVzaC5zZXRWZXJ0aWNlc0RhdGEoVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsIG5vcm1hbHMpO1xyXG4gICAgICAgIG1lc2guc2V0SW5kaWNlcyhpbmRpY2VzKTtcclxuICAgICAgICBtZXNoLmNvbXB1dGVXb3JsZE1hdHJpeCh0cnVlKTtcclxuICAgIH1cclxufVxyXG5cclxuUmVnaXN0ZXJTY2VuZUxvYWRlclBsdWdpbihuZXcgU1RMRmlsZUxvYWRlcigpKTtcclxuIiwiaW1wb3J0IHsgR0xURkxvYWRlckV4dGVuc2lvbiwgR0xURkxvYWRlciwgR0xURkxvYWRlckJhc2UgfSBmcm9tIFwiLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB7IEdMVEZVdGlscyB9IGZyb20gXCIuL2dsVEZMb2FkZXJVdGlsc1wiO1xyXG5pbXBvcnQgdHlwZSB7IFNjZW5lIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckRhdGEgfSBmcm9tIFwiLi4vZ2xURkZpbGVMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURlJ1bnRpbWUsIElHTFRGVGV4dHVyZSwgSUdMVEZJbWFnZSwgSUdMVEZCdWZmZXJWaWV3LCBJR0xURlNoYWRlciB9IGZyb20gXCIuL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB7IEVDb21wb25lbnRUeXBlIH0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgSURhdGFCdWZmZXIgfSBmcm9tIFwiY29yZS9NaXNjL2RhdGFSZWFkZXJcIjtcclxuXHJcbmNvbnN0IEJpbmFyeUV4dGVuc2lvbkJ1ZmZlck5hbWUgPSBcImJpbmFyeV9nbFRGXCI7XHJcblxyXG5pbnRlcmZhY2UgSUdMVEZCaW5hcnlFeHRlbnNpb25TaGFkZXIge1xyXG4gICAgYnVmZmVyVmlldzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSUdMVEZCaW5hcnlFeHRlbnNpb25JbWFnZSB7XHJcbiAgICBidWZmZXJWaWV3OiBzdHJpbmc7XHJcbiAgICBtaW1lVHlwZTogc3RyaW5nO1xyXG4gICAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICB3aWR0aDogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR0xURkJpbmFyeUV4dGVuc2lvbiBleHRlbmRzIEdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgcHJpdmF0ZSBfYmluOiBJRGF0YUJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoXCJLSFJfYmluYXJ5X2dsVEZcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgbG9hZFJ1bnRpbWVBc3luYyhzY2VuZTogU2NlbmUsIGRhdGE6IElHTFRGTG9hZGVyRGF0YSwgcm9vdFVybDogc3RyaW5nLCBvblN1Y2Nlc3M6IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1VzZWQgPSAoPGFueT5kYXRhLmpzb24pLmV4dGVuc2lvbnNVc2VkO1xyXG4gICAgICAgIGlmICghZXh0ZW5zaW9uc1VzZWQgfHwgZXh0ZW5zaW9uc1VzZWQuaW5kZXhPZih0aGlzLm5hbWUpID09PSAtMSB8fCAhZGF0YS5iaW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fYmluID0gZGF0YS5iaW47XHJcbiAgICAgICAgb25TdWNjZXNzKEdMVEZMb2FkZXJCYXNlLkNyZWF0ZVJ1bnRpbWUoZGF0YS5qc29uLCBzY2VuZSwgcm9vdFVybCkpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIG92ZXJyaWRlIGxvYWRCdWZmZXJBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBpZDogc3RyaW5nLCBvblN1Y2Nlc3M6IChidWZmZXI6IEFycmF5QnVmZmVyVmlldykgPT4gdm9pZCwgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChnbHRmUnVudGltZS5leHRlbnNpb25zVXNlZC5pbmRleE9mKHRoaXMubmFtZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpZCAhPT0gQmluYXJ5RXh0ZW5zaW9uQnVmZmVyTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICB0aGlzLl9iaW4ucmVhZEFzeW5jKDAsIHRoaXMuX2Jpbi5ieXRlTGVuZ3RoKS50aGVuKG9uU3VjY2VzcywgKGVycm9yKSA9PiBvbkVycm9yKGVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBvdmVycmlkZSBsb2FkVGV4dHVyZUJ1ZmZlckFzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKGJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3KSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZTogSUdMVEZUZXh0dXJlID0gZ2x0ZlJ1bnRpbWUudGV4dHVyZXNbaWRdO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZTogSUdMVEZJbWFnZSA9IGdsdGZSdW50aW1lLmltYWdlc1t0ZXh0dXJlLnNvdXJjZV07XHJcbiAgICAgICAgaWYgKCFzb3VyY2UuZXh0ZW5zaW9ucyB8fCAhKHRoaXMubmFtZSBpbiBzb3VyY2UuZXh0ZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlRXh0OiBJR0xURkJpbmFyeUV4dGVuc2lvbkltYWdlID0gc291cmNlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcclxuICAgICAgICBjb25zdCBidWZmZXJWaWV3OiBJR0xURkJ1ZmZlclZpZXcgPSBnbHRmUnVudGltZS5idWZmZXJWaWV3c1tzb3VyY2VFeHQuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gR0xURlV0aWxzLkdldEJ1ZmZlckZyb21CdWZmZXJWaWV3KGdsdGZSdW50aW1lLCBidWZmZXJWaWV3LCAwLCBidWZmZXJWaWV3LmJ5dGVMZW5ndGgsIEVDb21wb25lbnRUeXBlLlVOU0lHTkVEX0JZVEUpO1xyXG4gICAgICAgIG9uU3VjY2VzcyhidWZmZXIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIG92ZXJyaWRlIGxvYWRTaGFkZXJTdHJpbmdBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBpZDogc3RyaW5nLCBvblN1Y2Nlc3M6IChzaGFkZXJTdHJpbmc6IHN0cmluZykgPT4gdm9pZCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHNoYWRlcjogSUdMVEZTaGFkZXIgPSBnbHRmUnVudGltZS5zaGFkZXJzW2lkXTtcclxuICAgICAgICBpZiAoIXNoYWRlci5leHRlbnNpb25zIHx8ICEodGhpcy5uYW1lIGluIHNoYWRlci5leHRlbnNpb25zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBiaW5hcnlFeHRlbnNpb25TaGFkZXI6IElHTFRGQmluYXJ5RXh0ZW5zaW9uU2hhZGVyID0gc2hhZGVyLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcclxuICAgICAgICBjb25zdCBidWZmZXJWaWV3OiBJR0xURkJ1ZmZlclZpZXcgPSBnbHRmUnVudGltZS5idWZmZXJWaWV3c1tiaW5hcnlFeHRlbnNpb25TaGFkZXIuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyQnl0ZXMgPSBHTFRGVXRpbHMuR2V0QnVmZmVyRnJvbUJ1ZmZlclZpZXcoZ2x0ZlJ1bnRpbWUsIGJ1ZmZlclZpZXcsIDAsIGJ1ZmZlclZpZXcuYnl0ZUxlbmd0aCwgRUNvbXBvbmVudFR5cGUuVU5TSUdORURfQllURSk7XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXJTdHJpbmcgPSBHTFRGVXRpbHMuRGVjb2RlQnVmZmVyVG9UZXh0KHNoYWRlckJ5dGVzKTtcclxuICAgICAgICAgICAgb25TdWNjZXNzKHNoYWRlclN0cmluZyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5HTFRGTG9hZGVyLlJlZ2lzdGVyRXh0ZW5zaW9uKG5ldyBHTFRGQmluYXJ5RXh0ZW5zaW9uKCkpO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cclxuaW1wb3J0IHR5cGUge1xyXG4gICAgSUdMVEZSdW50aW1lLFxyXG4gICAgSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIsXHJcbiAgICBJR0xURkFuaW1hdGlvbixcclxuICAgIElHTFRGQW5pbWF0aW9uU2FtcGxlcixcclxuICAgIElHTFRGTm9kZSxcclxuICAgIElHTFRGU2tpbnMsXHJcbiAgICBJTm9kZVRvUm9vdCxcclxuICAgIElKb2ludE5vZGUsXHJcbiAgICBJR0xURk1lc2gsXHJcbiAgICBJR0xURkFjY2Vzc29yLFxyXG4gICAgSUdMVEZMaWdodCxcclxuICAgIElHTFRGQW1iaWVuTGlnaHQsXHJcbiAgICBJR0xURkRpcmVjdGlvbmFsTGlnaHQsXHJcbiAgICBJR0xURlBvaW50TGlnaHQsXHJcbiAgICBJR0xURlNwb3RMaWdodCxcclxuICAgIElHTFRGQ2FtZXJhLFxyXG4gICAgSUdMVEZDYW1lcmFQZXJzcGVjdGl2ZSxcclxuICAgIElHTFRGU2NlbmUsXHJcbiAgICBJR0xURlRlY2huaXF1ZSxcclxuICAgIElHTFRGTWF0ZXJpYWwsXHJcbiAgICBJR0xURlByb2dyYW0sXHJcbiAgICBJR0xURkJ1ZmZlcixcclxuICAgIElHTFRGVGV4dHVyZSxcclxuICAgIElHTFRGSW1hZ2UsXHJcbiAgICBJR0xURlNhbXBsZXIsXHJcbiAgICBJR0xURlNoYWRlcixcclxuICAgIElHTFRGVGVjaG5pcXVlU3RhdGVzLFxyXG59IGZyb20gXCIuL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB7IEVQYXJhbWV0ZXJUeXBlLCBFVGV4dHVyZUZpbHRlclR5cGUsIEVDdWxsaW5nVHlwZSwgRUJsZW5kaW5nRnVuY3Rpb24sIEVTaGFkZXJUeXBlIH0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgRmxvYXRBcnJheSwgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBRdWF0ZXJuaW9uLCBWZWN0b3IzLCBNYXRyaXggfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiY29yZS9DYW1lcmFzL2NhbWVyYVwiO1xyXG5pbXBvcnQgeyBGcmVlQ2FtZXJhIH0gZnJvbSBcImNvcmUvQ2FtZXJhcy9mcmVlQ2FtZXJhXCI7XHJcbmltcG9ydCB7IEFuaW1hdGlvbiB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0aW9uXCI7XHJcbmltcG9ydCB7IEJvbmUgfSBmcm9tIFwiY29yZS9Cb25lcy9ib25lXCI7XHJcbmltcG9ydCB7IFNrZWxldG9uIH0gZnJvbSBcImNvcmUvQm9uZXMvc2tlbGV0b25cIjtcclxuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL2VmZmVjdFwiO1xyXG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5pbXBvcnQgeyBNdWx0aU1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL211bHRpTWF0ZXJpYWxcIjtcclxuaW1wb3J0IHsgU3RhbmRhcmRNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9zdGFuZGFyZE1hdGVyaWFsXCI7XHJcbmltcG9ydCB7IFNoYWRlck1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL3NoYWRlck1hdGVyaWFsXCI7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZVwiO1xyXG5pbXBvcnQgdHlwZSB7IE5vZGUgfSBmcm9tIFwiY29yZS9ub2RlXCI7XHJcbmltcG9ydCB7IFZlcnRleERhdGEgfSBmcm9tIFwiY29yZS9NZXNoZXMvbWVzaC52ZXJ0ZXhEYXRhXCI7XHJcbmltcG9ydCB7IFZlcnRleEJ1ZmZlciB9IGZyb20gXCJjb3JlL0J1ZmZlcnMvYnVmZmVyXCI7XHJcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSBcImNvcmUvTWVzaGVzL2dlb21ldHJ5XCI7XHJcbmltcG9ydCB7IFN1Yk1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvc3ViTWVzaFwiO1xyXG5pbXBvcnQgeyBBYnN0cmFjdE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvYWJzdHJhY3RNZXNoXCI7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvbWVzaFwiO1xyXG5pbXBvcnQgeyBIZW1pc3BoZXJpY0xpZ2h0IH0gZnJvbSBcImNvcmUvTGlnaHRzL2hlbWlzcGhlcmljTGlnaHRcIjtcclxuaW1wb3J0IHsgRGlyZWN0aW9uYWxMaWdodCB9IGZyb20gXCJjb3JlL0xpZ2h0cy9kaXJlY3Rpb25hbExpZ2h0XCI7XHJcbmltcG9ydCB7IFBvaW50TGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvcG9pbnRMaWdodFwiO1xyXG5pbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvc3BvdExpZ2h0XCI7XHJcbmltcG9ydCB0eXBlIHsgSVNjZW5lTG9hZGVyQXN5bmNSZXN1bHQsIElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQgfSBmcm9tIFwiY29yZS9Mb2FkaW5nL3NjZW5lTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgU2NlbmUgfSBmcm9tIFwiY29yZS9zY2VuZVwiO1xyXG5cclxuaW1wb3J0IHsgR0xURlV0aWxzIH0gZnJvbSBcIi4vZ2xURkxvYWRlclV0aWxzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXIsIElHTFRGTG9hZGVyRGF0YSB9IGZyb20gXCIuLi9nbFRGRmlsZUxvYWRlclwiO1xyXG5pbXBvcnQgeyBHTFRGRmlsZUxvYWRlciB9IGZyb20gXCIuLi9nbFRGRmlsZUxvYWRlclwiO1xyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tIFwiY29yZS9FbmdpbmVzL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgdHlwZSB7IEFzc2V0Q29udGFpbmVyIH0gZnJvbSBcImNvcmUvYXNzZXRDb250YWluZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUb2tlbml6ZXIuIFVzZWQgZm9yIHNoYWRlcnMgY29tcGF0aWJpbGl0eVxyXG4gKiBBdXRvbWF0aWNhbGx5IG1hcCB3b3JsZCwgdmlldywgcHJvamVjdGlvbiwgd29ybGRWaWV3UHJvamVjdGlvbiwgYXR0cmlidXRlcyBhbmQgc28gb25cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZW51bSBFVG9rZW5UeXBlIHtcclxuICAgIElERU5USUZJRVIgPSAxLFxyXG5cclxuICAgIFVOS05PV04gPSAyLFxyXG4gICAgRU5EX09GX0lOUFVUID0gMyxcclxufVxyXG5cclxuY2xhc3MgVG9rZW5pemVyIHtcclxuICAgIHByaXZhdGUgX3RvUGFyc2U6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3BvczogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgX21heFBvczogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjdXJyZW50VG9rZW46IEVUb2tlblR5cGUgPSBFVG9rZW5UeXBlLlVOS05PV047XHJcbiAgICBwdWJsaWMgY3VycmVudElkZW50aWZpZXI6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgY3VycmVudFN0cmluZzogc3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBpc0xldHRlck9yRGlnaXRQYXR0ZXJuOiBSZWdFeHAgPSAvXlthLXpBLVowLTldKyQvO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRvUGFyc2U6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3RvUGFyc2UgPSB0b1BhcnNlO1xyXG4gICAgICAgIHRoaXMuX21heFBvcyA9IHRvUGFyc2UubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXROZXh0VG9rZW4oKTogRVRva2VuVHlwZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRVRva2VuVHlwZS5FTkRfT0ZfSU5QVVQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdHJpbmcgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IEVUb2tlblR5cGUuVU5LTk9XTjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0cmluZyA9PT0gXCJfXCIgfHwgdGhpcy5pc0xldHRlck9yRGlnaXRQYXR0ZXJuLnRlc3QodGhpcy5jdXJyZW50U3RyaW5nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IEVUb2tlblR5cGUuSURFTlRJRklFUjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SWRlbnRpZmllciA9IHRoaXMuY3VycmVudFN0cmluZztcclxuICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmlzRW5kKCkgJiYgKHRoaXMuaXNMZXR0ZXJPckRpZ2l0UGF0dGVybi50ZXN0KCh0aGlzLmN1cnJlbnRTdHJpbmcgPSB0aGlzLnBlZWsoKSkpIHx8IHRoaXMuY3VycmVudFN0cmluZyA9PT0gXCJfXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJZGVudGlmaWVyICs9IHRoaXMuY3VycmVudFN0cmluZztcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBlZWsoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdG9QYXJzZVt0aGlzLl9wb3NdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWFkKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvUGFyc2VbdGhpcy5fcG9zKytdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBmb3J3YXJkKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvcysrO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0VuZCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9zID49IHRoaXMuX21heFBvcztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbHVlc1xyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5jb25zdCBnbFRGVHJhbnNmb3JtcyA9IFtcIk1PREVMXCIsIFwiVklFV1wiLCBcIlBST0pFQ1RJT05cIiwgXCJNT0RFTFZJRVdcIiwgXCJNT0RFTFZJRVdQUk9KRUNUSU9OXCIsIFwiSk9JTlRNQVRSSVhcIl07XHJcbmNvbnN0IEJhYnlsb25UcmFuc2Zvcm1zID0gW1wid29ybGRcIiwgXCJ2aWV3XCIsIFwicHJvamVjdGlvblwiLCBcIndvcmxkVmlld1wiLCBcIndvcmxkVmlld1Byb2plY3Rpb25cIiwgXCJtQm9uZXNcIl07XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmNvbnN0IGdsVEZBbmltYXRpb25QYXRocyA9IFtcInRyYW5zbGF0aW9uXCIsIFwicm90YXRpb25cIiwgXCJzY2FsZVwiXTtcclxuY29uc3QgQmFieWxvbkFuaW1hdGlvblBhdGhzID0gW1wicG9zaXRpb25cIiwgXCJyb3RhdGlvblF1YXRlcm5pb25cIiwgXCJzY2FsaW5nXCJdO1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlXHJcbiAqIEBwYXJhbSBwYXJzZWRCdWZmZXJzXHJcbiAqIEBwYXJhbSBnbHRmUnVudGltZVxyXG4gKi9cclxuY29uc3QgUGFyc2VCdWZmZXJzID0gKHBhcnNlZEJ1ZmZlcnM6IGFueSwgZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBidWYgaW4gcGFyc2VkQnVmZmVycykge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZEJ1ZmZlciA9IHBhcnNlZEJ1ZmZlcnNbYnVmXTtcclxuICAgICAgICBnbHRmUnVudGltZS5idWZmZXJzW2J1Zl0gPSBwYXJzZWRCdWZmZXI7XHJcbiAgICAgICAgZ2x0ZlJ1bnRpbWUuYnVmZmVyc0NvdW50Kys7XHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCBQYXJzZVNoYWRlcnMgPSAocGFyc2VkU2hhZGVyczogYW55LCBnbHRmUnVudGltZTogSUdMVEZSdW50aW1lKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHNoYSBpbiBwYXJzZWRTaGFkZXJzKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkU2hhZGVyID0gcGFyc2VkU2hhZGVyc1tzaGFdO1xyXG4gICAgICAgIGdsdGZSdW50aW1lLnNoYWRlcnNbc2hhXSA9IHBhcnNlZFNoYWRlcjtcclxuICAgICAgICBnbHRmUnVudGltZS5zaGFkZXJzY291bnQrKztcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IFBhcnNlT2JqZWN0ID0gKHBhcnNlZE9iamVjdHM6IGFueSwgcnVudGltZVByb3BlcnR5OiBzdHJpbmcsIGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUpID0+IHtcclxuICAgIGZvciAoY29uc3Qgb2JqZWN0IGluIHBhcnNlZE9iamVjdHMpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRPYmplY3QgPSBwYXJzZWRPYmplY3RzW29iamVjdF07XHJcbiAgICAgICAgKDxhbnk+Z2x0ZlJ1bnRpbWUpW3J1bnRpbWVQcm9wZXJ0eV1bb2JqZWN0XSA9IHBhcnNlZE9iamVjdDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBVdGlsc1xyXG4gKiBAcGFyYW0gYnVmZmVyXHJcbiAqL1xyXG5jb25zdCBOb3JtYWxpemVVVnMgPSAoYnVmZmVyOiBhbnkpID0+IHtcclxuICAgIGlmICghYnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aCAvIDI7IGkrKykge1xyXG4gICAgICAgIGJ1ZmZlcltpICogMiArIDFdID0gMS4wIC0gYnVmZmVyW2kgKiAyICsgMV07XHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCBHZXRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlUGFyYW1ldGVyOiBJR0xURlRlY2huaXF1ZVBhcmFtZXRlcik6IE51bGxhYmxlPHN0cmluZz4gPT4ge1xyXG4gICAgaWYgKGF0dHJpYnV0ZVBhcmFtZXRlci5zZW1hbnRpYyA9PT0gXCJOT1JNQUxcIikge1xyXG4gICAgICAgIHJldHVybiBcIm5vcm1hbFwiO1xyXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVQYXJhbWV0ZXIuc2VtYW50aWMgPT09IFwiUE9TSVRJT05cIikge1xyXG4gICAgICAgIHJldHVybiBcInBvc2l0aW9uXCI7XHJcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZVBhcmFtZXRlci5zZW1hbnRpYyA9PT0gXCJKT0lOVFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibWF0cmljZXNJbmRpY2VzXCI7XHJcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZVBhcmFtZXRlci5zZW1hbnRpYyA9PT0gXCJXRUlHSFRcIikge1xyXG4gICAgICAgIHJldHVybiBcIm1hdHJpY2VzV2VpZ2h0c1wiO1xyXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVQYXJhbWV0ZXIuc2VtYW50aWMgPT09IFwiQ09MT1JcIikge1xyXG4gICAgICAgIHJldHVybiBcImNvbG9yXCI7XHJcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZVBhcmFtZXRlci5zZW1hbnRpYyAmJiBhdHRyaWJ1dGVQYXJhbWV0ZXIuc2VtYW50aWMuaW5kZXhPZihcIlRFWENPT1JEX1wiKSAhPT0gLTEpIHtcclxuICAgICAgICBjb25zdCBjaGFubmVsID0gTnVtYmVyKGF0dHJpYnV0ZVBhcmFtZXRlci5zZW1hbnRpYy5zcGxpdChcIl9cIilbMV0pO1xyXG4gICAgICAgIHJldHVybiBcInV2XCIgKyAoY2hhbm5lbCA9PT0gMCA/IFwiXCIgOiBjaGFubmVsICsgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogTG9hZHMgYW5kIGNyZWF0ZXMgYW5pbWF0aW9uc1xyXG4gKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICovXHJcbmNvbnN0IExvYWRBbmltYXRpb25zID0gKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUpID0+IHtcclxuICAgIGZvciAoY29uc3QgYW5pbSBpbiBnbHRmUnVudGltZS5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uOiBJR0xURkFuaW1hdGlvbiA9IGdsdGZSdW50aW1lLmFuaW1hdGlvbnNbYW5pbV07XHJcblxyXG4gICAgICAgIGlmICghYW5pbWF0aW9uLmNoYW5uZWxzIHx8ICFhbmltYXRpb24uc2FtcGxlcnMpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGFzdEFuaW1hdGlvbjogTnVsbGFibGU8QW5pbWF0aW9uPiA9IG51bGw7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5pbWF0aW9uLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBwYXJhbWV0ZXJzIGFuZCBsb2FkIGJ1ZmZlcnNcclxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGFuaW1hdGlvbi5jaGFubmVsc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlcjogSUdMVEZBbmltYXRpb25TYW1wbGVyID0gYW5pbWF0aW9uLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNhbXBsZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgaW5wdXREYXRhOiBOdWxsYWJsZTxzdHJpbmc+ID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IG91dHB1dERhdGE6IE51bGxhYmxlPHN0cmluZz4gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5wYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dERhdGEgPSBhbmltYXRpb24ucGFyYW1ldGVyc1tzYW1wbGVyLmlucHV0XTtcclxuICAgICAgICAgICAgICAgIG91dHB1dERhdGEgPSBhbmltYXRpb24ucGFyYW1ldGVyc1tzYW1wbGVyLm91dHB1dF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dERhdGEgPSBzYW1wbGVyLmlucHV0O1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0RGF0YSA9IHNhbXBsZXIub3V0cHV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbnB1dCA9IEdMVEZVdGlscy5HZXRCdWZmZXJGcm9tQWNjZXNzb3IoZ2x0ZlJ1bnRpbWUsIGdsdGZSdW50aW1lLmFjY2Vzc29yc1tpbnB1dERhdGFdKTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyT3V0cHV0ID0gR0xURlV0aWxzLkdldEJ1ZmZlckZyb21BY2Nlc3NvcihnbHRmUnVudGltZSwgZ2x0ZlJ1bnRpbWUuYWNjZXNzb3JzW291dHB1dERhdGFdKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gY2hhbm5lbC50YXJnZXQuaWQ7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXROb2RlOiBhbnkgPSBnbHRmUnVudGltZS5zY2VuZS5nZXROb2RlQnlJZCh0YXJnZXRJZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGdsdGZSdW50aW1lLnNjZW5lLmdldE5vZGVCeU5hbWUodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgVG9vbHMuV2FybihcIkNyZWF0aW5nIGFuaW1hdGlvbiBuYW1lZCBcIiArIGFuaW0gKyBcIi4gQnV0IGNhbm5vdCBmaW5kIG5vZGUgbmFtZWQgXCIgKyB0YXJnZXRJZCArIFwiIHRvIGF0dGFjaCB0b1wiKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpc0JvbmUgPSB0YXJnZXROb2RlIGluc3RhbmNlb2YgQm9uZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0YXJnZXQgcGF0aCAocG9zaXRpb24sIHJvdGF0aW9uIG9yIHNjYWxpbmcpXHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRQYXRoID0gY2hhbm5lbC50YXJnZXQucGF0aDtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aEluZGV4ID0gZ2xURkFuaW1hdGlvblBhdGhzLmluZGV4T2YodGFyZ2V0UGF0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0UGF0aEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0UGF0aCA9IEJhYnlsb25BbmltYXRpb25QYXRoc1t0YXJnZXRQYXRoSW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgYW5pbWF0aW9uIHR5cGVcclxuICAgICAgICAgICAgbGV0IGFuaW1hdGlvblR5cGUgPSBBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9NQVRSSVg7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzQm9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFBhdGggPT09IFwicm90YXRpb25RdWF0ZXJuaW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25UeXBlID0gQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfUVVBVEVSTklPTjtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlLnJvdGF0aW9uUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblR5cGUgPSBBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9WRUNUT1IzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5pbWF0aW9uIGFuZCBrZXkgZnJhbWVzXHJcbiAgICAgICAgICAgIGxldCBiYWJ5bG9uQW5pbWF0aW9uOiBOdWxsYWJsZTxBbmltYXRpb24+ID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgYXJyYXlPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZ5S2V5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNCb25lICYmIGxhc3RBbmltYXRpb24gJiYgbGFzdEFuaW1hdGlvbi5nZXRLZXlzKCkubGVuZ3RoID09PSBidWZmZXJJbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb24gPSBsYXN0QW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZ5S2V5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFtb2RpZnlLZXkpIHtcclxuICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLnNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIWdsdGZSdW50aW1lLmFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbkFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oYW5pbSwgaXNCb25lID8gXCJfbWF0cml4XCIgOiB0YXJnZXRQYXRoLCAxLCBhbmltYXRpb25UeXBlLCBBbmltYXRpb24uQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEUpO1xyXG4gICAgICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUuc2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBmcmFtZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ1ZmZlcklucHV0Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWU6IGFueSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFBhdGggPT09IFwicm90YXRpb25RdWF0ZXJuaW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWRUM0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBRdWF0ZXJuaW9uLkZyb21BcnJheShbYnVmZmVyT3V0cHV0W2FycmF5T2Zmc2V0XSwgYnVmZmVyT3V0cHV0W2FycmF5T2Zmc2V0ICsgMV0sIGJ1ZmZlck91dHB1dFthcnJheU9mZnNldCArIDJdLCBidWZmZXJPdXRwdXRbYXJyYXlPZmZzZXQgKyAzXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5T2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIGFuZCBzY2FsaW5nIGFyZSBWRUMzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBWZWN0b3IzLkZyb21BcnJheShbYnVmZmVyT3V0cHV0W2FycmF5T2Zmc2V0XSwgYnVmZmVyT3V0cHV0W2FycmF5T2Zmc2V0ICsgMV0sIGJ1ZmZlck91dHB1dFthcnJheU9mZnNldCArIDJdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlPZmZzZXQgKz0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNCb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9uZSA9IDxCb25lPnRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0aW9uID0gVmVjdG9yMy5aZXJvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvdGF0aW9uUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxpbmcgPSBWZWN0b3IzLlplcm8oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FybmluZyBvbiBkZWNvbXBvc2VcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0ID0gYm9uZS5nZXRCYXNlTWF0cml4KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnlLZXkgJiYgbGFzdEFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQgPSBsYXN0QW5pbWF0aW9uLmdldEtleXMoKVtqXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hdC5kZWNvbXBvc2Uoc2NhbGluZywgcm90YXRpb25RdWF0ZXJuaW9uLCB0cmFuc2xhdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQYXRoID09PSBcInBvc2l0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFBhdGggPT09IFwicm90YXRpb25RdWF0ZXJuaW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb25RdWF0ZXJuaW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGluZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRyaXguQ29tcG9zZShzY2FsaW5nLCByb3RhdGlvblF1YXRlcm5pb24sIHRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGlmeUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lOiBidWZmZXJJbnB1dFtqXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0QW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEFuaW1hdGlvbi5nZXRLZXlzKClbal0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluaXNoXHJcbiAgICAgICAgICAgIGlmICghbW9kaWZ5S2V5ICYmIGJhYnlsb25BbmltYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb24uc2V0S2V5cyhrZXlzKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUuYW5pbWF0aW9ucy5wdXNoKGJhYnlsb25BbmltYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXN0QW5pbWF0aW9uID0gYmFieWxvbkFuaW1hdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGdsdGZSdW50aW1lLnNjZW5lLnN0b3BBbmltYXRpb24odGFyZ2V0Tm9kZSk7XHJcbiAgICAgICAgICAgIGdsdGZSdW50aW1lLnNjZW5lLmJlZ2luQW5pbWF0aW9uKHRhcmdldE5vZGUsIDAsIGJ1ZmZlcklucHV0W2J1ZmZlcklucHV0Lmxlbmd0aCAtIDFdLCB0cnVlLCAxLjApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0aGUgYm9uZXMgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqL1xyXG5jb25zdCBDb25maWd1cmVCb25lVHJhbnNmb3JtYXRpb24gPSAobm9kZTogSUdMVEZOb2RlKTogTWF0cml4ID0+IHtcclxuICAgIGxldCBtYXQ6IE51bGxhYmxlPE1hdHJpeD4gPSBudWxsO1xyXG5cclxuICAgIGlmIChub2RlLnRyYW5zbGF0aW9uIHx8IG5vZGUucm90YXRpb24gfHwgbm9kZS5zY2FsZSkge1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gVmVjdG9yMy5Gcm9tQXJyYXkobm9kZS5zY2FsZSB8fCBbMSwgMSwgMV0pO1xyXG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gUXVhdGVybmlvbi5Gcm9tQXJyYXkobm9kZS5yb3RhdGlvbiB8fCBbMCwgMCwgMCwgMV0pO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gVmVjdG9yMy5Gcm9tQXJyYXkobm9kZS50cmFuc2xhdGlvbiB8fCBbMCwgMCwgMF0pO1xyXG5cclxuICAgICAgICBtYXQgPSBNYXRyaXguQ29tcG9zZShzY2FsZSwgcm90YXRpb24sIHBvc2l0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWF0ID0gTWF0cml4LkZyb21BcnJheShub2RlLm1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnQgYm9uZVxyXG4gKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICogQHBhcmFtIHNraW5zXHJcbiAqIEBwYXJhbSBqb2ludE5hbWVcclxuICogQHBhcmFtIG5ld1NrZWxldG9uXHJcbiAqIEByZXR1cm5zIHRoZSBwYXJlbnQgYm9uZVxyXG4gKi9cclxuY29uc3QgR2V0UGFyZW50Qm9uZSA9IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBza2luczogSUdMVEZTa2lucywgam9pbnROYW1lOiBzdHJpbmcsIG5ld1NrZWxldG9uOiBTa2VsZXRvbik6IE51bGxhYmxlPEJvbmU+ID0+IHtcclxuICAgIC8vIFRyeSB0byBmaW5kXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1NrZWxldG9uLmJvbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKG5ld1NrZWxldG9uLmJvbmVzW2ldLm5hbWUgPT09IGpvaW50TmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2tlbGV0b24uYm9uZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdCBmb3VuZCwgc2VhcmNoIGluIGdsdGYgbm9kZXNcclxuICAgIGNvbnN0IG5vZGVzID0gZ2x0ZlJ1bnRpbWUubm9kZXM7XHJcbiAgICBmb3IgKGNvbnN0IG5kZSBpbiBub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IElHTFRGTm9kZSA9IG5vZGVzW25kZV07XHJcblxyXG4gICAgICAgIGlmICghbm9kZS5qb2ludE5hbWUpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSUdMVEZOb2RlID0gZ2x0ZlJ1bnRpbWUubm9kZXNbY2hpbGRyZW5baV1dO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkLmpvaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5qb2ludE5hbWUgPT09IGpvaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ID0gQ29uZmlndXJlQm9uZVRyYW5zZm9ybWF0aW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9uZSA9IG5ldyBCb25lKG5vZGUubmFtZSB8fCBcIlwiLCBuZXdTa2VsZXRvbiwgR2V0UGFyZW50Qm9uZShnbHRmUnVudGltZSwgc2tpbnMsIG5vZGUuam9pbnROYW1lLCBuZXdTa2VsZXRvbiksIG1hdCk7XHJcbiAgICAgICAgICAgICAgICBib25lLmlkID0gbmRlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgcm9vdCBub2RlXHJcbiAqIEBwYXJhbSBub2Rlc1RvUm9vdFxyXG4gKiBAcGFyYW0gaWRcclxuICogQHJldHVybnMgdGhlIHJvb3Qgbm9kZVxyXG4gKi9cclxuY29uc3QgR2V0Tm9kZVRvUm9vdCA9IChub2Rlc1RvUm9vdDogSU5vZGVUb1Jvb3RbXSwgaWQ6IHN0cmluZyk6IE51bGxhYmxlPEJvbmU+ID0+IHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb1Jvb3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBub2RlVG9Sb290ID0gbm9kZXNUb1Jvb3RbaV07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZVRvUm9vdC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZVRvUm9vdC5ub2RlLmNoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVRvUm9vdC5ib25lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5vZGUgd2l0aCB0aGUgam9pbnQgbmFtZVxyXG4gKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICogQHBhcmFtIGpvaW50TmFtZVxyXG4gKiBAcmV0dXJucyB0aGUgbm9kZSB3aXRoIHRoZSBqb2ludCBuYW1lXHJcbiAqL1xyXG5jb25zdCBHZXRKb2ludE5vZGUgPSAoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgam9pbnROYW1lOiBzdHJpbmcpOiBOdWxsYWJsZTxJSm9pbnROb2RlPiA9PiB7XHJcbiAgICBjb25zdCBub2RlcyA9IGdsdGZSdW50aW1lLm5vZGVzO1xyXG4gICAgbGV0IG5vZGU6IElHTFRGTm9kZSA9IG5vZGVzW2pvaW50TmFtZV07XHJcbiAgICBpZiAobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgIGlkOiBqb2ludE5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IG5kZSBpbiBub2Rlcykge1xyXG4gICAgICAgIG5vZGUgPSBub2Rlc1tuZGVdO1xyXG4gICAgICAgIGlmIChub2RlLmpvaW50TmFtZSA9PT0gam9pbnROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgaWQ6IG5kZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgbm9kZXMgaXMgaW4gam9pbnRzXHJcbiAqIEBwYXJhbSBza2luc1xyXG4gKiBAcGFyYW0gaWRcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBpbiBqb2ludHMsIGVsc2UgZmFsc2VcclxuICovXHJcbmNvbnN0IE5vZGVJc0luSm9pbnRzID0gKHNraW5zOiBJR0xURlNraW5zLCBpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNraW5zLmpvaW50TmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoc2tpbnMuam9pbnROYW1lc1tpXSA9PT0gaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaWxscyB0aGUgbm9kZXMgdG8gcm9vdCBmb3IgYm9uZXMgYW5kIGJ1aWxkcyBoaWVyYXJjaHlcclxuICogQHBhcmFtIGdsdGZSdW50aW1lXHJcbiAqIEBwYXJhbSBuZXdTa2VsZXRvblxyXG4gKiBAcGFyYW0gc2tpbnNcclxuICogQHBhcmFtIG5vZGVzVG9Sb290XHJcbiAqL1xyXG5jb25zdCBHZXROb2Rlc1RvUm9vdCA9IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBuZXdTa2VsZXRvbjogU2tlbGV0b24sIHNraW5zOiBJR0xURlNraW5zLCBub2Rlc1RvUm9vdDogSU5vZGVUb1Jvb3RbXSkgPT4ge1xyXG4gICAgLy8gQ3JlYXRlcyBub2RlcyBmb3Igcm9vdFxyXG4gICAgZm9yIChjb25zdCBuZGUgaW4gZ2x0ZlJ1bnRpbWUubm9kZXMpIHtcclxuICAgICAgICBjb25zdCBub2RlOiBJR0xURk5vZGUgPSBnbHRmUnVudGltZS5ub2Rlc1tuZGVdO1xyXG4gICAgICAgIGNvbnN0IGlkID0gbmRlO1xyXG5cclxuICAgICAgICBpZiAoIW5vZGUuam9pbnROYW1lIHx8IE5vZGVJc0luSm9pbnRzKHNraW5zLCBub2RlLmpvaW50TmFtZSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbm9kZSB0byByb290IGJvbmVcclxuICAgICAgICBjb25zdCBtYXQgPSBDb25maWd1cmVCb25lVHJhbnNmb3JtYXRpb24obm9kZSk7XHJcbiAgICAgICAgY29uc3QgYm9uZSA9IG5ldyBCb25lKG5vZGUubmFtZSB8fCBcIlwiLCBuZXdTa2VsZXRvbiwgbnVsbCwgbWF0KTtcclxuICAgICAgICBib25lLmlkID0gaWQ7XHJcbiAgICAgICAgbm9kZXNUb1Jvb3QucHVzaCh7IGJvbmU6IGJvbmUsIG5vZGU6IG5vZGUsIGlkOiBpZCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJlbnRpbmdcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb1Jvb3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBub2RlVG9Sb290ID0gbm9kZXNUb1Jvb3RbaV07XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlVG9Sb290Lm5vZGUuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkOiBOdWxsYWJsZTxJTm9kZVRvUm9vdD4gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBub2Rlc1RvUm9vdC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzVG9Sb290W2tdLmlkID09PSBjaGlsZHJlbltqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZXNUb1Jvb3Rba107XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+Y2hpbGQuYm9uZSkuX3BhcmVudCA9IG5vZGVUb1Jvb3QuYm9uZTtcclxuICAgICAgICAgICAgICAgIG5vZGVUb1Jvb3QuYm9uZS5jaGlsZHJlbi5wdXNoKGNoaWxkLmJvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEltcG9ydHMgYSBza2VsZXRvblxyXG4gKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICogQHBhcmFtIHNraW5zXHJcbiAqIEBwYXJhbSBtZXNoXHJcbiAqIEBwYXJhbSBuZXdTa2VsZXRvblxyXG4gKiBAcmV0dXJucyB0aGUgYm9uZSBuYW1lXHJcbiAqL1xyXG5jb25zdCBJbXBvcnRTa2VsZXRvbiA9IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBza2luczogSUdMVEZTa2lucywgbWVzaDogTWVzaCwgbmV3U2tlbGV0b246IFNrZWxldG9uIHwgdW5kZWZpbmVkKTogU2tlbGV0b24gPT4ge1xyXG4gICAgaWYgKCFuZXdTa2VsZXRvbikge1xyXG4gICAgICAgIG5ld1NrZWxldG9uID0gbmV3IFNrZWxldG9uKHNraW5zLm5hbWUgfHwgXCJcIiwgXCJcIiwgZ2x0ZlJ1bnRpbWUuc2NlbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghc2tpbnMuYmFieWxvblNrZWxldG9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1NrZWxldG9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgdGhlIHJvb3QgYm9uZXNcclxuICAgIGNvbnN0IG5vZGVzVG9Sb290OiBJTm9kZVRvUm9vdFtdID0gW107XHJcbiAgICBjb25zdCBub2Rlc1RvUm9vdFRvQWRkOiBCb25lW10gPSBbXTtcclxuXHJcbiAgICBHZXROb2Rlc1RvUm9vdChnbHRmUnVudGltZSwgbmV3U2tlbGV0b24sIHNraW5zLCBub2Rlc1RvUm9vdCk7XHJcbiAgICBuZXdTa2VsZXRvbi5ib25lcyA9IFtdO1xyXG5cclxuICAgIC8vIEpvaW50c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBza2lucy5qb2ludE5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgam9pbnROb2RlID0gR2V0Sm9pbnROb2RlKGdsdGZSdW50aW1lLCBza2lucy5qb2ludE5hbWVzW2ldKTtcclxuXHJcbiAgICAgICAgaWYgKCFqb2ludE5vZGUpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBub2RlID0gam9pbnROb2RlLm5vZGU7XHJcblxyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICBUb29scy5XYXJuKFwiSm9pbnQgbmFtZWQgXCIgKyBza2lucy5qb2ludE5hbWVzW2ldICsgXCIgZG9lcyBub3QgZXhpc3RcIik7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaWQgPSBqb2ludE5vZGUuaWQ7XHJcblxyXG4gICAgICAgIC8vIE9wdGltaXplLCBpZiB0aGUgYm9uZSBhbHJlYWR5IGV4aXN0cy4uLlxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQm9uZSA9IGdsdGZSdW50aW1lLnNjZW5lLmdldEJvbmVCeUlkKGlkKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdCb25lKSB7XHJcbiAgICAgICAgICAgIG5ld1NrZWxldG9uLmJvbmVzLnB1c2goZXhpc3RpbmdCb25lKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZWFyY2ggZm9yIHBhcmVudCBib25lXHJcbiAgICAgICAgbGV0IGZvdW5kQm9uZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBwYXJlbnRCb25lOiBOdWxsYWJsZTxCb25lPiA9IG51bGw7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvaW50Tm9kZSA9IEdldEpvaW50Tm9kZShnbHRmUnVudGltZSwgc2tpbnMuam9pbnROYW1lc1tqXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWpvaW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGpvaW50OiBJR0xURk5vZGUgPSBqb2ludE5vZGUubm9kZTtcclxuXHJcbiAgICAgICAgICAgIGlmICgham9pbnQpIHtcclxuICAgICAgICAgICAgICAgIFRvb2xzLldhcm4oXCJKb2ludCBuYW1lZCBcIiArIHNraW5zLmpvaW50TmFtZXNbal0gKyBcIiBkb2VzIG5vdCBleGlzdCB3aGVuIGxvb2tpbmcgZm9yIHBhcmVudFwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGpvaW50LmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3VuZEJvbmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2hpbGRyZW4ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltrXSA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRCb25lID0gR2V0UGFyZW50Qm9uZShnbHRmUnVudGltZSwgc2tpbnMsIHNraW5zLmpvaW50TmFtZXNbal0sIG5ld1NrZWxldG9uKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZEJvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm91bmRCb25lKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGJvbmVcclxuICAgICAgICBjb25zdCBtYXQgPSBDb25maWd1cmVCb25lVHJhbnNmb3JtYXRpb24obm9kZSk7XHJcblxyXG4gICAgICAgIGlmICghcGFyZW50Qm9uZSAmJiBub2Rlc1RvUm9vdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEJvbmUgPSBHZXROb2RlVG9Sb290KG5vZGVzVG9Sb290LCBpZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyZW50Qm9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzVG9Sb290VG9BZGQuaW5kZXhPZihwYXJlbnRCb25lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUm9vdFRvQWRkLnB1c2gocGFyZW50Qm9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJvbmUgPSBuZXcgQm9uZShub2RlLmpvaW50TmFtZSB8fCBcIlwiLCBuZXdTa2VsZXRvbiwgcGFyZW50Qm9uZSwgbWF0KTtcclxuICAgICAgICBib25lLmlkID0gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUG9saXNoXHJcbiAgICBjb25zdCBib25lcyA9IG5ld1NrZWxldG9uLmJvbmVzO1xyXG4gICAgbmV3U2tlbGV0b24uYm9uZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNraW5zLmpvaW50TmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBqb2ludE5vZGUgPSBHZXRKb2ludE5vZGUoZ2x0ZlJ1bnRpbWUsIHNraW5zLmpvaW50TmFtZXNbaV0pO1xyXG5cclxuICAgICAgICBpZiAoIWpvaW50Tm9kZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYm9uZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGJvbmVzW2pdLmlkID09PSBqb2ludE5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NrZWxldG9uLmJvbmVzLnB1c2goYm9uZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmV3U2tlbGV0b24ucHJlcGFyZSgpO1xyXG5cclxuICAgIC8vIEZpbmlzaFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvUm9vdFRvQWRkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbmV3U2tlbGV0b24uYm9uZXMucHVzaChub2Rlc1RvUm9vdFRvQWRkW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3U2tlbGV0b247XHJcbn07XHJcblxyXG4vKipcclxuICogSW1wb3J0cyBhIG1lc2ggYW5kIGl0cyBnZW9tZXRyaWVzXHJcbiAqIEBwYXJhbSBnbHRmUnVudGltZVxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKiBAcGFyYW0gbWVzaGVzXHJcbiAqIEBwYXJhbSBpZFxyXG4gKiBAcGFyYW0gbmV3TWVzaFxyXG4gKiBAcmV0dXJucyB0aGUgbmV3IG1lc2hcclxuICovXHJcbmNvbnN0IEltcG9ydE1lc2ggPSAoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgbm9kZTogSUdMVEZOb2RlLCBtZXNoZXM6IHN0cmluZ1tdLCBpZDogc3RyaW5nLCBuZXdNZXNoOiBNZXNoKTogTWVzaCA9PiB7XHJcbiAgICBpZiAoIW5ld01lc2gpIHtcclxuICAgICAgICBnbHRmUnVudGltZS5zY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISFnbHRmUnVudGltZS5hc3NldENvbnRhaW5lcjtcclxuICAgICAgICBuZXdNZXNoID0gbmV3IE1lc2gobm9kZS5uYW1lIHx8IFwiXCIsIGdsdGZSdW50aW1lLnNjZW5lKTtcclxuICAgICAgICBuZXdNZXNoLl9wYXJlbnRDb250YWluZXIgPSBnbHRmUnVudGltZS5hc3NldENvbnRhaW5lcjtcclxuICAgICAgICBnbHRmUnVudGltZS5zY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgbmV3TWVzaC5pZCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbm9kZS5iYWJ5bG9uTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXdNZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN1Yk1hdGVyaWFsczogTWF0ZXJpYWxbXSA9IFtdO1xyXG5cclxuICAgIGxldCB2ZXJ0ZXhEYXRhOiBOdWxsYWJsZTxWZXJ0ZXhEYXRhPiA9IG51bGw7XHJcbiAgICBjb25zdCB2ZXJ0aWNlc1N0YXJ0czogbnVtYmVyW10gPSBbXTtcclxuICAgIGNvbnN0IHZlcnRpY2VzQ291bnRzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgY29uc3QgaW5kZXhTdGFydHM6IG51bWJlcltdID0gW107XHJcbiAgICBjb25zdCBpbmRleENvdW50czogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBtZXNoSW5kZXggPSAwOyBtZXNoSW5kZXggPCBtZXNoZXMubGVuZ3RoOyBtZXNoSW5kZXgrKykge1xyXG4gICAgICAgIGNvbnN0IG1lc2hJZCA9IG1lc2hlc1ttZXNoSW5kZXhdO1xyXG4gICAgICAgIGNvbnN0IG1lc2g6IElHTFRGTWVzaCA9IGdsdGZSdW50aW1lLm1lc2hlc1ttZXNoSWRdO1xyXG5cclxuICAgICAgICBpZiAoIW1lc2gpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQb3NpdGlvbnMsIG5vcm1hbHMgYW5kIFVWc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaC5wcmltaXRpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRlbXBvcmFyeSB2ZXJ0ZXggZGF0YVxyXG4gICAgICAgICAgICBjb25zdCB0ZW1wVmVydGV4RGF0YSA9IG5ldyBWZXJ0ZXhEYXRhKCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBtZXNoLnByaW1pdGl2ZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSAhPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmUuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgbGV0IGFjY2Vzc29yOiBOdWxsYWJsZTxJR0xURkFjY2Vzc29yPiA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBidWZmZXI6IGFueSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgcG9zaXRpb25zLCBub3JtYWwgYW5kIHV2c1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlbWFudGljIGluIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIExpbmsgYWNjZXNzb3IgYW5kIGJ1ZmZlciB2aWV3XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IGdsdGZSdW50aW1lLmFjY2Vzc29yc1thdHRyaWJ1dGVzW3NlbWFudGljXV07XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBHTFRGVXRpbHMuR2V0QnVmZmVyRnJvbUFjY2Vzc29yKGdsdGZSdW50aW1lLCBhY2Nlc3Nvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbWFudGljID09PSBcIk5PUk1BTFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRleERhdGEubm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxGbG9hdDMyQXJyYXk+dGVtcFZlcnRleERhdGEubm9ybWFscykuc2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbWFudGljID09PSBcIlBPU0lUSU9OXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoR0xURkZpbGVMb2FkZXIuSG9tb2dlbmVvdXNDb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wVmVydGV4RGF0YS5wb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGggLSBidWZmZXIubGVuZ3RoIC8gNCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ1ZmZlci5sZW5ndGg7IGogKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRleERhdGEucG9zaXRpb25zW2pdID0gYnVmZmVyW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRleERhdGEucG9zaXRpb25zW2ogKyAxXSA9IGJ1ZmZlcltqICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wVmVydGV4RGF0YS5wb3NpdGlvbnNbaiArIDJdID0gYnVmZmVyW2ogKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBWZXJ0ZXhEYXRhLnBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICg8RmxvYXQzMkFycmF5PnRlbXBWZXJ0ZXhEYXRhLnBvc2l0aW9ucykuc2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc0NvdW50cy5wdXNoKHRlbXBWZXJ0ZXhEYXRhLnBvc2l0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZW1hbnRpYy5pbmRleE9mKFwiVEVYQ09PUkRfXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBOdW1iZXIoc2VtYW50aWMuc3BsaXQoXCJfXCIpWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1dktpbmQgPSBWZXJ0ZXhCdWZmZXIuVVZLaW5kICsgKGNoYW5uZWwgPT09IDAgPyBcIlwiIDogY2hhbm5lbCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxGbG9hdDMyQXJyYXk+dXZzKS5zZXQoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBOb3JtYWxpemVVVnModXZzKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wVmVydGV4RGF0YS5zZXQodXZzLCB1dktpbmQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZW1hbnRpYyA9PT0gXCJKT0lOVFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRleERhdGEubWF0cmljZXNJbmRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAoPEZsb2F0MzJBcnJheT50ZW1wVmVydGV4RGF0YS5tYXRyaWNlc0luZGljZXMpLnNldChidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZW1hbnRpYyA9PT0gXCJXRUlHSFRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZXJ0ZXhEYXRhLm1hdHJpY2VzV2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxGbG9hdDMyQXJyYXk+dGVtcFZlcnRleERhdGEubWF0cmljZXNXZWlnaHRzKS5zZXQoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VtYW50aWMgPT09IFwiQ09MT1JcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZXJ0ZXhEYXRhLmNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxGbG9hdDMyQXJyYXk+dGVtcFZlcnRleERhdGEuY29sb3JzKS5zZXQoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5kaWNlc1xyXG4gICAgICAgICAgICBhY2Nlc3NvciA9IGdsdGZSdW50aW1lLmFjY2Vzc29yc1twcmltaXRpdmUuaW5kaWNlc107XHJcbiAgICAgICAgICAgIGlmIChhY2Nlc3Nvcikge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gR0xURlV0aWxzLkdldEJ1ZmZlckZyb21BY2Nlc3NvcihnbHRmUnVudGltZSwgYWNjZXNzb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRlbXBWZXJ0ZXhEYXRhLmluZGljZXMgPSBuZXcgSW50MzJBcnJheShidWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHRlbXBWZXJ0ZXhEYXRhLmluZGljZXMuc2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBpbmRleENvdW50cy5wdXNoKHRlbXBWZXJ0ZXhEYXRhLmluZGljZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBpbmRpY2VzIG9uIHRoZSBmbHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGljZXM6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8ICg8RmxvYXRBcnJheT50ZW1wVmVydGV4RGF0YS5wb3NpdGlvbnMpLmxlbmd0aCAvIDM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0ZW1wVmVydGV4RGF0YS5pbmRpY2VzID0gbmV3IEludDMyQXJyYXkoaW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICBpbmRleENvdW50cy5wdXNoKHRlbXBWZXJ0ZXhEYXRhLmluZGljZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF2ZXJ0ZXhEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhID0gdGVtcFZlcnRleERhdGE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhLm1lcmdlKHRlbXBWZXJ0ZXhEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3ViIG1hdGVyaWFsXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gZ2x0ZlJ1bnRpbWUuc2NlbmUuZ2V0TWF0ZXJpYWxCeUlkKHByaW1pdGl2ZS5tYXRlcmlhbCk7XHJcblxyXG4gICAgICAgICAgICBzdWJNYXRlcmlhbHMucHVzaChtYXRlcmlhbCA9PT0gbnVsbCA/IEdMVEZVdGlscy5HZXREZWZhdWx0TWF0ZXJpYWwoZ2x0ZlJ1bnRpbWUuc2NlbmUpIDogbWF0ZXJpYWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnRpY2VzIHN0YXJ0IGFuZCBpbmRleCBzdGFydFxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1N0YXJ0cy5wdXNoKHZlcnRpY2VzU3RhcnRzLmxlbmd0aCA9PT0gMCA/IDAgOiB2ZXJ0aWNlc1N0YXJ0c1t2ZXJ0aWNlc1N0YXJ0cy5sZW5ndGggLSAxXSArIHZlcnRpY2VzQ291bnRzW3ZlcnRpY2VzQ291bnRzLmxlbmd0aCAtIDJdKTtcclxuICAgICAgICAgICAgaW5kZXhTdGFydHMucHVzaChpbmRleFN0YXJ0cy5sZW5ndGggPT09IDAgPyAwIDogaW5kZXhTdGFydHNbaW5kZXhTdGFydHMubGVuZ3RoIC0gMV0gKyBpbmRleENvdW50c1tpbmRleENvdW50cy5sZW5ndGggLSAyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG1hdGVyaWFsOiBTdGFuZGFyZE1hdGVyaWFsIHwgTXVsdGlNYXRlcmlhbDtcclxuICAgIGdsdGZSdW50aW1lLnNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIWdsdGZSdW50aW1lLmFzc2V0Q29udGFpbmVyO1xyXG4gICAgaWYgKHN1Yk1hdGVyaWFscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgbWF0ZXJpYWwgPSBuZXcgTXVsdGlNYXRlcmlhbChcIm11bHRpbWF0XCIgKyBpZCwgZ2x0ZlJ1bnRpbWUuc2NlbmUpO1xyXG4gICAgICAgIG1hdGVyaWFsLnN1Yk1hdGVyaWFscyA9IHN1Yk1hdGVyaWFscztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWF0ZXJpYWwgPSBuZXcgU3RhbmRhcmRNYXRlcmlhbChcIm11bHRpbWF0XCIgKyBpZCwgZ2x0ZlJ1bnRpbWUuc2NlbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdWJNYXRlcmlhbHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgbWF0ZXJpYWwgPSBzdWJNYXRlcmlhbHNbMF0gYXMgU3RhbmRhcmRNYXRlcmlhbDtcclxuICAgIH1cclxuXHJcbiAgICBtYXRlcmlhbC5fcGFyZW50Q29udGFpbmVyID0gZ2x0ZlJ1bnRpbWUuYXNzZXRDb250YWluZXI7XHJcblxyXG4gICAgaWYgKCFuZXdNZXNoLm1hdGVyaWFsKSB7XHJcbiAgICAgICAgbmV3TWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFwcGx5IGdlb21ldHJ5XHJcbiAgICBuZXcgR2VvbWV0cnkoaWQsIGdsdGZSdW50aW1lLnNjZW5lLCB2ZXJ0ZXhEYXRhISwgZmFsc2UsIG5ld01lc2gpO1xyXG4gICAgbmV3TWVzaC5jb21wdXRlV29ybGRNYXRyaXgodHJ1ZSk7XHJcblxyXG4gICAgZ2x0ZlJ1bnRpbWUuc2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEFwcGx5IHN1Ym1lc2hlc1xyXG4gICAgbmV3TWVzaC5zdWJNZXNoZXMgPSBbXTtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICBmb3IgKGxldCBtZXNoSW5kZXggPSAwOyBtZXNoSW5kZXggPCBtZXNoZXMubGVuZ3RoOyBtZXNoSW5kZXgrKykge1xyXG4gICAgICAgIGNvbnN0IG1lc2hJZCA9IG1lc2hlc1ttZXNoSW5kZXhdO1xyXG4gICAgICAgIGNvbnN0IG1lc2g6IElHTFRGTWVzaCA9IGdsdGZSdW50aW1lLm1lc2hlc1ttZXNoSWRdO1xyXG5cclxuICAgICAgICBpZiAoIW1lc2gpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc2gucHJpbWl0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobWVzaC5wcmltaXRpdmVzW2ldLm1vZGUgIT09IDQpIHtcclxuICAgICAgICAgICAgICAgIC8vY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFN1Yk1lc2guQWRkVG9NZXNoKGluZGV4LCB2ZXJ0aWNlc1N0YXJ0c1tpbmRleF0sIHZlcnRpY2VzQ291bnRzW2luZGV4XSwgaW5kZXhTdGFydHNbaW5kZXhdLCBpbmRleENvdW50c1tpbmRleF0sIG5ld01lc2gsIG5ld01lc2gsIHRydWUpO1xyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5pc2hcclxuICAgIHJldHVybiBuZXdNZXNoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbmZpZ3VyZSBub2RlIHRyYW5zZm9ybWF0aW9uIGZyb20gcG9zaXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nXHJcbiAqIEBwYXJhbSBuZXdOb2RlXHJcbiAqIEBwYXJhbSBwb3NpdGlvblxyXG4gKiBAcGFyYW0gcm90YXRpb25cclxuICogQHBhcmFtIHNjYWxpbmdcclxuICovXHJcbmNvbnN0IENvbmZpZ3VyZU5vZGUgPSAobmV3Tm9kZTogYW55LCBwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHNjYWxpbmc6IFZlY3RvcjMpID0+IHtcclxuICAgIGlmIChuZXdOb2RlLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgbmV3Tm9kZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuZXdOb2RlLnJvdGF0aW9uUXVhdGVybmlvbiB8fCBuZXdOb2RlLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgbmV3Tm9kZS5yb3RhdGlvblF1YXRlcm5pb24gPSByb3RhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV3Tm9kZS5zY2FsaW5nKSB7XHJcbiAgICAgICAgbmV3Tm9kZS5zY2FsaW5nID0gc2NhbGluZztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIG5vZGUgZnJvbSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICogQHBhcmFtIG5ld05vZGVcclxuICogQHBhcmFtIG5vZGVcclxuICovXHJcbmNvbnN0IENvbmZpZ3VyZU5vZGVGcm9tTWF0cml4ID0gKG5ld05vZGU6IE1lc2gsIG5vZGU6IElHTFRGTm9kZSkgPT4ge1xyXG4gICAgaWYgKG5vZGUubWF0cml4KSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGluZyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IE1hdHJpeC5Gcm9tQXJyYXkobm9kZS5tYXRyaXgpO1xyXG4gICAgICAgIG1hdC5kZWNvbXBvc2Uoc2NhbGluZywgcm90YXRpb24sIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgQ29uZmlndXJlTm9kZShuZXdOb2RlLCBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxpbmcpO1xyXG4gICAgfSBlbHNlIGlmIChub2RlLnRyYW5zbGF0aW9uICYmIG5vZGUucm90YXRpb24gJiYgbm9kZS5zY2FsZSkge1xyXG4gICAgICAgIENvbmZpZ3VyZU5vZGUobmV3Tm9kZSwgVmVjdG9yMy5Gcm9tQXJyYXkobm9kZS50cmFuc2xhdGlvbiksIFF1YXRlcm5pb24uRnJvbUFycmF5KG5vZGUucm90YXRpb24pLCBWZWN0b3IzLkZyb21BcnJheShub2RlLnNjYWxlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmV3Tm9kZS5jb21wdXRlV29ybGRNYXRyaXgodHJ1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW1wb3J0cyBhIG5vZGVcclxuICogQHBhcmFtIGdsdGZSdW50aW1lXHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqIEBwYXJhbSBpZFxyXG4gKiBAcmV0dXJucyB0aGUgbmV3bHkgaW1wb3J0ZWQgbm9kZVxyXG4gKi9cclxuY29uc3QgSW1wb3J0Tm9kZSA9IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBub2RlOiBJR0xURk5vZGUsIGlkOiBzdHJpbmcpOiBOdWxsYWJsZTxOb2RlPiA9PiB7XHJcbiAgICBsZXQgbGFzdE5vZGU6IE51bGxhYmxlPE5vZGU+ID0gbnVsbDtcclxuXHJcbiAgICBpZiAoZ2x0ZlJ1bnRpbWUuaW1wb3J0T25seU1lc2hlcyAmJiAobm9kZS5za2luIHx8IG5vZGUubWVzaGVzKSkge1xyXG4gICAgICAgIGlmIChnbHRmUnVudGltZS5pbXBvcnRNZXNoZXNOYW1lcyAmJiBnbHRmUnVudGltZS5pbXBvcnRNZXNoZXNOYW1lcy5sZW5ndGggPiAwICYmIGdsdGZSdW50aW1lLmltcG9ydE1lc2hlc05hbWVzLmluZGV4T2Yobm9kZS5uYW1lIHx8IFwiXCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWVzaGVzXHJcbiAgICBpZiAobm9kZS5za2luKSB7XHJcbiAgICAgICAgaWYgKG5vZGUubWVzaGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNraW46IElHTFRGU2tpbnMgPSBnbHRmUnVudGltZS5za2luc1tub2RlLnNraW5dO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmV3TWVzaCA9IEltcG9ydE1lc2goZ2x0ZlJ1bnRpbWUsIG5vZGUsIG5vZGUubWVzaGVzLCBpZCwgPE1lc2g+bm9kZS5iYWJ5bG9uTm9kZSk7XHJcbiAgICAgICAgICAgIG5ld01lc2guc2tlbGV0b24gPSBnbHRmUnVudGltZS5zY2VuZS5nZXRMYXN0U2tlbGV0b25CeUlkKG5vZGUuc2tpbik7XHJcblxyXG4gICAgICAgICAgICBpZiAobmV3TWVzaC5za2VsZXRvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3TWVzaC5za2VsZXRvbiA9IEltcG9ydFNrZWxldG9uKGdsdGZSdW50aW1lLCBza2luLCBuZXdNZXNoLCBza2luLmJhYnlsb25Ta2VsZXRvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFza2luLmJhYnlsb25Ta2VsZXRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNraW4uYmFieWxvblNrZWxldG9uID0gbmV3TWVzaC5za2VsZXRvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFzdE5vZGUgPSBuZXdNZXNoO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobm9kZS5tZXNoZXMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXByb3ZlIG1lc2hlcyBwcm9wZXJ0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IG5ld01lc2ggPSBJbXBvcnRNZXNoKGdsdGZSdW50aW1lLCBub2RlLCBub2RlLm1lc2ggPyBbbm9kZS5tZXNoXSA6IG5vZGUubWVzaGVzLCBpZCwgPE1lc2g+bm9kZS5iYWJ5bG9uTm9kZSk7XHJcbiAgICAgICAgbGFzdE5vZGUgPSBuZXdNZXNoO1xyXG4gICAgfVxyXG4gICAgLy8gTGlnaHRzXHJcbiAgICBlbHNlIGlmIChub2RlLmxpZ2h0ICYmICFub2RlLmJhYnlsb25Ob2RlICYmICFnbHRmUnVudGltZS5pbXBvcnRPbmx5TWVzaGVzKSB7XHJcbiAgICAgICAgY29uc3QgbGlnaHQ6IElHTFRGTGlnaHQgPSBnbHRmUnVudGltZS5saWdodHNbbm9kZS5saWdodF07XHJcblxyXG4gICAgICAgIGlmIChsaWdodCkge1xyXG4gICAgICAgICAgICBpZiAobGlnaHQudHlwZSA9PT0gXCJhbWJpZW50XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFtYmllbkxpZ2h0OiBJR0xURkFtYmllbkxpZ2h0ID0gKDxhbnk+bGlnaHQpW2xpZ2h0LnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVtaUxpZ2h0ID0gbmV3IEhlbWlzcGhlcmljTGlnaHQobm9kZS5saWdodCwgVmVjdG9yMy5aZXJvKCksIGdsdGZSdW50aW1lLnNjZW5lKTtcclxuICAgICAgICAgICAgICAgIGhlbWlMaWdodC5uYW1lID0gbm9kZS5uYW1lIHx8IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFtYmllbkxpZ2h0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVtaUxpZ2h0LmRpZmZ1c2UgPSBDb2xvcjMuRnJvbUFycmF5KGFtYmllbkxpZ2h0LmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IGhlbWlMaWdodDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaWdodC50eXBlID09PSBcImRpcmVjdGlvbmFsXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsTGlnaHQ6IElHTFRGRGlyZWN0aW9uYWxMaWdodCA9ICg8YW55PmxpZ2h0KVtsaWdodC50eXBlXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpckxpZ2h0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQobm9kZS5saWdodCwgVmVjdG9yMy5aZXJvKCksIGdsdGZSdW50aW1lLnNjZW5lKTtcclxuICAgICAgICAgICAgICAgIGRpckxpZ2h0Lm5hbWUgPSBub2RlLm5hbWUgfHwgXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uYWxMaWdodC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpckxpZ2h0LmRpZmZ1c2UgPSBDb2xvcjMuRnJvbUFycmF5KGRpcmVjdGlvbmFsTGlnaHQuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gZGlyTGlnaHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlnaHQudHlwZSA9PT0gXCJwb2ludFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludExpZ2h0OiBJR0xURlBvaW50TGlnaHQgPSAoPGFueT5saWdodClbbGlnaHQudHlwZV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdExpZ2h0ID0gbmV3IFBvaW50TGlnaHQobm9kZS5saWdodCwgVmVjdG9yMy5aZXJvKCksIGdsdGZSdW50aW1lLnNjZW5lKTtcclxuICAgICAgICAgICAgICAgIHB0TGlnaHQubmFtZSA9IG5vZGUubmFtZSB8fCBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludExpZ2h0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRMaWdodC5kaWZmdXNlID0gQ29sb3IzLkZyb21BcnJheShwb2ludExpZ2h0LmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IHB0TGlnaHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlnaHQudHlwZSA9PT0gXCJzcG90XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwb3RMaWdodDogSUdMVEZTcG90TGlnaHQgPSAoPGFueT5saWdodClbbGlnaHQudHlwZV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcExpZ2h0ID0gbmV3IFNwb3RMaWdodChub2RlLmxpZ2h0LCBWZWN0b3IzLlplcm8oKSwgVmVjdG9yMy5aZXJvKCksIDAsIDAsIGdsdGZSdW50aW1lLnNjZW5lKTtcclxuICAgICAgICAgICAgICAgIHNwTGlnaHQubmFtZSA9IG5vZGUubmFtZSB8fCBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzcG90TGlnaHQuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcExpZ2h0LmRpZmZ1c2UgPSBDb2xvcjMuRnJvbUFycmF5KHNwb3RMaWdodC5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwb3RMaWdodC5mYWxsT2ZBbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwTGlnaHQuYW5nbGUgPSBzcG90TGlnaHQuZmFsbE9mQW5nbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwb3RMaWdodC5mYWxsT2ZmRXhwb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcExpZ2h0LmV4cG9uZW50ID0gc3BvdExpZ2h0LmZhbGxPZmZFeHBvbmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IHNwTGlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYW1lcmFzXHJcbiAgICBlbHNlIGlmIChub2RlLmNhbWVyYSAmJiAhbm9kZS5iYWJ5bG9uTm9kZSAmJiAhZ2x0ZlJ1bnRpbWUuaW1wb3J0T25seU1lc2hlcykge1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYTogSUdMVEZDYW1lcmEgPSBnbHRmUnVudGltZS5jYW1lcmFzW25vZGUuY2FtZXJhXTtcclxuXHJcbiAgICAgICAgaWYgKGNhbWVyYSkge1xyXG4gICAgICAgICAgICBnbHRmUnVudGltZS5zY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISFnbHRmUnVudGltZS5hc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgaWYgKGNhbWVyYS50eXBlID09PSBcIm9ydGhvZ3JhcGhpY1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcnRob0NhbWVyYSA9IG5ldyBGcmVlQ2FtZXJhKG5vZGUuY2FtZXJhLCBWZWN0b3IzLlplcm8oKSwgZ2x0ZlJ1bnRpbWUuc2NlbmUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvcnRob0NhbWVyYS5uYW1lID0gbm9kZS5uYW1lIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBvcnRob0NhbWVyYS5tb2RlID0gQ2FtZXJhLk9SVEhPR1JBUEhJQ19DQU1FUkE7XHJcbiAgICAgICAgICAgICAgICBvcnRob0NhbWVyYS5hdHRhY2hDb250cm9sKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBvcnRob0NhbWVyYTtcclxuXHJcbiAgICAgICAgICAgICAgICBvcnRob0NhbWVyYS5fcGFyZW50Q29udGFpbmVyID0gZ2x0ZlJ1bnRpbWUuYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FtZXJhLnR5cGUgPT09IFwicGVyc3BlY3RpdmVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyc3BlY3RpdmVDYW1lcmE6IElHTFRGQ2FtZXJhUGVyc3BlY3RpdmUgPSAoPGFueT5jYW1lcmEpW2NhbWVyYS50eXBlXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcnNDYW1lcmEgPSBuZXcgRnJlZUNhbWVyYShub2RlLmNhbWVyYSwgVmVjdG9yMy5aZXJvKCksIGdsdGZSdW50aW1lLnNjZW5lLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcGVyc0NhbWVyYS5uYW1lID0gbm9kZS5uYW1lIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBwZXJzQ2FtZXJhLmF0dGFjaENvbnRyb2woKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBlcnNwZWN0aXZlQ2FtZXJhLmFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyc3BlY3RpdmVDYW1lcmEuYXNwZWN0UmF0aW8gPSBnbHRmUnVudGltZS5zY2VuZS5nZXRFbmdpbmUoKS5nZXRSZW5kZXJXaWR0aCgpIC8gZ2x0ZlJ1bnRpbWUuc2NlbmUuZ2V0RW5naW5lKCkuZ2V0UmVuZGVySGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBlcnNwZWN0aXZlQ2FtZXJhLnpuZWFyICYmIHBlcnNwZWN0aXZlQ2FtZXJhLnpmYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwZXJzQ2FtZXJhLm1heFogPSBwZXJzcGVjdGl2ZUNhbWVyYS56ZmFyO1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNDYW1lcmEubWluWiA9IHBlcnNwZWN0aXZlQ2FtZXJhLnpuZWFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gcGVyc0NhbWVyYTtcclxuICAgICAgICAgICAgICAgIHBlcnNDYW1lcmEuX3BhcmVudENvbnRhaW5lciA9IGdsdGZSdW50aW1lLmFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbHRmUnVudGltZS5zY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEVtcHR5IG5vZGVcclxuICAgIGlmICghbm9kZS5qb2ludE5hbWUpIHtcclxuICAgICAgICBpZiAobm9kZS5iYWJ5bG9uTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5iYWJ5bG9uTm9kZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3ROb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGdsdGZSdW50aW1lLnNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIWdsdGZSdW50aW1lLmFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCBkdW1teSA9IG5ldyBNZXNoKG5vZGUubmFtZSB8fCBcIlwiLCBnbHRmUnVudGltZS5zY2VuZSk7XHJcbiAgICAgICAgICAgIGR1bW15Ll9wYXJlbnRDb250YWluZXIgPSBnbHRmUnVudGltZS5hc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUuc2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBub2RlLmJhYnlsb25Ob2RlID0gZHVtbXk7XHJcbiAgICAgICAgICAgIGxhc3ROb2RlID0gZHVtbXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsYXN0Tm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChub2RlLm1hdHJpeCAmJiBsYXN0Tm9kZSBpbnN0YW5jZW9mIE1lc2gpIHtcclxuICAgICAgICAgICAgQ29uZmlndXJlTm9kZUZyb21NYXRyaXgobGFzdE5vZGUsIG5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gbm9kZS50cmFuc2xhdGlvbiB8fCBbMCwgMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbiB8fCBbMCwgMCwgMCwgMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gbm9kZS5zY2FsZSB8fCBbMSwgMSwgMV07XHJcbiAgICAgICAgICAgIENvbmZpZ3VyZU5vZGUobGFzdE5vZGUsIFZlY3RvcjMuRnJvbUFycmF5KHRyYW5zbGF0aW9uKSwgUXVhdGVybmlvbi5Gcm9tQXJyYXkocm90YXRpb24pLCBWZWN0b3IzLkZyb21BcnJheShzY2FsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGFzdE5vZGUudXBkYXRlQ2FjaGUodHJ1ZSk7XHJcbiAgICAgICAgbm9kZS5iYWJ5bG9uTm9kZSA9IGxhc3ROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXN0Tm9kZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZXMgbm9kZXMgYW5kIGNyZWF0ZXMgdGhlbVxyXG4gKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICogQHBhcmFtIGlkXHJcbiAqIEBwYXJhbSBwYXJlbnRcclxuICogQHBhcmFtIG1lc2hJbmNsdWRlZFxyXG4gKi9cclxuY29uc3QgVHJhdmVyc2VOb2RlcyA9IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBpZDogc3RyaW5nLCBwYXJlbnQ6IE51bGxhYmxlPE5vZGU+LCBtZXNoSW5jbHVkZWQ6IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xyXG4gICAgY29uc3Qgbm9kZTogSUdMVEZOb2RlID0gZ2x0ZlJ1bnRpbWUubm9kZXNbaWRdO1xyXG4gICAgbGV0IG5ld05vZGU6IE51bGxhYmxlPE5vZGU+ID0gbnVsbDtcclxuXHJcbiAgICBpZiAoZ2x0ZlJ1bnRpbWUuaW1wb3J0T25seU1lc2hlcyAmJiAhbWVzaEluY2x1ZGVkICYmIGdsdGZSdW50aW1lLmltcG9ydE1lc2hlc05hbWVzKSB7XHJcbiAgICAgICAgaWYgKGdsdGZSdW50aW1lLmltcG9ydE1lc2hlc05hbWVzLmluZGV4T2Yobm9kZS5uYW1lIHx8IFwiXCIpICE9PSAtMSB8fCBnbHRmUnVudGltZS5pbXBvcnRNZXNoZXNOYW1lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbWVzaEluY2x1ZGVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNoSW5jbHVkZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1lc2hJbmNsdWRlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFub2RlLmpvaW50TmFtZSAmJiBtZXNoSW5jbHVkZWQpIHtcclxuICAgICAgICBuZXdOb2RlID0gSW1wb3J0Tm9kZShnbHRmUnVudGltZSwgbm9kZSwgaWQpO1xyXG5cclxuICAgICAgICBpZiAobmV3Tm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBuZXdOb2RlLmlkID0gaWQ7XHJcbiAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBUcmF2ZXJzZU5vZGVzKGdsdGZSdW50aW1lLCBub2RlLmNoaWxkcmVuW2ldLCBuZXdOb2RlLCBtZXNoSW5jbHVkZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBkbyBzdHVmZiBhZnRlciBidWZmZXJzLCBzaGFkZXJzIGFyZSBsb2FkZWQgKGUuZy4gaG9vayB1cCBtYXRlcmlhbHMsIGxvYWQgYW5pbWF0aW9ucywgZXRjLilcclxuICogQHBhcmFtIGdsdGZSdW50aW1lXHJcbiAqL1xyXG5jb25zdCBQb3N0TG9hZCA9IChnbHRmUnVudGltZTogSUdMVEZSdW50aW1lKSA9PiB7XHJcbiAgICAvLyBOb2Rlc1xyXG4gICAgbGV0IGN1cnJlbnRTY2VuZTogSUdMVEZTY2VuZSA9IDxJR0xURlNjZW5lPmdsdGZSdW50aW1lLmN1cnJlbnRTY2VuZTtcclxuXHJcbiAgICBpZiAoY3VycmVudFNjZW5lKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50U2NlbmUubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgVHJhdmVyc2VOb2RlcyhnbHRmUnVudGltZSwgY3VycmVudFNjZW5lLm5vZGVzW2ldLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGhpbmcgaW4gZ2x0ZlJ1bnRpbWUuc2NlbmVzKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRTY2VuZSA9IGdsdGZSdW50aW1lLnNjZW5lc1t0aGluZ107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRTY2VuZS5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgVHJhdmVyc2VOb2RlcyhnbHRmUnVudGltZSwgY3VycmVudFNjZW5lLm5vZGVzW2ldLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgYW5pbWF0aW9uc1xyXG4gICAgTG9hZEFuaW1hdGlvbnMoZ2x0ZlJ1bnRpbWUpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x0ZlJ1bnRpbWUuc2NlbmUuc2tlbGV0b25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2tlbGV0b24gPSBnbHRmUnVudGltZS5zY2VuZS5za2VsZXRvbnNbaV07XHJcbiAgICAgICAgZ2x0ZlJ1bnRpbWUuc2NlbmUuYmVnaW5BbmltYXRpb24oc2tlbGV0b24sIDAsIE51bWJlci5NQVhfVkFMVUUsIHRydWUsIDEuMCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogb25CaW5kIHNoYWRlcnJzIGNhbGxiYWNrIHRvIHNldCB1bmlmb3JtcyBhbmQgbWF0cmljZXNcclxuICogQHBhcmFtIG1lc2hcclxuICogQHBhcmFtIGdsdGZSdW50aW1lXHJcbiAqIEBwYXJhbSB1blRyZWF0ZWRVbmlmb3Jtc1xyXG4gKiBAcGFyYW0gc2hhZGVyTWF0ZXJpYWxcclxuICogQHBhcmFtIHRlY2huaXF1ZVxyXG4gKiBAcGFyYW0gbWF0ZXJpYWxcclxuICogQHBhcmFtIG9uU3VjY2Vzc1xyXG4gKi9cclxuY29uc3QgT25CaW5kU2hhZGVyTWF0ZXJpYWwgPSAoXHJcbiAgICBtZXNoOiBBYnN0cmFjdE1lc2gsXHJcbiAgICBnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLFxyXG4gICAgdW5UcmVhdGVkVW5pZm9ybXM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIgfSxcclxuICAgIHNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcclxuICAgIHRlY2huaXF1ZTogSUdMVEZUZWNobmlxdWUsXHJcbiAgICBtYXRlcmlhbDogSUdMVEZNYXRlcmlhbCxcclxuICAgIG9uU3VjY2VzczogKHNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCkgPT4gdm9pZFxyXG4pID0+IHtcclxuICAgIGNvbnN0IG1hdGVyaWFsVmFsdWVzID0gbWF0ZXJpYWwudmFsdWVzIHx8IHRlY2huaXF1ZS5wYXJhbWV0ZXJzO1xyXG5cclxuICAgIGZvciAoY29uc3QgdW5pZiBpbiB1blRyZWF0ZWRVbmlmb3Jtcykge1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm06IElHTFRGVGVjaG5pcXVlUGFyYW1ldGVyID0gdW5UcmVhdGVkVW5pZm9ybXNbdW5pZl07XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHVuaWZvcm0udHlwZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEVQYXJhbWV0ZXJUeXBlLkZMT0FUX01BVDIgfHwgdHlwZSA9PT0gRVBhcmFtZXRlclR5cGUuRkxPQVRfTUFUMyB8fCB0eXBlID09PSBFUGFyYW1ldGVyVHlwZS5GTE9BVF9NQVQ0KSB7XHJcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLnNlbWFudGljICYmICF1bmlmb3JtLnNvdXJjZSAmJiAhdW5pZm9ybS5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBHTFRGVXRpbHMuU2V0TWF0cml4KGdsdGZSdW50aW1lLnNjZW5lLCBtZXNoLCB1bmlmb3JtLCB1bmlmLCBzaGFkZXJNYXRlcmlhbC5nZXRFZmZlY3QoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pZm9ybS5zZW1hbnRpYyAmJiAodW5pZm9ybS5zb3VyY2UgfHwgdW5pZm9ybS5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZSA9IGdsdGZSdW50aW1lLnNjZW5lLmdldE5vZGVCeU5hbWUodW5pZm9ybS5zb3VyY2UgfHwgdW5pZm9ybS5ub2RlIHx8IFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGdsdGZSdW50aW1lLnNjZW5lLmdldE5vZGVCeUlkKHVuaWZvcm0uc291cmNlIHx8IHVuaWZvcm0ubm9kZSB8fCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBHTFRGVXRpbHMuU2V0TWF0cml4KGdsdGZSdW50aW1lLnNjZW5lLCBzb3VyY2UsIHVuaWZvcm0sIHVuaWYsIHNoYWRlck1hdGVyaWFsLmdldEVmZmVjdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKDxhbnk+bWF0ZXJpYWxWYWx1ZXMpW3RlY2huaXF1ZS51bmlmb3Jtc1t1bmlmXV07XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gRVBhcmFtZXRlclR5cGUuU0FNUExFUl8yRCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IGdsdGZSdW50aW1lLnRleHR1cmVzW21hdGVyaWFsLnZhbHVlcyA/IHZhbHVlIDogdW5pZm9ybS52YWx1ZV0uYmFieWxvblRleHR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUgPT09IG51bGwgfHwgdGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuZ2V0RWZmZWN0KCkuc2V0VGV4dHVyZSh1bmlmLCB0ZXh0dXJlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEdMVEZVdGlscy5TZXRVbmlmb3JtKHNoYWRlck1hdGVyaWFsLmdldEVmZmVjdCgpLCB1bmlmLCB2YWx1ZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25TdWNjZXNzKHNoYWRlck1hdGVyaWFsKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcmVwYXJlIHVuaWZvcm1zIHRvIHNlbmQgdGhlIG9ubHkgb25lIHRpbWVcclxuICogTG9hZHMgdGhlIGFwcHJvcHJpYXRlIHRleHR1cmVzXHJcbiAqIEBwYXJhbSBnbHRmUnVudGltZVxyXG4gKiBAcGFyYW0gc2hhZGVyTWF0ZXJpYWxcclxuICogQHBhcmFtIHRlY2huaXF1ZVxyXG4gKiBAcGFyYW0gbWF0ZXJpYWxcclxuICovXHJcbmNvbnN0IFByZXBhcmVTaGFkZXJNYXRlcmlhbFVuaWZvcm1zID0gKFxyXG4gICAgZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSxcclxuICAgIHNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcclxuICAgIHRlY2huaXF1ZTogSUdMVEZUZWNobmlxdWUsXHJcbiAgICBtYXRlcmlhbDogSUdMVEZNYXRlcmlhbCxcclxuICAgIHVuVHJlYXRlZFVuaWZvcm1zOiB7IFtrZXk6IHN0cmluZ106IElHTFRGVGVjaG5pcXVlUGFyYW1ldGVyIH1cclxuKSA9PiB7XHJcbiAgICBjb25zdCBtYXRlcmlhbFZhbHVlcyA9IG1hdGVyaWFsLnZhbHVlcyB8fCB0ZWNobmlxdWUucGFyYW1ldGVycztcclxuICAgIGNvbnN0IHRlY2huaXF1ZVVuaWZvcm1zID0gdGVjaG5pcXVlLnVuaWZvcm1zO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZSB2YWx1ZXMgaGVyZSAobm90IG1hdHJpY2VzKVxyXG4gICAgICovXHJcbiAgICBmb3IgKGNvbnN0IHVuaWYgaW4gdW5UcmVhdGVkVW5pZm9ybXMpIHtcclxuICAgICAgICBjb25zdCB1bmlmb3JtOiBJR0xURlRlY2huaXF1ZVBhcmFtZXRlciA9IHVuVHJlYXRlZFVuaWZvcm1zW3VuaWZdO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gKDxhbnk+bWF0ZXJpYWxWYWx1ZXMpW3RlY2huaXF1ZVVuaWZvcm1zW3VuaWZdXTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgdmFsdWUgaXMgdGhlIHNhbWUgZm9yIGFsbCBtYXRlcmlhbHNcclxuICAgICAgICAgICAgdmFsdWUgPSA8YW55PnVuaWZvcm0udmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgb25Mb2FkVGV4dHVyZSA9ICh1bmlmb3JtTmFtZTogTnVsbGFibGU8c3RyaW5nPikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRleHR1cmU6IFRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtLnZhbHVlICYmIHVuaWZvcm1OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhdGljIHVuaWZvcm1cclxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJNYXRlcmlhbC5zZXRUZXh0dXJlKHVuaWZvcm1OYW1lLCB0ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdW5UcmVhdGVkVW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFRleHR1cmUgKHNhbXBsZXIyRClcclxuICAgICAgICBpZiAodHlwZSA9PT0gRVBhcmFtZXRlclR5cGUuU0FNUExFUl8yRCkge1xyXG4gICAgICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLkxvYWRUZXh0dXJlQXN5bmMoZ2x0ZlJ1bnRpbWUsIG1hdGVyaWFsLnZhbHVlcyA/IHZhbHVlIDogdW5pZm9ybS52YWx1ZSwgb25Mb2FkVGV4dHVyZSh1bmlmKSwgKCkgPT4gb25Mb2FkVGV4dHVyZShudWxsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyc1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodW5pZm9ybS52YWx1ZSAmJiBHTFRGVXRpbHMuU2V0VW5pZm9ybShzaGFkZXJNYXRlcmlhbCwgdW5pZiwgbWF0ZXJpYWwudmFsdWVzID8gdmFsdWUgOiB1bmlmb3JtLnZhbHVlLCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhdGljIHVuaWZvcm1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB1blRyZWF0ZWRVbmlmb3Jtc1t1bmlmXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaGFkZXIgY29tcGlsYXRpb24gZmFpbGVkXHJcbiAqIEBwYXJhbSBwcm9ncmFtXHJcbiAqIEBwYXJhbSBzaGFkZXJNYXRlcmlhbFxyXG4gKiBAcGFyYW0gb25FcnJvclxyXG4gKiBAcmV0dXJucyBjYWxsYmFjayB3aGVuIHNoYWRlciBpcyBjb21waWxlZFxyXG4gKi9cclxuY29uc3QgT25TaGFkZXJDb21waWxlRXJyb3IgPSAocHJvZ3JhbTogSUdMVEZQcm9ncmFtLCBzaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwsIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpID0+IHtcclxuICAgIHJldHVybiAoZWZmZWN0OiBFZmZlY3QsIGVycm9yOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzaGFkZXJNYXRlcmlhbC5kaXNwb3NlKHRydWUpO1xyXG4gICAgICAgIG9uRXJyb3IoXCJDYW5ub3QgY29tcGlsZSBwcm9ncmFtIG5hbWVkIFwiICsgcHJvZ3JhbS5uYW1lICsgXCIuIEVycm9yOiBcIiArIGVycm9yICsgXCIuIERlZmF1bHQgbWF0ZXJpYWwgd2lsbCBiZSBhcHBsaWVkXCIpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaGFkZXIgY29tcGlsYXRpb24gc3VjY2Vzc1xyXG4gKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICogQHBhcmFtIHNoYWRlck1hdGVyaWFsXHJcbiAqIEBwYXJhbSB0ZWNobmlxdWVcclxuICogQHBhcmFtIG1hdGVyaWFsXHJcbiAqIEBwYXJhbSB1blRyZWF0ZWRVbmlmb3Jtc1xyXG4gKiBAcGFyYW0gb25TdWNjZXNzXHJcbiAqIEByZXR1cm5zIGNhbGxiYWNrIHdoZW4gc2hhZGVyIGlzIGNvbXBpbGVkXHJcbiAqL1xyXG5jb25zdCBPblNoYWRlckNvbXBpbGVTdWNjZXNzID0gKFxyXG4gICAgZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSxcclxuICAgIHNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcclxuICAgIHRlY2huaXF1ZTogSUdMVEZUZWNobmlxdWUsXHJcbiAgICBtYXRlcmlhbDogSUdMVEZNYXRlcmlhbCxcclxuICAgIHVuVHJlYXRlZFVuaWZvcm1zOiB7IFtrZXk6IHN0cmluZ106IElHTFRGVGVjaG5pcXVlUGFyYW1ldGVyIH0sXHJcbiAgICBvblN1Y2Nlc3M6IChzaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwpID0+IHZvaWRcclxuKSA9PiB7XHJcbiAgICByZXR1cm4gKF86IEVmZmVjdCkgPT4ge1xyXG4gICAgICAgIFByZXBhcmVTaGFkZXJNYXRlcmlhbFVuaWZvcm1zKGdsdGZSdW50aW1lLCBzaGFkZXJNYXRlcmlhbCwgdGVjaG5pcXVlLCBtYXRlcmlhbCwgdW5UcmVhdGVkVW5pZm9ybXMpO1xyXG5cclxuICAgICAgICBzaGFkZXJNYXRlcmlhbC5vbkJpbmQgPSAobWVzaDogQWJzdHJhY3RNZXNoKSA9PiB7XHJcbiAgICAgICAgICAgIE9uQmluZFNoYWRlck1hdGVyaWFsKG1lc2gsIGdsdGZSdW50aW1lLCB1blRyZWF0ZWRVbmlmb3Jtcywgc2hhZGVyTWF0ZXJpYWwsIHRlY2huaXF1ZSwgbWF0ZXJpYWwsIG9uU3VjY2Vzcyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgdW5pZm9ybSBpZiBhbHJlYWR5IGhhbmRsZWQgYnkgYmFieWxvblxyXG4gKiBAcGFyYW0gdG9rZW5pemVyXHJcbiAqIEBwYXJhbSB0ZWNobmlxdWVcclxuICogQHBhcmFtIHVuVHJlYXRlZFVuaWZvcm1zXHJcbiAqIEByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtIGhhbmRsZWQgYnkgYmFieWxvblxyXG4gKi9cclxuY29uc3QgUGFyc2VTaGFkZXJVbmlmb3JtcyA9ICh0b2tlbml6ZXI6IFRva2VuaXplciwgdGVjaG5pcXVlOiBJR0xURlRlY2huaXF1ZSwgdW5UcmVhdGVkVW5pZm9ybXM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIgfSk6IHN0cmluZyA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHVuaWYgaW4gdGVjaG5pcXVlLnVuaWZvcm1zKSB7XHJcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRlY2huaXF1ZS51bmlmb3Jtc1t1bmlmXTtcclxuICAgICAgICBjb25zdCB1bmlmb3JtUGFyYW1ldGVyOiBJR0xURlRlY2huaXF1ZVBhcmFtZXRlciA9IHRlY2huaXF1ZS5wYXJhbWV0ZXJzW3VuaWZvcm1dO1xyXG5cclxuICAgICAgICBpZiAodG9rZW5pemVyLmN1cnJlbnRJZGVudGlmaWVyID09PSB1bmlmKSB7XHJcbiAgICAgICAgICAgIGlmICh1bmlmb3JtUGFyYW1ldGVyLnNlbWFudGljICYmICF1bmlmb3JtUGFyYW1ldGVyLnNvdXJjZSAmJiAhdW5pZm9ybVBhcmFtZXRlci5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1JbmRleCA9IGdsVEZUcmFuc2Zvcm1zLmluZGV4T2YodW5pZm9ybVBhcmFtZXRlci5zZW1hbnRpYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB1blRyZWF0ZWRVbmlmb3Jtc1t1bmlmXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFieWxvblRyYW5zZm9ybXNbdHJhbnNmb3JtSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b2tlbml6ZXIuY3VycmVudElkZW50aWZpZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxsIHNoYWRlcnMgbG9hZGVkLiBDcmVhdGUgbWF0ZXJpYWxzIG9uZSBieSBvbmVcclxuICogQHBhcmFtIGdsdGZSdW50aW1lXHJcbiAqL1xyXG5jb25zdCBJbXBvcnRNYXRlcmlhbHMgPSAoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSkgPT4ge1xyXG4gICAgLy8gQ3JlYXRlIG1hdGVyaWFsc1xyXG4gICAgZm9yIChjb25zdCBtYXQgaW4gZ2x0ZlJ1bnRpbWUubWF0ZXJpYWxzKSB7XHJcbiAgICAgICAgR0xURkxvYWRlckV4dGVuc2lvbi5Mb2FkTWF0ZXJpYWxBc3luYyhcclxuICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUsXHJcbiAgICAgICAgICAgIG1hdCxcclxuICAgICAgICAgICAgKCkgPT4ge30sXHJcbiAgICAgICAgICAgICgpID0+IHt9XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgYmFzZSBnbFRGIHNwZWNcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR0xURkxvYWRlckJhc2Uge1xyXG4gICAgcHVibGljIHN0YXRpYyBDcmVhdGVSdW50aW1lKHBhcnNlZERhdGE6IGFueSwgc2NlbmU6IFNjZW5lLCByb290VXJsOiBzdHJpbmcpOiBJR0xURlJ1bnRpbWUge1xyXG4gICAgICAgIGNvbnN0IGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUgPSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IHt9LFxyXG4gICAgICAgICAgICBhY2Nlc3NvcnM6IHt9LFxyXG4gICAgICAgICAgICBidWZmZXJzOiB7fSxcclxuICAgICAgICAgICAgYnVmZmVyVmlld3M6IHt9LFxyXG4gICAgICAgICAgICBtZXNoZXM6IHt9LFxyXG4gICAgICAgICAgICBsaWdodHM6IHt9LFxyXG4gICAgICAgICAgICBjYW1lcmFzOiB7fSxcclxuICAgICAgICAgICAgbm9kZXM6IHt9LFxyXG4gICAgICAgICAgICBpbWFnZXM6IHt9LFxyXG4gICAgICAgICAgICB0ZXh0dXJlczoge30sXHJcbiAgICAgICAgICAgIHNoYWRlcnM6IHt9LFxyXG4gICAgICAgICAgICBwcm9ncmFtczoge30sXHJcbiAgICAgICAgICAgIHNhbXBsZXJzOiB7fSxcclxuICAgICAgICAgICAgdGVjaG5pcXVlczoge30sXHJcbiAgICAgICAgICAgIG1hdGVyaWFsczoge30sXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHt9LFxyXG4gICAgICAgICAgICBza2luczoge30sXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnNVc2VkOiBbXSxcclxuXHJcbiAgICAgICAgICAgIHNjZW5lczoge30sXHJcblxyXG4gICAgICAgICAgICBidWZmZXJzQ291bnQ6IDAsXHJcbiAgICAgICAgICAgIHNoYWRlcnNjb3VudDogMCxcclxuXHJcbiAgICAgICAgICAgIHNjZW5lOiBzY2VuZSxcclxuICAgICAgICAgICAgcm9vdFVybDogcm9vdFVybCxcclxuXHJcbiAgICAgICAgICAgIGxvYWRlZEJ1ZmZlckNvdW50OiAwLFxyXG4gICAgICAgICAgICBsb2FkZWRCdWZmZXJWaWV3czoge30sXHJcblxyXG4gICAgICAgICAgICBsb2FkZWRTaGFkZXJDb3VudDogMCxcclxuXHJcbiAgICAgICAgICAgIGltcG9ydE9ubHlNZXNoZXM6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgZHVtbXlOb2RlczogW10sXHJcblxyXG4gICAgICAgICAgICBhc3NldENvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBQYXJzZVxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLmV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgUGFyc2VPYmplY3QocGFyc2VkRGF0YS5leHRlbnNpb25zLCBcImV4dGVuc2lvbnNcIiwgZ2x0ZlJ1bnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZERhdGEuZXh0ZW5zaW9uc1VzZWQpIHtcclxuICAgICAgICAgICAgUGFyc2VPYmplY3QocGFyc2VkRGF0YS5leHRlbnNpb25zVXNlZCwgXCJleHRlbnNpb25zVXNlZFwiLCBnbHRmUnVudGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkRGF0YS5idWZmZXJzKSB7XHJcbiAgICAgICAgICAgIFBhcnNlQnVmZmVycyhwYXJzZWREYXRhLmJ1ZmZlcnMsIGdsdGZSdW50aW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLmJ1ZmZlclZpZXdzKSB7XHJcbiAgICAgICAgICAgIFBhcnNlT2JqZWN0KHBhcnNlZERhdGEuYnVmZmVyVmlld3MsIFwiYnVmZmVyVmlld3NcIiwgZ2x0ZlJ1bnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZERhdGEuYWNjZXNzb3JzKSB7XHJcbiAgICAgICAgICAgIFBhcnNlT2JqZWN0KHBhcnNlZERhdGEuYWNjZXNzb3JzLCBcImFjY2Vzc29yc1wiLCBnbHRmUnVudGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkRGF0YS5tZXNoZXMpIHtcclxuICAgICAgICAgICAgUGFyc2VPYmplY3QocGFyc2VkRGF0YS5tZXNoZXMsIFwibWVzaGVzXCIsIGdsdGZSdW50aW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLmxpZ2h0cykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLmxpZ2h0cywgXCJsaWdodHNcIiwgZ2x0ZlJ1bnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZERhdGEuY2FtZXJhcykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLmNhbWVyYXMsIFwiY2FtZXJhc1wiLCBnbHRmUnVudGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkRGF0YS5ub2Rlcykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLm5vZGVzLCBcIm5vZGVzXCIsIGdsdGZSdW50aW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLmltYWdlcykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLmltYWdlcywgXCJpbWFnZXNcIiwgZ2x0ZlJ1bnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZERhdGEudGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgUGFyc2VPYmplY3QocGFyc2VkRGF0YS50ZXh0dXJlcywgXCJ0ZXh0dXJlc1wiLCBnbHRmUnVudGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkRGF0YS5zaGFkZXJzKSB7XHJcbiAgICAgICAgICAgIFBhcnNlU2hhZGVycyhwYXJzZWREYXRhLnNoYWRlcnMsIGdsdGZSdW50aW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLnByb2dyYW1zKSB7XHJcbiAgICAgICAgICAgIFBhcnNlT2JqZWN0KHBhcnNlZERhdGEucHJvZ3JhbXMsIFwicHJvZ3JhbXNcIiwgZ2x0ZlJ1bnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZERhdGEuc2FtcGxlcnMpIHtcclxuICAgICAgICAgICAgUGFyc2VPYmplY3QocGFyc2VkRGF0YS5zYW1wbGVycywgXCJzYW1wbGVyc1wiLCBnbHRmUnVudGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkRGF0YS50ZWNobmlxdWVzKSB7XHJcbiAgICAgICAgICAgIFBhcnNlT2JqZWN0KHBhcnNlZERhdGEudGVjaG5pcXVlcywgXCJ0ZWNobmlxdWVzXCIsIGdsdGZSdW50aW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLm1hdGVyaWFscykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLm1hdGVyaWFscywgXCJtYXRlcmlhbHNcIiwgZ2x0ZlJ1bnRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZERhdGEuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLmFuaW1hdGlvbnMsIFwiYW5pbWF0aW9uc1wiLCBnbHRmUnVudGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkRGF0YS5za2lucykge1xyXG4gICAgICAgICAgICBQYXJzZU9iamVjdChwYXJzZWREYXRhLnNraW5zLCBcInNraW5zXCIsIGdsdGZSdW50aW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLnNjZW5lcykge1xyXG4gICAgICAgICAgICBnbHRmUnVudGltZS5zY2VuZXMgPSBwYXJzZWREYXRhLnNjZW5lcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWREYXRhLnNjZW5lICYmIHBhcnNlZERhdGEuc2NlbmVzKSB7XHJcbiAgICAgICAgICAgIGdsdGZSdW50aW1lLmN1cnJlbnRTY2VuZSA9IHBhcnNlZERhdGEuc2NlbmVzW3BhcnNlZERhdGEuc2NlbmVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdsdGZSdW50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkQnVmZmVyQXN5bmMoXHJcbiAgICAgICAgZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSxcclxuICAgICAgICBpZDogc3RyaW5nLFxyXG4gICAgICAgIG9uU3VjY2VzczogKGJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3KSA9PiB2b2lkLFxyXG4gICAgICAgIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgICAgICAgb25Qcm9ncmVzcz86ICgpID0+IHZvaWRcclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcjogSUdMVEZCdWZmZXIgPSBnbHRmUnVudGltZS5idWZmZXJzW2lkXTtcclxuXHJcbiAgICAgICAgaWYgKFRvb2xzLklzQmFzZTY0KGJ1ZmZlci51cmkpKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb25TdWNjZXNzKG5ldyBVaW50OEFycmF5KFRvb2xzLkRlY29kZUJhc2U2NChidWZmZXIudXJpKSkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBUb29scy5Mb2FkRmlsZShcclxuICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLnJvb3RVcmwgKyBidWZmZXIudXJpLFxyXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IG9uU3VjY2VzcyhuZXcgVWludDhBcnJheShkYXRhIGFzIEFycmF5QnVmZmVyKSksXHJcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgIChyZXF1ZXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihyZXF1ZXN0LnN0YXR1cyArIFwiIFwiICsgcmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkVGV4dHVyZUJ1ZmZlckFzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKGJ1ZmZlcjogTnVsbGFibGU8QXJyYXlCdWZmZXJWaWV3PikgPT4gdm9pZCwgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmU6IElHTFRGVGV4dHVyZSA9IGdsdGZSdW50aW1lLnRleHR1cmVzW2lkXTtcclxuXHJcbiAgICAgICAgaWYgKCF0ZXh0dXJlIHx8ICF0ZXh0dXJlLnNvdXJjZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKFwiXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGV4dHVyZS5iYWJ5bG9uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBvblN1Y2Nlc3MobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNvdXJjZTogSUdMVEZJbWFnZSA9IGdsdGZSdW50aW1lLmltYWdlc1t0ZXh0dXJlLnNvdXJjZV07XHJcblxyXG4gICAgICAgIGlmIChUb29scy5Jc0Jhc2U2NChzb3VyY2UudXJpKSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uU3VjY2VzcyhuZXcgVWludDhBcnJheShUb29scy5EZWNvZGVCYXNlNjQoc291cmNlLnVyaSkpKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgVG9vbHMuTG9hZEZpbGUoXHJcbiAgICAgICAgICAgICAgICBnbHRmUnVudGltZS5yb290VXJsICsgc291cmNlLnVyaSxcclxuICAgICAgICAgICAgICAgIChkYXRhKSA9PiBvblN1Y2Nlc3MobmV3IFVpbnQ4QXJyYXkoZGF0YSBhcyBBcnJheUJ1ZmZlcikpLFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgIChyZXF1ZXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihyZXF1ZXN0LnN0YXR1cyArIFwiIFwiICsgcmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIHN0YXRpYyBDcmVhdGVUZXh0dXJlQXN5bmMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgaWQ6IHN0cmluZywgYnVmZmVyOiBOdWxsYWJsZTxBcnJheUJ1ZmZlclZpZXc+LCBvblN1Y2Nlc3M6ICh0ZXh0dXJlOiBUZXh0dXJlKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZTogSUdMVEZUZXh0dXJlID0gZ2x0ZlJ1bnRpbWUudGV4dHVyZXNbaWRdO1xyXG5cclxuICAgICAgICBpZiAodGV4dHVyZS5iYWJ5bG9uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBvblN1Y2Nlc3ModGV4dHVyZS5iYWJ5bG9uVGV4dHVyZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNhbXBsZXI6IElHTFRGU2FtcGxlciA9IGdsdGZSdW50aW1lLnNhbXBsZXJzW3RleHR1cmUuc2FtcGxlcl07XHJcblxyXG4gICAgICAgIGNvbnN0IGNyZWF0ZU1pcE1hcHMgPVxyXG4gICAgICAgICAgICBzYW1wbGVyLm1pbkZpbHRlciA9PT0gRVRleHR1cmVGaWx0ZXJUeXBlLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QgfHxcclxuICAgICAgICAgICAgc2FtcGxlci5taW5GaWx0ZXIgPT09IEVUZXh0dXJlRmlsdGVyVHlwZS5ORUFSRVNUX01JUE1BUF9MSU5FQVIgfHxcclxuICAgICAgICAgICAgc2FtcGxlci5taW5GaWx0ZXIgPT09IEVUZXh0dXJlRmlsdGVyVHlwZS5MSU5FQVJfTUlQTUFQX05FQVJFU1QgfHxcclxuICAgICAgICAgICAgc2FtcGxlci5taW5GaWx0ZXIgPT09IEVUZXh0dXJlRmlsdGVyVHlwZS5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcclxuXHJcbiAgICAgICAgY29uc3Qgc2FtcGxpbmdNb2RlID0gVGV4dHVyZS5CSUxJTkVBUl9TQU1QTElOR01PREU7XHJcblxyXG4gICAgICAgIGNvbnN0IGJsb2IgPSBidWZmZXIgPT0gbnVsbCA/IG5ldyBCbG9iKCkgOiBuZXcgQmxvYihbYnVmZmVyXSk7XHJcbiAgICAgICAgY29uc3QgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgY29uc3QgcmV2b2tlQmxvYlVSTCA9ICgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XHJcbiAgICAgICAgY29uc3QgbmV3VGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJsb2JVUkwsIGdsdGZSdW50aW1lLnNjZW5lLCAhY3JlYXRlTWlwTWFwcywgdHJ1ZSwgc2FtcGxpbmdNb2RlLCByZXZva2VCbG9iVVJMLCByZXZva2VCbG9iVVJMKTtcclxuICAgICAgICBpZiAoc2FtcGxlci53cmFwUyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5ld1RleHR1cmUud3JhcFUgPSBHTFRGVXRpbHMuR2V0V3JhcE1vZGUoc2FtcGxlci53cmFwUyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzYW1wbGVyLndyYXBUICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbmV3VGV4dHVyZS53cmFwViA9IEdMVEZVdGlscy5HZXRXcmFwTW9kZShzYW1wbGVyLndyYXBUKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3VGV4dHVyZS5uYW1lID0gaWQ7XHJcblxyXG4gICAgICAgIHRleHR1cmUuYmFieWxvblRleHR1cmUgPSBuZXdUZXh0dXJlO1xyXG4gICAgICAgIG9uU3VjY2VzcyhuZXdUZXh0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBzdGF0aWMgTG9hZFNoYWRlclN0cmluZ0FzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKHNoYWRlclN0cmluZzogc3RyaW5nIHwgQXJyYXlCdWZmZXIpID0+IHZvaWQsIG9uRXJyb3I/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyOiBJR0xURlNoYWRlciA9IGdsdGZSdW50aW1lLnNoYWRlcnNbaWRdO1xyXG5cclxuICAgICAgICBpZiAoVG9vbHMuSXNCYXNlNjQoc2hhZGVyLnVyaSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyU3RyaW5nID0gYXRvYihzaGFkZXIudXJpLnNwbGl0KFwiLFwiKVsxXSk7XHJcbiAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhzaGFkZXJTdHJpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgVG9vbHMuTG9hZEZpbGUoZ2x0ZlJ1bnRpbWUucm9vdFVybCArIHNoYWRlci51cmksIG9uU3VjY2VzcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlLCAocmVxdWVzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QgJiYgb25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocmVxdWVzdC5zdGF0dXMgKyBcIiBcIiArIHJlcXVlc3Quc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBzdGF0aWMgTG9hZE1hdGVyaWFsQXN5bmMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgaWQ6IHN0cmluZywgb25TdWNjZXNzOiAobWF0ZXJpYWw6IE1hdGVyaWFsKSA9PiB2b2lkLCBvbkVycm9yOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWw6IElHTFRGTWF0ZXJpYWwgPSBnbHRmUnVudGltZS5tYXRlcmlhbHNbaWRdO1xyXG4gICAgICAgIGlmICghbWF0ZXJpYWwudGVjaG5pcXVlKSB7XHJcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKFwiTm8gdGVjaG5pcXVlIGZvdW5kLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0ZWNobmlxdWU6IElHTFRGVGVjaG5pcXVlID0gZ2x0ZlJ1bnRpbWUudGVjaG5pcXVlc1ttYXRlcmlhbC50ZWNobmlxdWVdO1xyXG4gICAgICAgIGlmICghdGVjaG5pcXVlKSB7XHJcbiAgICAgICAgICAgIGdsdGZSdW50aW1lLnNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIWdsdGZSdW50aW1lLmFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0TWF0ZXJpYWwgPSBuZXcgU3RhbmRhcmRNYXRlcmlhbChpZCwgZ2x0ZlJ1bnRpbWUuc2NlbmUpO1xyXG4gICAgICAgICAgICBkZWZhdWx0TWF0ZXJpYWwuX3BhcmVudENvbnRhaW5lciA9IGdsdGZSdW50aW1lLmFzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBnbHRmUnVudGltZS5zY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRlZmF1bHRNYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBuZXcgQ29sb3IzKDAuNSwgMC41LCAwLjUpO1xyXG4gICAgICAgICAgICBkZWZhdWx0TWF0ZXJpYWwuc2lkZU9yaWVudGF0aW9uID0gTWF0ZXJpYWwuQ291bnRlckNsb2NrV2lzZVNpZGVPcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgb25TdWNjZXNzKGRlZmF1bHRNYXRlcmlhbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2dyYW06IElHTFRGUHJvZ3JhbSA9IGdsdGZSdW50aW1lLnByb2dyYW1zW3RlY2huaXF1ZS5wcm9ncmFtXTtcclxuICAgICAgICBjb25zdCBzdGF0ZXM6IElHTFRGVGVjaG5pcXVlU3RhdGVzID0gdGVjaG5pcXVlLnN0YXRlcztcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2hhZGVyOiBzdHJpbmcgPSBFZmZlY3QuU2hhZGVyc1N0b3JlW3Byb2dyYW0udmVydGV4U2hhZGVyICsgXCJWZXJ0ZXhTaGFkZXJcIl07XHJcbiAgICAgICAgY29uc3QgcGl4ZWxTaGFkZXI6IHN0cmluZyA9IEVmZmVjdC5TaGFkZXJzU3RvcmVbcHJvZ3JhbS5mcmFnbWVudFNoYWRlciArIFwiUGl4ZWxTaGFkZXJcIl07XHJcbiAgICAgICAgbGV0IG5ld1ZlcnRleFNoYWRlciA9IFwiXCI7XHJcbiAgICAgICAgbGV0IG5ld1BpeGVsU2hhZGVyID0gXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4VG9rZW5pemVyID0gbmV3IFRva2VuaXplcih2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsVG9rZW5pemVyID0gbmV3IFRva2VuaXplcihwaXhlbFNoYWRlcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVuVHJlYXRlZFVuaWZvcm1zOiB7IFtrZXk6IHN0cmluZ106IElHTFRGVGVjaG5pcXVlUGFyYW1ldGVyIH0gPSB7fTtcclxuICAgICAgICBjb25zdCB1bmlmb3Jtczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHNhbXBsZXJzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBGaWxsIHVuaWZvcm0sIHNhbXBsZXIyRCBhbmQgYXR0cmlidXRlc1xyXG4gICAgICAgIGZvciAoY29uc3QgdW5pZiBpbiB0ZWNobmlxdWUudW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRlY2huaXF1ZS51bmlmb3Jtc1t1bmlmXTtcclxuICAgICAgICAgICAgY29uc3QgdW5pZm9ybVBhcmFtZXRlcjogSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIgPSB0ZWNobmlxdWUucGFyYW1ldGVyc1t1bmlmb3JtXTtcclxuXHJcbiAgICAgICAgICAgIHVuVHJlYXRlZFVuaWZvcm1zW3VuaWZdID0gdW5pZm9ybVBhcmFtZXRlcjtcclxuXHJcbiAgICAgICAgICAgIGlmICh1bmlmb3JtUGFyYW1ldGVyLnNlbWFudGljICYmICF1bmlmb3JtUGFyYW1ldGVyLm5vZGUgJiYgIXVuaWZvcm1QYXJhbWV0ZXIuc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1JbmRleCA9IGdsVEZUcmFuc2Zvcm1zLmluZGV4T2YodW5pZm9ybVBhcmFtZXRlci5zZW1hbnRpYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMucHVzaChCYWJ5bG9uVHJhbnNmb3Jtc1t0cmFuc2Zvcm1JbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB1blRyZWF0ZWRVbmlmb3Jtc1t1bmlmXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMucHVzaCh1bmlmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh1bmlmb3JtUGFyYW1ldGVyLnR5cGUgPT09IEVQYXJhbWV0ZXJUeXBlLlNBTVBMRVJfMkQpIHtcclxuICAgICAgICAgICAgICAgIHNhbXBsZXJzLnB1c2godW5pZik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3Jtcy5wdXNoKHVuaWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gdGVjaG5pcXVlLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gdGVjaG5pcXVlLmF0dHJpYnV0ZXNbYXR0cl07XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVBhcmFtZXRlcjogSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIgPSB0ZWNobmlxdWUucGFyYW1ldGVyc1thdHRyaWJ1dGVdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZVBhcmFtZXRlci5zZW1hbnRpYykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IEdldEF0dHJpYnV0ZShhdHRyaWJ1dGVQYXJhbWV0ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbmZpZ3VyZSB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgd2hpbGUgKCF2ZXJ0ZXhUb2tlbml6ZXIuaXNFbmQoKSAmJiB2ZXJ0ZXhUb2tlbml6ZXIuZ2V0TmV4dFRva2VuKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdmVydGV4VG9rZW5pemVyLmN1cnJlbnRUb2tlbjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b2tlblR5cGUgIT09IEVUb2tlblR5cGUuSURFTlRJRklFUikge1xyXG4gICAgICAgICAgICAgICAgbmV3VmVydGV4U2hhZGVyICs9IHZlcnRleFRva2VuaXplci5jdXJyZW50U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBmb3VuZEF0dHJpYnV0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIGluIHRlY2huaXF1ZS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0ZWNobmlxdWUuYXR0cmlidXRlc1thdHRyXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVBhcmFtZXRlcjogSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIgPSB0ZWNobmlxdWUucGFyYW1ldGVyc1thdHRyaWJ1dGVdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhUb2tlbml6ZXIuY3VycmVudElkZW50aWZpZXIgPT09IGF0dHIgJiYgYXR0cmlidXRlUGFyYW1ldGVyLnNlbWFudGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmVydGV4U2hhZGVyICs9IEdldEF0dHJpYnV0ZShhdHRyaWJ1dGVQYXJhbWV0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQXR0cmlidXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZvdW5kQXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbmV3VmVydGV4U2hhZGVyICs9IFBhcnNlU2hhZGVyVW5pZm9ybXModmVydGV4VG9rZW5pemVyLCB0ZWNobmlxdWUsIHVuVHJlYXRlZFVuaWZvcm1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbmZpZ3VyZSBwaXhlbCBzaGFkZXJcclxuICAgICAgICB3aGlsZSAoIXBpeGVsVG9rZW5pemVyLmlzRW5kKCkgJiYgcGl4ZWxUb2tlbml6ZXIuZ2V0TmV4dFRva2VuKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gcGl4ZWxUb2tlbml6ZXIuY3VycmVudFRva2VuO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRva2VuVHlwZSAhPT0gRVRva2VuVHlwZS5JREVOVElGSUVSKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdQaXhlbFNoYWRlciArPSBwaXhlbFRva2VuaXplci5jdXJyZW50U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ld1BpeGVsU2hhZGVyICs9IFBhcnNlU2hhZGVyVW5pZm9ybXMocGl4ZWxUb2tlbml6ZXIsIHRlY2huaXF1ZSwgdW5UcmVhdGVkVW5pZm9ybXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHNoYWRlciBtYXRlcmlhbFxyXG4gICAgICAgIGNvbnN0IHNoYWRlclBhdGggPSB7XHJcbiAgICAgICAgICAgIHZlcnRleDogcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIgKyBpZCxcclxuICAgICAgICAgICAgZnJhZ21lbnQ6IHByb2dyYW0uZnJhZ21lbnRTaGFkZXIgKyBpZCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICB1bmlmb3JtczogdW5pZm9ybXMsXHJcbiAgICAgICAgICAgIHNhbXBsZXJzOiBzYW1wbGVycyxcclxuICAgICAgICAgICAgbmVlZEFscGhhQmxlbmRpbmc6IHN0YXRlcyAmJiBzdGF0ZXMuZW5hYmxlICYmIHN0YXRlcy5lbmFibGUuaW5kZXhPZigzMDQyKSAhPT0gLTEsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRWZmZWN0LlNoYWRlcnNTdG9yZVtwcm9ncmFtLnZlcnRleFNoYWRlciArIGlkICsgXCJWZXJ0ZXhTaGFkZXJcIl0gPSBuZXdWZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgRWZmZWN0LlNoYWRlcnNTdG9yZVtwcm9ncmFtLmZyYWdtZW50U2hhZGVyICsgaWQgKyBcIlBpeGVsU2hhZGVyXCJdID0gbmV3UGl4ZWxTaGFkZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IHNoYWRlck1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKGlkLCBnbHRmUnVudGltZS5zY2VuZSwgc2hhZGVyUGF0aCwgb3B0aW9ucyk7XHJcbiAgICAgICAgc2hhZGVyTWF0ZXJpYWwub25FcnJvciA9IE9uU2hhZGVyQ29tcGlsZUVycm9yKHByb2dyYW0sIHNoYWRlck1hdGVyaWFsLCBvbkVycm9yKTtcclxuICAgICAgICBzaGFkZXJNYXRlcmlhbC5vbkNvbXBpbGVkID0gT25TaGFkZXJDb21waWxlU3VjY2VzcyhnbHRmUnVudGltZSwgc2hhZGVyTWF0ZXJpYWwsIHRlY2huaXF1ZSwgbWF0ZXJpYWwsIHVuVHJlYXRlZFVuaWZvcm1zLCBvblN1Y2Nlc3MpO1xyXG4gICAgICAgIHNoYWRlck1hdGVyaWFsLnNpZGVPcmllbnRhdGlvbiA9IE1hdGVyaWFsLkNvdW50ZXJDbG9ja1dpc2VTaWRlT3JpZW50YXRpb247XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZXMgJiYgc3RhdGVzLmZ1bmN0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSBzdGF0ZXMuZnVuY3Rpb25zO1xyXG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25zLmN1bGxGYWNlICYmIGZ1bmN0aW9ucy5jdWxsRmFjZVswXSAhPT0gRUN1bGxpbmdUeXBlLkJBQ0spIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlck1hdGVyaWFsLmJhY2tGYWNlQ3VsbGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBibGVuZEZ1bmMgPSBmdW5jdGlvbnMuYmxlbmRGdW5jU2VwYXJhdGU7XHJcbiAgICAgICAgICAgIGlmIChibGVuZEZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbMF0gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLlNSQ19BTFBIQSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1sxXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uT05FX01JTlVTX1NSQ19BTFBIQSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1syXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uT05FICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzNdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5PTkVcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlck1hdGVyaWFsLmFscGhhTW9kZSA9IENvbnN0YW50cy5BTFBIQV9DT01CSU5FO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbMF0gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLk9ORSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1sxXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uT05FICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzJdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5aRVJPICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzNdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5PTkVcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlck1hdGVyaWFsLmFscGhhTW9kZSA9IENvbnN0YW50cy5BTFBIQV9PTkVPTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1swXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uU1JDX0FMUEhBICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzFdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5PTkUgJiZcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbMl0gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLlpFUk8gJiZcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbM10gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLk9ORVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuYWxwaGFNb2RlID0gQ29uc3RhbnRzLkFMUEhBX0FERDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzBdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5aRVJPICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzFdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5PTkVfTUlOVVNfU1JDX0NPTE9SICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzJdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5PTkUgJiZcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbM10gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLk9ORVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuYWxwaGFNb2RlID0gQ29uc3RhbnRzLkFMUEhBX1NVQlRSQUNUO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbMF0gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLkRTVF9DT0xPUiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1sxXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uWkVSTyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1syXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uT05FICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzNdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5PTkVcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlck1hdGVyaWFsLmFscGhhTW9kZSA9IENvbnN0YW50cy5BTFBIQV9NVUxUSVBMWTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgYmxlbmRGdW5jWzBdID09PSBFQmxlbmRpbmdGdW5jdGlvbi5TUkNfQUxQSEEgJiZcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbMV0gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLk9ORV9NSU5VU19TUkNfQ09MT1IgJiZcclxuICAgICAgICAgICAgICAgICAgICBibGVuZEZ1bmNbMl0gPT09IEVCbGVuZGluZ0Z1bmN0aW9uLk9ORSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kRnVuY1szXSA9PT0gRUJsZW5kaW5nRnVuY3Rpb24uT05FXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJNYXRlcmlhbC5hbHBoYU1vZGUgPSBDb25zdGFudHMuQUxQSEFfTUFYSU1JWkVEO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogZ2xURiBWMSBMb2FkZXJcclxuICogQGludGVybmFsXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR0xURkxvYWRlciBpbXBsZW1lbnRzIElHTFRGTG9hZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgRXh0ZW5zaW9uczogeyBbbmFtZTogc3RyaW5nXTogR0xURkxvYWRlckV4dGVuc2lvbiB9ID0ge307XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBSZWdpc3RlckV4dGVuc2lvbihleHRlbnNpb246IEdMVEZMb2FkZXJFeHRlbnNpb24pOiB2b2lkIHtcclxuICAgICAgICBpZiAoR0xURkxvYWRlci5FeHRlbnNpb25zW2V4dGVuc2lvbi5uYW1lXSkge1xyXG4gICAgICAgICAgICBUb29scy5FcnJvcignVG9vbCB3aXRoIHRoZSBzYW1lIG5hbWUgXCInICsgZXh0ZW5zaW9uLm5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgR0xURkxvYWRlci5FeHRlbnNpb25zW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9pbXBvcnRNZXNoQXN5bmMoXHJcbiAgICAgICAgbWVzaGVzTmFtZXM6IGFueSxcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgZGF0YTogSUdMVEZMb2FkZXJEYXRhLFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBhc3NldENvbnRhaW5lcjogTnVsbGFibGU8QXNzZXRDb250YWluZXI+LFxyXG4gICAgICAgIG9uU3VjY2VzczogKG1lc2hlczogQWJzdHJhY3RNZXNoW10sIHNrZWxldG9uczogU2tlbGV0b25bXSkgPT4gdm9pZCxcclxuICAgICAgICBvblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLFxyXG4gICAgICAgIG9uRXJyb3I/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkXHJcbiAgICApOiBib29sZWFuIHtcclxuICAgICAgICBzY2VuZS51c2VSaWdodEhhbmRlZFN5c3RlbSA9IHRydWU7XHJcblxyXG4gICAgICAgIEdMVEZMb2FkZXJFeHRlbnNpb24uTG9hZFJ1bnRpbWVBc3luYyhcclxuICAgICAgICAgICAgc2NlbmUsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIHJvb3RVcmwsXHJcbiAgICAgICAgICAgIChnbHRmUnVudGltZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUuYXNzZXRDb250YWluZXIgPSBhc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLmltcG9ydE9ubHlNZXNoZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtZXNoZXNOYW1lcyA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLmltcG9ydE1lc2hlc05hbWVzID0gW107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtZXNoZXNOYW1lcyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLmltcG9ydE1lc2hlc05hbWVzID0gW21lc2hlc05hbWVzXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzaGVzTmFtZXMgJiYgIShtZXNoZXNOYW1lcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLmltcG9ydE1lc2hlc05hbWVzID0gW21lc2hlc05hbWVzXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUuaW1wb3J0TWVzaGVzTmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBUb29scy5XYXJuKFwiQXJndW1lbnQgbWVzaGVzTmFtZXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciBzdHJpbmdbXVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbm9kZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5vZGVzKGdsdGZSdW50aW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNoZXM6IEFic3RyYWN0TWVzaFtdID0gW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBza2VsZXRvbnM6IFNrZWxldG9uW10gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaWxsIGFycmF5cyBvZiBtZXNoZXMgYW5kIHNrZWxldG9uc1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZGUgaW4gZ2x0ZlJ1bnRpbWUubm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlOiBJR0xURk5vZGUgPSBnbHRmUnVudGltZS5ub2Rlc1tuZGVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5iYWJ5bG9uTm9kZSBpbnN0YW5jZW9mIEFic3RyYWN0TWVzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoZXMucHVzaChub2RlLmJhYnlsb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBza2wgaW4gZ2x0ZlJ1bnRpbWUuc2tpbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBza2luOiBJR0xURlNraW5zID0gZ2x0ZlJ1bnRpbWUuc2tpbnNbc2tsXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraW4uYmFieWxvblNrZWxldG9uIGluc3RhbmNlb2YgU2tlbGV0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25zLnB1c2goc2tpbi5iYWJ5bG9uU2tlbGV0b24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGJ1ZmZlcnMsIHNoYWRlcnMsIG1hdGVyaWFscywgZXRjLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEJ1ZmZlcnNBc3luYyhnbHRmUnVudGltZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRTaGFkZXJzQXN5bmMoZ2x0ZlJ1bnRpbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgSW1wb3J0TWF0ZXJpYWxzKGdsdGZSdW50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUG9zdExvYWQoZ2x0ZlJ1bnRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFHTFRGRmlsZUxvYWRlci5JbmNyZW1lbnRhbExvYWRpbmcgJiYgb25TdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MobWVzaGVzLCBza2VsZXRvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoR0xURkZpbGVMb2FkZXIuSW5jcmVtZW50YWxMb2FkaW5nICYmIG9uU3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhtZXNoZXMsIHNrZWxldG9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXJyb3JcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEltcG9ydHMgb25lIG9yIG1vcmUgbWVzaGVzIGZyb20gYSBsb2FkZWQgZ2x0ZiBmaWxlIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gbWVzaGVzTmFtZXMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBvZiB0aGUgbWVzaCBuYW1lcyB0aGF0IHNob3VsZCBiZSBsb2FkZWQgZnJvbSB0aGUgZmlsZVxyXG4gICAgICogQHBhcmFtIHNjZW5lIHRoZSBzY2VuZSB0aGUgbWVzaGVzIHNob3VsZCBiZSBhZGRlZCB0b1xyXG4gICAgICogQHBhcmFtIGFzc2V0Q29udGFpbmVyIGRlZmluZXMgdGhlIGFzc2V0IGNvbnRhaW5lciB0byB1c2UgKGNhbiBiZSBudWxsKVxyXG4gICAgICogQHBhcmFtIGRhdGEgZ2x0ZiBkYXRhIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb2YgdGhlIG1lc2hlcyBpbiBhIGxvYWRlZCBmaWxlXHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCByb290IHVybCB0byBsb2FkIGZyb21cclxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBsb2FkaW5nIHByb2dyZXNzIGhhcyBvY2N1cmVkXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgY29udGFpbmcgdGhlIGxvYWRlZCBtZXNoZXMsIHBhcnRpY2xlcywgc2tlbGV0b25zIGFuZCBhbmltYXRpb25zXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBpbXBvcnRNZXNoQXN5bmMoXHJcbiAgICAgICAgbWVzaGVzTmFtZXM6IGFueSxcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgYXNzZXRDb250YWluZXI6IE51bGxhYmxlPEFzc2V0Q29udGFpbmVyPixcclxuICAgICAgICBkYXRhOiBJR0xURkxvYWRlckRhdGEsXHJcbiAgICAgICAgcm9vdFVybDogc3RyaW5nLFxyXG4gICAgICAgIG9uUHJvZ3Jlc3M/OiAoZXZlbnQ6IElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQpID0+IHZvaWRcclxuICAgICk6IFByb21pc2U8SVNjZW5lTG9hZGVyQXN5bmNSZXN1bHQ+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9pbXBvcnRNZXNoQXN5bmMoXHJcbiAgICAgICAgICAgICAgICBtZXNoZXNOYW1lcyxcclxuICAgICAgICAgICAgICAgIHNjZW5lLFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIHJvb3RVcmwsXHJcbiAgICAgICAgICAgICAgICBhc3NldENvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgIChtZXNoZXMsIHNrZWxldG9ucykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoZXM6IG1lc2hlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVTeXN0ZW1zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25zOiBza2VsZXRvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkdyb3VwczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0czogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cmllczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZU1hbmFnZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRBc3luYyhcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgZGF0YTogSUdMVEZMb2FkZXJEYXRhLFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBvblN1Y2Nlc3M6ICgpID0+IHZvaWQsXHJcbiAgICAgICAgb25Qcm9ncmVzcz86IChldmVudDogSVNjZW5lTG9hZGVyUHJvZ3Jlc3NFdmVudCkgPT4gdm9pZCxcclxuICAgICAgICBvbkVycm9yPzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgc2NlbmUudXNlUmlnaHRIYW5kZWRTeXN0ZW0gPSB0cnVlO1xyXG5cclxuICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLkxvYWRSdW50aW1lQXN5bmMoXHJcbiAgICAgICAgICAgIHNjZW5lLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICByb290VXJsLFxyXG4gICAgICAgICAgICAoZ2x0ZlJ1bnRpbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIExvYWQgcnVudGltZSBleHRlbnNpb3NcclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXJFeHRlbnNpb24uTG9hZFJ1bnRpbWVFeHRlbnNpb25zQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbm9kZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTm9kZXMoZ2x0ZlJ1bnRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBidWZmZXJzLCBzaGFkZXJzLCBtYXRlcmlhbHMsIGV0Yy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZEJ1ZmZlcnNBc3luYyhnbHRmUnVudGltZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFNoYWRlcnNBc3luYyhnbHRmUnVudGltZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEltcG9ydE1hdGVyaWFscyhnbHRmUnVudGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zdExvYWQoZ2x0ZlJ1bnRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUdMVEZGaWxlTG9hZGVyLkluY3JlbWVudGFsTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoR0xURkZpbGVMb2FkZXIuSW5jcmVtZW50YWxMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBvcnRzIGFsbCBvYmplY3RzIGZyb20gYSBsb2FkZWQgZ2x0ZiBmaWxlIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgdGhlIHNjZW5lIHRoZSBvYmplY3RzIHNob3VsZCBiZSBhZGRlZCB0b1xyXG4gICAgICogQHBhcmFtIGRhdGEgZ2x0ZiBkYXRhIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb2YgdGhlIG1lc2hlcyBpbiBhIGxvYWRlZCBmaWxlXHJcbiAgICAgKiBAcGFyYW0gcm9vdFVybCByb290IHVybCB0byBsb2FkIGZyb21cclxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBsb2FkaW5nIHByb2dyZXNzIGhhcyBvY2N1cmVkXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggY29tcGxldGVzIHdoZW4gb2JqZWN0cyBoYXZlIGJlZW4gbG9hZGVkIHRvIHRoZSBzY2VuZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZEFzeW5jKHNjZW5lOiBTY2VuZSwgZGF0YTogSUdMVEZMb2FkZXJEYXRhLCByb290VXJsOiBzdHJpbmcsIG9uUHJvZ3Jlc3M/OiAoZXZlbnQ6IElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQpID0+IHZvaWQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkQXN5bmMoXHJcbiAgICAgICAgICAgICAgICBzY2VuZSxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICByb290VXJsLFxyXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRTaGFkZXJzQXN5bmMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgb25sb2FkOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGhhc1NoYWRlcnMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc1NoYWRlciA9IChzaGE6IHN0cmluZywgc2hhZGVyOiBJR0xURlNoYWRlcikgPT4ge1xyXG4gICAgICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLkxvYWRTaGFkZXJTdHJpbmdBc3luYyhcclxuICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLFxyXG4gICAgICAgICAgICAgICAgc2hhLFxyXG4gICAgICAgICAgICAgICAgKHNoYWRlclN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFkZXJTdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBnbHRmUnVudGltZS5sb2FkZWRTaGFkZXJDb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZGVyU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEVmZmVjdC5TaGFkZXJzU3RvcmVbc2hhICsgKHNoYWRlci50eXBlID09PSBFU2hhZGVyVHlwZS5WRVJURVggPyBcIlZlcnRleFNoYWRlclwiIDogXCJQaXhlbFNoYWRlclwiKV0gPSBzaGFkZXJTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2x0ZlJ1bnRpbWUubG9hZGVkU2hhZGVyQ291bnQgPT09IGdsdGZSdW50aW1lLnNoYWRlcnNjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmxvYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIFRvb2xzLkVycm9yKFwiRXJyb3Igd2hlbiBsb2FkaW5nIHNoYWRlciBwcm9ncmFtIG5hbWVkIFwiICsgc2hhICsgXCIgbG9jYXRlZCBhdCBcIiArIHNoYWRlci51cmkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgc2hhIGluIGdsdGZSdW50aW1lLnNoYWRlcnMpIHtcclxuICAgICAgICAgICAgaGFzU2hhZGVycyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXI6IElHTFRGU2hhZGVyID0gZ2x0ZlJ1bnRpbWUuc2hhZGVyc1tzaGFdO1xyXG4gICAgICAgICAgICBpZiAoc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzU2hhZGVyLmJpbmQodGhpcywgc2hhLCBzaGFkZXIpKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBUb29scy5FcnJvcihcIk5vIHNoYWRlciBuYW1lZDogXCIgKyBzaGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhhc1NoYWRlcnMpIHtcclxuICAgICAgICAgICAgb25sb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZEJ1ZmZlcnNBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBvbkxvYWQ6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaGFzQnVmZmVycyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9jZXNzQnVmZmVyID0gKGJ1Zjogc3RyaW5nLCBidWZmZXI6IElHTFRGQnVmZmVyKSA9PiB7XHJcbiAgICAgICAgICAgIEdMVEZMb2FkZXJFeHRlbnNpb24uTG9hZEJ1ZmZlckFzeW5jKFxyXG4gICAgICAgICAgICAgICAgZ2x0ZlJ1bnRpbWUsXHJcbiAgICAgICAgICAgICAgICBidWYsXHJcbiAgICAgICAgICAgICAgICAoYnVmZmVyVmlldykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLmxvYWRlZEJ1ZmZlckNvdW50Kys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJWaWV3LmJ5dGVMZW5ndGggIT0gZ2x0ZlJ1bnRpbWUuYnVmZmVyc1tidWZdLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvb2xzLkVycm9yKFwiQnVmZmVyIG5hbWVkIFwiICsgYnVmICsgXCIgaXMgbGVuZ3RoIFwiICsgYnVmZmVyVmlldy5ieXRlTGVuZ3RoICsgXCIuIEV4cGVjdGVkOiBcIiArIGJ1ZmZlci5ieXRlTGVuZ3RoKTsgLy8gSW1wcm92ZSBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsdGZSdW50aW1lLmxvYWRlZEJ1ZmZlclZpZXdzW2J1Zl0gPSBidWZmZXJWaWV3O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsdGZSdW50aW1lLmxvYWRlZEJ1ZmZlckNvdW50ID09PSBnbHRmUnVudGltZS5idWZmZXJzQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBUb29scy5FcnJvcihcIkVycm9yIHdoZW4gbG9hZGluZyBidWZmZXIgbmFtZWQgXCIgKyBidWYgKyBcIiBsb2NhdGVkIGF0IFwiICsgYnVmZmVyLnVyaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBidWYgaW4gZ2x0ZlJ1bnRpbWUuYnVmZmVycykge1xyXG4gICAgICAgICAgICBoYXNCdWZmZXJzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcjogSUdMVEZCdWZmZXIgPSBnbHRmUnVudGltZS5idWZmZXJzW2J1Zl07XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NCdWZmZXIuYmluZCh0aGlzLCBidWYsIGJ1ZmZlcikoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFRvb2xzLkVycm9yKFwiTm8gYnVmZmVyIG5hbWVkOiBcIiArIGJ1Zik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzQnVmZmVycykge1xyXG4gICAgICAgICAgICBvbkxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlTm9kZXMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBjdXJyZW50U2NlbmUgPSA8SUdMVEZTY2VuZT5nbHRmUnVudGltZS5jdXJyZW50U2NlbmU7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50U2NlbmUpIHtcclxuICAgICAgICAgICAgLy8gT25seSBvbmUgc2NlbmUgZXZlbiBpZiBtdWx0aXBsZSBzY2VuZXMgYXJlIGRlZmluZWRcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50U2NlbmUubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIFRyYXZlcnNlTm9kZXMoZ2x0ZlJ1bnRpbWUsIGN1cnJlbnRTY2VuZS5ub2Rlc1tpXSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBMb2FkIGFsbCBzY2VuZXNcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0aGluZyBpbiBnbHRmUnVudGltZS5zY2VuZXMpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY2VuZSA9IGdsdGZSdW50aW1lLnNjZW5lc1t0aGluZ107XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50U2NlbmUubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBUcmF2ZXJzZU5vZGVzKGdsdGZSdW50aW1lLCBjdXJyZW50U2NlbmUubm9kZXNbaV0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIHByaXZhdGUgX25hbWU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IobmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGFuIG92ZXJyaWRlIGZvciBsb2FkaW5nIHRoZSBydW50aW1lXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSB0byBzdG9wIGZ1cnRoZXIgZXh0ZW5zaW9ucyBmcm9tIGxvYWRpbmcgdGhlIHJ1bnRpbWVcclxuICAgICAqIEBwYXJhbSBzY2VuZVxyXG4gICAgICogQHBhcmFtIGRhdGFcclxuICAgICAqIEBwYXJhbSByb290VXJsXHJcbiAgICAgKiBAcGFyYW0gb25TdWNjZXNzXHJcbiAgICAgKiBAcGFyYW0gb25FcnJvclxyXG4gICAgICogQHJldHVybnMgdHJ1ZSB0byBzdG9wIGZ1cnRoZXIgZXh0ZW5zaW9ucyBmcm9tIGxvYWRpbmcgdGhlIHJ1bnRpbWVcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZFJ1bnRpbWVBc3luYyhzY2VuZTogU2NlbmUsIGRhdGE6IElHTFRGTG9hZGVyRGF0YSwgcm9vdFVybDogc3RyaW5nLCBvblN1Y2Nlc3M/OiAoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSkgPT4gdm9pZCwgb25FcnJvcj86IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGFuIG9udmVycmlkZSBmb3IgY3JlYXRpbmcgZ2x0ZiBydW50aW1lXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSB0byBzdG9wIGZ1cnRoZXIgZXh0ZW5zaW9ucyBmcm9tIGNyZWF0aW5nIHRoZSBydW50aW1lXHJcbiAgICAgKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICAgICAqIEBwYXJhbSBvblN1Y2Nlc3NcclxuICAgICAqIEBwYXJhbSBvbkVycm9yXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gY3JlYXRpbmcgdGhlIHJ1bnRpbWVcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZFJ1bnRpbWVFeHRlbnNpb25zQXN5bmMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgb25TdWNjZXNzOiAoKSA9PiB2b2lkLCBvbkVycm9yPzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYW4gb3ZlcnJpZGUgZm9yIGxvYWRpbmcgYnVmZmVyc1xyXG4gICAgICogUmV0dXJuIHRydWUgdG8gc3RvcCBmdXJ0aGVyIGV4dGVuc2lvbnMgZnJvbSBsb2FkaW5nIHRoaXMgYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICogQHBhcmFtIG9uU3VjY2Vzc1xyXG4gICAgICogQHBhcmFtIG9uRXJyb3JcclxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gbG9hZGluZyB0aGlzIGJ1ZmZlclxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRCdWZmZXJBc3luYyhcclxuICAgICAgICBnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLFxyXG4gICAgICAgIGlkOiBzdHJpbmcsXHJcbiAgICAgICAgb25TdWNjZXNzOiAoYnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcpID0+IHZvaWQsXHJcbiAgICAgICAgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBvblByb2dyZXNzPzogKCkgPT4gdm9pZFxyXG4gICAgKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhbiBvdmVycmlkZSBmb3IgbG9hZGluZyB0ZXh0dXJlIGJ1ZmZlcnNcclxuICAgICAqIFJldHVybiB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gbG9hZGluZyB0aGlzIHRleHR1cmUgZGF0YVxyXG4gICAgICogQHBhcmFtIGdsdGZSdW50aW1lXHJcbiAgICAgKiBAcGFyYW0gaWRcclxuICAgICAqIEBwYXJhbSBvblN1Y2Nlc3NcclxuICAgICAqIEBwYXJhbSBvbkVycm9yXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gbG9hZGluZyB0aGlzIHRleHR1cmUgZGF0YVxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkVGV4dHVyZUJ1ZmZlckFzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKGJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3KSA9PiB2b2lkLCBvbkVycm9yOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhbiBvdmVycmlkZSBmb3IgY3JlYXRpbmcgdGV4dHVyZXNcclxuICAgICAqIFJldHVybiB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gbG9hZGluZyB0aGlzIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSBnbHRmUnVudGltZVxyXG4gICAgICogQHBhcmFtIGlkXHJcbiAgICAgKiBAcGFyYW0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0gb25TdWNjZXNzXHJcbiAgICAgKiBAcGFyYW0gb25FcnJvclxyXG4gICAgICogQHJldHVybnMgdHJ1ZSB0byBzdG9wIGZ1cnRoZXIgZXh0ZW5zaW9ucyBmcm9tIGxvYWRpbmcgdGhpcyB0ZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGNyZWF0ZVRleHR1cmVBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBpZDogc3RyaW5nLCBidWZmZXI6IEFycmF5QnVmZmVyVmlldywgb25TdWNjZXNzOiAodGV4dHVyZTogVGV4dHVyZSkgPT4gdm9pZCwgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYW4gb3ZlcnJpZGUgZm9yIGxvYWRpbmcgc2hhZGVyIHN0cmluZ3NcclxuICAgICAqIFJldHVybiB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gbG9hZGluZyB0aGlzIHNoYWRlciBkYXRhXHJcbiAgICAgKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICogQHBhcmFtIG9uU3VjY2Vzc1xyXG4gICAgICogQHBhcmFtIG9uRXJyb3JcclxuICAgICAqIEByZXR1cm5zIHRydWUgdG8gc3RvcCBmdXJ0aGVyIGV4dGVuc2lvbnMgZnJvbSBsb2FkaW5nIHRoaXMgc2hhZGVyIGRhdGFcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZFNoYWRlclN0cmluZ0FzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKHNoYWRlclN0cmluZzogc3RyaW5nKSA9PiB2b2lkLCBvbkVycm9yOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhbiBvdmVycmlkZSBmb3IgbG9hZGluZyBtYXRlcmlhbHNcclxuICAgICAqIFJldHVybiB0cnVlIHRvIHN0b3AgZnVydGhlciBleHRlbnNpb25zIGZyb20gbG9hZGluZyB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKiBAcGFyYW0gZ2x0ZlJ1bnRpbWVcclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICogQHBhcmFtIG9uU3VjY2Vzc1xyXG4gICAgICogQHBhcmFtIG9uRXJyb3JcclxuICAgICAqIEByZXR1cm5zIHRydWUgdG8gc3RvcCBmdXJ0aGVyIGV4dGVuc2lvbnMgZnJvbSBsb2FkaW5nIHRoaXMgbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsQXN5bmMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgaWQ6IHN0cmluZywgb25TdWNjZXNzOiAobWF0ZXJpYWw6IE1hdGVyaWFsKSA9PiB2b2lkLCBvbkVycm9yOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLVxyXG4gICAgLy8gVXRpbGl0aWVzXHJcbiAgICAvLyAtLS0tLS0tLS1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBzdGF0aWMgTG9hZFJ1bnRpbWVBc3luYyhcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgZGF0YTogSUdMVEZMb2FkZXJEYXRhLFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBvblN1Y2Nlc3M/OiAoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSkgPT4gdm9pZCxcclxuICAgICAgICBvbkVycm9yPzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgR0xURkxvYWRlckV4dGVuc2lvbi5fQXBwbHlFeHRlbnNpb25zKFxyXG4gICAgICAgICAgICAobG9hZGVyRXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyRXh0ZW5zaW9uLmxvYWRSdW50aW1lQXN5bmMoc2NlbmUsIGRhdGEsIHJvb3RVcmwsIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb25TdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzKEdMVEZMb2FkZXJCYXNlLkNyZWF0ZVJ1bnRpbWUoZGF0YS5qc29uLCBzY2VuZSwgcm9vdFVybCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkUnVudGltZUV4dGVuc2lvbnNBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBvblN1Y2Nlc3M6ICgpID0+IHZvaWQsIG9uRXJyb3I/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgR0xURkxvYWRlckV4dGVuc2lvbi5fQXBwbHlFeHRlbnNpb25zKFxyXG4gICAgICAgICAgICAobG9hZGVyRXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyRXh0ZW5zaW9uLmxvYWRSdW50aW1lRXh0ZW5zaW9uc0FzeW5jKGdsdGZSdW50aW1lLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBzdGF0aWMgTG9hZEJ1ZmZlckFzeW5jKFxyXG4gICAgICAgIGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsXHJcbiAgICAgICAgaWQ6IHN0cmluZyxcclxuICAgICAgICBvblN1Y2Nlc3M6IChidWZmZXJWaWV3OiBBcnJheUJ1ZmZlclZpZXcpID0+IHZvaWQsXHJcbiAgICAgICAgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBvblByb2dyZXNzPzogKCkgPT4gdm9pZFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgR0xURkxvYWRlckV4dGVuc2lvbi5fQXBwbHlFeHRlbnNpb25zKFxyXG4gICAgICAgICAgICAobG9hZGVyRXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyRXh0ZW5zaW9uLmxvYWRCdWZmZXJBc3luYyhnbHRmUnVudGltZSwgaWQsIG9uU3VjY2Vzcywgb25FcnJvciwgb25Qcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXJCYXNlLkxvYWRCdWZmZXJBc3luYyhnbHRmUnVudGltZSwgaWQsIG9uU3VjY2Vzcywgb25FcnJvciwgb25Qcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkVGV4dHVyZUFzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKHRleHR1cmU6IFRleHR1cmUpID0+IHZvaWQsIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLl9Mb2FkVGV4dHVyZUJ1ZmZlckFzeW5jKFxyXG4gICAgICAgICAgICBnbHRmUnVudGltZSxcclxuICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgIChidWZmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLl9DcmVhdGVUZXh0dXJlQXN5bmMoZ2x0ZlJ1bnRpbWUsIGlkLCBidWZmZXIsIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXJyb3JcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkU2hhZGVyU3RyaW5nQXN5bmMoZ2x0ZlJ1bnRpbWU6IElHTFRGUnVudGltZSwgaWQ6IHN0cmluZywgb25TdWNjZXNzOiAoc2hhZGVyRGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXIpID0+IHZvaWQsIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLl9BcHBseUV4dGVuc2lvbnMoXHJcbiAgICAgICAgICAgIChsb2FkZXJFeHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJFeHRlbnNpb24ubG9hZFNoYWRlclN0cmluZ0FzeW5jKGdsdGZSdW50aW1lLCBpZCwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgR0xURkxvYWRlckJhc2UuTG9hZFNoYWRlclN0cmluZ0FzeW5jKGdsdGZSdW50aW1lLCBpZCwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgc3RhdGljIExvYWRNYXRlcmlhbEFzeW5jKGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsIGlkOiBzdHJpbmcsIG9uU3VjY2VzczogKG1hdGVyaWFsOiBNYXRlcmlhbCkgPT4gdm9pZCwgb25FcnJvcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIEdMVEZMb2FkZXJFeHRlbnNpb24uX0FwcGx5RXh0ZW5zaW9ucyhcclxuICAgICAgICAgICAgKGxvYWRlckV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckV4dGVuc2lvbi5sb2FkTWF0ZXJpYWxBc3luYyhnbHRmUnVudGltZSwgaWQsIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXJCYXNlLkxvYWRNYXRlcmlhbEFzeW5jKGdsdGZSdW50aW1lLCBpZCwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfTG9hZFRleHR1cmVCdWZmZXJBc3luYyhcclxuICAgICAgICBnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLFxyXG4gICAgICAgIGlkOiBzdHJpbmcsXHJcbiAgICAgICAgb25TdWNjZXNzOiAoYnVmZmVyOiBOdWxsYWJsZTxBcnJheUJ1ZmZlclZpZXc+KSA9PiB2b2lkLFxyXG4gICAgICAgIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWRcclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIEdMVEZMb2FkZXJFeHRlbnNpb24uX0FwcGx5RXh0ZW5zaW9ucyhcclxuICAgICAgICAgICAgKGxvYWRlckV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckV4dGVuc2lvbi5sb2FkVGV4dHVyZUJ1ZmZlckFzeW5jKGdsdGZSdW50aW1lLCBpZCwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgR0xURkxvYWRlckJhc2UuTG9hZFRleHR1cmVCdWZmZXJBc3luYyhnbHRmUnVudGltZSwgaWQsIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX0NyZWF0ZVRleHR1cmVBc3luYyhcclxuICAgICAgICBnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLFxyXG4gICAgICAgIGlkOiBzdHJpbmcsXHJcbiAgICAgICAgYnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcsXHJcbiAgICAgICAgb25TdWNjZXNzOiAodGV4dHVyZTogVGV4dHVyZSkgPT4gdm9pZCxcclxuICAgICAgICBvbkVycm9yOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkXHJcbiAgICApOiB2b2lkIHtcclxuICAgICAgICBHTFRGTG9hZGVyRXh0ZW5zaW9uLl9BcHBseUV4dGVuc2lvbnMoXHJcbiAgICAgICAgICAgIChsb2FkZXJFeHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJFeHRlbnNpb24uY3JlYXRlVGV4dHVyZUFzeW5jKGdsdGZSdW50aW1lLCBpZCwgYnVmZmVyLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBHTFRGTG9hZGVyQmFzZS5DcmVhdGVUZXh0dXJlQXN5bmMoZ2x0ZlJ1bnRpbWUsIGlkLCBidWZmZXIsIG9uU3VjY2Vzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9BcHBseUV4dGVuc2lvbnMoZnVuYzogKGxvYWRlckV4dGVuc2lvbjogR0xURkxvYWRlckV4dGVuc2lvbikgPT4gYm9vbGVhbiwgZGVmYXVsdEZ1bmM6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbk5hbWUgaW4gR0xURkxvYWRlci5FeHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlckV4dGVuc2lvbiA9IEdMVEZMb2FkZXIuRXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXTtcclxuICAgICAgICAgICAgaWYgKGZ1bmMobG9hZGVyRXh0ZW5zaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWZhdWx0RnVuYygpO1xyXG4gICAgfVxyXG59XHJcblxyXG5HTFRGRmlsZUxvYWRlci5fQ3JlYXRlR0xURjFMb2FkZXIgPSAoKSA9PiBuZXcgR0xURkxvYWRlcigpO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cclxuaW1wb3J0IHR5cGUgeyBBc3NldENvbnRhaW5lciB9IGZyb20gXCJjb3JlL2Fzc2V0Q29udGFpbmVyXCI7XHJcbmltcG9ydCB0eXBlIHsgQm9uZSB9IGZyb20gXCJjb3JlL0JvbmVzL2JvbmVcIjtcclxuaW1wb3J0IHR5cGUgeyBTa2VsZXRvbiB9IGZyb20gXCJjb3JlL0JvbmVzL3NrZWxldG9uXCI7XHJcbmltcG9ydCB0eXBlIHsgVGV4dHVyZSB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9UZXh0dXJlcy90ZXh0dXJlXCI7XHJcbmltcG9ydCB0eXBlIHsgTm9kZSB9IGZyb20gXCJjb3JlL25vZGVcIjtcclxuaW1wb3J0IHR5cGUgeyBTY2VuZSB9IGZyb20gXCJjb3JlL3NjZW5lXCI7XHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEVudW1zXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IGVudW0gRUNvbXBvbmVudFR5cGUge1xyXG4gICAgQllURSA9IDUxMjAsXHJcbiAgICBVTlNJR05FRF9CWVRFID0gNTEyMSxcclxuICAgIFNIT1JUID0gNTEyMixcclxuICAgIFVOU0lHTkVEX1NIT1JUID0gNTEyMyxcclxuICAgIEZMT0FUID0gNTEyNixcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgZW51bSBFU2hhZGVyVHlwZSB7XHJcbiAgICBGUkFHTUVOVCA9IDM1NjMyLFxyXG4gICAgVkVSVEVYID0gMzU2MzMsXHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGVudW0gRVBhcmFtZXRlclR5cGUge1xyXG4gICAgQllURSA9IDUxMjAsXHJcbiAgICBVTlNJR05FRF9CWVRFID0gNTEyMSxcclxuICAgIFNIT1JUID0gNTEyMixcclxuICAgIFVOU0lHTkVEX1NIT1JUID0gNTEyMyxcclxuICAgIElOVCA9IDUxMjQsXHJcbiAgICBVTlNJR05FRF9JTlQgPSA1MTI1LFxyXG4gICAgRkxPQVQgPSA1MTI2LFxyXG4gICAgRkxPQVRfVkVDMiA9IDM1NjY0LFxyXG4gICAgRkxPQVRfVkVDMyA9IDM1NjY1LFxyXG4gICAgRkxPQVRfVkVDNCA9IDM1NjY2LFxyXG4gICAgSU5UX1ZFQzIgPSAzNTY2NyxcclxuICAgIElOVF9WRUMzID0gMzU2NjgsXHJcbiAgICBJTlRfVkVDNCA9IDM1NjY5LFxyXG4gICAgQk9PTCA9IDM1NjcwLFxyXG4gICAgQk9PTF9WRUMyID0gMzU2NzEsXHJcbiAgICBCT09MX1ZFQzMgPSAzNTY3MixcclxuICAgIEJPT0xfVkVDNCA9IDM1NjczLFxyXG4gICAgRkxPQVRfTUFUMiA9IDM1Njc0LFxyXG4gICAgRkxPQVRfTUFUMyA9IDM1Njc1LFxyXG4gICAgRkxPQVRfTUFUNCA9IDM1Njc2LFxyXG4gICAgU0FNUExFUl8yRCA9IDM1Njc4LFxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBlbnVtIEVUZXh0dXJlV3JhcE1vZGUge1xyXG4gICAgQ0xBTVBfVE9fRURHRSA9IDMzMDcxLFxyXG4gICAgTUlSUk9SRURfUkVQRUFUID0gMzM2NDgsXHJcbiAgICBSRVBFQVQgPSAxMDQ5NyxcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgZW51bSBFVGV4dHVyZUZpbHRlclR5cGUge1xyXG4gICAgTkVBUkVTVCA9IDk3MjgsXHJcbiAgICBMSU5FQVIgPSA5NzI4LFxyXG4gICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCA9IDk5ODQsXHJcbiAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1QgPSA5OTg1LFxyXG4gICAgTkVBUkVTVF9NSVBNQVBfTElORUFSID0gOTk4NixcclxuICAgIExJTkVBUl9NSVBNQVBfTElORUFSID0gOTk4NyxcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgZW51bSBFVGV4dHVyZUZvcm1hdCB7XHJcbiAgICBBTFBIQSA9IDY0MDYsXHJcbiAgICBSR0IgPSA2NDA3LFxyXG4gICAgUkdCQSA9IDY0MDgsXHJcbiAgICBMVU1JTkFOQ0UgPSA2NDA5LFxyXG4gICAgTFVNSU5BTkNFX0FMUEhBID0gNjQxMCxcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgZW51bSBFQ3VsbGluZ1R5cGUge1xyXG4gICAgRlJPTlQgPSAxMDI4LFxyXG4gICAgQkFDSyA9IDEwMjksXHJcbiAgICBGUk9OVF9BTkRfQkFDSyA9IDEwMzIsXHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGVudW0gRUJsZW5kaW5nRnVuY3Rpb24ge1xyXG4gICAgWkVSTyA9IDAsXHJcbiAgICBPTkUgPSAxLFxyXG4gICAgU1JDX0NPTE9SID0gNzY4LFxyXG4gICAgT05FX01JTlVTX1NSQ19DT0xPUiA9IDc2OSxcclxuICAgIERTVF9DT0xPUiA9IDc3NCxcclxuICAgIE9ORV9NSU5VU19EU1RfQ09MT1IgPSA3NzUsXHJcbiAgICBTUkNfQUxQSEEgPSA3NzAsXHJcbiAgICBPTkVfTUlOVVNfU1JDX0FMUEhBID0gNzcxLFxyXG4gICAgRFNUX0FMUEhBID0gNzcyLFxyXG4gICAgT05FX01JTlVTX0RTVF9BTFBIQSA9IDc3MyxcclxuICAgIENPTlNUQU5UX0NPTE9SID0gMzI3NjksXHJcbiAgICBPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IgPSAzMjc3MCxcclxuICAgIENPTlNUQU5UX0FMUEhBID0gMzI3NzEsXHJcbiAgICBPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEEgPSAzMjc3MixcclxuICAgIFNSQ19BTFBIQV9TQVRVUkFURSA9IDc3NixcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGUHJvcGVydHkge1xyXG4gICAgZXh0ZW5zaW9ucz86IHsgW2tleTogc3RyaW5nXTogYW55IH07XHJcbiAgICBleHRyYXM/OiBvYmplY3Q7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURkNoaWxkUm9vdFByb3BlcnR5IGV4dGVuZHMgSUdMVEZQcm9wZXJ0eSB7XHJcbiAgICBuYW1lPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZBY2Nlc3NvciBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgYnVmZmVyVmlldzogc3RyaW5nO1xyXG4gICAgYnl0ZU9mZnNldDogbnVtYmVyO1xyXG4gICAgYnl0ZVN0cmlkZTogbnVtYmVyO1xyXG4gICAgY291bnQ6IG51bWJlcjtcclxuICAgIHR5cGU6IHN0cmluZztcclxuICAgIGNvbXBvbmVudFR5cGU6IEVDb21wb25lbnRUeXBlO1xyXG5cclxuICAgIG1heD86IG51bWJlcltdO1xyXG4gICAgbWluPzogbnVtYmVyW107XHJcbiAgICBuYW1lPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZCdWZmZXJWaWV3IGV4dGVuZHMgSUdMVEZDaGlsZFJvb3RQcm9wZXJ0eSB7XHJcbiAgICBidWZmZXI6IHN0cmluZztcclxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcjtcclxuICAgIGJ5dGVMZW5ndGg6IG51bWJlcjtcclxuICAgIGJ5dGVTdHJpZGU6IG51bWJlcjtcclxuXHJcbiAgICB0YXJnZXQ/OiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURkJ1ZmZlciBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgdXJpOiBzdHJpbmc7XHJcblxyXG4gICAgYnl0ZUxlbmd0aD86IG51bWJlcjtcclxuICAgIHR5cGU/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURlNoYWRlciBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgdXJpOiBzdHJpbmc7XHJcbiAgICB0eXBlOiBFU2hhZGVyVHlwZTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGUHJvZ3JhbSBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgYXR0cmlidXRlczogc3RyaW5nW107XHJcbiAgICBmcmFnbWVudFNoYWRlcjogc3RyaW5nO1xyXG4gICAgdmVydGV4U2hhZGVyOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURlRlY2huaXF1ZVBhcmFtZXRlciB7XHJcbiAgICB0eXBlOiBudW1iZXI7XHJcblxyXG4gICAgY291bnQ/OiBudW1iZXI7XHJcbiAgICBzZW1hbnRpYz86IHN0cmluZztcclxuICAgIG5vZGU/OiBzdHJpbmc7XHJcbiAgICB2YWx1ZT86IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfCBBcnJheTxhbnk+O1xyXG4gICAgc291cmNlPzogc3RyaW5nO1xyXG5cclxuICAgIGJhYnlsb25WYWx1ZT86IGFueTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGVGVjaG5pcXVlQ29tbW9uUHJvZmlsZSB7XHJcbiAgICBsaWdodGluZ01vZGVsOiBzdHJpbmc7XHJcbiAgICB0ZXhjb29yZEJpbmRpbmdzOiBvYmplY3Q7XHJcblxyXG4gICAgcGFyYW1ldGVycz86IEFycmF5PGFueT47XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURlRlY2huaXF1ZVN0YXRlc0Z1bmN0aW9ucyB7XHJcbiAgICBibGVuZENvbG9yPzogbnVtYmVyW107XHJcbiAgICBibGVuZEVxdWF0aW9uU2VwYXJhdGU/OiBudW1iZXJbXTtcclxuICAgIGJsZW5kRnVuY1NlcGFyYXRlPzogbnVtYmVyW107XHJcbiAgICBjb2xvck1hc2s6IGJvb2xlYW5bXTtcclxuICAgIGN1bGxGYWNlOiBudW1iZXJbXTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGVGVjaG5pcXVlU3RhdGVzIHtcclxuICAgIGVuYWJsZTogbnVtYmVyW107XHJcbiAgICBmdW5jdGlvbnM6IElHTFRGVGVjaG5pcXVlU3RhdGVzRnVuY3Rpb25zO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZUZWNobmlxdWUgZXh0ZW5kcyBJR0xURkNoaWxkUm9vdFByb3BlcnR5IHtcclxuICAgIHBhcmFtZXRlcnM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIgfTtcclxuICAgIHByb2dyYW06IHN0cmluZztcclxuXHJcbiAgICBhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xyXG4gICAgdW5pZm9ybXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XHJcbiAgICBzdGF0ZXM6IElHTFRGVGVjaG5pcXVlU3RhdGVzO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZNYXRlcmlhbCBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgdGVjaG5pcXVlPzogc3RyaW5nO1xyXG4gICAgdmFsdWVzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGTWVzaFByaW1pdGl2ZSBleHRlbmRzIElHTFRGUHJvcGVydHkge1xyXG4gICAgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcclxuICAgIGluZGljZXM6IHN0cmluZztcclxuICAgIG1hdGVyaWFsOiBzdHJpbmc7XHJcblxyXG4gICAgbW9kZT86IG51bWJlcjtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGTWVzaCBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgcHJpbWl0aXZlczogSUdMVEZNZXNoUHJpbWl0aXZlW107XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURkltYWdlIGV4dGVuZHMgSUdMVEZDaGlsZFJvb3RQcm9wZXJ0eSB7XHJcbiAgICB1cmk6IHN0cmluZztcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGU2FtcGxlciBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgbWFnRmlsdGVyPzogbnVtYmVyO1xyXG4gICAgbWluRmlsdGVyPzogbnVtYmVyO1xyXG4gICAgd3JhcFM/OiBudW1iZXI7XHJcbiAgICB3cmFwVD86IG51bWJlcjtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGVGV4dHVyZSBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgc2FtcGxlcjogc3RyaW5nO1xyXG4gICAgc291cmNlOiBzdHJpbmc7XHJcblxyXG4gICAgZm9ybWF0PzogRVRleHR1cmVGb3JtYXQ7XHJcbiAgICBpbnRlcm5hbEZvcm1hdD86IEVUZXh0dXJlRm9ybWF0O1xyXG4gICAgdGFyZ2V0PzogbnVtYmVyO1xyXG4gICAgdHlwZT86IG51bWJlcjtcclxuXHJcbiAgICAvLyBCYWJ5bG9uLmpzIHZhbHVlcyAob3B0aW1pemUpXHJcbiAgICBiYWJ5bG9uVGV4dHVyZT86IFRleHR1cmU7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURkFtYmllbkxpZ2h0IHtcclxuICAgIGNvbG9yPzogbnVtYmVyW107XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURkRpcmVjdGlvbmFsTGlnaHQge1xyXG4gICAgY29sb3I/OiBudW1iZXJbXTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGUG9pbnRMaWdodCB7XHJcbiAgICBjb2xvcj86IG51bWJlcltdO1xyXG4gICAgY29uc3RhbnRBdHRlbnVhdGlvbj86IG51bWJlcjtcclxuICAgIGxpbmVhckF0dGVudWF0aW9uPzogbnVtYmVyO1xyXG4gICAgcXVhZHJhdGljQXR0ZW51YXRpb24/OiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURlNwb3RMaWdodCB7XHJcbiAgICBjb2xvcj86IG51bWJlcltdO1xyXG4gICAgY29uc3RhbnRBdHRlbnVhdGlvbj86IG51bWJlcjtcclxuICAgIGZhbGxPZkFuZ2xlPzogbnVtYmVyO1xyXG4gICAgZmFsbE9mZkV4cG9uZW50PzogbnVtYmVyO1xyXG4gICAgbGluZWFyQXR0ZW51YXRpb24/OiBudW1iZXI7XHJcbiAgICBxdWFkcmF0aWNBdHRlbnVhdGlvbj86IG51bWJlcjtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGTGlnaHQgZXh0ZW5kcyBJR0xURkNoaWxkUm9vdFByb3BlcnR5IHtcclxuICAgIHR5cGU6IHN0cmluZztcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGQ2FtZXJhT3J0aG9ncmFwaGljIHtcclxuICAgIHhtYWc6IG51bWJlcjtcclxuICAgIHltYWc6IG51bWJlcjtcclxuICAgIHpmYXI6IG51bWJlcjtcclxuICAgIHpuZWFyOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURkNhbWVyYVBlcnNwZWN0aXZlIHtcclxuICAgIGFzcGVjdFJhdGlvOiBudW1iZXI7XHJcbiAgICB5Zm92OiBudW1iZXI7XHJcbiAgICB6ZmFyOiBudW1iZXI7XHJcbiAgICB6bmVhcjogbnVtYmVyO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZDYW1lcmEgZXh0ZW5kcyBJR0xURkNoaWxkUm9vdFByb3BlcnR5IHtcclxuICAgIHR5cGU6IHN0cmluZztcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGQW5pbWF0aW9uQ2hhbm5lbFRhcmdldCB7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgcGF0aDogc3RyaW5nO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZBbmltYXRpb25DaGFubmVsIHtcclxuICAgIHNhbXBsZXI6IHN0cmluZztcclxuICAgIHRhcmdldDogSUdMVEZBbmltYXRpb25DaGFubmVsVGFyZ2V0O1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZBbmltYXRpb25TYW1wbGVyIHtcclxuICAgIGlucHV0OiBzdHJpbmc7XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuXHJcbiAgICBpbnRlcnBvbGF0aW9uPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZBbmltYXRpb24gZXh0ZW5kcyBJR0xURkNoaWxkUm9vdFByb3BlcnR5IHtcclxuICAgIGNoYW5uZWxzPzogSUdMVEZBbmltYXRpb25DaGFubmVsW107XHJcbiAgICBwYXJhbWV0ZXJzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcclxuICAgIHNhbXBsZXJzPzogeyBba2V5OiBzdHJpbmddOiBJR0xURkFuaW1hdGlvblNhbXBsZXIgfTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGTm9kZUluc3RhbmNlU2tpbiB7XHJcbiAgICBza2VsZXRvbnM6IHN0cmluZ1tdO1xyXG4gICAgc2tpbjogc3RyaW5nO1xyXG4gICAgbWVzaGVzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGU2tpbnMgZXh0ZW5kcyBJR0xURkNoaWxkUm9vdFByb3BlcnR5IHtcclxuICAgIGJpbmRTaGFwZU1hdHJpeDogbnVtYmVyW107XHJcbiAgICBpbnZlcnNlQmluZE1hdHJpY2VzOiBzdHJpbmc7XHJcbiAgICBqb2ludE5hbWVzOiBzdHJpbmdbXTtcclxuXHJcbiAgICBiYWJ5bG9uU2tlbGV0b24/OiBTa2VsZXRvbjtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGTm9kZSBleHRlbmRzIElHTFRGQ2hpbGRSb290UHJvcGVydHkge1xyXG4gICAgY2FtZXJhPzogc3RyaW5nO1xyXG4gICAgY2hpbGRyZW46IHN0cmluZ1tdO1xyXG4gICAgc2tpbj86IHN0cmluZztcclxuICAgIGpvaW50TmFtZT86IHN0cmluZztcclxuICAgIGxpZ2h0Pzogc3RyaW5nO1xyXG4gICAgbWF0cml4OiBudW1iZXJbXTtcclxuICAgIG1lc2g/OiBzdHJpbmc7XHJcbiAgICBtZXNoZXM/OiBzdHJpbmdbXTtcclxuICAgIHJvdGF0aW9uPzogbnVtYmVyW107XHJcbiAgICBzY2FsZT86IG51bWJlcltdO1xyXG4gICAgdHJhbnNsYXRpb24/OiBudW1iZXJbXTtcclxuXHJcbiAgICAvLyBCYWJ5bG9uLmpzIHZhbHVlcyAob3B0aW1pemUpXHJcbiAgICBiYWJ5bG9uTm9kZT86IE5vZGU7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURlNjZW5lIGV4dGVuZHMgSUdMVEZDaGlsZFJvb3RQcm9wZXJ0eSB7XHJcbiAgICBub2Rlczogc3RyaW5nW107XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJR0xURlJ1bnRpbWUge1xyXG4gICAgZXh0ZW5zaW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcclxuICAgIGFjY2Vzc29yczogeyBba2V5OiBzdHJpbmddOiBJR0xURkFjY2Vzc29yIH07XHJcbiAgICBidWZmZXJzOiB7IFtrZXk6IHN0cmluZ106IElHTFRGQnVmZmVyIH07XHJcbiAgICBidWZmZXJWaWV3czogeyBba2V5OiBzdHJpbmddOiBJR0xURkJ1ZmZlclZpZXcgfTtcclxuICAgIG1lc2hlczogeyBba2V5OiBzdHJpbmddOiBJR0xURk1lc2ggfTtcclxuICAgIGxpZ2h0czogeyBba2V5OiBzdHJpbmddOiBJR0xURkxpZ2h0IH07XHJcbiAgICBjYW1lcmFzOiB7IFtrZXk6IHN0cmluZ106IElHTFRGQ2FtZXJhIH07XHJcbiAgICBub2RlczogeyBba2V5OiBzdHJpbmddOiBJR0xURk5vZGUgfTtcclxuICAgIGltYWdlczogeyBba2V5OiBzdHJpbmddOiBJR0xURkltYWdlIH07XHJcbiAgICB0ZXh0dXJlczogeyBba2V5OiBzdHJpbmddOiBJR0xURlRleHR1cmUgfTtcclxuICAgIHNoYWRlcnM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZTaGFkZXIgfTtcclxuICAgIHByb2dyYW1zOiB7IFtrZXk6IHN0cmluZ106IElHTFRGUHJvZ3JhbSB9O1xyXG4gICAgc2FtcGxlcnM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZTYW1wbGVyIH07XHJcbiAgICB0ZWNobmlxdWVzOiB7IFtrZXk6IHN0cmluZ106IElHTFRGVGVjaG5pcXVlIH07XHJcbiAgICBtYXRlcmlhbHM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZNYXRlcmlhbCB9O1xyXG4gICAgYW5pbWF0aW9uczogeyBba2V5OiBzdHJpbmddOiBJR0xURkFuaW1hdGlvbiB9O1xyXG4gICAgc2tpbnM6IHsgW2tleTogc3RyaW5nXTogSUdMVEZTa2lucyB9O1xyXG5cclxuICAgIGN1cnJlbnRTY2VuZT86IG9iamVjdDtcclxuICAgIHNjZW5lczogeyBba2V5OiBzdHJpbmddOiBJR0xURlNjZW5lIH07IC8vIHYxLjFcclxuXHJcbiAgICBleHRlbnNpb25zVXNlZDogc3RyaW5nW107XHJcbiAgICBleHRlbnNpb25zUmVxdWlyZWQ/OiBzdHJpbmdbXTsgLy8gdjEuMVxyXG5cclxuICAgIGJ1ZmZlcnNDb3VudDogbnVtYmVyO1xyXG4gICAgc2hhZGVyc2NvdW50OiBudW1iZXI7XHJcblxyXG4gICAgc2NlbmU6IFNjZW5lO1xyXG4gICAgcm9vdFVybDogc3RyaW5nO1xyXG5cclxuICAgIGxvYWRlZEJ1ZmZlckNvdW50OiBudW1iZXI7XHJcbiAgICBsb2FkZWRCdWZmZXJWaWV3czogeyBbbmFtZTogc3RyaW5nXTogQXJyYXlCdWZmZXJWaWV3IH07XHJcblxyXG4gICAgbG9hZGVkU2hhZGVyQ291bnQ6IG51bWJlcjtcclxuXHJcbiAgICBpbXBvcnRPbmx5TWVzaGVzOiBib29sZWFuO1xyXG4gICAgaW1wb3J0TWVzaGVzTmFtZXM/OiBzdHJpbmdbXTtcclxuXHJcbiAgICBkdW1teU5vZGVzOiBOb2RlW107XHJcblxyXG4gICAgYXNzZXRDb250YWluZXI6IE51bGxhYmxlPEFzc2V0Q29udGFpbmVyPjtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElOb2RlVG9Sb290IHtcclxuICAgIGJvbmU6IEJvbmU7XHJcbiAgICBub2RlOiBJR0xURk5vZGU7XHJcbiAgICBpZDogc3RyaW5nO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUpvaW50Tm9kZSB7XHJcbiAgICBub2RlOiBJR0xURk5vZGU7XHJcbiAgICBpZDogc3RyaW5nO1xyXG59XHJcbiIsImltcG9ydCB0eXBlIHsgSUdMVEZUZWNobmlxdWVQYXJhbWV0ZXIsIElHTFRGQWNjZXNzb3IsIElHTFRGUnVudGltZSwgSUdMVEZCdWZmZXJWaWV3IH0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHsgRVBhcmFtZXRlclR5cGUsIEVUZXh0dXJlV3JhcE1vZGUsIEVUZXh0dXJlRmlsdGVyVHlwZSwgRUNvbXBvbmVudFR5cGUgfSBmcm9tIFwiLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFZlY3RvcjIsIFZlY3RvcjMsIFZlY3RvcjQsIE1hdHJpeCB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XHJcbmltcG9ydCB7IENvbG9yNCB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL2VmZmVjdFwiO1xyXG5pbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9zaGFkZXJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL3RleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBOb2RlIH0gZnJvbSBcImNvcmUvbm9kZVwiO1xyXG5pbXBvcnQgdHlwZSB7IFNjZW5lIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuXHJcbi8qKlxyXG4gKiBVdGlscyBmdW5jdGlvbnMgZm9yIEdMVEZcclxuICogQGludGVybmFsXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR0xURlV0aWxzIHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gXCJwYXJhbWV0ZXJcIiBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBzY2VuZSB0aGUgU2NlbmUgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gc291cmNlIHRoZSBzb3VyY2Ugbm9kZSB3aGVyZSB0byBwaWNrIHRoZSBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXIgdGhlIEdMVEYgdGVjaG5pcXVlIHBhcmFtZXRlclxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIncyB1bmlmb3JtXHJcbiAgICAgKiBAcGFyYW0gc2hhZGVyTWF0ZXJpYWwgdGhlIHNoYWRlciBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNldE1hdHJpeChzY2VuZTogU2NlbmUsIHNvdXJjZTogTm9kZSwgcGFyYW1ldGVyOiBJR0xURlRlY2huaXF1ZVBhcmFtZXRlciwgdW5pZm9ybU5hbWU6IHN0cmluZywgc2hhZGVyTWF0ZXJpYWw6IFNoYWRlck1hdGVyaWFsIHwgRWZmZWN0KTogdm9pZCB7XHJcbiAgICAgICAgbGV0IG1hdDogTnVsbGFibGU8TWF0cml4PiA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChwYXJhbWV0ZXIuc2VtYW50aWMgPT09IFwiTU9ERUxcIikge1xyXG4gICAgICAgICAgICBtYXQgPSBzb3VyY2UuZ2V0V29ybGRNYXRyaXgoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlci5zZW1hbnRpYyA9PT0gXCJQUk9KRUNUSU9OXCIpIHtcclxuICAgICAgICAgICAgbWF0ID0gc2NlbmUuZ2V0UHJvamVjdGlvbk1hdHJpeCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIlZJRVdcIikge1xyXG4gICAgICAgICAgICBtYXQgPSBzY2VuZS5nZXRWaWV3TWF0cml4KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXIuc2VtYW50aWMgPT09IFwiTU9ERUxWSUVXSU5WRVJTRVRSQU5TUE9TRVwiKSB7XHJcbiAgICAgICAgICAgIG1hdCA9IE1hdHJpeC5UcmFuc3Bvc2Uoc291cmNlLmdldFdvcmxkTWF0cml4KCkubXVsdGlwbHkoc2NlbmUuZ2V0Vmlld01hdHJpeCgpKS5pbnZlcnQoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXIuc2VtYW50aWMgPT09IFwiTU9ERUxWSUVXXCIpIHtcclxuICAgICAgICAgICAgbWF0ID0gc291cmNlLmdldFdvcmxkTWF0cml4KCkubXVsdGlwbHkoc2NlbmUuZ2V0Vmlld01hdHJpeCgpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlci5zZW1hbnRpYyA9PT0gXCJNT0RFTFZJRVdQUk9KRUNUSU9OXCIpIHtcclxuICAgICAgICAgICAgbWF0ID0gc291cmNlLmdldFdvcmxkTWF0cml4KCkubXVsdGlwbHkoc2NlbmUuZ2V0VHJhbnNmb3JtTWF0cml4KCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIk1PREVMSU5WRVJTRVwiKSB7XHJcbiAgICAgICAgICAgIG1hdCA9IHNvdXJjZS5nZXRXb3JsZE1hdHJpeCgpLmludmVydCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIlZJRVdJTlZFUlNFXCIpIHtcclxuICAgICAgICAgICAgbWF0ID0gc2NlbmUuZ2V0Vmlld01hdHJpeCgpLmludmVydCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIlBST0pFQ1RJT05JTlZFUlNFXCIpIHtcclxuICAgICAgICAgICAgbWF0ID0gc2NlbmUuZ2V0UHJvamVjdGlvbk1hdHJpeCgpLmludmVydCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIk1PREVMVklFV0lOVkVSU0VcIikge1xyXG4gICAgICAgICAgICBtYXQgPSBzb3VyY2UuZ2V0V29ybGRNYXRyaXgoKS5tdWx0aXBseShzY2VuZS5nZXRWaWV3TWF0cml4KCkpLmludmVydCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIk1PREVMVklFV1BST0pFQ1RJT05JTlZFUlNFXCIpIHtcclxuICAgICAgICAgICAgbWF0ID0gc291cmNlLmdldFdvcmxkTWF0cml4KCkubXVsdGlwbHkoc2NlbmUuZ2V0VHJhbnNmb3JtTWF0cml4KCkpLmludmVydCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnNlbWFudGljID09PSBcIk1PREVMSU5WRVJTRVRSQU5TUE9TRVwiKSB7XHJcbiAgICAgICAgICAgIG1hdCA9IE1hdHJpeC5UcmFuc3Bvc2Uoc291cmNlLmdldFdvcmxkTWF0cml4KCkuaW52ZXJ0KCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1hdCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtZXRlci50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVQYXJhbWV0ZXJUeXBlLkZMT0FUX01BVDI6XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuc2V0TWF0cml4MngyKHVuaWZvcm1OYW1lLCBNYXRyaXguR2V0QXNNYXRyaXgyeDIobWF0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVQYXJhbWV0ZXJUeXBlLkZMT0FUX01BVDM6XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuc2V0TWF0cml4M3gzKHVuaWZvcm1OYW1lLCBNYXRyaXguR2V0QXNNYXRyaXgzeDMobWF0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVQYXJhbWV0ZXJUeXBlLkZMT0FUX01BVDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuc2V0TWF0cml4KHVuaWZvcm1OYW1lLCBtYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdpdmVuIFwicGFyYW1ldGVyXCIgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gc2hhZGVyTWF0ZXJpYWwgdGhlIHNoYWRlciBtYXRlcmlhbFxyXG4gICAgICogQHBhcmFtIHVuaWZvcm0gdGhlIG5hbWUgb2YgdGhlIHNoYWRlcidzIHVuaWZvcm1cclxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIHVuaWZvcm1cclxuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB1bmlmb3JtJ3MgdHlwZSAoRVBhcmFtZXRlclR5cGUgRkxPQVQsIFZFQzIsIFZFQzMgb3IgVkVDNClcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgc2V0LCBlbHNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU2V0VW5pZm9ybShzaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwgfCBFZmZlY3QsIHVuaWZvcm06IHN0cmluZywgdmFsdWU6IGFueSwgdHlwZTogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRVBhcmFtZXRlclR5cGUuRkxPQVQ6XHJcbiAgICAgICAgICAgICAgICBzaGFkZXJNYXRlcmlhbC5zZXRGbG9hdCh1bmlmb3JtLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgY2FzZSBFUGFyYW1ldGVyVHlwZS5GTE9BVF9WRUMyOlxyXG4gICAgICAgICAgICAgICAgc2hhZGVyTWF0ZXJpYWwuc2V0VmVjdG9yMih1bmlmb3JtLCBWZWN0b3IyLkZyb21BcnJheSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGNhc2UgRVBhcmFtZXRlclR5cGUuRkxPQVRfVkVDMzpcclxuICAgICAgICAgICAgICAgIHNoYWRlck1hdGVyaWFsLnNldFZlY3RvcjModW5pZm9ybSwgVmVjdG9yMy5Gcm9tQXJyYXkodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjYXNlIEVQYXJhbWV0ZXJUeXBlLkZMT0FUX1ZFQzQ6XHJcbiAgICAgICAgICAgICAgICBzaGFkZXJNYXRlcmlhbC5zZXRWZWN0b3I0KHVuaWZvcm0sIFZlY3RvcjQuRnJvbUFycmF5KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3cmFwIG1vZGUgb2YgdGhlIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgd3JhcCBtb2RlIChURVhUVVJFX1dSQVBfQUREUkVTU01PREUsIE1JUlJPUl9BRERSRVNTTU9ERSBvciBDTEFNUF9BRERSRVNTTU9ERSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHZXRXcmFwTW9kZShtb2RlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICBjYXNlIEVUZXh0dXJlV3JhcE1vZGUuQ0xBTVBfVE9fRURHRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFO1xyXG4gICAgICAgICAgICBjYXNlIEVUZXh0dXJlV3JhcE1vZGUuTUlSUk9SRURfUkVQRUFUOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuTUlSUk9SX0FERFJFU1NNT0RFO1xyXG4gICAgICAgICAgICBjYXNlIEVUZXh0dXJlV3JhcE1vZGUuUkVQRUFUOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuV1JBUF9BRERSRVNTTU9ERTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLldSQVBfQUREUkVTU01PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYnl0ZSBzdHJpZGUgZ2l2aW5nIGFuIGFjY2Vzc29yXHJcbiAgICAgKiBAcGFyYW0gYWNjZXNzb3IgdGhlIEdMVEYgYWNjZXNzb3Igb2JqZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSBieXRlIHN0cmlkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldEJ5dGVTdHJpZGVGcm9tVHlwZShhY2Nlc3NvcjogSUdMVEZBY2Nlc3Nvcik6IG51bWJlciB7XHJcbiAgICAgICAgLy8gTmVlZHMgdGhpcyBmdW5jdGlvbiBzaW5jZSBcImJ5dGVTdHJpZGVcIiBpc24ndCByZXF1aWVyZWQgaW4gZ2xURiBmb3JtYXRcclxuICAgICAgICBjb25zdCB0eXBlID0gYWNjZXNzb3IudHlwZTtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJWRUMyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgY2FzZSBcIlZFQzNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgICAgICBjYXNlIFwiVkVDNFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgICAgIGNhc2UgXCJNQVQyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgY2FzZSBcIk1BVDNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiA5O1xyXG4gICAgICAgICAgICBjYXNlIFwiTUFUNFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGV4dHVyZSBmaWx0ZXIgbW9kZSBnaXZpbmcgYSBtb2RlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gbW9kZSB0aGUgZmlsdGVyIG1vZGUgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHRoZSBmaWx0ZXIgbW9kZSAoVE9ETyAtIG5lZWRzIHRvIGJlIGEgdHlwZT8pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR2V0VGV4dHVyZUZpbHRlck1vZGUobW9kZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBFVGV4dHVyZUZpbHRlclR5cGUuTElORUFSOlxyXG4gICAgICAgICAgICBjYXNlIEVUZXh0dXJlRmlsdGVyVHlwZS5MSU5FQVJfTUlQTUFQX05FQVJFU1Q6XHJcbiAgICAgICAgICAgIGNhc2UgRVRleHR1cmVGaWx0ZXJUeXBlLkxJTkVBUl9NSVBNQVBfTElORUFSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERTtcclxuICAgICAgICAgICAgY2FzZSBFVGV4dHVyZUZpbHRlclR5cGUuTkVBUkVTVDpcclxuICAgICAgICAgICAgY2FzZSBFVGV4dHVyZUZpbHRlclR5cGUuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLk5FQVJFU1RfU0FNUExJTkdNT0RFO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuQklMSU5FQVJfU0FNUExJTkdNT0RFO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldEJ1ZmZlckZyb21CdWZmZXJWaWV3KFxyXG4gICAgICAgIGdsdGZSdW50aW1lOiBJR0xURlJ1bnRpbWUsXHJcbiAgICAgICAgYnVmZmVyVmlldzogSUdMVEZCdWZmZXJWaWV3LFxyXG4gICAgICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcclxuICAgICAgICBieXRlTGVuZ3RoOiBudW1iZXIsXHJcbiAgICAgICAgY29tcG9uZW50VHlwZTogRUNvbXBvbmVudFR5cGVcclxuICAgICk6IEFycmF5QnVmZmVyVmlldyB7XHJcbiAgICAgICAgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvYWRlZEJ1ZmZlclZpZXcgPSBnbHRmUnVudGltZS5sb2FkZWRCdWZmZXJWaWV3c1tidWZmZXJWaWV3LmJ1ZmZlcl07XHJcbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gbG9hZGVkQnVmZmVyVmlldy5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlciBhY2Nlc3MgaXMgb3V0IG9mIHJhbmdlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbG9hZGVkQnVmZmVyVmlldy5idWZmZXI7XHJcbiAgICAgICAgYnl0ZU9mZnNldCArPSBsb2FkZWRCdWZmZXJWaWV3LmJ5dGVPZmZzZXQ7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEVDb21wb25lbnRUeXBlLkJZVEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBjYXNlIEVDb21wb25lbnRUeXBlLlVOU0lHTkVEX0JZVEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgY2FzZSBFQ29tcG9uZW50VHlwZS5TSE9SVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBjYXNlIEVDb21wb25lbnRUeXBlLlVOU0lHTkVEX1NIT1JUOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYnVmZmVyIGZyb20gaXRzIGFjY2Vzc29yXHJcbiAgICAgKiBAcGFyYW0gZ2x0ZlJ1bnRpbWUgdGhlIEdMVEYgcnVudGltZVxyXG4gICAgICogQHBhcmFtIGFjY2Vzc29yIHRoZSBHTFRGIGFjY2Vzc29yXHJcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBidWZmZXIgdmlld1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldEJ1ZmZlckZyb21BY2Nlc3NvcihnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBhY2Nlc3NvcjogSUdMVEZBY2Nlc3Nvcik6IGFueSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyVmlldzogSUdMVEZCdWZmZXJWaWV3ID0gZ2x0ZlJ1bnRpbWUuYnVmZmVyVmlld3NbYWNjZXNzb3IuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGFjY2Vzc29yLmNvdW50ICogR0xURlV0aWxzLkdldEJ5dGVTdHJpZGVGcm9tVHlwZShhY2Nlc3Nvcik7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZVdGlscy5HZXRCdWZmZXJGcm9tQnVmZmVyVmlldyhnbHRmUnVudGltZSwgYnVmZmVyVmlldywgYWNjZXNzb3IuYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCwgYWNjZXNzb3IuY29tcG9uZW50VHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgYnVmZmVyIHZpZXcgaW50byBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHZpZXcgdGhlIGJ1ZmZlciB2aWV3XHJcbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERlY29kZUJ1ZmZlclRvVGV4dCh2aWV3OiBBcnJheUJ1ZmZlclZpZXcpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoPGFueT52aWV3KVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBtYXRlcmlhbCBvZiBnbHRmLiBSZWxhdGVkIHRvXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8xLjAjYXBwZW5kaXgtYS1kZWZhdWx0LW1hdGVyaWFsXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgdGhlIEJhYnlsb24uanMgc2NlbmVcclxuICAgICAqIEByZXR1cm5zIHRoZSBkZWZhdWx0IEJhYnlsb24gbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHZXREZWZhdWx0TWF0ZXJpYWwoc2NlbmU6IFNjZW5lKTogU2hhZGVyTWF0ZXJpYWwge1xyXG4gICAgICAgIGlmICghR0xURlV0aWxzLl9EZWZhdWx0TWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgRWZmZWN0LlNoYWRlcnNTdG9yZVtcIkdMVEZEZWZhdWx0TWF0ZXJpYWxWZXJ0ZXhTaGFkZXJcIl0gPSBbXHJcbiAgICAgICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIixcclxuICAgICAgICAgICAgICAgIFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInVuaWZvcm0gbWF0NCB3b3JsZFZpZXc7XCIsXHJcbiAgICAgICAgICAgICAgICBcInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uO1wiLFxyXG4gICAgICAgICAgICAgICAgXCJcIixcclxuICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgICAgICAgICBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJ2b2lkIG1haW4odm9pZClcIixcclxuICAgICAgICAgICAgICAgIFwie1wiLFxyXG4gICAgICAgICAgICAgICAgXCIgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uICogd29ybGRWaWV3ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICAgICAgICAgIFwifVwiLFxyXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIik7XHJcblxyXG4gICAgICAgICAgICBFZmZlY3QuU2hhZGVyc1N0b3JlW1wiR0xURkRlZmF1bHRNYXRlcmlhbFBpeGVsU2hhZGVyXCJdID0gW1xyXG4gICAgICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIsXHJcbiAgICAgICAgICAgICAgICBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJ1bmlmb3JtIHZlYzQgdV9lbWlzc2lvbjtcIixcclxuICAgICAgICAgICAgICAgIFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInZvaWQgbWFpbih2b2lkKVwiLFxyXG4gICAgICAgICAgICAgICAgXCJ7XCIsXHJcbiAgICAgICAgICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB1X2VtaXNzaW9uO1wiLFxyXG4gICAgICAgICAgICAgICAgXCJ9XCIsXHJcbiAgICAgICAgICAgIF0uam9pbihcIlxcblwiKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlclBhdGggPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXg6IFwiR0xURkRlZmF1bHRNYXRlcmlhbFwiLFxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQ6IFwiR0xURkRlZmF1bHRNYXRlcmlhbFwiLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcInBvc2l0aW9uXCJdLFxyXG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IFtcIndvcmxkVmlld1wiLCBcInByb2plY3Rpb25cIiwgXCJ1X2VtaXNzaW9uXCJdLFxyXG4gICAgICAgICAgICAgICAgc2FtcGxlcnM6IG5ldyBBcnJheTxzdHJpbmc+KCksXHJcbiAgICAgICAgICAgICAgICBuZWVkQWxwaGFCbGVuZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBHTFRGVXRpbHMuX0RlZmF1bHRNYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbChcIkdMVEZEZWZhdWx0TWF0ZXJpYWxcIiwgc2NlbmUsIHNoYWRlclBhdGgsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBHTFRGVXRpbHMuX0RlZmF1bHRNYXRlcmlhbC5zZXRDb2xvcjQoXCJ1X2VtaXNzaW9uXCIsIG5ldyBDb2xvcjQoMC41LCAwLjUsIDAuNSwgMS4wKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gR0xURlV0aWxzLl9EZWZhdWx0TWF0ZXJpYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIEdMVEYgZGVmYXVsdCBtYXRlcmlhbFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX0RlZmF1bHRNYXRlcmlhbDogTnVsbGFibGU8U2hhZGVyTWF0ZXJpYWw+ID0gbnVsbDtcclxufVxyXG4iLCJpbXBvcnQgeyBHTFRGTG9hZGVyRXh0ZW5zaW9uLCBHTFRGTG9hZGVyQmFzZSwgR0xURkxvYWRlciB9IGZyb20gXCIuL2dsVEZMb2FkZXJcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgSUdMVEZSdW50aW1lLCBJR0xURk1hdGVyaWFsIH0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuXHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5pbXBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL3N0YW5kYXJkTWF0ZXJpYWxcIjtcclxuaW1wb3J0IHsgSGVtaXNwaGVyaWNMaWdodCB9IGZyb20gXCJjb3JlL0xpZ2h0cy9oZW1pc3BoZXJpY0xpZ2h0XCI7XHJcbmltcG9ydCB7IERpcmVjdGlvbmFsTGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvZGlyZWN0aW9uYWxMaWdodFwiO1xyXG5pbXBvcnQgeyBQb2ludExpZ2h0IH0gZnJvbSBcImNvcmUvTGlnaHRzL3BvaW50TGlnaHRcIjtcclxuaW1wb3J0IHsgU3BvdExpZ2h0IH0gZnJvbSBcImNvcmUvTGlnaHRzL3Nwb3RMaWdodFwiO1xyXG5cclxuaW50ZXJmYWNlIElHTFRGTWF0ZXJpYWxzQ29tbW9uRXh0ZW5zaW9uVmFsdWVzIHtcclxuICAgIGFtYmllbnQ/OiBudW1iZXJbXSB8IHN0cmluZztcclxuICAgIGRpZmZ1c2U/OiBudW1iZXJbXSB8IHN0cmluZztcclxuICAgIGVtaXNzaW9uPzogbnVtYmVyW10gfCBzdHJpbmc7XHJcbiAgICBzcGVjdWxhcj86IG51bWJlcltdIHwgc3RyaW5nO1xyXG4gICAgc2hpbmluZXNzPzogbnVtYmVyO1xyXG4gICAgdHJhbnNwYXJlbmN5PzogbnVtYmVyO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSUdMVEZNYXRlcmlhbHNDb21tb25FeHRlbnNpb24ge1xyXG4gICAgdGVjaG5pcXVlOiBzdHJpbmc7XHJcbiAgICB0cmFuc3BhcmVudD86IG51bWJlcjtcclxuICAgIGRvdWJsZVNpZGVkPzogYm9vbGVhbjtcclxuICAgIHZhbHVlczogSUdMVEZNYXRlcmlhbHNDb21tb25FeHRlbnNpb25WYWx1ZXM7XHJcbn1cclxuXHJcbmludGVyZmFjZSBJR0xURlJ1bnRpbWVDb21tb25FeHRlbnNpb24ge1xyXG4gICAgbGlnaHRzOiB7IFtrZXk6IHN0cmluZ106IElHTFRGTGlnaHRDb21tb25FeHRlbnNpb24gfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIElHTFRGTGlnaHRDb21tb25FeHRlbnNpb24ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG5cclxuICAgIGFtYmllbnQ/OiBJR0xURkFtYmllbnRMaWdodENvbW1vbkV4dGVuc2lvbjtcclxuICAgIHBvaW50PzogSUdMVEZQb2ludExpZ2h0Q29tbW9uRXh0ZW5zaW9uO1xyXG4gICAgZGlyZWN0aW9uYWw/OiBJR0xURkRpcmVjdGlvbmFsTGlnaHRDb21tb25FeHRlbnNpb247XHJcbiAgICBzcG90PzogSUdMVEZTcG90TGlnaHRDb21tb25FeHRlbnNpb247XHJcbn1cclxuXHJcbmludGVyZmFjZSBJR0xURlBvaW50TGlnaHRDb21tb25FeHRlbnNpb24ge1xyXG4gICAgY29sb3I6IG51bWJlcltdO1xyXG4gICAgY29uc3RhbnRBdHRlbnVhdGlvbjogbnVtYmVyO1xyXG4gICAgbGluZWFyQXR0ZW51YXRpb246IG51bWJlcjtcclxuICAgIHF1YWRyYXRpY0F0dGVudWF0aW9uOiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBJR0xURkFtYmllbnRMaWdodENvbW1vbkV4dGVuc2lvbiB7XHJcbiAgICBjb2xvcjogbnVtYmVyW107XHJcbn1cclxuXHJcbmludGVyZmFjZSBJR0xURkRpcmVjdGlvbmFsTGlnaHRDb21tb25FeHRlbnNpb24ge1xyXG4gICAgY29sb3I6IG51bWJlcltdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSUdMVEZTcG90TGlnaHRDb21tb25FeHRlbnNpb24ge1xyXG4gICAgY29sb3I6IG51bWJlcltdO1xyXG4gICAgY29uc3RhbnRBdHRlbnVhdGlvbjogbnVtYmVyO1xyXG4gICAgZmFsbE9mZkFuZ2xlOiBudW1iZXI7XHJcbiAgICBmYWxsT2ZmRXhwb25lbnQ6IG51bWJlcjtcclxuICAgIGxpbmVhckF0dGVudWF0aW9uOiBudW1iZXI7XHJcbiAgICBxdWFkcmF0aWNBdHRlbnVhdGlvbjogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR0xURk1hdGVyaWFsc0NvbW1vbkV4dGVuc2lvbiBleHRlbmRzIEdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoXCJLSFJfbWF0ZXJpYWxzX2NvbW1vblwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBvdmVycmlkZSBsb2FkUnVudGltZUV4dGVuc2lvbnNBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKCFnbHRmUnVudGltZS5leHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbjogSUdMVEZSdW50aW1lQ29tbW9uRXh0ZW5zaW9uID0gZ2x0ZlJ1bnRpbWUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xyXG4gICAgICAgIGlmICghZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBsaWdodHNcclxuICAgICAgICBjb25zdCBsaWdodHMgPSBleHRlbnNpb24ubGlnaHRzO1xyXG4gICAgICAgIGlmIChsaWdodHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0aGluZyBpbiBsaWdodHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpZ2h0OiBJR0xURkxpZ2h0Q29tbW9uRXh0ZW5zaW9uID0gbGlnaHRzW3RoaW5nXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxpZ2h0LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW1iaWVudFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBIZW1pc3BoZXJpY0xpZ2h0KGxpZ2h0Lm5hbWUsIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBnbHRmUnVudGltZS5zY2VuZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtYmllbnQgPSBsaWdodC5hbWJpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1iaWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWVudExpZ2h0LmRpZmZ1c2UgPSBDb2xvcjMuRnJvbUFycmF5KGFtYmllbnQuY29sb3IgfHwgWzEsIDEsIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBvaW50XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRMaWdodCA9IG5ldyBQb2ludExpZ2h0KGxpZ2h0Lm5hbWUsIG5ldyBWZWN0b3IzKDEwLCAxMCwgMTApLCBnbHRmUnVudGltZS5zY2VuZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbGlnaHQucG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRMaWdodC5kaWZmdXNlID0gQ29sb3IzLkZyb21BcnJheShwb2ludC5jb2xvciB8fCBbMSwgMSwgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGlyZWN0aW9uYWxcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJMaWdodCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGxpZ2h0Lm5hbWUsIG5ldyBWZWN0b3IzKDAsIC0xLCAwKSwgZ2x0ZlJ1bnRpbWUuc2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25hbCA9IGxpZ2h0LmRpcmVjdGlvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpckxpZ2h0LmRpZmZ1c2UgPSBDb2xvcjMuRnJvbUFycmF5KGRpcmVjdGlvbmFsLmNvbG9yIHx8IFsxLCAxLCAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzcG90XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BvdCA9IGxpZ2h0LnNwb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcG90TGlnaHQgPSBuZXcgU3BvdExpZ2h0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjMoMCwgMTAsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKDAsIC0xLCAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcG90LmZhbGxPZmZBbmdsZSB8fCBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwb3QuZmFsbE9mZkV4cG9uZW50IHx8IDAuMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbHRmUnVudGltZS5zY2VuZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwb3RMaWdodC5kaWZmdXNlID0gQ29sb3IzLkZyb21BcnJheShzcG90LmNvbG9yIHx8IFsxLCAxLCAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRvb2xzLldhcm4oJ0dMVEYgTWF0ZXJpYWwgQ29tbW9uIGV4dGVuc2lvbjogbGlnaHQgdHlwZSBcIicgKyBsaWdodC50eXBlICsgXCLigJ0gbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBvdmVycmlkZSBsb2FkTWF0ZXJpYWxBc3luYyhnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBpZDogc3RyaW5nLCBvblN1Y2Nlc3M6IChtYXRlcmlhbDogTWF0ZXJpYWwpID0+IHZvaWQsIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbDogSUdMVEZNYXRlcmlhbCA9IGdsdGZSdW50aW1lLm1hdGVyaWFsc1tpZF07XHJcbiAgICAgICAgaWYgKCFtYXRlcmlhbCB8fCAhbWF0ZXJpYWwuZXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBleHRlbnNpb246IElHTFRGTWF0ZXJpYWxzQ29tbW9uRXh0ZW5zaW9uID0gbWF0ZXJpYWwuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xyXG4gICAgICAgIGlmICghZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YW5kYXJkTWF0ZXJpYWwgPSBuZXcgU3RhbmRhcmRNYXRlcmlhbChpZCwgZ2x0ZlJ1bnRpbWUuc2NlbmUpO1xyXG4gICAgICAgIHN0YW5kYXJkTWF0ZXJpYWwuc2lkZU9yaWVudGF0aW9uID0gTWF0ZXJpYWwuQ291bnRlckNsb2NrV2lzZVNpZGVPcmllbnRhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbi50ZWNobmlxdWUgPT09IFwiQ09OU1RBTlRcIikge1xyXG4gICAgICAgICAgICBzdGFuZGFyZE1hdGVyaWFsLmRpc2FibGVMaWdodGluZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGFuZGFyZE1hdGVyaWFsLmJhY2tGYWNlQ3VsbGluZyA9IGV4dGVuc2lvbi5kb3VibGVTaWRlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhZXh0ZW5zaW9uLmRvdWJsZVNpZGVkO1xyXG4gICAgICAgIHN0YW5kYXJkTWF0ZXJpYWwuYWxwaGEgPSBleHRlbnNpb24udmFsdWVzLnRyYW5zcGFyZW5jeSA9PT0gdW5kZWZpbmVkID8gMS4wIDogZXh0ZW5zaW9uLnZhbHVlcy50cmFuc3BhcmVuY3k7XHJcbiAgICAgICAgc3RhbmRhcmRNYXRlcmlhbC5zcGVjdWxhclBvd2VyID0gZXh0ZW5zaW9uLnZhbHVlcy5zaGluaW5lc3MgPT09IHVuZGVmaW5lZCA/IDAuMCA6IGV4dGVuc2lvbi52YWx1ZXMuc2hpbmluZXNzO1xyXG5cclxuICAgICAgICAvLyBBbWJpZW50XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24udmFsdWVzLmFtYmllbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZFRleHR1cmUoZ2x0ZlJ1bnRpbWUsIGV4dGVuc2lvbi52YWx1ZXMuYW1iaWVudCwgc3RhbmRhcmRNYXRlcmlhbCwgXCJhbWJpZW50VGV4dHVyZVwiLCBvbkVycm9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFuZGFyZE1hdGVyaWFsLmFtYmllbnRDb2xvciA9IENvbG9yMy5Gcm9tQXJyYXkoZXh0ZW5zaW9uLnZhbHVlcy5hbWJpZW50IHx8IFswLCAwLCAwXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEaWZmdXNlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24udmFsdWVzLmRpZmZ1c2UgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZFRleHR1cmUoZ2x0ZlJ1bnRpbWUsIGV4dGVuc2lvbi52YWx1ZXMuZGlmZnVzZSwgc3RhbmRhcmRNYXRlcmlhbCwgXCJkaWZmdXNlVGV4dHVyZVwiLCBvbkVycm9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFuZGFyZE1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IENvbG9yMy5Gcm9tQXJyYXkoZXh0ZW5zaW9uLnZhbHVlcy5kaWZmdXNlIHx8IFswLCAwLCAwXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbWlzc2lvblxyXG4gICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLnZhbHVlcy5lbWlzc2lvbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkVGV4dHVyZShnbHRmUnVudGltZSwgZXh0ZW5zaW9uLnZhbHVlcy5lbWlzc2lvbiwgc3RhbmRhcmRNYXRlcmlhbCwgXCJlbWlzc2l2ZVRleHR1cmVcIiwgb25FcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhbmRhcmRNYXRlcmlhbC5lbWlzc2l2ZUNvbG9yID0gQ29sb3IzLkZyb21BcnJheShleHRlbnNpb24udmFsdWVzLmVtaXNzaW9uIHx8IFswLCAwLCAwXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTcGVjdWxhclxyXG4gICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLnZhbHVlcy5zcGVjdWxhciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkVGV4dHVyZShnbHRmUnVudGltZSwgZXh0ZW5zaW9uLnZhbHVlcy5zcGVjdWxhciwgc3RhbmRhcmRNYXRlcmlhbCwgXCJzcGVjdWxhclRleHR1cmVcIiwgb25FcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhbmRhcmRNYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gQ29sb3IzLkZyb21BcnJheShleHRlbnNpb24udmFsdWVzLnNwZWN1bGFyIHx8IFswLCAwLCAwXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sb2FkVGV4dHVyZShnbHRmUnVudGltZTogSUdMVEZSdW50aW1lLCBpZDogc3RyaW5nLCBtYXRlcmlhbDogU3RhbmRhcmRNYXRlcmlhbCwgcHJvcGVydHlQYXRoOiBzdHJpbmcsIG9uRXJyb3I6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICAvLyBDcmVhdGUgYnVmZmVyIGZyb20gdGV4dHVyZSB1cmxcclxuICAgICAgICBHTFRGTG9hZGVyQmFzZS5Mb2FkVGV4dHVyZUJ1ZmZlckFzeW5jKFxyXG4gICAgICAgICAgICBnbHRmUnVudGltZSxcclxuICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgIChidWZmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0ZXh0dXJlIGZyb20gYnVmZmVyXHJcbiAgICAgICAgICAgICAgICBHTFRGTG9hZGVyQmFzZS5DcmVhdGVUZXh0dXJlQXN5bmMoZ2x0ZlJ1bnRpbWUsIGlkLCBidWZmZXIsICh0ZXh0dXJlKSA9PiAoKDxhbnk+bWF0ZXJpYWwpW3Byb3BlcnR5UGF0aF0gPSB0ZXh0dXJlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXJyb3JcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5HTFRGTG9hZGVyLlJlZ2lzdGVyRXh0ZW5zaW9uKG5ldyBHTFRGTWF0ZXJpYWxzQ29tbW9uRXh0ZW5zaW9uKCkpO1xyXG4iLCJleHBvcnQgKiBmcm9tIFwiLi9nbFRGQmluYXJ5RXh0ZW5zaW9uXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2dsVEZMb2FkZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURkxvYWRlclV0aWxzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2dsVEZNYXRlcmlhbHNDb21tb25FeHRlbnNpb25cIjtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSBcImNvcmUvTWF0aHMvbWF0aC52ZWN0b3JcIjtcclxuaW1wb3J0IHsgQ29sb3IzIH0gZnJvbSBcImNvcmUvTWF0aHMvbWF0aC5jb2xvclwiO1xyXG5pbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvc3BvdExpZ2h0XCI7XHJcbmltcG9ydCB7IExpZ2h0IH0gZnJvbSBcImNvcmUvTGlnaHRzL2xpZ2h0XCI7XHJcbmltcG9ydCB0eXBlIHsgVHJhbnNmb3JtTm9kZSB9IGZyb20gXCJjb3JlL01lc2hlcy90cmFuc2Zvcm1Ob2RlXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElFWFRMaWdodHNJRVNfTGlnaHRSZWZlcmVuY2UgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB0eXBlIHsgSUVYVExpZ2h0c0lFU19MaWdodCwgSU5vZGUgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIsIEFycmF5SXRlbSB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiRVhUX2xpZ2h0c19pZXNcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBFWFRfbGlnaHRzX2llcyBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiRVhUX2xpZ2h0c19pZXNcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21haW4vZXh0ZW5zaW9ucy8yLjAvVmVuZG9yL0VYVF9saWdodHNfaWVzKVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgRVhUX2xpZ2h0c19pZXMgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIGhpZGRlbiAqL1xyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG4gICAgcHJpdmF0ZSBfbGlnaHRzPzogSUVYVExpZ2h0c0lFU19MaWdodFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xpZ2h0cztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgb25Mb2FkaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLl9sb2FkZXIuZ2x0Zi5leHRlbnNpb25zO1xyXG4gICAgICAgIGlmIChleHRlbnNpb25zICYmIGV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xyXG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zW3RoaXMubmFtZV07XHJcbiAgICAgICAgICAgIHRoaXMuX2xpZ2h0cyA9IGV4dGVuc2lvbi5saWdodHM7XHJcbiAgICAgICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fbGlnaHRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTm9kZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgbm9kZTogSU5vZGUsIGFzc2lnbjogKGJhYnlsb25UcmFuc2Zvcm1Ob2RlOiBUcmFuc2Zvcm1Ob2RlKSA9PiB2b2lkKTogTnVsbGFibGU8UHJvbWlzZTxUcmFuc2Zvcm1Ob2RlPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJRVhUTGlnaHRzSUVTX0xpZ2h0UmVmZXJlbmNlLCBUcmFuc2Zvcm1Ob2RlPihjb250ZXh0LCBub2RlLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLl9hbGxNYXRlcmlhbHNEaXJ0eVJlcXVpcmVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBiYWJ5bG9uU3BvdExpZ2h0OiBTcG90TGlnaHQ7XHJcbiAgICAgICAgICAgIGxldCBsaWdodDogSUVYVExpZ2h0c0lFU19MaWdodDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybU5vZGUgPSBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZE5vZGVBc3luYyhjb250ZXh0LCBub2RlLCAoYmFieWxvbk1lc2gpID0+IHtcclxuICAgICAgICAgICAgICAgIGxpZ2h0ID0gQXJyYXlJdGVtLkdldChleHRlbnNpb25Db250ZXh0LCB0aGlzLl9saWdodHMsIGV4dGVuc2lvbi5saWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gbGlnaHQubmFtZSB8fCBiYWJ5bG9uTWVzaC5uYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fbG9hZGVyLl9hc3NldENvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uU3BvdExpZ2h0ID0gbmV3IFNwb3RMaWdodChuYW1lLCBWZWN0b3IzLlplcm8oKSwgVmVjdG9yMy5CYWNrd2FyZCgpLCAwLCAxLCB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lKTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25TcG90TGlnaHQuYW5nbGUgPSBNYXRoLlBJIC8gMjtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25TcG90TGlnaHQuaW5uZXJBbmdsZSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgYmFieWxvblNwb3RMaWdodC5fcGFyZW50Q29udGFpbmVyID0gdGhpcy5fbG9hZGVyLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGlnaHQuX2JhYnlsb25MaWdodCA9IGJhYnlsb25TcG90TGlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgYmFieWxvblNwb3RMaWdodC5mYWxsb2ZmVHlwZSA9IExpZ2h0LkZBTExPRkZfR0xURjtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25TcG90TGlnaHQuZGlmZnVzZSA9IGV4dGVuc2lvbi5jb2xvciA/IENvbG9yMy5Gcm9tQXJyYXkoZXh0ZW5zaW9uLmNvbG9yKSA6IENvbG9yMy5XaGl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvblNwb3RMaWdodC5pbnRlbnNpdHkgPSBleHRlbnNpb24ubXVsdGlwbGllciB8fCAxO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvblNwb3RMaWdodC5yYW5nZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uU3BvdExpZ2h0LnBhcmVudCA9IGJhYnlsb25NZXNoO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5fYmFieWxvbkxpZ2h0cy5wdXNoKGJhYnlsb25TcG90TGlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXIuQWRkUG9pbnRlck1ldGFkYXRhKGJhYnlsb25TcG90TGlnaHQsIGV4dGVuc2lvbkNvbnRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uTWVzaCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCB0aGUgcHJvZmlsZVxyXG4gICAgICAgICAgICBsZXQgYnVmZmVyRGF0YTogQXJyYXlCdWZmZXJWaWV3O1xyXG4gICAgICAgICAgICBpZiAobGlnaHQhLnVyaSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IGF3YWl0IHRoaXMuX2xvYWRlci5sb2FkVXJpQXN5bmMoY29udGV4dCwgbGlnaHQhLCBsaWdodCEudXJpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2J1ZmZlclZpZXdgLCB0aGlzLl9sb2FkZXIuZ2x0Zi5idWZmZXJWaWV3cywgbGlnaHQhLmJ1ZmZlclZpZXcpO1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IGF3YWl0IHRoaXMuX2xvYWRlci5sb2FkQnVmZmVyVmlld0FzeW5jKGAvYnVmZmVyVmlld3MvJHtidWZmZXJWaWV3LmluZGV4fWAsIGJ1ZmZlclZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhYnlsb25TcG90TGlnaHQhLmllc1Byb2ZpbGVUZXh0dXJlID0gbmV3IFRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICBuYW1lICsgXCJfaWVzUHJvZmlsZVwiLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmJhYnlsb25TY2VuZSxcclxuICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSxcclxuICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBcIi5pZXNcIlxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybU5vZGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEVYVF9saWdodHNfaWVzKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHsgU3BoZXJpY2FsSGFybW9uaWNzLCBTcGhlcmljYWxQb2x5bm9taWFsIH0gZnJvbSBcImNvcmUvTWF0aHMvc3BoZXJpY2FsUG9seW5vbWlhbFwiO1xyXG5pbXBvcnQgeyBRdWF0ZXJuaW9uLCBNYXRyaXggfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgdHlwZSB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlXCI7XHJcbmltcG9ydCB7IFJhd0N1YmVUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL3Jhd0N1YmVUZXh0dXJlXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElFWFRMaWdodHNJbWFnZUJhc2VkX0xpZ2h0UmVmZXJlbmNlSW1hZ2VCYXNlZCwgSUVYVExpZ2h0c0ltYWdlQmFzZWRfTGlnaHRJbWFnZUJhc2VkLCBJRVhUTGlnaHRzSW1hZ2VCYXNlZCB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHR5cGUgeyBJU2NlbmUgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIsIEFycmF5SXRlbSB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJFWFRfbGlnaHRzX2ltYWdlX2Jhc2VkXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgRVhUX2xpZ2h0c19pbWFnZV9iYXNlZCBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiRVhUX2xpZ2h0c19pbWFnZV9iYXNlZFwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCIge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgaW50ZXJmYWNlIElFWFRMaWdodHNJbWFnZUJhc2VkX0xpZ2h0SW1hZ2VCYXNlZCB7XHJcbiAgICAgICAgX2JhYnlsb25UZXh0dXJlPzogQmFzZVRleHR1cmU7XHJcbiAgICAgICAgX2xvYWRlZD86IFByb21pc2U8dm9pZD47XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX2xpZ2h0c19pbWFnZV9iYXNlZC9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBFWFRfbGlnaHRzX2ltYWdlX2Jhc2VkIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuICAgIHByaXZhdGUgX2xpZ2h0cz86IElFWFRMaWdodHNJbWFnZUJhc2VkX0xpZ2h0SW1hZ2VCYXNlZFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xpZ2h0cztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgb25Mb2FkaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLl9sb2FkZXIuZ2x0Zi5leHRlbnNpb25zO1xyXG4gICAgICAgIGlmIChleHRlbnNpb25zICYmIGV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xyXG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zW3RoaXMubmFtZV0gYXMgSUVYVExpZ2h0c0ltYWdlQmFzZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpZ2h0cyA9IGV4dGVuc2lvbi5saWdodHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRTY2VuZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgc2NlbmU6IElTY2VuZSk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUVYVExpZ2h0c0ltYWdlQmFzZWRfTGlnaHRSZWZlcmVuY2VJbWFnZUJhc2VkPihjb250ZXh0LCBzY2VuZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5fYWxsTWF0ZXJpYWxzRGlydHlSZXF1aXJlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRlci5sb2FkU2NlbmVBc3luYyhjb250ZXh0LCBzY2VuZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvZ09wZW4oYCR7ZXh0ZW5zaW9uQ29udGV4dH1gKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gQXJyYXlJdGVtLkdldChgJHtleHRlbnNpb25Db250ZXh0fS9saWdodGAsIHRoaXMuX2xpZ2h0cywgZXh0ZW5zaW9uLmxpZ2h0KTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZExpZ2h0QXN5bmMoYC9leHRlbnNpb25zLyR7dGhpcy5uYW1lfS9saWdodHMvJHtleHRlbnNpb24ubGlnaHR9YCwgbGlnaHQpLnRoZW4oKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLmVudmlyb25tZW50VGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvZ0Nsb3NlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9sb2FkTGlnaHRBc3luYyhjb250ZXh0OiBzdHJpbmcsIGxpZ2h0OiBJRVhUTGlnaHRzSW1hZ2VCYXNlZF9MaWdodEltYWdlQmFzZWQpOiBQcm9taXNlPEJhc2VUZXh0dXJlPiB7XHJcbiAgICAgICAgaWYgKCFsaWdodC5fbG9hZGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2dPcGVuKGAke2NvbnRleHR9YCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgQXJyYXk8QXJyYXk8QXJyYXlCdWZmZXJWaWV3Pj4obGlnaHQuc3BlY3VsYXJJbWFnZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbWlwbWFwID0gMDsgbWlwbWFwIDwgbGlnaHQuc3BlY3VsYXJJbWFnZXMubGVuZ3RoOyBtaXBtYXArKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmFjZXMgPSBsaWdodC5zcGVjdWxhckltYWdlc1ttaXBtYXBdO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhW21pcG1hcF0gPSBuZXcgQXJyYXk8QXJyYXlCdWZmZXJWaWV3PihmYWNlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBmYWNlcy5sZW5ndGg7IGZhY2UrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwZWN1bGFySW1hZ2VDb250ZXh0ID0gYCR7Y29udGV4dH0vc3BlY3VsYXJJbWFnZXMvJHttaXBtYXB9LyR7ZmFjZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2dPcGVuKGAke3NwZWN1bGFySW1hZ2VDb250ZXh0fWApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZhY2VzW2ZhY2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gQXJyYXlJdGVtLkdldChzcGVjdWxhckltYWdlQ29udGV4dCwgdGhpcy5fbG9hZGVyLmdsdGYuaW1hZ2VzLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkSW1hZ2VBc3luYyhgL2ltYWdlcy8ke2luZGV4fWAsIGltYWdlKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbbWlwbWFwXVtmYWNlXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvZ0Nsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2dDbG9zZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgIGxpZ2h0Ll9sb2FkZWQgPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uVGV4dHVyZSA9IG5ldyBSYXdDdWJlVGV4dHVyZSh0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLCBudWxsLCBsaWdodC5zcGVjdWxhckltYWdlU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uVGV4dHVyZS5uYW1lID0gbGlnaHQubmFtZSB8fCBcImVudmlyb25tZW50XCI7XHJcbiAgICAgICAgICAgICAgICBsaWdodC5fYmFieWxvblRleHR1cmUgPSBiYWJ5bG9uVGV4dHVyZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGlnaHQuaW50ZW5zaXR5ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25UZXh0dXJlLmxldmVsID0gbGlnaHQuaW50ZW5zaXR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsaWdodC5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByb3RhdGlvbiA9IFF1YXRlcm5pb24uRnJvbUFycmF5KGxpZ2h0LnJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52ZXJ0IHRoZSByb3RhdGlvbiBzbyB0aGF0IHBvc2l0aXZlIHJvdGF0aW9uIGlzIGNvdW50ZXItY2xvY2t3aXNlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGVyLmJhYnlsb25TY2VuZS51c2VSaWdodEhhbmRlZFN5c3RlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IFF1YXRlcm5pb24uSW52ZXJzZShyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBNYXRyaXguRnJvbVF1YXRlcm5pb25Ub1JlZihyb3RhdGlvbiwgYmFieWxvblRleHR1cmUuZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXgoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFsaWdodC5pcnJhZGlhbmNlQ29lZmZpY2llbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBJcnJhZGlhbmNlIGNvZWZmaWNpZW50cyBhcmUgbWlzc2luZ2ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwaGVyaWNhbEhhcm1vbmljcyA9IFNwaGVyaWNhbEhhcm1vbmljcy5Gcm9tQXJyYXkobGlnaHQuaXJyYWRpYW5jZUNvZWZmaWNpZW50cyk7XHJcbiAgICAgICAgICAgICAgICBzcGhlcmljYWxIYXJtb25pY3Muc2NhbGVJblBsYWNlKGxpZ2h0LmludGVuc2l0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3BoZXJpY2FsSGFybW9uaWNzLmNvbnZlcnRJcnJhZGlhbmNlVG9MYW1iZXJ0aWFuUmFkaWFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwaGVyaWNhbFBvbHlub21pYWwgPSBTcGhlcmljYWxQb2x5bm9taWFsLkZyb21IYXJtb25pY3Moc3BoZXJpY2FsSGFybW9uaWNzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsb2QgZ2VuZXJhdGlvbiBzY2FsZSB0byBmaXQgZXhhY3RseSB0byB0aGUgbnVtYmVyIG9mIGxldmVscyBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2RHZW5lcmF0aW9uU2NhbGUgPSAoaW1hZ2VEYXRhLmxlbmd0aCAtIDEpIC8gTWF0aC5sb2cyKGxpZ2h0LnNwZWN1bGFySW1hZ2VTaXplKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBiYWJ5bG9uVGV4dHVyZS51cGRhdGVSR0JEQXN5bmMoaW1hZ2VEYXRhLCBzcGhlcmljYWxQb2x5bm9taWFsLCBsb2RHZW5lcmF0aW9uU2NhbGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiBsaWdodC5fbG9hZGVkLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlnaHQuX2JhYnlsb25UZXh0dXJlITtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgRVhUX2xpZ2h0c19pbWFnZV9iYXNlZChsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElNYXRlcmlhbCB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUVYVE1hdGVyaWFsc0RpZmZ1c2VSb3VnaG5lc3MgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gXCJjb3JlL0VuZ2luZXMvY29uc3RhbnRzXCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJFWFRfbWF0ZXJpYWxzX2RpZmZ1c2Vfcm91Z2huZXNzXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgRVhUX21hdGVyaWFsc19kaWZmdXNlX3JvdWdobmVzcyBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiRVhUX21hdGVyaWFsc19kaWZmdXNlX3JvdWdobmVzc1wiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvZmRlZTM1NDI1YWU1NjBlYTM3ODA5MmUzODk3NzIxNmQ2M2EwOTRlYy9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0VYVF9tYXRlcmlhbHNfZGlmZnVzZV9yb3VnaG5lc3MvUkVBRE1FLm1kKVxyXG4gKiBAZXhwZXJpbWVudGFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBFWFRfbWF0ZXJpYWxzX2RpZmZ1c2Vfcm91Z2huZXNzIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxOTA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElFWFRNYXRlcmlhbHNEaWZmdXNlUm91Z2huZXNzPihjb250ZXh0LCBtYXRlcmlhbCwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkRGlmZnVzZVJvdWdobmVzc1Byb3BlcnRpZXNBc3luYyhleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24sIGJhYnlsb25NYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9sb2FkRGlmZnVzZVJvdWdobmVzc1Byb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIHByb3BlcnRpZXM6IElFWFRNYXRlcmlhbHNEaWZmdXNlUm91Z2huZXNzLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5icmRmLmJhc2VEaWZmdXNlTW9kZWwgPSBDb25zdGFudHMuTUFURVJJQUxfRElGRlVTRV9NT0RFTF9FX09SRU5fTkFZQVI7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmRpZmZ1c2VSb3VnaG5lc3NGYWN0b3IgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5iYXNlRGlmZnVzZVJvdWdobmVzcyA9IHByb3BlcnRpZXMuZGlmZnVzZVJvdWdobmVzc0ZhY3RvcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYmFzZURpZmZ1c2VSb3VnaG5lc3MgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuZGlmZnVzZVJvdWdobmVzc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9kaWZmdXNlUm91Z2huZXNzVGV4dHVyZWAsIHByb3BlcnRpZXMuZGlmZnVzZVJvdWdobmVzc1RleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uYW1lID0gYCR7YmFieWxvbk1hdGVyaWFsLm5hbWV9IChEaWZmdXNlIFJvdWdobmVzcylgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5iYXNlRGlmZnVzZVJvdWdobmVzc1RleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEVYVF9tYXRlcmlhbHNfZGlmZnVzZV9yb3VnaG5lc3MobG9hZGVyKSk7XHJcbiIsImltcG9ydCB7IFZlY3RvcjMsIFF1YXRlcm5pb24sIE1hdHJpeCwgVG1wVmVjdG9ycyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XHJcbmltcG9ydCB0eXBlIHsgTWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9tZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgVHJhbnNmb3JtTm9kZSB9IGZyb20gXCJjb3JlL01lc2hlcy90cmFuc2Zvcm1Ob2RlXCI7XHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyLCBBcnJheUl0ZW0gfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHR5cGUgeyBJTm9kZSB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElFWFRNZXNoR3B1SW5zdGFuY2luZyB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmltcG9ydCBcImNvcmUvTWVzaGVzL3RoaW5JbnN0YW5jZU1lc2hcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIkVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgRVhUX21lc2hfZ3B1X2luc3RhbmNpbmcgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIkVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfbWVzaF9ncHVfaW5zdGFuY2luZy9SRUFETUUubWQpXHJcbiAqIFtQbGF5Z3JvdW5kIFNhbXBsZV0oaHR0cHM6Ly9wbGF5Z3JvdW5kLmJhYnlsb25qcy5jb20vI1FGSUdMVyM5KVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgRVhUX21lc2hfZ3B1X2luc3RhbmNpbmcgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE5vZGVBc3luYyhjb250ZXh0OiBzdHJpbmcsIG5vZGU6IElOb2RlLCBhc3NpZ246IChiYWJ5bG9uVHJhbnNmb3JtTm9kZTogVHJhbnNmb3JtTm9kZSkgPT4gdm9pZCk6IE51bGxhYmxlPFByb21pc2U8VHJhbnNmb3JtTm9kZT4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUVYVE1lc2hHcHVJbnN0YW5jaW5nLCBUcmFuc2Zvcm1Ob2RlPihjb250ZXh0LCBub2RlLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLl9kaXNhYmxlSW5zdGFuY2VkTWVzaCsrO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2xvYWRlci5sb2FkTm9kZUFzeW5jKGAvbm9kZXMvJHtub2RlLmluZGV4fWAsIG5vZGUsIGFzc2lnbik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIuX2Rpc2FibGVJbnN0YW5jZWRNZXNoLS07XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5vZGUuX3ByaW1pdGl2ZUJhYnlsb25NZXNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPE51bGxhYmxlPEZsb2F0MzJBcnJheT4+PigpO1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsb2FkQXR0cmlidXRlID0gKGF0dHJpYnV0ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZShudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gQXJyYXlJdGVtLkdldChgJHtleHRlbnNpb25Db250ZXh0fS9hdHRyaWJ1dGVzLyR7YXR0cmlidXRlfWAsIHRoaXMuX2xvYWRlci5nbHRmLmFjY2Vzc29ycywgZXh0ZW5zaW9uLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSk7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRlci5fbG9hZEZsb2F0QWNjZXNzb3JBc3luYyhgL2FjY2Vzc29ycy8ke2FjY2Vzc29yLmJ1ZmZlclZpZXd9YCwgYWNjZXNzb3IpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQ291bnQgPSBhY2Nlc3Nvci5jb3VudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2VDb3VudCAhPT0gYWNjZXNzb3IuY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXh0ZW5zaW9uQ29udGV4dH0vYXR0cmlidXRlczogSW5zdGFuY2UgYnVmZmVyIGFjY2Vzc29ycyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBjb3VudC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJUUkFOU0xBVElPTlwiKTtcclxuICAgICAgICAgICAgbG9hZEF0dHJpYnV0ZShcIlJPVEFUSU9OXCIpO1xyXG4gICAgICAgICAgICBsb2FkQXR0cmlidXRlKFwiU0NBTEVcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2UudGhlbihhc3luYyAoYmFieWxvblRyYW5zZm9ybU5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmFuc2xhdGlvbkJ1ZmZlciwgcm90YXRpb25CdWZmZXIsIHNjYWxlQnVmZmVyXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShpbnN0YW5jZUNvdW50ICogMTYpO1xyXG4gICAgICAgICAgICAgICAgVG1wVmVjdG9ycy5WZWN0b3IzWzBdLmNvcHlGcm9tRmxvYXRzKDAsIDAsIDApOyAvLyB0cmFuc2xhdGlvblxyXG4gICAgICAgICAgICAgICAgVG1wVmVjdG9ycy5RdWF0ZXJuaW9uWzBdLmNvcHlGcm9tRmxvYXRzKDAsIDAsIDAsIDEpOyAvLyByb3RhdGlvblxyXG4gICAgICAgICAgICAgICAgVG1wVmVjdG9ycy5WZWN0b3IzWzFdLmNvcHlGcm9tRmxvYXRzKDEsIDEsIDEpOyAvLyBzY2FsZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbkJ1ZmZlciAmJiBWZWN0b3IzLkZyb21BcnJheVRvUmVmKHRyYW5zbGF0aW9uQnVmZmVyLCBpICogMywgVG1wVmVjdG9ycy5WZWN0b3IzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbkJ1ZmZlciAmJiBRdWF0ZXJuaW9uLkZyb21BcnJheVRvUmVmKHJvdGF0aW9uQnVmZmVyLCBpICogNCwgVG1wVmVjdG9ycy5RdWF0ZXJuaW9uWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZUJ1ZmZlciAmJiBWZWN0b3IzLkZyb21BcnJheVRvUmVmKHNjYWxlQnVmZmVyLCBpICogMywgVG1wVmVjdG9ycy5WZWN0b3IzWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0cml4LkNvbXBvc2VUb1JlZihUbXBWZWN0b3JzLlZlY3RvcjNbMV0sIFRtcFZlY3RvcnMuUXVhdGVybmlvblswXSwgVG1wVmVjdG9ycy5WZWN0b3IzWzBdLCBUbXBWZWN0b3JzLk1hdHJpeFswXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFRtcFZlY3RvcnMuTWF0cml4WzBdLmNvcHlUb0FycmF5KG1hdHJpY2VzLCBpICogMTYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYWJ5bG9uTWVzaCBvZiBub2RlLl9wcmltaXRpdmVCYWJ5bG9uTWVzaGVzISkge1xyXG4gICAgICAgICAgICAgICAgICAgIChiYWJ5bG9uTWVzaCBhcyBNZXNoKS50aGluSW5zdGFuY2VTZXRCdWZmZXIoXCJtYXRyaXhcIiwgbWF0cmljZXMsIDE2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBiYWJ5bG9uVHJhbnNmb3JtTm9kZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEFycmF5SXRlbSwgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUJ1ZmZlclZpZXcgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJRVhUTWVzaG9wdENvbXByZXNzaW9uIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyBNZXNob3B0Q29tcHJlc3Npb24gfSBmcm9tIFwiY29yZS9NZXNoZXMvQ29tcHJlc3Npb24vbWVzaG9wdENvbXByZXNzaW9uXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEVYVF9tZXNob3B0X2NvbXByZXNzaW9uIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBJQnVmZmVyVmlld01lc2hvcHQgZXh0ZW5kcyBJQnVmZmVyVmlldyB7XHJcbiAgICBfbWVzaE9wdERhdGE/OiBQcm9taXNlPEFycmF5QnVmZmVyVmlldz47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX21lc2hvcHRfY29tcHJlc3Npb24vUkVBRE1FLm1kKVxyXG4gKlxyXG4gKiBUaGlzIGV4dGVuc2lvbiB1c2VzIGEgV2ViQXNzZW1ibHkgZGVjb2RlciBtb2R1bGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vemV1eC9tZXNob3B0aW1pemVyL3RyZWUvbWFzdGVyL2pzXHJcbiAqIEBzaW5jZSA1LjAuMFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgRVhUX21lc2hvcHRfY29tcHJlc3Npb24gaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGxvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZEJ1ZmZlclZpZXdBc3luYyhjb250ZXh0OiBzdHJpbmcsIGJ1ZmZlclZpZXc6IElCdWZmZXJWaWV3KTogTnVsbGFibGU8UHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElFWFRNZXNob3B0Q29tcHJlc3Npb24sIEFycmF5QnVmZmVyVmlldz4oY29udGV4dCwgYnVmZmVyVmlldywgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXdNZXNob3B0ID0gYnVmZmVyVmlldyBhcyBJQnVmZmVyVmlld01lc2hvcHQ7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXJWaWV3TWVzaG9wdC5fbWVzaE9wdERhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBidWZmZXJWaWV3TWVzaG9wdC5fbWVzaE9wdERhdGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vYnVmZmVyYCwgdGhpcy5fbG9hZGVyLmdsdGYuYnVmZmVycywgZXh0ZW5zaW9uLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGJ1ZmZlclZpZXdNZXNob3B0Ll9tZXNoT3B0RGF0YSA9IHRoaXMuX2xvYWRlclxyXG4gICAgICAgICAgICAgICAgLmxvYWRCdWZmZXJBc3luYyhgL2J1ZmZlcnMvJHtidWZmZXIuaW5kZXh9YCwgYnVmZmVyLCBleHRlbnNpb24uYnl0ZU9mZnNldCB8fCAwLCBleHRlbnNpb24uYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBNZXNob3B0Q29tcHJlc3Npb24uRGVmYXVsdC5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoYnVmZmVyIGFzIFVpbnQ4QXJyYXksIGV4dGVuc2lvbi5jb3VudCwgZXh0ZW5zaW9uLmJ5dGVTdHJpZGUsIGV4dGVuc2lvbi5tb2RlLCBleHRlbnNpb24uZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGJ1ZmZlclZpZXdNZXNob3B0Ll9tZXNoT3B0RGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgRVhUX21lc2hvcHRfY29tcHJlc3Npb24obG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyLCBBcnJheUl0ZW0gfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElUZXh0dXJlIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUVYVFRleHR1cmVBVklGIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiRVhUX3RleHR1cmVfYXZpZlwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEVYVF90ZXh0dXJlX2F2aWYgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIkVYVF90ZXh0dXJlX2F2aWZcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW2dsVEYgUFJdKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9wdWxsLzIyMzUpXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfdGV4dHVyZV9hdmlmL1JFQURNRS5tZClcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEVYVF90ZXh0dXJlX2F2aWYgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLiAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBsb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgX2xvYWRUZXh0dXJlQXN5bmMoY29udGV4dDogc3RyaW5nLCB0ZXh0dXJlOiBJVGV4dHVyZSwgYXNzaWduOiAoYmFieWxvblRleHR1cmU6IEJhc2VUZXh0dXJlKSA9PiB2b2lkKTogTnVsbGFibGU8UHJvbWlzZTxCYXNlVGV4dHVyZT4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUVYVFRleHR1cmVBVklGLCBCYXNlVGV4dHVyZT4oY29udGV4dCwgdGV4dHVyZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZXIgPSB0ZXh0dXJlLnNhbXBsZXIgPT0gdW5kZWZpbmVkID8gR0xURkxvYWRlci5EZWZhdWx0U2FtcGxlciA6IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vc2FtcGxlcmAsIHRoaXMuX2xvYWRlci5nbHRmLnNhbXBsZXJzLCB0ZXh0dXJlLnNhbXBsZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IEFycmF5SXRlbS5HZXQoYCR7ZXh0ZW5zaW9uQ29udGV4dH0vc291cmNlYCwgdGhpcy5fbG9hZGVyLmdsdGYuaW1hZ2VzLCBleHRlbnNpb24uc291cmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2xvYWRlci5fY3JlYXRlVGV4dHVyZUFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAgIHNhbXBsZXIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgICAgIChiYWJ5bG9uVGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgIXRleHR1cmUuX3RleHR1cmVJbmZvLm5vbkNvbG9yRGF0YVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBFWFRfdGV4dHVyZV9hdmlmKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciwgQXJyYXlJdGVtIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJVGV4dHVyZSB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlXCI7XHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElFWFRUZXh0dXJlV2ViUCB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIkVYVF90ZXh0dXJlX3dlYnBcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBFWFRfdGV4dHVyZV93ZWJwIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJFWFRfdGV4dHVyZV93ZWJwXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfdGV4dHVyZV93ZWJwL1JFQURNRS5tZClcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEVYVF90ZXh0dXJlX3dlYnAgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLiAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBsb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgX2xvYWRUZXh0dXJlQXN5bmMoY29udGV4dDogc3RyaW5nLCB0ZXh0dXJlOiBJVGV4dHVyZSwgYXNzaWduOiAoYmFieWxvblRleHR1cmU6IEJhc2VUZXh0dXJlKSA9PiB2b2lkKTogTnVsbGFibGU8UHJvbWlzZTxCYXNlVGV4dHVyZT4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUVYVFRleHR1cmVXZWJQLCBCYXNlVGV4dHVyZT4oY29udGV4dCwgdGV4dHVyZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZXIgPSB0ZXh0dXJlLnNhbXBsZXIgPT0gdW5kZWZpbmVkID8gR0xURkxvYWRlci5EZWZhdWx0U2FtcGxlciA6IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vc2FtcGxlcmAsIHRoaXMuX2xvYWRlci5nbHRmLnNhbXBsZXJzLCB0ZXh0dXJlLnNhbXBsZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IEFycmF5SXRlbS5HZXQoYCR7ZXh0ZW5zaW9uQ29udGV4dH0vc291cmNlYCwgdGhpcy5fbG9hZGVyLmdsdGYuaW1hZ2VzLCBleHRlbnNpb24uc291cmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2xvYWRlci5fY3JlYXRlVGV4dHVyZUFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAgIHNhbXBsZXIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgICAgIChiYWJ5bG9uVGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgIXRleHR1cmUuX3RleHR1cmVJbmZvLm5vbkNvbG9yRGF0YVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBFWFRfdGV4dHVyZV93ZWJwKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBUcmFuc2Zvcm1Ob2RlIH0gZnJvbSBcImNvcmUvTWVzaGVzL3RyYW5zZm9ybU5vZGVcIjtcclxuaW1wb3J0IHR5cGUgeyBDYW1lcmEgfSBmcm9tIFwiY29yZS9DYW1lcmFzL2NhbWVyYVwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJUHJvcGVydHkgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB0eXBlIHsgSU5vZGUsIElDYW1lcmEsIElNYXRlcmlhbCB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHR5cGUgeyBHTFRGTG9hZGVyIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiRXh0cmFzQXNNZXRhZGF0YVwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEV4dHJhc0FzTWV0YWRhdGEgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIkV4dHJhc0FzTWV0YWRhdGFcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgSU9iamVjdFdpdGhNZXRhZGF0YSB7XHJcbiAgICBtZXRhZGF0YTogYW55O1xyXG59XHJcblxyXG4vKipcclxuICogU3RvcmUgZ2xURiBleHRyYXMgKGlmIHByZXNlbnQpIGluIEJKUyBvYmplY3RzJyBtZXRhZGF0YVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV4dHJhc0FzTWV0YWRhdGEgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICBwcml2YXRlIF9hc3NpZ25FeHRyYXMoYmFieWxvbk9iamVjdDogSU9iamVjdFdpdGhNZXRhZGF0YSwgZ2x0ZlByb3A6IElQcm9wZXJ0eSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChnbHRmUHJvcC5leHRyYXMgJiYgT2JqZWN0LmtleXMoZ2x0ZlByb3AuZXh0cmFzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gKGJhYnlsb25PYmplY3QubWV0YWRhdGEgPSBiYWJ5bG9uT2JqZWN0Lm1ldGFkYXRhIHx8IHt9KTtcclxuICAgICAgICAgICAgY29uc3QgZ2x0ZiA9IChtZXRhZGF0YS5nbHRmID0gbWV0YWRhdGEuZ2x0ZiB8fCB7fSk7XHJcbiAgICAgICAgICAgIGdsdGYuZXh0cmFzID0gZ2x0ZlByb3AuZXh0cmFzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IobG9hZGVyOiBHTFRGTG9hZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE5vZGVBc3luYyhjb250ZXh0OiBzdHJpbmcsIG5vZGU6IElOb2RlLCBhc3NpZ246IChiYWJ5bG9uVHJhbnNmb3JtTm9kZTogVHJhbnNmb3JtTm9kZSkgPT4gdm9pZCk6IE51bGxhYmxlPFByb21pc2U8VHJhbnNmb3JtTm9kZT4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLmxvYWROb2RlQXN5bmMoY29udGV4dCwgbm9kZSwgKGJhYnlsb25UcmFuc2Zvcm1Ob2RlKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fzc2lnbkV4dHJhcyhiYWJ5bG9uVHJhbnNmb3JtTm9kZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uVHJhbnNmb3JtTm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZENhbWVyYUFzeW5jKGNvbnRleHQ6IHN0cmluZywgY2FtZXJhOiBJQ2FtZXJhLCBhc3NpZ246IChiYWJ5bG9uQ2FtZXJhOiBDYW1lcmEpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPENhbWVyYT4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLmxvYWRDYW1lcmFBc3luYyhjb250ZXh0LCBjYW1lcmEsIChiYWJ5bG9uQ2FtZXJhKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fzc2lnbkV4dHJhcyhiYWJ5bG9uQ2FtZXJhLCBjYW1lcmEpO1xyXG4gICAgICAgICAgICBhc3NpZ24oYmFieWxvbkNhbWVyYSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZU1hdGVyaWFsKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbkRyYXdNb2RlOiBudW1iZXIpOiBOdWxsYWJsZTxNYXRlcmlhbD4ge1xyXG4gICAgICAgIGNvbnN0IGJhYnlsb25NYXRlcmlhbCA9IHRoaXMuX2xvYWRlci5jcmVhdGVNYXRlcmlhbChjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbkRyYXdNb2RlKTtcclxuICAgICAgICB0aGlzLl9hc3NpZ25FeHRyYXMoYmFieWxvbk1hdGVyaWFsLCBtYXRlcmlhbCk7XHJcbiAgICAgICAgcmV0dXJuIGJhYnlsb25NYXRlcmlhbDtcclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCBmYWxzZSwgKGxvYWRlcikgPT4gbmV3IEV4dHJhc0FzTWV0YWRhdGEobG9hZGVyKSk7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xyXG5cclxuaW1wb3J0IHsgQW5pbWF0aW9uIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRpb25cIjtcclxuaW1wb3J0IHR5cGUgeyBJQ2FtZXJhLCBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQsIElNYXRlcmlhbCB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElBbmltYXRhYmxlIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRhYmxlLmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyBBbmltYXRpb25Qcm9wZXJ0eUluZm8gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckFuaW1hdGlvblwiO1xyXG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XHJcbmltcG9ydCB7IFNldEludGVycG9sYXRpb25Gb3JLZXkgfSBmcm9tIFwiLi9vYmplY3RNb2RlbE1hcHBpbmdcIjtcclxuXHJcbmZ1bmN0aW9uIGdldENvbG9yMyhfdGFyZ2V0OiBhbnksIHNvdXJjZTogRmxvYXQzMkFycmF5LCBvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcik6IENvbG9yMyB7XHJcbiAgICByZXR1cm4gQ29sb3IzLkZyb21BcnJheShzb3VyY2UsIG9mZnNldCkuc2NhbGUoc2NhbGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbHBoYShfdGFyZ2V0OiBhbnksIHNvdXJjZTogRmxvYXQzMkFycmF5LCBvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gc291cmNlW29mZnNldCArIDNdICogc2NhbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZsb2F0KF90YXJnZXQ6IGFueSwgc291cmNlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBzb3VyY2Vbb2Zmc2V0XSAqIHNjYWxlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNaW51c0Zsb2F0KF90YXJnZXQ6IGFueSwgc291cmNlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAtc291cmNlW29mZnNldF0gKiBzY2FsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TmV4dEZsb2F0KF90YXJnZXQ6IGFueSwgc291cmNlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBzb3VyY2Vbb2Zmc2V0ICsgMV0gKiBzY2FsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RmxvYXRCeTIoX3RhcmdldDogYW55LCBzb3VyY2U6IEZsb2F0MzJBcnJheSwgb2Zmc2V0OiBudW1iZXIsIHNjYWxlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHNvdXJjZVtvZmZzZXRdICogc2NhbGUgKiAyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZSh0ZXh0dXJlTmFtZTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjYWxlOiBbXHJcbiAgICAgICAgICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgYCR7dGV4dHVyZU5hbWV9LnVTY2FsZWAsIGdldEZsb2F0LCAoKSA9PiAyKSxcclxuICAgICAgICAgICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBgJHt0ZXh0dXJlTmFtZX0udlNjYWxlYCwgZ2V0TmV4dEZsb2F0LCAoKSA9PiAyKSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIG9mZnNldDogW1xyXG4gICAgICAgICAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIGAke3RleHR1cmVOYW1lfS51T2Zmc2V0YCwgZ2V0RmxvYXQsICgpID0+IDIpLFxyXG4gICAgICAgICAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIGAke3RleHR1cmVOYW1lfS52T2Zmc2V0YCwgZ2V0TmV4dEZsb2F0LCAoKSA9PiAyKSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHJvdGF0aW9uOiBbbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBgJHt0ZXh0dXJlTmFtZX0ud0FuZ2AsIGdldE1pbnVzRmxvYXQsICgpID0+IDEpXSxcclxuICAgIH07XHJcbn1cclxuXHJcbmNsYXNzIENhbWVyYUFuaW1hdGlvblByb3BlcnR5SW5mbyBleHRlbmRzIEFuaW1hdGlvblByb3BlcnR5SW5mbyB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgYnVpbGRBbmltYXRpb25zKHRhcmdldDogSUNhbWVyYSwgbmFtZTogc3RyaW5nLCBmcHM6IG51bWJlciwga2V5czogYW55W10pIHtcclxuICAgICAgICByZXR1cm4gW3sgYmFieWxvbkFuaW1hdGFibGU6IHRhcmdldC5fYmFieWxvbkNhbWVyYSEsIGJhYnlsb25BbmltYXRpb246IHRoaXMuX2J1aWxkQW5pbWF0aW9uKG5hbWUsIGZwcywga2V5cykgfV07XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvIGV4dGVuZHMgQW5pbWF0aW9uUHJvcGVydHlJbmZvIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBidWlsZEFuaW1hdGlvbnModGFyZ2V0OiBJTWF0ZXJpYWwsIG5hbWU6IHN0cmluZywgZnBzOiBudW1iZXIsIGtleXM6IGFueVtdKSB7XHJcbiAgICAgICAgY29uc3QgYmFieWxvbkFuaW1hdGlvbnM6IHsgYmFieWxvbkFuaW1hdGFibGU6IElBbmltYXRhYmxlOyBiYWJ5bG9uQW5pbWF0aW9uOiBBbmltYXRpb24gfVtdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWxsTW9kZSBpbiB0YXJnZXQuX2RhdGEhKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbkFuaW1hdGFibGU6IHRhcmdldC5fZGF0YVtmaWxsTW9kZV0uYmFieWxvbk1hdGVyaWFsLFxyXG4gICAgICAgICAgICAgICAgYmFieWxvbkFuaW1hdGlvbjogdGhpcy5fYnVpbGRBbmltYXRpb24obmFtZSwgZnBzLCBrZXlzKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYWJ5bG9uQW5pbWF0aW9ucztcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTGlnaHRBbmltYXRpb25Qcm9wZXJ0eUluZm8gZXh0ZW5kcyBBbmltYXRpb25Qcm9wZXJ0eUluZm8ge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGJ1aWxkQW5pbWF0aW9ucyh0YXJnZXQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCwgbmFtZTogc3RyaW5nLCBmcHM6IG51bWJlciwga2V5czogYW55W10pIHtcclxuICAgICAgICByZXR1cm4gW3sgYmFieWxvbkFuaW1hdGFibGU6IHRhcmdldC5fYmFieWxvbkxpZ2h0ISwgYmFieWxvbkFuaW1hdGlvbjogdGhpcy5fYnVpbGRBbmltYXRpb24obmFtZSwgZnBzLCBrZXlzKSB9XTtcclxuICAgIH1cclxufVxyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9jYW1lcmFzL3t9L29ydGhvZ3JhcGhpYy94bWFnXCIsIFtcclxuICAgIG5ldyBDYW1lcmFBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwib3J0aG9MZWZ0XCIsIGdldE1pbnVzRmxvYXQsICgpID0+IDEpLFxyXG4gICAgbmV3IENhbWVyYUFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJvcnRob1JpZ2h0XCIsIGdldE5leHRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9jYW1lcmFzL3t9L29ydGhvZ3JhcGhpYy95bWFnXCIsIFtcclxuICAgIG5ldyBDYW1lcmFBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwib3J0aG9Cb3R0b21cIiwgZ2V0TWludXNGbG9hdCwgKCkgPT4gMSksXHJcbiAgICBuZXcgQ2FtZXJhQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcIm9ydGhvVG9wXCIsIGdldE5leHRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9jYW1lcmFzL3t9L29ydGhvZ3JhcGhpYy96ZmFyXCIsIFtuZXcgQ2FtZXJhQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcIm1heFpcIiwgZ2V0RmxvYXQsICgpID0+IDEpXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvY2FtZXJhcy97fS9vcnRob2dyYXBoaWMvem5lYXJcIiwgW25ldyBDYW1lcmFBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwibWluWlwiLCBnZXRGbG9hdCwgKCkgPT4gMSldKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvY2FtZXJhcy97fS9wZXJzcGVjdGl2ZS95Zm92XCIsIFtuZXcgQ2FtZXJhQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcImZvdlwiLCBnZXRGbG9hdCwgKCkgPT4gMSldKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9jYW1lcmFzL3t9L3BlcnNwZWN0aXZlL3pmYXJcIiwgW25ldyBDYW1lcmFBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwibWF4WlwiLCBnZXRGbG9hdCwgKCkgPT4gMSldKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9jYW1lcmFzL3t9L3BlcnNwZWN0aXZlL3puZWFyXCIsIFtuZXcgQ2FtZXJhQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcIm1pblpcIiwgZ2V0RmxvYXQsICgpID0+IDEpXSk7XHJcblxyXG4vLyBhZGQgaW50ZXJwb2xhdGlvbiB0byB0aGUgbWF0ZXJpYWxzIG1hcHBpbmdcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vcGJyTWV0YWxsaWNSb3VnaG5lc3MvYmFzZUNvbG9yRmFjdG9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9DT0xPUjMsIFwiYWxiZWRvQ29sb3JcIiwgZ2V0Q29sb3IzLCAoKSA9PiA0KSxcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJhbHBoYVwiLCBnZXRBbHBoYSwgKCkgPT4gNCksXHJcbl0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9wYnJNZXRhbGxpY1JvdWdobmVzcy9tZXRhbGxpY0ZhY3RvclwiLCBbbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcIm1ldGFsbGljXCIsIGdldEZsb2F0LCAoKSA9PiAxKV0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9wYnJNZXRhbGxpY1JvdWdobmVzcy9tZXRhbGxpY0ZhY3RvclwiLCBbbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcInJvdWdobmVzc1wiLCBnZXRGbG9hdCwgKCkgPT4gMSldKTtcclxuY29uc3QgYmFzZUNvbG9yVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcImFsYmVkb1RleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L3Bick1ldGFsbGljUm91Z2huZXNzL2Jhc2VDb2xvclRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIiwgYmFzZUNvbG9yVGV4dHVyZUludGVycG9sYXRpb24uc2NhbGUpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9wYnJNZXRhbGxpY1JvdWdobmVzcy9iYXNlQ29sb3JUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL29mZnNldFwiLCBiYXNlQ29sb3JUZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9wYnJNZXRhbGxpY1JvdWdobmVzcy9iYXNlQ29sb3JUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsIGJhc2VDb2xvclRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uKTtcclxuXHJcbmNvbnN0IG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcIm1ldGFsbGljVGV4dHVyZVwiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi8vbWF0ZXJpYWxzL3t9L3Bick1ldGFsbGljUm91Z2huZXNzL21ldGFsbGljUm91Z2huZXNzVGV4dHVyZS9zY2FsZVwiLCBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uLnNjYWxlKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi8vbWF0ZXJpYWxzL3t9L3Bick1ldGFsbGljUm91Z2huZXNzL21ldGFsbGljUm91Z2huZXNzVGV4dHVyZS9vZmZzZXRcIiwgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiLy9tYXRlcmlhbHMve30vcGJyTWV0YWxsaWNSb3VnaG5lc3MvbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlL3JvdGF0aW9uXCIsIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb24pO1xyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZW1pc3NpdmVGYWN0b3JcIiwgW25ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9DT0xPUjMsIFwiZW1pc3NpdmVDb2xvclwiLCBnZXRDb2xvcjMsICgpID0+IDMpXSk7XHJcbmNvbnN0IG5vcm1hbFRleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJidW1wVGV4dHVyZVwiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vbm9ybWFsVGV4dHVyZS9zY2FsZVwiLCBbbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcImJ1bXBUZXh0dXJlLmxldmVsXCIsIGdldEZsb2F0LCAoKSA9PiAxKV0pO1xyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vbm9ybWFsVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9zY2FsZVwiLCBub3JtYWxUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L25vcm1hbFRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vb2Zmc2V0XCIsIG5vcm1hbFRleHR1cmVJbnRlcnBvbGF0aW9uLm9mZnNldCk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L25vcm1hbFRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIiwgbm9ybWFsVGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb24pO1xyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vb2NjbHVzaW9uVGV4dHVyZS9zdHJlbmd0aFwiLCBbbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcImFtYmllbnRUZXh0dXJlU3RyZW5ndGhcIiwgZ2V0RmxvYXQsICgpID0+IDEpXSk7XHJcblxyXG5jb25zdCBvY2NsdXNpb25UZXh0dXJlSW50ZXJwb2xhdGlvbiA9IGdldFRleHR1cmVUcmFuc2Zvcm1UcmVlKFwiYW1iaWVudFRleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L29jY2x1c2lvblRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIiwgb2NjbHVzaW9uVGV4dHVyZUludGVycG9sYXRpb24uc2NhbGUpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9vY2NsdXNpb25UZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL29mZnNldFwiLCBvY2NsdXNpb25UZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9vY2NsdXNpb25UZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsIG9jY2x1c2lvblRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uKTtcclxuY29uc3QgZW1pc3NpdmVUZXh0dXJlSW50ZXJwb2xhdGlvbiA9IGdldFRleHR1cmVUcmFuc2Zvcm1UcmVlKFwiZW1pc3NpdmVUZXh0dXJlXCIpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9lbWlzc2l2ZVRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIiwgZW1pc3NpdmVUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2VtaXNzaXZlVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgZW1pc3NpdmVUZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9lbWlzc2l2ZVRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIiwgZW1pc3NpdmVUZXh0dXJlSW50ZXJwb2xhdGlvbi5yb3RhdGlvbik7XHJcblxyXG4vLyBtYXRlcmlhbHMgZXh0ZW5zaW9uc1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfYW5pc290cm9weS9hbmlzb3Ryb3B5U3RyZW5ndGhcIiwgW1xyXG4gICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcImFuaXNvdHJvcHkuaW50ZW5zaXR5XCIsIGdldEZsb2F0LCAoKSA9PiAxKSxcclxuXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5L2FuaXNvdHJvcHlSb3RhdGlvblwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwiYW5pc290cm9weS5hbmdsZVwiLCBnZXRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5jb25zdCBhbmlzb3Ryb3B5VGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcImFuaXNvdHJvcHkudGV4dHVyZVwiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHkvYW5pc290cm9weVRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIiwgYW5pc290cm9weVRleHR1cmVJbnRlcnBvbGF0aW9uLnNjYWxlKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHkvYW5pc290cm9weVRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vb2Zmc2V0XCIsIGFuaXNvdHJvcHlUZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfYW5pc290cm9weS9hbmlzb3Ryb3B5VGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9yb3RhdGlvblwiLCBhbmlzb3Ryb3B5VGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb24pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0L2NsZWFyY29hdEZhY3RvclwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwiY2xlYXJDb2F0LmludGVuc2l0eVwiLCBnZXRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0L2NsZWFyY29hdFJvdWdobmVzc0ZhY3RvclwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwiY2xlYXJDb2F0LnJvdWdobmVzc1wiLCBnZXRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5jb25zdCBjbGVhcmNvYXRUZXh0dXJlSW50ZXJwb2xhdGlvbiA9IGdldFRleHR1cmVUcmFuc2Zvcm1UcmVlKFwiY2xlYXJDb2F0LnRleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19jbGVhcmNvYXQvY2xlYXJjb2F0VGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9zY2FsZVwiLCBjbGVhcmNvYXRUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19jbGVhcmNvYXQvY2xlYXJjb2F0VGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgY2xlYXJjb2F0VGV4dHVyZUludGVycG9sYXRpb24ub2Zmc2V0KTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdC9jbGVhcmNvYXRUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsIGNsZWFyY29hdFRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uKTtcclxuY29uc3QgY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcImNsZWFyQ29hdC5idW1wVGV4dHVyZVwiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdC9jbGVhcmNvYXROb3JtYWxUZXh0dXJlL3NjYWxlXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJjbGVhckNvYXQuYnVtcFRleHR1cmUubGV2ZWxcIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdC9jbGVhcmNvYXROb3JtYWxUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3NjYWxlXCIsIGNsZWFyY29hdE5vcm1hbFRleHR1cmVJbnRlcnBvbGF0aW9uLnNjYWxlKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcclxuICAgIFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0L2NsZWFyY29hdE5vcm1hbFRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vb2Zmc2V0XCIsXHJcbiAgICBjbGVhcmNvYXROb3JtYWxUZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXRcclxuKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcclxuICAgIFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0L2NsZWFyY29hdE5vcm1hbFRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIixcclxuICAgIGNsZWFyY29hdE5vcm1hbFRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uXHJcbik7XHJcbmNvbnN0IGNsZWFyY29hdFJvdWdobmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJjbGVhckNvYXQudGV4dHVyZVJvdWdobmVzc1wiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcclxuICAgIFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0L2NsZWFyY29hdFJvdWdobmVzc1RleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIixcclxuICAgIGNsZWFyY29hdFJvdWdobmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uLnNjYWxlXHJcbik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXHJcbiAgICBcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdC9jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL29mZnNldFwiLFxyXG4gICAgY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZUludGVycG9sYXRpb24ub2Zmc2V0XHJcbik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXHJcbiAgICBcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdC9jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsXHJcbiAgICBjbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlSW50ZXJwb2xhdGlvbi5yb3RhdGlvblxyXG4pO1xyXG5cclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb24vZGlzcGVyc2lvbkZhY3RvclwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwic3ViU3VyZmFjZS5kaXNwZXJzaW9uXCIsIGdldEZsb2F0LCAoKSA9PiAxKSxcclxuXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aC9lbWlzc2l2ZVN0cmVuZ3RoXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJlbWlzc2l2ZUludGVuc2l0eVwiLCBnZXRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfaW9yL2lvclwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwiaW5kZXhPZlJlZnJhY3Rpb25cIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlL2lyaWRlc2NlbmNlRmFjdG9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJpcmlkZXNjZW5jZS5pbnRlbnNpdHlcIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlL2lyaWRlc2NlbmNlSW9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJpcmlkZXNjZW5jZS5pbmRleE9mUmVmcmFjdGlvblwiLCBnZXRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2UvaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJpcmlkZXNjZW5jZS5taW5pbXVtVGhpY2tuZXNzXCIsIGdldEZsb2F0LCAoKSA9PiAxKSxcclxuXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZS9pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW1cIiwgW1xyXG4gICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcImlyaWRlc2NlbmNlLm1heGltdW1UaGlja25lc3NcIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuXHJcbmNvbnN0IGlyaWRlc2NlbmNlVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcImlyaWRlc2NlbmNlLnRleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZS9pcmlkZXNjZW5jZVRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIiwgaXJpZGVzY2VuY2VUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZS9pcmlkZXNjZW5jZVRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vb2Zmc2V0XCIsIGlyaWRlc2NlbmNlVGV4dHVyZUludGVycG9sYXRpb24ub2Zmc2V0KTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlL2lyaWRlc2NlbmNlVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9yb3RhdGlvblwiLCBpcmlkZXNjZW5jZVRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uKTtcclxuXHJcbmNvbnN0IGlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcImlyaWRlc2NlbmNlLnRoaWNrbmVzc1RleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXHJcbiAgICBcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlL2lyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9zY2FsZVwiLFxyXG4gICAgaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZVxyXG4pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFxyXG4gICAgXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZS9pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vb2Zmc2V0XCIsXHJcbiAgICBpcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uLm9mZnNldFxyXG4pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFxyXG4gICAgXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZS9pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIixcclxuICAgIGlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb25cclxuKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19zaGVlbi9zaGVlbkNvbG9yRmFjdG9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9DT0xPUjMsIFwic2hlZW4uY29sb3JcIiwgZ2V0Q29sb3IzLCAoKSA9PiAzKSxcclxuXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19zaGVlbi9zaGVlblJvdWdobmVzc0ZhY3RvclwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwic2hlZW4ucm91Z2huZXNzXCIsIGdldEZsb2F0LCAoKSA9PiAxKSxcclxuXSk7XHJcblxyXG5jb25zdCBzaGVlblRleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJzaGVlbi50ZXh0dXJlXCIpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc2hlZW4vc2hlZW5Db2xvclRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIiwgc2hlZW5UZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19zaGVlbi9zaGVlbkNvbG9yVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgc2hlZW5UZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc2hlZW4vc2hlZW5Db2xvclRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIiwgc2hlZW5UZXh0dXJlSW50ZXJwb2xhdGlvbi5yb3RhdGlvbik7XHJcblxyXG5jb25zdCBzaGVlblJvdWdobmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJzaGVlbi50ZXh0dXJlUm91Z2huZXNzXCIpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc2hlZW4vc2hlZW5Sb3VnaG5lc3NUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3NjYWxlXCIsIHNoZWVuUm91Z2huZXNzVGV4dHVyZUludGVycG9sYXRpb24uc2NhbGUpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc2hlZW4vc2hlZW5Sb3VnaG5lc3NUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL29mZnNldFwiLCBzaGVlblJvdWdobmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uLm9mZnNldCk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19zaGVlbi9zaGVlblJvdWdobmVzc1RleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIiwgc2hlZW5Sb3VnaG5lc3NUZXh0dXJlSW50ZXJwb2xhdGlvbi5yb3RhdGlvbik7XHJcblxyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc3BlY3VsYXIvc3BlY3VsYXJGYWN0b3JcIiwgW1xyXG4gICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcIm1ldGFsbGljRjBGYWN0b3JcIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyL3NwZWN1bGFyQ29sb3JGYWN0b3JcIiwgW1xyXG4gICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0NPTE9SMywgXCJtZXRhbGxpY1JlZmxlY3RhbmNlQ29sb3JcIiwgZ2V0Q29sb3IzLCAoKSA9PiAzKSxcclxuXSk7XHJcblxyXG5jb25zdCBzcGVjdWxhclRleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJtZXRhbGxpY1JlZmxlY3RhbmNlVGV4dHVyZVwiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyL3NwZWN1bGFyVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9zY2FsZVwiLCBzcGVjdWxhclRleHR1cmVJbnRlcnBvbGF0aW9uLnNjYWxlKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyL3NwZWN1bGFyVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgc3BlY3VsYXJUZXh0dXJlSW50ZXJwb2xhdGlvbi5vZmZzZXQpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfc3BlY3VsYXIvc3BlY3VsYXJUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsIHNwZWN1bGFyVGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb24pO1xyXG5jb25zdCBzcGVjdWxhckNvbG9yVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcInJlZmxlY3RhbmNlVGV4dHVyZVwiKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyL3NwZWN1bGFyQ29sb3JUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3NjYWxlXCIsIHNwZWN1bGFyQ29sb3JUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19zcGVjdWxhci9zcGVjdWxhckNvbG9yVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgc3BlY3VsYXJDb2xvclRleHR1cmVJbnRlcnBvbGF0aW9uLm9mZnNldCk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXHJcbiAgICBcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyL3NwZWN1bGFyQ29sb3JUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsXHJcbiAgICBzcGVjdWxhckNvbG9yVGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb25cclxuKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc190cmFuc21pc3Npb24vdHJhbnNtaXNzaW9uRmFjdG9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJzdWJTdXJmYWNlLnJlZnJhY3Rpb25JbnRlbnNpdHlcIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuY29uc3QgdHJhbnNtaXNzaW9uVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcInN1YlN1cmZhY2UucmVmcmFjdGlvbkludGVuc2l0eVRleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc190cmFuc21pc3Npb24vdHJhbnNtaXNzaW9uVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9zY2FsZVwiLCB0cmFuc21pc3Npb25UZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc190cmFuc21pc3Npb24vdHJhbnNtaXNzaW9uVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgdHJhbnNtaXNzaW9uVGV4dHVyZUludGVycG9sYXRpb24ub2Zmc2V0KTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcclxuICAgIFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uL3RyYW5zbWlzc2lvblRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIixcclxuICAgIHRyYW5zbWlzc2lvblRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uXHJcbik7XHJcblxyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL21hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfdm9sdW1lL2F0dGVudWF0aW9uQ29sb3JcIiwgW1xyXG4gICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0NPTE9SMywgXCJzdWJTdXJmYWNlLnRpbnRDb2xvclwiLCBnZXRDb2xvcjMsICgpID0+IDMpLFxyXG5dKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc192b2x1bWUvYXR0ZW51YXRpb25EaXN0YW5jZVwiLCBbXHJcbiAgICBuZXcgTWF0ZXJpYWxBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwic3ViU3VyZmFjZS50aW50Q29sb3JBdERpc3RhbmNlXCIsIGdldEZsb2F0LCAoKSA9PiAxKSxcclxuXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc192b2x1bWUvdGhpY2tuZXNzRmFjdG9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJzdWJTdXJmYWNlLm1heGltdW1UaGlja25lc3NcIiwgZ2V0RmxvYXQsICgpID0+IDEpLFxyXG5dKTtcclxuXHJcbmNvbnN0IHRoaWNrbmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJzdWJTdXJmYWNlLnRoaWNrbmVzc1RleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc192b2x1bWUvdGhpY2tuZXNzVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9zY2FsZVwiLCB0aGlja25lc3NUZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc192b2x1bWUvdGhpY2tuZXNzVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIiwgdGhpY2tuZXNzVGV4dHVyZUludGVycG9sYXRpb24ub2Zmc2V0KTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9tYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX3ZvbHVtZS90aGlja25lc3NUZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsIHRoaWNrbmVzc1RleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19kaWZmdXNlX3RyYW5zbWlzc2lvbi9kaWZmdXNlVHJhbnNtaXNzaW9uRmFjdG9yXCIsIFtcclxuICAgIG5ldyBNYXRlcmlhbEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJzdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUludGVuc2l0eVwiLCBnZXRGbG9hdCwgKCkgPT4gMSksXHJcbl0pO1xyXG5cclxuY29uc3QgZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmVJbnRlcnBvbGF0aW9uID0gZ2V0VGV4dHVyZVRyYW5zZm9ybVRyZWUoXCJzdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUludGVuc2l0eVRleHR1cmVcIik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXHJcbiAgICBcIm1hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfZGlmZnVzZV90cmFuc21pc3Npb24vZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIixcclxuICAgIGRpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlSW50ZXJwb2xhdGlvbi5zY2FsZVxyXG4pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFxyXG4gICAgXCJtYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uL2RpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL29mZnNldFwiLFxyXG4gICAgZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmVJbnRlcnBvbGF0aW9uLm9mZnNldFxyXG4pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFxyXG4gICAgXCJtYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uL2RpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtL3JvdGF0aW9uXCIsXHJcbiAgICBkaWZmdXNlVHJhbnNtaXNzaW9uVGV4dHVyZUludGVycG9sYXRpb24ucm90YXRpb25cclxuKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbWF0ZXJpYWxzL3t9L2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19kaWZmdXNlX3RyYW5zbWlzc2lvbi9kaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JGYWN0b3JcIiwgW1xyXG4gICAgbmV3IE1hdGVyaWFsQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0NPTE9SMywgXCJzdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUNvbG9yXCIsIGdldENvbG9yMywgKCkgPT4gMyksXHJcbl0pO1xyXG5cclxuY29uc3QgZGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yVGV4dHVyZUludGVycG9sYXRpb24gPSBnZXRUZXh0dXJlVHJhbnNmb3JtVHJlZShcInN1YlN1cmZhY2UudHJhbnNsdWNlbmN5Q29sb3JUZXh0dXJlXCIpO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFxyXG4gICAgXCJtYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uL2RpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vc2NhbGVcIixcclxuICAgIGRpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmVJbnRlcnBvbGF0aW9uLnNjYWxlXHJcbik7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXHJcbiAgICBcIm1hdGVyaWFscy97fS9leHRlbnNpb25zL0tIUl9tYXRlcmlhbHNfZGlmZnVzZV90cmFuc21pc3Npb24vZGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yVGV4dHVyZS9leHRlbnNpb25zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9vZmZzZXRcIixcclxuICAgIGRpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmVJbnRlcnBvbGF0aW9uLm9mZnNldFxyXG4pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFxyXG4gICAgXCJtYXRlcmlhbHMve30vZXh0ZW5zaW9ucy9LSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uL2RpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmUvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV90cmFuc2Zvcm0vcm90YXRpb25cIixcclxuICAgIGRpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmVJbnRlcnBvbGF0aW9uLnJvdGF0aW9uXHJcbik7XHJcblxyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL2V4dGVuc2lvbnMvS0hSX2xpZ2h0c19wdW5jdHVhbC9saWdodHMve30vY29sb3JcIiwgW25ldyBMaWdodEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9DT0xPUjMsIFwiZGlmZnVzZVwiLCBnZXRDb2xvcjMsICgpID0+IDMpXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvZXh0ZW5zaW9ucy9LSFJfbGlnaHRzX3B1bmN0dWFsL2xpZ2h0cy97fS9pbnRlbnNpdHlcIiwgW25ldyBMaWdodEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJpbnRlbnNpdHlcIiwgZ2V0RmxvYXQsICgpID0+IDEpXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvZXh0ZW5zaW9ucy9LSFJfbGlnaHRzX3B1bmN0dWFsL2xpZ2h0cy97fS9yYW5nZVwiLCBbbmV3IExpZ2h0QW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FULCBcInJhbmdlXCIsIGdldEZsb2F0LCAoKSA9PiAxKV0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL2V4dGVuc2lvbnMvS0hSX2xpZ2h0c19wdW5jdHVhbC9saWdodHMve30vc3BvdC9pbm5lckNvbmVBbmdsZVwiLCBbXHJcbiAgICBuZXcgTGlnaHRBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwiaW5uZXJBbmdsZVwiLCBnZXRGbG9hdEJ5MiwgKCkgPT4gMSksXHJcbl0pO1xyXG5TZXRJbnRlcnBvbGF0aW9uRm9yS2V5KFwiL2V4dGVuc2lvbnMvS0hSX2xpZ2h0c19wdW5jdHVhbC9saWdodHMve30vc3BvdC9vdXRlckNvbmVBbmdsZVwiLCBbXHJcbiAgICBuZXcgTGlnaHRBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQsIFwiYW5nbGVcIiwgZ2V0RmxvYXRCeTIsICgpID0+IDEpLFxyXG5dKTtcclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbm9kZXMve30vZXh0ZW5zaW9ucy9FWFRfbGlnaHRzX2llcy9jb2xvclwiLCBbbmV3IExpZ2h0QW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0NPTE9SMywgXCJkaWZmdXNlXCIsIGdldENvbG9yMywgKCkgPT4gMyldKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9ub2Rlcy97fS9leHRlbnNpb25zL0VYVF9saWdodHNfaWVzL211bHRpcGxpZXJcIiwgW25ldyBMaWdodEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJpbnRlbnNpdHlcIiwgZ2V0RmxvYXQsICgpID0+IDEpXSk7XHJcbiIsImltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgdHlwZSB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBBbmltYXRpb24gfSBmcm9tIFwiY29yZS9BbmltYXRpb25zL2FuaW1hdGlvblwiO1xyXG5pbXBvcnQgdHlwZSB7IElBbmltYXRhYmxlIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRhYmxlLmludGVyZmFjZVwiO1xyXG5pbXBvcnQgdHlwZSB7IElBbmltYXRpb24sIElBbmltYXRpb25DaGFubmVsIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUkFuaW1hdGlvblBvaW50ZXIgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IEFuaW1hdGlvbkNoYW5uZWxUYXJnZXRQYXRoIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiY29yZS9NaXNjL2xvZ2dlclwiO1xyXG5pbXBvcnQgdHlwZSB7IEdMVEZQYXRoVG9PYmplY3RDb252ZXJ0ZXIgfSBmcm9tIFwiLi9nbHRmUGF0aFRvT2JqZWN0Q29udmVydGVyXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcbmltcG9ydCB7IEdldFBhdGhUb09iamVjdENvbnZlcnRlciB9IGZyb20gXCIuL29iamVjdE1vZGVsTWFwcGluZ1wiO1xyXG5pbXBvcnQgXCIuL0tIUl9hbmltYXRpb25fcG9pbnRlci5kYXRhXCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfYW5pbWF0aW9uX3BvaW50ZXJcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfYW5pbWF0aW9uX3BvaW50ZXIgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl9hbmltYXRpb25fcG9pbnRlclwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbiBQUl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3B1bGwvMjE0NylcclxuICogISEhIEV4cGVyaW1lbnRhbCBFeHRlbnNpb24gU3ViamVjdCB0byBDaGFuZ2VzICEhIVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX2FuaW1hdGlvbl9wb2ludGVyIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuICAgIHByaXZhdGUgX3BhdGhUb09iamVjdENvbnZlcnRlcj86IEdMVEZQYXRoVG9PYmplY3RDb252ZXJ0ZXI8YW55LCBhbnksIGFueT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyOiBHTFRGTG9hZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuX3BhdGhUb09iamVjdENvbnZlcnRlciA9IEdldFBhdGhUb09iamVjdENvbnZlcnRlcih0aGlzLl9sb2FkZXIuZ2x0Zik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBlbmFibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BhdGhUb09iamVjdENvbnZlcnRlcjsgLy8gR0NcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ2xURiBhbmltYXRpb24gY2hhbm5lbC5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb25Db250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBhbmltYXRpb24gd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgZ2xURiBhbmltYXRpb24gcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBnbFRGIGFuaW1hdGlvbiBjaGFubmVsIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gb25Mb2FkIENhbGxlZCBmb3IgZWFjaCBhbmltYXRpb24gbG9hZGVkXHJcbiAgICAgKiBAcmV0dXJucyBBIHZvaWQgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGUgb3IgbnVsbCBpZiBub3QgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBfbG9hZEFuaW1hdGlvbkNoYW5uZWxBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uQ29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbjogSUFuaW1hdGlvbixcclxuICAgICAgICBjaGFubmVsOiBJQW5pbWF0aW9uQ2hhbm5lbCxcclxuICAgICAgICBvbkxvYWQ6IChiYWJ5bG9uQW5pbWF0YWJsZTogSUFuaW1hdGFibGUsIGJhYnlsb25BbmltYXRpb246IEFuaW1hdGlvbikgPT4gdm9pZFxyXG4gICAgKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGNoYW5uZWwudGFyZ2V0LmV4dGVuc2lvbnM/LktIUl9hbmltYXRpb25fcG9pbnRlciBhcyBJS0hSQW5pbWF0aW9uUG9pbnRlcjtcclxuICAgICAgICBpZiAoIWV4dGVuc2lvbiB8fCAhdGhpcy5fcGF0aFRvT2JqZWN0Q29udmVydGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYW5uZWwudGFyZ2V0LnBhdGggIT09IEFuaW1hdGlvbkNoYW5uZWxUYXJnZXRQYXRoLlBPSU5URVIpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLldhcm4oYCR7Y29udGV4dH0vdGFyZ2V0L3BhdGg6IFZhbHVlICgke2NoYW5uZWwudGFyZ2V0LnBhdGh9KSBtdXN0IGJlICgke0FuaW1hdGlvbkNoYW5uZWxUYXJnZXRQYXRoLlBPSU5URVJ9KSB3aGVuIHVzaW5nIHRoZSAke3RoaXMubmFtZX0gZXh0ZW5zaW9uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2hhbm5lbC50YXJnZXQubm9kZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLldhcm4oYCR7Y29udGV4dH0vdGFyZ2V0L25vZGU6IFZhbHVlICgke2NoYW5uZWwudGFyZ2V0Lm5vZGV9KSBtdXN0IG5vdCBiZSBwcmVzZW50IHdoZW4gdXNpbmcgdGhlICR7dGhpcy5uYW1lfSBleHRlbnNpb25gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkNvbnRleHQgPSBgJHtjb250ZXh0fS9leHRlbnNpb25zLyR7dGhpcy5uYW1lfWA7XHJcblxyXG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSBleHRlbnNpb24ucG9pbnRlcjtcclxuICAgICAgICBpZiAoIXBvaW50ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V4dGVuc2lvbkNvbnRleHR9OiBQb2ludGVyIGlzIG1pc3NpbmdgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3BhdGhUb09iamVjdENvbnZlcnRlci5jb252ZXJ0KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICBpZiAoIW9iai5pbmZvLmludGVycG9sYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtleHRlbnNpb25Db250ZXh0fS9wb2ludGVyOiBJbnRlcnBvbGF0aW9uIGlzIG1pc3NpbmdgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLl9sb2FkQW5pbWF0aW9uQ2hhbm5lbEZyb21UYXJnZXRJbmZvQXN5bmMoXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ29udGV4dCxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmoub2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZm86IG9iai5pbmZvLmludGVycG9sYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25Mb2FkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBMb2dnZXIuV2FybihgJHtleHRlbnNpb25Db250ZXh0fS9wb2ludGVyOiBJbnZhbGlkIHBvaW50ZXIgKCR7cG9pbnRlcn0pIHNraXBwZWRgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfYW5pbWF0aW9uX3BvaW50ZXIobG9hZGVyKSk7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIGdpdGh1Yi9uby10aGVuICovXHJcbmltcG9ydCB7IERyYWNvRGVjb2RlciB9IGZyb20gXCJjb3JlL01lc2hlcy9Db21wcmVzc2lvbi9kcmFjb0RlY29kZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFZlcnRleEJ1ZmZlciB9IGZyb20gXCJjb3JlL0J1ZmZlcnMvYnVmZmVyXCI7XHJcbmltcG9ydCB0eXBlIHsgR2VvbWV0cnkgfSBmcm9tIFwiY29yZS9NZXNoZXMvZ2VvbWV0cnlcIjtcclxuaW1wb3J0IHR5cGUgeyBNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL21lc2hcIjtcclxuXHJcbmltcG9ydCB7IE1lc2hQcmltaXRpdmVNb2RlIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgdHlwZSB7IElLSFJEcmFjb01lc2hDb21wcmVzc2lvbiB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHR5cGUgeyBJTWVzaFByaW1pdGl2ZSwgSUJ1ZmZlclZpZXcgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIsIEFycmF5SXRlbSwgTG9hZEJvdW5kaW5nSW5mb0Zyb21Qb3NpdGlvbkFjY2Vzc29yIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24gZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIElCdWZmZXJWaWV3RHJhY28gZXh0ZW5kcyBJQnVmZmVyVmlldyB7XHJcbiAgICBfZHJhY29CYWJ5bG9uR2VvbWV0cnk/OiBQcm9taXNlPEdlb21ldHJ5PjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24vUkVBRE1FLm1kKVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24gaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZHJhY28gZGVjb2RlciB1c2VkIHRvIGRlY29kZSB2ZXJ0ZXggZGF0YSBvciBEcmFjb0RlY29kZXIuRGVmYXVsdCBpZiBub3QgZGVmaW5lZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZHJhY29EZWNvZGVyPzogRHJhY29EZWNvZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRvIHVzZSB0aGUgbm9ybWFsaXplZCBmbGFnIGZyb20gdGhlIGdsVEYgYWNjZXNzb3IgaW5zdGVhZCBvZiB0aGUgRHJhY28gZGF0YS4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZU5vcm1hbGl6ZWRGbGFnRnJvbUFjY2Vzc29yID0gdHJ1ZTtcclxuXHJcbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyOiBHTFRGTG9hZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IERyYWNvRGVjb2Rlci5EZWZhdWx0QXZhaWxhYmxlICYmIHRoaXMuX2xvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZHJhY29EZWNvZGVyO1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgX2xvYWRWZXJ0ZXhEYXRhQXN5bmMoY29udGV4dDogc3RyaW5nLCBwcmltaXRpdmU6IElNZXNoUHJpbWl0aXZlLCBiYWJ5bG9uTWVzaDogTWVzaCk6IE51bGxhYmxlPFByb21pc2U8R2VvbWV0cnk+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJEcmFjb01lc2hDb21wcmVzc2lvbiwgR2VvbWV0cnk+KGNvbnRleHQsIHByaW1pdGl2ZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSAhPT0gTWVzaFByaW1pdGl2ZU1vZGUuVFJJQU5HTEVTICYmIHByaW1pdGl2ZS5tb2RlICE9PSBNZXNoUHJpbWl0aXZlTW9kZS5UUklBTkdMRV9TVFJJUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogVW5zdXBwb3J0ZWQgbW9kZSAke3ByaW1pdGl2ZS5tb2RlfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzOiB7IFtraW5kOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkOiB7IFtraW5kOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcclxuICAgICAgICAgICAgY29uc3QgbG9hZEF0dHJpYnV0ZSA9IChuYW1lOiBzdHJpbmcsIGtpbmQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSWQgPSBleHRlbnNpb24uYXR0cmlidXRlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVJZCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1lc2guX2RlbGF5SW5mbyA9IGJhYnlsb25NZXNoLl9kZWxheUluZm8gfHwgW107XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFieWxvbk1lc2guX2RlbGF5SW5mby5pbmRleE9mKGtpbmQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoLl9kZWxheUluZm8ucHVzaChraW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tpbmRdID0gdW5pcXVlSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlTm9ybWFsaXplZEZsYWdGcm9tQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NvciA9IEFycmF5SXRlbS5UcnlHZXQodGhpcy5fbG9hZGVyLmdsdGYuYWNjZXNzb3JzLCBwcmltaXRpdmUuYXR0cmlidXRlc1tuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2Vzc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRba2luZF0gPSBhY2Nlc3Nvci5ub3JtYWxpemVkIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJQT1NJVElPTlwiLCBWZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTtcclxuICAgICAgICAgICAgbG9hZEF0dHJpYnV0ZShcIk5PUk1BTFwiLCBWZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCk7XHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJUQU5HRU5UXCIsIFZlcnRleEJ1ZmZlci5UYW5nZW50S2luZCk7XHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF8wXCIsIFZlcnRleEJ1ZmZlci5VVktpbmQpO1xyXG4gICAgICAgICAgICBsb2FkQXR0cmlidXRlKFwiVEVYQ09PUkRfMVwiLCBWZXJ0ZXhCdWZmZXIuVVYyS2luZCk7XHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF8yXCIsIFZlcnRleEJ1ZmZlci5VVjNLaW5kKTtcclxuICAgICAgICAgICAgbG9hZEF0dHJpYnV0ZShcIlRFWENPT1JEXzNcIiwgVmVydGV4QnVmZmVyLlVWNEtpbmQpO1xyXG4gICAgICAgICAgICBsb2FkQXR0cmlidXRlKFwiVEVYQ09PUkRfNFwiLCBWZXJ0ZXhCdWZmZXIuVVY1S2luZCk7XHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF81XCIsIFZlcnRleEJ1ZmZlci5VVjZLaW5kKTtcclxuICAgICAgICAgICAgbG9hZEF0dHJpYnV0ZShcIkpPSU5UU18wXCIsIFZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKTtcclxuICAgICAgICAgICAgbG9hZEF0dHJpYnV0ZShcIldFSUdIVFNfMFwiLCBWZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCk7XHJcbiAgICAgICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJDT0xPUl8wXCIsIFZlcnRleEJ1ZmZlci5Db2xvcktpbmQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyVmlldyA9IEFycmF5SXRlbS5HZXQoZXh0ZW5zaW9uQ29udGV4dCwgdGhpcy5fbG9hZGVyLmdsdGYuYnVmZmVyVmlld3MsIGV4dGVuc2lvbi5idWZmZXJWaWV3KSBhcyBJQnVmZmVyVmlld0RyYWNvO1xyXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlclZpZXcuX2RyYWNvQmFieWxvbkdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXJWaWV3Ll9kcmFjb0JhYnlsb25HZW9tZXRyeSA9IHRoaXMuX2xvYWRlci5sb2FkQnVmZmVyVmlld0FzeW5jKGAvYnVmZmVyVmlld3MvJHtidWZmZXJWaWV3LmluZGV4fWAsIGJ1ZmZlclZpZXcpLnRoZW4oYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkcmFjb0RlY29kZXIgPSB0aGlzLmRyYWNvRGVjb2RlciB8fCBEcmFjb0RlY29kZXIuRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkFjY2Vzc29yID0gQXJyYXlJdGVtLlRyeUdldCh0aGlzLl9sb2FkZXIuZ2x0Zi5hY2Nlc3NvcnMsIHByaW1pdGl2ZS5hdHRyaWJ1dGVzW1wiUE9TSVRJT05cIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhYnlsb25Cb3VuZGluZ0luZm8gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fbG9hZGVyLnBhcmVudC5hbHdheXNDb21wdXRlQm91bmRpbmdCb3ggJiYgIWJhYnlsb25NZXNoLnNrZWxldG9uICYmIHBvc2l0aW9uQWNjZXNzb3IgPyBMb2FkQm91bmRpbmdJbmZvRnJvbVBvc2l0aW9uQWNjZXNzb3IocG9zaXRpb25BY2Nlc3NvcikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBkcmFjb0RlY29kZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLl9kZWNvZGVNZXNoVG9HZW9tZXRyeUZvckdsdGZBc3luYyhiYWJ5bG9uTWVzaC5uYW1lLCB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLCBkYXRhLCBhdHRyaWJ1dGVzLCBub3JtYWxpemVkLCBiYWJ5bG9uQm91bmRpbmdJbmZvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGJ1ZmZlclZpZXcuX2RyYWNvQmFieWxvbkdlb21ldHJ5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvbihsb2FkZXIpKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXHJcbmltcG9ydCB0eXBlIHsgSUtIUkludGVyYWN0aXZpdHkgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB0eXBlIHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBGbG93R3JhcGhDb29yZGluYXRvciB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9mbG93R3JhcGhDb29yZGluYXRvclwiO1xyXG5pbXBvcnQgeyBQYXJzZUZsb3dHcmFwaEFzeW5jIH0gZnJvbSBcImNvcmUvRmxvd0dyYXBoL2Zsb3dHcmFwaFBhcnNlclwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5pbXBvcnQgdHlwZSB7IEdMVEZQYXRoVG9PYmplY3RDb252ZXJ0ZXIgfSBmcm9tIFwiLi9nbHRmUGF0aFRvT2JqZWN0Q29udmVydGVyXCI7XHJcbmltcG9ydCB7IEFkZE9iamVjdEFjY2Vzc29yVG9LZXksIEdldFBhdGhUb09iamVjdENvbnZlcnRlciB9IGZyb20gXCIuL29iamVjdE1vZGVsTWFwcGluZ1wiO1xyXG5pbXBvcnQgeyBJbnRlcmFjdGl2aXR5R3JhcGhUb0Zsb3dHcmFwaFBhcnNlciB9IGZyb20gXCIuL0tIUl9pbnRlcmFjdGl2aXR5L2ludGVyYWN0aXZpdHlHcmFwaFBhcnNlclwiO1xyXG5pbXBvcnQgeyBhZGRUb0Jsb2NrRmFjdG9yeSB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9CbG9ja3MvZmxvd0dyYXBoQmxvY2tGYWN0b3J5XCI7XHJcbmltcG9ydCB7IFF1YXRlcm5pb24sIFZlY3RvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgdHlwZSB7IFNjZW5lIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJQW5pbWF0aW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfaW50ZXJhY3Rpdml0eVwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEtIUl9pbnRlcmFjdGl2aXR5IGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfaW50ZXJhY3Rpdml0eVwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgZXh0ZW5zaW9uIGZvciBLSFJfaW50ZXJhY3Rpdml0eVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEtIUl9pbnRlcmFjdGl2aXR5IGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfcGF0aENvbnZlcnRlcj86IEdMVEZQYXRoVG9PYmplY3RDb252ZXJ0ZXI8YW55LCBhbnksIGFueT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSBfbG9hZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuX2xvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICAgICAgdGhpcy5fcGF0aENvbnZlcnRlciA9IEdldFBhdGhUb09iamVjdENvbnZlcnRlcih0aGlzLl9sb2FkZXIuZ2x0Zik7XHJcbiAgICAgICAgLy8gYXZvaWQgc3RhcnRpbmcgYW5pbWF0aW9ucyBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgIF9sb2FkZXIuX3NraXBTdGFydEFuaW1hdGlvblN0ZXAgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgb2JqZWN0IG1vZGVsIHdpdGggbmV3IHBvaW50ZXJzXHJcblxyXG4gICAgICAgIGNvbnN0IHNjZW5lID0gX2xvYWRlci5iYWJ5bG9uU2NlbmU7XHJcbiAgICAgICAgaWYgKHNjZW5lKSB7XHJcbiAgICAgICAgICAgIF9BZGRJbnRlcmFjdGl2aXR5T2JqZWN0TW9kZWwoc2NlbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wYXRoQ29udmVydGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcclxuICAgIHB1YmxpYyBhc3luYyBvblJlYWR5KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVyLmJhYnlsb25TY2VuZSB8fCAhdGhpcy5fcGF0aENvbnZlcnRlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fbG9hZGVyLmJhYnlsb25TY2VuZTtcclxuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5RGVmaW5pdGlvbiA9IHRoaXMuX2xvYWRlci5nbHRmLmV4dGVuc2lvbnM/LktIUl9pbnRlcmFjdGl2aXR5IGFzIElLSFJJbnRlcmFjdGl2aXR5O1xyXG4gICAgICAgIGlmICghaW50ZXJhY3Rpdml0eURlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gdGVjaG5pY2FsbHkgdGhyb3csIGJ1dCBpdCdzIG5vdCBhIGNyaXRpY2FsIGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdG9yID0gbmV3IEZsb3dHcmFwaENvb3JkaW5hdG9yKHsgc2NlbmUgfSk7XHJcbiAgICAgICAgY29vcmRpbmF0b3IuZGlzcGF0Y2hFdmVudHNTeW5jaHJvbm91c2x5ID0gZmFsc2U7IC8vIGdsVEYgaW50ZXJhY3Rpdml0eSBkaXNwYXRjaGVzIGV2ZW50cyBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGNvbnN0IGdyYXBocyA9IGludGVyYWN0aXZpdHlEZWZpbml0aW9uLmdyYXBocy5tYXAoKGdyYXBoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBJbnRlcmFjdGl2aXR5R3JhcGhUb0Zsb3dHcmFwaFBhcnNlcihncmFwaCwgdGhpcy5fbG9hZGVyLmdsdGYsIHRoaXMuX2xvYWRlci5wYXJlbnQudGFyZ2V0RnBzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5zZXJpYWxpemVUb0Zsb3dHcmFwaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHBhcnNlIGVhY2ggZ3JhcGggYXN5bmNcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChncmFwaHMubWFwKGFzeW5jIChncmFwaCkgPT4gYXdhaXQgUGFyc2VGbG93R3JhcGhBc3luYyhncmFwaCwgeyBjb29yZGluYXRvciwgcGF0aENvbnZlcnRlcjogdGhpcy5fcGF0aENvbnZlcnRlciB9KSkpO1xyXG5cclxuICAgICAgICBjb29yZGluYXRvci5zdGFydCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIHBvcHVsYXRlcyB0aGUgb2JqZWN0IG1vZGVsIHdpdGggdGhlIGludGVyYWN0aXZpdHkgZXh0ZW5zaW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX0FkZEludGVyYWN0aXZpdHlPYmplY3RNb2RlbChzY2VuZTogU2NlbmUpIHtcclxuICAgIC8vIE5vdGUgLSBhbGwgb2YgdGhvc2UgYXJlIHJlYWQtb25seSwgYXMgcGVyIHRoZSBzcGVjcyFcclxuXHJcbiAgICAvLyBhY3RpdmUgY2FtZXJhIHJvdGF0aW9uXHJcbiAgICBBZGRPYmplY3RBY2Nlc3NvclRvS2V5KFwiL2V4dGVuc2lvbnMvS0hSX2ludGVyYWN0aXZpdHkvPy9hY3RpdmVDYW1lcmEvcm90YXRpb25cIiwge1xyXG4gICAgICAgIGdldDogKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNjZW5lLmFjdGl2ZUNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKE5hTiwgTmFOLCBOYU4sIE5hTik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcXVhdCA9IFF1YXRlcm5pb24uRnJvbVJvdGF0aW9uTWF0cml4KHNjZW5lLmFjdGl2ZUNhbWVyYS5nZXRXb3JsZE1hdHJpeCgpKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgaWYgKCFzY2VuZS51c2VSaWdodEhhbmRlZFN5c3RlbSkge1xyXG4gICAgICAgICAgICAgICAgcXVhdC53ICo9IC0xOyAvLyBnbFRGIHVzZXMgcmlnaHQtaGFuZGVkIHN5c3RlbSwgd2hpbGUgYmFieWxvbiB1c2VzIGxlZnQtaGFuZGVkXHJcbiAgICAgICAgICAgICAgICBxdWF0LnggKj0gLTE7IC8vIGdsVEYgdXNlcyByaWdodC1oYW5kZWQgc3lzdGVtLCB3aGlsZSBiYWJ5bG9uIHVzZXMgbGVmdC1oYW5kZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcXVhdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGU6IFwiUXVhdGVybmlvblwiLFxyXG4gICAgICAgIGdldFRhcmdldDogKCkgPT4gc2NlbmUuYWN0aXZlQ2FtZXJhLFxyXG4gICAgfSk7XHJcbiAgICAvLyBhY3RpdmVDYW1lcmEgcG9zaXRpb25cclxuICAgIEFkZE9iamVjdEFjY2Vzc29yVG9LZXkoXCIvZXh0ZW5zaW9ucy9LSFJfaW50ZXJhY3Rpdml0eS8/L2FjdGl2ZUNhbWVyYS9wb3NpdGlvblwiLCB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2NlbmUuYWN0aXZlQ2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoTmFOLCBOYU4sIE5hTik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcG9zID0gc2NlbmUuYWN0aXZlQ2FtZXJhLmdldFdvcmxkTWF0cml4KCkuZ2V0VHJhbnNsYXRpb24oKTsgLy8gbm90IGdsb2JhbCBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAoIXNjZW5lLnVzZVJpZ2h0SGFuZGVkU3lzdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBwb3MueCAqPSAtMTsgLy8gZ2xURiB1c2VzIHJpZ2h0LWhhbmRlZCBzeXN0ZW0sIHdoaWxlIGJhYnlsb24gdXNlcyBsZWZ0LWhhbmRlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwb3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0eXBlOiBcIlZlY3RvcjNcIixcclxuICAgICAgICBnZXRUYXJnZXQ6ICgpID0+IHNjZW5lLmFjdGl2ZUNhbWVyYSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIC9hbmltYXRpb25zL3t9IHBvaW50ZXJzOlxyXG4gICAgQWRkT2JqZWN0QWNjZXNzb3JUb0tleShcIi9hbmltYXRpb25zL3t9L2V4dGVuc2lvbnMvS0hSX2ludGVyYWN0aXZpdHkvaXNQbGF5aW5nXCIsIHtcclxuICAgICAgICBnZXQ6IChhbmltYXRpb246IElBbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5fYmFieWxvbkFuaW1hdGlvbkdyb3VwPy5pc1BsYXlpbmcgPz8gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcclxuICAgICAgICBnZXRUYXJnZXQ6IChhbmltYXRpb246IElBbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5fYmFieWxvbkFuaW1hdGlvbkdyb3VwO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIEFkZE9iamVjdEFjY2Vzc29yVG9LZXkoXCIvYW5pbWF0aW9ucy97fS9leHRlbnNpb25zL0tIUl9pbnRlcmFjdGl2aXR5L21pblRpbWVcIiwge1xyXG4gICAgICAgIGdldDogKGFuaW1hdGlvbjogSUFuaW1hdGlvbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKGFuaW1hdGlvbi5fYmFieWxvbkFuaW1hdGlvbkdyb3VwPy5mcm9tID8/IDApIC8gNjA7IC8vIGZpeGVkIGZhY3RvciBmb3IgZHVyYXRpb24tdG8tZnJhbWVzIGNvbnZlcnNpb25cclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXHJcbiAgICAgICAgZ2V0VGFyZ2V0OiAoYW5pbWF0aW9uOiBJQW5pbWF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cDtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBBZGRPYmplY3RBY2Nlc3NvclRvS2V5KFwiL2FuaW1hdGlvbnMve30vZXh0ZW5zaW9ucy9LSFJfaW50ZXJhY3Rpdml0eS9tYXhUaW1lXCIsIHtcclxuICAgICAgICBnZXQ6IChhbmltYXRpb246IElBbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIChhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cD8udG8gPz8gMCkgLyA2MDsgLy8gZml4ZWQgZmFjdG9yIGZvciBkdXJhdGlvbi10by1mcmFtZXMgY29udmVyc2lvblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcclxuICAgICAgICBnZXRUYXJnZXQ6IChhbmltYXRpb246IElBbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5fYmFieWxvbkFuaW1hdGlvbkdyb3VwO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIC8vIHBsYXloZWFkXHJcbiAgICBBZGRPYmplY3RBY2Nlc3NvclRvS2V5KFwiL2FuaW1hdGlvbnMve30vZXh0ZW5zaW9ucy9LSFJfaW50ZXJhY3Rpdml0eS9wbGF5aGVhZFwiLCB7XHJcbiAgICAgICAgZ2V0OiAoYW5pbWF0aW9uOiBJQW5pbWF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYW5pbWF0aW9uLl9iYWJ5bG9uQW5pbWF0aW9uR3JvdXA/LmdldEN1cnJlbnRGcmFtZSgpID8/IDApIC8gNjA7IC8vIGZpeGVkIGZhY3RvciBmb3IgZHVyYXRpb24tdG8tZnJhbWVzIGNvbnZlcnNpb25cclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXHJcbiAgICAgICAgZ2V0VGFyZ2V0OiAoYW5pbWF0aW9uOiBJQW5pbWF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cDtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICAvL3ZpcnR1YWxQbGF5aGVhZCAtIFRPRE8sIGRvIHdlIHN1cHBvcnQgdGhpcyBwcm9wZXJ0eSBpbiBvdXIgYW5pbWF0aW9ucz8gZ2V0Q3VycmVudEZyYW1lICBpcyB0aGUgb25seSBtZXRob2Qgd2UgaGF2ZSBmb3IgdGhpcy5cclxuICAgIEFkZE9iamVjdEFjY2Vzc29yVG9LZXkoXCIvYW5pbWF0aW9ucy97fS9leHRlbnNpb25zL0tIUl9pbnRlcmFjdGl2aXR5L3ZpcnR1YWxQbGF5aGVhZFwiLCB7XHJcbiAgICAgICAgZ2V0OiAoYW5pbWF0aW9uOiBJQW5pbWF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYW5pbWF0aW9uLl9iYWJ5bG9uQW5pbWF0aW9uR3JvdXA/LmdldEN1cnJlbnRGcmFtZSgpID8/IDApIC8gNjA7IC8vIGZpeGVkIGZhY3RvciBmb3IgZHVyYXRpb24tdG8tZnJhbWVzIGNvbnZlcnNpb25cclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXHJcbiAgICAgICAgZ2V0VGFyZ2V0OiAoYW5pbWF0aW9uOiBJQW5pbWF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cDtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIFJlZ2lzdGVyIGZsb3cgZ3JhcGggYmxvY2tzLiBEbyBpdCBoZXJlIHNvIHRoZXkgYXJlIGF2YWlsYWJsZSB3aGVuIHRoZSBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuYWRkVG9CbG9ja0ZhY3RvcnkoTkFNRSwgXCJGbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyXCIsIGFzeW5jICgpID0+IHtcclxuICAgIHJldHVybiAoYXdhaXQgaW1wb3J0KFwiLi9LSFJfaW50ZXJhY3Rpdml0eS9mbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyXCIpKS5GbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyO1xyXG59KTtcclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9pbnRlcmFjdGl2aXR5KGxvYWRlcikpO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmltcG9ydCB0eXBlIHsgSUtIUkludGVyYWN0aXZpdHlfRGVjbGFyYXRpb24sIElLSFJJbnRlcmFjdGl2aXR5X0dyYXBoLCBJS0hSSW50ZXJhY3Rpdml0eV9Ob2RlIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xuaW1wb3J0IHsgRmxvd0dyYXBoQmxvY2tOYW1lcyB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9CbG9ja3MvZmxvd0dyYXBoQmxvY2tOYW1lc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNvcmUvTWlzYy9sb2dnZXJcIjtcbmltcG9ydCB0eXBlIHsgSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9jaywgSVNlcmlhbGl6ZWRGbG93R3JhcGhDb250ZXh0IH0gZnJvbSBcImNvcmUvRmxvd0dyYXBoL3R5cGVEZWZpbml0aW9uc1wiO1xuaW1wb3J0IHR5cGUgeyBJbnRlcmFjdGl2aXR5RXZlbnQsIEludGVyYWN0aXZpdHlHcmFwaFRvRmxvd0dyYXBoUGFyc2VyIH0gZnJvbSBcIi4vaW50ZXJhY3Rpdml0eUdyYXBoUGFyc2VyXCI7XG5pbXBvcnQgdHlwZSB7IElHTFRGIH0gZnJvbSBcIi4uLy4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBGbG93R3JhcGhUeXBlcywgZ2V0QW5pbWF0aW9uVHlwZUJ5Rmxvd0dyYXBoVHlwZSB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9mbG93R3JhcGhSaWNoVHlwZXNcIjtcblxuaW50ZXJmYWNlIElHTFRGVG9GbG93R3JhcGhNYXBwaW5nT2JqZWN0PEkgPSBhbnksIE8gPSBhbnk+IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIEZsb3dHcmFwaCBibG9jay5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHByb3BlcnR5IGluIHRoZSBnbFRGIHNwZWNzLlxuICAgICAqIElmIG5vdCBwcm92aWRlZCB3aWxsIGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGdsdGZUeXBlPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRmxvd0dyYXBoIGJsb2NrLlxuICAgICAqIElmIG5vdCBkZWZpbmVkIGl0IGVxdWFscyB0aGUgZ2xURiB0eXBlLlxuICAgICAqL1xuICAgIGZsb3dHcmFwaFR5cGU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGRhdGEgZnJvbSB0aGUgZ2xURiB0byB0aGUgRmxvd0dyYXBoIGJsb2NrLlxuICAgICAqL1xuICAgIGRhdGFUcmFuc2Zvcm1lcj86IChkYXRhOiBJW10sIHBhcnNlcjogSW50ZXJhY3Rpdml0eUdyYXBoVG9GbG93R3JhcGhQYXJzZXIpID0+IE9bXTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcHJvcGVydHkgaXMgaW4gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgYmxvY2suXG4gICAgICovXG4gICAgaW5PcHRpb25zPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcm9wZXJ0eSBpcyBhIHBvaW50ZXIgdG8gYSB2YWx1ZS5cbiAgICAgKiBUaGlzIHdpbGwgYWRkIGFuIGV4dHJhIEpzb25Qb2ludGVyUGFyc2VyIGJsb2NrIHRvIHRoZSBncmFwaC5cbiAgICAgKi9cbiAgICBpc1BvaW50ZXI/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByb3BlcnR5IGlzIGFuIGluZGV4IHRvIGEgdmFsdWUuXG4gICAgICogaWYgZGVmaW5lZCB0aGlzIHdpbGwgYmUgdGhlIG5hbWUgb2YgdGhlIGFycmF5IHRvIGZpbmQgdGhlIG9iamVjdCBpbi5cbiAgICAgKi9cbiAgICBpc1ZhcmlhYmxlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0eXBlIHRoaXMgdmFsdWUgd2lsbCBiZSBtYXBwZWQgdG8uXG4gICAgICogVGhpcyBpcyB1c2VkIGlmIHdlIGdlbmVyYXRlIG1vcmUgdGhhbiBvbmUgYmxvY2sgZm9yIGEgc2luZ2xlIGdsVEYgbm9kZS5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgZmlyc3QgYmxvY2sgaW4gdGhlIG1hcHBpbmcuXG4gICAgICovXG4gICAgdG9CbG9jaz86IEZsb3dHcmFwaEJsb2NrTmFtZXM7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGluIGNvbmZpZ3VyYXRpb24gdmFsdWVzLiBJZiBkZWZpbmVkLCB0aGlzIHdpbGwgYmUgdGhlIGRlZmF1bHQgdmFsdWUsIGlmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZT86IE87XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmcge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBGbG93R3JhcGggYmxvY2socykuXG4gICAgICogVHlwaWNhbGx5IHdpbGwgYmUgYSBzaW5nbGUgZWxlbWVudCBpbiBhbiBhcnJheS5cbiAgICAgKiBXaGVuIGFkZGluZyBibG9ja3MgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB1c2UgdGhlIEtIUl9pbnRlcmFjdGl2aXR5IHByZWZpeC5cbiAgICAgKi9cbiAgICBibG9ja3M6IChGbG93R3JhcGhCbG9ja05hbWVzIHwgc3RyaW5nKVtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dHMgb2YgdGhlIGdsVEYgbm9kZSBtYXBwZWQgdG8gdGhlIEZsb3dHcmFwaCBibG9jay5cbiAgICAgKi9cbiAgICBpbnB1dHM/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgaW5wdXRzIG9mIHRoZSBnbFRGIG5vZGUgbWFwcGVkIHRvIHRoZSBGbG93R3JhcGggYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZXM/OiB7IFtvcmlnaW5OYW1lOiBzdHJpbmddOiBJR0xURlRvRmxvd0dyYXBoTWFwcGluZ09iamVjdCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZsb3cgaW5wdXRzIG9mIHRoZSBnbFRGIG5vZGUgbWFwcGVkIHRvIHRoZSBGbG93R3JhcGggYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICBmbG93cz86IHsgW29yaWdpbk5hbWU6IHN0cmluZ106IElHTFRGVG9GbG93R3JhcGhNYXBwaW5nT2JqZWN0IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0cyBvZiB0aGUgZ2xURiBub2RlIG1hcHBlZCB0byB0aGUgRmxvd0dyYXBoIGJsb2NrLlxuICAgICAqL1xuICAgIG91dHB1dHM/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgb3V0cHV0cyBvZiB0aGUgZ2xURiBub2RlIG1hcHBlZCB0byB0aGUgRmxvd0dyYXBoIGJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVzPzogeyBbb3JpZ2luTmFtZTogc3RyaW5nXTogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmdPYmplY3QgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmbG93IG91dHB1dHMgb2YgdGhlIGdsVEYgbm9kZSBtYXBwZWQgdG8gdGhlIEZsb3dHcmFwaCBibG9jay5cbiAgICAgICAgICovXG4gICAgICAgIGZsb3dzPzogeyBbb3JpZ2luTmFtZTogc3RyaW5nXTogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmdPYmplY3QgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBnbFRGIG5vZGUgbWFwcGVkIHRvIHRoZSBGbG93R3JhcGggYmxvY2suXG4gICAgICogVGhpcyBpbmZvcm1hdGlvbiBpcyB1c3VhbGx5IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGJsb2NrLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyYXRpb24/OiB7IFtvcmlnaW5OYW1lOiBzdHJpbmddOiBJR0xURlRvRmxvd0dyYXBoTWFwcGluZ09iamVjdCB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgd2UgZ2VuZXJhdGUgbW9yZSB0aGFuIG9uZSBibG9jayBmb3IgYSBzaW5nbGUgZ2xURiBub2RlLCB0aGlzIG1hcHBpbmcgd2lsbCBiZSB1c2VkIHRvIG1hcFxuICAgICAqIGJldHdlZW4gdGhlIGZsb3dHcmFwaCBjbGFzc2VzLlxuICAgICAqL1xuICAgIHR5cGVUb1R5cGVNYXBwaW5nPzogeyBbb3JpZ2luTmFtZTogc3RyaW5nXTogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmdPYmplY3QgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9ucyBiZXR3ZWVuIHR3byBvciBtb3JlIGJsb2Nrcy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gY29ubmVjdCB0aGUgYmxvY2tzIGluIHRoZSBncmFwaFxuICAgICAqL1xuICAgIGludGVyQmxvY2tDb25uZWN0b3JzPzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGlucHV0IGNvbm5lY3Rpb24gaW4gdGhlIGZpcnN0IGJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXQ6IHN0cmluZztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBvdXRwdXQgY29ubmVjdGlvbiBpbiB0aGUgc2Vjb25kIGJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgb3V0cHV0OiBzdHJpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYmxvY2sgaW4gdGhlIGFycmF5IG9mIGJsb2NrcyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBpbnB1dC5cbiAgICAgICAgICovXG4gICAgICAgIGlucHV0QmxvY2tJbmRleDogbnVtYmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBibG9jayBpbiB0aGUgYXJyYXkgb2YgYmxvY2tzIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIG91dHB1dC5cbiAgICAgICAgICovXG4gICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IG51bWJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIGEgdmFyaWFibGUgY29ubmVjdGlvbiBvciBhIGZsb3cgY29ubmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzVmFyaWFibGU/OiBib29sZWFuO1xuICAgIH1bXTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb3B0aW9uYWwgZnVuY3Rpb24gd2lsbCBhbGxvdyB0byB2YWxpZGF0ZSB0aGUgbm9kZSwgYWNjb3JkaW5nIHRvIHRoZSBnbFRGIHNwZWNzLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiBhIG5vZGUgaGFzIGEgY29uZmlndXJhdGlvbiBvYmplY3QsIGl0IG11c3QgYmUgcHJlc2VudCBhbmQgY29ycmVjdC5cbiAgICAgKiBUaGlzIGlzIGEgYmFzaWMgbm9kZS1iYXNlZCB2YWxpZGF0aW9uLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGZhbHNlIGFuZCBsb2cgdGhlIGVycm9yIGlmIHRoZSBub2RlIGlzIG5vdCB2YWxpZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBjYW4gYWxzbyBtb2RpZnkgdGhlIG5vZGUsIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnbHRmQmxvY2sgdGhlIGdsVEYgbm9kZSB0byB2YWxpZGF0ZVxuICAgICAqIEBwYXJhbSBnbFRGT2JqZWN0IHRoZSBnbFRGIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdmFsaWRhdGVkLCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgdmFsaWRhdGlvbj86IChnbHRmQmxvY2s6IElLSFJJbnRlcmFjdGl2aXR5X05vZGUsIGludGVyYWN0aXZpdHlHcmFwaDogSUtIUkludGVyYWN0aXZpdHlfR3JhcGgsIGdsVEZPYmplY3Q/OiBJR0xURikgPT4geyB2YWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCBpZiB3ZSBuZWVkIGV4dHJhIGluZm9ybWF0aW9uIGZvciB0aGUgY29uc3RydWN0b3Ivb3B0aW9ucyB0aGF0IGlzIG5vdCBwcm92aWRlZCBkaXJlY3RseSBieSB0aGUgZ2xURiBub2RlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIHJldHVybiBtb3JlIHRoYW4gb25lIG5vZGUsIGlmIGV4dHJhIG5vZGVzIGFyZSBuZWVkZWQgZm9yIHRoaXMgYmxvY2sgdG8gZnVuY3Rpb24gY29ycmVjdGx5LlxuICAgICAqIFJldHVybmluZyBtb3JlIHRoYW4gb25lIGJsb2NrIHdpbGwgdXN1YWxseSBoYXBwZW4gd2hlbiBhIGpzb24gcG9pbnRlciB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2x0ZkJsb2NrIHRoZSBnbFRGIG5vZGVcbiAgICAgKiBAcGFyYW0gbWFwcGluZyB0aGUgbWFwcGluZyBvYmplY3RcbiAgICAgKiBAcGFyYW0gYXJyYXlzIHRoZSBhcnJheXMgb2YgdGhlIGludGVyYWN0aXZpdHkgb2JqZWN0XG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZWRPYmplY3RzIHRoZSBzZXJpYWxpemVkIG9iamVjdFxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHNlcmlhbGl6ZWQgbm9kZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBncmFwaC5cbiAgICAgKi9cbiAgICBleHRyYVByb2Nlc3Nvcj86IChcbiAgICAgICAgZ2x0ZkJsb2NrOiBJS0hSSW50ZXJhY3Rpdml0eV9Ob2RlLFxuICAgICAgICBkZWNsYXJhdGlvbjogSUtIUkludGVyYWN0aXZpdHlfRGVjbGFyYXRpb24sXG4gICAgICAgIG1hcHBpbmc6IElHTFRGVG9GbG93R3JhcGhNYXBwaW5nLFxuICAgICAgICBwYXJzZXI6IEludGVyYWN0aXZpdHlHcmFwaFRvRmxvd0dyYXBoUGFyc2VyLFxuICAgICAgICBzZXJpYWxpemVkT2JqZWN0czogSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9ja1tdLFxuICAgICAgICBjb250ZXh0OiBJU2VyaWFsaXplZEZsb3dHcmFwaENvbnRleHQsXG4gICAgICAgIGdsb2JhbEdMVEY/OiBJR0xURlxuICAgICkgPT4gSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9ja1tdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwcGluZ0ZvckZ1bGxPcGVyYXRpb25OYW1lKGZ1bGxPcGVyYXRpb25OYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBbb3AsIGV4dGVuc2lvbl0gPSBmdWxsT3BlcmF0aW9uTmFtZS5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIGdldE1hcHBpbmdGb3JEZWNsYXJhdGlvbih7IG9wLCBleHRlbnNpb24gfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBwaW5nRm9yRGVjbGFyYXRpb24oZGVjbGFyYXRpb246IElLSFJJbnRlcmFjdGl2aXR5X0RlY2xhcmF0aW9uLCByZXR1cm5Ob09wSWZOb3RBdmFpbGFibGU6IGJvb2xlYW4gPSB0cnVlKTogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IG1hcHBpbmcgPSBkZWNsYXJhdGlvbi5leHRlbnNpb24gPyBnbHRmRXh0ZW5zaW9uc1RvRmxvd0dyYXBoTWFwcGluZ1tkZWNsYXJhdGlvbi5leHRlbnNpb25dPy5bZGVjbGFyYXRpb24ub3BdIDogZ2x0ZlRvRmxvd0dyYXBoTWFwcGluZ1tkZWNsYXJhdGlvbi5vcF07XG4gICAgaWYgKCFtYXBwaW5nKSB7XG4gICAgICAgIExvZ2dlci5XYXJuKGBObyBtYXBwaW5nIGZvdW5kIGZvciBvcGVyYXRpb24gJHtkZWNsYXJhdGlvbi5vcH0gYW5kIGV4dGVuc2lvbiAke2RlY2xhcmF0aW9uLmV4dGVuc2lvbiB8fCBcIktIUl9pbnRlcmFjdGl2aXR5XCJ9YCk7XG4gICAgICAgIGlmIChyZXR1cm5Ob09wSWZOb3RBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0czogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmdbXCJpbnB1dHNcIl0gPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dHM6IElHTFRGVG9GbG93R3JhcGhNYXBwaW5nW1wib3V0cHV0c1wiXSA9IHtcbiAgICAgICAgICAgICAgICBmbG93czoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmlucHV0VmFsdWVTb2NrZXRzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzLnZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlY2xhcmF0aW9uLmlucHV0VmFsdWVTb2NrZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy52YWx1ZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24ub3V0cHV0VmFsdWVTb2NrZXRzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy52YWx1ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWNsYXJhdGlvbi5vdXRwdXRWYWx1ZVNvY2tldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnZhbHVlcyFba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmxvY2tzOiBbXSwgLy8gbm8gYmxvY2tzLCBqdXN0IG1hcHBpbmdcbiAgICAgICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBpbmc7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBuZXcgbWFwcGluZyB0byBnbFRGIGludGVyYWN0aXZpdHkuXG4gKiBPdGhlciBleHRlbnNpb25zIGNhbiBkZWZpbmUgbmV3IHR5cGVzIG9mIGJsb2NrcywgdGhpcyBpcyB0aGUgd2F5IHRvIGxldCBpbnRlcmFjdGl2aXR5IGtub3cgaG93IHRvIHBhcnNlIHRoZW0uXG4gKiBAcGFyYW0ga2V5IHRoZSB0eXBlIG9mIG5vZGUsIGkuZS4gXCJ2YXJpYWJsZS9nZXRcIlxuICogQHBhcmFtIGV4dGVuc2lvbiB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBpbnRlcmFjdGl2aXR5IG9wZXJhdGlvbiwgaS5lLiBcIktIUl9zZWxlY3RhYmlsaXR5XCJcbiAqIEBwYXJhbSBtYXBwaW5nIFRoZSBtYXBwaW5nIG9iamVjdC4gU2VlIGRvY3VtZW50YXRpb24gb3IgZXhhbXBsZXMgYmVsb3cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGROZXdJbnRlcmFjdGl2aXR5Rmxvd0dyYXBoTWFwcGluZyhrZXk6IHN0cmluZywgZXh0ZW5zaW9uOiBzdHJpbmcsIG1hcHBpbmc6IElHTFRGVG9GbG93R3JhcGhNYXBwaW5nKSB7XG4gICAgZ2x0ZkV4dGVuc2lvbnNUb0Zsb3dHcmFwaE1hcHBpbmdbZXh0ZW5zaW9uXSB8fD0ge307XG4gICAgZ2x0ZkV4dGVuc2lvbnNUb0Zsb3dHcmFwaE1hcHBpbmdbZXh0ZW5zaW9uXVtrZXldID0gbWFwcGluZztcbn1cblxuY29uc3QgZ2x0ZkV4dGVuc2lvbnNUb0Zsb3dHcmFwaE1hcHBpbmc6IHsgW2V4dGVuc2lvbjogc3RyaW5nXTogeyBba2V5OiBzdHJpbmddOiBJR0xURlRvRmxvd0dyYXBoTWFwcGluZyB9IH0gPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgQkFCWUxPTiBleHRlbnNpb24gZm9yIGdsVEYgaW50ZXJhY3Rpdml0eS5cbiAgICAgKiBJdCBkZWZpbmVzIGJhYnlsb24tc3BlY2lmaWMgYmxvY2tzIGFuZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIEJBQllMT046IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZsb3cvbG9nIGlzIGEgZmxvdyBub2RlIHRoYXQgbG9ncyBpbnB1dCB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICogSXQgaGFzIFwiaW5cIiBhbmQgXCJvdXRcIiBmbG93cywgYW5kIHRha2VzIGEgbWVzc2FnZSBhcyBpbnB1dC5cbiAgICAgICAgICogVGhlIG1lc3NhZ2UgY2FuIGJlIGFueSB0eXBlIG9mIHZhbHVlLlxuICAgICAgICAgKiBUaGUgbWVzc2FnZSBpcyBsb2dnZWQgdG8gdGhlIGNvbnNvbGUgd2hlbiB0aGUgXCJpblwiIGZsb3cgaXMgdHJpZ2dlcmVkLlxuICAgICAgICAgKiBUaGUgXCJvdXRcIiBmbG93IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBtZXNzYWdlIGlzIGxvZ2dlZC5cbiAgICAgICAgICovXG4gICAgICAgIFwiZmxvdy9sb2dcIjoge1xuICAgICAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5Db25zb2xlTG9nXSxcbiAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB7IG5hbWU6IFwibWVzc2FnZVwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbi8vIHRoaXMgbWFwcGVyIGlzIGp1c3QgYSB3YXkgdG8gY29udmVydCB0aGUgZ2xURiBub2RlcyB0byBGbG93R3JhcGggbm9kZXMgaW4gdGVybXMgb2YgaW5wdXQvb3V0cHV0IGNvbm5lY3Rpb24gbmFtZXMgYW5kIHZhbHVlcy5cbmNvbnN0IGdsdGZUb0Zsb3dHcmFwaE1hcHBpbmc6IHsgW2tleTogc3RyaW5nXTogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmcgfSA9IHtcbiAgICBcImV2ZW50L29uU3RhcnRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLlNjZW5lUmVhZHlFdmVudF0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgb3V0OiB7IG5hbWU6IFwiZG9uZVwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJldmVudC9vblRpY2tcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLlNjZW5lVGlja0V2ZW50XSxcbiAgICAgICAgaW5wdXRzOiB7fSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgdGltZVNpbmNlTGFzdFRpY2s6IHsgbmFtZTogXCJkZWx0YVRpbWVcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgLyosIGRhdGFUcmFuc2Zvcm1lcjogKHRpbWU6IG51bWJlcikgPT4gdGltZSAvIDEwMDAqLyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgb3V0OiB7IG5hbWU6IFwiZG9uZVwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJldmVudC9zZW5kXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5TZW5kQ3VzdG9tRXZlbnRdLFxuICAgICAgICBleHRyYVByb2Nlc3NvcihnbHRmQmxvY2ssIGRlY2xhcmF0aW9uLCBfbWFwcGluZywgcGFyc2VyLCBzZXJpYWxpemVkT2JqZWN0cykge1xuICAgICAgICAgICAgLy8gc2V0IGV2ZW50SWQgYW5kIGV2ZW50RGF0YS4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9mIHRoZSBnbFRGIHNob3VsZCBoYXZlIGEgc2luZ2xlIG9iamVjdC5cbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIHRoYXQgd2UgYXJlIHJ1bm5pbmcgaXQgb24gdGhlIHJpZ2h0IGJsb2NrLlxuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLm9wICE9PSBcImV2ZW50L3NlbmRcIiB8fCAhZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24gfHwgT2JqZWN0LmtleXMoZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24pLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmUgZXZlbnQgc2hvdWxkIGhhdmUgYSBzaW5nbGUgY29uZmlndXJhdGlvbiBvYmplY3QsIHRoZSBldmVudCBpdHNlbGZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudENvbmZpZ3VyYXRpb24gPSBnbHRmQmxvY2suY29uZmlndXJhdGlvbltcImV2ZW50XCJdO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRJZCA9IGV2ZW50Q29uZmlndXJhdGlvbi52YWx1ZVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnRJZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGlkIHNob3VsZCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50OiBJbnRlcmFjdGl2aXR5RXZlbnQgPSBwYXJzZXIuYXJyYXlzLmV2ZW50c1tldmVudElkXTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRPYmplY3QgPSBzZXJpYWxpemVkT2JqZWN0c1swXTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnIHx8PSB7fTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnLmV2ZW50SWQgPSBldmVudC5ldmVudElkO1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcuZXZlbnREYXRhID0gZXZlbnQuZXZlbnREYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRPYmplY3RzO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJldmVudC9yZWNlaXZlXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5SZWNlaXZlQ3VzdG9tRXZlbnRdLFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgICAgIG91dDogeyBuYW1lOiBcImRvbmVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGlvbihnbHRmQmxvY2ssIGludGVyYWN0aXZpdHlHcmFwaCkge1xuICAgICAgICAgICAgaWYgKCFnbHRmQmxvY2suY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIlJlY2VpdmUgZXZlbnQgc2hvdWxkIGhhdmUgYSBjb25maWd1cmF0aW9uIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiBcIlJlY2VpdmUgZXZlbnQgc2hvdWxkIGhhdmUgYSBjb25maWd1cmF0aW9uIG9iamVjdFwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudENvbmZpZ3VyYXRpb24gPSBnbHRmQmxvY2suY29uZmlndXJhdGlvbltcImV2ZW50XCJdO1xuICAgICAgICAgICAgaWYgKCFldmVudENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoXCJSZWNlaXZlIGV2ZW50IHNob3VsZCBoYXZlIGEgc2luZ2xlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCB0aGUgZXZlbnQgaXRzZWxmXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IFwiUmVjZWl2ZSBldmVudCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBjb25maWd1cmF0aW9uIG9iamVjdCwgdGhlIGV2ZW50IGl0c2VsZlwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudElkID0gZXZlbnRDb25maWd1cmF0aW9uLnZhbHVlWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudElkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiRXZlbnQgaWQgc2hvdWxkIGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IFwiRXZlbnQgaWQgc2hvdWxkIGJlIGEgbnVtYmVyXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gaW50ZXJhY3Rpdml0eUdyYXBoLmV2ZW50cz8uW2V2ZW50SWRdO1xuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihgRXZlbnQgd2l0aCBpZCAke2V2ZW50SWR9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IGBFdmVudCB3aXRoIGlkICR7ZXZlbnRJZH0gbm90IGZvdW5kYCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoZ2x0ZkJsb2NrLCBkZWNsYXJhdGlvbiwgX21hcHBpbmcsIHBhcnNlciwgc2VyaWFsaXplZE9iamVjdHMpIHtcbiAgICAgICAgICAgIC8vIHNldCBldmVudElkIGFuZCBldmVudERhdGEuIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBvZiB0aGUgZ2xURiBzaG91bGQgaGF2ZSBhIHNpbmdsZSBvYmplY3QuXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGF0IHdlIGFyZSBydW5uaW5nIGl0IG9uIHRoZSByaWdodCBibG9jay5cbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5vcCAhPT0gXCJldmVudC9yZWNlaXZlXCIgfHwgIWdsdGZCbG9jay5jb25maWd1cmF0aW9uIHx8IE9iamVjdC5rZXlzKGdsdGZCbG9jay5jb25maWd1cmF0aW9uKS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlIGV2ZW50IHNob3VsZCBoYXZlIGEgc2luZ2xlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCB0aGUgZXZlbnQgaXRzZWxmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnRDb25maWd1cmF0aW9uID0gZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb25bXCJldmVudFwiXTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudENvbmZpZ3VyYXRpb24udmFsdWVbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50SWQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpZCBzaG91bGQgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudDogSW50ZXJhY3Rpdml0eUV2ZW50ID0gcGFyc2VyLmFycmF5cy5ldmVudHNbZXZlbnRJZF07XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkT2JqZWN0ID0gc2VyaWFsaXplZE9iamVjdHNbMF07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5ldmVudElkID0gZXZlbnQuZXZlbnRJZDtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnLmV2ZW50RGF0YSA9IGV2ZW50LmV2ZW50RGF0YTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9lXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkUpLFxuICAgIFwibWF0aC9waVwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5QSSksXG4gICAgXCJtYXRoL2luZlwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5JbmYpLFxuICAgIFwibWF0aC9uYW5cIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuTmFOKSxcbiAgICBcIm1hdGgvYWJzXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkFicyksXG4gICAgXCJtYXRoL3NpZ25cIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuU2lnbiksXG4gICAgXCJtYXRoL3RydW5jXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLlRydW5jKSxcbiAgICBcIm1hdGgvZmxvb3JcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuRmxvb3IpLFxuICAgIFwibWF0aC9jZWlsXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkNlaWwpLFxuICAgIFwibWF0aC9yb3VuZFwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuUm91bmRdLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7fSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiYVwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKGdsdGZCbG9jaywgZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBwYXJzZXIsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgaXQgdG8gd29yayB0aGUgd2F5IGdsVEYgc3BlY2lmaWVzXG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgPSBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgfHwge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcucm91bmRIYWxmQXdheUZyb21aZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9mcmFjdFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5GcmFjdGlvbiksXG4gICAgXCJtYXRoL25lZ1wiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5OZWdhdGlvbiksXG4gICAgXCJtYXRoL2FkZFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5BZGQsIFtcImFcIiwgXCJiXCJdLCB0cnVlKSxcbiAgICBcIm1hdGgvc3ViXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLlN1YnRyYWN0LCBbXCJhXCIsIFwiYlwiXSwgdHJ1ZSksXG4gICAgXCJtYXRoL211bFwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuTXVsdGlwbHldLFxuICAgICAgICBleHRyYVByb2Nlc3NvcihfZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBfcGFyc2VyLCBzZXJpYWxpemVkT2JqZWN0cykge1xuICAgICAgICAgICAgLy8gY29uZmlndXJlIGl0IHRvIHdvcmsgdGhlIHdheSBnbFRGIHNwZWNpZmllc1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnID0gc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnLnVzZU1hdHJpeFBlckNvbXBvbmVudCA9IHRydWU7XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcucHJldmVudEludGVnZXJGbG9hdEFyaXRobWV0aWMgPSB0cnVlO1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSB0eXBlIG9yIGZhbGxiYWNrIHRvIEludGVnZXJcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBnbHRmIGJsb2NrIGZvciB0aGUgaW5wdXRzLCBzZWUgaWYgdGhleSBoYXZlIGEgdHlwZVxuICAgICAgICAgICAgbGV0IHR5cGUgPSAtMTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9nbHRmQmxvY2sudmFsdWVzIHx8IHt9KS5maW5kKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChfZ2x0ZkJsb2NrLnZhbHVlcz8uW3ZhbHVlXS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IF9nbHRmQmxvY2sudmFsdWVzW3ZhbHVlXS50eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcudHlwZSA9IF9wYXJzZXIuYXJyYXlzLnR5cGVzW3R5cGVdLmZsb3dHcmFwaFR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb24oZ2x0ZkJsb2NrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdHlwZXMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBpZiAoZ2x0ZkJsb2NrLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICByZXR1cm4gVmFsaWRhdGVUeXBlcyhnbHRmQmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9kaXZcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuRGl2aWRlLCBbXCJhXCIsIFwiYlwiXSwgdHJ1ZSksXG4gICAgXCJtYXRoL3JlbVwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Nb2R1bG8sIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvbWluXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLk1pbiwgW1wiYVwiLCBcImJcIl0pLFxuICAgIFwibWF0aC9tYXhcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuTWF4LCBbXCJhXCIsIFwiYlwiXSksXG4gICAgXCJtYXRoL2NsYW1wXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkNsYW1wLCBbXCJhXCIsIFwiYlwiLCBcImNcIl0pLFxuICAgIFwibWF0aC9zYXR1cmF0ZVwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5TYXR1cmF0ZSksXG4gICAgXCJtYXRoL21peFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5NYXRoSW50ZXJwb2xhdGlvbiwgW1wiYVwiLCBcImJcIiwgXCJjXCJdKSxcbiAgICBcIm1hdGgvZXFcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuRXF1YWxpdHksIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvbHRcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuTGVzc1RoYW4sIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvbGVcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuTGVzc1RoYW5PckVxdWFsLCBbXCJhXCIsIFwiYlwiXSksXG4gICAgXCJtYXRoL2d0XCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkdyZWF0ZXJUaGFuLCBbXCJhXCIsIFwiYlwiXSksXG4gICAgXCJtYXRoL2dlXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkdyZWF0ZXJUaGFuT3JFcXVhbCwgW1wiYVwiLCBcImJcIl0pLFxuICAgIFwibWF0aC9pc25hblwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Jc05hTiksXG4gICAgXCJtYXRoL2lzaW5mXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLklzSW5maW5pdHkpLFxuICAgIFwibWF0aC9zZWxlY3RcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkNvbmRpdGlvbmFsXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHsgbmFtZTogXCJjb25kaXRpb25cIiB9LFxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSB2YWxpZGF0ZSB0aG9zZSBoYXZlIHRoZSBzYW1lIHR5cGUgaGVyZSwgb3IgYXNzdW1lIGl0IGlzIGFscmVhZHkgdmFsaWRhdGVkP1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJvblRydWVcIiB9LFxuICAgICAgICAgICAgICAgIGI6IHsgbmFtZTogXCJvbkZhbHNlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwib3V0cHV0XCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvcmFuZG9tXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5SYW5kb21dLFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvc2luXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLlNpbiksXG4gICAgXCJtYXRoL2Nvc1wiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Db3MpLFxuICAgIFwibWF0aC90YW5cIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuVGFuKSxcbiAgICBcIm1hdGgvYXNpblwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Bc2luKSxcbiAgICBcIm1hdGgvYWNvc1wiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5BY29zKSxcbiAgICBcIm1hdGgvYXRhblwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5BdGFuKSxcbiAgICBcIm1hdGgvYXRhbjJcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuQXRhbjIsIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvc2luaFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5TaW5oKSxcbiAgICBcIm1hdGgvY29zaFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Db3NoKSxcbiAgICBcIm1hdGgvdGFuaFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5UYW5oKSxcbiAgICBcIm1hdGgvYXNpbmhcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuQXNpbmgpLFxuICAgIFwibWF0aC9hY29zaFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5BY29zaCksXG4gICAgXCJtYXRoL2F0YW5oXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkF0YW5oKSxcbiAgICBcIm1hdGgvZXhwXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkV4cG9uZW50aWFsKSxcbiAgICBcIm1hdGgvbG9nXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkxvZyksXG4gICAgXCJtYXRoL2xvZzJcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuTG9nMiksXG4gICAgXCJtYXRoL2xvZzEwXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkxvZzEwKSxcbiAgICBcIm1hdGgvc3FydFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5TcXVhcmVSb290KSxcbiAgICBcIm1hdGgvY2JydFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5DdWJlUm9vdCksXG4gICAgXCJtYXRoL3Bvd1wiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Qb3dlciwgW1wiYVwiLCBcImJcIl0pLFxuICAgIFwibWF0aC9sZW5ndGhcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuTGVuZ3RoKSxcbiAgICBcIm1hdGgvbm9ybWFsaXplXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLk5vcm1hbGl6ZSksXG4gICAgXCJtYXRoL2RvdFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Eb3QsIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvY3Jvc3NcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuQ3Jvc3MsIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvcm90YXRlMkRcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuUm90YXRlMkQsIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvcm90YXRlM0RcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuUm90YXRlM0QsIFtcImFcIiwgXCJiXCJdKSxcbiAgICBcIm1hdGgvdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgLy8gZ2xURiB0cmFuc2Zvcm0gaXMgdmVjdG9yTiB3aXRoIG1hdHJpeE5cbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5UcmFuc2Zvcm1WZWN0b3JdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJhXCIgfSxcbiAgICAgICAgICAgICAgICBiOiB7IG5hbWU6IFwiYlwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvY29tYmluZTJcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkNvbWJpbmVWZWN0b3IyXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiaW5wdXRfMFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGI6IHsgbmFtZTogXCJpbnB1dF8xXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvY29tYmluZTNcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkNvbWJpbmVWZWN0b3IzXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiaW5wdXRfMFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGI6IHsgbmFtZTogXCJpbnB1dF8xXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgYzogeyBuYW1lOiBcImlucHV0XzJcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwidmFsdWVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9jb21iaW5lNFwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZVZlY3RvcjRdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJpbnB1dF8wXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgYjogeyBuYW1lOiBcImlucHV0XzFcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBjOiB7IG5hbWU6IFwiaW5wdXRfMlwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGQ6IHsgbmFtZTogXCJpbnB1dF8zXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBvbmUgaW5wdXQsIE4gb3V0cHV0cyEgb3V0cHV0cyBuYW1lZCB1c2luZyBudW1iZXJzLlxuICAgIFwibWF0aC9leHRyYWN0MlwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuRXh0cmFjdFZlY3RvcjJdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJpbnB1dFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgXCIwXCI6IHsgbmFtZTogXCJvdXRwdXRfMFwiIH0sXG4gICAgICAgICAgICAgICAgXCIxXCI6IHsgbmFtZTogXCJvdXRwdXRfMVwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJtYXRoL2V4dHJhY3QzXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5FeHRyYWN0VmVjdG9yM10sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgYTogeyBuYW1lOiBcImlucHV0XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBcIjBcIjogeyBuYW1lOiBcIm91dHB1dF8wXCIgfSxcbiAgICAgICAgICAgICAgICBcIjFcIjogeyBuYW1lOiBcIm91dHB1dF8xXCIgfSxcbiAgICAgICAgICAgICAgICBcIjJcIjogeyBuYW1lOiBcIm91dHB1dF8yXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvZXh0cmFjdDRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkV4dHJhY3RWZWN0b3I0XSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiaW5wdXRcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIFwiMFwiOiB7IG5hbWU6IFwib3V0cHV0XzBcIiB9LFxuICAgICAgICAgICAgICAgIFwiMVwiOiB7IG5hbWU6IFwib3V0cHV0XzFcIiB9LFxuICAgICAgICAgICAgICAgIFwiMlwiOiB7IG5hbWU6IFwib3V0cHV0XzJcIiB9LFxuICAgICAgICAgICAgICAgIFwiM1wiOiB7IG5hbWU6IFwib3V0cHV0XzNcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC90cmFuc3Bvc2VcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuVHJhbnNwb3NlKSxcbiAgICBcIm1hdGgvZGV0ZXJtaW5hbnRcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuRGV0ZXJtaW5hbnQpLFxuICAgIFwibWF0aC9pbnZlcnNlXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkludmVydE1hdHJpeCksXG4gICAgXCJtYXRoL21hdG11bFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5NYXRyaXhNdWx0aXBsaWNhdGlvbiwgW1wiYVwiLCBcImJcIl0pLFxuICAgIFwibWF0aC9tYXRDb21wb3NlXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5NYXRyaXhDb21wb3NlXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbjogeyBuYW1lOiBcInBvc2l0aW9uXCIsIGdsdGZUeXBlOiBcImZsb2F0M1wiIH0sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHsgbmFtZTogXCJyb3RhdGlvblF1YXRlcm5pb25cIiwgZ2x0ZlR5cGU6IFwiZmxvYXQ0XCIgfSxcbiAgICAgICAgICAgICAgICBzY2FsZTogeyBuYW1lOiBcInNjYWxpbmdcIiwgZ2x0ZlR5cGU6IFwiZmxvYXQzXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwidmFsdWVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoX2dsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgX3BhcnNlciwgc2VyaWFsaXplZE9iamVjdHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBpdCB0byB3b3JrIHRoZSB3YXkgZ2xURiBzcGVjaWZpZXNcbiAgICAgICAgICAgIGNvbnN0IGQgPSBzZXJpYWxpemVkT2JqZWN0c1swXS5kYXRhSW5wdXRzLmZpbmQoKGlucHV0KSA9PiBpbnB1dC5uYW1lID09PSBcInJvdGF0aW9uUXVhdGVybmlvblwiKTtcbiAgICAgICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvdGF0aW9uIHF1YXRlcm5pb24gaW5wdXQgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgZGVmaW5lZCwgc2V0IHRoZSB0eXBlIHRvIHF1YXRlcm5pb25cbiAgICAgICAgICAgIGlmIChjb250ZXh0Ll9jb25uZWN0aW9uVmFsdWVzW2QudW5pcXVlSWRdKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5fY29ubmVjdGlvblZhbHVlc1tkLnVuaXF1ZUlkXS50eXBlID0gRmxvd0dyYXBoVHlwZXMuUXVhdGVybmlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9tYXREZWNvbXBvc2VcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLk1hdHJpeERlY29tcG9zZV0sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgYTogeyBuYW1lOiBcImlucHV0XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbjogeyBuYW1lOiBcInBvc2l0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogeyBuYW1lOiBcInJvdGF0aW9uUXVhdGVybmlvblwiIH0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgbmFtZTogXCJzY2FsaW5nXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvY29tYmluZTJ4MlwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZU1hdHJpeDJEXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiaW5wdXRfMFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGI6IHsgbmFtZTogXCJpbnB1dF8xXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgYzogeyBuYW1lOiBcImlucHV0XzJcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBkOiB7IG5hbWU6IFwiaW5wdXRfM1wiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHsgbmFtZTogXCJ2YWx1ZVwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBleHRyYVByb2Nlc3NvcihfZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBfcGFyc2VyLCBzZXJpYWxpemVkT2JqZWN0cykge1xuICAgICAgICAgICAgLy8gY29uZmlndXJlIGl0IHRvIHdvcmsgdGhlIHdheSBnbFRGIHNwZWNpZmllc1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnID0gc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnLmlucHV0SXNDb2x1bW5NYWpvciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvZXh0cmFjdDJ4MlwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuRXh0cmFjdE1hdHJpeDJEXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiaW5wdXRcIiwgZ2x0ZlR5cGU6IFwiZmxvYXQyeDJcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgXCIwXCI6IHsgbmFtZTogXCJvdXRwdXRfMFwiIH0sXG4gICAgICAgICAgICAgICAgXCIxXCI6IHsgbmFtZTogXCJvdXRwdXRfMVwiIH0sXG4gICAgICAgICAgICAgICAgXCIyXCI6IHsgbmFtZTogXCJvdXRwdXRfMlwiIH0sXG4gICAgICAgICAgICAgICAgXCIzXCI6IHsgbmFtZTogXCJvdXRwdXRfM1wiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJtYXRoL2NvbWJpbmUzeDNcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkNvbWJpbmVNYXRyaXgzRF0sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgYTogeyBuYW1lOiBcImlucHV0XzBcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBiOiB7IG5hbWU6IFwiaW5wdXRfMVwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGM6IHsgbmFtZTogXCJpbnB1dF8yXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgZDogeyBuYW1lOiBcImlucHV0XzNcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBlOiB7IG5hbWU6IFwiaW5wdXRfNFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGY6IHsgbmFtZTogXCJpbnB1dF81XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgZzogeyBuYW1lOiBcImlucHV0XzZcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBoOiB7IG5hbWU6IFwiaW5wdXRfN1wiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGk6IHsgbmFtZTogXCJpbnB1dF84XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKF9nbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9wYXJzZXIsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgaXQgdG8gd29yayB0aGUgd2F5IGdsVEYgc3BlY2lmaWVzXG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgPSBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgfHwge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcuaW5wdXRJc0NvbHVtbk1ham9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9leHRyYWN0M3gzXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5FeHRyYWN0TWF0cml4M0RdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJpbnB1dFwiLCBnbHRmVHlwZTogXCJmbG9hdDN4M1wiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBcIjBcIjogeyBuYW1lOiBcIm91dHB1dF8wXCIgfSxcbiAgICAgICAgICAgICAgICBcIjFcIjogeyBuYW1lOiBcIm91dHB1dF8xXCIgfSxcbiAgICAgICAgICAgICAgICBcIjJcIjogeyBuYW1lOiBcIm91dHB1dF8yXCIgfSxcbiAgICAgICAgICAgICAgICBcIjNcIjogeyBuYW1lOiBcIm91dHB1dF8zXCIgfSxcbiAgICAgICAgICAgICAgICBcIjRcIjogeyBuYW1lOiBcIm91dHB1dF80XCIgfSxcbiAgICAgICAgICAgICAgICBcIjVcIjogeyBuYW1lOiBcIm91dHB1dF81XCIgfSxcbiAgICAgICAgICAgICAgICBcIjZcIjogeyBuYW1lOiBcIm91dHB1dF82XCIgfSxcbiAgICAgICAgICAgICAgICBcIjdcIjogeyBuYW1lOiBcIm91dHB1dF83XCIgfSxcbiAgICAgICAgICAgICAgICBcIjhcIjogeyBuYW1lOiBcIm91dHB1dF84XCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvY29tYmluZTR4NFwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZU1hdHJpeF0sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgYTogeyBuYW1lOiBcImlucHV0XzBcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBiOiB7IG5hbWU6IFwiaW5wdXRfMVwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGM6IHsgbmFtZTogXCJpbnB1dF8yXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgZDogeyBuYW1lOiBcImlucHV0XzNcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBlOiB7IG5hbWU6IFwiaW5wdXRfNFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGY6IHsgbmFtZTogXCJpbnB1dF81XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgZzogeyBuYW1lOiBcImlucHV0XzZcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBoOiB7IG5hbWU6IFwiaW5wdXRfN1wiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGk6IHsgbmFtZTogXCJpbnB1dF84XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgICAgICAgICAgajogeyBuYW1lOiBcImlucHV0XzlcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBrOiB7IG5hbWU6IFwiaW5wdXRfMTBcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBsOiB7IG5hbWU6IFwiaW5wdXRfMTFcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBtOiB7IG5hbWU6IFwiaW5wdXRfMTJcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBuOiB7IG5hbWU6IFwiaW5wdXRfMTNcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBvOiB7IG5hbWU6IFwiaW5wdXRfMTRcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICBwOiB7IG5hbWU6IFwiaW5wdXRfMTVcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwidmFsdWVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoX2dsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgX3BhcnNlciwgc2VyaWFsaXplZE9iamVjdHMpIHtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBpdCB0byB3b3JrIHRoZSB3YXkgZ2xURiBzcGVjaWZpZXNcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZyA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZy5pbnB1dElzQ29sdW1uTWFqb3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRPYmplY3RzO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJtYXRoL2V4dHJhY3Q0eDRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkV4dHJhY3RNYXRyaXhdLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7fSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhOiB7IG5hbWU6IFwiaW5wdXRcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIFwiMFwiOiB7IG5hbWU6IFwib3V0cHV0XzBcIiB9LFxuICAgICAgICAgICAgICAgIFwiMVwiOiB7IG5hbWU6IFwib3V0cHV0XzFcIiB9LFxuICAgICAgICAgICAgICAgIFwiMlwiOiB7IG5hbWU6IFwib3V0cHV0XzJcIiB9LFxuICAgICAgICAgICAgICAgIFwiM1wiOiB7IG5hbWU6IFwib3V0cHV0XzNcIiB9LFxuICAgICAgICAgICAgICAgIFwiNFwiOiB7IG5hbWU6IFwib3V0cHV0XzRcIiB9LFxuICAgICAgICAgICAgICAgIFwiNVwiOiB7IG5hbWU6IFwib3V0cHV0XzVcIiB9LFxuICAgICAgICAgICAgICAgIFwiNlwiOiB7IG5hbWU6IFwib3V0cHV0XzZcIiB9LFxuICAgICAgICAgICAgICAgIFwiN1wiOiB7IG5hbWU6IFwib3V0cHV0XzdcIiB9LFxuICAgICAgICAgICAgICAgIFwiOFwiOiB7IG5hbWU6IFwib3V0cHV0XzhcIiB9LFxuICAgICAgICAgICAgICAgIFwiOVwiOiB7IG5hbWU6IFwib3V0cHV0XzlcIiB9LFxuICAgICAgICAgICAgICAgIFwiMTBcIjogeyBuYW1lOiBcIm91dHB1dF8xMFwiIH0sXG4gICAgICAgICAgICAgICAgXCIxMVwiOiB7IG5hbWU6IFwib3V0cHV0XzExXCIgfSxcbiAgICAgICAgICAgICAgICBcIjEyXCI6IHsgbmFtZTogXCJvdXRwdXRfMTJcIiB9LFxuICAgICAgICAgICAgICAgIFwiMTNcIjogeyBuYW1lOiBcIm91dHB1dF8xM1wiIH0sXG4gICAgICAgICAgICAgICAgXCIxNFwiOiB7IG5hbWU6IFwib3V0cHV0XzE0XCIgfSxcbiAgICAgICAgICAgICAgICBcIjE1XCI6IHsgbmFtZTogXCJvdXRwdXRfMTVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9jb21wb3NlXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5NYXRyaXhDb21wb3NlXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjoge30sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb246IHsgbmFtZTogXCJwb3NpdGlvblwiLCBnbHRmVHlwZTogXCJmbG9hdDNcIiB9LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB7IG5hbWU6IFwicm90YXRpb25RdWF0ZXJuaW9uXCIsIGdsdGZUeXBlOiBcImZsb2F0NFwiIH0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgbmFtZTogXCJzY2FsaW5nXCIsIGdsdGZUeXBlOiBcImZsb2F0M1wiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcIm91dHB1dFwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJtYXRoL2RlY29tcG9zZVwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuTWF0cml4RGVjb21wb3NlXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjoge30sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgYTogeyBuYW1lOiBcImlucHV0XCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uOiB7IG5hbWU6IFwicG9zaXRpb25cIiB9LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB7IG5hbWU6IFwicm90YXRpb25RdWF0ZXJuaW9uXCIgfSxcbiAgICAgICAgICAgICAgICBzY2FsZTogeyBuYW1lOiBcInNjYWxpbmdcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9ub3RcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VOb3RdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJhXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwidmFsdWVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoX2dsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgX3BhcnNlciwgc2VyaWFsaXplZE9iamVjdHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBpdCB0byB3b3JrIHRoZSB3YXkgZ2xURiBzcGVjaWZpZXNcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZyA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIC8vIHRyeSB0byBpbmZlciB0aGUgdHlwZSBvciBmYWxsYmFjayB0byBJbnRlZ2VyXG4gICAgICAgICAgICBjb25zdCBzb2NrZXRJbiA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdLmRhdGFJbnB1dHNbMF07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcudmFsdWVUeXBlID0gY29udGV4dC5fY29ubmVjdGlvblZhbHVlc1tzb2NrZXRJbi51bmlxdWVJZF0/LnR5cGUgPz8gRmxvd0dyYXBoVHlwZXMuSW50ZWdlcjtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC9hbmRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VBbmRdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJhXCIgfSxcbiAgICAgICAgICAgICAgICBiOiB7IG5hbWU6IFwiYlwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKF9nbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9wYXJzZXIsIHNlcmlhbGl6ZWRPYmplY3RzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgaXQgdG8gd29yayB0aGUgd2F5IGdsVEYgc3BlY2lmaWVzXG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgPSBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgfHwge307XG4gICAgICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIHR5cGUgb3IgZmFsbGJhY2sgdG8gSW50ZWdlclxuICAgICAgICAgICAgY29uc3Qgc29ja2V0SW5BID0gc2VyaWFsaXplZE9iamVjdHNbMF0uZGF0YUlucHV0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldEluQiA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdLmRhdGFJbnB1dHNbMV07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcudmFsdWVUeXBlID1cbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9jb25uZWN0aW9uVmFsdWVzW3NvY2tldEluQS51bmlxdWVJZF0/LnR5cGUgPz8gY29udGV4dC5fY29ubmVjdGlvblZhbHVlc1tzb2NrZXRJbkIudW5pcXVlSWRdPy50eXBlID8/IEZsb3dHcmFwaFR5cGVzLkludGVnZXI7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvb3JcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VPcl0sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgYTogeyBuYW1lOiBcImFcIiB9LFxuICAgICAgICAgICAgICAgIGI6IHsgbmFtZTogXCJiXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwidmFsdWVcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoX2dsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgX3BhcnNlciwgc2VyaWFsaXplZE9iamVjdHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBpdCB0byB3b3JrIHRoZSB3YXkgZ2xURiBzcGVjaWZpZXNcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZyA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIC8vIHRyeSB0byBpbmZlciB0aGUgdHlwZSBvciBmYWxsYmFjayB0byBJbnRlZ2VyXG4gICAgICAgICAgICBjb25zdCBzb2NrZXRJbkEgPSBzZXJpYWxpemVkT2JqZWN0c1swXS5kYXRhSW5wdXRzWzBdO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0SW5CID0gc2VyaWFsaXplZE9iamVjdHNbMF0uZGF0YUlucHV0c1sxXTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZy52YWx1ZVR5cGUgPVxuICAgICAgICAgICAgICAgIGNvbnRleHQuX2Nvbm5lY3Rpb25WYWx1ZXNbc29ja2V0SW5BLnVuaXF1ZUlkXT8udHlwZSA/PyBjb250ZXh0Ll9jb25uZWN0aW9uVmFsdWVzW3NvY2tldEluQi51bmlxdWVJZF0/LnR5cGUgPz8gRmxvd0dyYXBoVHlwZXMuSW50ZWdlcjtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibWF0aC94b3JcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VYb3JdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGE6IHsgbmFtZTogXCJhXCIgfSxcbiAgICAgICAgICAgICAgICBiOiB7IG5hbWU6IFwiYlwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKF9nbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9wYXJzZXIsIHNlcmlhbGl6ZWRPYmplY3RzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgaXQgdG8gd29yayB0aGUgd2F5IGdsVEYgc3BlY2lmaWVzXG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgPSBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcgfHwge307XG4gICAgICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIHR5cGUgb3IgZmFsbGJhY2sgdG8gSW50ZWdlclxuICAgICAgICAgICAgY29uc3Qgc29ja2V0SW5BID0gc2VyaWFsaXplZE9iamVjdHNbMF0uZGF0YUlucHV0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldEluQiA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdLmRhdGFJbnB1dHNbMV07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0c1swXS5jb25maWcudmFsdWVUeXBlID1cbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9jb25uZWN0aW9uVmFsdWVzW3NvY2tldEluQS51bmlxdWVJZF0/LnR5cGUgPz8gY29udGV4dC5fY29ubmVjdGlvblZhbHVlc1tzb2NrZXRJbkIudW5pcXVlSWRdPy50eXBlID8/IEZsb3dHcmFwaFR5cGVzLkludGVnZXI7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvYXNyXCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VSaWdodFNoaWZ0LCBbXCJhXCIsIFwiYlwiXSksXG4gICAgXCJtYXRoL2xzbFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5CaXR3aXNlTGVmdFNoaWZ0LCBbXCJhXCIsIFwiYlwiXSksXG4gICAgXCJtYXRoL2NselwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5MZWFkaW5nWmVyb3MpLFxuICAgIFwibWF0aC9jdHpcIjogZ2V0U2ltcGxlSW5wdXRNYXBwaW5nKEZsb3dHcmFwaEJsb2NrTmFtZXMuVHJhaWxpbmdaZXJvcyksXG4gICAgXCJtYXRoL3BvcGNudFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5PbmVCaXRzQ291bnRlciksXG4gICAgXCJtYXRoL3JhZFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5EZWdUb1JhZCksXG4gICAgXCJtYXRoL2RlZ1wiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5SYWRUb0RlZyksXG4gICAgXCJ0eXBlL2Jvb2xUb0ludFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Cb29sZWFuVG9JbnQpLFxuICAgIFwidHlwZS9ib29sVG9GbG9hdFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5Cb29sZWFuVG9GbG9hdCksXG4gICAgXCJ0eXBlL2ludFRvQm9vbFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5JbnRUb0Jvb2xlYW4pLFxuICAgIFwidHlwZS9pbnRUb0Zsb2F0XCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkludFRvRmxvYXQpLFxuICAgIFwidHlwZS9mbG9hdFRvSW50XCI6IGdldFNpbXBsZUlucHV0TWFwcGluZyhGbG93R3JhcGhCbG9ja05hbWVzLkZsb2F0VG9JbnQpLFxuICAgIFwidHlwZS9mbG9hdFRvQm9vbFwiOiBnZXRTaW1wbGVJbnB1dE1hcHBpbmcoRmxvd0dyYXBoQmxvY2tOYW1lcy5GbG9hdFRvQm9vbGVhbiksXG5cbiAgICAvLyBmbG93c1xuICAgIFwiZmxvdy9zZXF1ZW5jZVwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuU2VxdWVuY2VdLFxuICAgICAgICBleHRyYVByb2Nlc3NvcihnbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9hcnJheXMsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkT2JqZWN0ID0gc2VyaWFsaXplZE9iamVjdHNbMF07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5vdXRwdXRTaWduYWxDb3VudCA9IE9iamVjdC5rZXlzKGdsdGZCbG9jay5mbG93cyB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5zaWduYWxPdXRwdXRzLmZvckVhY2goKG91dHB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmFtZSA9IFwib3V0X1wiICsgaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiZmxvdy9icmFuY2hcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkJyYW5jaF0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgdHJ1ZTogeyBuYW1lOiBcIm9uVHJ1ZVwiIH0sXG4gICAgICAgICAgICAgICAgZmFsc2U6IHsgbmFtZTogXCJvbkZhbHNlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImZsb3cvc3dpdGNoXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5Td2l0Y2hdLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICBjYXNlczogeyBuYW1lOiBcImNhc2VzXCIsIGluT3B0aW9uczogdHJ1ZSwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogeyBuYW1lOiBcImNhc2VcIiB9LFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHsgbmFtZTogXCJkZWZhdWx0XCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb24oZ2x0ZkJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24gJiYgZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24uY2FzZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXNlcyA9IGdsdGZCbG9jay5jb25maWd1cmF0aW9uLmNhc2VzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ubHlJbnRlZ2VycyA9IGNhc2VzLmV2ZXJ5KChjYXNlVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSB2YWx1ZSBzaG91bGQgYmUgYW4gaW50ZWdlci4gU2luY2UgTnVtYmVyLmlzSW50ZWdlcigxLjApIGlzIHRydWUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdG9TdHJpbmcgaGFzIG9ubHkgZGlnaXRzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGNhc2VWYWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAvXi0/XFxkKyQvLnRlc3QoY2FzZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghb25seUludGVnZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKFwiU3dpdGNoIGNhc2VzIHNob3VsZCBiZSBpbnRlZ2Vycy4gVXNpbmcgZW1wdHkgYXJyYXkgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGdsdGZCbG9jay5jb25maWd1cmF0aW9uLmNhc2VzLnZhbHVlID0gW10gYXMgbnVtYmVyW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlQ2FzZXMgPSBuZXcgU2V0KGNhc2VzKTtcbiAgICAgICAgICAgICAgICBnbHRmQmxvY2suY29uZmlndXJhdGlvbi5jYXNlcy52YWx1ZSA9IEFycmF5LmZyb20odW5pcXVlQ2FzZXMpIGFzIG51bWJlcltdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoZ2x0ZkJsb2NrLCBkZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9hcnJheXMsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGFsbCBuYW1lcyBvZiBvdXRwdXQgZmxvdyB0byBvdXRfJDEgYXBhcnQgZnJvbSBcImRlZmF1bHRcIlxuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLm9wICE9PSBcImZsb3cvc3dpdGNoXCIgfHwgIWdsdGZCbG9jay5mbG93cyB8fCBPYmplY3Qua2V5cyhnbHRmQmxvY2suZmxvd3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN3aXRjaCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBjb25maWd1cmF0aW9uIG9iamVjdCwgdGhlIGNhc2VzIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdO1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5zaWduYWxPdXRwdXRzLmZvckVhY2goKG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubmFtZSAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5hbWUgPSBcIm91dF9cIiArIG91dHB1dC5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRPYmplY3RzO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJmbG93L3doaWxlXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5XaGlsZUxvb3BdLFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgICAgIGxvb3BCb2R5OiB7IG5hbWU6IFwiZXhlY3V0aW9uRmxvd1wiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJmbG93L2ZvclwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuRm9yTG9vcF0sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIGluaXRpYWxJbmRleDogeyBuYW1lOiBcImluaXRpYWxJbmRleFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiwgaW5PcHRpb25zOiB0cnVlLCBkZWZhdWx0VmFsdWU6IDAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiB7IG5hbWU6IFwic3RhcnRJbmRleFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIGVuZEluZGV4OiB7IG5hbWU6IFwiZW5kSW5kZXhcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGluZGV4OiB7IG5hbWU6IFwiaW5kZXhcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgbG9vcEJvZHk6IHsgbmFtZTogXCJleGVjdXRpb25GbG93XCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKF9nbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9hcnJheXMsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkT2JqZWN0ID0gc2VyaWFsaXplZE9iamVjdHNbMF07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5pbmNyZW1lbnRJbmRleFdoZW5Mb29wRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImZsb3cvZG9OXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5Eb05dLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7fSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBuOiB7IG5hbWU6IFwibWF4RXhlY3V0aW9uc1wiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvdW50OiB7IG5hbWU6IFwiZXhlY3V0aW9uQ291bnRcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiZmxvdy9tdWx0aUdhdGVcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLk11bHRpR2F0ZV0sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIGlzUmFuZG9tOiB7IG5hbWU6IFwiaXNSYW5kb21cIiwgZ2x0ZlR5cGU6IFwiYm9vbGVhblwiLCBpbk9wdGlvbnM6IHRydWUsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIGlzTG9vcDogeyBuYW1lOiBcImlzTG9vcFwiLCBnbHRmVHlwZTogXCJib29sZWFuXCIsIGluT3B0aW9uczogdHJ1ZSwgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICB9LFxuICAgICAgICBleHRyYVByb2Nlc3NvcihnbHRmQmxvY2ssIGRlY2xhcmF0aW9uLCBfbWFwcGluZywgX2FycmF5cywgc2VyaWFsaXplZE9iamVjdHMpIHtcbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5vcCAhPT0gXCJmbG93L211bHRpR2F0ZVwiIHx8ICFnbHRmQmxvY2suZmxvd3MgfHwgT2JqZWN0LmtleXMoZ2x0ZkJsb2NrLmZsb3dzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aUdhdGUgc2hvdWxkIGhhdmUgYSBzaW5nbGUgY29uZmlndXJhdGlvbiBvYmplY3QsIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGZsb3dzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdO1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcgfHw9IHt9O1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcub3V0cHV0U2lnbmFsQ291bnQgPSBPYmplY3Qua2V5cyhnbHRmQmxvY2suZmxvd3MpLmxlbmd0aDtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3Quc2lnbmFsT3V0cHV0cy5mb3JFYWNoKChvdXRwdXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5hbWUgPSBcIm91dF9cIiArIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImZsb3cvd2FpdEFsbFwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuV2FpdEFsbF0sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIGlucHV0Rmxvd3M6IHsgbmFtZTogXCJpbnB1dFNpZ25hbENvdW50XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiLCBpbk9wdGlvbnM6IHRydWUsIGRlZmF1bHRWYWx1ZTogMCB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgcmVzZXQ6IHsgbmFtZTogXCJyZXNldFwiIH0sXG4gICAgICAgICAgICAgICAgXCJbc2VnbWVudF1cIjogeyBuYW1lOiBcImluXyQxXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb24oZ2x0ZkJsb2NrKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBjb25maWd1cmF0aW9uIHZhbHVlIGlzIGFuIGludGVnZXJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24/LmlucHV0Rmxvd3M/LnZhbHVlWzBdICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24gPSBnbHRmQmxvY2suY29uZmlndXJhdGlvbiB8fCB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Rmxvd3M6IHsgdmFsdWU6IFswXSB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24uaW5wdXRGbG93cy52YWx1ZSA9IFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImZsb3cvdGhyb3R0bGVcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLlRocm90dGxlXSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgZmxvd3M6IHtcbiAgICAgICAgICAgICAgICBlcnI6IHsgbmFtZTogXCJlcnJvclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJmbG93L3NldERlbGF5XCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5TZXREZWxheV0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgZXJyOiB7IG5hbWU6IFwiZXJyb3JcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiZmxvdy9jYW5jZWxEZWxheVwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuQ2FuY2VsRGVsYXldLFxuICAgIH0sXG4gICAgXCJ2YXJpYWJsZS9nZXRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkdldFZhcmlhYmxlXSxcbiAgICAgICAgdmFsaWRhdGlvbihnbHRmQmxvY2spIHtcbiAgICAgICAgICAgIGlmICghZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24/LnZhcmlhYmxlPy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIlZhcmlhYmxlIGdldCBibG9jayBzaG91bGQgaGF2ZSBhIHZhcmlhYmxlIGNvbmZpZ3VyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJWYXJpYWJsZSBnZXQgYmxvY2sgc2hvdWxkIGhhdmUgYSB2YXJpYWJsZSBjb25maWd1cmF0aW9uXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIHZhcmlhYmxlOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgIGdsdGZUeXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGZsb3dHcmFwaFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaW5PcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YVRyYW5zZm9ybWVyKGluZGV4LCBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXJzZXIuZ2V0VmFyaWFibGVOYW1lKGluZGV4WzBdKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcInZhcmlhYmxlL3NldFwiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuU2V0VmFyaWFibGVdLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICB2YXJpYWJsZToge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICBnbHRmVHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBmbG93R3JhcGhUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGluT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zvcm1lcihpbmRleDogbnVtYmVyW10sIHBhcnNlcik6IHN0cmluZ1tdIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXJzZXIuZ2V0VmFyaWFibGVOYW1lKGluZGV4WzBdKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcInZhcmlhYmxlL3NldE11bHRpcGxlXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5TZXRWYXJpYWJsZV0sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidmFyaWFibGVzXCIsXG4gICAgICAgICAgICAgICAgZ2x0ZlR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgZmxvd0dyYXBoVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpbk9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YVRyYW5zZm9ybWVyKGluZGV4OiBudW1iZXJbXVtdLCBwYXJzZXIpOiBzdHJpbmdbXVtdIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpbmRleFswXS5tYXAoKGkpID0+IHBhcnNlci5nZXRWYXJpYWJsZU5hbWUoaSkpXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoX2dsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgcGFyc2VyLCBzZXJpYWxpemVkT2JqZWN0cykge1xuICAgICAgICAgICAgLy8gdmFyaWFibGUvZ2V0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRHZXRWYXJpYWJsZSA9IHNlcmlhbGl6ZWRPYmplY3RzWzBdO1xuICAgICAgICAgICAgc2VyaWFsaXplZEdldFZhcmlhYmxlLmRhdGFJbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5uYW1lID0gcGFyc2VyLmdldFZhcmlhYmxlTmFtZSgraW5wdXQubmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRPYmplY3RzO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJ2YXJpYWJsZS9pbnRlcnBvbGF0ZVwiOiB7XG4gICAgICAgIGJsb2NrczogW1xuICAgICAgICAgICAgRmxvd0dyYXBoQmxvY2tOYW1lcy5WYWx1ZUludGVycG9sYXRpb24sXG4gICAgICAgICAgICBGbG93R3JhcGhCbG9ja05hbWVzLkNvbnRleHQsXG4gICAgICAgICAgICBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb24sXG4gICAgICAgICAgICBGbG93R3JhcGhCbG9ja05hbWVzLkJlemllckN1cnZlRWFzaW5nLFxuICAgICAgICAgICAgRmxvd0dyYXBoQmxvY2tOYW1lcy5HZXRWYXJpYWJsZSxcbiAgICAgICAgXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgdmFyaWFibGU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgIGluT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zvcm1lcihpbmRleCwgcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VyLmdldFZhcmlhYmxlTmFtZShpbmRleFswXSldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlU2xlcnA6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFuaW1hdGlvblR5cGVcIixcbiAgICAgICAgICAgICAgICBpbk9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmb3JtZXI6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbRmxvd0dyYXBoVHlwZXMuUXVhdGVybmlvbl07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXzFcIiB9LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IG5hbWU6IFwiZHVyYXRpb25fMVwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIHAxOiB7IG5hbWU6IFwiY29udHJvbFBvaW50MVwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLkJlemllckN1cnZlRWFzaW5nIH0sXG4gICAgICAgICAgICAgICAgcDI6IHsgbmFtZTogXCJjb250cm9sUG9pbnQyXCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuQmV6aWVyQ3VydmVFYXNpbmcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgICAgIGluOiB7IG5hbWU6IFwiaW5cIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5QbGF5QW5pbWF0aW9uIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgICAgIGVycjogeyBuYW1lOiBcImVycm9yXCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuUGxheUFuaW1hdGlvbiB9LFxuICAgICAgICAgICAgICAgIG91dDogeyBuYW1lOiBcIm91dFwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb24gfSxcbiAgICAgICAgICAgICAgICBkb25lOiB7IG5hbWU6IFwiZG9uZVwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb24gfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGludGVyQmxvY2tDb25uZWN0b3JzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcInVzZXJWYXJpYWJsZXNcIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDIsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJhbmltYXRpb25cIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwiYW5pbWF0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAyLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IFwiZWFzaW5nRnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwiZWFzaW5nRnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMyxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJ2YWx1ZV8wXCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDQsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKGdsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgcGFyc2VyLCBzZXJpYWxpemVkT2JqZWN0cykge1xuICAgICAgICAgICAgLy8gaXMgdXNlU2xlcnAgaXMgdXNlZCwgYW5pbWF0aW9uVHlwZSBzaG91bGQgYmUgc2V0IHRvIGJlIHF1YXRlcm5pb24hXG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkVmFsdWVJbnRlcnBvbGF0aW9uID0gc2VyaWFsaXplZE9iamVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUluZGV4ID0gZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24/LnZhcmlhYmxlLnZhbHVlWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eUluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiVmFyaWFibGUgaW5kZXggaXMgbm90IGRlZmluZWQgZm9yIHZhcmlhYmxlIGludGVycG9sYXRpb24gYmxvY2tcIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgaW5kZXggaXMgbm90IGRlZmluZWQgZm9yIHZhcmlhYmxlIGludGVycG9sYXRpb24gYmxvY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHBhcnNlci5hcnJheXMuc3RhdGljVmFyaWFibGVzW3Byb3BlcnR5SW5kZXhdO1xuICAgICAgICAgICAgLy8gaWYgbm90IHNldCBieSB1c2VTbGVycFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkVmFsdWVJbnRlcnBvbGF0aW9uLmNvbmZpZy5hbmltYXRpb25UeXBlLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSB0eXBlXG4gICAgICAgICAgICAgICAgcGFyc2VyLmFycmF5cy5zdGF0aWNWYXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZFZhbHVlSW50ZXJwb2xhdGlvbi5jb25maWcuYW5pbWF0aW9uVHlwZS52YWx1ZSA9IGdldEFuaW1hdGlvblR5cGVCeUZsb3dHcmFwaFR5cGUodmFyaWFibGUudHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhcmlhYmxlL2dldCBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkR2V0VmFyaWFibGUgPSBzZXJpYWxpemVkT2JqZWN0c1s0XTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRHZXRWYXJpYWJsZS5jb25maWcgfHw9IHt9O1xuICAgICAgICAgICAgc2VyaWFsaXplZEdldFZhcmlhYmxlLmNvbmZpZy52YXJpYWJsZSB8fD0ge307XG4gICAgICAgICAgICBzZXJpYWxpemVkR2V0VmFyaWFibGUuY29uZmlnLnZhcmlhYmxlLnZhbHVlID0gcGFyc2VyLmdldFZhcmlhYmxlTmFtZShwcm9wZXJ0eUluZGV4KTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBjb250cm9sIHBvaW50cyBmcm9tIHRoZSBlYXNpbmcgYmxvY2tcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzNdLmNvbmZpZyB8fD0ge307XG5cbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwicG9pbnRlci9nZXRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLkdldFByb3BlcnR5LCBGbG93R3JhcGhCbG9ja05hbWVzLkpzb25Qb2ludGVyUGFyc2VyXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgcG9pbnRlcjogeyBuYW1lOiBcImpzb25Qb2ludGVyXCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuSnNvblBvaW50ZXJQYXJzZXIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBcIltzZWdtZW50XVwiOiB7IG5hbWU6IFwiJDFcIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlciB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJCbG9ja0Nvbm5lY3RvcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IFwicHJvcGVydHlOYW1lXCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcInByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcImN1c3RvbUdldEZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcImdldEZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKGdsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgcGFyc2VyLCBzZXJpYWxpemVkT2JqZWN0cykge1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdHMuZm9yRWFjaCgoc2VyaWFsaXplZE9iamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0IGlzIHRoZSBqc29uIHBvaW50ZXIgYmxvY2tcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZE9iamVjdC5jbGFzc05hbWUgPT09IEZsb3dHcmFwaEJsb2NrTmFtZXMuSnNvblBvaW50ZXJQYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcgfHw9IHt9O1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5vdXRwdXRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcInBvaW50ZXIvc2V0XCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5TZXRQcm9wZXJ0eSwgRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlcl0sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIHBvaW50ZXI6IHsgbmFtZTogXCJqc29uUG9pbnRlclwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLkpzb25Qb2ludGVyUGFyc2VyIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSBkZWZpbmVkIGR1ZSB0byB0aGUgYXJyYXkgdGFraW5nIG92ZXJcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgICAgICBcIltzZWdtZW50XVwiOiB7IG5hbWU6IFwiJDFcIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlciB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgZmxvd3M6IHtcbiAgICAgICAgICAgICAgICBlcnI6IHsgbmFtZTogXCJlcnJvclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnRlckJsb2NrQ29ubmVjdG9yczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJwcm9wZXJ0eU5hbWVcIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwicHJvcGVydHlOYW1lXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IFwiY3VzdG9tU2V0RnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwic2V0RnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBwYXJzZXIsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0cy5mb3JFYWNoKChzZXJpYWxpemVkT2JqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgdGhlIGpzb24gcG9pbnRlciBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkT2JqZWN0LmNsYXNzTmFtZSA9PT0gRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnLm91dHB1dFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwicG9pbnRlci9pbnRlcnBvbGF0ZVwiOiB7XG4gICAgICAgIC8vIGludGVycG9sYXRlLCBwYXJzZSB0aGUgcG9pbnRlciBhbmQgcGxheSB0aGUgYW5pbWF0aW9uIGdlbmVyYXRlZC4gMyBibG9ja3MhXG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuVmFsdWVJbnRlcnBvbGF0aW9uLCBGbG93R3JhcGhCbG9ja05hbWVzLkpzb25Qb2ludGVyUGFyc2VyLCBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb24sIEZsb3dHcmFwaEJsb2NrTmFtZXMuQmV6aWVyQ3VydmVFYXNpbmddLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICBwb2ludGVyOiB7IG5hbWU6IFwianNvblBvaW50ZXJcIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlciB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7IG5hbWU6IFwidmFsdWVfMVwiIH0sXG4gICAgICAgICAgICAgICAgXCJbc2VnbWVudF1cIjogeyBuYW1lOiBcIiQxXCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuSnNvblBvaW50ZXJQYXJzZXIgfSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBuYW1lOiBcImR1cmF0aW9uXzFcIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIgLyosIGluT3B0aW9uczogdHJ1ZSAqLyB9LFxuICAgICAgICAgICAgICAgIHAxOiB7IG5hbWU6IFwiY29udHJvbFBvaW50MVwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLkJlemllckN1cnZlRWFzaW5nIH0sXG4gICAgICAgICAgICAgICAgcDI6IHsgbmFtZTogXCJjb250cm9sUG9pbnQyXCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuQmV6aWVyQ3VydmVFYXNpbmcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgICAgIGluOiB7IG5hbWU6IFwiaW5cIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5QbGF5QW5pbWF0aW9uIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgICAgIGVycjogeyBuYW1lOiBcImVycm9yXCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuUGxheUFuaW1hdGlvbiB9LFxuICAgICAgICAgICAgICAgIG91dDogeyBuYW1lOiBcIm91dFwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb24gfSxcbiAgICAgICAgICAgICAgICBkb25lOiB7IG5hbWU6IFwiZG9uZVwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb24gfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGludGVyQmxvY2tDb25uZWN0b3JzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMixcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcInByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJwcm9wZXJ0eU5hbWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJjdXN0b21CdWlsZEFuaW1hdGlvblwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJnZW5lcmF0ZUFuaW1hdGlvbnNGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcImFuaW1hdGlvblwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJhbmltYXRpb25cIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDIsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJlYXNpbmdGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJlYXNpbmdGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAzLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcInZhbHVlXzBcIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBwYXJzZXIsIHNlcmlhbGl6ZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0cy5mb3JFYWNoKChzZXJpYWxpemVkT2JqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgdGhlIGpzb24gcG9pbnRlciBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkT2JqZWN0LmNsYXNzTmFtZSA9PT0gRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnLm91dHB1dFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlcmlhbGl6ZWRPYmplY3QuY2xhc3NOYW1lID09PSBGbG93R3JhcGhCbG9ja05hbWVzLlZhbHVlSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGdsdGZCbG9jay52YWx1ZXMgfHwgW10pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnbHRmQmxvY2sudmFsdWVzPy5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdmFsdWUudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnLmFuaW1hdGlvblR5cGUgPSBwYXJzZXIuYXJyYXlzLnR5cGVzW3R5cGVdLmZsb3dHcmFwaFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiYW5pbWF0aW9uL3N0YXJ0XCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5QbGF5QW5pbWF0aW9uLCBGbG93R3JhcGhCbG9ja05hbWVzLkFycmF5SW5kZXgsIFwiS0hSX2ludGVyYWN0aXZpdHkvRmxvd0dyYXBoR0xURkRhdGFQcm92aWRlclwiXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHsgbmFtZTogXCJpbmRleFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5BcnJheUluZGV4IH0sXG4gICAgICAgICAgICAgICAgc3BlZWQ6IHsgbmFtZTogXCJzcGVlZFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogeyBuYW1lOiBcImZyb21cIiwgZ2x0ZlR5cGU6IFwibnVtYmVyXCIsIGRhdGFUcmFuc2Zvcm1lcjogKHRpbWU6IG51bWJlcltdLCBwYXJzZXIpID0+IFt0aW1lWzBdICogcGFyc2VyLl9hbmltYXRpb25UYXJnZXRGcHNdIH0sXG4gICAgICAgICAgICAgICAgZW5kVGltZTogeyBuYW1lOiBcInRvXCIsIGdsdGZUeXBlOiBcIm51bWJlclwiLCBkYXRhVHJhbnNmb3JtZXI6ICh0aW1lOiBudW1iZXJbXSwgcGFyc2VyKSA9PiBbdGltZVswXSAqIHBhcnNlci5fYW5pbWF0aW9uVGFyZ2V0RnBzXSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgZmxvd3M6IHtcbiAgICAgICAgICAgICAgICBlcnI6IHsgbmFtZTogXCJlcnJvclwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBpbnRlckJsb2NrQ29ubmVjdG9yczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcImFuaW1hdGlvbkdyb3VwXCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFwiYW5pbWF0aW9uR3JvdXBzXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDIsXG4gICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKF9nbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9hcnJheXMsIHNlcmlhbGl6ZWRPYmplY3RzLCBfY29udGV4dCwgZ2xvYmFsR0xURikge1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBnbFRGIHRvIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBsYXN0IHNlcmlhbGl6ZWQgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkT2JqZWN0ID0gc2VyaWFsaXplZE9iamVjdHNbc2VyaWFsaXplZE9iamVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5nbFRGID0gZ2xvYmFsR0xURjtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkT2JqZWN0cztcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiYW5pbWF0aW9uL3N0b3BcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLlN0b3BBbmltYXRpb24sIEZsb3dHcmFwaEJsb2NrTmFtZXMuQXJyYXlJbmRleCwgXCJLSFJfaW50ZXJhY3Rpdml0eS9GbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyXCJdLFxuICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogeyBuYW1lOiBcImluZGV4XCIsIGdsdGZUeXBlOiBcIm51bWJlclwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLkFycmF5SW5kZXggfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgZXJyOiB7IG5hbWU6IFwiZXJyb3JcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJCbG9ja0Nvbm5lY3RvcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJhbmltYXRpb25Hcm91cFwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcImFuaW1hdGlvbkdyb3Vwc1wiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAyLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBleHRyYVByb2Nlc3NvcihfZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBfYXJyYXlzLCBzZXJpYWxpemVkT2JqZWN0cywgX2NvbnRleHQsIGdsb2JhbEdMVEYpIHtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZ2xURiB0byB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbGFzdCBzZXJpYWxpemVkIG9iamVjdFxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZWRPYmplY3RzW3NlcmlhbGl6ZWRPYmplY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcgfHw9IHt9O1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcuZ2xURiA9IGdsb2JhbEdMVEY7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImFuaW1hdGlvbi9zdG9wQXRcIjoge1xuICAgICAgICBibG9ja3M6IFtGbG93R3JhcGhCbG9ja05hbWVzLlN0b3BBbmltYXRpb24sIEZsb3dHcmFwaEJsb2NrTmFtZXMuQXJyYXlJbmRleCwgXCJLSFJfaW50ZXJhY3Rpdml0eS9GbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyXCJdLFxuICAgICAgICBjb25maWd1cmF0aW9uOiB7fSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHsgbmFtZTogXCJpbmRleFwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5BcnJheUluZGV4IH0sXG4gICAgICAgICAgICAgICAgc3RvcFRpbWU6IHsgbmFtZTogXCJzdG9wQXRGcmFtZVwiLCBnbHRmVHlwZTogXCJudW1iZXJcIiwgZGF0YVRyYW5zZm9ybWVyOiAodGltZTogbnVtYmVyW10sIHBhcnNlcikgPT4gW3RpbWVbMF0gKiBwYXJzZXIuX2FuaW1hdGlvblRhcmdldEZwc10gfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG91dHB1dHM6IHtcbiAgICAgICAgICAgIGZsb3dzOiB7XG4gICAgICAgICAgICAgICAgZXJyOiB7IG5hbWU6IFwiZXJyb3JcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJCbG9ja0Nvbm5lY3RvcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnB1dDogXCJhbmltYXRpb25Hcm91cFwiLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcImFuaW1hdGlvbkdyb3Vwc1wiLFxuICAgICAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMSxcbiAgICAgICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAyLFxuICAgICAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBleHRyYVByb2Nlc3NvcihfZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBfYXJyYXlzLCBzZXJpYWxpemVkT2JqZWN0cywgX2NvbnRleHQsIGdsb2JhbEdMVEYpIHtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZ2xURiB0byB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbGFzdCBzZXJpYWxpemVkIG9iamVjdFxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZWRPYmplY3RzW3NlcmlhbGl6ZWRPYmplY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcgfHw9IHt9O1xuICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdC5jb25maWcuZ2xURiA9IGdsb2JhbEdMVEY7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIm1hdGgvc3dpdGNoXCI6IHtcbiAgICAgICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5EYXRhU3dpdGNoXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgY2FzZXM6IHsgbmFtZTogXCJjYXNlc1wiLCBpbk9wdGlvbnM6IHRydWUsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHsgbmFtZTogXCJjYXNlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb24oZ2x0ZkJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24gJiYgZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24uY2FzZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXNlcyA9IGdsdGZCbG9jay5jb25maWd1cmF0aW9uLmNhc2VzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ubHlJbnRlZ2VycyA9IGNhc2VzLmV2ZXJ5KChjYXNlVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSB2YWx1ZSBzaG91bGQgYmUgYW4gaW50ZWdlci4gU2luY2UgTnVtYmVyLmlzSW50ZWdlcigxLjApIGlzIHRydWUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdG9TdHJpbmcgaGFzIG9ubHkgZGlnaXRzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGNhc2VWYWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAvXi0/XFxkKyQvLnRlc3QoY2FzZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghb25seUludGVnZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKFwiU3dpdGNoIGNhc2VzIHNob3VsZCBiZSBpbnRlZ2Vycy4gVXNpbmcgZW1wdHkgYXJyYXkgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGdsdGZCbG9jay5jb25maWd1cmF0aW9uLmNhc2VzLnZhbHVlID0gW10gYXMgbnVtYmVyW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlQ2FzZXMgPSBuZXcgU2V0KGNhc2VzKTtcbiAgICAgICAgICAgICAgICBnbHRmQmxvY2suY29uZmlndXJhdGlvbi5jYXNlcy52YWx1ZSA9IEFycmF5LmZyb20odW5pcXVlQ2FzZXMpIGFzIG51bWJlcltdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFQcm9jZXNzb3IoX2dsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgX2FycmF5cywgc2VyaWFsaXplZE9iamVjdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRPYmplY3QgPSBzZXJpYWxpemVkT2JqZWN0c1swXTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuZGF0YUlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5uYW1lICE9PSBcImRlZmF1bHRcIiAmJiBpbnB1dC5uYW1lICE9PSBcImNhc2VcIikge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5uYW1lID0gXCJpbl9cIiArIGlucHV0Lm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyB8fD0ge307XG4gICAgICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy50cmVhdENhc2VzQXNJbnRlZ2VycyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImRlYnVnL2xvZ1wiOiB7XG4gICAgICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuQ29uc29sZUxvZ10sXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHsgbmFtZTogXCJtZXNzYWdlVGVtcGxhdGVcIiwgaW5PcHRpb25zOiB0cnVlIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldFNpbXBsZUlucHV0TWFwcGluZyh0eXBlOiBGbG93R3JhcGhCbG9ja05hbWVzLCBpbnB1dHM6IHN0cmluZ1tdID0gW1wiYVwiXSwgaW5mZXJUeXBlPzogYm9vbGVhbik6IElHTFRGVG9GbG93R3JhcGhNYXBwaW5nIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBibG9ja3M6IFt0eXBlXSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IGlucHV0cy5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKGFjYywgaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2lucHV0XSA9IHsgbmFtZTogaW5wdXQgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHt9IGFzIHsgW2tleTogc3RyaW5nXTogeyBuYW1lOiBzdHJpbmcgfSB9XG4gICAgICAgICAgICApLFxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBuYW1lOiBcInZhbHVlXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhUHJvY2Vzc29yKGdsdGZCbG9jaywgX2RlY2xhcmF0aW9uLCBfbWFwcGluZywgX3BhcnNlciwgc2VyaWFsaXplZE9iamVjdHMpIHtcbiAgICAgICAgICAgIGlmIChpbmZlclR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25maWd1cmUgaXQgdG8gd29yayB0aGUgd2F5IGdsVEYgc3BlY2lmaWVzXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnID0gc2VyaWFsaXplZE9iamVjdHNbMF0uY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZy5wcmV2ZW50SW50ZWdlckZsb2F0QXJpdGhtZXRpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSB0eXBlIG9yIGZhbGxiYWNrIHRvIEludGVnZXJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgZ2x0ZiBibG9jayBmb3IgdGhlIGlucHV0cywgc2VlIGlmIHRoZXkgaGF2ZSBhIHR5cGVcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IC0xO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGdsdGZCbG9jay52YWx1ZXMgfHwge30pLmZpbmQoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbHRmQmxvY2sudmFsdWVzPy5bdmFsdWVdLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGdsdGZCbG9jay52YWx1ZXNbdmFsdWVdLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzBdLmNvbmZpZy50eXBlID0gX3BhcnNlci5hcnJheXMudHlwZXNbdHlwZV0uZmxvd0dyYXBoVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb24oZ2x0ZkJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHR5cGVzIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIHJldHVybiBWYWxpZGF0ZVR5cGVzKGdsdGZCbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIFZhbGlkYXRlVHlwZXMoZ2x0ZkJsb2NrOiBJS0hSSW50ZXJhY3Rpdml0eV9Ob2RlKTogeyB2YWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gICAgaWYgKGdsdGZCbG9jay52YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhnbHRmQmxvY2sudmFsdWVzKVxuICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBnbHRmQmxvY2sudmFsdWVzIVtrZXldLnR5cGUpXG4gICAgICAgICAgICAuZmlsdGVyKCh0eXBlKSA9PiB0eXBlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBhbGxTYW1lVHlwZSA9IHR5cGVzLmV2ZXJ5KCh0eXBlKSA9PiB0eXBlID09PSB0eXBlc1swXSk7XG4gICAgICAgIGlmICghYWxsU2FtZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IFwiQWxsIGlucHV0cyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGVcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxTdXBwb3J0ZWROYXRpdmVOb2RlVHlwZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhnbHRmVG9GbG93R3JhcGhNYXBwaW5nKTtcbn1cblxuLyoqXG4gKiBcbiAqIFRoZXNlIGFyZSB0aGUgbm9kZXMgZnJvbSB0aGUgc3BlY3M6XG5cbiMjIyBNYXRoIE5vZGVzXG4xLiAqKkNvbnN0YW50cyoqXG4gICAtIEUgKGBtYXRoL2VgKSBGbG93R3JhcGhCbG9ja05hbWVzLkVcbiAgIC0gUGkgKGBtYXRoL3BpYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5QSVxuICAgLSBJbmZpbml0eSAoYG1hdGgvaW5mYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5JbmZcbiAgIC0gTm90IGEgTnVtYmVyIChgbWF0aC9uYW5gKSBGbG93R3JhcGhCbG9ja05hbWVzLk5hTlxuMi4gKipBcml0aG1ldGljIE5vZGVzKipcbiAgIC0gQWJzb2x1dGUgVmFsdWUgKGBtYXRoL2Fic2ApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQWJzXG4gICAtIFNpZ24gKGBtYXRoL3NpZ25gKSBGbG93R3JhcGhCbG9ja05hbWVzLlNpZ25cbiAgIC0gVHJ1bmNhdGUgKGBtYXRoL3RydW5jYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5UcnVuY1xuICAgLSBGbG9vciAoYG1hdGgvZmxvb3JgKSBGbG93R3JhcGhCbG9ja05hbWVzLkZsb29yXG4gICAtIENlaWwgKGBtYXRoL2NlaWxgKSBGbG93R3JhcGhCbG9ja05hbWVzLkNlaWxcbiAgIC0gUm91bmQgKGBtYXRoL3JvdW5kYCkgIEZsb3dHcmFwaEJsb2NrTmFtZXMuUm91bmRcbiAgIC0gRnJhY3Rpb24gKGBtYXRoL2ZyYWN0YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5GcmFjdFxuICAgLSBOZWdhdGlvbiAoYG1hdGgvbmVnYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5OZWdhdGlvblxuICAgLSBBZGRpdGlvbiAoYG1hdGgvYWRkYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5BZGRcbiAgIC0gU3VidHJhY3Rpb24gKGBtYXRoL3N1YmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuU3VidHJhY3RcbiAgIC0gTXVsdGlwbGljYXRpb24gKGBtYXRoL211bGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuTXVsdGlwbHlcbiAgIC0gRGl2aXNpb24gKGBtYXRoL2RpdmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuRGl2aWRlXG4gICAtIFJlbWFpbmRlciAoYG1hdGgvcmVtYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5Nb2R1bG9cbiAgIC0gTWluaW11bSAoYG1hdGgvbWluYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5NaW5cbiAgIC0gTWF4aW11bSAoYG1hdGgvbWF4YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5NYXhcbiAgIC0gQ2xhbXAgKGBtYXRoL2NsYW1wYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5DbGFtcFxuICAgLSBTYXR1cmF0ZSAoYG1hdGgvc2F0dXJhdGVgKSBGbG93R3JhcGhCbG9ja05hbWVzLlNhdHVyYXRlXG4gICAtIEludGVycG9sYXRlIChgbWF0aC9taXhgKSBGbG93R3JhcGhCbG9ja05hbWVzLk1hdGhJbnRlcnBvbGF0aW9uXG4zLiAqKkNvbXBhcmlzb24gTm9kZXMqKlxuICAgLSBFcXVhbGl0eSAoYG1hdGgvZXFgKSBGbG93R3JhcGhCbG9ja05hbWVzLkVxdWFsaXR5XG4gICAtIExlc3MgVGhhbiAoYG1hdGgvbHRgKSBGbG93R3JhcGhCbG9ja05hbWVzLkxlc3NUaGFuXG4gICAtIExlc3MgVGhhbiBPciBFcXVhbCBUbyAoYG1hdGgvbGVgKSBGbG93R3JhcGhCbG9ja05hbWVzLkxlc3NUaGFuT3JFcXVhbFxuICAgLSBHcmVhdGVyIFRoYW4gKGBtYXRoL2d0YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5HcmVhdGVyVGhhblxuICAgLSBHcmVhdGVyIFRoYW4gT3IgRXF1YWwgVG8gKGBtYXRoL2dlYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5HcmVhdGVyVGhhbk9yRXF1YWxcbjQuICoqU3BlY2lhbCBOb2RlcyoqXG4gICAtIElzIE5vdCBhIE51bWJlciAoYG1hdGgvaXNuYW5gKSBGbG93R3JhcGhCbG9ja05hbWVzLklzTmFOXG4gICAtIElzIEluZmluaXR5IChgbWF0aC9pc2luZmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuSXNJbmZpbml0eVxuICAgLSBTZWxlY3QgKGBtYXRoL3NlbGVjdGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ29uZGl0aW9uYWxcbiAgIC0gUmFuZG9tIChgbWF0aC9yYW5kb21gKSBGbG93R3JhcGhCbG9ja05hbWVzLlJhbmRvbVxuNS4gKipBbmdsZSBhbmQgVHJpZ29ub21ldHJ5IE5vZGVzKipcbiAgIC0gRGVncmVlcy1Uby1SYWRpYW5zIChgbWF0aC9yYWRgKSBGbG93R3JhcGhCbG9ja05hbWVzLkRlZ1RvUmFkXG4gICAtIFJhZGlhbnMtVG8tRGVncmVlcyAoYG1hdGgvZGVnYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5SYWRUb0RlZ1xuICAgLSBTaW5lIChgbWF0aC9zaW5gKSAgRmxvd0dyYXBoQmxvY2tOYW1lcy5TaW5cbiAgIC0gQ29zaW5lIChgbWF0aC9jb3NgKSBGbG93R3JhcGhCbG9ja05hbWVzLkNvc1xuICAgLSBUYW5nZW50IChgbWF0aC90YW5gKSBGbG93R3JhcGhCbG9ja05hbWVzLlRhblxuICAgLSBBcmNzaW5lIChgbWF0aC9hc2luYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5Bc2luXG4gICAtIEFyY2Nvc2luZSAoYG1hdGgvYWNvc2ApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQWNvc1xuICAgLSBBcmN0YW5nZW50IChgbWF0aC9hdGFuYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5BdGFuXG4gICAtIEFyY3RhbmdlbnQgMiAoYG1hdGgvYXRhbjJgKSBGbG93R3JhcGhCbG9ja05hbWVzLkF0YW4yXG42LiAqKkh5cGVyYm9saWMgTm9kZXMqKlxuICAgLSBIeXBlcmJvbGljIFNpbmUgKGBtYXRoL3NpbmhgKSBGbG93R3JhcGhCbG9ja05hbWVzLlNpbmhcbiAgIC0gSHlwZXJib2xpYyBDb3NpbmUgKGBtYXRoL2Nvc2hgKSBGbG93R3JhcGhCbG9ja05hbWVzLkNvc2hcbiAgIC0gSHlwZXJib2xpYyBUYW5nZW50IChgbWF0aC90YW5oYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5UYW5oXG4gICAtIEludmVyc2UgSHlwZXJib2xpYyBTaW5lIChgbWF0aC9hc2luaGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQXNpbmhcbiAgIC0gSW52ZXJzZSBIeXBlcmJvbGljIENvc2luZSAoYG1hdGgvYWNvc2hgKSBGbG93R3JhcGhCbG9ja05hbWVzLkFjb3NoXG4gICAtIEludmVyc2UgSHlwZXJib2xpYyBUYW5nZW50IChgbWF0aC9hdGFuaGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQXRhbmhcbjcuICoqRXhwb25lbnRpYWwgTm9kZXMqKlxuICAgLSBFeHBvbmVudCAoYG1hdGgvZXhwYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5FeHBvbmVudGlhbFxuICAgLSBOYXR1cmFsIExvZ2FyaXRobSAoYG1hdGgvbG9nYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5Mb2dcbiAgIC0gQmFzZS0yIExvZ2FyaXRobSAoYG1hdGgvbG9nMmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuTG9nMlxuICAgLSBCYXNlLTEwIExvZ2FyaXRobSAoYG1hdGgvbG9nMTBgKSBGbG93R3JhcGhCbG9ja05hbWVzLkxvZzEwXG4gICAtIFNxdWFyZSBSb290IChgbWF0aC9zcXJ0YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5TcXVhcmVSb290XG4gICAtIEN1YmUgUm9vdCAoYG1hdGgvY2JydGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ3ViZVJvb3RcbiAgIC0gUG93ZXIgKGBtYXRoL3Bvd2ApIEZsb3dHcmFwaEJsb2NrTmFtZXMuUG93ZXJcbjguICoqVmVjdG9yIE5vZGVzKipcbiAgIC0gTGVuZ3RoIChgbWF0aC9sZW5ndGhgKSBGbG93R3JhcGhCbG9ja05hbWVzLkxlbmd0aFxuICAgLSBOb3JtYWxpemUgKGBtYXRoL25vcm1hbGl6ZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuTm9ybWFsaXplXG4gICAtIERvdCBQcm9kdWN0IChgbWF0aC9kb3RgKSBGbG93R3JhcGhCbG9ja05hbWVzLkRvdFxuICAgLSBDcm9zcyBQcm9kdWN0IChgbWF0aC9jcm9zc2ApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ3Jvc3NcbiAgIC0gUm90YXRlIDJEIChgbWF0aC9yb3RhdGUyRGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuUm90YXRlMkRcbiAgIC0gUm90YXRlIDNEIChgbWF0aC9yb3RhdGUzRGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuUm90YXRlM0RcbiAgIC0gVHJhbnNmb3JtIChgbWF0aC90cmFuc2Zvcm1gKSBGbG93R3JhcGhCbG9ja05hbWVzLlRyYW5zZm9ybVZlY3RvclxuOS4gKipNYXRyaXggTm9kZXMqKlxuICAgLSBUcmFuc3Bvc2UgKGBtYXRoL3RyYW5zcG9zZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuVHJhbnNwb3NlXG4gICAtIERldGVybWluYW50IChgbWF0aC9kZXRlcm1pbmFudGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuRGV0ZXJtaW5hbnRcbiAgIC0gSW52ZXJzZSAoYG1hdGgvaW52ZXJzZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuSW52ZXJ0TWF0cml4XG4gICAtIE11bHRpcGxpY2F0aW9uIChgbWF0aC9tYXRtdWxgKSBGbG93R3JhcGhCbG9ja05hbWVzLk1hdHJpeE11bHRpcGxpY2F0aW9uXG4xMC4gKipTd2l6emxlIE5vZGVzKipcbiAgICAtIENvbWJpbmUgKGBtYXRoL2NvbWJpbmUyYCwgYG1hdGgvY29tYmluZTNgLCBgbWF0aC9jb21iaW5lNGAsIGBtYXRoL2NvbWJpbmUyeDJgLCBgbWF0aC9jb21iaW5lM3gzYCwgYG1hdGgvY29tYmluZTR4NGApXG4gICAgICAgIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZVZlY3RvcjIsIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZVZlY3RvcjMsIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZVZlY3RvcjRcbiAgICAgICAgRmxvd0dyYXBoQmxvY2tOYW1lcy5Db21iaW5lTWF0cml4MkQsIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ29tYmluZU1hdHJpeDNELCBGbG93R3JhcGhCbG9ja05hbWVzLkNvbWJpbmVNYXRyaXhcbiAgICAtIEV4dHJhY3QgKGBtYXRoL2V4dHJhY3QyYCwgYG1hdGgvZXh0cmFjdDNgLCBgbWF0aC9leHRyYWN0NGAsIGBtYXRoL2V4dHJhY3QyeDJgLCBgbWF0aC9leHRyYWN0M3gzYCwgYG1hdGgvZXh0cmFjdDR4NGApXG4gICAgICAgIEZsb3dHcmFwaEJsb2NrTmFtZXMuRXh0cmFjdFZlY3RvcjIsIEZsb3dHcmFwaEJsb2NrTmFtZXMuRXh0cmFjdFZlY3RvcjMsIEZsb3dHcmFwaEJsb2NrTmFtZXMuRXh0cmFjdFZlY3RvcjRcbiAgICAgICAgRmxvd0dyYXBoQmxvY2tOYW1lcy5FeHRyYWN0TWF0cml4MkQsIEZsb3dHcmFwaEJsb2NrTmFtZXMuRXh0cmFjdE1hdHJpeDNELCBGbG93R3JhcGhCbG9ja05hbWVzLkV4dHJhY3RNYXRyaXhcbjExLiAqKkludGVnZXIgQXJpdGhtZXRpYyBOb2RlcyoqXG4gICAgLSBBYnNvbHV0ZSBWYWx1ZSAoYG1hdGgvYWJzYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5BYnNcbiAgICAtIFNpZ24gKGBtYXRoL3NpZ25gKSBGbG93R3JhcGhCbG9ja05hbWVzLlNpZ25cbiAgICAtIE5lZ2F0aW9uIChgbWF0aC9uZWdgKSBGbG93R3JhcGhCbG9ja05hbWVzLk5lZ2F0aW9uXG4gICAgLSBBZGRpdGlvbiAoYG1hdGgvYWRkYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5BZGRcbiAgICAtIFN1YnRyYWN0aW9uIChgbWF0aC9zdWJgKSBGbG93R3JhcGhCbG9ja05hbWVzLlN1YnRyYWN0XG4gICAgLSBNdWx0aXBsaWNhdGlvbiAoYG1hdGgvbXVsYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5NdWx0aXBseVxuICAgIC0gRGl2aXNpb24gKGBtYXRoL2RpdmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuRGl2aWRlXG4gICAgLSBSZW1haW5kZXIgKGBtYXRoL3JlbWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuTW9kdWxvXG4gICAgLSBNaW5pbXVtIChgbWF0aC9taW5gKSBGbG93R3JhcGhCbG9ja05hbWVzLk1pblxuICAgIC0gTWF4aW11bSAoYG1hdGgvbWF4YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5NYXhcbiAgICAtIENsYW1wIChgbWF0aC9jbGFtcGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQ2xhbXBcbjEyLiAqKkludGVnZXIgQ29tcGFyaXNvbiBOb2RlcyoqXG4gICAgLSBFcXVhbGl0eSAoYG1hdGgvZXFgKSBGbG93R3JhcGhCbG9ja05hbWVzLkVxdWFsaXR5XG4gICAgLSBMZXNzIFRoYW4gKGBtYXRoL2x0YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5MZXNzVGhhblxuICAgIC0gTGVzcyBUaGFuIE9yIEVxdWFsIFRvIChgbWF0aC9sZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuTGVzc1RoYW5PckVxdWFsXG4gICAgLSBHcmVhdGVyIFRoYW4gKGBtYXRoL2d0YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5HcmVhdGVyVGhhblxuICAgIC0gR3JlYXRlciBUaGFuIE9yIEVxdWFsIFRvIChgbWF0aC9nZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuR3JlYXRlclRoYW5PckVxdWFsXG4xMy4gKipJbnRlZ2VyIEJpdHdpc2UgTm9kZXMqKlxuICAgIC0gQml0d2lzZSBOT1QgKGBtYXRoL25vdGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZU5vdFxuICAgIC0gQml0d2lzZSBBTkQgKGBtYXRoL2FuZGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZUFuZFxuICAgIC0gQml0d2lzZSBPUiAoYG1hdGgvb3JgKSBGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VPclxuICAgIC0gQml0d2lzZSBYT1IgKGBtYXRoL3hvcmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZVhvclxuICAgIC0gUmlnaHQgU2hpZnQgKGBtYXRoL2FzcmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZVJpZ2h0U2hpZnRcbiAgICAtIExlZnQgU2hpZnQgKGBtYXRoL2xzbGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZUxlZnRTaGlmdFxuICAgIC0gQ291bnQgTGVhZGluZyBaZXJvcyAoYG1hdGgvY2x6YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5MZWFkaW5nWmVyb3NcbiAgICAtIENvdW50IFRyYWlsaW5nIFplcm9zIChgbWF0aC9jdHpgKSBGbG93R3JhcGhCbG9ja05hbWVzLlRyYWlsaW5nWmVyb3NcbiAgICAtIENvdW50IE9uZSBCaXRzIChgbWF0aC9wb3BjbnRgKSBGbG93R3JhcGhCbG9ja05hbWVzLk9uZUJpdHNDb3VudGVyXG4xNC4gKipCb29sZWFuIEFyaXRobWV0aWMgTm9kZXMqKlxuICAgIC0gRXF1YWxpdHkgKGBtYXRoL2VxYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5FcXVhbGl0eVxuICAgIC0gQm9vbGVhbiBOT1QgKGBtYXRoL25vdGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZU5vdFxuICAgIC0gQm9vbGVhbiBBTkQgKGBtYXRoL2FuZGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZUFuZFxuICAgIC0gQm9vbGVhbiBPUiAoYG1hdGgvb3JgKSBGbG93R3JhcGhCbG9ja05hbWVzLkJpdHdpc2VPclxuICAgIC0gQm9vbGVhbiBYT1IgKGBtYXRoL3hvcmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQml0d2lzZVhvclxuXG4jIyMgVHlwZSBDb252ZXJzaW9uIE5vZGVzXG4xLiAqKkJvb2xlYW4gQ29udmVyc2lvbiBOb2RlcyoqXG4gICAtIEJvb2xlYW4gdG8gSW50ZWdlciAoYHR5cGUvYm9vbFRvSW50YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5Cb29sZWFuVG9JbnRcbiAgIC0gQm9vbGVhbiB0byBGbG9hdCAoYHR5cGUvYm9vbFRvRmxvYXRgKSBGbG93R3JhcGhCbG9ja05hbWVzLkJvb2xlYW5Ub0Zsb2F0XG4yLiAqKkludGVnZXIgQ29udmVyc2lvbiBOb2RlcyoqXG4gICAtIEludGVnZXIgdG8gQm9vbGVhbiAoYHR5cGUvaW50VG9Cb29sYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5JbnRUb0Jvb2xlYW5cbiAgIC0gSW50ZWdlciB0byBGbG9hdCAoYHR5cGUvaW50VG9GbG9hdGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuSW50VG9GbG9hdFxuMy4gKipGbG9hdCBDb252ZXJzaW9uIE5vZGVzKipcbiAgIC0gRmxvYXQgdG8gQm9vbGVhbiAoYHR5cGUvZmxvYXRUb0Jvb2xgKSBGbG93R3JhcGhCbG9ja05hbWVzLkZsb2F0VG9Cb29sZWFuXG4gICAtIEZsb2F0IHRvIEludGVnZXIgKGB0eXBlL2Zsb2F0VG9JbnRgKSBGbG93R3JhcGhCbG9ja05hbWVzLkZsb2F0VG9JbnRcblxuIyMjIENvbnRyb2wgRmxvdyBOb2Rlc1xuMS4gKipTeW5jIE5vZGVzKipcbiAgIC0gU2VxdWVuY2UgKGBmbG93L3NlcXVlbmNlYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5TZXF1ZW5jZVxuICAgLSBCcmFuY2ggKGBmbG93L2JyYW5jaGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuQnJhbmNoXG4gICAtIFN3aXRjaCAoYGZsb3cvc3dpdGNoYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5Td2l0Y2hcbiAgIC0gV2hpbGUgTG9vcCAoYGZsb3cvd2hpbGVgKSBGbG93R3JhcGhCbG9ja05hbWVzLldoaWxlTG9vcFxuICAgLSBGb3IgTG9vcCAoYGZsb3cvZm9yYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5Gb3JMb29wXG4gICAtIERvIE4gKGBmbG93L2RvTmApIEZsb3dHcmFwaEJsb2NrTmFtZXMuRG9OXG4gICAtIE11bHRpIEdhdGUgKGBmbG93L211bHRpR2F0ZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuTXVsdGlHYXRlXG4gICAtIFdhaXQgQWxsIChgZmxvdy93YWl0QWxsYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5XYWl0QWxsXG4gICAtIFRocm90dGxlIChgZmxvdy90aHJvdHRsZWApIEZsb3dHcmFwaEJsb2NrTmFtZXMuVGhyb3R0bGVcbjIuICoqRGVsYXkgTm9kZXMqKlxuICAgLSBTZXQgRGVsYXkgKGBmbG93L3NldERlbGF5YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5TZXREZWxheVxuICAgLSBDYW5jZWwgRGVsYXkgKGBmbG93L2NhbmNlbERlbGF5YCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5DYW5jZWxEZWxheVxuXG4jIyMgU3RhdGUgTWFuaXB1bGF0aW9uIE5vZGVzXG4xLiAqKkN1c3RvbSBWYXJpYWJsZSBBY2Nlc3MqKlxuICAgLSBWYXJpYWJsZSBHZXQgKGB2YXJpYWJsZS9nZXRgKSBGbG93R3JhcGhCbG9ja05hbWVzLkdldFZhcmlhYmxlXG4gICAtIFZhcmlhYmxlIFNldCAoYHZhcmlhYmxlL3NldGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuU2V0VmFyaWFibGVcbiAgIC0gVmFyaWFibGUgSW50ZXJwb2xhdGUgKGB2YXJpYWJsZS9pbnRlcnBvbGF0ZWApXG4yLiAqKk9iamVjdCBNb2RlbCBBY2Nlc3MqKiAvLyBUT0RPIGZ1bGx5IHRlc3QgdGhpcyEhIVxuICAgLSBKU09OIFBvaW50ZXIgVGVtcGxhdGUgUGFyc2luZyAoYHBvaW50ZXIvZ2V0YCkgW0Zsb3dHcmFwaEJsb2NrTmFtZXMuR2V0UHJvcGVydHksIEZsb3dHcmFwaEJsb2NrTmFtZXMuSnNvblBvaW50ZXJQYXJzZXJdXG4gICAtIEVmZmVjdGl2ZSBKU09OIFBvaW50ZXIgR2VuZXJhdGlvbiAoYHBvaW50ZXIvc2V0YCkgW0Zsb3dHcmFwaEJsb2NrTmFtZXMuU2V0UHJvcGVydHksIEZsb3dHcmFwaEJsb2NrTmFtZXMuSnNvblBvaW50ZXJQYXJzZXJdXG4gICAtIFBvaW50ZXIgR2V0IChgcG9pbnRlci9nZXRgKSBbRmxvd0dyYXBoQmxvY2tOYW1lcy5HZXRQcm9wZXJ0eSwgRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlcl1cbiAgIC0gUG9pbnRlciBTZXQgKGBwb2ludGVyL3NldGApIFtGbG93R3JhcGhCbG9ja05hbWVzLlNldFByb3BlcnR5LCBGbG93R3JhcGhCbG9ja05hbWVzLkpzb25Qb2ludGVyUGFyc2VyXVxuICAgLSBQb2ludGVyIEludGVycG9sYXRlIChgcG9pbnRlci9pbnRlcnBvbGF0ZWApIFtGbG93R3JhcGhCbG9ja05hbWVzLlZhbHVlSW50ZXJwb2xhdGlvbiwgRmxvd0dyYXBoQmxvY2tOYW1lcy5Kc29uUG9pbnRlclBhcnNlciwgRmxvd0dyYXBoQmxvY2tOYW1lcy5QbGF5QW5pbWF0aW9uLCBGbG93R3JhcGhCbG9ja05hbWVzLkVhc2luZ11cblxuIyMjIEFuaW1hdGlvbiBDb250cm9sIE5vZGVzXG4xLiAqKkFuaW1hdGlvbiBQbGF5KiogKGBhbmltYXRpb24vc3RhcnRgKSBGbG93R3JhcGhCbG9ja05hbWVzLlBsYXlBbmltYXRpb25cbjIuICoqQW5pbWF0aW9uIFN0b3AqKiAoYGFuaW1hdGlvbi9zdG9wYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5TdG9wQW5pbWF0aW9uIFxuMy4gKipBbmltYXRpb24gU3RvcCBBdCoqIChgYW5pbWF0aW9uL3N0b3BBdGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuU3RvcEFuaW1hdGlvbiBcblxuIyMjIEV2ZW50IE5vZGVzXG4xLiAqKkxpZmVjeWNsZSBFdmVudCBOb2RlcyoqXG4gICAtIE9uIFN0YXJ0IChgZXZlbnQvb25TdGFydGApIEZsb3dHcmFwaEJsb2NrTmFtZXMuU2NlbmVSZWFkeUV2ZW50XG4gICAtIE9uIFRpY2sgKGBldmVudC9vblRpY2tgKSBGbG93R3JhcGhCbG9ja05hbWVzLlNjZW5lVGlja0V2ZW50XG4yLiAqKkN1c3RvbSBFdmVudCBOb2RlcyoqXG4gICAtIFJlY2VpdmUgKGBldmVudC9yZWNlaXZlYCkgRmxvd0dyYXBoQmxvY2tOYW1lcy5SZWNlaXZlQ3VzdG9tRXZlbnRcbiAgIC0gU2VuZCAoYGV2ZW50L3NlbmRgKSBGbG93R3JhcGhCbG9ja05hbWVzLlNlbmRDdXN0b21FdmVudFxuXG4gKi9cbiIsImltcG9ydCB0eXBlIHsgSUZsb3dHcmFwaEJsb2NrQ29uZmlndXJhdGlvbiB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9mbG93R3JhcGhCbG9ja1wiO1xuaW1wb3J0IHsgRmxvd0dyYXBoQmxvY2sgfSBmcm9tIFwiY29yZS9GbG93R3JhcGgvZmxvd0dyYXBoQmxvY2tcIjtcbmltcG9ydCB0eXBlIHsgSUdMVEYgfSBmcm9tIFwiLi4vLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcbmltcG9ydCB0eXBlIHsgRmxvd0dyYXBoRGF0YUNvbm5lY3Rpb24gfSBmcm9tIFwiY29yZS9GbG93R3JhcGgvZmxvd0dyYXBoRGF0YUNvbm5lY3Rpb25cIjtcbmltcG9ydCB0eXBlIHsgQW5pbWF0aW9uR3JvdXAgfSBmcm9tIFwiY29yZS9BbmltYXRpb25zL2FuaW1hdGlvbkdyb3VwXCI7XG5pbXBvcnQgdHlwZSB7IFRyYW5zZm9ybU5vZGUgfSBmcm9tIFwiY29yZS9NZXNoZXMvdHJhbnNmb3JtTm9kZVwiO1xuaW1wb3J0IHsgUmljaFR5cGVBbnkgfSBmcm9tIFwiY29yZS9GbG93R3JhcGgvZmxvd0dyYXBoUmljaFR5cGVzXCI7XG5cbi8qKlxuICogYSBjb25maWd1cmF0aW9uIGludGVyZmFjZSBmb3IgdGhpcyBibG9ja1xuICovXG5leHBvcnQgaW50ZXJmYWNlIElGbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyQmxvY2tDb25maWd1cmF0aW9uIGV4dGVuZHMgSUZsb3dHcmFwaEJsb2NrQ29uZmlndXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogdGhlIGdsVEYgb2JqZWN0IHRvIHByb3ZpZGUgZGF0YSBmcm9tXG4gICAgICovXG4gICAgZ2xURjogSUdMVEY7XG59XG5cbi8qKlxuICogYSBnbFRGLWJhc2VkIEZsb3dHcmFwaCBibG9jayB0aGF0IHByb3ZpZGVzIGFycmF5cyB3aXRoIGJhYnlsb24gb2JqZWN0LCBiYXNlZCBvbiB0aGUgZ2xURiB0cmVlXG4gKiBDYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGdldCBhbmltYXRpb24gaW5kZXggZnJvbSBhIGdsVEYgYW5pbWF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBGbG93R3JhcGhHTFRGRGF0YVByb3ZpZGVyIGV4dGVuZHMgRmxvd0dyYXBoQmxvY2sge1xuICAgIC8qKlxuICAgICAqIE91dHB1dDogYW4gYXJyYXkgb2YgYW5pbWF0aW9uIGdyb3Vwc1xuICAgICAqIENvcnJlc3BvbmRzIGRpcmVjdGx5IHRvIHRoZSBnbFRGIGFuaW1hdGlvbnMgYXJyYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYW5pbWF0aW9uR3JvdXBzOiBGbG93R3JhcGhEYXRhQ29ubmVjdGlvbjxBbmltYXRpb25Hcm91cFtdPjtcblxuICAgIC8qKlxuICAgICAqIE91dHB1dCBhbiBhcnJheSBvZiAoVHJhbnNmb3JtKSBub2Rlc1xuICAgICAqIENvcnJlc3BvbmRzIGRpcmVjdGx5IHRvIHRoZSBnbFRGIG5vZGVzIGFycmF5XG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IG5vZGVzOiBGbG93R3JhcGhEYXRhQ29ubmVjdGlvbjxUcmFuc2Zvcm1Ob2RlW10+O1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBJRmxvd0dyYXBoR0xURkRhdGFQcm92aWRlckJsb2NrQ29uZmlndXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBnbFRGID0gY29uZmlnLmdsVEY7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbkdyb3VwcyA9IGdsVEYuYW5pbWF0aW9ucz8ubWFwKChhKSA9PiBhLl9iYWJ5bG9uQW5pbWF0aW9uR3JvdXApIHx8IFtdO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkdyb3VwcyA9IHRoaXMucmVnaXN0ZXJEYXRhT3V0cHV0KFwiYW5pbWF0aW9uR3JvdXBzXCIsIFJpY2hUeXBlQW55LCBhbmltYXRpb25Hcm91cHMpO1xuICAgICAgICBjb25zdCBub2RlcyA9IGdsVEYubm9kZXM/Lm1hcCgobikgPT4gbi5fYmFieWxvblRyYW5zZm9ybU5vZGUpIHx8IFtdO1xuICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5yZWdpc3RlckRhdGFPdXRwdXQoXCJub2Rlc1wiLCBSaWNoVHlwZUFueSwgbm9kZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRDbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwiRmxvd0dyYXBoR0xURkRhdGFQcm92aWRlclwiO1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2RlY2xhcmF0aW9uTWFwcGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9pbnRlcmFjdGl2aXR5R3JhcGhQYXJzZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Zsb3dHcmFwaEdMVEZEYXRhUHJvdmlkZXJcIjtcbiIsImltcG9ydCB0eXBlIHsgSUtIUkludGVyYWN0aXZpdHlfR3JhcGgsIElLSFJJbnRlcmFjdGl2aXR5X05vZGUsIElLSFJJbnRlcmFjdGl2aXR5X091dHB1dFNvY2tldFJlZmVyZW5jZSwgSUtIUkludGVyYWN0aXZpdHlfVmFyaWFibGUgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XG5pbXBvcnQgdHlwZSB7IElHTFRGIH0gZnJvbSBcIi4uLy4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XG5pbXBvcnQgdHlwZSB7IElHTFRGVG9GbG93R3JhcGhNYXBwaW5nIH0gZnJvbSBcIi4vZGVjbGFyYXRpb25NYXBwZXJcIjtcbmltcG9ydCB7IGdldE1hcHBpbmdGb3JEZWNsYXJhdGlvbiwgZ2V0TWFwcGluZ0ZvckZ1bGxPcGVyYXRpb25OYW1lIH0gZnJvbSBcIi4vZGVjbGFyYXRpb25NYXBwZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjb3JlL01pc2MvbG9nZ2VyXCI7XG5pbXBvcnQgdHlwZSB7IElTZXJpYWxpemVkRmxvd0dyYXBoLCBJU2VyaWFsaXplZEZsb3dHcmFwaEJsb2NrLCBJU2VyaWFsaXplZEZsb3dHcmFwaENvbm5lY3Rpb24sIElTZXJpYWxpemVkRmxvd0dyYXBoQ29udGV4dCB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC90eXBlRGVmaW5pdGlvbnNcIjtcbmltcG9ydCB7IFJhbmRvbUdVSUQgfSBmcm9tIFwiY29yZS9NaXNjL2d1aWRcIjtcbmltcG9ydCB0eXBlIHsgSUZsb3dHcmFwaEJsb2NrQ29uZmlndXJhdGlvbiB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9mbG93R3JhcGhCbG9ja1wiO1xuaW1wb3J0IHR5cGUgeyBGbG93R3JhcGhCbG9ja05hbWVzIH0gZnJvbSBcImNvcmUvRmxvd0dyYXBoL0Jsb2Nrcy9mbG93R3JhcGhCbG9ja05hbWVzXCI7XG5pbXBvcnQgeyBGbG93R3JhcGhDb25uZWN0aW9uVHlwZSB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9mbG93R3JhcGhDb25uZWN0aW9uXCI7XG5pbXBvcnQgeyBGbG93R3JhcGhUeXBlcyB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC9mbG93R3JhcGhSaWNoVHlwZXNcIjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcmFjdGl2aXR5RXZlbnQge1xuICAgIGV2ZW50SWQ6IHN0cmluZztcbiAgICBldmVudERhdGE/OiB7XG4gICAgICAgIGV2ZW50RGF0YTogYm9vbGVhbjtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgdHlwZTogc3RyaW5nO1xuICAgICAgICB2YWx1ZT86IGFueTtcbiAgICB9W107XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgZ2x0ZlR5cGVUb0JhYnlsb25UeXBlOiB7XG4gICAgW2tleTogc3RyaW5nXTogeyBsZW5ndGg6IG51bWJlcjsgZmxvd0dyYXBoVHlwZTogRmxvd0dyYXBoVHlwZXM7IGVsZW1lbnRUeXBlOiBcIm51bWJlclwiIHwgXCJib29sZWFuXCIgfTtcbn0gPSB7XG4gICAgZmxvYXQ6IHsgbGVuZ3RoOiAxLCBmbG93R3JhcGhUeXBlOiBGbG93R3JhcGhUeXBlcy5OdW1iZXIsIGVsZW1lbnRUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgYm9vbDogeyBsZW5ndGg6IDEsIGZsb3dHcmFwaFR5cGU6IEZsb3dHcmFwaFR5cGVzLkJvb2xlYW4sIGVsZW1lbnRUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGZsb2F0MjogeyBsZW5ndGg6IDIsIGZsb3dHcmFwaFR5cGU6IEZsb3dHcmFwaFR5cGVzLlZlY3RvcjIsIGVsZW1lbnRUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgZmxvYXQzOiB7IGxlbmd0aDogMywgZmxvd0dyYXBoVHlwZTogRmxvd0dyYXBoVHlwZXMuVmVjdG9yMywgZWxlbWVudFR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICBmbG9hdDQ6IHsgbGVuZ3RoOiA0LCBmbG93R3JhcGhUeXBlOiBGbG93R3JhcGhUeXBlcy5WZWN0b3I0LCBlbGVtZW50VHlwZTogXCJudW1iZXJcIiB9LFxuICAgIGZsb2F0NHg0OiB7IGxlbmd0aDogMTYsIGZsb3dHcmFwaFR5cGU6IEZsb3dHcmFwaFR5cGVzLk1hdHJpeCwgZWxlbWVudFR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICBmbG9hdDJ4MjogeyBsZW5ndGg6IDQsIGZsb3dHcmFwaFR5cGU6IEZsb3dHcmFwaFR5cGVzLk1hdHJpeDJELCBlbGVtZW50VHlwZTogXCJudW1iZXJcIiB9LFxuICAgIGZsb2F0M3gzOiB7IGxlbmd0aDogOSwgZmxvd0dyYXBoVHlwZTogRmxvd0dyYXBoVHlwZXMuTWF0cml4M0QsIGVsZW1lbnRUeXBlOiBcIm51bWJlclwiIH0sXG4gICAgaW50OiB7IGxlbmd0aDogMSwgZmxvd0dyYXBoVHlwZTogRmxvd0dyYXBoVHlwZXMuSW50ZWdlciwgZWxlbWVudFR5cGU6IFwibnVtYmVyXCIgfSxcbn07XG5cbmV4cG9ydCBjbGFzcyBJbnRlcmFjdGl2aXR5R3JhcGhUb0Zsb3dHcmFwaFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogTm90ZSAtIHRoZSBncmFwaCBzaG91bGQgYmUgcmVqZWN0ZWQgaWYgdGhlIHNhbWUgdHlwZSBpcyBkZWZpbmVkIHR3aWNlLlxuICAgICAqIFdlIGN1cnJlbnRseSBkb24ndCB2YWxpZGF0ZSB0aGF0LlxuICAgICAqL1xuICAgIHByaXZhdGUgX3R5cGVzOiB7IGxlbmd0aDogbnVtYmVyOyBmbG93R3JhcGhUeXBlOiBGbG93R3JhcGhUeXBlczsgZWxlbWVudFR5cGU6IFwibnVtYmVyXCIgfCBcImJvb2xlYW5cIiB9W10gPSBbXTtcbiAgICBwcml2YXRlIF9tYXBwaW5nczogeyBmbG93R3JhcGhNYXBwaW5nOiBJR0xURlRvRmxvd0dyYXBoTWFwcGluZzsgZnVsbE9wZXJhdGlvbk5hbWU6IHN0cmluZyB9W10gPSBbXTtcbiAgICBwcml2YXRlIF9zdGF0aWNWYXJpYWJsZXM6IHsgdHlwZTogRmxvd0dyYXBoVHlwZXM7IHZhbHVlOiBhbnlbXSB9W10gPSBbXTtcbiAgICBwcml2YXRlIF9ldmVudHM6IEludGVyYWN0aXZpdHlFdmVudFtdID0gW107XG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxFdmVudHNDb3VudGVyOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgX25vZGVzOiB7IGJsb2NrczogSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9ja1tdOyBmdWxsT3BlcmF0aW9uTmFtZTogc3RyaW5nIH1bXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2ludGVyYWN0aXZpdHlHcmFwaDogSUtIUkludGVyYWN0aXZpdHlfR3JhcGgsXG4gICAgICAgIHByaXZhdGUgX2dsdGY6IElHTFRGLFxuICAgICAgICBwdWJsaWMgX2FuaW1hdGlvblRhcmdldEZwczogbnVtYmVyID0gNjBcbiAgICApIHtcbiAgICAgICAgLy8gc3RhcnQgd2l0aCB0eXBlc1xuICAgICAgICB0aGlzLl9wYXJzZVR5cGVzKCk7XG4gICAgICAgIC8vIGNvbnRpbnVlIHdpdGggZGVjbGFyYXRpb25zXG4gICAgICAgIHRoaXMuX3BhcnNlRGVjbGFyYXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGVzKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlTm9kZXMoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGFycmF5cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0aGlzLl90eXBlcyxcbiAgICAgICAgICAgIG1hcHBpbmdzOiB0aGlzLl9tYXBwaW5ncyxcbiAgICAgICAgICAgIHN0YXRpY1ZhcmlhYmxlczogdGhpcy5fc3RhdGljVmFyaWFibGVzLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLl9ldmVudHMsXG4gICAgICAgICAgICBub2RlczogdGhpcy5fbm9kZXMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcGFyc2VUeXBlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcmFjdGl2aXR5R3JhcGgudHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLnR5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlcy5wdXNoKGdsdGZUeXBlVG9CYWJ5bG9uVHlwZVt0eXBlLnNpZ25hdHVyZV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcGFyc2VEZWNsYXJhdGlvbnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgdGhlIG1hcHBpbmcgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZ0ZvckRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgIC8vIG1hcHBpbmcgaXMgZGVmaW5lZCwgYmVjYXVzZSB3ZSBnZW5lcmF0ZSBhbiBlbXB0eSBtYXBwaW5nIGlmIGl0J3Mgbm90IGZvdW5kXG4gICAgICAgICAgICBpZiAoIW1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoW1wiTm8gbWFwcGluZyBmb3VuZCBmb3IgZGVjbGFyYXRpb25cIiwgZGVjbGFyYXRpb25dKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIGRlY2xhcmF0aW9uc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZsb3dHcmFwaE1hcHBpbmc6IG1hcHBpbmcsXG4gICAgICAgICAgICAgICAgZnVsbE9wZXJhdGlvbk5hbWU6IGRlY2xhcmF0aW9uLmV4dGVuc2lvbiA/IGRlY2xhcmF0aW9uLm9wICsgXCI6XCIgKyBkZWNsYXJhdGlvbi5leHRlbnNpb24gOiBkZWNsYXJhdGlvbi5vcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcGFyc2VWYXJpYWJsZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5fcGFyc2VWYXJpYWJsZSh2YXJpYWJsZSk7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGhlcmVcbiAgICAgICAgICAgIHRoaXMuX3N0YXRpY1ZhcmlhYmxlcy5wdXNoKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9wYXJzZVZhcmlhYmxlKHZhcmlhYmxlOiBJS0hSSW50ZXJhY3Rpdml0eV9WYXJpYWJsZSwgZGF0YVRyYW5zZm9ybT86ICh2YWx1ZTogYW55LCBwYXJzZXI6IEludGVyYWN0aXZpdHlHcmFwaFRvRmxvd0dyYXBoUGFyc2VyKSA9PiBhbnkpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3R5cGVzW3ZhcmlhYmxlLnR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJObyB0eXBlIGZvdW5kIGZvciB2YXJpYWJsZVwiLCB2YXJpYWJsZV0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyB2YXJpYWJsZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhYmxlLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUudmFsdWUubGVuZ3RoICE9PSB0eXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJJbnZhbGlkIHZhbHVlIGxlbmd0aCBmb3IgdmFyaWFibGVcIiwgdmFyaWFibGUsIHR5cGVdKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIHZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhcmlhYmxlLnZhbHVlIHx8IFtdO1xuICAgICAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLmZsb3dHcmFwaFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZsb3dHcmFwaFR5cGVzLkJvb2xlYW46XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZsb3dHcmFwaFR5cGVzLkludGVnZXI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRmxvd0dyYXBoVHlwZXMuTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRmxvd0dyYXBoVHlwZXMuVmVjdG9yMjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChOYU4sIE5hTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRmxvd0dyYXBoVHlwZXMuVmVjdG9yMzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChOYU4sIE5hTiwgTmFOKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGbG93R3JhcGhUeXBlcy5WZWN0b3I0OlxuICAgICAgICAgICAgICAgIGNhc2UgRmxvd0dyYXBoVHlwZXMuTWF0cml4MkQ6XG4gICAgICAgICAgICAgICAgY2FzZSBGbG93R3JhcGhUeXBlcy5RdWF0ZXJuaW9uOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5maWxsKE5hTiwgMCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRmxvd0dyYXBoVHlwZXMuTWF0cml4OlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5maWxsKE5hTiwgMCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZsb3dHcmFwaFR5cGVzLk1hdHJpeDNEOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5maWxsKE5hTiwgMCwgOSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgTmFOLCBJbmZpbml0eSwgd2UgbmVlZCB0byBwYXJzZSB0aGUgc3RyaW5nIHRvIHRoZSBvYmplY3QgaXRzZWxmXG4gICAgICAgIGlmICh0eXBlLmVsZW1lbnRUeXBlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFsdWVbMF0gPSBwYXJzZUZsb2F0KHZhbHVlWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLmZsb3dHcmFwaFR5cGUsIHZhbHVlOiBkYXRhVHJhbnNmb3JtID8gZGF0YVRyYW5zZm9ybSh2YWx1ZSwgdGhpcykgOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX3BhcnNlRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ludGVyYWN0aXZpdHlHcmFwaC5ldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuX2ludGVyYWN0aXZpdHlHcmFwaC5ldmVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZDogSW50ZXJhY3Rpdml0eUV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50SWQ6IGV2ZW50LmlkIHx8IFwiaW50ZXJuYWxFdmVudF9cIiArIHRoaXMuX2ludGVybmFsRXZlbnRzQ291bnRlcisrLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChldmVudC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWQuZXZlbnREYXRhID0gT2JqZWN0LmtleXMoZXZlbnQudmFsdWVzKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudFZhbHVlID0gZXZlbnQudmFsdWVzPy5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoW1wiTm8gdmFsdWUgZm91bmQgZm9yIGV2ZW50IGtleVwiLCBrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgZXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl90eXBlc1tldmVudFZhbHVlLnR5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJObyB0eXBlIGZvdW5kIGZvciBldmVudCB2YWx1ZVwiLCBldmVudFZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIGV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBldmVudFZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5fcGFyc2VWYXJpYWJsZShldmVudFZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLmZsb3dHcmFwaFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudERhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGNvbnZlcnRlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9wYXJzZU5vZGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ludGVyYWN0aXZpdHlHcmFwaC5ub2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLl9pbnRlcmFjdGl2aXR5R3JhcGgubm9kZXMpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgdmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmRlY2xhcmF0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFtcIk5vIGRlY2xhcmF0aW9uIGZvdW5kIGZvciBub2RlXCIsIG5vZGVdKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIG5vZGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IHRoaXMuX21hcHBpbmdzW25vZGUuZGVjbGFyYXRpb25dO1xuICAgICAgICAgICAgaWYgKCFtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFtcIk5vIG1hcHBpbmcgZm91bmQgZm9yIG5vZGVcIiwgbm9kZV0pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgbm9kZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFwcGluZy5mbG93R3JhcGhNYXBwaW5nLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gbWFwcGluZy5mbG93R3JhcGhNYXBwaW5nLnZhbGlkYXRpb24obm9kZSwgdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLCB0aGlzLl9nbHRmKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB2YWxpZGF0aW5nIGludGVyYWN0aXZpdHkgbm9kZSAke3RoaXMuX2ludGVyYWN0aXZpdHlHcmFwaC5kZWNsYXJhdGlvbnM/Lltub2RlLmRlY2xhcmF0aW9uXS5vcH0gLSAke3ZhbGlkYXRpb25SZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tzOiBJU2VyaWFsaXplZEZsb3dHcmFwaEJsb2NrW10gPSBbXTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBibG9jayhzKSBmb3IgdGhpcyBub2RlIHVzaW5nIHRoZSBtYXBwaW5nXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrVHlwZSBvZiBtYXBwaW5nLmZsb3dHcmFwaE1hcHBpbmcuYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLl9nZXRFbXB0eUJsb2NrKGJsb2NrVHlwZSwgbWFwcGluZy5mdWxsT3BlcmF0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VOb2RlQ29uZmlndXJhdGlvbihub2RlLCBibG9jaywgbWFwcGluZy5mbG93R3JhcGhNYXBwaW5nLCBibG9ja1R5cGUpO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnB1c2goeyBibG9ja3MsIGZ1bGxPcGVyYXRpb25OYW1lOiBtYXBwaW5nLmZ1bGxPcGVyYXRpb25OYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0RW1wdHlCbG9jayhjbGFzc05hbWU6IHN0cmluZywgdHlwZTogc3RyaW5nKTogSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9jayB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUlkID0gUmFuZG9tR1VJRCgpO1xuICAgICAgICBjb25zdCBkYXRhSW5wdXRzOiBJU2VyaWFsaXplZEZsb3dHcmFwaENvbm5lY3Rpb25bXSA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhT3V0cHV0czogSVNlcmlhbGl6ZWRGbG93R3JhcGhDb25uZWN0aW9uW10gPSBbXTtcbiAgICAgICAgY29uc3Qgc2lnbmFsSW5wdXRzOiBJU2VyaWFsaXplZEZsb3dHcmFwaENvbm5lY3Rpb25bXSA9IFtdO1xuICAgICAgICBjb25zdCBzaWduYWxPdXRwdXRzOiBJU2VyaWFsaXplZEZsb3dHcmFwaENvbm5lY3Rpb25bXSA9IFtdO1xuICAgICAgICBjb25zdCBjb25maWc6IElGbG93R3JhcGhCbG9ja0NvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuaXF1ZUlkLFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgZGF0YUlucHV0cyxcbiAgICAgICAgICAgIGRhdGFPdXRwdXRzLFxuICAgICAgICAgICAgc2lnbmFsSW5wdXRzLFxuICAgICAgICAgICAgc2lnbmFsT3V0cHV0cyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9wYXJzZU5vZGVDb25maWd1cmF0aW9uKG5vZGU6IElLSFJJbnRlcmFjdGl2aXR5X05vZGUsIGJsb2NrOiBJU2VyaWFsaXplZEZsb3dHcmFwaEJsb2NrLCBub2RlTWFwcGluZzogSUdMVEZUb0Zsb3dHcmFwaE1hcHBpbmcsIGJsb2NrVHlwZTogRmxvd0dyYXBoQmxvY2tOYW1lcyB8IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gYmxvY2suY29uZmlnO1xuICAgICAgICBpZiAobm9kZS5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5jb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuY29uZmlndXJhdGlvbj8uW2tleV07XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgYWx3YXlzIGFuIGFycmF5LCBuZXZlciBhIG51bWJlciBvciBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJObyB2YWx1ZSBmb3VuZCBmb3Igbm9kZSBjb25maWd1cmF0aW9uXCIsIGtleV0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBwYXJzaW5nIG5vZGUgY29uZmlndXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnTWFwcGluZyA9IG5vZGVNYXBwaW5nLmNvbmZpZ3VyYXRpb24/LltrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlbG9uZ3NUb0Jsb2NrID0gY29uZmlnTWFwcGluZyAmJiBjb25maWdNYXBwaW5nLnRvQmxvY2sgPyBjb25maWdNYXBwaW5nLnRvQmxvY2sgPT09IGJsb2NrVHlwZSA6IG5vZGVNYXBwaW5nLmJsb2Nrcy5pbmRleE9mKGJsb2NrVHlwZSkgPT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKGJlbG9uZ3NUb0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcmlnaHQgbmFtZSBmb3IgdGhlIGNvbmZpZ3VyYXRpb24ga2V5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0tleSA9IGNvbmZpZ01hcHBpbmc/Lm5hbWUgfHwga2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpICYmIHR5cGVvZiBjb25maWdNYXBwaW5nPy5kZWZhdWx0VmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bY29uZmlnS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29uZmlnTWFwcGluZy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnZhbHVlLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0aW5nIGludFtdIGFuZCBpbnQvYm9vbGVhbi9zdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bY29uZmlnS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudmFsdWUubGVuZ3RoID09PSAxID8gdmFsdWUudmFsdWVbMF0gOiB2YWx1ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihbXCJJbnZhbGlkIHZhbHVlIGZvciBub2RlIGNvbmZpZ3VyYXRpb25cIiwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgdHJhbnNmb3JtIHRoZSBkYXRhIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnTWFwcGluZyAmJiBjb25maWdNYXBwaW5nLmRhdGFUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbltjb25maWdLZXldLnZhbHVlID0gY29uZmlnTWFwcGluZy5kYXRhVHJhbnNmb3JtZXIoW2NvbmZpZ3VyYXRpb25bY29uZmlnS2V5XS52YWx1ZV0sIHRoaXMpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcGFyc2VOb2RlQ29ubmVjdGlvbnMoY29udGV4dDogSVNlcmlhbGl6ZWRGbG93R3JhcGhDb250ZXh0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgY29ycmVzcG9uZGluZyBnbHRmIG5vZGVcbiAgICAgICAgICAgIGNvbnN0IGdsdGZOb2RlID0gdGhpcy5faW50ZXJhY3Rpdml0eUdyYXBoLm5vZGVzPy5baV07XG4gICAgICAgICAgICBpZiAoIWdsdGZOb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlbiBidXQgbGV0J3Mgc3RpbGwgY2hlY2tcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoW1wiTm8gbm9kZSBmb3VuZCBmb3IgaW50ZXJhY3Rpdml0eSBub2RlXCIsIHRoaXMuX25vZGVzW2ldXSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBub2RlIGNvbm5lY3Rpb25zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxvd0dyYXBoQmxvY2tzID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRNYXBwZXIgPSB0aGlzLl9tYXBwaW5nc1tnbHRmTm9kZS5kZWNsYXJhdGlvbl07XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICAgICAgaWYgKCFvdXRwdXRNYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoW1wiTm8gbWFwcGluZyBmb3VuZCBmb3Igbm9kZVwiLCBnbHRmTm9kZV0pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgbm9kZSBjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsb3dzRnJvbUdMVEYgPSBnbHRmTm9kZS5mbG93cyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IGZsb3dzS2V5cyA9IE9iamVjdC5rZXlzKGZsb3dzRnJvbUdMVEYpLnNvcnQoKTsgLy8gc29ydGluZyBhcyBzb21lIG9wZXJhdGlvbnMgcmVxdWlyZSBzb3J0ZWQga2V5c1xuICAgICAgICAgICAgLy8gY29ubmVjdCB0aGUgZmxvd3NcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmxvd0tleSBvZiBmbG93c0tleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmbG93ID0gZmxvd3NGcm9tR0xURltmbG93S2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbG93TWFwcGluZyA9IG91dHB1dE1hcHBlci5mbG93R3JhcGhNYXBwaW5nLm91dHB1dHM/LmZsb3dzPy5bZmxvd0tleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0T3V0TmFtZSA9IGZsb3dNYXBwaW5nPy5uYW1lIHx8IGZsb3dLZXk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgc2VyaWFsaXplZCBzb2NrZXRcbiAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXRPdXQgPSB0aGlzLl9jcmVhdGVOZXdTb2NrZXRDb25uZWN0aW9uKHNvY2tldE91dE5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gKGZsb3dNYXBwaW5nICYmIGZsb3dNYXBwaW5nLnRvQmxvY2sgJiYgZmxvd0dyYXBoQmxvY2tzLmJsb2Nrcy5maW5kKChiKSA9PiBiLmNsYXNzTmFtZSA9PT0gZmxvd01hcHBpbmcudG9CbG9jaykpIHx8IGZsb3dHcmFwaEJsb2Nrcy5ibG9ja3NbMF07XG4gICAgICAgICAgICAgICAgYmxvY2suc2lnbmFsT3V0cHV0cy5wdXNoKHNvY2tldE91dCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbnB1dCBub2RlIG9mIHRoaXMgYmxvY2tcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dE5vZGVJZCA9IGZsb3cubm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlSW4gPSB0aGlzLl9ub2Rlc1tpbnB1dE5vZGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSW4pIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFtcIk5vIG5vZGUgZm91bmQgZm9yIGlucHV0IG5vZGUgaWRcIiwgaW5wdXROb2RlSWRdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBub2RlIGNvbm5lY3Rpb25zXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG1hcHBlciBmb3IgdGhlIGlucHV0IG5vZGUgLSBpbiBjYXNlIGl0IG1hcHBlZCB0byBtdWx0aXBsZSBibG9ja3NcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dE1hcHBlciA9IGdldE1hcHBpbmdGb3JGdWxsT3BlcmF0aW9uTmFtZShub2RlSW4uZnVsbE9wZXJhdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXRNYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFtcIk5vIG1hcHBpbmcgZm91bmQgZm9yIGlucHV0IG5vZGVcIiwgbm9kZUluXSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgbm9kZSBjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZsb3dJbk1hcHBpbmcgPSBpbnB1dE1hcHBlci5pbnB1dHM/LmZsb3dzPy5bZmxvdy5zb2NrZXQgfHwgXCJpblwiXTtcbiAgICAgICAgICAgICAgICBsZXQgYXJyYXlNYXBwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFmbG93SW5NYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0TWFwcGVyLmlucHV0cz8uZmxvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIltcIikgJiYga2V5LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5TWFwcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvd0luTWFwcGluZyA9IGlucHV0TWFwcGVyLmlucHV0cz8uZmxvd3M/LltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJblNvY2tldE5hbWUgPSBmbG93SW5NYXBwaW5nID8gKGFycmF5TWFwcGluZyA/IGZsb3dJbk1hcHBpbmcubmFtZS5yZXBsYWNlKFwiJDFcIiwgZmxvdy5zb2NrZXQgfHwgXCJcIikgOiBmbG93SW5NYXBwaW5nLm5hbWUpIDogZmxvdy5zb2NrZXQgfHwgXCJpblwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0QmxvY2sgPSAoZmxvd0luTWFwcGluZyAmJiBmbG93SW5NYXBwaW5nLnRvQmxvY2sgJiYgbm9kZUluLmJsb2Nrcy5maW5kKChiKSA9PiBiLmNsYXNzTmFtZSA9PT0gZmxvd0luTWFwcGluZy50b0Jsb2NrKSkgfHwgbm9kZUluLmJsb2Nrc1swXTtcbiAgICAgICAgICAgICAgICAvLyBpbiBhbGwgb2YgdGhlIGZsb3cgZ3JhcGggaW5wdXQgY29ubmVjdGlvbnMsIGZpbmQgdGhlIG9uZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIHNvY2tldFxuICAgICAgICAgICAgICAgIGxldCBzb2NrZXRJbiA9IGlucHV0QmxvY2suc2lnbmFsSW5wdXRzLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gbm9kZUluU29ja2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNvY2tldCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgdGhlIGlucHV0IHNvY2tldCBmb3IgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoIXNvY2tldEluKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldEluID0gdGhpcy5fY3JlYXRlTmV3U29ja2V0Q29ubmVjdGlvbihub2RlSW5Tb2NrZXROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRCbG9jay5zaWduYWxJbnB1dHMucHVzaChzb2NrZXRJbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdGhlIHNvY2tldHNcbiAgICAgICAgICAgICAgICBzb2NrZXRJbi5jb25uZWN0ZWRQb2ludElkcy5wdXNoKHNvY2tldE91dC51bmlxdWVJZCk7XG4gICAgICAgICAgICAgICAgc29ja2V0T3V0LmNvbm5lY3RlZFBvaW50SWRzLnB1c2goc29ja2V0SW4udW5pcXVlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29ubmVjdCB0aGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNGcm9tR0xURiA9IGdsdGZOb2RlLnZhbHVlcyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc0tleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXNGcm9tR0xURik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlS2V5IG9mIHZhbHVlc0tleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc0Zyb21HTFRGW3ZhbHVlS2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVNYXBwaW5nID0gb3V0cHV0TWFwcGVyLmZsb3dHcmFwaE1hcHBpbmcuaW5wdXRzPy52YWx1ZXM/Llt2YWx1ZUtleV07XG4gICAgICAgICAgICAgICAgbGV0IGFycmF5TWFwcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWVNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG91dHB1dE1hcHBlci5mbG93R3JhcGhNYXBwaW5nLmlucHV0cz8udmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGtleS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU1hcHBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTWFwcGluZyA9IG91dHB1dE1hcHBlci5mbG93R3JhcGhNYXBwaW5nLmlucHV0cz8udmFsdWVzPy5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXRJbk5hbWUgPSB2YWx1ZU1hcHBpbmcgPyAoYXJyYXlNYXBwaW5nID8gdmFsdWVNYXBwaW5nLm5hbWUucmVwbGFjZShcIiQxXCIsIHZhbHVlS2V5KSA6IHZhbHVlTWFwcGluZy5uYW1lKSA6IHZhbHVlS2V5O1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHNlcmlhbGl6ZWQgc29ja2V0XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0SW4gPSB0aGlzLl9jcmVhdGVOZXdTb2NrZXRDb25uZWN0aW9uKHNvY2tldEluTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSAodmFsdWVNYXBwaW5nICYmIHZhbHVlTWFwcGluZy50b0Jsb2NrICYmIGZsb3dHcmFwaEJsb2Nrcy5ibG9ja3MuZmluZCgoYikgPT4gYi5jbGFzc05hbWUgPT09IHZhbHVlTWFwcGluZy50b0Jsb2NrKSkgfHwgZmxvd0dyYXBoQmxvY2tzLmJsb2Nrc1swXTtcbiAgICAgICAgICAgICAgICBibG9jay5kYXRhSW5wdXRzLnB1c2goc29ja2V0SW4pO1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgYXMgSUtIUkludGVyYWN0aXZpdHlfVmFyaWFibGUpLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSB0aGlzLl9wYXJzZVZhcmlhYmxlKHZhbHVlIGFzIElLSFJJbnRlcmFjdGl2aXR5X1ZhcmlhYmxlLCB2YWx1ZU1hcHBpbmcgJiYgdmFsdWVNYXBwaW5nLmRhdGFUcmFuc2Zvcm1lcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2Nvbm5lY3Rpb25WYWx1ZXNbc29ja2V0SW4udW5pcXVlSWRdID0gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHZhbHVlIGFzIElLSFJJbnRlcmFjdGl2aXR5X091dHB1dFNvY2tldFJlZmVyZW5jZSkubm9kZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlT3V0SWQgPSAodmFsdWUgYXMgSUtIUkludGVyYWN0aXZpdHlfT3V0cHV0U29ja2V0UmVmZXJlbmNlKS5ub2RlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlT3V0U29ja2V0TmFtZSA9ICh2YWx1ZSBhcyBJS0hSSW50ZXJhY3Rpdml0eV9PdXRwdXRTb2NrZXRSZWZlcmVuY2UpLnNvY2tldCB8fCBcInZhbHVlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVPdXQgPSB0aGlzLl9ub2Rlc1tub2RlT3V0SWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJObyBub2RlIGZvdW5kIGZvciBvdXRwdXQgc29ja2V0IHJlZmVyZW5jZVwiLCB2YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBub2RlIGNvbm5lY3Rpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dE1hcHBlciA9IGdldE1hcHBpbmdGb3JGdWxsT3BlcmF0aW9uTmFtZShub2RlT3V0LmZ1bGxPcGVyYXRpb25OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRwdXRNYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJObyBtYXBwaW5nIGZvdW5kIGZvciBvdXRwdXQgc29ja2V0IHJlZmVyZW5jZVwiLCB2YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBub2RlIGNvbm5lY3Rpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZU1hcHBpbmcgPSBvdXRwdXRNYXBwZXIub3V0cHV0cz8udmFsdWVzPy5bbm9kZU91dFNvY2tldE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJyYXlNYXBwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIGFycmF5IG1hcHBpbmcgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBhIHZhbHVlIG1hcHBpbmcgdGhhdCBoYXMgYW4gYXJyYXkgbWFwcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3V0cHV0TWFwcGVyLm91dHB1dHM/LnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIltcIikgJiYga2V5LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU1hcHBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZU1hcHBpbmcgPSBvdXRwdXRNYXBwZXIub3V0cHV0cz8udmFsdWVzPy5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0T3V0TmFtZSA9IHZhbHVlTWFwcGluZyA/IChhcnJheU1hcHBpbmcgPyB2YWx1ZU1hcHBpbmcubmFtZS5yZXBsYWNlKFwiJDFcIiwgbm9kZU91dFNvY2tldE5hbWUpIDogdmFsdWVNYXBwaW5nPy5uYW1lKSA6IG5vZGVPdXRTb2NrZXROYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRCbG9jayA9ICh2YWx1ZU1hcHBpbmcgJiYgdmFsdWVNYXBwaW5nLnRvQmxvY2sgJiYgbm9kZU91dC5ibG9ja3MuZmluZCgoYikgPT4gYi5jbGFzc05hbWUgPT09IHZhbHVlTWFwcGluZy50b0Jsb2NrKSkgfHwgbm9kZU91dC5ibG9ja3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzb2NrZXRPdXQgPSBvdXRCbG9jay5kYXRhT3V0cHV0cy5maW5kKChzKSA9PiBzLm5hbWUgPT09IHNvY2tldE91dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc29ja2V0IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNvY2tldE91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0T3V0ID0gdGhpcy5fY3JlYXRlTmV3U29ja2V0Q29ubmVjdGlvbihzb2NrZXRPdXROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dEJsb2NrLmRhdGFPdXRwdXRzLnB1c2goc29ja2V0T3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRoZSBzb2NrZXRzXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldEluLmNvbm5lY3RlZFBvaW50SWRzLnB1c2goc29ja2V0T3V0LnVuaXF1ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0T3V0LmNvbm5lY3RlZFBvaW50SWRzLnB1c2goc29ja2V0SW4udW5pcXVlSWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJJbnZhbGlkIHZhbHVlIGZvciB2YWx1ZSBjb25uZWN0aW9uXCIsIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgbm9kZSBjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGludGVyIGJsb2NrIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBpZiAob3V0cHV0TWFwcGVyLmZsb3dHcmFwaE1hcHBpbmcuaW50ZXJCbG9ja0Nvbm5lY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3RvciBvZiBvdXRwdXRNYXBwZXIuZmxvd0dyYXBoTWFwcGluZy5pbnRlckJsb2NrQ29ubmVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNvbm5lY3Rvci5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gY29ubmVjdG9yLm91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYXJpYWJsZSA9IGNvbm5lY3Rvci5pc1ZhcmlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0Rmxvd0dyYXBoTm9kZXMoaW5wdXQsIG91dHB1dCwgZmxvd0dyYXBoQmxvY2tzLmJsb2Nrc1tjb25uZWN0b3IuaW5wdXRCbG9ja0luZGV4XSwgZmxvd0dyYXBoQmxvY2tzLmJsb2Nrc1tjb25uZWN0b3Iub3V0cHV0QmxvY2tJbmRleF0sIGlzVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG91dHB1dE1hcHBlci5mbG93R3JhcGhNYXBwaW5nLmV4dHJhUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLl9pbnRlcmFjdGl2aXR5R3JhcGguZGVjbGFyYXRpb25zPy5bZ2x0Zk5vZGUuZGVjbGFyYXRpb25dO1xuICAgICAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFtcIk5vIGRlY2xhcmF0aW9uIGZvdW5kIGZvciBleHRyYSBwcm9jZXNzb3JcIiwgZ2x0Zk5vZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBub2RlIGNvbm5lY3Rpb25zXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbG93R3JhcGhCbG9ja3MuYmxvY2tzID0gb3V0cHV0TWFwcGVyLmZsb3dHcmFwaE1hcHBpbmcuZXh0cmFQcm9jZXNzb3IoXG4gICAgICAgICAgICAgICAgICAgIGdsdGZOb2RlLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0TWFwcGVyLmZsb3dHcmFwaE1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGZsb3dHcmFwaEJsb2Nrcy5ibG9ja3MsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsdGZcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY3JlYXRlTmV3U29ja2V0Q29ubmVjdGlvbihuYW1lOiBzdHJpbmcsIGlzT3V0cHV0PzogYm9vbGVhbik6IElTZXJpYWxpemVkRmxvd0dyYXBoQ29ubmVjdGlvbiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bmlxdWVJZDogUmFuZG9tR1VJRCgpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIF9jb25uZWN0aW9uVHlwZTogaXNPdXRwdXQgPyBGbG93R3JhcGhDb25uZWN0aW9uVHlwZS5PdXRwdXQgOiBGbG93R3JhcGhDb25uZWN0aW9uVHlwZS5JbnB1dCxcbiAgICAgICAgICAgIGNvbm5lY3RlZFBvaW50SWRzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jb25uZWN0Rmxvd0dyYXBoTm9kZXMoaW5wdXQ6IHN0cmluZywgb3V0cHV0OiBzdHJpbmcsIHNlcmlhbGl6ZWRJbnB1dDogSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9jaywgc2VyaWFsaXplZE91dHB1dDogSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9jaywgaXNWYXJpYWJsZT86IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgaW5wdXRBcnJheSA9IGlzVmFyaWFibGUgPyBzZXJpYWxpemVkSW5wdXQuZGF0YUlucHV0cyA6IHNlcmlhbGl6ZWRJbnB1dC5zaWduYWxJbnB1dHM7XG4gICAgICAgIGNvbnN0IG91dHB1dEFycmF5ID0gaXNWYXJpYWJsZSA/IHNlcmlhbGl6ZWRPdXRwdXQuZGF0YU91dHB1dHMgOiBzZXJpYWxpemVkT3V0cHV0LnNpZ25hbE91dHB1dHM7XG4gICAgICAgIGNvbnN0IGlucHV0Q29ubmVjdGlvbiA9IGlucHV0QXJyYXkuZmluZCgocykgPT4gcy5uYW1lID09PSBpbnB1dCkgfHwgdGhpcy5fY3JlYXRlTmV3U29ja2V0Q29ubmVjdGlvbihpbnB1dCk7XG4gICAgICAgIGNvbnN0IG91dHB1dENvbm5lY3Rpb24gPSBvdXRwdXRBcnJheS5maW5kKChzKSA9PiBzLm5hbWUgPT09IG91dHB1dCkgfHwgdGhpcy5fY3JlYXRlTmV3U29ja2V0Q29ubmVjdGlvbihvdXRwdXQsIHRydWUpO1xuICAgICAgICAvLyBvZiBub3QgZm91bmQgYWRkIGl0IHRvIHRoZSBhcnJheVxuICAgICAgICBpZiAoIWlucHV0QXJyYXkuZmluZCgocykgPT4gcy5uYW1lID09PSBpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0QXJyYXkucHVzaChpbnB1dENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3V0cHV0QXJyYXkuZmluZCgocykgPT4gcy5uYW1lID09PSBvdXRwdXQpKSB7XG4gICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKG91dHB1dENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbm5lY3QgdGhlIHNvY2tldHNcbiAgICAgICAgaW5wdXRDb25uZWN0aW9uLmNvbm5lY3RlZFBvaW50SWRzLnB1c2gob3V0cHV0Q29ubmVjdGlvbi51bmlxdWVJZCk7XG4gICAgICAgIG91dHB1dENvbm5lY3Rpb24uY29ubmVjdGVkUG9pbnRJZHMucHVzaChpbnB1dENvbm5lY3Rpb24udW5pcXVlSWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRWYXJpYWJsZU5hbWUoaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gXCJzdGF0aWNWYXJpYWJsZV9cIiArIGluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemVUb0Zsb3dHcmFwaCgpOiBJU2VyaWFsaXplZEZsb3dHcmFwaCB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQ6IElTZXJpYWxpemVkRmxvd0dyYXBoQ29udGV4dCA9IHtcbiAgICAgICAgICAgIHVuaXF1ZUlkOiBSYW5kb21HVUlEKCksXG4gICAgICAgICAgICBfdXNlclZhcmlhYmxlczoge30sXG4gICAgICAgICAgICBfY29ubmVjdGlvblZhbHVlczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhcnNlTm9kZUNvbm5lY3Rpb25zKGNvbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0YXRpY1ZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLl9zdGF0aWNWYXJpYWJsZXNbaV07XG4gICAgICAgICAgICBjb250ZXh0Ll91c2VyVmFyaWFibGVzW3RoaXMuZ2V0VmFyaWFibGVOYW1lKGkpXSA9IHZhcmlhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxsQmxvY2tzID0gdGhpcy5fbm9kZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwuYmxvY2tzKSwgW10gYXMgSVNlcmlhbGl6ZWRGbG93R3JhcGhCbG9ja1tdKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmlnaHRIYW5kZWQ6IHRydWUsXG4gICAgICAgICAgICBhbGxCbG9ja3MsXG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0czogW2NvbnRleHRdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xyXG5pbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XHJcbmltcG9ydCB7IENvbG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgRGlyZWN0aW9uYWxMaWdodCB9IGZyb20gXCJjb3JlL0xpZ2h0cy9kaXJlY3Rpb25hbExpZ2h0XCI7XHJcbmltcG9ydCB7IFBvaW50TGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvcG9pbnRMaWdodFwiO1xyXG5pbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvc3BvdExpZ2h0XCI7XHJcbmltcG9ydCB7IExpZ2h0IH0gZnJvbSBcImNvcmUvTGlnaHRzL2xpZ2h0XCI7XHJcbmltcG9ydCB0eXBlIHsgVHJhbnNmb3JtTm9kZSB9IGZyb20gXCJjb3JlL01lc2hlcy90cmFuc2Zvcm1Ob2RlXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodFJlZmVyZW5jZSB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHRUeXBlIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgdHlwZSB7IElOb2RlLCBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIsIEFycmF5SXRlbSB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX2xpZ2h0c19wdW5jdHVhbCBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiS0hSX2xpZ2h0c19wdW5jdHVhbFwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9saWdodHNfcHVuY3R1YWwvUkVBRE1FLm1kKVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX2xpZ2h0cyBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogaGlkZGVuICovXHJcbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XHJcbiAgICBwcml2YXRlIF9saWdodHM/OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHRbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9saWdodHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIG9uTG9hZGluZygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5fbG9hZGVyLmdsdGYuZXh0ZW5zaW9ucztcclxuICAgICAgICBpZiAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zW3RoaXMubmFtZV0pIHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLl9saWdodHMgPSBleHRlbnNpb24ubGlnaHRzO1xyXG4gICAgICAgICAgICBBcnJheUl0ZW0uQXNzaWduKHRoaXMuX2xpZ2h0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWROb2RlQXN5bmMoY29udGV4dDogc3RyaW5nLCBub2RlOiBJTm9kZSwgYXNzaWduOiAoYmFieWxvblRyYW5zZm9ybU5vZGU6IFRyYW5zZm9ybU5vZGUpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPFRyYW5zZm9ybU5vZGU+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJMaWdodHNQdW5jdHVhbF9MaWdodFJlZmVyZW5jZSwgVHJhbnNmb3JtTm9kZT4oY29udGV4dCwgbm9kZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5fYWxsTWF0ZXJpYWxzRGlydHlSZXF1aXJlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZGVyLmxvYWROb2RlQXN5bmMoY29udGV4dCwgbm9kZSwgKGJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmFieWxvbkxpZ2h0OiBMaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaWdodCA9IEFycmF5SXRlbS5HZXQoZXh0ZW5zaW9uQ29udGV4dCwgdGhpcy5fbGlnaHRzLCBleHRlbnNpb24ubGlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGxpZ2h0Lm5hbWUgfHwgYmFieWxvbk1lc2gubmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIXRoaXMuX2xvYWRlci5fYXNzZXRDb250YWluZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChsaWdodC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLSFJMaWdodHNQdW5jdHVhbF9MaWdodFR5cGUuRElSRUNUSU9OQUw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFieWxvbkRpcmVjdGlvbmFsTGlnaHQgPSBuZXcgRGlyZWN0aW9uYWxMaWdodChuYW1lLCBWZWN0b3IzLkJhY2t3YXJkKCksIHRoaXMuX2xvYWRlci5iYWJ5bG9uU2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uRGlyZWN0aW9uYWxMaWdodC5wb3NpdGlvbi5zZXRBbGwoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25MaWdodCA9IGJhYnlsb25EaXJlY3Rpb25hbExpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLSFJMaWdodHNQdW5jdHVhbF9MaWdodFR5cGUuUE9JTlQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbkxpZ2h0ID0gbmV3IFBvaW50TGlnaHQobmFtZSwgVmVjdG9yMy5aZXJvKCksIHRoaXMuX2xvYWRlci5iYWJ5bG9uU2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLSFJMaWdodHNQdW5jdHVhbF9MaWdodFR5cGUuU1BPVDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uU3BvdExpZ2h0ID0gbmV3IFNwb3RMaWdodChuYW1lLCBWZWN0b3IzLlplcm8oKSwgVmVjdG9yMy5CYWNrd2FyZCgpLCAwLCAxLCB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvblNwb3RMaWdodC5hbmdsZSA9ICgobGlnaHQuc3BvdCAmJiBsaWdodC5zcG90Lm91dGVyQ29uZUFuZ2xlKSB8fCBNYXRoLlBJIC8gNCkgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uU3BvdExpZ2h0LmlubmVyQW5nbGUgPSAoKGxpZ2h0LnNwb3QgJiYgbGlnaHQuc3BvdC5pbm5lckNvbmVBbmdsZSkgfHwgMCkgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTGlnaHQgPSBiYWJ5bG9uU3BvdExpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V4dGVuc2lvbkNvbnRleHR9OiBJbnZhbGlkIGxpZ2h0IHR5cGUgKCR7bGlnaHQudHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJhYnlsb25MaWdodC5fcGFyZW50Q29udGFpbmVyID0gdGhpcy5fbG9hZGVyLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGlnaHQuX2JhYnlsb25MaWdodCA9IGJhYnlsb25MaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTGlnaHQuZmFsbG9mZlR5cGUgPSBMaWdodC5GQUxMT0ZGX0dMVEY7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTGlnaHQuZGlmZnVzZSA9IGxpZ2h0LmNvbG9yID8gQ29sb3IzLkZyb21BcnJheShsaWdodC5jb2xvcikgOiBDb2xvcjMuV2hpdGUoKTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25MaWdodC5pbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHkgPT0gdW5kZWZpbmVkID8gMSA6IGxpZ2h0LmludGVuc2l0eTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25MaWdodC5yYW5nZSA9IGxpZ2h0LnJhbmdlID09IHVuZGVmaW5lZCA/IE51bWJlci5NQVhfVkFMVUUgOiBsaWdodC5yYW5nZTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25MaWdodC5wYXJlbnQgPSBiYWJ5bG9uTWVzaDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuX2JhYnlsb25MaWdodHMucHVzaChiYWJ5bG9uTGlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXIuQWRkUG9pbnRlck1ldGFkYXRhKGJhYnlsb25MaWdodCwgZXh0ZW5zaW9uQ29udGV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9saWdodHMobG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBQQlJNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9QQlIvcGJyTWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwsIElUZXh0dXJlSW5mbyB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUk1hdGVyaWFsc0FuaXNvdHJvcHkgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHlcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHkgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl9tYXRlcmlhbHNfYW5pc290cm9weVwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfYW5pc290cm9weSlcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEtIUl9tYXRlcmlhbHNfYW5pc290cm9weSBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBvcmRlciB0aGUgZXh0ZW5zaW9ucyBhcmUgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9yZGVyID0gMTk1O1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJNYXRlcmlhbHNBbmlzb3Ryb3B5Pihjb250ZXh0LCBtYXRlcmlhbCwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkSXJpZGVzY2VuY2VQcm9wZXJ0aWVzQXN5bmMoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX2xvYWRJcmlkZXNjZW5jZVByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIHByb3BlcnRpZXM6IElLSFJNYXRlcmlhbHNBbmlzb3Ryb3B5LCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5hbmlzb3Ryb3B5LmlzRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5hbmlzb3Ryb3B5LmludGVuc2l0eSA9IHByb3BlcnRpZXMuYW5pc290cm9weVN0cmVuZ3RoID8/IDA7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFuaXNvdHJvcHkuYW5nbGUgPSBwcm9wZXJ0aWVzLmFuaXNvdHJvcHlSb3RhdGlvbiA/PyAwO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5hbmlzb3Ryb3B5VGV4dHVyZSkge1xyXG4gICAgICAgICAgICAocHJvcGVydGllcy5hbmlzb3Ryb3B5VGV4dHVyZSBhcyBJVGV4dHVyZUluZm8pLm5vbkNvbG9yRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vYW5pc290cm9weVRleHR1cmVgLCBwcm9wZXJ0aWVzLmFuaXNvdHJvcHlUZXh0dXJlLCAodGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoQW5pc290cm9weSBJbnRlbnNpdHkpYDtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYW5pc290cm9weS50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9tYXRlcmlhbHNfYW5pc290cm9weShsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElNYXRlcmlhbCwgSVRleHR1cmVJbmZvIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJS0hSTWF0ZXJpYWxzQ2xlYXJjb2F0IH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21haW4vZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdC9SRUFETUUubWQpXHJcbiAqIFtQbGF5Z3JvdW5kIFNhbXBsZV0oaHR0cHM6Ly93d3cuYmFieWxvbmpzLXBsYXlncm91bmQuY29tL2ZyYW1lLmh0bWwjN0Y3UE42IzgpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBvcmRlciB0aGUgZXh0ZW5zaW9ucyBhcmUgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9yZGVyID0gMTkwO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJNYXRlcmlhbHNDbGVhcmNvYXQ+KGNvbnRleHQsIG1hdGVyaWFsLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxhbnk+PigpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRlci5sb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dCwgbWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRDbGVhckNvYXRQcm9wZXJ0aWVzQXN5bmMoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRDbGVhckNvYXRQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBwcm9wZXJ0aWVzOiBJS0hSTWF0ZXJpYWxzQ2xlYXJjb2F0LCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5jbGVhckNvYXQuaXNFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuY2xlYXJDb2F0LnVzZVJvdWdobmVzc0Zyb21NYWluVGV4dHVyZSA9IGZhbHNlO1xyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5jbGVhckNvYXQucmVtYXBGME9uSW50ZXJmYWNlQ2hhbmdlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNsZWFyY29hdEZhY3RvciAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmNsZWFyQ29hdC5pbnRlbnNpdHkgPSBwcm9wZXJ0aWVzLmNsZWFyY29hdEZhY3RvcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuY2xlYXJDb2F0LmludGVuc2l0eSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5jbGVhcmNvYXRUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vY2xlYXJjb2F0VGV4dHVyZWAsIHByb3BlcnRpZXMuY2xlYXJjb2F0VGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKENsZWFyQ29hdClgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5jbGVhckNvYXQudGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuY2xlYXJDb2F0LnJvdWdobmVzcyA9IHByb3BlcnRpZXMuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5jbGVhckNvYXQucm91Z2huZXNzID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgKHByb3BlcnRpZXMuY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSBhcyBJVGV4dHVyZUluZm8pLm5vbkNvbG9yRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZWAsIHByb3BlcnRpZXMuY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKENsZWFyQ29hdCBSb3VnaG5lc3MpYDtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuY2xlYXJDb2F0LnRleHR1cmVSb3VnaG5lc3MgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNsZWFyY29hdE5vcm1hbFRleHR1cmUpIHtcclxuICAgICAgICAgICAgKHByb3BlcnRpZXMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSBhcyBJVGV4dHVyZUluZm8pLm5vbkNvbG9yRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZWAsIHByb3BlcnRpZXMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKENsZWFyQ29hdCBOb3JtYWwpYDtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuY2xlYXJDb2F0LmJ1bXBUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuaW52ZXJ0Tm9ybWFsTWFwWCA9ICFiYWJ5bG9uTWF0ZXJpYWwuZ2V0U2NlbmUoKS51c2VSaWdodEhhbmRlZFN5c3RlbTtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmludmVydE5vcm1hbE1hcFkgPSBiYWJ5bG9uTWF0ZXJpYWwuZ2V0U2NlbmUoKS51c2VSaWdodEhhbmRlZFN5c3RlbTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5jbGVhckNvYXQuYnVtcFRleHR1cmUhLmxldmVsID0gcHJvcGVydGllcy5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdChsb2FkZXIpKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgZ2l0aHViL25vLXRoZW4gKi9cclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwsIElUZXh0dXJlSW5mbyB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUk1hdGVyaWFsc0RpZmZ1c2VUcmFuc21pc3Npb24gfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IENvbG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIktIUl9tYXRlcmlhbHNfZGlmZnVzZV90cmFuc21pc3Npb25cIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtQcm9wb3NlZCBTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvcHVsbC8xODI1KVxyXG4gKiAhISEgRXhwZXJpbWVudGFsIEV4dGVuc2lvbiBTdWJqZWN0IHRvIENoYW5nZXMgISEhXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxNzQ7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgbG9hZGVyLnBhcmVudC50cmFuc3BhcmVuY3lBc0NvdmVyYWdlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgKHRoaXMuX2xvYWRlciBhcyBhbnkpID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJS0hSTWF0ZXJpYWxzRGlmZnVzZVRyYW5zbWlzc2lvbj4oY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZGVyLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZFRyYW5zbHVjZW50UHJvcGVydGllc0FzeW5jKGV4dGVuc2lvbkNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwsIGV4dGVuc2lvbikpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcclxuICAgIHByaXZhdGUgX2xvYWRUcmFuc2x1Y2VudFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwsIGV4dGVuc2lvbjogSUtIUk1hdGVyaWFsc0RpZmZ1c2VUcmFuc21pc3Npb24pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIShiYWJ5bG9uTWF0ZXJpYWwgaW5zdGFuY2VvZiBQQlJNYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBNYXRlcmlhbCB0eXBlIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBick1hdGVyaWFsID0gYmFieWxvbk1hdGVyaWFsO1xyXG5cclxuICAgICAgICAvLyBFbmFibGVzIFwidHJhbnNsdWNlbmN5XCIgdGV4dHVyZSB3aGljaCByZXByZXNlbnRzIGRpZmZ1c2VseS10cmFuc21pdHRlZCBsaWdodC5cclxuICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLmlzVHJhbnNsdWNlbmN5RW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFNpbmNlIHRoaXMgZXh0ZW5zaW9uIG1vZGVscyB0aGluLXN1cmZhY2UgdHJhbnNtaXNzaW9uIG9ubHksIHdlIG11c3QgbWFrZSB0aGVcclxuICAgICAgICAvLyBpbnRlcm5hbCBJT1IgPT0gMS4wIGFuZCBzZXQgdGhlIHRoaWNrbmVzcyB0byAwLlxyXG4gICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2Uudm9sdW1lSW5kZXhPZlJlZnJhY3Rpb24gPSAxLjA7XHJcbiAgICAgICAgcGJyTWF0ZXJpYWwuc3ViU3VyZmFjZS5taW5pbXVtVGhpY2tuZXNzID0gMC4wO1xyXG4gICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2UubWF4aW11bVRoaWNrbmVzcyA9IDAuMDtcclxuXHJcbiAgICAgICAgLy8gVGludCBjb2xvciB3aWxsIGJlIHVzZWQgZm9yIHRyYW5zbWlzc2lvbi5cclxuICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnVzZUFsYmVkb1RvVGludFRyYW5zbHVjZW5jeSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoZXh0ZW5zaW9uLmRpZmZ1c2VUcmFuc21pc3Npb25GYWN0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUludGVuc2l0eSA9IGV4dGVuc2lvbi5kaWZmdXNlVHJhbnNtaXNzaW9uRmFjdG9yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2UudHJhbnNsdWNlbmN5SW50ZW5zaXR5ID0gMC4wO1xyXG4gICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLmlzVHJhbnNsdWNlbmN5RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2UudXNlR2x0ZlN0eWxlVGV4dHVyZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoZXh0ZW5zaW9uLmRpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIChleHRlbnNpb24uZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmUgYXMgSVRleHR1cmVJbmZvKS5ub25Db2xvckRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvYWRUZXh0dXJlSW5mb0FzeW5jKGAke2NvbnRleHR9L2RpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlYCwgZXh0ZW5zaW9uLmRpZmZ1c2VUcmFuc21pc3Npb25UZXh0dXJlKS50aGVuKCh0ZXh0dXJlOiBCYXNlVGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoRGlmZnVzZSBUcmFuc21pc3Npb24pYDtcclxuICAgICAgICAgICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUludGVuc2l0eVRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHRlbnNpb24uZGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yRmFjdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcGJyTWF0ZXJpYWwuc3ViU3VyZmFjZS50cmFuc2x1Y2VuY3lDb2xvciA9IENvbG9yMy5Gcm9tQXJyYXkoZXh0ZW5zaW9uLmRpZmZ1c2VUcmFuc21pc3Npb25Db2xvckZhY3Rvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGJyTWF0ZXJpYWwuc3ViU3VyZmFjZS50cmFuc2x1Y2VuY3lDb2xvciA9IENvbG9yMy5XaGl0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5kaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vZGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yVGV4dHVyZWAsIGV4dGVuc2lvbi5kaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlKS50aGVuKCh0ZXh0dXJlOiBCYXNlVGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoRGlmZnVzZSBUcmFuc21pc3Npb24gQ29sb3IpYDtcclxuICAgICAgICAgICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUNvbG9yVGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgS0hSX21hdGVyaWFsc19kaWZmdXNlX3RyYW5zbWlzc2lvbihsb2FkZXIpKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBQQlJNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9QQlIvcGJyTWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IElNYXRlcmlhbCB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUk1hdGVyaWFsc0Rpc3BlcnNpb24gfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb25cIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb24gZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl9tYXRlcmlhbHNfZGlzcGVyc2lvblwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvODdiZDY0YTdmNWUyM2M4NGI2YWVmMmU2MDgyMDY5NTgzZWQwZGRiNC9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfZGlzcGVyc2lvbi9SRUFETUUubWQpXHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEtIUl9tYXRlcmlhbHNfZGlzcGVyc2lvbiBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBvcmRlciB0aGUgZXh0ZW5zaW9ucyBhcmUgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9yZGVyID0gMTc0O1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJNYXRlcmlhbHNEaXNwZXJzaW9uPihjb250ZXh0LCBtYXRlcmlhbCwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkRGlzcGVyc2lvblByb3BlcnRpZXNBc3luYyhleHRlbnNpb25Db250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsLCBleHRlbnNpb24pKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZERpc3BlcnNpb25Qcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsLCBleHRlbnNpb246IElLSFJNYXRlcmlhbHNEaXNwZXJzaW9uKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0cmFuc3BhcmVuY3kgaXNuJ3QgZW5hYmxlZCBhbHJlYWR5LCB0aGlzIGV4dGVuc2lvbiBzaG91bGRuJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAgLy8gaS5lLiBpdCByZXF1aXJlcyBlaXRoZXIgdGhlIEtIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uIG9yIEtIUl9tYXRlcmlhbHNfZGlmZnVzZV90cmFuc21pc3Npb24gZXh0ZW5zaW9ucy5cclxuICAgICAgICBpZiAoIWJhYnlsb25NYXRlcmlhbC5zdWJTdXJmYWNlLmlzUmVmcmFjdGlvbkVuYWJsZWQgfHwgIWV4dGVuc2lvbi5kaXNwZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnN1YlN1cmZhY2UuaXNEaXNwZXJzaW9uRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnN1YlN1cmZhY2UuZGlzcGVyc2lvbiA9IGV4dGVuc2lvbi5kaXNwZXJzaW9uO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgS0hSX21hdGVyaWFsc19kaXNwZXJzaW9uKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHsgUEJSTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvUEJSL3Bick1hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgSU1hdGVyaWFsIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJS0hSTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aCB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGhcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aC9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxNzA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUtIUk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGg+KGNvbnRleHQsIG1hdGVyaWFsLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEVtaXNzaXZlUHJvcGVydGllcyhleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24sIGJhYnlsb25NYXRlcmlhbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRFbWlzc2l2ZVByb3BlcnRpZXMoY29udGV4dDogc3RyaW5nLCBwcm9wZXJ0aWVzOiBJS0hSTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghKGJhYnlsb25NYXRlcmlhbCBpbnN0YW5jZW9mIFBCUk1hdGVyaWFsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06IE1hdGVyaWFsIHR5cGUgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuZW1pc3NpdmVTdHJlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IHByb3BlcnRpZXMuZW1pc3NpdmVTdHJlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGgobG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgeyBQQlJNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9QQlIvcGJyTWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElLSFJNYXRlcmlhbHNJb3IgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbWF0ZXJpYWxzX2lvclwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEtIUl9tYXRlcmlhbHNfaW9yIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWF0ZXJpYWxzX2lvclwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfaW9yL1JFQURNRS5tZClcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEtIUl9tYXRlcmlhbHNfaW9yIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGlvciBWYWx1ZSBmcm9tIHRoZSBzcGVjLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBfREVGQVVMVF9JT1IgPSAxLjU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxODA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUtIUk1hdGVyaWFsc0lvcj4oY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZGVyLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZElvclByb3BlcnRpZXNBc3luYyhleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24sIGJhYnlsb25NYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9sb2FkSW9yUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgcHJvcGVydGllczogSUtIUk1hdGVyaWFsc0lvciwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICghKGJhYnlsb25NYXRlcmlhbCBpbnN0YW5jZW9mIFBCUk1hdGVyaWFsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06IE1hdGVyaWFsIHR5cGUgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuaW9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmluZGV4T2ZSZWZyYWN0aW9uID0gcHJvcGVydGllcy5pb3I7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmluZGV4T2ZSZWZyYWN0aW9uID0gS0hSX21hdGVyaWFsc19pb3IuX0RFRkFVTFRfSU9SO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX2lvcihsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElNYXRlcmlhbCB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUk1hdGVyaWFsc0lyaWRlc2NlbmNlIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZVwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEtIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2UgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21haW4vZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlL1JFQURNRS5tZClcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEtIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2UgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGEgbnVtYmVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgb3JkZXIgdGhlIGV4dGVuc2lvbnMgYXJlIGFwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvcmRlciA9IDE5NTtcclxuXHJcbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyOiBHTFRGTG9hZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuX2xvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgKHRoaXMuX2xvYWRlciBhcyBhbnkpID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJS0hSTWF0ZXJpYWxzSXJpZGVzY2VuY2U+KGNvbnRleHQsIG1hdGVyaWFsLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxhbnk+PigpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRlci5sb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dCwgbWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRJcmlkZXNjZW5jZVByb3BlcnRpZXNBc3luYyhleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24sIGJhYnlsb25NYXRlcmlhbCkpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9sb2FkSXJpZGVzY2VuY2VQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBwcm9wZXJ0aWVzOiBJS0hSTWF0ZXJpYWxzSXJpZGVzY2VuY2UsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIShiYWJ5bG9uTWF0ZXJpYWwgaW5zdGFuY2VvZiBQQlJNYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBNYXRlcmlhbCB0eXBlIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuXHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLmlyaWRlc2NlbmNlLmlzRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5pcmlkZXNjZW5jZS5pbnRlbnNpdHkgPSBwcm9wZXJ0aWVzLmlyaWRlc2NlbmNlRmFjdG9yID8/IDA7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLmlyaWRlc2NlbmNlLmluZGV4T2ZSZWZyYWN0aW9uID0gcHJvcGVydGllcy5pcmlkZXNjZW5jZUlvciA/PyAocHJvcGVydGllcyBhcyBhbnkpLmlyaWRlc2NlbmNlSU9SID8/IDEuMztcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuaXJpZGVzY2VuY2UubWluaW11bVRoaWNrbmVzcyA9IHByb3BlcnRpZXMuaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtID8/IDEwMDtcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuaXJpZGVzY2VuY2UubWF4aW11bVRoaWNrbmVzcyA9IHByb3BlcnRpZXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtID8/IDQwMDtcclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuaXJpZGVzY2VuY2VUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vaXJpZGVzY2VuY2VUZXh0dXJlYCwgcHJvcGVydGllcy5pcmlkZXNjZW5jZVRleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uYW1lID0gYCR7YmFieWxvbk1hdGVyaWFsLm5hbWV9IChJcmlkZXNjZW5jZSlgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5pcmlkZXNjZW5jZS50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmVgLCBwcm9wZXJ0aWVzLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKElyaWRlc2NlbmNlIFRoaWNrbmVzcylgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5pcmlkZXNjZW5jZS50aGlja25lc3NUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHsgQ29sb3IzIH0gZnJvbSBcImNvcmUvTWF0aHMvbWF0aC5jb2xvclwiO1xyXG5pbXBvcnQgeyBQQlJNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9QQlIvcGJyTWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBNYXRlcmlhbCB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9tYXRlcmlhbFwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElLSFJNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3MgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1wiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEtIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1wiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9BcmNoaXZlZC9LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcy9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcyBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBvcmRlciB0aGUgZXh0ZW5zaW9ucyBhcmUgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9yZGVyID0gMjAwO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3M+KGNvbnRleHQsIG1hdGVyaWFsLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxhbnk+PigpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRlci5sb2FkTWF0ZXJpYWxCYXNlUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkU3BlY3VsYXJHbG9zc2luZXNzUHJvcGVydGllc0FzeW5jKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbiwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkTWF0ZXJpYWxBbHBoYVByb3BlcnRpZXMoY29udGV4dCwgbWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRTcGVjdWxhckdsb3NzaW5lc3NQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBwcm9wZXJ0aWVzOiBJS0hSTWF0ZXJpYWxzUGJyU3BlY3VsYXJHbG9zc2luZXNzLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5tZXRhbGxpYyA9IG51bGw7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnJvdWdobmVzcyA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmRpZmZ1c2VGYWN0b3IpIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb0NvbG9yID0gQ29sb3IzLkZyb21BcnJheShwcm9wZXJ0aWVzLmRpZmZ1c2VGYWN0b3IpO1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYWxwaGEgPSBwcm9wZXJ0aWVzLmRpZmZ1c2VGYWN0b3JbM107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb0NvbG9yID0gQ29sb3IzLldoaXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwucmVmbGVjdGl2aXR5Q29sb3IgPSBwcm9wZXJ0aWVzLnNwZWN1bGFyRmFjdG9yID8gQ29sb3IzLkZyb21BcnJheShwcm9wZXJ0aWVzLnNwZWN1bGFyRmFjdG9yKSA6IENvbG9yMy5XaGl0ZSgpO1xyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5taWNyb1N1cmZhY2UgPSBwcm9wZXJ0aWVzLmdsb3NzaW5lc3NGYWN0b3IgPT0gdW5kZWZpbmVkID8gMSA6IHByb3BlcnRpZXMuZ2xvc3NpbmVzc0ZhY3RvcjtcclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuZGlmZnVzZVRleHR1cmUpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9kaWZmdXNlVGV4dHVyZWAsIHByb3BlcnRpZXMuZGlmZnVzZVRleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uYW1lID0gYCR7YmFieWxvbk1hdGVyaWFsLm5hbWV9IChEaWZmdXNlKWA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb1RleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlYCwgcHJvcGVydGllcy5zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlLCAodGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoU3BlY3VsYXIgR2xvc3NpbmVzcylgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5yZWZsZWN0aXZpdHlUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwucmVmbGVjdGl2aXR5VGV4dHVyZS5oYXNBbHBoYSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnVzZU1pY3JvU3VyZmFjZUZyb21SZWZsZWN0aXZpdHlNYXBBbHBoYSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcyhsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElNYXRlcmlhbCwgSVRleHR1cmVJbmZvIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHsgQ29sb3IzIH0gZnJvbSBcImNvcmUvTWF0aHMvbWF0aC5jb2xvclwiO1xyXG5pbXBvcnQgdHlwZSB7IElLSFJNYXRlcmlhbHNTaGVlbiB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIktIUl9tYXRlcmlhbHNfc2hlZW5cIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX3NoZWVuIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19zaGVlbi9SRUFETUUubWQpXHJcbiAqIFtQbGF5Z3JvdW5kIFNhbXBsZV0oaHR0cHM6Ly93d3cuYmFieWxvbmpzLXBsYXlncm91bmQuY29tL2ZyYW1lLmh0bWwjQk5JWlg2IzQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX3NoZWVuIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxOTA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUtIUk1hdGVyaWFsc1NoZWVuPihjb250ZXh0LCBtYXRlcmlhbCwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkU2hlZW5Qcm9wZXJ0aWVzQXN5bmMoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZFNoZWVuUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgcHJvcGVydGllczogSUtIUk1hdGVyaWFsc1NoZWVuLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5zaGVlbi5pc0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5zaGVlbi5pbnRlbnNpdHkgPSAxO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5zaGVlbkNvbG9yRmFjdG9yICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuc2hlZW4uY29sb3IgPSBDb2xvcjMuRnJvbUFycmF5KHByb3BlcnRpZXMuc2hlZW5Db2xvckZhY3Rvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnNoZWVuLmNvbG9yID0gQ29sb3IzLkJsYWNrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5zaGVlbkNvbG9yVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvYWRUZXh0dXJlSW5mb0FzeW5jKGAke2NvbnRleHR9L3NoZWVuQ29sb3JUZXh0dXJlYCwgcHJvcGVydGllcy5zaGVlbkNvbG9yVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKFNoZWVuIENvbG9yKWA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnNoZWVuLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnNoZWVuUm91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnNoZWVuLnJvdWdobmVzcyA9IHByb3BlcnRpZXMuc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnNoZWVuLnJvdWdobmVzcyA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5zaGVlblJvdWdobmVzc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgKHByb3BlcnRpZXMuc2hlZW5Sb3VnaG5lc3NUZXh0dXJlIGFzIElUZXh0dXJlSW5mbykubm9uQ29sb3JEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9zaGVlblJvdWdobmVzc1RleHR1cmVgLCBwcm9wZXJ0aWVzLnNoZWVuUm91Z2huZXNzVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKFNoZWVuIFJvdWdobmVzcylgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5zaGVlbi50ZXh0dXJlUm91Z2huZXNzID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuc2hlZW4uYWxiZWRvU2NhbGluZyA9IHRydWU7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnNoZWVuLnVzZVJvdWdobmVzc0Zyb21NYWluVGV4dHVyZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX3NoZWVuKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHsgUEJSTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvUEJSL3Bick1hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgSU1hdGVyaWFsLCBJVGV4dHVyZUluZm8gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XHJcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gXCJjb3JlL0VuZ2luZXMvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUVYVE1hdGVyaWFsc1NwZWN1bGFyRWRnZUNvbG9yLCBJS0hSTWF0ZXJpYWxzU3BlY3VsYXIgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX21hdGVyaWFsc19zcGVjdWxhciBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiS0hSX21hdGVyaWFsc19zcGVjdWxhclwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfc3BlY3VsYXIvUkVBRE1FLm1kKVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX21hdGVyaWFsc19zcGVjdWxhciBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBvcmRlciB0aGUgZXh0ZW5zaW9ucyBhcmUgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9yZGVyID0gMTkwO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJNYXRlcmlhbHNTcGVjdWxhcj4oY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZGVyLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZFNwZWN1bGFyUHJvcGVydGllc0FzeW5jKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbiwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgRVhUX21hdGVyaWFsc19zcGVjdWxhcl9lZGdlX2NvbG9yIHN1Yi1leHRlbnNpb25cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvMmExMTExYjg4ZjA1MmNiZDNlMmQ4MmFiYjlmYWVlNTZlNzQ5NDkwNC9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX21hdGVyaWFsc19zcGVjdWxhcl9lZGdlX2NvbG9yL1JFQURNRS5tZFxyXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9uLmV4dGVuc2lvbnMuRVhUX21hdGVyaWFsc19zcGVjdWxhcl9lZGdlX2NvbG9yICYmIGJhYnlsb25NYXRlcmlhbCBpbnN0YW5jZW9mIFBCUk1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVjdWxhckVkZ2VDb2xvckV4dGVuc2lvbiA9IGV4dGVuc2lvbi5leHRlbnNpb25zLkVYVF9tYXRlcmlhbHNfc3BlY3VsYXJfZWRnZV9jb2xvciBhcyBJRVhUTWF0ZXJpYWxzU3BlY3VsYXJFZGdlQ29sb3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlY3VsYXJFZGdlQ29sb3JFeHRlbnNpb24uc3BlY3VsYXJFZGdlQ29sb3JFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmJyZGYuZGllbGVjdHJpY1NwZWN1bGFyTW9kZWwgPSBDb25zdGFudHMuTUFURVJJQUxfRElFTEVDVFJJQ19TUEVDVUxBUl9NT0RFTF9PUEVOUEJSO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5icmRmLmNvbmR1Y3RvclNwZWN1bGFyTW9kZWwgPSBDb25zdGFudHMuTUFURVJJQUxfQ09ORFVDVE9SX1NQRUNVTEFSX01PREVMX09QRU5QQlI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZFNwZWN1bGFyUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgcHJvcGVydGllczogSUtIUk1hdGVyaWFsc1NwZWN1bGFyLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnNwZWN1bGFyRmFjdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLm1ldGFsbGljRjBGYWN0b3IgPSBwcm9wZXJ0aWVzLnNwZWN1bGFyRmFjdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuc3BlY3VsYXJDb2xvckZhY3RvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5tZXRhbGxpY1JlZmxlY3RhbmNlQ29sb3IgPSBDb2xvcjMuRnJvbUFycmF5KHByb3BlcnRpZXMuc3BlY3VsYXJDb2xvckZhY3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5zcGVjdWxhclRleHR1cmUpIHtcclxuICAgICAgICAgICAgKHByb3BlcnRpZXMuc3BlY3VsYXJUZXh0dXJlIGFzIElUZXh0dXJlSW5mbykubm9uQ29sb3JEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9zcGVjdWxhclRleHR1cmVgLCBwcm9wZXJ0aWVzLnNwZWN1bGFyVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKFNwZWN1bGFyKWA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLm1ldGFsbGljUmVmbGVjdGFuY2VUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwudXNlT25seU1ldGFsbGljRnJvbU1ldGFsbGljUmVmbGVjdGFuY2VUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcy5zcGVjdWxhckNvbG9yVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvYWRUZXh0dXJlSW5mb0FzeW5jKGAke2NvbnRleHR9L3NwZWN1bGFyQ29sb3JUZXh0dXJlYCwgcHJvcGVydGllcy5zcGVjdWxhckNvbG9yVGV4dHVyZSwgKHRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKFNwZWN1bGFyIENvbG9yKWA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnJlZmxlY3RhbmNlVGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgS0hSX21hdGVyaWFsc19zcGVjdWxhcihsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwsIElUZXh0dXJlSW5mbyB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUk1hdGVyaWFsc1RyYW5zbWlzc2lvbiB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHR5cGUgeyBTY2VuZSB9IGZyb20gXCJjb3JlL3NjZW5lXCI7XHJcbmltcG9ydCB0eXBlIHsgQWJzdHJhY3RNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL2Fic3RyYWN0TWVzaFwiO1xyXG5pbXBvcnQgdHlwZSB7IFRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZVwiO1xyXG5pbXBvcnQgeyBSZW5kZXJUYXJnZXRUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL3JlbmRlclRhcmdldFRleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBPYnNlcnZlciB9IGZyb20gXCJjb3JlL01pc2Mvb2JzZXJ2YWJsZVwiO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcImNvcmUvTWlzYy9vYnNlcnZhYmxlXCI7XHJcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gXCJjb3JlL0VuZ2luZXMvY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5pbXBvcnQgdHlwZSB7IENvbG9yNCB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmludGVyZmFjZSBJVHJhbnNtaXNzaW9uSGVscGVySG9sZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF90cmFuc21pc3Npb25IZWxwZXI6IFRyYW5zbWlzc2lvbkhlbHBlciB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIElUcmFuc21pc3Npb25IZWxwZXJPcHRpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNpemUgb2YgdGhlIHJlbmRlciBidWZmZXJzIChkZWZhdWx0OiAxMDI0KVxyXG4gICAgICovXHJcbiAgICByZW5kZXJTaXplOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyB0aGUgcmVuZGVyIHRhcmdldCB0ZXh0dXJlIGZvciBvcGFxdWUgbWVzaGVzIChkZWZhdWx0OiA0KVxyXG4gICAgICovXHJcbiAgICBzYW1wbGVzOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZSB0byBhcHBseSB3aGVuIHNlbGVjdGluZyB0aGUgTE9EIGxldmVsIHRvIHNhbXBsZSB0aGUgcmVmcmFjdGlvbiB0ZXh0dXJlIChkZWZhdWx0OiAxKVxyXG4gICAgICovXHJcbiAgICBsb2RHZW5lcmF0aW9uU2NhbGU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9mZnNldCB0byBhcHBseSB3aGVuIHNlbGVjdGluZyB0aGUgTE9EIGxldmVsIHRvIHNhbXBsZSB0aGUgcmVmcmFjdGlvbiB0ZXh0dXJlIChkZWZhdWx0OiAtNClcclxuICAgICAqL1xyXG4gICAgbG9kR2VuZXJhdGlvbk9mZnNldDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHlwZSBvZiB0aGUgcmVmcmFjdGlvbiByZW5kZXIgdGFyZ2V0IHRleHR1cmUgKGRlZmF1bHQ6IFRFWFRVUkVUWVBFX0hBTEZfRkxPQVQpXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclRhcmdldFRleHR1cmVUeXBlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBtaXBtYXBzIGZvciB0aGUgcmVmcmFjdGlvbiByZW5kZXIgdGFyZ2V0IHRleHR1cmUgbXVzdCBiZSBnZW5lcmF0ZWQgKGRlZmF1bHQ6IHRydWUpXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlTWlwbWFwczogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIGNvbG9yIG9mIHRoZSBvcGFxdWUgdGV4dHVyZS4gSWYgbm90IHByb3ZpZGVkLCB1c2UgdGhlIHNjZW5lIGNsZWFyIGNvbG9yICh3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCB0byBsaW5lYXIgc3BhY2UpLlxyXG4gICAgICogSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBpbiBsaW5lYXIgc3BhY2VcclxuICAgICAqL1xyXG4gICAgY2xlYXJDb2xvcj86IENvbG9yNDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdG8gaGFuZGxlIHNldHRpbmcgdXAgdGhlIHJlbmRlcmluZyBvZiBvcGFxdWUgb2JqZWN0cyB0byBiZSBzaG93biB0aHJvdWdoIHRyYW5zbWlzc2l2ZSBvYmplY3RzLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNtaXNzaW9uSGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgaGVscGVyLlxyXG4gICAgICogQHJldHVybnMgdGhlIGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfR2V0RGVmYXVsdE9wdGlvbnMoKTogSVRyYW5zbWlzc2lvbkhlbHBlck9wdGlvbnMge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlbmRlclNpemU6IDEwMjQsXHJcbiAgICAgICAgICAgIHNhbXBsZXM6IDQsXHJcbiAgICAgICAgICAgIGxvZEdlbmVyYXRpb25TY2FsZTogMSxcclxuICAgICAgICAgICAgbG9kR2VuZXJhdGlvbk9mZnNldDogLTQsXHJcbiAgICAgICAgICAgIHJlbmRlclRhcmdldFRleHR1cmVUeXBlOiBDb25zdGFudHMuVEVYVFVSRVRZUEVfSEFMRl9GTE9BVCxcclxuICAgICAgICAgICAgZ2VuZXJhdGVNaXBtYXBzOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMgdGhlIGNyZWF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3NjZW5lOiBTY2VuZSAmIElUcmFuc21pc3Npb25IZWxwZXJIb2xkZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBfb3B0aW9uczogSVRyYW5zbWlzc2lvbkhlbHBlck9wdGlvbnM7XHJcblxyXG4gICAgcHJpdmF0ZSBfb3BhcXVlUmVuZGVyVGFyZ2V0OiBOdWxsYWJsZTxSZW5kZXJUYXJnZXRUZXh0dXJlPiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9vcGFxdWVNZXNoZXNDYWNoZTogQWJzdHJhY3RNZXNoW10gPSBbXTtcclxuICAgIHByaXZhdGUgX3RyYW5zcGFyZW50TWVzaGVzQ2FjaGU6IEFic3RyYWN0TWVzaFtdID0gW107XHJcbiAgICBwcml2YXRlIF9tYXRlcmlhbE9ic2VydmVyczogeyBbaWQ6IHN0cmluZ106IE51bGxhYmxlPE9ic2VydmVyPEFic3RyYWN0TWVzaD4+IH0gPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgb2JzZXJ2YWJsZSB3aWxsIGJlIG5vdGlmaWVkIHdpdGggYW55IGVycm9yIGR1cmluZyB0aGUgY3JlYXRpb24gb2YgdGhlIGVudmlyb25tZW50LFxyXG4gICAgICogbWFpbmx5IHRleHR1cmUgY3JlYXRpb24gZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25FcnJvck9ic2VydmFibGU6IE9ic2VydmFibGU8eyBtZXNzYWdlPzogc3RyaW5nOyBleGNlcHRpb24/OiBhbnkgfT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgRGVmaW5lcyB0aGUgb3B0aW9ucyB3ZSB3YW50IHRvIGN1c3RvbWl6ZSB0aGUgaGVscGVyXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0aGUgbWF0ZXJpYWwgdG9cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxJVHJhbnNtaXNzaW9uSGVscGVyT3B0aW9ucz4sIHNjZW5lOiBTY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIC4uLlRyYW5zbWlzc2lvbkhlbHBlci5fR2V0RGVmYXVsdE9wdGlvbnMoKSxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3NjZW5lID0gc2NlbmUgYXMgYW55O1xyXG4gICAgICAgIHRoaXMuX3NjZW5lLl90cmFuc21pc3Npb25IZWxwZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLm9uRXJyb3JPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLl9zY2VuZS5vbkRpc3Bvc2VPYnNlcnZhYmxlLmFkZE9uY2UoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fcGFyc2VTY2VuZSgpO1xyXG4gICAgICAgIHRoaXMuX3NldHVwUmVuZGVyVGFyZ2V0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYmFja2dyb3VuZCBhY2NvcmRpbmcgdG8gdGhlIG5ldyBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlT3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPElUcmFuc21pc3Npb25IZWxwZXJPcHRpb25zPikge1xyXG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGFueSBvcHRpb25zIGFyZSBhY3R1YWxseSBiZWluZyBjaGFuZ2VkLiBJZiBub3QsIGV4aXQuXHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWVzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrZXk6IHN0cmluZykgPT4gKHRoaXMuX29wdGlvbnMgYXMgYW55KVtrZXldICE9PSAob3B0aW9ucyBhcyBhbnkpW2tleV0pO1xyXG4gICAgICAgIGlmICghbmV3VmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLl9vcHRpb25zLFxyXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG9sZE9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBuZXdPcHRpb25zO1xyXG5cclxuICAgICAgICAvLyBJZiBzaXplIGNoYW5nZXMsIHJlY3JlYXRlIGV2ZXJ5dGhpbmdcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIG5ld09wdGlvbnMucmVuZGVyU2l6ZSAhPT0gb2xkT3B0aW9ucy5yZW5kZXJTaXplIHx8XHJcbiAgICAgICAgICAgIG5ld09wdGlvbnMucmVuZGVyVGFyZ2V0VGV4dHVyZVR5cGUgIT09IG9sZE9wdGlvbnMucmVuZGVyVGFyZ2V0VGV4dHVyZVR5cGUgfHxcclxuICAgICAgICAgICAgbmV3T3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgIT09IG9sZE9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIHx8XHJcbiAgICAgICAgICAgICF0aGlzLl9vcGFxdWVSZW5kZXJUYXJnZXRcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0dXBSZW5kZXJUYXJnZXRzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LnNhbXBsZXMgPSBuZXdPcHRpb25zLnNhbXBsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldC5sb2RHZW5lcmF0aW9uU2NhbGUgPSBuZXdPcHRpb25zLmxvZEdlbmVyYXRpb25TY2FsZTtcclxuICAgICAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LmxvZEdlbmVyYXRpb25PZmZzZXQgPSBuZXdPcHRpb25zLmxvZEdlbmVyYXRpb25PZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdGhlIG9wYXF1ZSByZW5kZXIgdGFyZ2V0IHRleHR1cmUgb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T3BhcXVlVGFyZ2V0KCk6IE51bGxhYmxlPFRleHR1cmU+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3Nob3VsZFJlbmRlckFzVHJhbnNtaXNzaW9uKG1hdGVyaWFsOiBOdWxsYWJsZTxNYXRlcmlhbD4pOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoIW1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwgJiYgbWF0ZXJpYWwuc3ViU3VyZmFjZS5pc1JlZnJhY3Rpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfYWRkTWVzaChtZXNoOiBBYnN0cmFjdE1lc2gpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXRlcmlhbE9ic2VydmVyc1ttZXNoLnVuaXF1ZUlkXSA9IG1lc2gub25NYXRlcmlhbENoYW5nZWRPYnNlcnZhYmxlLmFkZCh0aGlzLl9vbk1lc2hNYXRlcmlhbENoYW5nZWQuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVmZXIgdGhlIHByb2Nlc3NpbmcgYmVjYXVzZSBfYWRkTWVzaCBtYXkgYmUgY2FsbGVkIGFzIHBhcnQgYXMgYW4gaW5zdGFuY2UgbWVzaCBjcmVhdGlvbiwgaW4gd2hpY2ggY2FzZSBzb21lXHJcbiAgICAgICAgLy8gaW50ZXJuYWwgcHJvcGVydGllcyBhcmUgbm90IHNldHVwIHlldCwgbGlrZSBfc291cmNlTWVzaCAobmVlZGVkIHdoZW4gZG9pbmcgbWVzaC5tYXRlcmlhbCBiZWxvdylcclxuICAgICAgICBUb29scy5TZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkUmVuZGVyQXNUcmFuc21pc3Npb24obWVzaC5tYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgICAgIChtZXNoLm1hdGVyaWFsIGFzIFBCUk1hdGVyaWFsKS5yZWZyYWN0aW9uVGV4dHVyZSA9IHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc3BhcmVudE1lc2hlc0NhY2hlLmluZGV4T2YobWVzaCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRNZXNoZXNDYWNoZS5wdXNoKG1lc2gpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wYXF1ZU1lc2hlc0NhY2hlLmluZGV4T2YobWVzaCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BhcXVlTWVzaGVzQ2FjaGUucHVzaChtZXNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3JlbW92ZU1lc2gobWVzaDogQWJzdHJhY3RNZXNoKTogdm9pZCB7XHJcbiAgICAgICAgbWVzaC5vbk1hdGVyaWFsQ2hhbmdlZE9ic2VydmFibGUucmVtb3ZlKHRoaXMuX21hdGVyaWFsT2JzZXJ2ZXJzW21lc2gudW5pcXVlSWRdKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fbWF0ZXJpYWxPYnNlcnZlcnNbbWVzaC51bmlxdWVJZF07XHJcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuX3RyYW5zcGFyZW50TWVzaGVzQ2FjaGUuaW5kZXhPZihtZXNoKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc3BhcmVudE1lc2hlc0NhY2hlLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZHggPSB0aGlzLl9vcGFxdWVNZXNoZXNDYWNoZS5pbmRleE9mKG1lc2gpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wYXF1ZU1lc2hlc0NhY2hlLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9wYXJzZVNjZW5lKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3NjZW5lLm1lc2hlcy5mb3JFYWNoKHRoaXMuX2FkZE1lc2guYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTGlzdGVuIGZvciB3aGVuIGEgbWVzaCBpcyBhZGRlZCB0byB0aGUgc2NlbmUgYW5kIGFkZCBpdCB0byBvdXIgY2FjaGUgbGlzdHMuXHJcbiAgICAgICAgdGhpcy5fc2NlbmUub25OZXdNZXNoQWRkZWRPYnNlcnZhYmxlLmFkZCh0aGlzLl9hZGRNZXNoLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIExpc3RlbiBmb3Igd2hlbiBhIG1lc2ggaXMgcmVtb3ZlZCBmcm9tIHRvIHRoZSBzY2VuZSBhbmQgcmVtb3ZlIGl0IGZyb20gb3VyIGNhY2hlIGxpc3RzLlxyXG4gICAgICAgIHRoaXMuX3NjZW5lLm9uTWVzaFJlbW92ZWRPYnNlcnZhYmxlLmFkZCh0aGlzLl9yZW1vdmVNZXNoLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdoZW4gb25lIG9mIHRoZSBtZXNoZXMgaW4gdGhlIHNjZW5lIGhhcyBpdHMgbWF0ZXJpYWwgY2hhbmdlZCwgbWFrZSBzdXJlIHRoYXQgaXQncyBpbiB0aGUgY29ycmVjdCBjYWNoZSBsaXN0LlxyXG4gICAgcHJpdmF0ZSBfb25NZXNoTWF0ZXJpYWxDaGFuZ2VkKG1lc2g6IEFic3RyYWN0TWVzaCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zcGFyZW50SWR4ID0gdGhpcy5fdHJhbnNwYXJlbnRNZXNoZXNDYWNoZS5pbmRleE9mKG1lc2gpO1xyXG4gICAgICAgIGNvbnN0IG9wYXF1ZUlkeCA9IHRoaXMuX29wYXF1ZU1lc2hlc0NhY2hlLmluZGV4T2YobWVzaCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBtYXRlcmlhbCBpcyB0cmFuc3BhcmVudCwgbWFrZSBzdXJlIHRoYXQgaXQncyBhZGRlZCB0byB0aGUgdHJhbnNwYXJlbnQgbGlzdCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBvcGFxdWUgbGlzdFxyXG4gICAgICAgIGNvbnN0IHVzZVRyYW5zbWlzc2lvbiA9IHRoaXMuX3Nob3VsZFJlbmRlckFzVHJhbnNtaXNzaW9uKG1lc2gubWF0ZXJpYWwpO1xyXG4gICAgICAgIGlmICh1c2VUcmFuc21pc3Npb24pIHtcclxuICAgICAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwgaW5zdGFuY2VvZiBQQlJNYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgbWVzaC5tYXRlcmlhbC5zdWJTdXJmYWNlLnJlZnJhY3Rpb25UZXh0dXJlID0gdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcGFxdWVJZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGFxdWVNZXNoZXNDYWNoZS5zcGxpY2Uob3BhcXVlSWR4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50TWVzaGVzQ2FjaGUucHVzaChtZXNoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFuc3BhcmVudElkeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50TWVzaGVzQ2FjaGUucHVzaChtZXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbWF0ZXJpYWwgaXMgb3BhcXVlLCBtYWtlIHN1cmUgdGhhdCBpdCdzIGFkZGVkIHRvIHRoZSBvcGFxdWUgbGlzdCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSB0cmFuc3BhcmVudCBsaXN0XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW50SWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRNZXNoZXNDYWNoZS5zcGxpY2UodHJhbnNwYXJlbnRJZHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BhcXVlTWVzaGVzQ2FjaGUucHVzaChtZXNoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcGFxdWVJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGFxdWVNZXNoZXNDYWNoZS5wdXNoKG1lc2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgb3BhcXVlIHJlbmRlciB0YXJnZXQgaGFzIG5vdCBiZWVuIGRpc3Bvc2VkIGFuZCBjYW4gc3RpbGwgYmUgdXNlZC5cclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBfaXNSZW5kZXJUYXJnZXRWYWxpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0Py5nZXRJbnRlcm5hbFRleHR1cmUoKSAhPT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogU2V0dXAgdGhlIHJlbmRlciB0YXJnZXRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBfc2V0dXBSZW5kZXJUYXJnZXRzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9vcGFxdWVSZW5kZXJUYXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0ID0gbmV3IFJlbmRlclRhcmdldFRleHR1cmUoXHJcbiAgICAgICAgICAgIFwib3BhcXVlU2NlbmVUZXh0dXJlXCIsXHJcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMucmVuZGVyU2l6ZSxcclxuICAgICAgICAgICAgdGhpcy5fc2NlbmUsXHJcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzLFxyXG4gICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMucmVuZGVyVGFyZ2V0VGV4dHVyZVR5cGVcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldC5pZ25vcmVDYW1lcmFWaWV3cG9ydCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LnJlbmRlckxpc3QgPSB0aGlzLl9vcGFxdWVNZXNoZXNDYWNoZTtcclxuICAgICAgICB0aGlzLl9vcGFxdWVSZW5kZXJUYXJnZXQuY2xlYXJDb2xvciA9IHRoaXMuX29wdGlvbnMuY2xlYXJDb2xvcj8uY2xvbmUoKSA/PyB0aGlzLl9zY2VuZS5jbGVhckNvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LmdhbW1hU3BhY2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcGFxdWVSZW5kZXJUYXJnZXQubG9kR2VuZXJhdGlvblNjYWxlID0gdGhpcy5fb3B0aW9ucy5sb2RHZW5lcmF0aW9uU2NhbGU7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LmxvZEdlbmVyYXRpb25PZmZzZXQgPSB0aGlzLl9vcHRpb25zLmxvZEdlbmVyYXRpb25PZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LnNhbXBsZXMgPSB0aGlzLl9vcHRpb25zLnNhbXBsZXM7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0LnJlbmRlclNwcml0ZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldC5yZW5kZXJQYXJ0aWNsZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldC5kaXNhYmxlSW1hZ2VQcm9jZXNzaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgbGV0IHNhdmVTY2VuZUVudkludGVuc2l0eTogbnVtYmVyO1xyXG4gICAgICAgIHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldC5vbkJlZm9yZUJpbmRPYnNlcnZhYmxlLmFkZCgob3BhcXVlUmVuZGVyVGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIHNhdmVTY2VuZUVudkludGVuc2l0eSA9IHRoaXMuX3NjZW5lLmVudmlyb25tZW50SW50ZW5zaXR5O1xyXG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5lbnZpcm9ubWVudEludGVuc2l0eSA9IDEuMDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmNsZWFyQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NjZW5lLmNsZWFyQ29sb3IudG9MaW5lYXJTcGFjZVRvUmVmKG9wYXF1ZVJlbmRlclRhcmdldC5jbGVhckNvbG9yLCB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS51c2VFeGFjdFNyZ2JDb252ZXJzaW9ucyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcGFxdWVSZW5kZXJUYXJnZXQuY2xlYXJDb2xvci5jb3B5RnJvbSh0aGlzLl9vcHRpb25zLmNsZWFyQ29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUmVuZGVyVGFyZ2V0Lm9uQWZ0ZXJVbmJpbmRPYnNlcnZhYmxlLmFkZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lLmVudmlyb25tZW50SW50ZW5zaXR5ID0gc2F2ZVNjZW5lRW52SW50ZW5zaXR5O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgdGhpcy5fdHJhbnNwYXJlbnRNZXNoZXNDYWNoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkUmVuZGVyQXNUcmFuc21pc3Npb24obWVzaC5tYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgICAgIChtZXNoLm1hdGVyaWFsIGFzIFBCUk1hdGVyaWFsKS5yZWZyYWN0aW9uVGV4dHVyZSA9IHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2UgYWxsIHRoZSBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBIZWxwZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3NjZW5lLl90cmFuc21pc3Npb25IZWxwZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX29wYXF1ZVJlbmRlclRhcmdldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcGFxdWVSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9vcGFxdWVSZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc3BhcmVudE1lc2hlc0NhY2hlID0gW107XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlTWVzaGVzQ2FjaGUgPSBbXTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgTkFNRSA9IFwiS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbiBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21haW4vZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbi9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbiBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBvcmRlciB0aGUgZXh0ZW5zaW9ucyBhcmUgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9yZGVyID0gMTc1O1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGxvYWRlci5wYXJlbnQudHJhbnNwYXJlbmN5QXNDb3ZlcmFnZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUtIUk1hdGVyaWFsc1RyYW5zbWlzc2lvbj4oY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZGVyLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZFRyYW5zcGFyZW50UHJvcGVydGllc0FzeW5jKGV4dGVuc2lvbkNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwsIGV4dGVuc2lvbikpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jXHJcbiAgICBwcml2YXRlIF9sb2FkVHJhbnNwYXJlbnRQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsLCBleHRlbnNpb246IElLSFJNYXRlcmlhbHNUcmFuc21pc3Npb24pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIShiYWJ5bG9uTWF0ZXJpYWwgaW5zdGFuY2VvZiBQQlJNYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBNYXRlcmlhbCB0eXBlIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGJyTWF0ZXJpYWwgPSBiYWJ5bG9uTWF0ZXJpYWw7XHJcblxyXG4gICAgICAgIC8vIEVuYWJsZXMgXCJyZWZyYWN0aW9uXCIgdGV4dHVyZSB3aGljaCByZXByZXNlbnRzIHRyYW5zbWl0dGVkIGxpZ2h0LlxyXG4gICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2UuaXNSZWZyYWN0aW9uRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFNpbmNlIHRoaXMgZXh0ZW5zaW9uIG1vZGVscyB0aGluLXN1cmZhY2UgdHJhbnNtaXNzaW9uIG9ubHksIHdlIG11c3QgbWFrZSBJT1IgPSAxLjBcclxuICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnZvbHVtZUluZGV4T2ZSZWZyYWN0aW9uID0gMS4wO1xyXG5cclxuICAgICAgICAvLyBBbGJlZG8gY29sb3VyIHdpbGwgdGludCB0cmFuc21pc3Npb24uXHJcbiAgICAgICAgcGJyTWF0ZXJpYWwuc3ViU3VyZmFjZS51c2VBbGJlZG9Ub1RpbnRSZWZyYWN0aW9uID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnJlZnJhY3Rpb25JbnRlbnNpdHkgPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xyXG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IHBick1hdGVyaWFsLmdldFNjZW5lKCkgYXMgdW5rbm93biBhcyBJVHJhbnNtaXNzaW9uSGVscGVySG9sZGVyO1xyXG4gICAgICAgICAgICBpZiAocGJyTWF0ZXJpYWwuc3ViU3VyZmFjZS5yZWZyYWN0aW9uSW50ZW5zaXR5ICYmICFzY2VuZS5fdHJhbnNtaXNzaW9uSGVscGVyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgVHJhbnNtaXNzaW9uSGVscGVyKHt9LCBwYnJNYXRlcmlhbC5nZXRTY2VuZSgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnJlZnJhY3Rpb25JbnRlbnNpdHkgJiYgIXNjZW5lLl90cmFuc21pc3Npb25IZWxwZXI/Ll9pc1JlbmRlclRhcmdldFZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZW5kZXIgdGFyZ2V0IGlzIG5vdCB2YWxpZCwgcmVjcmVhdGUgaXQuXHJcbiAgICAgICAgICAgICAgICBzY2VuZS5fdHJhbnNtaXNzaW9uSGVscGVyPy5fc2V0dXBSZW5kZXJUYXJnZXRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnJlZnJhY3Rpb25JbnRlbnNpdHkgPSAwLjA7XHJcbiAgICAgICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2UuaXNSZWZyYWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLm1pbmltdW1UaGlja25lc3MgPSAwLjA7XHJcbiAgICAgICAgcGJyTWF0ZXJpYWwuc3ViU3VyZmFjZS5tYXhpbXVtVGhpY2tuZXNzID0gMC4wO1xyXG4gICAgICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAoZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUgYXMgSVRleHR1cmVJbmZvKS5ub25Db2xvckRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS90cmFuc21pc3Npb25UZXh0dXJlYCwgZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUsIHVuZGVmaW5lZCkudGhlbigodGV4dHVyZTogQmFzZVRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoVHJhbnNtaXNzaW9uKWA7XHJcbiAgICAgICAgICAgICAgICBwYnJNYXRlcmlhbC5zdWJTdXJmYWNlLnJlZnJhY3Rpb25JbnRlbnNpdHlUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIHBick1hdGVyaWFsLnN1YlN1cmZhY2UudXNlR2x0ZlN0eWxlVGV4dHVyZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbihsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IENvbG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGguY29sb3JcIjtcclxuaW1wb3J0IHsgUEJSTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvUEJSL3Bick1hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgSU1hdGVyaWFsIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIktIUl9tYXRlcmlhbHNfdW5saXRcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbWF0ZXJpYWxzX3VubGl0IGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWF0ZXJpYWxzX3VubGl0XCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc191bmxpdC9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX3VubGl0IGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAyMTA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmMoY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZFVubGl0UHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRVbmxpdFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIShiYWJ5bG9uTWF0ZXJpYWwgaW5zdGFuY2VvZiBQQlJNYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBNYXRlcmlhbCB0eXBlIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwudW5saXQgPSB0cnVlO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3M7XHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuYmFzZUNvbG9yRmFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYWxiZWRvQ29sb3IgPSBDb2xvcjMuRnJvbUFycmF5KHByb3BlcnRpZXMuYmFzZUNvbG9yRmFjdG9yKTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5hbHBoYSA9IHByb3BlcnRpZXMuYmFzZUNvbG9yRmFjdG9yWzNdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb0NvbG9yID0gQ29sb3IzLldoaXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmJhc2VDb2xvclRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvYWRUZXh0dXJlSW5mb0FzeW5jKGAke2NvbnRleHR9L2Jhc2VDb2xvclRleHR1cmVgLCBwcm9wZXJ0aWVzLmJhc2VDb2xvclRleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoQmFzZSBDb2xvcilgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYWxiZWRvVGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXRlcmlhbC5kb3VibGVTaWRlZCkge1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYmFja0ZhY2VDdWxsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC50d29TaWRlZExpZ2h0aW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xvYWRlci5sb2FkTWF0ZXJpYWxBbHBoYVByb3BlcnRpZXMoY29udGV4dCwgbWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbCk7XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9tYXRlcmlhbHNfdW5saXQobG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciwgQXJyYXlJdGVtIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuXHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9tZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgTm9kZSB9IGZyb20gXCJjb3JlL25vZGVcIjtcclxuaW1wb3J0IHR5cGUgeyBBYnN0cmFjdE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvYWJzdHJhY3RNZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgSU5vZGUsIElNZXNoUHJpbWl0aXZlLCBJTWVzaCB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElLSFJNYXRlcmlhbFZhcmlhbnRzX01hcHBpbmcsIElLSFJNYXRlcmlhbFZhcmlhbnRzX1ZhcmlhbnQsIElLSFJNYXRlcmlhbFZhcmlhbnRzX1ZhcmlhbnRzIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgdHlwZSB7IFRyYW5zZm9ybU5vZGUgfSBmcm9tIFwiY29yZS9NZXNoZXMvdHJhbnNmb3JtTm9kZVwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsVmFyaWFudHNDb250cm9sbGVyIH0gZnJvbSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzXCI7XHJcblxyXG5leHBvcnQgeyBNYXRlcmlhbFZhcmlhbnRzQ29udHJvbGxlciB9O1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIERlZmluZSBvcHRpb25zIHJlbGF0ZWQgdHlwZXMgaGVyZSBzbyB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBvcHRpb25zLFxyXG4gICAgLy8gYnV0IGV4cG9ydCB0aGUgdHlwZXMgYXQgdGhlIG1vZHVsZSBsZXZlbC4gVGhpcyBlbnN1cmVzIHRoZSB0eXBlcyBhcmUgaW4gdGhlXHJcbiAgICAvLyBjb3JyZWN0IG5hbWVzcGFjZSBmb3IgVU1ELlxyXG4gICAgdHlwZSBNYXRlcmlhbFZhcmlhbnRzQ29udHJvbGxlciA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBhdmFpbGFibGUgdmFyaWFudCBuYW1lcyBmb3IgdGhpcyBhc3NldC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWFkb25seSB2YXJpYW50czogcmVhZG9ubHkgc3RyaW5nW107XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgdmFyaWFudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWxlY3RlZFZhcmlhbnQ6IHN0cmluZztcclxuICAgIH07XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX21hdGVyaWFsc192YXJpYW50cyBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiS0hSX21hdGVyaWFsc192YXJpYW50c1wiXTogUGFydGlhbDx7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIHZhcmlhbnQgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQgYnkgZGVmYXVsdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYXJpYW50OiBzdHJpbmc7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgbWF0ZXJpYWwgdmFyaWFudHMgYXJlIGxvYWRlZC5cclxuICAgICAgICAgICAgICogQGV4cGVyaW1lbnRhbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgb25Mb2FkZWQ6IChjb250cm9sbGVyOiBNYXRlcmlhbFZhcmlhbnRzQ29udHJvbGxlcikgPT4gdm9pZDtcclxuICAgICAgICB9PjtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIElWYXJpYW50c01hcCB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBBcnJheTx7IG1lc2g6IEFic3RyYWN0TWVzaDsgbWF0ZXJpYWw6IE51bGxhYmxlPE1hdGVyaWFsPiB9PjtcclxufVxyXG5cclxuaW50ZXJmYWNlIElFeHRlbnNpb25NZXRhZGF0YSB7XHJcbiAgICBsYXN0U2VsZWN0ZWQ6IE51bGxhYmxlPHN0cmluZyB8IEFycmF5PHN0cmluZz4+O1xyXG4gICAgb3JpZ2luYWw6IEFycmF5PHsgbWVzaDogQWJzdHJhY3RNZXNoOyBtYXRlcmlhbDogTnVsbGFibGU8TWF0ZXJpYWw+IH0+O1xyXG4gICAgdmFyaWFudHM6IElWYXJpYW50c01hcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc192YXJpYW50cy9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICBwcml2YXRlIF92YXJpYW50cz86IEFycmF5PElLSFJNYXRlcmlhbFZhcmlhbnRzX1ZhcmlhbnQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB2YXJpYW50IG5hbWVzIGZvciB0aGlzIGFzc2V0LlxyXG4gICAgICogQHBhcmFtIHJvb3ROb2RlIFRoZSBnbFRGIHJvb3Qgbm9kZVxyXG4gICAgICogQHJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIHRoZSB2YXJpYW50IG5hbWVzIGZvciB0aGlzIG1vZGVsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR2V0QXZhaWxhYmxlVmFyaWFudHMocm9vdE5vZGU6IFRyYW5zZm9ybU5vZGUpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uTWV0YWRhdGEgPSB0aGlzLl9HZXRFeHRlbnNpb25NZXRhZGF0YShyb290Tm9kZSk7XHJcbiAgICAgICAgaWYgKCFleHRlbnNpb25NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZXh0ZW5zaW9uTWV0YWRhdGEudmFyaWFudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdmFyaWFudCBuYW1lcyBmb3IgdGhpcyBhc3NldC5cclxuICAgICAqIEBwYXJhbSByb290Tm9kZSBUaGUgZ2xURiByb290IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCB0aGUgdmFyaWFudCBuYW1lcyBmb3IgdGhpcyBtb2RlbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXZhaWxhYmxlVmFyaWFudHMocm9vdE5vZGU6IFRyYW5zZm9ybU5vZGUpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIEtIUl9tYXRlcmlhbHNfdmFyaWFudHMuR2V0QXZhaWxhYmxlVmFyaWFudHMocm9vdE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IGEgdmFyaWFudCBnaXZlbiBhIHZhcmlhbnQgbmFtZSBvciBhIGxpc3Qgb2YgdmFyaWFudCBuYW1lcy5cclxuICAgICAqIEBwYXJhbSByb290Tm9kZSBUaGUgZ2xURiByb290IG5vZGVcclxuICAgICAqIEBwYXJhbSB2YXJpYW50TmFtZSBUaGUgdmFyaWFudCBuYW1lKHMpIHRvIHNlbGVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTZWxlY3RWYXJpYW50KHJvb3ROb2RlOiBUcmFuc2Zvcm1Ob2RlLCB2YXJpYW50TmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25NZXRhZGF0YSA9IHRoaXMuX0dldEV4dGVuc2lvbk1ldGFkYXRhKHJvb3ROb2RlKTtcclxuICAgICAgICBpZiAoIWV4dGVuc2lvbk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNlbGVjdCB2YXJpYW50IG9uIGEgZ2xURiBtZXNoIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgJHtOQU1FfSBleHRlbnNpb25gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdCA9ICh2YXJpYW50TmFtZTogc3RyaW5nKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBleHRlbnNpb25NZXRhZGF0YS52YXJpYW50c1t2YXJpYW50TmFtZV07XHJcbiAgICAgICAgICAgIGlmIChlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5tZXNoLm1hdGVyaWFsID0gZW50cnkubWF0ZXJpYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodmFyaWFudE5hbWUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdmFyaWFudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh2YXJpYW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHRlbnNpb25NZXRhZGF0YS5sYXN0U2VsZWN0ZWQgPSB2YXJpYW50TmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCBhIHZhcmlhbnQgZ2l2ZW4gYSB2YXJpYW50IG5hbWUgb3IgYSBsaXN0IG9mIHZhcmlhbnQgbmFtZXMuXHJcbiAgICAgKiBAcGFyYW0gcm9vdE5vZGUgVGhlIGdsVEYgcm9vdCBub2RlXHJcbiAgICAgKiBAcGFyYW0gdmFyaWFudE5hbWUgVGhlIHZhcmlhbnQgbmFtZShzKSB0byBzZWxlY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZWxlY3RWYXJpYW50KHJvb3ROb2RlOiBUcmFuc2Zvcm1Ob2RlLCB2YXJpYW50TmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgICBLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzLlNlbGVjdFZhcmlhbnQocm9vdE5vZGUsIHZhcmlhbnROYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIGJlZm9yZSBzZWxlY3RpbmcgYSB2YXJpYW50LlxyXG4gICAgICogQHBhcmFtIHJvb3ROb2RlIFRoZSBnbFRGIHJvb3Qgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJlc2V0KHJvb3ROb2RlOiBUcmFuc2Zvcm1Ob2RlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uTWV0YWRhdGEgPSB0aGlzLl9HZXRFeHRlbnNpb25NZXRhZGF0YShyb290Tm9kZSk7XHJcbiAgICAgICAgaWYgKCFleHRlbnNpb25NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNldCBvbiBhIGdsVEYgbWVzaCB0aGF0IGRvZXMgbm90IGhhdmUgdGhlICR7TkFNRX0gZXh0ZW5zaW9uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGV4dGVuc2lvbk1ldGFkYXRhLm9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIGVudHJ5Lm1lc2gubWF0ZXJpYWwgPSBlbnRyeS5tYXRlcmlhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4dGVuc2lvbk1ldGFkYXRhLmxhc3RTZWxlY3RlZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBiZWZvcmUgc2VsZWN0aW5nIGEgdmFyaWFudC5cclxuICAgICAqIEBwYXJhbSByb290Tm9kZSBUaGUgZ2xURiByb290IG5vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KHJvb3ROb2RlOiBUcmFuc2Zvcm1Ob2RlKTogdm9pZCB7XHJcbiAgICAgICAgS0hSX21hdGVyaWFsc192YXJpYW50cy5SZXNldChyb290Tm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsYXN0IHNlbGVjdGVkIHZhcmlhbnQgbmFtZShzKSBvciBudWxsIGlmIG9yaWdpbmFsLlxyXG4gICAgICogQHBhcmFtIHJvb3ROb2RlIFRoZSBnbFRGIHJvb3Qgbm9kZVxyXG4gICAgICogQHJldHVybnMgVGhlIHNlbGVjdGVkIHZhcmlhbnQgbmFtZShzKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHZXRMYXN0U2VsZWN0ZWRWYXJpYW50KHJvb3ROb2RlOiBUcmFuc2Zvcm1Ob2RlKTogTnVsbGFibGU8c3RyaW5nIHwgc3RyaW5nW10+IHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25NZXRhZGF0YSA9IHRoaXMuX0dldEV4dGVuc2lvbk1ldGFkYXRhKHJvb3ROb2RlKTtcclxuICAgICAgICBpZiAoIWV4dGVuc2lvbk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCB0aGUgbGFzdCBzZWxlY3RlZCB2YXJpYW50IG9uIGEgZ2xURiBtZXNoIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgJHtOQU1FfSBleHRlbnNpb25gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25NZXRhZGF0YS5sYXN0U2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsYXN0IHNlbGVjdGVkIHZhcmlhbnQgbmFtZShzKSBvciBudWxsIGlmIG9yaWdpbmFsLlxyXG4gICAgICogQHBhcmFtIHJvb3ROb2RlIFRoZSBnbFRGIHJvb3Qgbm9kZVxyXG4gICAgICogQHJldHVybnMgVGhlIHNlbGVjdGVkIHZhcmlhbnQgbmFtZShzKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldExhc3RTZWxlY3RlZFZhcmlhbnQocm9vdE5vZGU6IFRyYW5zZm9ybU5vZGUpOiBOdWxsYWJsZTxzdHJpbmcgfCBzdHJpbmdbXT4ge1xyXG4gICAgICAgIHJldHVybiBLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzLkdldExhc3RTZWxlY3RlZFZhcmlhbnQocm9vdE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9HZXRFeHRlbnNpb25NZXRhZGF0YShyb290Tm9kZTogTnVsbGFibGU8VHJhbnNmb3JtTm9kZT4pOiBOdWxsYWJsZTxJRXh0ZW5zaW9uTWV0YWRhdGE+IHtcclxuICAgICAgICByZXR1cm4gcm9vdE5vZGU/Ll9pbnRlcm5hbE1ldGFkYXRhPy5nbHRmPy5bTkFNRV0gfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgb25Mb2FkaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLl9sb2FkZXIuZ2x0Zi5leHRlbnNpb25zO1xyXG4gICAgICAgIGlmIChleHRlbnNpb25zICYmIGV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xyXG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zW3RoaXMubmFtZV0gYXMgSUtIUk1hdGVyaWFsVmFyaWFudHNfVmFyaWFudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhcmlhbnRzID0gZXh0ZW5zaW9uLnZhcmlhbnRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgb25SZWFkeSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX2xvYWRlci5yb290QmFieWxvbk1lc2g7XHJcbiAgICAgICAgaWYgKHJvb3ROb2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9sb2FkZXIucGFyZW50LmV4dGVuc2lvbk9wdGlvbnNbTkFNRV07XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5kZWZhdWx0VmFyaWFudCkge1xyXG4gICAgICAgICAgICAgICAgS0hSX21hdGVyaWFsc192YXJpYW50cy5TZWxlY3RWYXJpYW50KHJvb3ROb2RlLCBvcHRpb25zLmRlZmF1bHRWYXJpYW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3B0aW9ucz8ub25Mb2FkZWQ/Lih7XHJcbiAgICAgICAgICAgICAgICBnZXQgdmFyaWFudHMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtIUl9tYXRlcmlhbHNfdmFyaWFudHMuR2V0QXZhaWxhYmxlVmFyaWFudHMocm9vdE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldCBzZWxlY3RlZFZhcmlhbnQoKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2VsZWN0ZWRWYXJpYW50ID0gS0hSX21hdGVyaWFsc192YXJpYW50cy5HZXRMYXN0U2VsZWN0ZWRWYXJpYW50KHJvb3ROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RTZWxlY3RlZFZhcmlhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtIUl9tYXRlcmlhbHNfdmFyaWFudHMuR2V0QXZhaWxhYmxlVmFyaWFudHMocm9vdE5vZGUpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXN0U2VsZWN0ZWRWYXJpYW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFNlbGVjdGVkVmFyaWFudFswXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RTZWxlY3RlZFZhcmlhbnQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0IHNlbGVjdGVkVmFyaWFudCh2YXJpYW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfdmFyaWFudHMuU2VsZWN0VmFyaWFudChyb290Tm9kZSwgdmFyaWFudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIF9sb2FkTWVzaFByaW1pdGl2ZUFzeW5jKFxyXG4gICAgICAgIGNvbnRleHQ6IHN0cmluZyxcclxuICAgICAgICBuYW1lOiBzdHJpbmcsXHJcbiAgICAgICAgbm9kZTogSU5vZGUsXHJcbiAgICAgICAgbWVzaDogSU1lc2gsXHJcbiAgICAgICAgcHJpbWl0aXZlOiBJTWVzaFByaW1pdGl2ZSxcclxuICAgICAgICBhc3NpZ246IChiYWJ5bG9uTWVzaDogQWJzdHJhY3RNZXNoKSA9PiB2b2lkXHJcbiAgICApOiBOdWxsYWJsZTxQcm9taXNlPEFic3RyYWN0TWVzaD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUtIUk1hdGVyaWFsVmFyaWFudHNfTWFwcGluZywgQWJzdHJhY3RNZXNoPihjb250ZXh0LCBwcmltaXRpdmUsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuX2xvYWRNZXNoUHJpbWl0aXZlQXN5bmMoY29udGV4dCwgbmFtZSwgbm9kZSwgbWVzaCwgcHJpbWl0aXZlLCAoYmFieWxvbk1lc2gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24oYmFieWxvbk1lc2gpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFieWxvbk1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhYnlsb25EcmF3TW9kZSA9IEdMVEZMb2FkZXIuX0dldERyYXdNb2RlKGNvbnRleHQsIHByaW1pdGl2ZS5tb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9sb2FkZXIucm9vdEJhYnlsb25NZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJvb3QgPyAocm9vdC5faW50ZXJuYWxNZXRhZGF0YSA9IHJvb3QuX2ludGVybmFsTWV0YWRhdGEgfHwge30pIDoge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsdGYgPSAobWV0YWRhdGEuZ2x0ZiA9IG1ldGFkYXRhLmdsdGYgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb25NZXRhZGF0YTogSUV4dGVuc2lvbk1ldGFkYXRhID0gKGdsdGZbTkFNRV0gPSBnbHRmW05BTUVdIHx8IHsgbGFzdFNlbGVjdGVkOiBudWxsLCBvcmlnaW5hbDogW10sIHZhcmlhbnRzOiB7fSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBtYXRlcmlhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uTWV0YWRhdGEub3JpZ2luYWwucHVzaCh7IG1lc2g6IGJhYnlsb25NZXNoLCBtYXRlcmlhbDogYmFieWxvbk1lc2gubWF0ZXJpYWwgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBtYXBwaW5nLCBsb29rIGF0IHRoZSB2YXJpYW50cyBhbmQgbWFrZSBhIG5ldyBlbnRyeSBmb3IgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbWFwcGluZ0luZGV4ID0gMDsgbWFwcGluZ0luZGV4IDwgZXh0ZW5zaW9uLm1hcHBpbmdzLmxlbmd0aDsgKyttYXBwaW5nSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBleHRlbnNpb24ubWFwcGluZ3NbbWFwcGluZ0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gQXJyYXlJdGVtLkdldChgJHtleHRlbnNpb25Db250ZXh0fS9tYXBwaW5ncy8ke21hcHBpbmdJbmRleH0vbWF0ZXJpYWxgLCB0aGlzLl9sb2FkZXIuZ2x0Zi5tYXRlcmlhbHMsIG1hcHBpbmcubWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuX2xvYWRNYXRlcmlhbEFzeW5jKGAjL21hdGVyaWFscy8ke21hcHBpbmcubWF0ZXJpYWx9YCwgbWF0ZXJpYWwsIGJhYnlsb25NZXNoLCBiYWJ5bG9uRHJhd01vZGUsIChiYWJ5bG9uTWF0ZXJpYWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbWFwcGluZ1ZhcmlhbnRJbmRleCA9IDA7IG1hcHBpbmdWYXJpYW50SW5kZXggPCBtYXBwaW5nLnZhcmlhbnRzLmxlbmd0aDsgKyttYXBwaW5nVmFyaWFudEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW50SW5kZXggPSBtYXBwaW5nLnZhcmlhbnRzW21hcHBpbmdWYXJpYW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFudCA9IEFycmF5SXRlbS5HZXQoYC9leHRlbnNpb25zLyR7TkFNRX0vdmFyaWFudHMvJHt2YXJpYW50SW5kZXh9YCwgdGhpcy5fdmFyaWFudHMsIHZhcmlhbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25NZXRhZGF0YS52YXJpYW50c1t2YXJpYW50Lm5hbWVdID0gZXh0ZW5zaW9uTWV0YWRhdGEudmFyaWFudHNbdmFyaWFudC5uYW1lXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbk1ldGFkYXRhLnZhcmlhbnRzW3ZhcmlhbnQubmFtZV0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaDogYmFieWxvbk1lc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWw6IGJhYnlsb25NYXRlcmlhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHRhcmdldCB3aGVuIG9yaWdpbmFsIG1lc2ggaXMgY2xvbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5vbkNsb25lZE9ic2VydmFibGUuYWRkKChuZXdPbmU6IE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdNZXNoID0gbmV3T25lIGFzIE1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhOiBOdWxsYWJsZTxJRXh0ZW5zaW9uTWV0YWRhdGE+ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Um9vdDogTnVsbGFibGU8Tm9kZT4gPSBuZXdNZXNoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHJvb3QgdG8gZ2V0IG1lZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IEtIUl9tYXRlcmlhbHNfdmFyaWFudHMuX0dldEV4dGVuc2lvbk1ldGFkYXRhKG5ld1Jvb3QgYXMgTWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobWV0YWRhdGEgPT09IG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNsb25lIHRoZSBtZXRhZGF0YSBvbiB0aGUgcm9vdCAoZmlyc3QgdGltZSBvbmx5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb290ICYmIG1ldGFkYXRhID09PSBLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzLl9HZXRFeHRlbnNpb25NZXRhZGF0YShyb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IG1haW4gbWV0YWRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdC5faW50ZXJuYWxNZXRhZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByb290Ll9pbnRlcm5hbE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb290Ll9pbnRlcm5hbE1ldGFkYXRhW2tleV0gPSByb290Ll9pbnRlcm5hbE1ldGFkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGdsdGYgbWV0YWRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdC5faW50ZXJuYWxNZXRhZGF0YS5nbHRmID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJvb3QuX2ludGVybmFsTWV0YWRhdGEuZ2x0Zikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdC5faW50ZXJuYWxNZXRhZGF0YS5nbHRmW2tleV0gPSByb290Ll9pbnRlcm5hbE1ldGFkYXRhLmdsdGZba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHVwbGljYXRlIHRoZSBleHRlbnNpb24gc3BlY2lmaWMgbWV0YWRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdC5faW50ZXJuYWxNZXRhZGF0YS5nbHRmW05BTUVdID0geyBsYXN0U2VsZWN0ZWQ6IG51bGwsIG9yaWdpbmFsOiBbXSwgdmFyaWFudHM6IHt9IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3JpZ2luYWwgb2YgbWV0YWRhdGEub3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvb3QuX2ludGVybmFsTWV0YWRhdGEuZ2x0ZltOQU1FXS5vcmlnaW5hbC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBvcmlnaW5hbC5tZXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsOiBvcmlnaW5hbC5tYXRlcmlhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGFkYXRhLnZhcmlhbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGFkYXRhLnZhcmlhbnRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdC5faW50ZXJuYWxNZXRhZGF0YS5nbHRmW05BTUVdLnZhcmlhbnRzW2tleV0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhcmlhbnRFbnRyeSBvZiBtZXRhZGF0YS52YXJpYW50c1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvb3QuX2ludGVybmFsTWV0YWRhdGEuZ2x0ZltOQU1FXS52YXJpYW50c1trZXldLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaDogdmFyaWFudEVudHJ5Lm1lc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbDogdmFyaWFudEVudHJ5Lm1hdGVyaWFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3Um9vdC5faW50ZXJuYWxNZXRhZGF0YS5nbHRmW05BTUVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsb2NhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBtZXRhZGF0YSEub3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5tZXNoID09PSBiYWJ5bG9uTWVzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm1lc2ggPSBuZXdNZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIG1ldGFkYXRhIS52YXJpYW50c1t2YXJpYW50Lm5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQubWVzaCA9PT0gYmFieWxvbk1lc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5tZXNoID0gbmV3TWVzaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKChbYmFieWxvbk1lc2hdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFieWxvbk1lc2g7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzKGxvYWRlcikpO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwsIElUZXh0dXJlSW5mbyB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUk1hdGVyaWFsc1ZvbHVtZSB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uLCB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX21hdGVyaWFsc192b2x1bWUgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFtTcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc192b2x1bWUvUkVBRE1FLm1kKVxyXG4gKiBAc2luY2UgNS4wLjBcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIEtIUl9tYXRlcmlhbHNfdm9sdW1lIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxNzM7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkaXNhYmxlIGluc3RhbmNlIHVzYWdlIGJlY2F1c2UgdGhlIGF0dGVudWF0aW9uIGZhY3RvciBkZXBlbmRzIG9uIHRoZSBub2RlIHNjYWxlIG9mIGVhY2ggaW5kaXZpZHVhbCBtZXNoXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5fZGlzYWJsZUluc3RhbmNlZE1lc2grKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIuX2Rpc2FibGVJbnN0YW5jZWRNZXNoLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gR0xURkxvYWRlci5Mb2FkRXh0ZW5zaW9uQXN5bmM8SUtIUk1hdGVyaWFsc1ZvbHVtZT4oY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZGVyLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZFZvbHVtZVByb3BlcnRpZXNBc3luYyhleHRlbnNpb25Db250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsLCBleHRlbnNpb24pKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZFZvbHVtZVByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwsIGV4dGVuc2lvbjogSUtIUk1hdGVyaWFsc1ZvbHVtZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICghKGJhYnlsb25NYXRlcmlhbCBpbnN0YW5jZW9mIFBCUk1hdGVyaWFsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06IE1hdGVyaWFsIHR5cGUgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdHJhbnNwYXJlbmN5IGlzbid0IGVuYWJsZWQgYWxyZWFkeSwgdGhpcyBleHRlbnNpb24gc2hvdWxkbid0IGRvIGFueXRoaW5nLlxyXG4gICAgICAgIC8vIGkuZS4gaXQgcmVxdWlyZXMgZWl0aGVyIHRoZSBLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbiBvciBLSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uIGV4dGVuc2lvbnMuXHJcbiAgICAgICAgaWYgKCghYmFieWxvbk1hdGVyaWFsLnN1YlN1cmZhY2UuaXNSZWZyYWN0aW9uRW5hYmxlZCAmJiAhYmFieWxvbk1hdGVyaWFsLnN1YlN1cmZhY2UuaXNUcmFuc2x1Y2VuY3lFbmFibGVkKSB8fCAhZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJT1IgaW4gdGhpcyBleHRlbnNpb24gb25seSBhZmZlY3RzIGludGVyaW9yLlxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5zdWJTdXJmYWNlLnZvbHVtZUluZGV4T2ZSZWZyYWN0aW9uID0gYmFieWxvbk1hdGVyaWFsLmluZGV4T2ZSZWZyYWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGF0dGVudWF0aW9uRGlzdGFuY2UgPSBleHRlbnNpb24uYXR0ZW51YXRpb25EaXN0YW5jZSAhPT0gdW5kZWZpbmVkID8gZXh0ZW5zaW9uLmF0dGVudWF0aW9uRGlzdGFuY2UgOiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5zdWJTdXJmYWNlLnRpbnRDb2xvckF0RGlzdGFuY2UgPSBhdHRlbnVhdGlvbkRpc3RhbmNlO1xyXG4gICAgICAgIGlmIChleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkICYmIGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5zdWJTdXJmYWNlLnRpbnRDb2xvci5jb3B5RnJvbUZsb2F0cyhleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvclswXSwgZXh0ZW5zaW9uLmF0dGVudWF0aW9uQ29sb3JbMV0sIGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yWzJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5zdWJTdXJmYWNlLm1pbmltdW1UaGlja25lc3MgPSAwLjA7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnN1YlN1cmZhY2UubWF4aW11bVRoaWNrbmVzcyA9IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3I7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnN1YlN1cmZhY2UudXNlVGhpY2tuZXNzQXNEZXB0aCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIChleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSBhcyBJVGV4dHVyZUluZm8pLm5vbkNvbG9yRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLmxvYWRUZXh0dXJlSW5mb0FzeW5jKGAke2NvbnRleHR9L3RoaWNrbmVzc1RleHR1cmVgLCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSkudGhlbigodGV4dHVyZTogQmFzZVRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoVGhpY2tuZXNzKWA7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuc3ViU3VyZmFjZS50aGlja25lc3NUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5zdWJTdXJmYWNlLnVzZUdsdGZTdHlsZVRleHR1cmVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgS0hSX21hdGVyaWFsc192b2x1bWUobG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgdHlwZSB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiS0hSX21lc2hfcXVhbnRpemF0aW9uXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX21lc2hfcXVhbnRpemF0aW9uIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfbWVzaF9xdWFudGl6YXRpb25cIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21haW4vZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWVzaF9xdWFudGl6YXRpb24vUkVBRE1FLm1kKVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX21lc2hfcXVhbnRpemF0aW9uIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGxvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKSB7fVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbWVzaF9xdWFudGl6YXRpb24obG9hZGVyKSk7XHJcbiIsImltcG9ydCB7IEZsb3dHcmFwaEJsb2NrTmFtZXMgfSBmcm9tIFwiY29yZS9GbG93R3JhcGgvQmxvY2tzL2Zsb3dHcmFwaEJsb2NrTmFtZXNcIjtcbmltcG9ydCB0eXBlIHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XG5pbXBvcnQgeyBhZGROZXdJbnRlcmFjdGl2aXR5Rmxvd0dyYXBoTWFwcGluZyB9IGZyb20gXCIuL0tIUl9pbnRlcmFjdGl2aXR5L2RlY2xhcmF0aW9uTWFwcGVyXCI7XG5pbXBvcnQgdHlwZSB7IElOb2RlIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBBZGRPYmplY3RBY2Nlc3NvclRvS2V5IH0gZnJvbSBcIi4vb2JqZWN0TW9kZWxNYXBwaW5nXCI7XG5cbmNvbnN0IE5BTUUgPSBcIktIUl9ub2RlX2hvdmVyYWJpbGl0eVwiO1xuXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIEtIUl9ub2RlX2hvdmVyYWJpbGl0eSBleHRlbnNpb24uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cbiAgICAgICAgW1wiS0hSX25vZGVfaG92ZXJhYmlsaXR5XCJdOiB7fTtcbiAgICB9XG59XG5cbi8vIGludGVyYWN0aXZpdHlcbmNvbnN0IE1lc2hQb2ludGVyT3ZlclByZWZpeCA9IFwidGFyZ2V0TWVzaFBvaW50ZXJPdmVyX1wiO1xuYWRkTmV3SW50ZXJhY3Rpdml0eUZsb3dHcmFwaE1hcHBpbmcoXCJldmVudC9vbkhvdmVySW5cIiwgTkFNRSwge1xuICAgIC8vIHVzaW5nIEdldFZhcmlhYmxlIGFzIHRoZSBub2RlSW5kZXggaXMgYSBjb25maWd1cmF0aW9uIGFuZCBub3QgYSB2YWx1ZSAoaS5lLiBpdCdzIG5vdCBtdXRhYmxlKVxuICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuUG9pbnRlck92ZXJFdmVudCwgRmxvd0dyYXBoQmxvY2tOYW1lcy5HZXRWYXJpYWJsZSwgRmxvd0dyYXBoQmxvY2tOYW1lcy5JbmRleE9mLCBcIktIUl9pbnRlcmFjdGl2aXR5L0Zsb3dHcmFwaEdMVEZEYXRhUHJvdmlkZXJcIl0sXG4gICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICBzdG9wUHJvcGFnYXRpb246IHsgbmFtZTogXCJzdG9wUHJvcGFnYXRpb25cIiB9LFxuICAgICAgICBub2RlSW5kZXg6IHtcbiAgICAgICAgICAgIG5hbWU6IFwidmFyaWFibGVcIixcbiAgICAgICAgICAgIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuR2V0VmFyaWFibGUsXG4gICAgICAgICAgICBkYXRhVHJhbnNmb3JtZXIoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbTWVzaFBvaW50ZXJPdmVyUHJlZml4ICsgZGF0YVswXV07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgb3V0cHV0czoge1xuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGhvdmVyTm9kZUluZGV4OiB7IG5hbWU6IFwiaW5kZXhcIiwgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5JbmRleE9mIH0sXG4gICAgICAgICAgICBjb250cm9sbGVySW5kZXg6IHsgbmFtZTogXCJwb2ludGVySWRcIiB9LFxuICAgICAgICB9LFxuICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgb3V0OiB7IG5hbWU6IFwiZG9uZVwiIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBpbnRlckJsb2NrQ29ubmVjdG9yczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBpbnB1dDogXCJ0YXJnZXRNZXNoXCIsXG4gICAgICAgICAgICBvdXRwdXQ6IFwidmFsdWVcIixcbiAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDEsXG4gICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBpbnB1dDogXCJhcnJheVwiLFxuICAgICAgICAgICAgb3V0cHV0OiBcIm5vZGVzXCIsXG4gICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDIsXG4gICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAzLFxuICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBvdXRwdXQ6IFwibWVzaFVuZGVyUG9pbnRlclwiLFxuICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAyLFxuICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMCxcbiAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBleHRyYVByb2Nlc3NvcihnbHRmQmxvY2ssIF9kZWNsYXJhdGlvbiwgX21hcHBpbmcsIF9hcnJheXMsIHNlcmlhbGl6ZWRPYmplY3RzLCBjb250ZXh0LCBnbG9iYWxHTFRGKSB7XG4gICAgICAgIC8vIGFkZCB0aGUgZ2xURiB0byB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbGFzdCBzZXJpYWxpemVkIG9iamVjdFxuICAgICAgICBjb25zdCBzZXJpYWxpemVkT2JqZWN0ID0gc2VyaWFsaXplZE9iamVjdHNbc2VyaWFsaXplZE9iamVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnID0gc2VyaWFsaXplZE9iamVjdC5jb25maWcgfHwge307XG4gICAgICAgIHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnLmdsVEYgPSBnbG9iYWxHTFRGO1xuICAgICAgICAvLyBmaW5kIHRoZSBsaXN0ZW5lciBub2RlSW5kZXggdmFsdWVcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gZ2x0ZkJsb2NrLmNvbmZpZ3VyYXRpb24/LltcIm5vZGVJbmRleFwiXT8udmFsdWVbMF07XG4gICAgICAgIGlmIChub2RlSW5kZXggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygbm9kZUluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlSW5kZXggbm90IGZvdW5kIGluIGNvbmZpZ3VyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gTWVzaFBvaW50ZXJPdmVyUHJlZml4ICsgbm9kZUluZGV4O1xuICAgICAgICAvLyBmaW5kIHRoZSBub2RlSW5kZXggdmFsdWVcbiAgICAgICAgc2VyaWFsaXplZE9iamVjdHNbMV0uY29uZmlnLnZhcmlhYmxlID0gdmFyaWFibGVOYW1lO1xuICAgICAgICBjb250ZXh0Ll91c2VyVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV0gPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiTWVzaFwiLFxuICAgICAgICAgICAgaWQ6IGdsb2JhbEdMVEY/Lm5vZGVzPy5bbm9kZUluZGV4XS5fYmFieWxvblRyYW5zZm9ybU5vZGU/LmlkLFxuICAgICAgICAgICAgdW5pcXVlSWQ6IGdsb2JhbEdMVEY/Lm5vZGVzPy5bbm9kZUluZGV4XS5fYmFieWxvblRyYW5zZm9ybU5vZGU/LnVuaXF1ZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZE9iamVjdHM7XG4gICAgfSxcbn0pO1xuXG5jb25zdCBNZXNoUG9pbnRlck91dFByZWZpeCA9IFwidGFyZ2V0TWVzaFBvaW50ZXJPdXRfXCI7XG5hZGROZXdJbnRlcmFjdGl2aXR5Rmxvd0dyYXBoTWFwcGluZyhcImV2ZW50L29uSG92ZXJPdXRcIiwgTkFNRSwge1xuICAgIC8vIHVzaW5nIEdldFZhcmlhYmxlIGFzIHRoZSBub2RlSW5kZXggaXMgYSBjb25maWd1cmF0aW9uIGFuZCBub3QgYSB2YWx1ZSAoaS5lLiBpdCdzIG5vdCBtdXRhYmxlKVxuICAgIGJsb2NrczogW0Zsb3dHcmFwaEJsb2NrTmFtZXMuUG9pbnRlck91dEV2ZW50LCBGbG93R3JhcGhCbG9ja05hbWVzLkdldFZhcmlhYmxlLCBGbG93R3JhcGhCbG9ja05hbWVzLkluZGV4T2YsIFwiS0hSX2ludGVyYWN0aXZpdHkvRmxvd0dyYXBoR0xURkRhdGFQcm92aWRlclwiXSxcbiAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogeyBuYW1lOiBcInN0b3BQcm9wYWdhdGlvblwiIH0sXG4gICAgICAgIG5vZGVJbmRleDoge1xuICAgICAgICAgICAgbmFtZTogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgICAgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5HZXRWYXJpYWJsZSxcbiAgICAgICAgICAgIGRhdGFUcmFuc2Zvcm1lcihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtNZXNoUG9pbnRlck91dFByZWZpeCArIGRhdGFbMF1dO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG91dHB1dHM6IHtcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBob3Zlck5vZGVJbmRleDogeyBuYW1lOiBcImluZGV4XCIsIHRvQmxvY2s6IEZsb3dHcmFwaEJsb2NrTmFtZXMuSW5kZXhPZiB9LFxuICAgICAgICAgICAgY29udHJvbGxlckluZGV4OiB7IG5hbWU6IFwicG9pbnRlcklkXCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmxvd3M6IHtcbiAgICAgICAgICAgIG91dDogeyBuYW1lOiBcImRvbmVcIiB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgaW50ZXJCbG9ja0Nvbm5lY3RvcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXQ6IFwidGFyZ2V0TWVzaFwiLFxuICAgICAgICAgICAgb3V0cHV0OiBcInZhbHVlXCIsXG4gICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXQ6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIG91dHB1dDogXCJub2Rlc1wiLFxuICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAyLFxuICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMyxcbiAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlucHV0OiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgb3V0cHV0OiBcIm1lc2hPdXRPZlBvaW50ZXJcIixcbiAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMixcbiAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgZXh0cmFQcm9jZXNzb3IoZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBfYXJyYXlzLCBzZXJpYWxpemVkT2JqZWN0cywgY29udGV4dCwgZ2xvYmFsR0xURikge1xuICAgICAgICAvLyBhZGQgdGhlIGdsVEYgdG8gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGxhc3Qgc2VyaWFsaXplZCBvYmplY3RcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZWRPYmplY3RzW3NlcmlhbGl6ZWRPYmplY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyA9IHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnIHx8IHt9O1xuICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5nbFRGID0gZ2xvYmFsR0xURjtcblxuICAgICAgICBjb25zdCBub2RlSW5kZXggPSBnbHRmQmxvY2suY29uZmlndXJhdGlvbj8uW1wibm9kZUluZGV4XCJdPy52YWx1ZVswXTtcbiAgICAgICAgaWYgKG5vZGVJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBub2RlSW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGVJbmRleCBub3QgZm91bmQgaW4gY29uZmlndXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBNZXNoUG9pbnRlck91dFByZWZpeCArIG5vZGVJbmRleDtcbiAgICAgICAgLy8gZmluZCB0aGUgbm9kZUluZGV4IHZhbHVlXG4gICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzFdLmNvbmZpZy52YXJpYWJsZSA9IHZhcmlhYmxlTmFtZTtcbiAgICAgICAgY29udGV4dC5fdXNlclZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIk1lc2hcIixcbiAgICAgICAgICAgIGlkOiBnbG9iYWxHTFRGPy5ub2Rlcz8uW25vZGVJbmRleF0uX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5pZCxcbiAgICAgICAgICAgIHVuaXF1ZUlkOiBnbG9iYWxHTFRGPy5ub2Rlcz8uW25vZGVJbmRleF0uX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy51bmlxdWVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRPYmplY3RzO1xuICAgIH0sXG59KTtcblxuQWRkT2JqZWN0QWNjZXNzb3JUb0tleShcIi9ub2Rlcy97fS9leHRlbnNpb25zL0tIUl9ub2RlX2hvdmVyYWJpbGl0eS9ob3ZlcmFibGVcIiwge1xuICAgIGdldDogKG5vZGU6IElOb2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRuID0gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUgYXMgYW55O1xuICAgICAgICBpZiAodG4gJiYgdG4ucG9pbnRlck92ZXJEaXNhYmxlTWVzaFRlc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRuLnBvaW50ZXJPdmVyRGlzYWJsZU1lc2hUZXN0aW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2V0OiAodmFsdWU6IGJvb2xlYW4sIG5vZGU6IElOb2RlKSA9PiB7XG4gICAgICAgIG5vZGUuX3ByaW1pdGl2ZUJhYnlsb25NZXNoZXM/LmZvckVhY2goKG1lc2gpID0+IHtcbiAgICAgICAgICAgIG1lc2gucG9pbnRlck92ZXJEaXNhYmxlTWVzaFRlc3RpbmcgPSAhdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLFxuICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwicG9pbnRlck92ZXJEaXNhYmxlTWVzaFRlc3RpbmdcIl0sXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG59KTtcblxuLyoqXG4gKiBMb2FkZXIgZXh0ZW5zaW9uIGZvciBLSFJfbm9kZV9ob3ZlcmFiaWxpdHlcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3B1bGwvMjQyNlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY2xhc3MgS0hSX25vZGVfaG92ZXJhYmlsaXR5IGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGxvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICBwdWJsaWMgYXN5bmMgb25SZWFkeSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5fbG9hZGVyLmdsdGYubm9kZXM/LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgdHJ1ZSwgc28gb25seSBhcHBseSBpZiBmYWxzZVxuICAgICAgICAgICAgaWYgKG5vZGUuZXh0ZW5zaW9ucz8uS0hSX25vZGVfaG92ZXJhYmlsaXR5ICYmIG5vZGUuZXh0ZW5zaW9ucz8uS0hSX25vZGVfaG92ZXJhYmlsaXR5LmhvdmVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8uZ2V0Q2hpbGRNZXNoZXMoKS5mb3JFYWNoKChtZXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2gucG9pbnRlck92ZXJEaXNhYmxlTWVzaFRlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcbiAgICAgICAgKHRoaXMuX2xvYWRlciBhcyBhbnkpID0gbnVsbDtcbiAgICB9XG59XG5cbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBLSFJfbm9kZV9ob3ZlcmFiaWxpdHkobG9hZGVyKSk7XG4iLCJpbXBvcnQgeyBGbG93R3JhcGhCbG9ja05hbWVzIH0gZnJvbSBcImNvcmUvRmxvd0dyYXBoL0Jsb2Nrcy9mbG93R3JhcGhCbG9ja05hbWVzXCI7XG5pbXBvcnQgdHlwZSB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xuaW1wb3J0IHsgYWRkTmV3SW50ZXJhY3Rpdml0eUZsb3dHcmFwaE1hcHBpbmcgfSBmcm9tIFwiLi9LSFJfaW50ZXJhY3Rpdml0eS9kZWNsYXJhdGlvbk1hcHBlclwiO1xuaW1wb3J0IHR5cGUgeyBJTm9kZSB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgQWRkT2JqZWN0QWNjZXNzb3JUb0tleSB9IGZyb20gXCIuL29iamVjdE1vZGVsTWFwcGluZ1wiO1xuXG5jb25zdCBOQU1FID0gXCJLSFJfbm9kZV9zZWxlY3RhYmlsaXR5XCI7XG5cbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX3NlbGVjdGFiaWxpdHkgZXh0ZW5zaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXG4gICAgICAgIFtcIktIUl9ub2RlX3NlbGVjdGFiaWxpdHlcIl06IHt9O1xuICAgIH1cbn1cblxuLy8gYWRkIHRoZSBpbnRlcmFjdGl2aXR5IG1hcHBpbmcgZm9yIHRoZSBvblNlbGVjdCBldmVudFxuYWRkTmV3SW50ZXJhY3Rpdml0eUZsb3dHcmFwaE1hcHBpbmcoXCJldmVudC9vblNlbGVjdFwiLCBOQU1FLCB7XG4gICAgLy8gdXNpbmcgR2V0VmFyaWFibGUgYXMgdGhlIG5vZGVJbmRleCBpcyBhIGNvbmZpZ3VyYXRpb24gYW5kIG5vdCBhIHZhbHVlIChpLmUuIGl0J3Mgbm90IG11dGFibGUpXG4gICAgYmxvY2tzOiBbRmxvd0dyYXBoQmxvY2tOYW1lcy5NZXNoUGlja0V2ZW50LCBGbG93R3JhcGhCbG9ja05hbWVzLkdldFZhcmlhYmxlLCBGbG93R3JhcGhCbG9ja05hbWVzLkluZGV4T2YsIFwiS0hSX2ludGVyYWN0aXZpdHkvRmxvd0dyYXBoR0xURkRhdGFQcm92aWRlclwiXSxcbiAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogeyBuYW1lOiBcInN0b3BQcm9wYWdhdGlvblwiIH0sXG4gICAgICAgIG5vZGVJbmRleDoge1xuICAgICAgICAgICAgbmFtZTogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgICAgdG9CbG9jazogRmxvd0dyYXBoQmxvY2tOYW1lcy5HZXRWYXJpYWJsZSxcbiAgICAgICAgICAgIGRhdGFUcmFuc2Zvcm1lcihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcInBpY2tlZE1lc2hfXCIgKyBkYXRhWzBdXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvdXRwdXRzOiB7XG4gICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2RlSW5kZXg6IHsgbmFtZTogXCJpbmRleFwiLCB0b0Jsb2NrOiBGbG93R3JhcGhCbG9ja05hbWVzLkluZGV4T2YgfSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJJbmRleDogeyBuYW1lOiBcInBvaW50ZXJJZFwiIH0sXG4gICAgICAgICAgICBzZWxlY3Rpb25Qb2ludDogeyBuYW1lOiBcInBpY2tlZFBvaW50XCIgfSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJheU9yaWdpbjogeyBuYW1lOiBcInBpY2tPcmlnaW5cIiB9LFxuICAgICAgICB9LFxuICAgICAgICBmbG93czoge1xuICAgICAgICAgICAgb3V0OiB7IG5hbWU6IFwiZG9uZVwiIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBpbnRlckJsb2NrQ29ubmVjdG9yczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBpbnB1dDogXCJhc3NldFwiLFxuICAgICAgICAgICAgb3V0cHV0OiBcInZhbHVlXCIsXG4gICAgICAgICAgICBpbnB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICBvdXRwdXRCbG9ja0luZGV4OiAxLFxuICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXQ6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIG91dHB1dDogXCJub2Rlc1wiLFxuICAgICAgICAgICAgaW5wdXRCbG9ja0luZGV4OiAyLFxuICAgICAgICAgICAgb3V0cHV0QmxvY2tJbmRleDogMyxcbiAgICAgICAgICAgIGlzVmFyaWFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlucHV0OiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgb3V0cHV0OiBcInBpY2tlZE1lc2hcIixcbiAgICAgICAgICAgIGlucHV0QmxvY2tJbmRleDogMixcbiAgICAgICAgICAgIG91dHB1dEJsb2NrSW5kZXg6IDAsXG4gICAgICAgICAgICBpc1ZhcmlhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgZXh0cmFQcm9jZXNzb3IoZ2x0ZkJsb2NrLCBfZGVjbGFyYXRpb24sIF9tYXBwaW5nLCBfYXJyYXlzLCBzZXJpYWxpemVkT2JqZWN0cywgY29udGV4dCwgZ2xvYmFsR0xURikge1xuICAgICAgICAvLyBhZGQgdGhlIGdsVEYgdG8gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGxhc3Qgc2VyaWFsaXplZCBvYmplY3RcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZWRPYmplY3RzW3NlcmlhbGl6ZWRPYmplY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZyA9IHNlcmlhbGl6ZWRPYmplY3QuY29uZmlnIHx8IHt9O1xuICAgICAgICBzZXJpYWxpemVkT2JqZWN0LmNvbmZpZy5nbFRGID0gZ2xvYmFsR0xURjtcbiAgICAgICAgLy8gZmluZCB0aGUgbGlzdGVuZXIgbm9kZUluZGV4IHZhbHVlXG4gICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IGdsdGZCbG9jay5jb25maWd1cmF0aW9uPy5bXCJub2RlSW5kZXhcIl0/LnZhbHVlWzBdO1xuICAgICAgICBpZiAobm9kZUluZGV4ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG5vZGVJbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZUluZGV4IG5vdCBmb3VuZCBpbiBjb25maWd1cmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IFwicGlja2VkTWVzaF9cIiArIG5vZGVJbmRleDtcbiAgICAgICAgLy8gZmluZCB0aGUgbm9kZUluZGV4IHZhbHVlXG4gICAgICAgIHNlcmlhbGl6ZWRPYmplY3RzWzFdLmNvbmZpZy52YXJpYWJsZSA9IHZhcmlhYmxlTmFtZTtcbiAgICAgICAgY29udGV4dC5fdXNlclZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIk1lc2hcIixcbiAgICAgICAgICAgIGlkOiBnbG9iYWxHTFRGPy5ub2Rlcz8uW25vZGVJbmRleF0uX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5pZCxcbiAgICAgICAgICAgIHVuaXF1ZUlkOiBnbG9iYWxHTFRGPy5ub2Rlcz8uW25vZGVJbmRleF0uX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy51bmlxdWVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRPYmplY3RzO1xuICAgIH0sXG59KTtcblxuLy8gb2JqZWN0IG1vZGVsIGV4dGVuc2lvbiBmb3Igc2VsZWN0YWJsZVxuQWRkT2JqZWN0QWNjZXNzb3JUb0tleShcIi9ub2Rlcy97fS9leHRlbnNpb25zL0tIUl9ub2RlX3NlbGVjdGFiaWxpdHkvc2VsZWN0YWJsZVwiLCB7XG4gICAgZ2V0OiAobm9kZTogSU5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgdG4gPSBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSBhcyBhbnk7XG4gICAgICAgIGlmICh0biAmJiB0bi5pc1BpY2thYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0bi5pc1BpY2thYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2V0OiAodmFsdWU6IGJvb2xlYW4sIG5vZGU6IElOb2RlKSA9PiB7XG4gICAgICAgIG5vZGUuX3ByaW1pdGl2ZUJhYnlsb25NZXNoZXM/LmZvckVhY2goKG1lc2gpID0+IHtcbiAgICAgICAgICAgIG1lc2guaXNQaWNrYWJsZSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGdldFRhcmdldDogKG5vZGU6IElOb2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSxcbiAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcImlzUGlja2FibGVcIl0sXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG59KTtcblxuLyoqXG4gKiBMb2FkZXIgZXh0ZW5zaW9uIGZvciBLSFJfc2VsZWN0YWJpbGl0eVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY2xhc3MgS0hSX25vZGVfc2VsZWN0YWJpbGl0eSBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBsb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgcHVibGljIGFzeW5jIG9uUmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuX2xvYWRlci5nbHRmLm5vZGVzPy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5leHRlbnNpb25zPy5LSFJfbm9kZV9zZWxlY3RhYmlsaXR5ICYmIG5vZGUuZXh0ZW5zaW9ucz8uS0hSX25vZGVfc2VsZWN0YWJpbGl0eS5zZWxlY3RhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5nZXRDaGlsZE1lc2hlcygpLmZvckVhY2goKG1lc2gpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzaC5pc1BpY2thYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xuICAgIH1cbn1cblxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9ub2RlX3NlbGVjdGFiaWxpdHkobG9hZGVyKSk7XG4iLCJpbXBvcnQgdHlwZSB7IEFic3RyYWN0TWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9hYnN0cmFjdE1lc2hcIjtcbmltcG9ydCB0eXBlIHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XG5pbXBvcnQgdHlwZSB7IElOb2RlIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBBZGRPYmplY3RBY2Nlc3NvclRvS2V5IH0gZnJvbSBcIi4vb2JqZWN0TW9kZWxNYXBwaW5nXCI7XG5cbmNvbnN0IE5BTUUgPSBcIktIUl9ub2RlX3Zpc2liaWxpdHlcIjtcblxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfbm9kZV92aXNpYmlsaXR5IGV4dGVuc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxuICAgICAgICBbXCJLSFJfbm9kZV92aXNpYmlsaXR5XCJdOiB7fTtcbiAgICB9XG59XG5cbi8vIG9iamVjdCBtb2RlbCBleHRlbnNpb24gZm9yIHZpc2liaWxpdHlcbkFkZE9iamVjdEFjY2Vzc29yVG9LZXkoXCIvbm9kZXMve30vZXh0ZW5zaW9ucy9LSFJfbm9kZV92aXNpYmlsaXR5L3Zpc2libGVcIiwge1xuICAgIGdldDogKG5vZGU6IElOb2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRuID0gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUgYXMgYW55O1xuICAgICAgICBpZiAodG4gJiYgdG4uaXNWaXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0bi5pc1Zpc2libGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBzZXQ6ICh2YWx1ZTogYm9vbGVhbiwgbm9kZTogSU5vZGUpID0+IHtcbiAgICAgICAgbm9kZS5fcHJpbWl0aXZlQmFieWxvbk1lc2hlcz8uZm9yRWFjaCgobWVzaCkgPT4ge1xuICAgICAgICAgICAgbWVzaC5pbmhlcml0VmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUpIHtcbiAgICAgICAgICAgIChub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSBhcyBBYnN0cmFjdE1lc2gpLmlzVmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuX3ByaW1pdGl2ZUJhYnlsb25NZXNoZXM/LmZvckVhY2goKG1lc2gpID0+IHtcbiAgICAgICAgICAgIG1lc2guaXNWaXNpYmxlID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLFxuICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwiaXNWaXNpYmxlXCJdLFxuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxufSk7XG5cbi8qKlxuICogTG9hZGVyIGV4dGVuc2lvbiBmb3IgS0hSX25vZGVfdmlzaWJpbGl0eVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY2xhc3MgS0hSX25vZGVfdmlzaWJpbGl0eSBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBsb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgcHVibGljIGFzeW5jIG9uUmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuX2xvYWRlci5nbHRmLm5vZGVzPy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBub2RlLl9wcmltaXRpdmVCYWJ5bG9uTWVzaGVzPy5mb3JFYWNoKChtZXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVzaC5pbmhlcml0VmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIEpTT04gUG9pbnRlciBpcyB1c2VkIHdlIG5lZWQgdG8gY2hhbmdlIGJvdGggdGhlIHRyYW5zZm9ybSBub2RlIGFuZCB0aGUgcHJpbWl0aXZlIG1lc2hlcyB0byB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgICAgaWYgKG5vZGUuZXh0ZW5zaW9ucz8uS0hSX25vZGVfdmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmV4dGVuc2lvbnM/LktIUl9ub2RlX3Zpc2liaWxpdHkudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUgYXMgQWJzdHJhY3RNZXNoKS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLl9wcmltaXRpdmVCYWJ5bG9uTWVzaGVzPy5mb3JFYWNoKChtZXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xuICAgIH1cbn1cblxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl9ub2RlX3Zpc2liaWxpdHkobG9hZGVyKSk7XG4iLCJpbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciwgQXJyYXlJdGVtIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJVGV4dHVyZSB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlXCI7XHJcbmltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElLSFJUZXh0dXJlQmFzaXNVIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiS0hSX3RleHR1cmVfYmFzaXN1XCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgS0hSX3RleHR1cmVfYmFzaXN1IGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJLSFJfdGV4dHVyZV9iYXNpc3VcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21haW4vZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfdGV4dHVyZV9iYXNpc3UvUkVBRE1FLm1kKVxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX3RleHR1cmVfYmFzaXN1IGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLiAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC4gKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXI6IEdMVEZMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIF9sb2FkVGV4dHVyZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgdGV4dHVyZTogSVRleHR1cmUsIGFzc2lnbjogKGJhYnlsb25UZXh0dXJlOiBCYXNlVGV4dHVyZSkgPT4gdm9pZCk6IE51bGxhYmxlPFByb21pc2U8QmFzZVRleHR1cmU+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElLSFJUZXh0dXJlQmFzaXNVLCBCYXNlVGV4dHVyZT4oY29udGV4dCwgdGV4dHVyZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZXIgPSB0ZXh0dXJlLnNhbXBsZXIgPT0gdW5kZWZpbmVkID8gR0xURkxvYWRlci5EZWZhdWx0U2FtcGxlciA6IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vc2FtcGxlcmAsIHRoaXMuX2xvYWRlci5nbHRmLnNhbXBsZXJzLCB0ZXh0dXJlLnNhbXBsZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IEFycmF5SXRlbS5HZXQoYCR7ZXh0ZW5zaW9uQ29udGV4dH0vc291cmNlYCwgdGhpcy5fbG9hZGVyLmdsdGYuaW1hZ2VzLCBleHRlbnNpb24uc291cmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2xvYWRlci5fY3JlYXRlVGV4dHVyZUFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAgIHNhbXBsZXIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgICAgIChiYWJ5bG9uVGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fdGV4dHVyZUluZm8ubm9uQ29sb3JEYXRhID8geyB1c2VSR0JBSWZBU1RDQkM3Tm90QXZhaWxhYmxlV2hlblVBU1RDOiB0cnVlIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAhdGV4dHVyZS5fdGV4dHVyZUluZm8ubm9uQ29sb3JEYXRhXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl90ZXh0dXJlX2Jhc2lzdShsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcclxuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9UZXh0dXJlcy90ZXh0dXJlXCI7XHJcblxyXG5pbXBvcnQgdHlwZSB7IElUZXh0dXJlSW5mbyB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUlRleHR1cmVUcmFuc2Zvcm0gfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfdGV4dHVyZV90cmFuc2Zvcm1cIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfdGV4dHVyZV90cmFuc2Zvcm0gZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl90ZXh0dXJlX3RyYW5zZm9ybVwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybS9SRUFETUUubWQpXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBLSFJfdGV4dHVyZV90cmFuc2Zvcm0gaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZFRleHR1cmVJbmZvQXN5bmMoY29udGV4dDogc3RyaW5nLCB0ZXh0dXJlSW5mbzogSVRleHR1cmVJbmZvLCBhc3NpZ246IChiYWJ5bG9uVGV4dHVyZTogQmFzZVRleHR1cmUpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPEJhc2VUZXh0dXJlPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJS0hSVGV4dHVyZVRyYW5zZm9ybSwgQmFzZVRleHR1cmU+KGNvbnRleHQsIHRleHR1cmVJbmZvLCB0aGlzLm5hbWUsIGFzeW5jIChleHRlbnNpb25Db250ZXh0LCBleHRlbnNpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2xvYWRlci5sb2FkVGV4dHVyZUluZm9Bc3luYyhjb250ZXh0LCB0ZXh0dXJlSW5mbywgKGJhYnlsb25UZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShiYWJ5bG9uVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V4dGVuc2lvbkNvbnRleHR9OiBUZXh0dXJlIHR5cGUgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24ub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvblRleHR1cmUudU9mZnNldCA9IGV4dGVuc2lvbi5vZmZzZXRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvblRleHR1cmUudk9mZnNldCA9IGV4dGVuc2lvbi5vZmZzZXRbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHJvdGF0ZSBhcm91bmQgdGhlIG9yaWdpbi5cclxuICAgICAgICAgICAgICAgIGJhYnlsb25UZXh0dXJlLnVSb3RhdGlvbkNlbnRlciA9IDA7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uVGV4dHVyZS52Um90YXRpb25DZW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24ucm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uVGV4dHVyZS53QW5nID0gLWV4dGVuc2lvbi5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvblRleHR1cmUudVNjYWxlID0gZXh0ZW5zaW9uLnNjYWxlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25UZXh0dXJlLnZTY2FsZSA9IGV4dGVuc2lvbi5zY2FsZVsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnRleENvb3JkICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25UZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXggPSBleHRlbnNpb24udGV4Q29vcmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGJhYnlsb25UZXh0dXJlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IEtIUl90ZXh0dXJlX3RyYW5zZm9ybShsb2FkZXIpKTtcclxuIiwiaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB0eXBlIHsgR0xURkxvYWRlciB9IGZyb20gXCIuLi9nbFRGTG9hZGVyXCI7XHJcbmltcG9ydCB0eXBlIHsgSUtIUlhtcEpzb25MZF9HbHRmLCBJS0hSWG1wSnNvbkxkX05vZGUgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5jb25zdCBOQU1FID0gXCJLSFJfeG1wX2pzb25fbGRcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBLSFJfeG1wX2pzb25fbGQgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIktIUl94bXBfanNvbl9sZFwiXToge307XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBbU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl94bXBfanNvbl9sZC9SRUFETUUubWQpXHJcbiAqIEBzaW5jZSA1LjAuMFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgY2xhc3MgS0hSX3htcF9qc29uX2xkIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxMDA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGxvYWRlciBzdGF0ZSBjaGFuZ2VzIHRvIExPQURJTkcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkxvYWRpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlci5yb290QmFieWxvbk1lc2ggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeG1wR2x0ZiA9IHRoaXMuX2xvYWRlci5nbHRmLmV4dGVuc2lvbnM/LktIUl94bXBfanNvbl9sZCBhcyBJS0hSWG1wSnNvbkxkX0dsdGY7XHJcbiAgICAgICAgY29uc3QgeG1wTm9kZSA9IHRoaXMuX2xvYWRlci5nbHRmLmFzc2V0Py5leHRlbnNpb25zPy5LSFJfeG1wX2pzb25fbGQgYXMgSUtIUlhtcEpzb25MZF9Ob2RlO1xyXG4gICAgICAgIGlmICh4bXBHbHRmICYmIHhtcE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gK3htcE5vZGUucGFja2V0O1xyXG4gICAgICAgICAgICBpZiAoeG1wR2x0Zi5wYWNrZXRzICYmIHBhY2tldCA8IHhtcEdsdGYucGFja2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5yb290QmFieWxvbk1lc2gubWV0YWRhdGEgPSB0aGlzLl9sb2FkZXIucm9vdEJhYnlsb25NZXNoLm1ldGFkYXRhIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLnJvb3RCYWJ5bG9uTWVzaC5tZXRhZGF0YS54bXAgPSB4bXBHbHRmLnBhY2tldHNbcGFja2V0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgS0hSX3htcF9qc29uX2xkKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEFuaW1hdGlvbkdyb3VwIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRpb25Hcm91cFwiO1xyXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0aW9uRXZlbnRcIjtcclxuaW1wb3J0IHR5cGUgeyBUcmFuc2Zvcm1Ob2RlIH0gZnJvbSBcImNvcmUvTWVzaGVzL3RyYW5zZm9ybU5vZGVcIjtcclxuaW1wb3J0IHsgU291bmQgfSBmcm9tIFwiY29yZS9BdWRpby9zb3VuZFwiO1xyXG5pbXBvcnQgeyBXZWlnaHRlZFNvdW5kIH0gZnJvbSBcImNvcmUvQXVkaW8vd2VpZ2h0ZWRzb3VuZFwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJQXJyYXlJdGVtLCBJU2NlbmUsIElOb2RlLCBJQW5pbWF0aW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEZMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyLCBBcnJheUl0ZW0gfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElNU0ZUQXVkaW9FbWl0dGVyX0NsaXAsIElNU0ZUQXVkaW9FbWl0dGVyX0VtaXR0ZXIsIElNU0ZUQXVkaW9FbWl0dGVyX0VtaXR0ZXJzUmVmZXJlbmNlLCBJTVNGVEF1ZGlvRW1pdHRlcl9BbmltYXRpb25FdmVudCB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgSU1TRlRBdWRpb0VtaXR0ZXJfQW5pbWF0aW9uRXZlbnRBY3Rpb24gfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IHJlZ2lzdGVyR0xURkV4dGVuc2lvbiwgdW5yZWdpc3RlckdMVEZFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcblxyXG5pbXBvcnQgXCJjb3JlL0F1ZGlvL2F1ZGlvU2NlbmVDb21wb25lbnRcIjtcclxuXHJcbmNvbnN0IE5BTUUgPSBcIk1TRlRfYXVkaW9fZW1pdHRlclwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIE1TRlRfYXVkaW9fZW1pdHRlciBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiTVNGVF9hdWRpb19lbWl0dGVyXCJdOiB7fTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIElMb2FkZXJDbGlwIGV4dGVuZHMgSU1TRlRBdWRpb0VtaXR0ZXJfQ2xpcCwgSUFycmF5SXRlbSB7XHJcbiAgICBfb2JqZWN0VVJMPzogUHJvbWlzZTxzdHJpbmc+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSUxvYWRlckVtaXR0ZXIgZXh0ZW5kcyBJTVNGVEF1ZGlvRW1pdHRlcl9FbWl0dGVyLCBJQXJyYXlJdGVtIHtcclxuICAgIF9iYWJ5bG9uRGF0YT86IHtcclxuICAgICAgICBzb3VuZD86IFdlaWdodGVkU291bmQ7XHJcbiAgICAgICAgbG9hZGVkOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgfTtcclxuICAgIF9iYWJ5bG9uU291bmRzOiBTb3VuZFtdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSU1TRlRBdWRpb0VtaXR0ZXIge1xyXG4gICAgY2xpcHM6IElMb2FkZXJDbGlwW107XHJcbiAgICBlbWl0dGVyczogSUxvYWRlckVtaXR0ZXJbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIElMb2FkZXJBbmltYXRpb25FdmVudCBleHRlbmRzIElNU0ZUQXVkaW9FbWl0dGVyX0FuaW1hdGlvbkV2ZW50LCBJQXJyYXlJdGVtIHt9XHJcblxyXG5pbnRlcmZhY2UgSUxvYWRlckFuaW1hdGlvbkV2ZW50cyB7XHJcbiAgICBldmVudHM6IElMb2FkZXJBbmltYXRpb25FdmVudFtdO1xyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9uYWphZG9qby9nbFRGL2Jsb2IvTVNGVF9hdWRpb19lbWl0dGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9NU0ZUX2F1ZGlvX2VtaXR0ZXIvUkVBRE1FLm1kKVxyXG4gKiAhISEgRXhwZXJpbWVudGFsIEV4dGVuc2lvbiBTdWJqZWN0IHRvIENoYW5nZXMgISEhXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjbGFzcyBNU0ZUX2F1ZGlvX2VtaXR0ZXIgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhpcyBleHRlbnNpb24gaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG4gICAgcHJpdmF0ZSBfY2xpcHM6IEFycmF5PElMb2FkZXJDbGlwPjtcclxuICAgIHByaXZhdGUgX2VtaXR0ZXJzOiBBcnJheTxJTG9hZGVyRW1pdHRlcj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyOiBHTFRGTG9hZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuX2xvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgKHRoaXMuX2xvYWRlciBhcyBhbnkpID0gbnVsbDtcclxuICAgICAgICAodGhpcy5fY2xpcHMgYXMgYW55KSA9IG51bGw7XHJcbiAgICAgICAgKHRoaXMuX2VtaXR0ZXJzIGFzIGFueSkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBvbkxvYWRpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuX2xvYWRlci5nbHRmLmV4dGVuc2lvbnM7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbdGhpcy5uYW1lXSBhcyBJTVNGVEF1ZGlvRW1pdHRlcjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzID0gZXh0ZW5zaW9uLmNsaXBzO1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVycyA9IGV4dGVuc2lvbi5lbWl0dGVycztcclxuXHJcbiAgICAgICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fY2xpcHMpO1xyXG4gICAgICAgICAgICBBcnJheUl0ZW0uQXNzaWduKHRoaXMuX2VtaXR0ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgbG9hZFNjZW5lQXN5bmMoY29udGV4dDogc3RyaW5nLCBzY2VuZTogSVNjZW5lKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJTVNGVEF1ZGlvRW1pdHRlcl9FbWl0dGVyc1JlZmVyZW5jZT4oY29udGV4dCwgc2NlbmUsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRlci5sb2FkU2NlbmVBc3luYyhjb250ZXh0LCBzY2VuZSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbWl0dGVySW5kZXggb2YgZXh0ZW5zaW9uLmVtaXR0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gQXJyYXlJdGVtLkdldChgJHtleHRlbnNpb25Db250ZXh0fS9lbWl0dGVyc2AsIHRoaXMuX2VtaXR0ZXJzLCBlbWl0dGVySW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVmRGlzdGFuY2UgIT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5tYXhEaXN0YW5jZSAhPSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLnJvbGxvZmZGYWN0b3IgIT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5kaXN0YW5jZU1vZGVsICE9IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuaW5uZXJBbmdsZSAhPSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLm91dGVyQW5nbGUgIT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXh0ZW5zaW9uQ29udGV4dH06IERpcmVjdGlvbiBvciBEaXN0YW5jZSBwcm9wZXJ0aWVzIGFyZSBub3QgYWxsb3dlZCBvbiBlbWl0dGVycyBhdHRhY2hlZCB0byBhIHNjZW5lYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkRW1pdHRlckFzeW5jKGAke2V4dGVuc2lvbkNvbnRleHR9L2VtaXR0ZXJzLyR7ZW1pdHRlci5pbmRleH1gLCBlbWl0dGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTm9kZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgbm9kZTogSU5vZGUsIGFzc2lnbjogKGJhYnlsb25UcmFuc2Zvcm1Ob2RlOiBUcmFuc2Zvcm1Ob2RlKSA9PiB2b2lkKTogTnVsbGFibGU8UHJvbWlzZTxUcmFuc2Zvcm1Ob2RlPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJTVNGVEF1ZGlvRW1pdHRlcl9FbWl0dGVyc1JlZmVyZW5jZSwgVHJhbnNmb3JtTm9kZT4oY29udGV4dCwgbm9kZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGJhYnlsb25NZXNoID0gYXdhaXQgdGhpcy5fbG9hZGVyLmxvYWROb2RlQXN5bmMoZXh0ZW5zaW9uQ29udGV4dCwgbm9kZSwgKGJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtaXR0ZXJJbmRleCBvZiBleHRlbnNpb24uZW1pdHRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gQXJyYXlJdGVtLkdldChgJHtleHRlbnNpb25Db250ZXh0fS9lbWl0dGVyc2AsIHRoaXMuX2VtaXR0ZXJzLCBlbWl0dGVySW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRW1pdHRlckFzeW5jKGAke2V4dGVuc2lvbkNvbnRleHR9L2VtaXR0ZXJzLyR7ZW1pdHRlci5pbmRleH1gLCBlbWl0dGVyKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc291bmQgb2YgZW1pdHRlci5fYmFieWxvblNvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdW5kLmF0dGFjaFRvTWVzaChiYWJ5bG9uTWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtaXR0ZXIuaW5uZXJBbmdsZSAhPSB1bmRlZmluZWQgfHwgZW1pdHRlci5vdXRlckFuZ2xlICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VuZC5zZXRMb2NhbERpcmVjdGlvblRvTWVzaChWZWN0b3IzLkZvcndhcmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdW5kLnNldERpcmVjdGlvbmFsQ29uZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgKiBUb29scy5Ub0RlZ3JlZXMoZW1pdHRlci5pbm5lckFuZ2xlID09IHVuZGVmaW5lZCA/IE1hdGguUEkgOiBlbWl0dGVyLmlubmVyQW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAqIFRvb2xzLlRvRGVncmVlcyhlbWl0dGVyLm91dGVyQW5nbGUgPT0gdW5kZWZpbmVkID8gTWF0aC5QSSA6IGVtaXR0ZXIub3V0ZXJBbmdsZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJhYnlsb25NZXNoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRBbmltYXRpb25Bc3luYyhjb250ZXh0OiBzdHJpbmcsIGFuaW1hdGlvbjogSUFuaW1hdGlvbik6IE51bGxhYmxlPFByb21pc2U8QW5pbWF0aW9uR3JvdXA+PiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElMb2FkZXJBbmltYXRpb25FdmVudHMsIEFuaW1hdGlvbkdyb3VwPihjb250ZXh0LCBhbmltYXRpb24sIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYWJ5bG9uQW5pbWF0aW9uR3JvdXAgPSBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZEFuaW1hdGlvbkFzeW5jKGNvbnRleHQsIGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8YW55Pj4oKTtcclxuICAgICAgICAgICAgQXJyYXlJdGVtLkFzc2lnbihleHRlbnNpb24uZXZlbnRzKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBleHRlbnNpb24uZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRBbmltYXRpb25FdmVudEFzeW5jKGAke2V4dGVuc2lvbkNvbnRleHR9L2V2ZW50cy8ke2V2ZW50LmluZGV4fWAsIGNvbnRleHQsIGFuaW1hdGlvbiwgZXZlbnQsIGJhYnlsb25BbmltYXRpb25Hcm91cCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJhYnlsb25BbmltYXRpb25Hcm91cDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9sb2FkQ2xpcEFzeW5jKGNvbnRleHQ6IHN0cmluZywgY2xpcDogSUxvYWRlckNsaXApOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGlmIChjbGlwLl9vYmplY3RVUkwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaXAuX29iamVjdFVSTDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwcm9taXNlOiBQcm9taXNlPEFycmF5QnVmZmVyVmlldz47XHJcbiAgICAgICAgaWYgKGNsaXAudXJpKSB7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9sb2FkZXIubG9hZFVyaUFzeW5jKGNvbnRleHQsIGNsaXAsIGNsaXAudXJpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJWaWV3ID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9idWZmZXJWaWV3YCwgdGhpcy5fbG9hZGVyLmdsdGYuYnVmZmVyVmlld3MsIGNsaXAuYnVmZmVyVmlldyk7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9sb2FkZXIubG9hZEJ1ZmZlclZpZXdBc3luYyhgL2J1ZmZlclZpZXdzLyR7YnVmZmVyVmlldy5pbmRleH1gLCBidWZmZXJWaWV3KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIGNsaXAuX29iamVjdFVSTCA9IHByb21pc2UudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogY2xpcC5taW1lVHlwZSB9KSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbGlwLl9vYmplY3RVUkw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZEVtaXR0ZXJBc3luYyhjb250ZXh0OiBzdHJpbmcsIGVtaXR0ZXI6IElMb2FkZXJFbWl0dGVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgZW1pdHRlci5fYmFieWxvblNvdW5kcyA9IGVtaXR0ZXIuX2JhYnlsb25Tb3VuZHMgfHwgW107XHJcbiAgICAgICAgaWYgKCFlbWl0dGVyLl9iYWJ5bG9uRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBjbGlwUHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxhbnk+PigpO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZW1pdHRlci5uYW1lIHx8IGBlbWl0dGVyJHtlbWl0dGVyLmluZGV4fWA7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBsb29wOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZvbHVtZTogZW1pdHRlci52b2x1bWUgPT0gdW5kZWZpbmVkID8gMSA6IGVtaXR0ZXIudm9sdW1lLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbWl0dGVyLmNsaXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGlwQ29udGV4dCA9IGAvZXh0ZW5zaW9ucy8ke3RoaXMubmFtZX0vY2xpcHNgO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpcCA9IEFycmF5SXRlbS5HZXQoY2xpcENvbnRleHQsIHRoaXMuX2NsaXBzLCBlbWl0dGVyLmNsaXBzW2ldLmNsaXApO1xyXG4gICAgICAgICAgICAgICAgY2xpcFByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZENsaXBBc3luYyhgJHtjbGlwQ29udGV4dH0vJHtlbWl0dGVyLmNsaXBzW2ldLmNsaXB9YCwgY2xpcCkudGhlbigob2JqZWN0VVJMOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291bmQgPSAoZW1pdHRlci5fYmFieWxvblNvdW5kc1tpXSA9IG5ldyBTb3VuZChuYW1lLCBvYmplY3RVUkwsIHRoaXMuX2xvYWRlci5iYWJ5bG9uU2NlbmUsIG51bGwsIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291bmQucmVmRGlzdGFuY2UgPSBlbWl0dGVyLnJlZkRpc3RhbmNlIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdW5kLm1heERpc3RhbmNlID0gZW1pdHRlci5tYXhEaXN0YW5jZSB8fCAyNTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdW5kLnJvbGxvZmZGYWN0b3IgPSBlbWl0dGVyLnJvbGxvZmZGYWN0b3IgfHwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291bmQuZGlzdGFuY2VNb2RlbCA9IGVtaXR0ZXIuZGlzdGFuY2VNb2RlbCB8fCBcImV4cG9uZW50aWFsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5hbGwoY2xpcFByb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdlaWdodHMgPSBlbWl0dGVyLmNsaXBzLm1hcCgoY2xpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGlwLndlaWdodCB8fCAxO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWlnaHRlZFNvdW5kID0gbmV3IFdlaWdodGVkU291bmQoZW1pdHRlci5sb29wIHx8IGZhbHNlLCBlbWl0dGVyLl9iYWJ5bG9uU291bmRzLCB3ZWlnaHRzKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbWl0dGVyLmlubmVyQW5nbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZFNvdW5kLmRpcmVjdGlvbmFsQ29uZUlubmVyQW5nbGUgPSAyICogVG9vbHMuVG9EZWdyZWVzKGVtaXR0ZXIuaW5uZXJBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW1pdHRlci5vdXRlckFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRTb3VuZC5kaXJlY3Rpb25hbENvbmVPdXRlckFuZ2xlID0gMiAqIFRvb2xzLlRvRGVncmVlcyhlbWl0dGVyLm91dGVyQW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVtaXR0ZXIudm9sdW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRTb3VuZC52b2x1bWUgPSBlbWl0dGVyLnZvbHVtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuX2JhYnlsb25EYXRhIS5zb3VuZCA9IHdlaWdodGVkU291bmQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZW1pdHRlci5fYmFieWxvbkRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IHByb21pc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZW1pdHRlci5fYmFieWxvbkRhdGEubG9hZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldEV2ZW50QWN0aW9uKFxyXG4gICAgICAgIGNvbnRleHQ6IHN0cmluZyxcclxuICAgICAgICBzb3VuZDogV2VpZ2h0ZWRTb3VuZCxcclxuICAgICAgICBhY3Rpb246IElNU0ZUQXVkaW9FbWl0dGVyX0FuaW1hdGlvbkV2ZW50QWN0aW9uLFxyXG4gICAgICAgIHRpbWU6IG51bWJlcixcclxuICAgICAgICBzdGFydE9mZnNldD86IG51bWJlclxyXG4gICAgKTogKGN1cnJlbnRGcmFtZTogbnVtYmVyKSA9PiB2b2lkIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIElNU0ZUQXVkaW9FbWl0dGVyX0FuaW1hdGlvbkV2ZW50QWN0aW9uLnBsYXk6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudEZyYW1lOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZU9mZnNldCA9IChzdGFydE9mZnNldCB8fCAwKSArIChjdXJyZW50RnJhbWUgLSB0aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBzb3VuZC5wbGF5KGZyYW1lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBJTVNGVEF1ZGlvRW1pdHRlcl9BbmltYXRpb25FdmVudEFjdGlvbi5zdG9wOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdW5kLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBJTVNGVEF1ZGlvRW1pdHRlcl9BbmltYXRpb25FdmVudEFjdGlvbi5wYXVzZToge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VuZC5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06IFVuc3VwcG9ydGVkIGFjdGlvbiAke2FjdGlvbn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9sb2FkQW5pbWF0aW9uRXZlbnRBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uQ29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbjogSUFuaW1hdGlvbixcclxuICAgICAgICBldmVudDogSUxvYWRlckFuaW1hdGlvbkV2ZW50LFxyXG4gICAgICAgIGJhYnlsb25BbmltYXRpb25Hcm91cDogQW5pbWF0aW9uR3JvdXBcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmIChiYWJ5bG9uQW5pbWF0aW9uR3JvdXAudGFyZ2V0ZWRBbmltYXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmFieWxvbkFuaW1hdGlvbiA9IGJhYnlsb25BbmltYXRpb25Hcm91cC50YXJnZXRlZEFuaW1hdGlvbnNbMF07XHJcbiAgICAgICAgY29uc3QgZW1pdHRlckluZGV4ID0gZXZlbnQuZW1pdHRlcjtcclxuICAgICAgICBjb25zdCBlbWl0dGVyID0gQXJyYXlJdGVtLkdldChgL2V4dGVuc2lvbnMvJHt0aGlzLm5hbWV9L2VtaXR0ZXJzYCwgdGhpcy5fZW1pdHRlcnMsIGVtaXR0ZXJJbmRleCk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdpdGh1Yi9uby10aGVuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRFbWl0dGVyQXN5bmMoY29udGV4dCwgZW1pdHRlcikudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdW5kID0gZW1pdHRlci5fYmFieWxvbkRhdGEhLnNvdW5kO1xyXG4gICAgICAgICAgICBpZiAoc291bmQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhYnlsb25BbmltYXRpb25FdmVudCA9IG5ldyBBbmltYXRpb25FdmVudChldmVudC50aW1lLCB0aGlzLl9nZXRFdmVudEFjdGlvbihjb250ZXh0LCBzb3VuZCwgZXZlbnQuYWN0aW9uLCBldmVudC50aW1lLCBldmVudC5zdGFydE9mZnNldCkpO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbkFuaW1hdGlvbi5hbmltYXRpb24uYWRkRXZlbnQoYmFieWxvbkFuaW1hdGlvbkV2ZW50KTtcclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgc3RhcnRlZCBhdWRpbyBzdG9wcyB3aGVuIHRoaXMgYW5pbWF0aW9uIGlzIHRlcm1pbmF0ZWQuXHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQW5pbWF0aW9uR3JvdXAub25BbmltYXRpb25Hcm91cEVuZE9ic2VydmFibGUuYWRkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VuZC5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb25Hcm91cC5vbkFuaW1hdGlvbkdyb3VwUGF1c2VPYnNlcnZhYmxlLmFkZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291bmQucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUpO1xyXG5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSwgdHJ1ZSwgKGxvYWRlcikgPT4gbmV3IE1TRlRfYXVkaW9fZW1pdHRlcihsb2FkZXIpKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgZ2l0aHViL25vLXRoZW4gKi9cclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiY29yZS9NaXNjL29ic2VydmFibGVcIjtcclxuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tIFwiY29yZS9NaXNjL2RlZmVycmVkXCI7XHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBUcmFuc2Zvcm1Ob2RlIH0gZnJvbSBcImNvcmUvTWVzaGVzL3RyYW5zZm9ybU5vZGVcIjtcclxuaW1wb3J0IHR5cGUgeyBNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL21lc2hcIjtcclxuaW1wb3J0IHR5cGUgeyBCYXNlVGV4dHVyZSB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9UZXh0dXJlcy9iYXNlVGV4dHVyZVwiO1xyXG5pbXBvcnQgdHlwZSB7IElOb2RlLCBJTWF0ZXJpYWwsIElCdWZmZXIsIElTY2VuZSB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IElHTFRGTG9hZGVyRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHsgR0xURkxvYWRlciwgQXJyYXlJdGVtIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJUHJvcGVydHksIElNU0ZUTE9EIH0gZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiTVNGVF9sb2RcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwiLi4vLi4vZ2xURkZpbGVMb2FkZXJcIiB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIHRoZSBNU0ZUX2xvZCBleHRlbnNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gTk9URTogRG9uJ3QgdXNlIE5BTUUgaGVyZSBhcyBpdCB3aWxsIGJyZWFrIHRoZSBVTUQgdHlwZSBkZWNsYXJhdGlvbnMuXHJcbiAgICAgICAgW1wiTVNGVF9sb2RcIl06IFBhcnRpYWw8e1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWF4aW11bSBudW1iZXIgb2YgTE9EcyB0byBsb2FkLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgTE9ELlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbWF4TE9Ec1RvTG9hZDogbnVtYmVyO1xyXG4gICAgICAgIH0+O1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgSUJ1ZmZlckluZm8ge1xyXG4gICAgc3RhcnQ6IG51bWJlcjtcclxuICAgIGVuZDogbnVtYmVyO1xyXG4gICAgbG9hZGVkOiBEZWZlcnJlZDxBcnJheUJ1ZmZlclZpZXc+O1xyXG59XHJcblxyXG4vKipcclxuICogW1NwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21haW4vZXh0ZW5zaW9ucy8yLjAvVmVuZG9yL01TRlRfbG9kL1JFQURNRS5tZClcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIE1TRlRfbG9kIGltcGxlbWVudHMgSUdMVEZMb2FkZXJFeHRlbnNpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBOQU1FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoaXMgZXh0ZW5zaW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIG9yZGVyIHRoZSBleHRlbnNpb25zIGFyZSBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3JkZXIgPSAxMDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBMT0RzIHRvIGxvYWQsIHN0YXJ0aW5nIGZyb20gdGhlIGxvd2VzdCBMT0QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXhMT0RzVG9Mb2FkID0gMTA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCB3aGVuIGFsbCBub2RlIExPRHMgb2Ygb25lIGxldmVsIGFyZSBsb2FkZWQuXHJcbiAgICAgKiBUaGUgZXZlbnQgZGF0YSBpcyB0aGUgaW5kZXggb2YgdGhlIGxvYWRlZCBMT0Qgc3RhcnRpbmcgZnJvbSB6ZXJvLlxyXG4gICAgICogRGlzcG9zZSB0aGUgbG9hZGVyIHRvIGNhbmNlbCB0aGUgbG9hZGluZyBvZiB0aGUgbmV4dCBsZXZlbCBvZiBMT0RzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25Ob2RlTE9Ec0xvYWRlZE9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxudW1iZXI+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCB3aGVuIGFsbCBtYXRlcmlhbCBMT0RzIG9mIG9uZSBsZXZlbCBhcmUgbG9hZGVkLlxyXG4gICAgICogVGhlIGV2ZW50IGRhdGEgaXMgdGhlIGluZGV4IG9mIHRoZSBsb2FkZWQgTE9EIHN0YXJ0aW5nIGZyb20gemVyby5cclxuICAgICAqIERpc3Bvc2UgdGhlIGxvYWRlciB0byBjYW5jZWwgdGhlIGxvYWRpbmcgb2YgdGhlIG5leHQgbGV2ZWwgb2YgTE9Ecy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uTWF0ZXJpYWxMT0RzTG9hZGVkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPG51bWJlcj4oKTtcclxuXHJcbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBfYnVmZmVyTE9EcyA9IG5ldyBBcnJheTxJQnVmZmVySW5mbz4oKTtcclxuXHJcbiAgICBwcml2YXRlIF9ub2RlSW5kZXhMT0Q6IE51bGxhYmxlPG51bWJlcj4gPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbm9kZVNpZ25hbExPRHMgPSBuZXcgQXJyYXk8RGVmZXJyZWQ8dm9pZD4+KCk7XHJcbiAgICBwcml2YXRlIF9ub2RlUHJvbWlzZUxPRHMgPSBuZXcgQXJyYXk8QXJyYXk8UHJvbWlzZTxhbnk+Pj4oKTtcclxuICAgIHByaXZhdGUgX25vZGVCdWZmZXJMT0RzID0gbmV3IEFycmF5PElCdWZmZXJJbmZvPigpO1xyXG5cclxuICAgIHByaXZhdGUgX21hdGVyaWFsSW5kZXhMT0Q6IE51bGxhYmxlPG51bWJlcj4gPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbWF0ZXJpYWxTaWduYWxMT0RzID0gbmV3IEFycmF5PERlZmVycmVkPHZvaWQ+PigpO1xyXG4gICAgcHJpdmF0ZSBfbWF0ZXJpYWxQcm9taXNlTE9EcyA9IG5ldyBBcnJheTxBcnJheTxQcm9taXNlPGFueT4+PigpO1xyXG4gICAgcHJpdmF0ZSBfbWF0ZXJpYWxCdWZmZXJMT0RzID0gbmV3IEFycmF5PElCdWZmZXJJbmZvPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICAvLyBPcHRpb25zIHRha2VzIHByZWNlZGVuY2UuIFRoZSBtYXhMT0RzVG9Mb2FkIGV4dGVuc2lvbiBwcm9wZXJ0eSBpcyByZXRhaW5lZCBmb3IgYmFjayBjb21wYXQuXHJcbiAgICAgICAgLy8gRm9yIG5ldyBleHRlbnNpb25zLCB0aGV5IHNob3VsZCBvbmx5IHVzZSBvcHRpb25zLlxyXG4gICAgICAgIHRoaXMubWF4TE9Ec1RvTG9hZCA9IHRoaXMuX2xvYWRlci5wYXJlbnQuZXh0ZW5zaW9uT3B0aW9uc1tOQU1FXT8ubWF4TE9Ec1RvTG9hZCA/PyB0aGlzLm1heExPRHNUb0xvYWQ7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdGhpcy5fbG9hZGVyLmlzRXh0ZW5zaW9uVXNlZChOQU1FKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpIHtcclxuICAgICAgICAodGhpcy5fbG9hZGVyIGFzIGFueSkgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLl9ub2RlSW5kZXhMT0QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX25vZGVTaWduYWxMT0RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbm9kZVByb21pc2VMT0RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbm9kZUJ1ZmZlckxPRHMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWxJbmRleExPRCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWxTaWduYWxMT0RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWxQcm9taXNlTE9Ecy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX21hdGVyaWFsQnVmZmVyTE9Ecy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLm9uTWF0ZXJpYWxMT0RzTG9hZGVkT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMub25Ob2RlTE9Ec0xvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgb25SZWFkeSgpOiB2b2lkIHtcclxuICAgICAgICBmb3IgKGxldCBpbmRleExPRCA9IDA7IGluZGV4TE9EIDwgdGhpcy5fbm9kZVByb21pc2VMT0RzLmxlbmd0aDsgaW5kZXhMT0QrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5hbGwodGhpcy5fbm9kZVByb21pc2VMT0RzW2luZGV4TE9EXSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhMT0QgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuZW5kUGVyZm9ybWFuY2VDb3VudGVyKGBOb2RlIExPRCAke2luZGV4TE9EfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2coYExvYWRlZCBub2RlIExPRCAke2luZGV4TE9EfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMub25Ob2RlTE9Ec0xvYWRlZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKGluZGV4TE9EKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhMT0QgIT09IHRoaXMuX25vZGVQcm9taXNlTE9Ecy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLnN0YXJ0UGVyZm9ybWFuY2VDb3VudGVyKGBOb2RlIExPRCAke2luZGV4TE9EICsgMX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkQnVmZmVyTE9EKHRoaXMuX25vZGVCdWZmZXJMT0RzLCBpbmRleExPRCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ub2RlU2lnbmFsTE9Ec1tpbmRleExPRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZVNpZ25hbExPRHNbaW5kZXhMT0RdLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLl9jb21wbGV0ZVByb21pc2VzLnB1c2gocHJvbWlzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleExPRCA9IDA7IGluZGV4TE9EIDwgdGhpcy5fbWF0ZXJpYWxQcm9taXNlTE9Ecy5sZW5ndGg7IGluZGV4TE9EKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UuYWxsKHRoaXMuX21hdGVyaWFsUHJvbWlzZUxPRHNbaW5kZXhMT0RdKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5lbmRQZXJmb3JtYW5jZUNvdW50ZXIoYE1hdGVyaWFsIExPRCAke2luZGV4TE9EfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2coYExvYWRlZCBtYXRlcmlhbCBMT0QgJHtpbmRleExPRH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWF0ZXJpYWxMT0RzTG9hZGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoaW5kZXhMT0QpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCAhPT0gdGhpcy5fbWF0ZXJpYWxQcm9taXNlTE9Ecy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLnN0YXJ0UGVyZm9ybWFuY2VDb3VudGVyKGBNYXRlcmlhbCBMT0QgJHtpbmRleExPRCArIDF9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZEJ1ZmZlckxPRCh0aGlzLl9tYXRlcmlhbEJ1ZmZlckxPRHMsIGluZGV4TE9EICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGVyaWFsU2lnbmFsTE9Ec1tpbmRleExPRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxTaWduYWxMT0RzW2luZGV4TE9EXS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5fY29tcGxldGVQcm9taXNlcy5wdXNoKHByb21pc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkU2NlbmVBc3luYyhjb250ZXh0OiBzdHJpbmcsIHNjZW5lOiBJU2NlbmUpOiBOdWxsYWJsZTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2xvYWRlci5sb2FkU2NlbmVBc3luYyhjb250ZXh0LCBzY2VuZSk7XHJcbiAgICAgICAgdGhpcy5fbG9hZEJ1ZmZlckxPRCh0aGlzLl9idWZmZXJMT0RzLCAwKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTm9kZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgbm9kZTogSU5vZGUsIGFzc2lnbjogKGJhYnlsb25UcmFuc2Zvcm1Ob2RlOiBUcmFuc2Zvcm1Ob2RlKSA9PiB2b2lkKTogTnVsbGFibGU8UHJvbWlzZTxUcmFuc2Zvcm1Ob2RlPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRlbnNpb25Bc3luYzxJTVNGVExPRCwgVHJhbnNmb3JtTm9kZT4oY29udGV4dCwgbm9kZSwgdGhpcy5uYW1lLCBhc3luYyAoZXh0ZW5zaW9uQ29udGV4dCwgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdFByb21pc2U6IFByb21pc2U8VHJhbnNmb3JtTm9kZT47XHJcblxyXG4gICAgICAgICAgICBjb25zdCBub2RlTE9EcyA9IHRoaXMuX2dldExPRHMoZXh0ZW5zaW9uQ29udGV4dCwgbm9kZSwgdGhpcy5fbG9hZGVyLmdsdGYubm9kZXMsIGV4dGVuc2lvbi5pZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9nT3BlbihgJHtleHRlbnNpb25Db250ZXh0fWApO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXhMT0QgPSAwOyBpbmRleExPRCA8IG5vZGVMT0RzLmxlbmd0aDsgaW5kZXhMT0QrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUxPRCA9IG5vZGVMT0RzW2luZGV4TE9EXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhMT0QgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2RlSW5kZXhMT0QgPSBpbmRleExPRDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2RlU2lnbmFsTE9Ec1tpbmRleExPRF0gPSB0aGlzLl9ub2RlU2lnbmFsTE9Ec1tpbmRleExPRF0gfHwgbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNzaWduV3JhcCA9IChiYWJ5bG9uVHJhbnNmb3JtTm9kZTogVHJhbnNmb3JtTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uVHJhbnNmb3JtTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvblRyYW5zZm9ybU5vZGUuc2V0RW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9sb2FkZXIubG9hZE5vZGVBc3luYyhgL25vZGVzLyR7bm9kZUxPRC5pbmRleH1gLCBub2RlTE9ELCBhc3NpZ25XcmFwKS50aGVuKChiYWJ5bG9uTWVzaCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgbm90IHJlbHkgb24gX2JhYnlsb25UcmFuc2Zvcm1Ob2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzTm9kZUxPRCA9IG5vZGVMT0RzW2luZGV4TE9EIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGVMT0QuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlVHJhbnNmb3JtTm9kZShwcmV2aW91c05vZGVMT0QuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmV2aW91c05vZGVMT0QuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5zZXRFbmFibGVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYWJ5bG9uTWVzaDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVQcm9taXNlTE9Ec1tpbmRleExPRF0gPSB0aGlzLl9ub2RlUHJvbWlzZUxPRHNbaW5kZXhMT0RdIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UHJvbWlzZSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGVJbmRleExPRCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZVByb21pc2VMT0RzW2luZGV4TE9EXS5wdXNoKHByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9nQ2xvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZpcnN0UHJvbWlzZSE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgX2xvYWRNYXRlcmlhbEFzeW5jKFxyXG4gICAgICAgIGNvbnRleHQ6IHN0cmluZyxcclxuICAgICAgICBtYXRlcmlhbDogSU1hdGVyaWFsLFxyXG4gICAgICAgIGJhYnlsb25NZXNoOiBOdWxsYWJsZTxNZXNoPixcclxuICAgICAgICBiYWJ5bG9uRHJhd01vZGU6IG51bWJlcixcclxuICAgICAgICBhc3NpZ246IChiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKSA9PiB2b2lkXHJcbiAgICApOiBOdWxsYWJsZTxQcm9taXNlPE1hdGVyaWFsPj4ge1xyXG4gICAgICAgIC8vIERvbid0IGxvYWQgbWF0ZXJpYWwgTE9EcyBpZiBhbHJlYWR5IGxvYWRpbmcgYSBub2RlIExPRC5cclxuICAgICAgICBpZiAodGhpcy5fbm9kZUluZGV4TE9EKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuTG9hZEV4dGVuc2lvbkFzeW5jPElNU0ZUTE9ELCBNYXRlcmlhbD4oY29udGV4dCwgbWF0ZXJpYWwsIHRoaXMubmFtZSwgYXN5bmMgKGV4dGVuc2lvbkNvbnRleHQsIGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZmlyc3RQcm9taXNlOiBQcm9taXNlPE1hdGVyaWFsPjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsTE9EcyA9IHRoaXMuX2dldExPRHMoZXh0ZW5zaW9uQ29udGV4dCwgbWF0ZXJpYWwsIHRoaXMuX2xvYWRlci5nbHRmLm1hdGVyaWFscywgZXh0ZW5zaW9uLmlkcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2dPcGVuKGAke2V4dGVuc2lvbkNvbnRleHR9YCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleExPRCA9IDA7IGluZGV4TE9EIDwgbWF0ZXJpYWxMT0RzLmxlbmd0aDsgaW5kZXhMT0QrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWxMT0QgPSBtYXRlcmlhbExPRHNbaW5kZXhMT0RdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsSW5kZXhMT0QgPSBpbmRleExPRDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fbG9hZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLl9sb2FkTWF0ZXJpYWxBc3luYyhgL21hdGVyaWFscy8ke21hdGVyaWFsTE9ELmluZGV4fWAsIG1hdGVyaWFsTE9ELCBiYWJ5bG9uTWVzaCwgYmFieWxvbkRyYXdNb2RlLCAoYmFieWxvbk1hdGVyaWFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduKGJhYnlsb25NYXRlcmlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChiYWJ5bG9uTWF0ZXJpYWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4TE9EICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ24oYmFieWxvbk1hdGVyaWFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgbm90IHJlbHkgb24gX2RhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRGF0YUxPRCA9IG1hdGVyaWFsTE9Ec1tpbmRleExPRCAtIDFdLl9kYXRhITtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0RhdGFMT0RbYmFieWxvbkRyYXdNb2RlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VNYXRlcmlhbHMoW3ByZXZpb3VzRGF0YUxPRFtiYWJ5bG9uRHJhd01vZGVdLmJhYnlsb25NYXRlcmlhbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmV2aW91c0RhdGFMT0RbYmFieWxvbkRyYXdNb2RlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhYnlsb25NYXRlcmlhbDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRlcmlhbFByb21pc2VMT0RzW2luZGV4TE9EXSA9IHRoaXMuX21hdGVyaWFsUHJvbWlzZUxPRHNbaW5kZXhMT0RdIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleExPRCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UHJvbWlzZSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsSW5kZXhMT0QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsUHJvbWlzZUxPRHNbaW5kZXhMT0RdLnB1c2gocHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2dDbG9zZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmlyc3RQcm9taXNlITtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBfbG9hZFVyaUFzeW5jKGNvbnRleHQ6IHN0cmluZywgcHJvcGVydHk6IElQcm9wZXJ0eSwgdXJpOiBzdHJpbmcpOiBOdWxsYWJsZTxQcm9taXNlPEFycmF5QnVmZmVyVmlldz4+IHtcclxuICAgICAgICAvLyBEZWZlciB0aGUgbG9hZGluZyBvZiB1cmlzIGlmIGxvYWRpbmcgYSBub2RlIG9yIG1hdGVyaWFsIExPRC5cclxuICAgICAgICBpZiAodGhpcy5fbm9kZUluZGV4TE9EICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2coYGRlZmVycmVkYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXhMT0QgPSB0aGlzLl9ub2RlSW5kZXhMT0QgLSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2RlU2lnbmFsTE9Ec1twcmV2aW91c0luZGV4TE9EXSA9IHRoaXMuX25vZGVTaWduYWxMT0RzW3ByZXZpb3VzSW5kZXhMT0RdIHx8IG5ldyBEZWZlcnJlZDx2b2lkPigpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZVNpZ25hbExPRHNbdGhpcy5fbm9kZUluZGV4TE9EIC0gMV0ucHJvbWlzZS50aGVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZFVyaUFzeW5jKGNvbnRleHQsIHByb3BlcnR5LCB1cmkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21hdGVyaWFsSW5kZXhMT0QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmxvZyhgZGVmZXJyZWRgKTtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbmRleExPRCA9IHRoaXMuX21hdGVyaWFsSW5kZXhMT0QgLSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbFNpZ25hbExPRHNbcHJldmlvdXNJbmRleExPRF0gPSB0aGlzLl9tYXRlcmlhbFNpZ25hbExPRHNbcHJldmlvdXNJbmRleExPRF0gfHwgbmV3IERlZmVycmVkPHZvaWQ+KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbFNpZ25hbExPRHNbcHJldmlvdXNJbmRleExPRF0ucHJvbWlzZS50aGVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZFVyaUFzeW5jKGNvbnRleHQsIHByb3BlcnR5LCB1cmkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWRCdWZmZXJBc3luYyhjb250ZXh0OiBzdHJpbmcsIGJ1ZmZlcjogSUJ1ZmZlciwgYnl0ZU9mZnNldDogbnVtYmVyLCBieXRlTGVuZ3RoOiBudW1iZXIpOiBOdWxsYWJsZTxQcm9taXNlPEFycmF5QnVmZmVyVmlldz4+IHtcclxuICAgICAgICBpZiAodGhpcy5fbG9hZGVyLnBhcmVudC51c2VSYW5nZVJlcXVlc3RzICYmICFidWZmZXIudXJpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGVyLmJpbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBVcmkgaXMgbWlzc2luZyBvciB0aGUgYmluYXJ5IGdsVEYgaXMgbWlzc2luZyBpdHMgYmluYXJ5IGNodW5rYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRBc3luYyA9IGFzeW5jIChidWZmZXJMT0RzOiBBcnJheTxJQnVmZmVySW5mbz4sIGluZGV4TE9EOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gYnl0ZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgYnl0ZUxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyTE9EID0gYnVmZmVyTE9Ec1tpbmRleExPRF07XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyTE9EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTE9ELnN0YXJ0ID0gTWF0aC5taW4oYnVmZmVyTE9ELnN0YXJ0LCBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTE9ELmVuZCA9IE1hdGgubWF4KGJ1ZmZlckxPRC5lbmQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckxPRCA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgbG9hZGVkOiBuZXcgRGVmZXJyZWQoKSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckxPRHNbaW5kZXhMT0RdID0gYnVmZmVyTE9EO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBidWZmZXJMT0QubG9hZGVkLnByb21pc2UudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCAtIGJ1ZmZlckxPRC5zdGFydCwgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5sb2coYGRlZmVycmVkYCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZUluZGV4TE9EICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEFzeW5jKHRoaXMuX25vZGVCdWZmZXJMT0RzLCB0aGlzLl9ub2RlSW5kZXhMT0QpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21hdGVyaWFsSW5kZXhMT0QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkQXN5bmModGhpcy5fbWF0ZXJpYWxCdWZmZXJMT0RzLCB0aGlzLl9tYXRlcmlhbEluZGV4TE9EKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkQXN5bmModGhpcy5fYnVmZmVyTE9EcywgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRCdWZmZXJMT0QoYnVmZmVyTE9EczogQXJyYXk8SUJ1ZmZlckluZm8+LCBpbmRleExPRDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyTE9EID0gYnVmZmVyTE9Ec1tpbmRleExPRF07XHJcbiAgICAgICAgaWYgKGJ1ZmZlckxPRCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIubG9nKGBMb2FkaW5nIGJ1ZmZlciByYW5nZSBbJHtidWZmZXJMT0Quc3RhcnR9LSR7YnVmZmVyTE9ELmVuZH1dYCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5iaW4hLnJlYWRBc3luYyhidWZmZXJMT0Quc3RhcnQsIGJ1ZmZlckxPRC5lbmQgLSBidWZmZXJMT0Quc3RhcnQgKyAxKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJMT0QubG9hZGVkLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTE9ELmxvYWRlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIExPRCBwcm9wZXJ0aWVzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gYXJyYXlcclxuICAgICAqIEBwYXJhbSBpZHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0TE9EczxUPihjb250ZXh0OiBzdHJpbmcsIHByb3BlcnR5OiBULCBhcnJheTogQXJyYXlMaWtlPFQ+IHwgdW5kZWZpbmVkLCBpZHM6IG51bWJlcltdKTogVFtdIHtcclxuICAgICAgICBpZiAodGhpcy5tYXhMT0RzVG9Mb2FkIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4TE9Ec1RvTG9hZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvcGVydGllczogVFtdID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBpZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vaWRzLyR7aWRzW2ldfWAsIGFycmF5LCBpZHNbaV0pKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSB0aGlzLm1heExPRHNUb0xvYWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2Rpc3Bvc2VUcmFuc2Zvcm1Ob2RlKGJhYnlsb25UcmFuc2Zvcm1Ob2RlOiBUcmFuc2Zvcm1Ob2RlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYmFieWxvbk1hdGVyaWFsczogTWF0ZXJpYWxbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGJhYnlsb25NYXRlcmlhbCA9IChiYWJ5bG9uVHJhbnNmb3JtTm9kZSBhcyBNZXNoKS5tYXRlcmlhbDtcclxuICAgICAgICBpZiAoYmFieWxvbk1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbHMucHVzaChiYWJ5bG9uTWF0ZXJpYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGJhYnlsb25NZXNoIG9mIGJhYnlsb25UcmFuc2Zvcm1Ob2RlLmdldENoaWxkTWVzaGVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKGJhYnlsb25NZXNoLm1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWxzLnB1c2goYmFieWxvbk1lc2gubWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiYWJ5bG9uVHJhbnNmb3JtTm9kZS5kaXNwb3NlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhYnlsb25NYXRlcmlhbHNUb0Rpc3Bvc2UgPSBiYWJ5bG9uTWF0ZXJpYWxzLmZpbHRlcigoYmFieWxvbk1hdGVyaWFsKSA9PiB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLm1lc2hlcy5ldmVyeSgobWVzaCkgPT4gbWVzaC5tYXRlcmlhbCAhPSBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlTWF0ZXJpYWxzKGJhYnlsb25NYXRlcmlhbHNUb0Rpc3Bvc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2Rpc3Bvc2VNYXRlcmlhbHMoYmFieWxvbk1hdGVyaWFsczogTWF0ZXJpYWxbXSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJhYnlsb25UZXh0dXJlczogeyBbdW5pcXVlSWQ6IG51bWJlcl06IEJhc2VUZXh0dXJlIH0gPSB7fTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBiYWJ5bG9uTWF0ZXJpYWwgb2YgYmFieWxvbk1hdGVyaWFscykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhYnlsb25UZXh0dXJlIG9mIGJhYnlsb25NYXRlcmlhbC5nZXRBY3RpdmVUZXh0dXJlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uVGV4dHVyZXNbYmFieWxvblRleHR1cmUudW5pcXVlSWRdID0gYmFieWxvblRleHR1cmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHVuaXF1ZUlkIGluIGJhYnlsb25UZXh0dXJlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhYnlsb25NYXRlcmlhbCBvZiB0aGlzLl9sb2FkZXIuYmFieWxvblNjZW5lLm1hdGVyaWFscykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhYnlsb25NYXRlcmlhbC5oYXNUZXh0dXJlKGJhYnlsb25UZXh0dXJlc1t1bmlxdWVJZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJhYnlsb25UZXh0dXJlc1t1bmlxdWVJZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgdW5pcXVlSWQgaW4gYmFieWxvblRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIGJhYnlsb25UZXh0dXJlc1t1bmlxdWVJZF0uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxudW5yZWdpc3RlckdMVEZFeHRlbnNpb24oTkFNRSk7XHJcbnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FLCB0cnVlLCAobG9hZGVyKSA9PiBuZXcgTVNGVF9sb2QobG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiTVNGVF9taW5lY3JhZnRNZXNoXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIi4uLy4uL2dsVEZGaWxlTG9hZGVyXCIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgTVNGVF9taW5lY3JhZnRNZXNoIGV4dGVuc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOT1RFOiBEb24ndCB1c2UgTkFNRSBoZXJlIGFzIGl0IHdpbGwgYnJlYWsgdGhlIFVNRCB0eXBlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICBbXCJNU0ZUX21pbmVjcmFmdE1lc2hcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIE1TRlRfbWluZWNyYWZ0TWVzaCBpbXBsZW1lbnRzIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lID0gTkFNRTtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgZW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIF9sb2FkZXI6IEdMVEZMb2FkZXI7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyOiBHTFRGTG9hZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuX2xvYWRlci5pc0V4dGVuc2lvblVzZWQoTkFNRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgKHRoaXMuX2xvYWRlciBhcyBhbnkpID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRyYUFzeW5jPGJvb2xlYW4+KGNvbnRleHQsIG1hdGVyaWFsLCB0aGlzLm5hbWUsIGFzeW5jIChleHRyYUNvbnRleHQsIGV4dHJhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V4dHJhQ29udGV4dH06IE1hdGVyaWFsIHR5cGUgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiYWJ5bG9uTWF0ZXJpYWwubmVlZEFscGhhQmxlbmRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5mb3JjZURlcHRoV3JpdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5zZXBhcmF0ZUN1bGxpbmdQYXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYmFja0ZhY2VDdWxsaW5nID0gYmFieWxvbk1hdGVyaWFsLmZvcmNlRGVwdGhXcml0ZTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC50d29TaWRlZExpZ2h0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBNU0ZUX21pbmVjcmFmdE1lc2gobG9hZGVyKSk7XHJcbiIsImltcG9ydCB0eXBlIHsgTnVsbGFibGUgfSBmcm9tIFwiY29yZS90eXBlc1wiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBJTWF0ZXJpYWwgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuLi9nbFRGTG9hZGVyRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tIFwiLi4vZ2xURkxvYWRlclwiO1xyXG5pbXBvcnQgeyByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4uL2dsVEZMb2FkZXJFeHRlbnNpb25SZWdpc3RyeVwiO1xyXG5cclxuY29uc3QgTkFNRSA9IFwiTVNGVF9zUkdCRmFjdG9yc1wiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCIuLi8uLi9nbFRGRmlsZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgR0xURkxvYWRlckV4dGVuc2lvbk9wdGlvbnMge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgb3B0aW9ucyBmb3IgdGhlIE1TRlRfc1JHQkZhY3RvcnMgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE5PVEU6IERvbid0IHVzZSBOQU1FIGhlcmUgYXMgaXQgd2lsbCBicmVhayB0aGUgVU1EIHR5cGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgIFtcIk1TRlRfc1JHQkZhY3RvcnNcIl06IHt9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNsYXNzIE1TRlRfc1JHQkZhY3RvcnMgaW1wbGVtZW50cyBJR0xURkxvYWRlckV4dGVuc2lvbiB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZSA9IE5BTUU7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZGVyOiBHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlcjogR0xURkxvYWRlcikge1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLl9sb2FkZXIuaXNFeHRlbnNpb25Vc2VkKE5BTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgICh0aGlzLl9sb2FkZXIgYXMgYW55KSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHB1YmxpYyBsb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiBHTFRGTG9hZGVyLkxvYWRFeHRyYUFzeW5jPGJvb2xlYW4+KGNvbnRleHQsIG1hdGVyaWFsLCB0aGlzLm5hbWUsIGFzeW5jIChleHRyYUNvbnRleHQsIGV4dHJhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V4dHJhQ29udGV4dH06IE1hdGVyaWFsIHR5cGUgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9sb2FkZXIubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZUV4YWN0U3JnYkNvbnZlcnNpb25zID0gYmFieWxvbk1hdGVyaWFsLmdldFNjZW5lKCkuZ2V0RW5naW5lKCkudXNlRXhhY3RTcmdiQ29udmVyc2lvbnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJhYnlsb25NYXRlcmlhbC5hbGJlZG9UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb0NvbG9yLnRvTGluZWFyU3BhY2VUb1JlZihiYWJ5bG9uTWF0ZXJpYWwuYWxiZWRvQ29sb3IsIHVzZUV4YWN0U3JnYkNvbnZlcnNpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWJhYnlsb25NYXRlcmlhbC5yZWZsZWN0aXZpdHlUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnJlZmxlY3Rpdml0eUNvbG9yLnRvTGluZWFyU3BhY2VUb1JlZihiYWJ5bG9uTWF0ZXJpYWwucmVmbGVjdGl2aXR5Q29sb3IsIHVzZUV4YWN0U3JnYkNvbnZlcnNpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG51bnJlZ2lzdGVyR0xURkV4dGVuc2lvbihOQU1FKTtcclxucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKE5BTUUsIHRydWUsIChsb2FkZXIpID0+IG5ldyBNU0ZUX3NSR0JGYWN0b3JzKGxvYWRlcikpO1xyXG4iLCJpbXBvcnQgdHlwZSB7IElPYmplY3RJbmZvLCBJUGF0aFRvT2JqZWN0Q29udmVydGVyIH0gZnJvbSBcImNvcmUvT2JqZWN0TW9kZWwvb2JqZWN0TW9kZWxJbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB0eXBlIHsgSUdMVEYgfSBmcm9tIFwiLi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJT2JqZWN0QWNjZXNzb3IgfSBmcm9tIFwiY29yZS9GbG93R3JhcGgvdHlwZURlZmluaXRpb25zXCI7XHJcblxyXG4vKipcclxuICogQWRkaW5nIGFuIGV4Y2VwdGlvbiBoZXJlIHdpbGwgYnJlYWsgdHJhdmVyc2luZyB0aHJvdWdoIHRoZSBnbFRGIG9iamVjdCB0cmVlLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHByb3BlcnRpZXMgdGhhdCBtaWdodCBub3QgYmUgaW4gdGhlIGdsVEYgb2JqZWN0IG1vZGVsLCBidXQgYXJlIG9wdGlvbmFsIGFuZCBoYXZlIGEgZGVmYXVsdCB2YWx1ZS5cclxuICogRm9yIGV4YW1wbGUsIHRoZSBwYXRoIC9ub2Rlcy9cXHtcXH0vZXh0ZW5zaW9ucy9LSFJfbm9kZV92aXNpYmlsaXR5L3Zpc2libGUgaXMgb3B0aW9uYWwgLSB0aGUgb2JqZWN0IGNhbiBiZSBkZWZlcnJlZCB3aXRob3V0IHRoZSBvYmplY3QgZnVsbHkgZXhpc3RpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgT3B0aW9uYWxQYXRoRXhjZXB0aW9uc0xpc3Q6IHtcclxuICAgIHJlZ2V4OiBSZWdFeHA7XHJcbn1bXSA9IFtcclxuICAgIHtcclxuICAgICAgICAvLyBnZXQgdGhlIG5vZGUgYXMgb2JqZWN0IHdoZW4gcmVhZGluZyBhbiBleHRlbnNpb25cclxuICAgICAgICByZWdleDogbmV3IFJlZ0V4cChgXi9ub2Rlcy9cXFxcZCsvZXh0ZW5zaW9ucy9gKSxcclxuICAgIH0sXHJcbl07XHJcblxyXG4vKipcclxuICogQSBjb252ZXJ0ZXIgdGhhdCB0YWtlcyBhIGdsVEYgT2JqZWN0IE1vZGVsIEpTT04gUG9pbnRlclxyXG4gKiBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIGFuIE9iamVjdEFjY2Vzc29yQ29udGFpbmVyLCBhbGxvd2luZ1xyXG4gKiBvYmplY3RzIHJlZmVyZW5jZWQgaW4gdGhlIGdsVEYgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZWlyXHJcbiAqIHJlc3BlY3RpdmUgQmFieWxvbi5qcyBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdMVEZQYXRoVG9PYmplY3RDb252ZXJ0ZXI8VCwgQmFieWxvblR5cGUsIEJhYnlsb25WYWx1ZT4gaW1wbGVtZW50cyBJUGF0aFRvT2JqZWN0Q29udmVydGVyPElPYmplY3RBY2Nlc3NvcjxULCBCYWJ5bG9uVHlwZSwgQmFieWxvblZhbHVlPj4ge1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2dsdGY6IElHTFRGLFxyXG4gICAgICAgIHByaXZhdGUgX2luZm9UcmVlOiBhbnlcclxuICAgICkge31cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb2ludGVyIHN0cmluZyBpcyByZXByZXNlbnRlZCBieSBhIFtKU09OIHBvaW50ZXJdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjkwMSkuXHJcbiAgICAgKiBTZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYWluL3NwZWNpZmljYXRpb24vMi4wL09iamVjdE1vZGVsLmFkb2MjY29yZS1wb2ludGVyc1xyXG4gICAgICogPGFuaW1hdGlvblBvaW50ZXI+IDo9IC88cm9vdE5vZGU+Lzxhc3NldEluZGV4Pi88cHJvcGVydHlQYXRoPlxyXG4gICAgICogPHJvb3ROb2RlPiA6PSBcIm5vZGVzXCIgfCBcIm1hdGVyaWFsc1wiIHwgXCJtZXNoZXNcIiB8IFwiY2FtZXJhc1wiIHwgXCJleHRlbnNpb25zXCJcclxuICAgICAqIDxhc3NldEluZGV4PiA6PSA8ZGlnaXQ+IHwgPG5hbWU+XHJcbiAgICAgKiA8cHJvcGVydHlQYXRoPiA6PSA8ZXh0ZW5zaW9uUGF0aD4gfCA8c3RhbmRhcmRQYXRoPlxyXG4gICAgICogPGV4dGVuc2lvblBhdGg+IDo9IFwiZXh0ZW5zaW9uc1wiLzxuYW1lPi88c3RhbmRhcmRQYXRoPlxyXG4gICAgICogPHN0YW5kYXJkUGF0aD4gOj0gPG5hbWU+IHwgPG5hbWU+LzxzdGFuZGFyZFBhdGg+XHJcbiAgICAgKiA8bmFtZT4gOj0gVytcclxuICAgICAqIDxkaWdpdD4gOj0gRCtcclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlczpcclxuICAgICAqICAtIFwiL25vZGVzLzAvcm90YXRpb25cIlxyXG4gICAgICogLSBcIi9ub2Rlcy5sZW5ndGhcIlxyXG4gICAgICogIC0gXCIvbWF0ZXJpYWxzLzIvZW1pc3NpdmVGYWN0b3JcIlxyXG4gICAgICogIC0gXCIvbWF0ZXJpYWxzLzIvcGJyTWV0YWxsaWNSb3VnaG5lc3MvYmFzZUNvbG9yRmFjdG9yXCJcclxuICAgICAqICAtIFwiL21hdGVyaWFscy8yL2V4dGVuc2lvbnMvS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aC9lbWlzc2l2ZVN0cmVuZ3RoXCJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjb252ZXJ0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IGFuZCBpbmZvIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGF0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29udmVydChwYXRoOiBzdHJpbmcpOiBJT2JqZWN0SW5mbzxJT2JqZWN0QWNjZXNzb3I8VCwgQmFieWxvblR5cGUsIEJhYnlsb25WYWx1ZT4+IHtcclxuICAgICAgICBsZXQgb2JqZWN0VHJlZTogYW55ID0gdGhpcy5fZ2x0ZjtcclxuICAgICAgICBsZXQgaW5mb1RyZWU6IGFueSA9IHRoaXMuX2luZm9UcmVlO1xyXG4gICAgICAgIGxldCB0YXJnZXQ6IGFueSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggbXVzdCBzdGFydCB3aXRoIGEgL1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICBwYXJ0cy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAvL2lmIHRoZSBsYXN0IHBhcnQgaGFzIFwiLmxlbmd0aFwiIGluIGl0LCBzZXBhcmF0ZSB0aGF0IGFzIGFuIGV4dHJhIHBhcnRcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0uaW5jbHVkZXMoXCIubGVuZ3RoXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0ID0gbGFzdFBhcnQuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICBwYXJ0cy5wb3AoKTtcclxuICAgICAgICAgICAgcGFydHMucHVzaCguLi5zcGxpdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaWdub3JlT2JqZWN0VHJlZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNMZW5ndGggPSBwYXJ0ID09PSBcImxlbmd0aFwiO1xyXG4gICAgICAgICAgICBpZiAoaXNMZW5ndGggJiYgIWluZm9UcmVlLl9fYXJyYXlfXykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoICR7cGF0aH0gaXMgaW52YWxpZGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpbmZvVHJlZS5fX2lnbm9yZU9iamVjdFRyZWVfXykge1xyXG4gICAgICAgICAgICAgICAgaWdub3JlT2JqZWN0VHJlZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGluZm9UcmVlLl9fYXJyYXlfXyAmJiAhaXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGluZm9UcmVlID0gaW5mb1RyZWUuX19hcnJheV9fO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5mb1RyZWUgPSBpbmZvVHJlZVtwYXJ0XTtcclxuICAgICAgICAgICAgICAgIGlmICghaW5mb1RyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJHtwYXRofSBpcyBpbnZhbGlkYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpZ25vcmVPYmplY3RUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0VHJlZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHBhdGggaXMgaW4gdGhlIGV4Y2VwdGlvbiBsaXN0LiBJZiBpdCBpcywgYnJlYWsgYW5kIHJldHVybiB0aGUgbGFzdCBvYmplY3QgdGhhdCB3YXMgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNlcHRpb24gPSBPcHRpb25hbFBhdGhFeGNlcHRpb25zTGlzdC5maW5kKChlKSA9PiBlLnJlZ2V4LnRlc3QocGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGF0aCAke3BhdGh9IGlzIGludmFsaWRgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFRyZWUgPSBvYmplY3RUcmVlPy5bcGFydF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvVHJlZS5fX3RhcmdldF9fIHx8IGlzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBvYmplY3RUcmVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvYmplY3Q6IHRhcmdldCxcclxuICAgICAgICAgICAgaW5mbzogaW5mb1RyZWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgKiBmcm9tIFwiLi9vYmplY3RNb2RlbE1hcHBpbmdcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vRVhUX2xpZ2h0c19pbWFnZV9iYXNlZFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9FWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9FWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9FWFRfdGV4dHVyZV93ZWJwXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0VYVF90ZXh0dXJlX2F2aWZcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vRVhUX2xpZ2h0c19pZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX2xpZ2h0c19wdW5jdHVhbFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbWF0ZXJpYWxzX3VubGl0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGhcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX21hdGVyaWFsc19zaGVlblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbWF0ZXJpYWxzX3NwZWN1bGFyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9tYXRlcmlhbHNfaW9yXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9tYXRlcmlhbHNfdmFyaWFudHNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX21hdGVyaWFsc19kaWZmdXNlX3RyYW5zbWlzc2lvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbWF0ZXJpYWxzX3ZvbHVtZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vRVhUX21hdGVyaWFsc19kaWZmdXNlX3JvdWdobmVzc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbWVzaF9xdWFudGl6YXRpb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX3RleHR1cmVfYmFzaXN1XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl90ZXh0dXJlX3RyYW5zZm9ybVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfeG1wX2pzb25fbGRcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX2FuaW1hdGlvbl9wb2ludGVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL01TRlRfYXVkaW9fZW1pdHRlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9NU0ZUX2xvZFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9NU0ZUX21pbmVjcmFmdE1lc2hcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vTVNGVF9zUkdCRmFjdG9yc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfaW50ZXJhY3Rpdml0eVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9LSFJfbm9kZV92aXNpYmlsaXR5XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9ub2RlX3NlbGVjdGFiaWxpdHlcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vS0hSX25vZGVfaG92ZXJhYmlsaXR5XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL0V4dHJhc0FzTWV0YWRhdGFcIjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1pbnRlcm5hbC1tb2R1bGVzXHJcbmV4cG9ydCAqIGZyb20gXCIuL0tIUl9pbnRlcmFjdGl2aXR5L2luZGV4XCI7XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFRyYW5zZm9ybU5vZGUgfSBmcm9tIFwiY29yZS9NZXNoZXMvdHJhbnNmb3JtTm9kZVwiO1xuaW1wb3J0IHR5cGUgeyBJQW5pbWF0aW9uLCBJQ2FtZXJhLCBJR0xURiwgSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0LCBJTWF0ZXJpYWwsIElNZXNoLCBJTm9kZSB9IGZyb20gXCIuLi9nbFRGTG9hZGVySW50ZXJmYWNlc1wiO1xuaW1wb3J0IHR5cGUgeyBWZWN0b3IzIH0gZnJvbSBcImNvcmUvTWF0aHMvbWF0aC52ZWN0b3JcIjtcbmltcG9ydCB7IE1hdHJpeCwgUXVhdGVybmlvbiwgVmVjdG9yMiB9IGZyb20gXCJjb3JlL01hdGhzL21hdGgudmVjdG9yXCI7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tIFwiY29yZS9FbmdpbmVzL2NvbnN0YW50c1wiO1xuaW1wb3J0IHR5cGUgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XG5pbXBvcnQgeyBDb2xvcjQgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XG5pbXBvcnQgdHlwZSB7IFBCUk1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1BCUi9wYnJNYXRlcmlhbFwiO1xuaW1wb3J0IHR5cGUgeyBMaWdodCB9IGZyb20gXCJjb3JlL0xpZ2h0cy9saWdodFwiO1xuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XG5pbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvc3BvdExpZ2h0XCI7XG5pbXBvcnQgdHlwZSB7IElFWFRMaWdodHNJbWFnZUJhc2VkX0xpZ2h0SW1hZ2VCYXNlZCB9IGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcbmltcG9ydCB0eXBlIHsgSUludGVycG9sYXRpb25Qcm9wZXJ0eUluZm8sIElPYmplY3RBY2Nlc3NvciB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC90eXBlRGVmaW5pdGlvbnNcIjtcbmltcG9ydCB7IEdMVEZQYXRoVG9PYmplY3RDb252ZXJ0ZXIgfSBmcm9tIFwiLi9nbHRmUGF0aFRvT2JqZWN0Q29udmVydGVyXCI7XG5pbXBvcnQgdHlwZSB7IEFuaW1hdGlvbkdyb3VwIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRpb25Hcm91cFwiO1xuaW1wb3J0IHR5cGUgeyBNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL21lc2hcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJR0xURk9iamVjdE1vZGVsVHJlZSB7XG4gICAgY2FtZXJhczogSUdMVEZPYmplY3RNb2RlbFRyZWVDYW1lcmFzT2JqZWN0O1xuICAgIG5vZGVzOiBJR0xURk9iamVjdE1vZGVsVHJlZU5vZGVzT2JqZWN0O1xuICAgIG1hdGVyaWFsczogSUdMVEZPYmplY3RNb2RlbFRyZWVNYXRlcmlhbHNPYmplY3Q7XG4gICAgZXh0ZW5zaW9uczogSUdMVEZPYmplY3RNb2RlbFRyZWVFeHRlbnNpb25zT2JqZWN0O1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgbGVuZ3RoOiBJT2JqZWN0QWNjZXNzb3I8SUFuaW1hdGlvbltdLCBBbmltYXRpb25Hcm91cFtdLCBudW1iZXI+O1xuICAgICAgICBfX2FycmF5X186IHt9O1xuICAgIH07XG4gICAgbWVzaGVzOiB7XG4gICAgICAgIGxlbmd0aDogSU9iamVjdEFjY2Vzc29yPElNZXNoW10sIChNZXNoIHwgdW5kZWZpbmVkKVtdLCBudW1iZXI+O1xuICAgICAgICBfX2FycmF5X186IHt9O1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZPYmplY3RNb2RlbFRyZWVOb2Rlc09iamVjdDxHTFRGVGFyZ2V0VHlwZSA9IElOb2RlLCBCYWJ5bG9uVGFyZ2V0VHlwZSA9IFRyYW5zZm9ybU5vZGU+IHtcbiAgICBsZW5ndGg6IElPYmplY3RBY2Nlc3NvcjxHTFRGVGFyZ2V0VHlwZVtdLCBCYWJ5bG9uVGFyZ2V0VHlwZVtdLCBudW1iZXI+O1xuICAgIF9fYXJyYXlfXzoge1xuICAgICAgICBfX3RhcmdldF9fOiBib29sZWFuO1xuICAgICAgICB0cmFuc2xhdGlvbjogSU9iamVjdEFjY2Vzc29yPEdMVEZUYXJnZXRUeXBlLCBCYWJ5bG9uVGFyZ2V0VHlwZSwgVmVjdG9yMz47XG4gICAgICAgIHJvdGF0aW9uOiBJT2JqZWN0QWNjZXNzb3I8R0xURlRhcmdldFR5cGUsIEJhYnlsb25UYXJnZXRUeXBlLCBRdWF0ZXJuaW9uPjtcbiAgICAgICAgc2NhbGU6IElPYmplY3RBY2Nlc3NvcjxHTFRGVGFyZ2V0VHlwZSwgQmFieWxvblRhcmdldFR5cGUsIFZlY3RvcjM+O1xuICAgICAgICBtYXRyaXg6IElPYmplY3RBY2Nlc3NvcjxHTFRGVGFyZ2V0VHlwZSwgQmFieWxvblRhcmdldFR5cGUsIE1hdHJpeD47XG4gICAgICAgIGdsb2JhbE1hdHJpeDogSU9iamVjdEFjY2Vzc29yPEdMVEZUYXJnZXRUeXBlLCBCYWJ5bG9uVGFyZ2V0VHlwZSwgTWF0cml4PjtcbiAgICAgICAgd2VpZ2h0czoge1xuICAgICAgICAgICAgbGVuZ3RoOiBJT2JqZWN0QWNjZXNzb3I8R0xURlRhcmdldFR5cGUsIEJhYnlsb25UYXJnZXRUeXBlLCBudW1iZXI+O1xuICAgICAgICAgICAgX19hcnJheV9fOiB7IF9fdGFyZ2V0X186IGJvb2xlYW4gfSAmIElPYmplY3RBY2Nlc3NvcjxHTFRGVGFyZ2V0VHlwZSwgQmFieWxvblRhcmdldFR5cGUsIG51bWJlcj47XG4gICAgICAgIH0gJiBJT2JqZWN0QWNjZXNzb3I8R0xURlRhcmdldFR5cGUsIEJhYnlsb25UYXJnZXRUeXBlLCBudW1iZXJbXT47XG4gICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgIEVYVF9saWdodHNfaWVzPzoge1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXI6IElPYmplY3RBY2Nlc3NvcjxJTm9kZSwgTGlnaHQsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgY29sb3I6IElPYmplY3RBY2Nlc3NvcjxJTm9kZSwgTGlnaHQsIENvbG9yMz47XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZPYmplY3RNb2RlbFRyZWVDYW1lcmFzT2JqZWN0IHtcbiAgICBfX2FycmF5X186IHtcbiAgICAgICAgX190YXJnZXRfXzogYm9vbGVhbjtcbiAgICAgICAgb3J0aG9ncmFwaGljOiB7XG4gICAgICAgICAgICB4bWFnOiBJT2JqZWN0QWNjZXNzb3I8SUNhbWVyYSwgSUNhbWVyYSwgVmVjdG9yMj47XG4gICAgICAgICAgICB5bWFnOiBJT2JqZWN0QWNjZXNzb3I8SUNhbWVyYSwgSUNhbWVyYSwgVmVjdG9yMj47XG4gICAgICAgICAgICB6ZmFyOiBJT2JqZWN0QWNjZXNzb3I8SUNhbWVyYSwgSUNhbWVyYSwgbnVtYmVyPjtcbiAgICAgICAgICAgIHpuZWFyOiBJT2JqZWN0QWNjZXNzb3I8SUNhbWVyYSwgSUNhbWVyYSwgbnVtYmVyPjtcbiAgICAgICAgfTtcbiAgICAgICAgcGVyc3BlY3RpdmU6IHtcbiAgICAgICAgICAgIHlmb3Y6IElPYmplY3RBY2Nlc3NvcjxJQ2FtZXJhLCBJQ2FtZXJhLCBudW1iZXI+O1xuICAgICAgICAgICAgemZhcjogSU9iamVjdEFjY2Vzc29yPElDYW1lcmEsIElDYW1lcmEsIG51bWJlcj47XG4gICAgICAgICAgICB6bmVhcjogSU9iamVjdEFjY2Vzc29yPElDYW1lcmEsIElDYW1lcmEsIG51bWJlcj47XG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogSU9iamVjdEFjY2Vzc29yPElDYW1lcmEsIElDYW1lcmEsIE51bGxhYmxlPG51bWJlcj4+O1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZPYmplY3RNb2RlbFRyZWVNYXRlcmlhbHNPYmplY3Qge1xuICAgIF9fYXJyYXlfXzoge1xuICAgICAgICBfX3RhcmdldF9fOiBib29sZWFuO1xuICAgICAgICBwYnJNZXRhbGxpY1JvdWdobmVzczoge1xuICAgICAgICAgICAgYmFzZUNvbG9yRmFjdG9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgQ29sb3I0PjtcbiAgICAgICAgICAgIG1ldGFsbGljRmFjdG9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgTnVsbGFibGU8bnVtYmVyPj47XG4gICAgICAgICAgICByb3VnaG5lc3NGYWN0b3I6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBOdWxsYWJsZTxudW1iZXI+PjtcbiAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogSVRleHR1cmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZW1pc3NpdmVGYWN0b3I6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBDb2xvcjM+O1xuICAgICAgICBub3JtYWxUZXh0dXJlOiB7XG4gICAgICAgICAgICBzY2FsZTogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBJVGV4dHVyZURlZmluaXRpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBvY2NsdXNpb25UZXh0dXJlOiB7XG4gICAgICAgICAgICBzdHJlbmd0aDogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBJVGV4dHVyZURlZmluaXRpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBlbWlzc2l2ZVRleHR1cmU6IHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfYW5pc290cm9weToge1xuICAgICAgICAgICAgICAgIGFuaXNvdHJvcHlTdHJlbmd0aDogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgYW5pc290cm9weVJvdGF0aW9uOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICBhbmlzb3Ryb3B5VGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfY2xlYXJjb2F0OiB7XG4gICAgICAgICAgICAgICAgY2xlYXJjb2F0RmFjdG9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICBjbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBudW1iZXI+O1xuICAgICAgICAgICAgICAgIGNsZWFyY29hdFRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBJVGV4dHVyZURlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbGVhcmNvYXROb3JtYWxUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBJVGV4dHVyZURlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogSVRleHR1cmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19kaXNwZXJzaW9uOiB7XG4gICAgICAgICAgICAgICAgZGlzcGVyc2lvbjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aDoge1xuICAgICAgICAgICAgICAgIGVtaXNzaXZlU3RyZW5ndGg6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBudW1iZXI+O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfaW9yOiB7XG4gICAgICAgICAgICAgICAgaW9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBLSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlOiB7XG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VGYWN0b3I6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBudW1iZXI+O1xuICAgICAgICAgICAgICAgIGlyaWRlc2NlbmNlSW9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW06IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBudW1iZXI+O1xuICAgICAgICAgICAgICAgIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogSVRleHR1cmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogSVRleHR1cmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19zaGVlbjoge1xuICAgICAgICAgICAgICAgIHNoZWVuQ29sb3JGYWN0b3I6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBDb2xvcjM+O1xuICAgICAgICAgICAgICAgIHNoZWVuUm91Z2huZXNzRmFjdG9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICBzaGVlbkNvbG9yVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNoZWVuUm91Z2huZXNzVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfc3BlY3VsYXI6IHtcbiAgICAgICAgICAgICAgICBzcGVjdWxhckZhY3RvcjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgc3BlY3VsYXJDb2xvckZhY3RvcjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIENvbG9yMz47XG4gICAgICAgICAgICAgICAgc3BlY3VsYXJUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogSVRleHR1cmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3BlY3VsYXJDb2xvclRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBJVGV4dHVyZURlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbjoge1xuICAgICAgICAgICAgICAgIHRyYW5zbWlzc2lvbkZhY3RvcjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgdHJhbnNtaXNzaW9uVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfZGlmZnVzZV90cmFuc21pc3Npb246IHtcbiAgICAgICAgICAgICAgICBkaWZmdXNlVHJhbnNtaXNzaW9uRmFjdG9yOiBJT2JqZWN0QWNjZXNzb3I8SU1hdGVyaWFsLCBQQlJNYXRlcmlhbCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICBkaWZmdXNlVHJhbnNtaXNzaW9uVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpZmZ1c2VUcmFuc21pc3Npb25Db2xvckZhY3RvcjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIE51bGxhYmxlPENvbG9yMz4+O1xuICAgICAgICAgICAgICAgIGRpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBJVGV4dHVyZURlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBLSFJfbWF0ZXJpYWxzX3ZvbHVtZToge1xuICAgICAgICAgICAgICAgIHRoaWNrbmVzc0ZhY3RvcjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgYXR0ZW51YXRpb25Db2xvcjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIENvbG9yMz47XG4gICAgICAgICAgICAgICAgYXR0ZW51YXRpb25EaXN0YW5jZTogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IElUZXh0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5pbnRlcmZhY2UgSVRleHR1cmVEZWZpbml0aW9uIHtcbiAgICBvZmZzZXQ6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBWZWN0b3IyPjtcbiAgICByb3RhdGlvbjogSU9iamVjdEFjY2Vzc29yPElNYXRlcmlhbCwgUEJSTWF0ZXJpYWwsIG51bWJlcj47XG4gICAgc2NhbGU6IElPYmplY3RBY2Nlc3NvcjxJTWF0ZXJpYWwsIFBCUk1hdGVyaWFsLCBWZWN0b3IyPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJR0xURk9iamVjdE1vZGVsVHJlZU1lc2hlc09iamVjdCB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGT2JqZWN0TW9kZWxUcmVlRXh0ZW5zaW9uc09iamVjdCB7XG4gICAgS0hSX2xpZ2h0c19wdW5jdHVhbDoge1xuICAgICAgICBsaWdodHM6IHtcbiAgICAgICAgICAgIGxlbmd0aDogSU9iamVjdEFjY2Vzc29yPElLSFJMaWdodHNQdW5jdHVhbF9MaWdodFtdLCBMaWdodFtdLCBudW1iZXI+O1xuICAgICAgICAgICAgX19hcnJheV9fOiB7XG4gICAgICAgICAgICAgICAgX190YXJnZXRfXzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgICBjb2xvcjogSU9iamVjdEFjY2Vzc29yPElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCwgTGlnaHQsIENvbG9yMz47XG4gICAgICAgICAgICAgICAgaW50ZW5zaXR5OiBJT2JqZWN0QWNjZXNzb3I8SUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0LCBMaWdodCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICByYW5nZTogSU9iamVjdEFjY2Vzc29yPElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCwgTGlnaHQsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgc3BvdDoge1xuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbmVBbmdsZTogSU9iamVjdEFjY2Vzc29yPElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCwgTGlnaHQsIG51bWJlcj47XG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ29uZUFuZ2xlOiBJT2JqZWN0QWNjZXNzb3I8SUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0LCBMaWdodCwgbnVtYmVyPjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEVYVF9saWdodHNfaWVzOiB7XG4gICAgICAgIGxpZ2h0czoge1xuICAgICAgICAgICAgbGVuZ3RoOiBJT2JqZWN0QWNjZXNzb3I8SUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0W10sIExpZ2h0W10sIG51bWJlcj47XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFWFRfbGlnaHRzX2ltYWdlX2Jhc2VkOiB7XG4gICAgICAgIGxpZ2h0czoge1xuICAgICAgICAgICAgX19hcnJheV9fOiB7XG4gICAgICAgICAgICAgICAgX190YXJnZXRfXzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgICBpbnRlbnNpdHk6IElPYmplY3RBY2Nlc3NvcjxJRVhUTGlnaHRzSW1hZ2VCYXNlZF9MaWdodEltYWdlQmFzZWQsIEJhc2VUZXh0dXJlLCBudW1iZXI+O1xuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBJT2JqZWN0QWNjZXNzb3I8SUVYVExpZ2h0c0ltYWdlQmFzZWRfTGlnaHRJbWFnZUJhc2VkLCBCYXNlVGV4dHVyZSwgUXVhdGVybmlvbj47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGVuZ3RoOiBJT2JqZWN0QWNjZXNzb3I8SUVYVExpZ2h0c0ltYWdlQmFzZWRfTGlnaHRJbWFnZUJhc2VkW10sIEJhc2VUZXh0dXJlW10sIG51bWJlcj47XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuY29uc3Qgbm9kZXNUcmVlOiBJR0xURk9iamVjdE1vZGVsVHJlZU5vZGVzT2JqZWN0ID0ge1xuICAgIGxlbmd0aDoge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBnZXQ6IChub2RlczogSU5vZGVbXSkgPT4gbm9kZXMubGVuZ3RoLFxuICAgICAgICBnZXRUYXJnZXQ6IChub2RlczogSU5vZGVbXSkgPT4gbm9kZXMubWFwKChub2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSEpLFxuICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcImxlbmd0aFwiXSxcbiAgICB9LFxuICAgIF9fYXJyYXlfXzoge1xuICAgICAgICBfX3RhcmdldF9fOiB0cnVlLFxuICAgICAgICB0cmFuc2xhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJWZWN0b3IzXCIsXG4gICAgICAgICAgICBnZXQ6IChub2RlOiBJTm9kZSkgPT4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGU/LnBvc2l0aW9uLFxuICAgICAgICAgICAgc2V0OiAodmFsdWU6IFZlY3RvcjMsIG5vZGU6IElOb2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8ucG9zaXRpb24uY29weUZyb20odmFsdWUpLFxuICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLFxuICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJwb3NpdGlvblwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwiUXVhdGVybmlvblwiLFxuICAgICAgICAgICAgZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5yb3RhdGlvblF1YXRlcm5pb24hLFxuICAgICAgICAgICAgc2V0OiAodmFsdWU6IFF1YXRlcm5pb24sIG5vZGU6IElOb2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8ucm90YXRpb25RdWF0ZXJuaW9uPy5jb3B5RnJvbSh2YWx1ZSksXG4gICAgICAgICAgICBnZXRUYXJnZXQ6IChub2RlOiBJTm9kZSkgPT4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUsXG4gICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcInJvdGF0aW9uUXVhdGVybmlvblwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiVmVjdG9yM1wiLFxuICAgICAgICAgICAgZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5zY2FsaW5nLFxuICAgICAgICAgICAgc2V0OiAodmFsdWU6IFZlY3RvcjMsIG5vZGU6IElOb2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8uc2NhbGluZy5jb3B5RnJvbSh2YWx1ZSksXG4gICAgICAgICAgICBnZXRUYXJnZXQ6IChub2RlOiBJTm9kZSkgPT4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUsXG4gICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcInNjYWxpbmdcIl0sXG4gICAgICAgIH0sXG4gICAgICAgIHdlaWdodHM6IHtcbiAgICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX251bU1vcnBoVGFyZ2V0cyxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChub2RlOiBJTm9kZSkgPT4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUsXG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJpbmZsdWVuY2VcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX19hcnJheV9fOiB7XG4gICAgICAgICAgICAgICAgX190YXJnZXRfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKG5vZGU6IElOb2RlLCBpbmRleD86IG51bWJlcikgPT4gKGluZGV4ICE9PSB1bmRlZmluZWQgPyBub2RlLl9wcmltaXRpdmVCYWJ5bG9uTWVzaGVzPy5bMF0ubW9ycGhUYXJnZXRNYW5hZ2VyPy5nZXRUYXJnZXQoaW5kZXgpLmluZmx1ZW5jZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgLy8gc2V0OiAodmFsdWU6IG51bWJlciwgbm9kZTogSU5vZGUsIGluZGV4PzogbnVtYmVyKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8uZ2V0TW9ycGhUYXJnZXRNYW5hZ2VyKCk/LmdldFRhcmdldChpbmRleCk/LnNldEluZmx1ZW5jZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLFxuICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwiaW5mbHVlbmNlXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyW11cIixcbiAgICAgICAgICAgIGdldDogKG5vZGU6IElOb2RlLCBpbmRleD86IG51bWJlcikgPT4gWzBdLCAvLyBUT0RPOiBnZXQgdGhlIHdlaWdodHMgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyBzZXQ6ICh2YWx1ZTogbnVtYmVyLCBub2RlOiBJTm9kZSwgaW5kZXg/OiBudW1iZXIpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5nZXRNb3JwaFRhcmdldE1hbmFnZXIoKT8uZ2V0VGFyZ2V0KGluZGV4KT8uc2V0SW5mbHVlbmNlKHZhbHVlKSxcbiAgICAgICAgICAgIGdldFRhcmdldDogKG5vZGU6IElOb2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSxcbiAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwiaW5mbHVlbmNlXCJdLFxuICAgICAgICB9LFxuICAgICAgICAvLyByZWFkb25seSFcbiAgICAgICAgbWF0cml4OiB7XG4gICAgICAgICAgICB0eXBlOiBcIk1hdHJpeFwiLFxuICAgICAgICAgICAgZ2V0OiAobm9kZTogSU5vZGUpID0+IE1hdHJpeC5Db21wb3NlKG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5zY2FsaW5nISwgbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGU/LnJvdGF0aW9uUXVhdGVybmlvbiEsIG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5wb3NpdGlvbiEpLFxuICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLFxuICAgICAgICAgICAgaXNSZWFkT25seTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2xvYmFsTWF0cml4OiB7XG4gICAgICAgICAgICB0eXBlOiBcIk1hdHJpeFwiLFxuICAgICAgICAgICAgZ2V0OiAobm9kZTogSU5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRyaXggPSBNYXRyaXguSWRlbnRpdHkoKTtcbiAgICAgICAgICAgICAgICAvLyBSSFMvTEhTIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBsZXQgcm9vdE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocm9vdE5vZGUgJiYgcm9vdE5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gcm9vdE5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5wb3NpdGlvbi5faXNEaXJ0eSB8fCBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8ucm90YXRpb25RdWF0ZXJuaW9uPy5faXNEaXJ0eSB8fCBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8uc2NhbGluZy5faXNEaXJ0eTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSB0aGUgcGFyZW50IHJvb3Qgbm9kZSdzIHdvcmxkIG1hdHJpeCwgaW52ZXJ0IGl0LCBhbmQgbXVsdGlwbHkgaXQgd2l0aCB0aGUgY3VycmVudCBub2RlJ3Mgd29ybGQgbWF0cml4XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcm92aWRlIHRoZSBnbG9iYWwgbWF0cml4LCBpZ25vcmluZyB0aGUgUkhTLT5MSFMgY29udmVyc2lvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb290TWF0cml4ID0gcm9vdE5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5jb21wdXRlV29ybGRNYXRyaXgodHJ1ZSkuaW52ZXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290TWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8uY29tcHV0ZVdvcmxkTWF0cml4KGZvcmNlVXBkYXRlKT8ubXVsdGlwbHlUb1JlZihyb290TWF0cml4LCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguY29weUZyb20obm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUuY29tcHV0ZVdvcmxkTWF0cml4KGZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLFxuICAgICAgICAgICAgaXNSZWFkT25seTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgRVhUX2xpZ2h0c19pZXM6IHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKG5vZGU6IElOb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGU/LmdldENoaWxkcmVuKChjaGlsZCkgPT4gY2hpbGQgaW5zdGFuY2VvZiBTcG90TGlnaHQsIHRydWUpWzBdPy5pbnRlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogKG5vZGU6IElOb2RlKSA9PiBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZT8uZ2V0Q2hpbGRyZW4oKGNoaWxkKSA9PiBjaGlsZCBpbnN0YW5jZW9mIFNwb3RMaWdodCwgdHJ1ZSlbMF0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaWdodCA9IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLmdldENoaWxkcmVuKChjaGlsZCkgPT4gY2hpbGQgaW5zdGFuY2VvZiBTcG90TGlnaHQsIHRydWUpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWdodC5pbnRlbnNpdHkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkNvbG9yM1wiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChub2RlOiBJTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5nZXRDaGlsZHJlbigoY2hpbGQpID0+IGNoaWxkIGluc3RhbmNlb2YgU3BvdExpZ2h0LCB0cnVlKVswXT8uZGlmZnVzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobm9kZTogSU5vZGUpID0+IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPy5nZXRDaGlsZHJlbigoY2hpbGQpID0+IGNoaWxkIGluc3RhbmNlb2YgU3BvdExpZ2h0LCB0cnVlKVswXSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG5vZGU6IElOb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaWdodCA9IG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLmdldENoaWxkcmVuKChjaGlsZCkgPT4gY2hpbGQgaW5zdGFuY2VvZiBTcG90TGlnaHQsIHRydWUpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWdodC5kaWZmdXNlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5jb25zdCBhbmltYXRpb25zVHJlZSA9IHtcbiAgICBsZW5ndGg6IHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgZ2V0OiAoYW5pbWF0aW9uczogSUFuaW1hdGlvbltdKSA9PiBhbmltYXRpb25zLmxlbmd0aCxcbiAgICAgICAgZ2V0VGFyZ2V0OiAoYW5pbWF0aW9uczogSUFuaW1hdGlvbltdKSA9PiBhbmltYXRpb25zLm1hcCgoYW5pbWF0aW9uKSA9PiBhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cCEpLFxuICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcImxlbmd0aFwiXSxcbiAgICB9LFxuICAgIF9fYXJyYXlfXzoge30sXG59O1xuXG5jb25zdCBtZXNoZXNUcmVlID0ge1xuICAgIGxlbmd0aDoge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBnZXQ6IChtZXNoZXM6IElNZXNoW10pID0+IG1lc2hlcy5sZW5ndGgsXG4gICAgICAgIGdldFRhcmdldDogKG1lc2hlczogSU1lc2hbXSkgPT4gbWVzaGVzLm1hcCgobWVzaCkgPT4gbWVzaC5wcmltaXRpdmVzWzBdLl9pbnN0YW5jZURhdGE/LmJhYnlsb25Tb3VyY2VNZXNoKSxcbiAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJsZW5ndGhcIl0sXG4gICAgfSxcbiAgICBfX2FycmF5X186IHt9LFxufTtcblxuY29uc3QgY2FtZXJhc1RyZWU6IElHTFRGT2JqZWN0TW9kZWxUcmVlQ2FtZXJhc09iamVjdCA9IHtcbiAgICBfX2FycmF5X186IHtcbiAgICAgICAgX190YXJnZXRfXzogdHJ1ZSxcbiAgICAgICAgb3J0aG9ncmFwaGljOiB7XG4gICAgICAgICAgICB4bWFnOiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c0NvdW50OiAyLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmVjdG9yMlwiLFxuICAgICAgICAgICAgICAgIGdldDogKGNhbWVyYSkgPT4gbmV3IFZlY3RvcjIoY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhPy5vcnRob0xlZnQgPz8gMCwgY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhPy5vcnRob1JpZ2h0ID8/IDApLFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBjYW1lcmEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbWVyYS5fYmFieWxvbkNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhLm9ydGhvTGVmdCA9IHZhbHVlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmEuX2JhYnlsb25DYW1lcmEub3J0aG9SaWdodCA9IHZhbHVlLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRhcmdldDogKGNhbWVyYSkgPT4gY2FtZXJhLFxuICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwib3J0aG9MZWZ0XCIsICgpID0+IFwib3J0aG9SaWdodFwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5bWFnOiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c0NvdW50OiAyLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmVjdG9yMlwiLFxuICAgICAgICAgICAgICAgIGdldDogKGNhbWVyYTogSUNhbWVyYSkgPT4gbmV3IFZlY3RvcjIoY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhPy5vcnRob0JvdHRvbSA/PyAwLCBjYW1lcmEuX2JhYnlsb25DYW1lcmE/Lm9ydGhvVG9wID8/IDApLFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBWZWN0b3IyLCBjYW1lcmE6IElDYW1lcmEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbWVyYS5fYmFieWxvbkNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhLm9ydGhvQm90dG9tID0gdmFsdWUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVyYS5fYmFieWxvbkNhbWVyYS5vcnRob1RvcCA9IHZhbHVlLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRhcmdldDogKGNhbWVyYSkgPT4gY2FtZXJhLFxuICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwib3J0aG9Cb3R0b21cIiwgKCkgPT4gXCJvcnRob1RvcFwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6ZmFyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYS5fYmFieWxvbkNhbWVyYT8ubWF4WixcbiAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZTogbnVtYmVyLCBjYW1lcmE6IElDYW1lcmEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbWVyYS5fYmFieWxvbkNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhLm1heFogPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAoY2FtZXJhOiBJQ2FtZXJhKSA9PiBjYW1lcmEsXG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJtYXhaXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpuZWFyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYS5fYmFieWxvbkNhbWVyYT8ubWluWixcbiAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZTogbnVtYmVyLCBjYW1lcmE6IElDYW1lcmEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbWVyYS5fYmFieWxvbkNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhLm1pblogPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAoY2FtZXJhOiBJQ2FtZXJhKSA9PiBjYW1lcmEsXG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJtaW5aXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcGVyc3BlY3RpdmU6IHtcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYS5fYmFieWxvbkNhbWVyYT8uZ2V0RW5naW5lKCkuZ2V0QXNwZWN0UmF0aW8oY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhKSxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcImFzcGVjdFJhdGlvXCJdLFxuICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IHRydWUsIC8vIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZSBmb3IgZ2xURj9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5Zm92OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYS5fYmFieWxvbkNhbWVyYT8uZm92LFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBudW1iZXIsIGNhbWVyYTogSUNhbWVyYSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmEuX2JhYnlsb25DYW1lcmEuZm92ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRhcmdldDogKGNhbWVyYTogSUNhbWVyYSkgPT4gY2FtZXJhLFxuICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwiZm92XCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpmYXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKGNhbWVyYTogSUNhbWVyYSkgPT4gY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhPy5tYXhaLFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBudW1iZXIsIGNhbWVyYTogSUNhbWVyYSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmEuX2JhYnlsb25DYW1lcmEubWF4WiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcIm1heFpcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem5lYXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKGNhbWVyYTogSUNhbWVyYSkgPT4gY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhPy5taW5aLFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBudW1iZXIsIGNhbWVyYTogSUNhbWVyYSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FtZXJhLl9iYWJ5bG9uQ2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmEuX2JhYnlsb25DYW1lcmEubWluWiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChjYW1lcmE6IElDYW1lcmEpID0+IGNhbWVyYSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcIm1pblpcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5jb25zdCBtYXRlcmlhbHNUcmVlOiBJR0xURk9iamVjdE1vZGVsVHJlZU1hdGVyaWFsc09iamVjdCA9IHtcbiAgICBfX2FycmF5X186IHtcbiAgICAgICAgX190YXJnZXRfXzogdHJ1ZSxcbiAgICAgICAgZW1pc3NpdmVGYWN0b3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiQ29sb3IzXCIsXG4gICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5lbWlzc2l2ZUNvbG9yLFxuICAgICAgICAgICAgc2V0OiAodmFsdWU6IENvbG9yMywgbWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuZW1pc3NpdmVDb2xvci5jb3B5RnJvbSh2YWx1ZSksXG4gICAgICAgICAgICBnZXRUYXJnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSxcbiAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwiZW1pc3NpdmVDb2xvclwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgZW1pc3NpdmVUZXh0dXJlOiB7XG4gICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBHZW5lcmF0ZVRleHR1cmVNYXAoXCJlbWlzc2l2ZVRleHR1cmVcIiksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBub3JtYWxUZXh0dXJlOiB7XG4gICAgICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IEdldFRleHR1cmUobWF0ZXJpYWwsIHBheWxvYWQsIFwiYnVtcFRleHR1cmVcIik/LmxldmVsLFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBudW1iZXIsIG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBHZXRUZXh0dXJlKG1hdGVyaWFsLCBwYXlsb2FkLCBcImJ1bXBUZXh0dXJlXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5sZXZlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcImxldmVsXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IEdlbmVyYXRlVGV4dHVyZU1hcChcImJ1bXBUZXh0dXJlXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb2NjbHVzaW9uVGV4dHVyZToge1xuICAgICAgICAgICAgc3RyZW5ndGg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmFtYmllbnRUZXh0dXJlU3RyZW5ndGgsXG4gICAgICAgICAgICAgICAgc2V0OiAodmFsdWU6IG51bWJlciwgbWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ID0gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmFtYmllbnRUZXh0dXJlU3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJhbWJpZW50VGV4dHVyZVN0cmVuZ3RoXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IEdlbmVyYXRlVGV4dHVyZU1hcChcImFtYmllbnRUZXh0dXJlXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcGJyTWV0YWxsaWNSb3VnaG5lc3M6IHtcbiAgICAgICAgICAgIGJhc2VDb2xvckZhY3Rvcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQ29sb3I0XCIsXG4gICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ID0gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yNC5Gcm9tQ29sb3IzKG1hdC5hbGJlZG9Db2xvciwgbWF0LmFscGhhKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBDb2xvcjQsIG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdCA9IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdC5hbGJlZG9Db2xvci5zZXQodmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYik7XG4gICAgICAgICAgICAgICAgICAgIG1hdC5hbHBoYSA9IHZhbHVlLmE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGNvcnJlY3Qgb24gdGhlIGFuaW1hdGlvbiBsZXZlbCwgYnV0IGluY29ycmVjdCBhcyBhIHNpbmdsZSBwcm9wZXJ0eSBvZiBhIHR5cGUgQ29sb3I0XG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJhbGJlZG9Db2xvclwiLCAoKSA9PiBcImFscGhhXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwiYWxiZWRvVGV4dHVyZVwiKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGFsbGljRmFjdG9yOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5tZXRhbGxpYyxcbiAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ID0gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Lm1ldGFsbGljID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFRhcmdldDogKG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwibWV0YWxsaWNcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm91Z2huZXNzRmFjdG9yOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5yb3VnaG5lc3MsXG4gICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdCA9IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5yb3VnaG5lc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJyb3VnaG5lc3NcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IEdlbmVyYXRlVGV4dHVyZU1hcChcIm1ldGFsbGljVGV4dHVyZVwiKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5OiB7XG4gICAgICAgICAgICAgICAgYW5pc290cm9weVN0cmVuZ3RoOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmFuaXNvdHJvcHkuaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZTogbnVtYmVyLCBtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5hbmlzb3Ryb3B5LmludGVuc2l0eSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJhbmlzb3Ryb3B5LmludGVuc2l0eVwiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFuaXNvdHJvcHlSb3RhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5hbmlzb3Ryb3B5LmFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZTogbnVtYmVyLCBtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5hbmlzb3Ryb3B5LmFuZ2xlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogKG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLFxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcImFuaXNvdHJvcHkuYW5nbGVcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmlzb3Ryb3B5VGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IEdlbmVyYXRlVGV4dHVyZU1hcChcImFuaXNvdHJvcHlcIiwgXCJ0ZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19jbGVhcmNvYXQ6IHtcbiAgICAgICAgICAgICAgICBjbGVhcmNvYXRGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuY2xlYXJDb2F0LmludGVuc2l0eSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleD8sIHBheWxvYWQ/KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmNsZWFyQ29hdC5pbnRlbnNpdHkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IFwiY2xlYXJDb2F0LmludGVuc2l0eVwiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsZWFyY29hdFJvdWdobmVzc0ZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5jbGVhckNvYXQucm91Z2huZXNzLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuY2xlYXJDb2F0LnJvdWdobmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChtYXRlcmlhbCwgaW5kZXg/LCBwYXlsb2FkPykgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJjbGVhckNvYXQucm91Z2huZXNzXCJdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xlYXJjb2F0VGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IEdlbmVyYXRlVGV4dHVyZU1hcChcImNsZWFyQ29hdFwiLCBcInRleHR1cmVcIiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGVhcmNvYXROb3JtYWxUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmNsZWFyQ29hdC5idW1wVGV4dHVyZT8ubGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gKEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuY2xlYXJDb2F0LmJ1bXBUZXh0dXJlIS5sZXZlbCA9IHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBHZW5lcmF0ZVRleHR1cmVNYXAoXCJjbGVhckNvYXRcIiwgXCJidW1wVGV4dHVyZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsZWFyY29hdFJvdWdobmVzc1RleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBHZW5lcmF0ZVRleHR1cmVNYXAoXCJjbGVhckNvYXRcIiwgXCJ0ZXh0dXJlUm91Z2huZXNzXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19kaXNwZXJzaW9uOiB7XG4gICAgICAgICAgICAgICAgZGlzcGVyc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS5kaXNwZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5zdWJTdXJmYWNlLmRpc3BlcnNpb24gPSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoOiB7XG4gICAgICAgICAgICAgICAgZW1pc3NpdmVTdHJlbmd0aDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuZW1pc3NpdmVJbnRlbnNpdHksXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IChHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmVtaXNzaXZlSW50ZW5zaXR5ID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19pb3I6IHtcbiAgICAgICAgICAgICAgICBpb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmluZGV4T2ZSZWZyYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5pbmRleE9mUmVmcmFjdGlvbiA9IHZhbHVlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2U6IHtcbiAgICAgICAgICAgICAgICBpcmlkZXNjZW5jZUZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuaXJpZGVzY2VuY2UuaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5pcmlkZXNjZW5jZS5pbnRlbnNpdHkgPSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpcmlkZXNjZW5jZUlvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuaXJpZGVzY2VuY2UuaW5kZXhPZlJlZnJhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IChHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLmlyaWRlc2NlbmNlLmluZGV4T2ZSZWZyYWN0aW9uID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwiaXJpZGVzY2VuY2VcIiwgXCJ0ZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5pcmlkZXNjZW5jZS5tYXhpbXVtVGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5pcmlkZXNjZW5jZS5tYXhpbXVtVGhpY2tuZXNzID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5pcmlkZXNjZW5jZS5taW5pbXVtVGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5pcmlkZXNjZW5jZS5taW5pbXVtVGhpY2tuZXNzID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwiaXJpZGVzY2VuY2VcIiwgXCJ0aGlja25lc3NUZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19zaGVlbjoge1xuICAgICAgICAgICAgICAgIHNoZWVuQ29sb3JGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJDb2xvcjNcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLnNoZWVuLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLnNoZWVuLmNvbG9yLmNvcHlGcm9tKHZhbHVlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNoZWVuQ29sb3JUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwic2hlZW5cIiwgXCJ0ZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hlZW5Sb3VnaG5lc3NGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLnNoZWVuLmludGVuc2l0eSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiBHZXRNYXRlcmlhbCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gKEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc2hlZW4uaW50ZW5zaXR5ID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hlZW5Sb3VnaG5lc3NUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwic2hlZW5cIiwgXCJ0aGlja25lc3NUZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgS0hSX21hdGVyaWFsc19zcGVjdWxhcjoge1xuICAgICAgICAgICAgICAgIHNwZWN1bGFyRmFjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5tZXRhbGxpY0YwRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5tZXRhbGxpY0YwRmFjdG9yID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcIm1ldGFsbGljRjBGYWN0b3JcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcGVjdWxhckNvbG9yRmFjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiQ29sb3IzXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5tZXRhbGxpY1JlZmxlY3RhbmNlQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkubWV0YWxsaWNSZWZsZWN0YW5jZUNvbG9yLmNvcHlGcm9tKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKCkgPT4gXCJtZXRhbGxpY1JlZmxlY3RhbmNlQ29sb3JcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcGVjdWxhclRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBHZW5lcmF0ZVRleHR1cmVNYXAoXCJtZXRhbGxpY1JlZmxlY3RhbmNlVGV4dHVyZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNwZWN1bGFyQ29sb3JUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwicmVmbGVjdGFuY2VUZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgS0hSX21hdGVyaWFsc190cmFuc21pc3Npb246IHtcbiAgICAgICAgICAgICAgICB0cmFuc21pc3Npb25GYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLnN1YlN1cmZhY2UucmVmcmFjdGlvbkludGVuc2l0eSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiBHZXRNYXRlcmlhbCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gKEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS5yZWZyYWN0aW9uSW50ZW5zaXR5ID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoKSA9PiBcInN1YlN1cmZhY2UucmVmcmFjdGlvbkludGVuc2l0eVwiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zbWlzc2lvblRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBHZW5lcmF0ZVRleHR1cmVNYXAoXCJzdWJTdXJmYWNlXCIsIFwicmVmcmFjdGlvbkludGVuc2l0eVRleHR1cmVcIiksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBLSFJfbWF0ZXJpYWxzX2RpZmZ1c2VfdHJhbnNtaXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgZGlmZnVzZVRyYW5zbWlzc2lvbkZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS50cmFuc2x1Y2VuY3lJbnRlbnNpdHksXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IChHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLnN1YlN1cmZhY2UudHJhbnNsdWNlbmN5SW50ZW5zaXR5ID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiBHZW5lcmF0ZVRleHR1cmVNYXAoXCJzdWJTdXJmYWNlXCIsIFwidHJhbnNsdWNlbmN5SW50ZW5zaXR5VGV4dHVyZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpZmZ1c2VUcmFuc21pc3Npb25Db2xvckZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkNvbG9yM1wiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS50cmFuc2x1Y2VuY3lDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiBHZXRNYXRlcmlhbCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gdmFsdWUgJiYgR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5zdWJTdXJmYWNlLnRyYW5zbHVjZW5jeUNvbG9yPy5jb3B5RnJvbSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtIUl90ZXh0dXJlX3RyYW5zZm9ybTogR2VuZXJhdGVUZXh0dXJlTWFwKFwic3ViU3VyZmFjZVwiLCBcInRyYW5zbHVjZW5jeUNvbG9yVGV4dHVyZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEtIUl9tYXRlcmlhbHNfdm9sdW1lOiB7XG4gICAgICAgICAgICAgICAgYXR0ZW51YXRpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkNvbG9yM1wiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS50aW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS50aW50Q29sb3IuY29weUZyb20odmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXR0ZW51YXRpb25EaXN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpID0+IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS50aW50Q29sb3JBdERpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IEdldE1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiAoR2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKS5zdWJTdXJmYWNlLnRpbnRDb2xvckF0RGlzdGFuY2UgPSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3NGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIGluZGV4LCBwYXlsb2FkKSA9PiBHZXRNYXRlcmlhbChtYXRlcmlhbCwgaW5kZXgsIHBheWxvYWQpLnN1YlN1cmZhY2UubWF4aW11bVRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiBHZXRNYXRlcmlhbCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUsIG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkgPT4gKEdldE1hdGVyaWFsKG1hdGVyaWFsLCBpbmRleCwgcGF5bG9hZCkuc3ViU3VyZmFjZS5tYXhpbXVtVGhpY2tuZXNzID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLSFJfdGV4dHVyZV90cmFuc2Zvcm06IEdlbmVyYXRlVGV4dHVyZU1hcChcInN1YlN1cmZhY2VcIiwgXCJ0aGlja25lc3NUZXh0dXJlXCIpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5jb25zdCBleHRlbnNpb25zVHJlZTogSUdMVEZPYmplY3RNb2RlbFRyZWVFeHRlbnNpb25zT2JqZWN0ID0ge1xuICAgIEtIUl9saWdodHNfcHVuY3R1YWw6IHtcbiAgICAgICAgbGlnaHRzOiB7XG4gICAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKGxpZ2h0czogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0W10pID0+IGxpZ2h0cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobGlnaHRzOiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHRbXSkgPT4gbGlnaHRzLm1hcCgobGlnaHQpID0+IGxpZ2h0Ll9iYWJ5bG9uTGlnaHQhKSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoX2xpZ2h0czogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0W10pID0+IFwibGVuZ3RoXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9fYXJyYXlfXzoge1xuICAgICAgICAgICAgICAgIF9fdGFyZ2V0X186IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJDb2xvcjNcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gbGlnaHQuX2JhYnlsb25MaWdodD8uZGlmZnVzZSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWU6IENvbG9yMywgbGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gbGlnaHQuX2JhYnlsb25MaWdodD8uZGlmZnVzZS5jb3B5RnJvbSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogKGxpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IGxpZ2h0Ll9iYWJ5bG9uTGlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWyhfbGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gXCJkaWZmdXNlXCJdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZW5zaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKGxpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IGxpZ2h0Ll9iYWJ5bG9uTGlnaHQ/LmludGVuc2l0eSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWU6IG51bWJlciwgbGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gKGxpZ2h0Ll9iYWJ5bG9uTGlnaHQgPyAobGlnaHQuX2JhYnlsb25MaWdodC5pbnRlbnNpdHkgPSB2YWx1ZSkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChsaWdodDogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0KSA9PiBsaWdodC5fYmFieWxvbkxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoX2xpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IFwiaW50ZW5zaXR5XCJdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gbGlnaHQuX2JhYnlsb25MaWdodD8ucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBudW1iZXIsIGxpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IChsaWdodC5fYmFieWxvbkxpZ2h0ID8gKGxpZ2h0Ll9iYWJ5bG9uTGlnaHQucmFuZ2UgPSB2YWx1ZSkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChsaWdodDogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0KSA9PiBsaWdodC5fYmFieWxvbkxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoX2xpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IFwicmFuZ2VcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcG90OiB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyQ29uZUFuZ2xlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAobGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gKGxpZ2h0Ll9iYWJ5bG9uTGlnaHQgYXMgU3BvdExpZ2h0KT8uaW5uZXJBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlOiBudW1iZXIsIGxpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IChsaWdodC5fYmFieWxvbkxpZ2h0ID8gKChsaWdodC5fYmFieWxvbkxpZ2h0IGFzIFNwb3RMaWdodCkuaW5uZXJBbmdsZSA9IHZhbHVlKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChsaWdodDogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0KSA9PiBsaWdodC5fYmFieWxvbkxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKF9saWdodDogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0KSA9PiBcImlubmVyQ29uZUFuZ2xlXCJdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRlckNvbmVBbmdsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKGxpZ2h0OiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHQpID0+IChsaWdodC5fYmFieWxvbkxpZ2h0IGFzIFNwb3RMaWdodCk/LmFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWU6IG51bWJlciwgbGlnaHQ6IElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCkgPT4gKGxpZ2h0Ll9iYWJ5bG9uTGlnaHQgPyAoKGxpZ2h0Ll9iYWJ5bG9uTGlnaHQgYXMgU3BvdExpZ2h0KS5hbmdsZSA9IHZhbHVlKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChsaWdodDogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0KSA9PiBsaWdodC5fYmFieWxvbkxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbKF9saWdodDogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0KSA9PiBcIm91dGVyQ29uZUFuZ2xlXCJdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgRVhUX2xpZ2h0c19pZXM6IHtcbiAgICAgICAgbGlnaHRzOiB7XG4gICAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKGxpZ2h0czogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0W10pID0+IGxpZ2h0cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0OiAobGlnaHRzOiBJS0hSTGlnaHRzUHVuY3R1YWxfTGlnaHRbXSkgPT4gbGlnaHRzLm1hcCgobGlnaHQpID0+IGxpZ2h0Ll9iYWJ5bG9uTGlnaHQhKSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoX2xpZ2h0czogSUtIUkxpZ2h0c1B1bmN0dWFsX0xpZ2h0W10pID0+IFwibGVuZ3RoXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEVYVF9saWdodHNfaW1hZ2VfYmFzZWQ6IHtcbiAgICAgICAgbGlnaHRzOiB7XG4gICAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGdldDogKGxpZ2h0cykgPT4gbGlnaHRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXQ6IChsaWdodHMpID0+IGxpZ2h0cy5tYXAoKGxpZ2h0KSA9PiBsaWdodC5fYmFieWxvblRleHR1cmUhKSxcbiAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eU5hbWU6IFsoX2xpZ2h0cykgPT4gXCJsZW5ndGhcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX19hcnJheV9fOiB7XG4gICAgICAgICAgICAgICAgX190YXJnZXRfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlbnNpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobGlnaHQpID0+IGxpZ2h0Ll9iYWJ5bG9uVGV4dHVyZT8ubGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIHNldDogKHZhbHVlLCBsaWdodCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpZ2h0Ll9iYWJ5bG9uVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0Ll9iYWJ5bG9uVGV4dHVyZS5sZXZlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogKGxpZ2h0KSA9PiBsaWdodC5fYmFieWxvblRleHR1cmUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlF1YXRlcm5pb25cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAobGlnaHQpID0+IGxpZ2h0Ll9iYWJ5bG9uVGV4dHVyZSAmJiBRdWF0ZXJuaW9uLkZyb21Sb3RhdGlvbk1hdHJpeChsaWdodC5fYmFieWxvblRleHR1cmU/LmdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4KCkpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbGlnaHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGlnaHQuX2JhYnlsb25UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52ZXJ0IHRoZSByb3RhdGlvbiBzbyB0aGF0IHBvc2l0aXZlIHJvdGF0aW9uIGlzIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaWdodC5fYmFieWxvblRleHR1cmUuZ2V0U2NlbmUoKT8udXNlUmlnaHRIYW5kZWRTeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFF1YXRlcm5pb24uSW52ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdHJpeC5Gcm9tUXVhdGVybmlvblRvUmVmKHZhbHVlLCBsaWdodC5fYmFieWxvblRleHR1cmUuZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFRhcmdldDogKGxpZ2h0KSA9PiBsaWdodC5fYmFieWxvblRleHR1cmUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIEdldFRleHR1cmUobWF0ZXJpYWw6IElNYXRlcmlhbCwgcGF5bG9hZDogYW55LCB0ZXh0dXJlVHlwZToga2V5b2YgUEJSTWF0ZXJpYWwsIHRleHR1cmVJbk9iamVjdD86IHN0cmluZykge1xuICAgIGNvbnN0IGJhYnlsb25NYXRlcmlhbCA9IEdldE1hdGVyaWFsKG1hdGVyaWFsLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gdGV4dHVyZUluT2JqZWN0ID8gYmFieWxvbk1hdGVyaWFsW3RleHR1cmVUeXBlXVt0ZXh0dXJlSW5PYmplY3RdIDogYmFieWxvbk1hdGVyaWFsW3RleHR1cmVUeXBlXTtcbn1cbmZ1bmN0aW9uIEdldE1hdGVyaWFsKG1hdGVyaWFsOiBJTWF0ZXJpYWwsIF9pbmRleD86IG51bWJlciwgcGF5bG9hZD86IGFueSkge1xuICAgIHJldHVybiBtYXRlcmlhbC5fZGF0YT8uW3BheWxvYWQ/LmZpbGxNb2RlID8/IENvbnN0YW50cy5NQVRFUklBTF9UcmlhbmdsZUZpbGxNb2RlXT8uYmFieWxvbk1hdGVyaWFsIGFzIFBCUk1hdGVyaWFsO1xufVxuZnVuY3Rpb24gR2VuZXJhdGVUZXh0dXJlTWFwKHRleHR1cmVUeXBlOiBrZXlvZiBQQlJNYXRlcmlhbCwgdGV4dHVyZUluT2JqZWN0Pzogc3RyaW5nKTogSVRleHR1cmVEZWZpbml0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNDb3VudDogMixcbiAgICAgICAgICAgIC8vIGFzc3VtaW5nIHR3byBpbmRlcGVuZGVudCB2YWx1ZXMgZm9yIHUgYW5kIHYsIGFuZCBOT1QgYSBWZWN0b3IyXG4gICAgICAgICAgICB0eXBlOiBcIlZlY3RvcjJcIixcbiAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBfaW5kZXg/LCBwYXlsb2FkPykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBHZXRUZXh0dXJlKG1hdGVyaWFsLCBwYXlsb2FkLCB0ZXh0dXJlVHlwZSwgdGV4dHVyZUluT2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGV4dHVyZT8udU9mZnNldCwgdGV4dHVyZT8udk9mZnNldCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VGFyZ2V0OiBHZXRNYXRlcmlhbCxcbiAgICAgICAgICAgIHNldDogKHZhbHVlLCBtYXRlcmlhbCwgX2luZGV4PywgcGF5bG9hZD8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gR2V0VGV4dHVyZShtYXRlcmlhbCwgcGF5bG9hZCwgdGV4dHVyZVR5cGUsIHRleHR1cmVJbk9iamVjdCk7XG4gICAgICAgICAgICAgICAgKHRleHR1cmUudU9mZnNldCA9IHZhbHVlLngpLCAodGV4dHVyZS52T2Zmc2V0ID0gdmFsdWUueSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UHJvcGVydHlOYW1lOiBbXG4gICAgICAgICAgICAgICAgKCkgPT4gYCR7dGV4dHVyZVR5cGV9JHt0ZXh0dXJlSW5PYmplY3QgPyBcIi5cIiArIHRleHR1cmVJbk9iamVjdCA6IFwiXCJ9LnVPZmZzZXRgLFxuICAgICAgICAgICAgICAgICgpID0+IGAke3RleHR1cmVUeXBlfSR7dGV4dHVyZUluT2JqZWN0ID8gXCIuXCIgKyB0ZXh0dXJlSW5PYmplY3QgOiBcIlwifS52T2Zmc2V0YCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZ2V0OiAobWF0ZXJpYWwsIF9pbmRleD8sIHBheWxvYWQ/KSA9PiBHZXRUZXh0dXJlKG1hdGVyaWFsLCBwYXlsb2FkLCB0ZXh0dXJlVHlwZSwgdGV4dHVyZUluT2JqZWN0KT8ud0FuZyxcbiAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIF9pbmRleD8sIHBheWxvYWQ/KSA9PiAoR2V0VGV4dHVyZShtYXRlcmlhbCwgcGF5bG9hZCwgdGV4dHVyZVR5cGUsIHRleHR1cmVJbk9iamVjdCkud0FuZyA9IHZhbHVlKSxcbiAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogWygpID0+IGAke3RleHR1cmVUeXBlfSR7dGV4dHVyZUluT2JqZWN0ID8gXCIuXCIgKyB0ZXh0dXJlSW5PYmplY3QgOiBcIlwifS53QW5nYF0sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICBjb21wb25lbnRzQ291bnQ6IDIsXG4gICAgICAgICAgICB0eXBlOiBcIlZlY3RvcjJcIixcbiAgICAgICAgICAgIGdldDogKG1hdGVyaWFsLCBfaW5kZXg/LCBwYXlsb2FkPykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBHZXRUZXh0dXJlKG1hdGVyaWFsLCBwYXlsb2FkLCB0ZXh0dXJlVHlwZSwgdGV4dHVyZUluT2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGV4dHVyZT8udVNjYWxlLCB0ZXh0dXJlPy52U2NhbGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRhcmdldDogR2V0TWF0ZXJpYWwsXG4gICAgICAgICAgICBzZXQ6ICh2YWx1ZSwgbWF0ZXJpYWwsIGluZGV4PywgcGF5bG9hZD8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gR2V0VGV4dHVyZShtYXRlcmlhbCwgcGF5bG9hZCwgdGV4dHVyZVR5cGUsIHRleHR1cmVJbk9iamVjdCk7XG4gICAgICAgICAgICAgICAgKHRleHR1cmUudVNjYWxlID0gdmFsdWUueCksICh0ZXh0dXJlLnZTY2FsZSA9IHZhbHVlLnkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFByb3BlcnR5TmFtZTogW1xuICAgICAgICAgICAgICAgICgpID0+IGAke3RleHR1cmVUeXBlfSR7dGV4dHVyZUluT2JqZWN0ID8gXCIuXCIgKyB0ZXh0dXJlSW5PYmplY3QgOiBcIlwifS51U2NhbGVgLFxuICAgICAgICAgICAgICAgICgpID0+IGAke3RleHR1cmVUeXBlfSR7dGV4dHVyZUluT2JqZWN0ID8gXCIuXCIgKyB0ZXh0dXJlSW5PYmplY3QgOiBcIlwifS52U2NhbGVgLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBvYmplY3RNb2RlbE1hcHBpbmc6IElHTFRGT2JqZWN0TW9kZWxUcmVlID0ge1xuICAgIGNhbWVyYXM6IGNhbWVyYXNUcmVlLFxuICAgIG5vZGVzOiBub2Rlc1RyZWUsXG4gICAgbWF0ZXJpYWxzOiBtYXRlcmlhbHNUcmVlLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNUcmVlLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnNUcmVlLFxuICAgIG1lc2hlczogbWVzaGVzVHJlZSxcbn07XG5cbi8qKlxuICogZ2V0IGEgcGF0aC10by1vYmplY3QgY29udmVydGVyIGZvciB0aGUgZ2l2ZW4gZ2xURiB0cmVlXG4gKiBAcGFyYW0gZ2x0ZiB0aGUgZ2xURiB0cmVlIHRvIHVzZVxuICogQHJldHVybnMgYSBwYXRoLXRvLW9iamVjdCBjb252ZXJ0ZXIgZm9yIHRoZSBnaXZlbiBnbFRGIHRyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdldFBhdGhUb09iamVjdENvbnZlcnRlcihnbHRmOiBJR0xURikge1xuICAgIHJldHVybiBuZXcgR0xURlBhdGhUb09iamVjdENvbnZlcnRlcihnbHRmLCBvYmplY3RNb2RlbE1hcHBpbmcpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIG9iamVjdCBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIGtleSBpbiB0aGUgb2JqZWN0IG1vZGVsXG4gKiBJZiB0aGUga2V5IGlzIG5vdCBmb3VuZCwgaXQgd2lsbCByZXR1cm4gdW5kZWZpbmVkXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gZ2V0IHRoZSBtYXBwaW5nIGZvciwgZm9yIGV4YW1wbGUgL21hdGVyaWFscy9cXHtcXH0vZW1pc3NpdmVGYWN0b3JcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRNYXBwaW5nRm9yS2V5KGtleTogc3RyaW5nKTogSU9iamVjdEFjY2Vzc29yIHwgdW5kZWZpbmVkIHtcbiAgICAvLyByZXBsYWNlIGV2ZXJ5IGB7fWAgaW4ga2V5IHdpdGggX19hcnJheV9fIHRvIG1hdGNoIHRoZSBvYmplY3QgbW9kZWxcbiAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdChcIi9cIikubWFwKChwYXJ0KSA9PiBwYXJ0LnJlcGxhY2UoL3t9L2csIFwiX19hcnJheV9fXCIpKTtcbiAgICBsZXQgY3VycmVudCA9IG9iamVjdE1vZGVsTWFwcGluZyBhcyBhbnk7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGtleVBhcnRzKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBwYXJ0IGlzIG5vdCBlbXB0eVxuICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSB0aGF0IGN1cnJlbnQgaXMgYW4gb2JqZWN0IGFjY2Vzc29yXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC50eXBlICYmIGN1cnJlbnQuZ2V0KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFNldCBpbnRlcnBvbGF0aW9uIGZvciBhIHNwZWNpZmljIGtleSBpbiB0aGUgb2JqZWN0IG1vZGVsXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gc2V0LCBmb3IgZXhhbXBsZSAvbWF0ZXJpYWxzL1xce1xcfS9lbWlzc2l2ZUZhY3RvclxuICogQHBhcmFtIGludGVycG9sYXRpb24gdGhlIGludGVycG9sYXRpb24gZWxlbWVudHMgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNldEludGVycG9sYXRpb25Gb3JLZXkoa2V5OiBzdHJpbmcsIGludGVycG9sYXRpb24/OiBJSW50ZXJwb2xhdGlvblByb3BlcnR5SW5mb1tdKTogdm9pZCB7XG4gICAgLy8gcmVwbGFjZSBldmVyeSBge31gIGluIGtleSB3aXRoIF9fYXJyYXlfXyB0byBtYXRjaCB0aGUgb2JqZWN0IG1vZGVsXG4gICAgY29uc3Qga2V5UGFydHMgPSBrZXkuc3BsaXQoXCIvXCIpLm1hcCgocGFydCkgPT4gcGFydC5yZXBsYWNlKC97fS9nLCBcIl9fYXJyYXlfX1wiKSk7XG4gICAgbGV0IGN1cnJlbnQgPSBvYmplY3RNb2RlbE1hcHBpbmcgYXMgYW55O1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBrZXlQYXJ0cykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcGFydCBpcyBub3QgZW1wdHlcbiAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgdGhhdCB0aGUgY3VycmVudCBvYmplY3QgaXMgYW4gb2JqZWN0IGFjY2Vzc29yXG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC50eXBlICYmIGN1cnJlbnQuZ2V0KSB7XG4gICAgICAgIChjdXJyZW50IGFzIElPYmplY3RBY2Nlc3NvcikuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgd2lsbCBhZCBhIG5ldyBvYmplY3QgYWNjZXNzb3IgaW4gdGhlIG9iamVjdCBtb2RlbCBhdCB0aGUgZ2l2ZW4ga2V5LlxuICogTm90ZSB0aGF0IHRoaXMgd2lsbCBOT1QgY2hhbmdlIHRoZSB0eXBlc2NyaXB0IHR5cGVzLiBUbyBkbyB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY2hhbmdlIHRoZSBpbnRlcmZhY2UgaXRzZWxmIChleHRlbmRpbmcgaXQgaW4gdGhlIG1vZHVsZSB0aGF0IHVzZXMgaXQpXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gYWRkIHRoZSBvYmplY3QgYWNjZXNzb3IgYXQuIEZvciBleGFtcGxlIC9jYW1lcmFzL1xce1xcfS9wZXJzcGVjdGl2ZS9hc3BlY3RSYXRpb1xuICogQHBhcmFtIGFjY2Vzc29yIHRoZSBvYmplY3QgYWNjZXNzb3IgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBZGRPYmplY3RBY2Nlc3NvclRvS2V5PEdMVEZUYXJnZXRUeXBlID0gYW55LCBCYWJ5bG9uVGFyZ2V0VHlwZSA9IGFueSwgQmFieWxvblZhbHVlVHlwZSA9IGFueT4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgYWNjZXNzb3I6IElPYmplY3RBY2Nlc3NvcjxHTFRGVGFyZ2V0VHlwZSwgQmFieWxvblRhcmdldFR5cGUsIEJhYnlsb25WYWx1ZVR5cGU+XG4pOiB2b2lkIHtcbiAgICAvLyByZXBsYWNlIGV2ZXJ5IGB7fWAgaW4ga2V5IHdpdGggX19hcnJheV9fIHRvIG1hdGNoIHRoZSBvYmplY3QgbW9kZWxcbiAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdChcIi9cIikubWFwKChwYXJ0KSA9PiBwYXJ0LnJlcGxhY2UoL3t9L2csIFwiX19hcnJheV9fXCIpKTtcbiAgICBsZXQgY3VycmVudCA9IG9iamVjdE1vZGVsTWFwcGluZyBhcyBhbnk7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGtleVBhcnRzKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBwYXJ0IGlzIG5vdCBlbXB0eVxuICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudFtwYXJ0XSkge1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5fX2lnbm9yZU9iamVjdFRyZWVfXyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50W3BhcnRdID0ge307XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFydCBpcyBfX2FycmF5X18gdGhlbiBhZGQgdGhlIF9fdGFyZ2V0X18gcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSBcIl9fYXJyYXlfX1wiKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtwYXJ0XS5fX3RhcmdldF9fID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihjdXJyZW50LCBhY2Nlc3Nvcik7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBnaXRodWIvbm8tdGhlbiAqL1xyXG5pbXBvcnQgdHlwZSB7IEluZGljZXNBcnJheSwgTnVsbGFibGUsIFR5cGVkQXJyYXksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB7IERlZmVycmVkIH0gZnJvbSBcImNvcmUvTWlzYy9kZWZlcnJlZFwiO1xyXG5pbXBvcnQgeyBRdWF0ZXJuaW9uLCBWZWN0b3IzLCBNYXRyaXgsIFRtcFZlY3RvcnMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLmNvbG9yXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiY29yZS9DYW1lcmFzL2NhbWVyYVwiO1xyXG5pbXBvcnQgeyBGcmVlQ2FtZXJhIH0gZnJvbSBcImNvcmUvQ2FtZXJhcy9mcmVlQ2FtZXJhXCI7XHJcbmltcG9ydCB0eXBlIHsgQW5pbWF0aW9uIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRpb25cIjtcclxuaW1wb3J0IHR5cGUgeyBJQW5pbWF0YWJsZSB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0YWJsZS5pbnRlcmZhY2VcIjtcclxuaW1wb3J0IHR5cGUgeyBJQW5pbWF0aW9uS2V5IH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRpb25LZXlcIjtcclxuaW1wb3J0IHsgQW5pbWF0aW9uS2V5SW50ZXJwb2xhdGlvbiB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0aW9uS2V5XCI7XHJcbmltcG9ydCB0eXBlIHsgQW5pbWF0aW9uR3JvdXAgfSBmcm9tIFwiY29yZS9BbmltYXRpb25zL2FuaW1hdGlvbkdyb3VwXCI7XHJcbmltcG9ydCB7IEJvbmUgfSBmcm9tIFwiY29yZS9Cb25lcy9ib25lXCI7XHJcbmltcG9ydCB7IFNrZWxldG9uIH0gZnJvbSBcImNvcmUvQm9uZXMvc2tlbGV0b25cIjtcclxuaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuaW1wb3J0IHsgUEJSTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvUEJSL3Bick1hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJVGV4dHVyZUNyZWF0aW9uT3B0aW9ucyB9IGZyb20gXCJjb3JlL01hdGVyaWFscy9UZXh0dXJlcy90ZXh0dXJlXCI7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZVwiO1xyXG5pbXBvcnQgeyBUcmFuc2Zvcm1Ob2RlIH0gZnJvbSBcImNvcmUvTWVzaGVzL3RyYW5zZm9ybU5vZGVcIjtcclxuaW1wb3J0IHsgQnVmZmVyLCBWZXJ0ZXhCdWZmZXIgfSBmcm9tIFwiY29yZS9CdWZmZXJzL2J1ZmZlclwiO1xyXG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCJjb3JlL01lc2hlcy9nZW9tZXRyeVwiO1xyXG5pbXBvcnQgeyBBYnN0cmFjdE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvYWJzdHJhY3RNZXNoXCI7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvbWVzaFwiO1xyXG5pbXBvcnQgeyBNb3JwaFRhcmdldCB9IGZyb20gXCJjb3JlL01vcnBoL21vcnBoVGFyZ2V0XCI7XHJcbmltcG9ydCB7IE1vcnBoVGFyZ2V0TWFuYWdlciB9IGZyb20gXCJjb3JlL01vcnBoL21vcnBoVGFyZ2V0TWFuYWdlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElTY2VuZUxvYWRlckFzeW5jUmVzdWx0LCBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50IH0gZnJvbSBcImNvcmUvTG9hZGluZy9zY2VuZUxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IFNjZW5lIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuaW1wb3J0IHR5cGUgeyBJUHJvcGVydHkgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBBbmltYXRpb25DaGFubmVsVGFyZ2V0UGF0aCxcclxuICAgIEFuaW1hdGlvblNhbXBsZXJJbnRlcnBvbGF0aW9uLFxyXG4gICAgQWNjZXNzb3JUeXBlLFxyXG4gICAgQ2FtZXJhVHlwZSxcclxuICAgIEFjY2Vzc29yQ29tcG9uZW50VHlwZSxcclxuICAgIE1hdGVyaWFsQWxwaGFNb2RlLFxyXG4gICAgVGV4dHVyZU1pbkZpbHRlcixcclxuICAgIFRleHR1cmVXcmFwTW9kZSxcclxuICAgIFRleHR1cmVNYWdGaWx0ZXIsXHJcbiAgICBNZXNoUHJpbWl0aXZlTW9kZSxcclxufSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB0eXBlIHtcclxuICAgIElHTFRGLFxyXG4gICAgSVNhbXBsZXIsXHJcbiAgICBJTm9kZSxcclxuICAgIElTY2VuZSxcclxuICAgIElNZXNoLFxyXG4gICAgSUFjY2Vzc29yLFxyXG4gICAgSVNraW4sXHJcbiAgICBJQ2FtZXJhLFxyXG4gICAgSUFuaW1hdGlvbixcclxuICAgIElCdWZmZXIsXHJcbiAgICBJQnVmZmVyVmlldyxcclxuICAgIElNYXRlcmlhbFBick1ldGFsbGljUm91Z2huZXNzLFxyXG4gICAgSU1hdGVyaWFsLFxyXG4gICAgSVRleHR1cmVJbmZvLFxyXG4gICAgSVRleHR1cmUsXHJcbiAgICBJSW1hZ2UsXHJcbiAgICBJTWVzaFByaW1pdGl2ZSxcclxuICAgIElBcnJheUl0ZW0sXHJcbiAgICBfSVNhbXBsZXJEYXRhLFxyXG4gICAgSUFuaW1hdGlvbkNoYW5uZWwsXHJcbiAgICBJQW5pbWF0aW9uU2FtcGxlcixcclxuICAgIF9JQW5pbWF0aW9uU2FtcGxlckRhdGEsXHJcbn0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlciwgSUdMVEZMb2FkZXJEYXRhIH0gZnJvbSBcIi4uL2dsVEZGaWxlTG9hZGVyXCI7XHJcbmltcG9ydCB7IEdMVEZGaWxlTG9hZGVyLCBHTFRGTG9hZGVyU3RhdGUsIEdMVEZMb2FkZXJDb29yZGluYXRlU3lzdGVtTW9kZSwgR0xURkxvYWRlckFuaW1hdGlvblN0YXJ0TW9kZSB9IGZyb20gXCIuLi9nbFRGRmlsZUxvYWRlclwiO1xyXG5pbXBvcnQgdHlwZSB7IElEYXRhQnVmZmVyIH0gZnJvbSBcImNvcmUvTWlzYy9kYXRhUmVhZGVyXCI7XHJcbmltcG9ydCB7IERlY29kZUJhc2U2NFVybFRvQmluYXJ5LCBHZXRNaW1lVHlwZSwgSXNCYXNlNjREYXRhVXJsLCBMb2FkRmlsZUVycm9yIH0gZnJvbSBcImNvcmUvTWlzYy9maWxlVG9vbHNcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNvcmUvTWlzYy9sb2dnZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBMaWdodCB9IGZyb20gXCJjb3JlL0xpZ2h0cy9saWdodFwiO1xyXG5pbXBvcnQgeyBCb3VuZGluZ0luZm8gfSBmcm9tIFwiY29yZS9DdWxsaW5nL2JvdW5kaW5nSW5mb1wiO1xyXG5pbXBvcnQgdHlwZSB7IEFzc2V0Q29udGFpbmVyIH0gZnJvbSBcImNvcmUvYXNzZXRDb250YWluZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBBbmltYXRpb25Qcm9wZXJ0eUluZm8gfSBmcm9tIFwiLi9nbFRGTG9hZGVyQW5pbWF0aW9uXCI7XHJcbmltcG9ydCB0eXBlIHsgSU9iamVjdEluZm8gfSBmcm9tIFwiY29yZS9PYmplY3RNb2RlbC9vYmplY3RNb2RlbEludGVyZmFjZXNcIjtcclxuaW1wb3J0IHsgcmVnaXN0ZXJlZEdMVEZFeHRlbnNpb25zLCByZWdpc3RlckdMVEZFeHRlbnNpb24sIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uIH0gZnJvbSBcIi4vZ2xURkxvYWRlckV4dGVuc2lvblJlZ2lzdHJ5XCI7XHJcbmltcG9ydCB0eXBlIHsgR0xURkV4dGVuc2lvbkZhY3RvcnkgfSBmcm9tIFwiLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuaW1wb3J0IHR5cGUgeyBJSW50ZXJwb2xhdGlvblByb3BlcnR5SW5mbyB9IGZyb20gXCJjb3JlL0Zsb3dHcmFwaC90eXBlRGVmaW5pdGlvbnNcIjtcclxuaW1wb3J0IHsgR2V0TWFwcGluZ0ZvcktleSB9IGZyb20gXCIuL0V4dGVuc2lvbnMvb2JqZWN0TW9kZWxNYXBwaW5nXCI7XHJcbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gXCJjb3JlL01pc2MvZGVlcE1lcmdlclwiO1xyXG5pbXBvcnQgeyBHZXRUeXBlZEFycmF5Q29uc3RydWN0b3IgfSBmcm9tIFwiY29yZS9CdWZmZXJzL2J1ZmZlclV0aWxzXCI7XHJcblxyXG5leHBvcnQgeyBHTFRGRmlsZUxvYWRlciB9O1xyXG5cclxuaW50ZXJmYWNlIElMb2FkZXJQcm9wZXJ0eSBleHRlbmRzIElQcm9wZXJ0eSB7XHJcbiAgICBfYWN0aXZlTG9hZGVyRXh0ZW5zaW9uRnVuY3Rpb25zOiB7XHJcbiAgICAgICAgW2lkOiBzdHJpbmddOiBib29sZWFuO1xyXG4gICAgfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIElXaXRoTWV0YWRhdGEge1xyXG4gICAgbWV0YWRhdGE6IGFueTtcclxuICAgIF9pbnRlcm5hbE1ldGFkYXRhOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBhcnJheXMgd2hlbiBsb2FkaW5nIHRoZSBnbFRGIGFzc2V0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXJyYXlJdGVtIHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBnZXQgdGhlIGl0ZW0gZnJvbVxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB0byB0aGUgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSBpdGVtXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR2V0PFQ+KGNvbnRleHQ6IHN0cmluZywgYXJyYXk6IEFycmF5TGlrZTxUPiB8IHVuZGVmaW5lZCwgaW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCk6IFQge1xyXG4gICAgICAgIGlmICghYXJyYXkgfHwgaW5kZXggPT0gdW5kZWZpbmVkIHx8ICFhcnJheVtpbmRleF0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBGYWlsZWQgdG8gZmluZCBpbmRleCAoJHtpbmRleH0pYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIGdpdmVuIGFycmF5IG9yIHJldHVybnMgbnVsbCBpZiBub3QgYXZhaWxhYmxlLlxyXG4gICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBnZXQgdGhlIGl0ZW0gZnJvbVxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB0byB0aGUgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSBpdGVtIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcnlHZXQ8VD4oYXJyYXk6IEFycmF5TGlrZTxUPiB8IHVuZGVmaW5lZCwgaW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCk6IE51bGxhYmxlPFQ+IHtcclxuICAgICAgICBpZiAoIWFycmF5IHx8IGluZGV4ID09IHVuZGVmaW5lZCB8fCAhYXJyYXlbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc2lnbiBhbiBgaW5kZXhgIGZpZWxkIHRvIGVhY2ggaXRlbSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IG9mIGl0ZW1zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQXNzaWduKGFycmF5PzogSUFycmF5SXRlbVtdKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGFycmF5KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2luZGV4XS5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFuaW1hdGlvblRhcmdldEluZm8ge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgdGFyZ2V0OiB1bmtub3duO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHByb3BlcnRpZXM6IEFycmF5PEFuaW1hdGlvblByb3BlcnR5SW5mbz47XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExvYWRCb3VuZGluZ0luZm9Gcm9tUG9zaXRpb25BY2Nlc3NvcihhY2Nlc3NvcjogSUFjY2Vzc29yKTogTnVsbGFibGU8Qm91bmRpbmdJbmZvPiB7XHJcbiAgICBpZiAoYWNjZXNzb3IubWluICYmIGFjY2Vzc29yLm1heCkge1xyXG4gICAgICAgIGNvbnN0IG1pbkFycmF5ID0gYWNjZXNzb3IubWluIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICAgICAgICBjb25zdCBtYXhBcnJheSA9IGFjY2Vzc29yLm1heCBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgICAgICAgY29uc3QgbWluVmVjdG9yID0gVG1wVmVjdG9ycy5WZWN0b3IzWzBdLmNvcHlGcm9tRmxvYXRzKG1pbkFycmF5WzBdLCBtaW5BcnJheVsxXSwgbWluQXJyYXlbMl0pO1xyXG4gICAgICAgIGNvbnN0IG1heFZlY3RvciA9IFRtcFZlY3RvcnMuVmVjdG9yM1sxXS5jb3B5RnJvbUZsb2F0cyhtYXhBcnJheVswXSwgbWF4QXJyYXlbMV0sIG1heEFycmF5WzJdKTtcclxuICAgICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCAmJiBhY2Nlc3Nvci5jb21wb25lbnRUeXBlICE9PSBBY2Nlc3NvckNvbXBvbmVudFR5cGUuRkxPQVQpIHtcclxuICAgICAgICAgICAgbGV0IGRpdmlkZXIgPSAxO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWNjZXNzb3JDb21wb25lbnRUeXBlLkJZVEU6XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDEyNy4wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBY2Nlc3NvckNvbXBvbmVudFR5cGUuVU5TSUdORURfQllURTpcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMjU1LjA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFjY2Vzc29yQ29tcG9uZW50VHlwZS5TSE9SVDpcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMzI3NjcuMDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWNjZXNzb3JDb21wb25lbnRUeXBlLlVOU0lHTkVEX1NIT1JUOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSA2NTUzNS4wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uZU92ZXJEaXZpZGVyID0gMSAvIGRpdmlkZXI7XHJcbiAgICAgICAgICAgIG1pblZlY3Rvci5zY2FsZUluUGxhY2Uob25lT3ZlckRpdmlkZXIpO1xyXG4gICAgICAgICAgICBtYXhWZWN0b3Iuc2NhbGVJblBsYWNlKG9uZU92ZXJEaXZpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0luZm8obWluVmVjdG9yLCBtYXhWZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZ2xURiAyLjAgbG9hZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR0xURkxvYWRlciBpbXBsZW1lbnRzIElHTFRGTG9hZGVyIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBfY29tcGxldGVQcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBfYXNzZXRDb250YWluZXI6IE51bGxhYmxlPEFzc2V0Q29udGFpbmVyPiA9IG51bGw7XHJcblxyXG4gICAgLyoqIFN0b3JhZ2UgKi9cclxuICAgIHB1YmxpYyBfYmFieWxvbkxpZ2h0czogTGlnaHRbXSA9IFtdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBfZGlzYWJsZUluc3RhbmNlZE1lc2ggPSAwO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBfYWxsTWF0ZXJpYWxzRGlydHlSZXF1aXJlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBfc2tpcFN0YXJ0QW5pbWF0aW9uU3RlcCA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3BhcmVudDogR0xURkZpbGVMb2FkZXI7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9leHRlbnNpb25zID0gbmV3IEFycmF5PElHTFRGTG9hZGVyRXh0ZW5zaW9uPigpO1xyXG4gICAgcHJpdmF0ZSBfZGlzcG9zZWQgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3Jvb3RVcmw6IE51bGxhYmxlPHN0cmluZz4gPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfZmlsZU5hbWU6IE51bGxhYmxlPHN0cmluZz4gPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfdW5pcXVlUm9vdFVybDogTnVsbGFibGU8c3RyaW5nPiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9nbHRmOiBJR0xURjtcclxuICAgIHByaXZhdGUgX2JpbjogTnVsbGFibGU8SURhdGFCdWZmZXI+ID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2JhYnlsb25TY2VuZTogU2NlbmU7XHJcbiAgICBwcml2YXRlIF9yb290QmFieWxvbk1lc2g6IE51bGxhYmxlPFRyYW5zZm9ybU5vZGU+ID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2RlZmF1bHRCYWJ5bG9uTWF0ZXJpYWxEYXRhOiB7IFtkcmF3TW9kZTogbnVtYmVyXTogTWF0ZXJpYWwgfSA9IHt9O1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfcG9zdFNjZW5lTG9hZEFjdGlvbnMgPSBuZXcgQXJyYXk8KCkgPT4gdm9pZD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IGdsVEYgc2FtcGxlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEZWZhdWx0U2FtcGxlcjogSVNhbXBsZXIgPSB7IGluZGV4OiAtMSB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbG9hZGVyIGV4dGVuc2lvbi5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsb2FkZXIgZXh0ZW5zaW9uLlxyXG4gICAgICogQHBhcmFtIGZhY3RvcnkgVGhlIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBsb2FkZXIgZXh0ZW5zaW9uLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSByZWdpc3RlckdMVEZFeHRlbnNpb24gaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSZWdpc3RlckV4dGVuc2lvbihuYW1lOiBzdHJpbmcsIGZhY3Rvcnk6IEdMVEZFeHRlbnNpb25GYWN0b3J5KTogdm9pZCB7XHJcbiAgICAgICAgcmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKG5hbWUsIGZhbHNlLCBmYWN0b3J5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVucmVnaXN0ZXJzIGEgbG9hZGVyIGV4dGVuc2lvbi5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsb2FkZXIgZXh0ZW5zaW9uLlxyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZXh0ZW5zaW9uIGhhcyBiZWVuIHVucmVnaXN0ZXJlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSB1bnJlZ2lzdGVyR0xURkV4dGVuc2lvbiBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFVucmVnaXN0ZXJFeHRlbnNpb24obmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGdsVEYgSlNPTi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBnbHRmKCk6IElHTFRGIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2dsdGYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2xURiBKU09OIGlzIG5vdCBhdmFpbGFibGVcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2x0ZjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBCSU4gY2h1bmsgb2YgYSBiaW5hcnkgZ2xURi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBiaW4oKTogTnVsbGFibGU8SURhdGFCdWZmZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmluO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcmVudCBmaWxlIGxvYWRlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwYXJlbnQoKTogR0xURkZpbGVMb2FkZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgQmFieWxvbiBzY2VuZSB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJhYnlsb25TY2VuZSgpOiBTY2VuZSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9iYWJ5bG9uU2NlbmUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NlbmUgaXMgbm90IGF2YWlsYWJsZVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9iYWJ5bG9uU2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm9vdCBCYWJ5bG9uIG5vZGUgd2hlbiBsb2FkaW5nIHRoZSBhc3NldC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByb290QmFieWxvbk1lc2goKTogTnVsbGFibGU8VHJhbnNmb3JtTm9kZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290QmFieWxvbk1lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm9vdCB1cmwgd2hlbiBsb2FkaW5nIHRoZSBhc3NldC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByb290VXJsKCk6IE51bGxhYmxlPHN0cmluZz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290VXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogR0xURkZpbGVMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29tcGxldGVQcm9taXNlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl9leHRlbnNpb25zLmZvckVhY2goKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLmRpc3Bvc2UgJiYgZXh0ZW5zaW9uLmRpc3Bvc2UoKSk7XHJcbiAgICAgICAgdGhpcy5fZXh0ZW5zaW9ucy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAodGhpcy5fZ2x0ZiBhcyBOdWxsYWJsZTxJR0xURj4pID0gbnVsbDsgLy8gVE9ET1xyXG4gICAgICAgIHRoaXMuX2JpbiA9IG51bGw7XHJcbiAgICAgICAgKHRoaXMuX2JhYnlsb25TY2VuZSBhcyBOdWxsYWJsZTxTY2VuZT4pID0gbnVsbDsgLy8gVE9ET1xyXG4gICAgICAgIHRoaXMuX3Jvb3RCYWJ5bG9uTWVzaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdEJhYnlsb25NYXRlcmlhbERhdGEgPSB7fTtcclxuICAgICAgICB0aGlzLl9wb3N0U2NlbmVMb2FkQWN0aW9ucy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl9wYXJlbnQuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbXBvcnRNZXNoQXN5bmMoXHJcbiAgICAgICAgbWVzaGVzTmFtZXM6IHN0cmluZyB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgY29udGFpbmVyOiBOdWxsYWJsZTxBc3NldENvbnRhaW5lcj4sXHJcbiAgICAgICAgZGF0YTogSUdMVEZMb2FkZXJEYXRhLFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBvblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLFxyXG4gICAgICAgIGZpbGVOYW1lID0gXCJcIlxyXG4gICAgKTogUHJvbWlzZTxJU2NlbmVMb2FkZXJBc3luY1Jlc3VsdD4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnaXRodWIvbm8tdGhlblxyXG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fzc2V0Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkRGF0YShkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBub2RlczogTnVsbGFibGU8QXJyYXk8bnVtYmVyPj4gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1lc2hlc05hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlTWFwOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dsdGYubm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fZ2x0Zi5ub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlTWFwW25vZGUubmFtZV0gPSBub2RlLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gbWVzaGVzTmFtZXMgaW5zdGFuY2VvZiBBcnJheSA/IG1lc2hlc05hbWVzIDogW21lc2hlc05hbWVzXTtcclxuICAgICAgICAgICAgICAgIG5vZGVzID0gbmFtZXMubWFwKChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXBbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIG5vZGUgJyR7bmFtZX0nYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZEFzeW5jKHJvb3RVcmwsIGZpbGVOYW1lLCBub2RlcywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNoZXM6IHRoaXMuX2dldE1lc2hlcygpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlU3lzdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25zOiB0aGlzLl9nZXRTa2VsZXRvbnMoKSxcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Hcm91cHM6IHRoaXMuX2dldEFuaW1hdGlvbkdyb3VwcygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0czogdGhpcy5fYmFieWxvbkxpZ2h0cyxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Ob2RlczogdGhpcy5fZ2V0VHJhbnNmb3JtTm9kZXMoKSxcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyaWVzOiB0aGlzLl9nZXRHZW9tZXRyaWVzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlTWFuYWdlcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWRBc3luYyhzY2VuZTogU2NlbmUsIGRhdGE6IElHTFRGTG9hZGVyRGF0YSwgcm9vdFVybDogc3RyaW5nLCBvblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLCBmaWxlTmFtZSA9IFwiXCIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLl9sb2FkRGF0YShkYXRhKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZEFzeW5jKHJvb3RVcmwsIGZpbGVOYW1lLCBudWxsLCAoKSA9PiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX2xvYWRBc3luYzxUPihyb290VXJsOiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcsIG5vZGVzOiBOdWxsYWJsZTxBcnJheTxudW1iZXI+PiwgcmVzdWx0RnVuYzogKCkgPT4gVCk6IFByb21pc2U8VD4ge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290VXJsID0gcm9vdFVybDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXF1ZVJvb3RVcmwgPSAhcm9vdFVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikgJiYgZmlsZU5hbWUgPyByb290VXJsIDogYCR7cm9vdFVybH0ke0RhdGUubm93KCl9L2A7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlTmFtZSA9IGZpbGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsTWF0ZXJpYWxzRGlydHlSZXF1aXJlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2xvYWRFeHRlbnNpb25zQXN5bmMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nVG9SZWFkeUNvdW50ZXJOYW1lID0gYCR7R0xURkxvYWRlclN0YXRlW0dMVEZMb2FkZXJTdGF0ZS5MT0FESU5HXX0gPT4gJHtHTFRGTG9hZGVyU3RhdGVbR0xURkxvYWRlclN0YXRlLlJFQURZXX1gO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGluZ1RvQ29tcGxldGVDb3VudGVyTmFtZSA9IGAke0dMVEZMb2FkZXJTdGF0ZVtHTFRGTG9hZGVyU3RhdGUuTE9BRElOR119ID0+ICR7R0xURkxvYWRlclN0YXRlW0dMVEZMb2FkZXJTdGF0ZS5DT01QTEVURV19YDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3N0YXJ0UGVyZm9ybWFuY2VDb3VudGVyKGxvYWRpbmdUb1JlYWR5Q291bnRlck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll9zdGFydFBlcmZvcm1hbmNlQ291bnRlcihsb2FkaW5nVG9Db21wbGV0ZUNvdW50ZXJOYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3NldFN0YXRlKEdMVEZMb2FkZXJTdGF0ZS5MT0FESU5HKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVuc2lvbnNPbkxvYWRpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJsb2NrIHRoZSBtYXJraW5nIG9mIG1hdGVyaWFscyBkaXJ0eSB1bnRpbCB0aGUgc2NlbmUgaXMgbG9hZGVkLlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQmxvY2tNYXRlcmlhbERpcnR5TWVjaGFuaXNtID0gdGhpcy5fYmFieWxvblNjZW5lLmJsb2NrTWF0ZXJpYWxEaXJ0eU1lY2hhbmlzbTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5ibG9ja01hdGVyaWFsRGlydHlNZWNoYW5pc20gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQubG9hZE9ubHlNYXRlcmlhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmxvYWRTY2VuZUFzeW5jKFwiL25vZGVzXCIsIHsgbm9kZXM6IG5vZGVzLCBpbmRleDogLTEgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZ2x0Zi5zY2VuZSAhPSB1bmRlZmluZWQgfHwgKHRoaXMuX2dsdGYuc2NlbmVzICYmIHRoaXMuX2dsdGYuc2NlbmVzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2VuZSA9IEFycmF5SXRlbS5HZXQoYC9zY2VuZWAsIHRoaXMuX2dsdGYuc2NlbmVzLCB0aGlzLl9nbHRmLnNjZW5lIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMubG9hZFNjZW5lQXN5bmMoYC9zY2VuZXMvJHtzY2VuZS5pbmRleH1gLCBzY2VuZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50LnNraXBNYXRlcmlhbHMgJiYgdGhpcy5wYXJlbnQubG9hZEFsbE1hdGVyaWFscyAmJiB0aGlzLl9nbHRmLm1hdGVyaWFscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy5fZ2x0Zi5tYXRlcmlhbHMubGVuZ3RoOyArK20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLl9nbHRmLm1hdGVyaWFsc1ttXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IFwiL21hdGVyaWFscy9cIiArIG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhYnlsb25EcmF3TW9kZSA9IE1hdGVyaWFsLlRyaWFuZ2xlRmlsbE1vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRNYXRlcmlhbEFzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBudWxsLCBiYWJ5bG9uRHJhd01vZGUsICgpID0+IHt9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGJsb2NraW5nIG9mIG1hdGVyaWFsIGRpcnR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FsbE1hdGVyaWFsc0RpcnR5UmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UgYWRkIGEgbGlnaHQgZm9yIGluc3RhbmNlIGFzIGl0IHdpbGwgaW1wYWN0IHRoZSB3aG9sZSBzY2VuZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGF1dG9tYXRpY2FsbHkgcmVzZXRzIGV2ZXJ5dGhpbmcgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5ibG9ja01hdGVyaWFsRGlydHlNZWNoYW5pc20gPSBvbGRCbG9ja01hdGVyaWFsRGlydHlNZWNoYW5pc207XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQgYSBuZXdseSBjcmVhdGVkIG1hdGVyaWFsIGlzIGRpcnR5IHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gZmxhZyB0aGUgZnVsbCBzY2VuZSBhcyBkaXJ0eS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgcGVyZiByZWFzb25zLCB3ZSB0aGVuIGJ5cGFzcyBibG9ja01hdGVyaWFsRGlydHlNZWNoYW5pc20gYXMgdGhpcyB3b3VsZCBcImRpcnR5XCIgdGhlIGVudGlyZSBzY2VuZS5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2ZvcmNlQmxvY2tNYXRlcmlhbERpcnR5TWVjaGFuaXNtKG9sZEJsb2NrTWF0ZXJpYWxEaXJ0eU1lY2hhbmlzbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5jb21waWxlTWF0ZXJpYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9jb21waWxlTWF0ZXJpYWxzQXN5bmMoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5jb21waWxlU2hhZG93R2VuZXJhdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fY29tcGlsZVNoYWRvd0dlbmVyYXRvcnNBc3luYygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb290QmFieWxvbk1lc2ggJiYgdGhpcy5fcm9vdEJhYnlsb25NZXNoICE9PSB0aGlzLl9wYXJlbnQuY3VzdG9tUm9vdE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdEJhYnlsb25NZXNoLnNldEVuYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtpbmcgc3VyZSB3ZSBlbmFibGUgZW5vdWdoIGxpZ2h0cyB0byBoYXZlIGFsbCBsaWdodHMgdG9nZXRoZXJcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGVyaWFsIG9mIHRoaXMuX2JhYnlsb25TY2VuZS5tYXRlcmlhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ID0gbWF0ZXJpYWwgYXMgYW55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdC5tYXhTaW11bHRhbmVvdXNMaWdodHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Lm1heFNpbXVsdGFuZW91c0xpZ2h0cyA9IE1hdGgubWF4KG1hdC5tYXhTaW11bHRhbmVvdXNMaWdodHMsIHRoaXMuX2JhYnlsb25TY2VuZS5saWdodHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXh0ZW5zaW9uc09uUmVhZHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3NldFN0YXRlKEdMVEZMb2FkZXJTdGF0ZS5SRUFEWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9za2lwU3RhcnRBbmltYXRpb25TdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fZW5kUGVyZm9ybWFuY2VDb3VudGVyKGxvYWRpbmdUb1JlYWR5Q291bnRlck5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBUb29scy5TZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbCh0aGlzLl9jb21wbGV0ZVByb21pc2VzKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll9lbmRQZXJmb3JtYW5jZUNvdW50ZXIobG9hZGluZ1RvQ29tcGxldGVDb3VudGVyTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3NldFN0YXRlKEdMVEZMb2FkZXJTdGF0ZS5DT01QTEVURSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQub25Db21wbGV0ZU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5vbkNvbXBsZXRlT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm9uRXJyb3JPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5vbkVycm9yT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQub25FcnJvck9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQub25FcnJvck9ic2VydmFibGUuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWREYXRhKGRhdGE6IElHTFRGTG9hZGVyRGF0YSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2dsdGYgPSBkYXRhLmpzb24gYXMgSUdMVEY7XHJcbiAgICAgICAgdGhpcy5fc2V0dXBEYXRhKCk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhLmJpbikge1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5fZ2x0Zi5idWZmZXJzO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVycyAmJiBidWZmZXJzWzBdICYmICFidWZmZXJzWzBdLnVyaSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5QnVmZmVyID0gYnVmZmVyc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChiaW5hcnlCdWZmZXIuYnl0ZUxlbmd0aCA8IGRhdGEuYmluLmJ5dGVMZW5ndGggLSAzIHx8IGJpbmFyeUJ1ZmZlci5ieXRlTGVuZ3RoID4gZGF0YS5iaW4uYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKGBCaW5hcnkgYnVmZmVyIGxlbmd0aCAoJHtiaW5hcnlCdWZmZXIuYnl0ZUxlbmd0aH0pIGZyb20gSlNPTiBkb2VzIG5vdCBtYXRjaCBjaHVuayBsZW5ndGggKCR7ZGF0YS5iaW4uYnl0ZUxlbmd0aH0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmluID0gZGF0YS5iaW47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihcIlVuZXhwZWN0ZWQgQklOIGNodW5rXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3NldHVwRGF0YSgpOiB2b2lkIHtcclxuICAgICAgICBBcnJheUl0ZW0uQXNzaWduKHRoaXMuX2dsdGYuYWNjZXNzb3JzKTtcclxuICAgICAgICBBcnJheUl0ZW0uQXNzaWduKHRoaXMuX2dsdGYuYW5pbWF0aW9ucyk7XHJcbiAgICAgICAgQXJyYXlJdGVtLkFzc2lnbih0aGlzLl9nbHRmLmJ1ZmZlcnMpO1xyXG4gICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fZ2x0Zi5idWZmZXJWaWV3cyk7XHJcbiAgICAgICAgQXJyYXlJdGVtLkFzc2lnbih0aGlzLl9nbHRmLmNhbWVyYXMpO1xyXG4gICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fZ2x0Zi5pbWFnZXMpO1xyXG4gICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fZ2x0Zi5tYXRlcmlhbHMpO1xyXG4gICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fZ2x0Zi5tZXNoZXMpO1xyXG4gICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fZ2x0Zi5ub2Rlcyk7XHJcbiAgICAgICAgQXJyYXlJdGVtLkFzc2lnbih0aGlzLl9nbHRmLnNhbXBsZXJzKTtcclxuICAgICAgICBBcnJheUl0ZW0uQXNzaWduKHRoaXMuX2dsdGYuc2NlbmVzKTtcclxuICAgICAgICBBcnJheUl0ZW0uQXNzaWduKHRoaXMuX2dsdGYuc2tpbnMpO1xyXG4gICAgICAgIEFycmF5SXRlbS5Bc3NpZ24odGhpcy5fZ2x0Zi50ZXh0dXJlcyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9nbHRmLm5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVQYXJlbnRzOiB7IFtpbmRleDogbnVtYmVyXTogbnVtYmVyIH0gPSB7fTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX2dsdGYubm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQYXJlbnRzW2luZGV4XSA9IG5vZGUuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX2NyZWF0ZVJvb3ROb2RlKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLl9nbHRmLm5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJbmRleCA9IG5vZGVQYXJlbnRzW25vZGUuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnRJbmRleCA9PT0gdW5kZWZpbmVkID8gcm9vdE5vZGUgOiB0aGlzLl9nbHRmLm5vZGVzW3BhcmVudEluZGV4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIF9sb2FkRXh0ZW5zaW9uc0FzeW5jKCkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvblByb21pc2VzOiBQcm9taXNlPElHTFRGTG9hZGVyRXh0ZW5zaW9uPltdID0gW107XHJcblxyXG4gICAgICAgIHJlZ2lzdGVyZWRHTFRGRXh0ZW5zaW9ucy5mb3JFYWNoKChyZWdpc3RlcmVkRXh0ZW5zaW9uLCBuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGxvYWQgZXhwbGljaXRseSBkaXNhYmxlZCBleHRlbnNpb25zLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuZXh0ZW5zaW9uT3B0aW9uc1tuYW1lXT8uZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3YXJuIGlmIHRoZSBkaXNhYmxlZCBleHRlbnNpb24gaXMgdXNlZCBieSB0aGUgbW9kZWwuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0ZXJlZEV4dGVuc2lvbi5pc0dMVEZFeHRlbnNpb24gJiYgdGhpcy5pc0V4dGVuc2lvblVzZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihgRXh0ZW5zaW9uICR7bmFtZX0gaXMgdXNlZCBidXQgaGFzIGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBMb2FkIGxvYWRlciBleHRlbnNpb25zIHRoYXQgYXJlIG5vdCBhIGdsVEYgZXh0ZW5zaW9uLCBhcyB3ZWxsIGFzIGV4dGVuc2lvbnMgdGhhdCBhcmUgZ2xURiBleHRlbnNpb25zIGFuZCBhcmUgdXNlZCBieSB0aGUgbW9kZWwuXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZWdpc3RlcmVkRXh0ZW5zaW9uLmlzR0xURkV4dGVuc2lvbiB8fCB0aGlzLmlzRXh0ZW5zaW9uVXNlZChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBhd2FpdCByZWdpc3RlcmVkRXh0ZW5zaW9uLmZhY3RvcnkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24ubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLldhcm4oYFRoZSBuYW1lIG9mIHRoZSBnbFRGIGxvYWRlciBleHRlbnNpb24gaW5zdGFuY2UgZG9lcyBub3QgbWF0Y2ggdGhlIHJlZ2lzdGVyZWQgbmFtZTogJHtleHRlbnNpb24ubmFtZX0gIT09ICR7bmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm9uRXh0ZW5zaW9uTG9hZGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoZXh0ZW5zaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMucHVzaCguLi4oYXdhaXQgUHJvbWlzZS5hbGwoZXh0ZW5zaW9uUHJvbWlzZXMpKSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4gKGEub3JkZXIgfHwgTnVtYmVyLk1BWF9WQUxVRSkgLSAoYi5vcmRlciB8fCBOdW1iZXIuTUFYX1ZBTFVFKSk7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Lm9uRXh0ZW5zaW9uTG9hZGVkT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fZ2x0Zi5leHRlbnNpb25zUmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuX2dsdGYuZXh0ZW5zaW9uc1JlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLl9leHRlbnNpb25zLnNvbWUoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLm5hbWUgPT09IG5hbWUgJiYgZXh0ZW5zaW9uLmVuYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuZXh0ZW5zaW9uT3B0aW9uc1tuYW1lXT8uZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBleHRlbnNpb24gJHtuYW1lfSBpcyBkaXNhYmxlZGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVkIGV4dGVuc2lvbiAke25hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jcmVhdGVSb290Tm9kZSgpOiBJTm9kZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5jdXN0b21Sb290Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RCYWJ5bG9uTWVzaCA9IHRoaXMuX3BhcmVudC5jdXN0b21Sb290Tm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgICAgICAgICAgICAgIF9iYWJ5bG9uVHJhbnNmb3JtTm9kZTogdGhpcy5fcm9vdEJhYnlsb25NZXNoID09PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5fcm9vdEJhYnlsb25NZXNoLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IC0xLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgY29uc3Qgcm9vdE1lc2ggPSBuZXcgTWVzaChcIl9fcm9vdF9fXCIsIHRoaXMuX2JhYnlsb25TY2VuZSk7XHJcbiAgICAgICAgdGhpcy5fcm9vdEJhYnlsb25NZXNoID0gcm9vdE1lc2g7XHJcbiAgICAgICAgdGhpcy5fcm9vdEJhYnlsb25NZXNoLl9wYXJlbnRDb250YWluZXIgPSB0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Jvb3RCYWJ5bG9uTWVzaC5zZXRFbmFibGVkKGZhbHNlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm9vdE5vZGU6IElOb2RlID0ge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICAgICAgICAgIF9iYWJ5bG9uVHJhbnNmb3JtTm9kZTogdGhpcy5fcm9vdEJhYnlsb25NZXNoLFxyXG4gICAgICAgICAgICBpbmRleDogLTEsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wYXJlbnQuY29vcmRpbmF0ZVN5c3RlbU1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBHTFRGTG9hZGVyQ29vcmRpbmF0ZVN5c3RlbU1vZGUuQVVUTzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9iYWJ5bG9uU2NlbmUudXNlUmlnaHRIYW5kZWRTeXN0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByb290Tm9kZS5yb3RhdGlvbiA9IFswLCAxLCAwLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICByb290Tm9kZS5zY2FsZSA9IFsxLCAxLCAtMV07XHJcbiAgICAgICAgICAgICAgICAgICAgR0xURkxvYWRlci5fTG9hZFRyYW5zZm9ybShyb290Tm9kZSwgdGhpcy5fcm9vdEJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgR0xURkxvYWRlckNvb3JkaW5hdGVTeXN0ZW1Nb2RlLkZPUkNFX1JJR0hUX0hBTkRFRDoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLnVzZVJpZ2h0SGFuZGVkU3lzdGVtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbSBtb2RlICgke3RoaXMuX3BhcmVudC5jb29yZGluYXRlU3lzdGVtTW9kZX0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3BhcmVudC5vbk1lc2hMb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhyb290TWVzaCk7XHJcbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBnbFRGIHNjZW5lLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBnbFRGIHNjZW5lIHByb3BlcnR5XHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcclxuICAgIHB1YmxpYyBsb2FkU2NlbmVBc3luYyhjb250ZXh0OiBzdHJpbmcsIHNjZW5lOiBJU2NlbmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25Qcm9taXNlID0gdGhpcy5fZXh0ZW5zaW9uc0xvYWRTY2VuZUFzeW5jKGNvbnRleHQsIHNjZW5lKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9nT3BlbihgJHtjb250ZXh0fSAke3NjZW5lLm5hbWUgfHwgXCJcIn1gKTtcclxuXHJcbiAgICAgICAgaWYgKHNjZW5lLm5vZGVzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2NlbmUubm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L25vZGVzLyR7aW5kZXh9YCwgdGhpcy5fZ2x0Zi5ub2RlcywgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWROb2RlQXN5bmMoYC9ub2Rlcy8ke25vZGUuaW5kZXh9YCwgbm9kZSwgKGJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoLnBhcmVudCA9IHRoaXMuX3Jvb3RCYWJ5bG9uTWVzaDtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgdGhpcy5fcG9zdFNjZW5lTG9hZEFjdGlvbnMpIHtcclxuICAgICAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2xvYWRBbmltYXRpb25zQXN5bmMoKSk7XHJcblxyXG4gICAgICAgIHRoaXMubG9nQ2xvc2UoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9mb3JFYWNoUHJpbWl0aXZlKG5vZGU6IElOb2RlLCBjYWxsYmFjazogKGJhYnlsb25NZXNoOiBBYnN0cmFjdE1lc2gpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBpZiAobm9kZS5fcHJpbWl0aXZlQmFieWxvbk1lc2hlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhYnlsb25NZXNoIG9mIG5vZGUuX3ByaW1pdGl2ZUJhYnlsb25NZXNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXRHZW9tZXRyaWVzKCk6IEdlb21ldHJ5W10ge1xyXG4gICAgICAgIGNvbnN0IGdlb21ldHJpZXM6IEdlb21ldHJ5W10gPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLl9nbHRmLm5vZGVzO1xyXG4gICAgICAgIGlmIChub2Rlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hQcmltaXRpdmUobm9kZSwgKGJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSAoYmFieWxvbk1lc2ggYXMgTWVzaCkuZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5ICYmIGdlb21ldHJpZXMuaW5kZXhPZihnZW9tZXRyeSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJpZXMucHVzaChnZW9tZXRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldE1lc2hlcygpOiBBYnN0cmFjdE1lc2hbXSB7XHJcbiAgICAgICAgY29uc3QgbWVzaGVzOiBBYnN0cmFjdE1lc2hbXSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBSb290IG1lc2ggaXMgYWx3YXlzIGZpcnN0LCBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RCYWJ5bG9uTWVzaCBpbnN0YW5jZW9mIEFic3RyYWN0TWVzaCkge1xyXG4gICAgICAgICAgICBtZXNoZXMucHVzaCh0aGlzLl9yb290QmFieWxvbk1lc2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLl9nbHRmLm5vZGVzO1xyXG4gICAgICAgIGlmIChub2Rlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hQcmltaXRpdmUobm9kZSwgKGJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzaGVzLnB1c2goYmFieWxvbk1lc2gpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtZXNoZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0VHJhbnNmb3JtTm9kZXMoKTogVHJhbnNmb3JtTm9kZVtdIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1Ob2RlczogVHJhbnNmb3JtTm9kZVtdID0gW107XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5fZ2x0Zi5ub2RlcztcclxuICAgICAgICBpZiAobm9kZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUgJiYgbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUuZ2V0Q2xhc3NOYW1lKCkgPT09IFwiVHJhbnNmb3JtTm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtTm9kZXMucHVzaChub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGVGb3JTa2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtTm9kZXMucHVzaChub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZUZvclNraW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtTm9kZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0U2tlbGV0b25zKCk6IFNrZWxldG9uW10ge1xyXG4gICAgICAgIGNvbnN0IHNrZWxldG9uczogU2tlbGV0b25bXSA9IFtdO1xyXG5cclxuICAgICAgICBjb25zdCBza2lucyA9IHRoaXMuX2dsdGYuc2tpbnM7XHJcbiAgICAgICAgaWYgKHNraW5zKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2tpbiBvZiBza2lucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNraW4uX2RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbnMucHVzaChza2luLl9kYXRhLmJhYnlsb25Ta2VsZXRvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBza2VsZXRvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0QW5pbWF0aW9uR3JvdXBzKCk6IEFuaW1hdGlvbkdyb3VwW10ge1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbkdyb3VwczogQW5pbWF0aW9uR3JvdXBbXSA9IFtdO1xyXG5cclxuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fZ2x0Zi5hbmltYXRpb25zO1xyXG4gICAgICAgIGlmIChhbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIGFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkdyb3Vwcy5wdXNoKGFuaW1hdGlvbi5fYmFieWxvbkFuaW1hdGlvbkdyb3VwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkdyb3VwcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zdGFydEFuaW1hdGlvbnMoKTogdm9pZCB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wYXJlbnQuYW5pbWF0aW9uU3RhcnRNb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgR0xURkxvYWRlckFuaW1hdGlvblN0YXJ0TW9kZS5OT05FOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEdMVEZMb2FkZXJBbmltYXRpb25TdGFydE1vZGUuRklSU1Q6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhYnlsb25BbmltYXRpb25Hcm91cHMgPSB0aGlzLl9nZXRBbmltYXRpb25Hcm91cHMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChiYWJ5bG9uQW5pbWF0aW9uR3JvdXBzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb25Hcm91cHNbMF0uc3RhcnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEdMVEZMb2FkZXJBbmltYXRpb25TdGFydE1vZGUuQUxMOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uQW5pbWF0aW9uR3JvdXBzID0gdGhpcy5fZ2V0QW5pbWF0aW9uR3JvdXBzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhYnlsb25BbmltYXRpb25Hcm91cCBvZiBiYWJ5bG9uQW5pbWF0aW9uR3JvdXBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbkFuaW1hdGlvbkdyb3VwLnN0YXJ0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKGBJbnZhbGlkIGFuaW1hdGlvbiBzdGFydCBtb2RlICgke3RoaXMuX3BhcmVudC5hbmltYXRpb25TdGFydE1vZGV9KWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBnbFRGIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgZ2xURiBub2RlIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gYXNzaWduIEEgZnVuY3Rpb24gY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2FkZWQgQmFieWxvbiBtZXNoIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHVibGljIGxvYWROb2RlQXN5bmMoY29udGV4dDogc3RyaW5nLCBub2RlOiBJTm9kZSwgYXNzaWduOiAoYmFieWxvblRyYW5zZm9ybU5vZGU6IFRyYW5zZm9ybU5vZGUpID0+IHZvaWQgPSAoKSA9PiB7fSk6IFByb21pc2U8VHJhbnNmb3JtTm9kZT4ge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvblByb21pc2UgPSB0aGlzLl9leHRlbnNpb25zTG9hZE5vZGVBc3luYyhjb250ZXh0LCBub2RlLCBhc3NpZ24pO1xyXG4gICAgICAgIGlmIChleHRlbnNpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25Qcm9taXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogSW52YWxpZCByZWN1cnNpdmUgbm9kZSBoaWVyYXJjaHlgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9nT3BlbihgJHtjb250ZXh0fSAke25vZGUubmFtZSB8fCBcIlwifWApO1xyXG5cclxuICAgICAgICBjb25zdCBsb2FkTm9kZSA9IChiYWJ5bG9uVHJhbnNmb3JtTm9kZTogVHJhbnNmb3JtTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBHTFRGTG9hZGVyLkFkZFBvaW50ZXJNZXRhZGF0YShiYWJ5bG9uVHJhbnNmb3JtTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIEdMVEZMb2FkZXIuX0xvYWRUcmFuc2Zvcm0obm9kZSwgYmFieWxvblRyYW5zZm9ybU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5vZGUuY2FtZXJhICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9jYW1lcmFgLCB0aGlzLl9nbHRmLmNhbWVyYXMsIG5vZGUuY2FtZXJhKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkQ2FtZXJhQXN5bmMoYC9jYW1lcmFzLyR7Y2FtZXJhLmluZGV4fWAsIGNhbWVyYSwgKGJhYnlsb25DYW1lcmEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbkNhbWVyYS5wYXJlbnQgPSBiYWJ5bG9uVHJhbnNmb3JtTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9iYWJ5bG9uU2NlbmUudXNlUmlnaHRIYW5kZWRTeXN0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25UcmFuc2Zvcm1Ob2RlLnNjYWxpbmcueCA9IC0xOyAvLyBDYW5jZWxsaW5nIHJvb3Qgbm9kZSBzY2FsaW5nIGZvciBoYW5kZWRuZXNzIHNvIHRoZSB2aWV3IG1hdHJpeCBkb2VzIG5vdCBlbmQgdXAgZmxpcHBlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9jaGlsZHJlbi8ke2luZGV4fWAsIHRoaXMuX2dsdGYubm9kZXMsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWROb2RlQXN5bmMoYC9ub2Rlcy8ke2NoaWxkTm9kZS5pbmRleH1gLCBjaGlsZE5vZGUsIChjaGlsZEJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEJhYnlsb25NZXNoLnBhcmVudCA9IGJhYnlsb25UcmFuc2Zvcm1Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFzc2lnbihiYWJ5bG9uVHJhbnNmb3JtTm9kZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaGFzTWVzaCA9IG5vZGUubWVzaCAhPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgaGFzU2tpbiA9IHRoaXMuX3BhcmVudC5sb2FkU2tpbnMgJiYgbm9kZS5za2luICE9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCFoYXNNZXNoIHx8IGhhc1NraW4pIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5hbWUgfHwgYG5vZGUke25vZGUuaW5kZXh9YDtcclxuICAgICAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIXRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1Ob2RlID0gbmV3IFRyYW5zZm9ybU5vZGUobm9kZU5hbWUsIHRoaXMuX2JhYnlsb25TY2VuZSk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU5vZGUuX3BhcmVudENvbnRhaW5lciA9IHRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5tZXNoID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUgPSB0cmFuc2Zvcm1Ob2RlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGVGb3JTa2luID0gdHJhbnNmb3JtTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkTm9kZSh0cmFuc2Zvcm1Ob2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoYXNNZXNoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNTa2luKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zIChzZWNvbmQgaW1wbGVtZW50YXRpb24gbm90ZSlcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSBwYXRoIHdpbGwgcGxhY2UgdGhlIHNraW5uZWQgbWVzaCBhcyBhIHNpYmxpbmcgb2YgdGhlIHNrZWxldG9uIHJvb3Qgbm9kZSB3aXRob3V0IGxvYWRpbmcgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0sIHdoaWNoIGVmZmVjdGl2ZWx5IGlnbm9yZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgc2tpbm5lZCBtZXNoLCBhcyBwZXIgc3BlYy5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9tZXNoYCwgdGhpcy5fZ2x0Zi5tZXNoZXMsIG5vZGUubWVzaCk7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRNZXNoQXN5bmMoYC9tZXNoZXMvJHttZXNoLmluZGV4fWAsIG5vZGUsIG1lc2gsIChiYWJ5bG9uVHJhbnNmb3JtTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uVHJhbnNmb3JtTm9kZUZvclNraW4gPSBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZUZvclNraW4hO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIG1ldGFkYXRhIGZyb20gdGhlIHNraW4gbm9kZSB0byB0aGUgc2tpbm5lZCBtZXNoIGluIGNhc2UgYSBsb2FkZXIgZXh0ZW5zaW9uIGFkZGVkIG1ldGFkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uVHJhbnNmb3JtTm9kZS5tZXRhZGF0YSA9IGRlZXBNZXJnZShiYWJ5bG9uVHJhbnNmb3JtTm9kZUZvclNraW4ubWV0YWRhdGEsIGJhYnlsb25UcmFuc2Zvcm1Ob2RlLm1ldGFkYXRhIHx8IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNraW4gPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L3NraW5gLCB0aGlzLl9nbHRmLnNraW5zLCBub2RlLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFNraW5Bc3luYyhgL3NraW5zLyR7c2tpbi5pbmRleH1gLCBub2RlLCBza2luLCAoYmFieWxvblNrZWxldG9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaFByaW1pdGl2ZShub2RlLCAoYmFieWxvbk1lc2gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1lc2guc2tlbGV0b24gPSBiYWJ5bG9uU2tlbGV0b247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIHRoZSBub2RlcyBhcmUgcGFyZW50ZWQgYmVmb3JlIHBhcmVudGluZyB0aGUgc2tpbm5lZCBtZXNoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RTY2VuZUxvYWRBY3Rpb25zLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbi5za2VsZXRvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIHRoZSBza2lubmVkIG1lc2ggbm9kZSBhcyBhIHNpYmxpbmcgb2YgdGhlIHNrZWxldG9uIHJvb3Qgbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlbiB0aGUgcGFyZW50IG9mIHRoZSBza2VsZXRvbiByb290IGlzIHRoZSBza2lubmVkIG1lc2guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gQXJyYXlJdGVtLkdldChgL3NraW5zLyR7c2tpbi5pbmRleH0vc2tlbGV0b25gLCB0aGlzLl9nbHRmLm5vZGVzLCBza2luLnNrZWxldG9uKS5wYXJlbnQhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5kZXggPT09IHBhcmVudE5vZGUuaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uVHJhbnNmb3JtTm9kZS5wYXJlbnQgPSBiYWJ5bG9uVHJhbnNmb3JtTm9kZUZvclNraW4ucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uVHJhbnNmb3JtTm9kZS5wYXJlbnQgPSBwYXJlbnROb2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uVHJhbnNmb3JtTm9kZS5wYXJlbnQgPSB0aGlzLl9yb290QmFieWxvbk1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5vblNraW5Mb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh7IG5vZGU6IGJhYnlsb25UcmFuc2Zvcm1Ob2RlRm9yU2tpbiwgc2tpbm5lZE5vZGU6IGJhYnlsb25UcmFuc2Zvcm1Ob2RlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L21lc2hgLCB0aGlzLl9nbHRmLm1lc2hlcywgbm9kZS5tZXNoKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZE1lc2hBc3luYyhgL21lc2hlcy8ke21lc2guaW5kZXh9YCwgbm9kZSwgbWVzaCwgbG9hZE5vZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5sb2dDbG9zZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoUHJpbWl0aXZlKG5vZGUsIChiYWJ5bG9uTWVzaCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNNZXNoID0gYmFieWxvbk1lc2ggYXMgTWVzaDtcclxuICAgICAgICAgICAgICAgIGlmICghYXNNZXNoLmlzQW5JbnN0YW5jZSAmJiBhc01lc2guZ2VvbWV0cnkgJiYgYXNNZXNoLmdlb21ldHJ5LnVzZUJvdW5kaW5nSW5mb0Zyb21HZW9tZXRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbXBseSBhcHBseSB0aGUgd29ybGQgbWF0cmljZXMgdG8gdGhlIGJvdW5kaW5nIGluZm8gLSB0aGUgZXh0ZW5kcyBhcmUgYWxyZWFkeSBva1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoLl91cGRhdGVCb3VuZGluZ0luZm8oKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1lc2gucmVmcmVzaEJvdW5kaW5nSW5mbyh0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRNZXNoQXN5bmMoY29udGV4dDogc3RyaW5nLCBub2RlOiBJTm9kZSwgbWVzaDogSU1lc2gsIGFzc2lnbjogKGJhYnlsb25UcmFuc2Zvcm1Ob2RlOiBUcmFuc2Zvcm1Ob2RlKSA9PiB2b2lkKTogUHJvbWlzZTxUcmFuc2Zvcm1Ob2RlPiB7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlcyA9IG1lc2gucHJpbWl0aXZlcztcclxuICAgICAgICBpZiAoIXByaW1pdGl2ZXMgfHwgIXByaW1pdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogUHJpbWl0aXZlcyBhcmUgbWlzc2luZ2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByaW1pdGl2ZXNbMF0uaW5kZXggPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIEFycmF5SXRlbS5Bc3NpZ24ocHJpbWl0aXZlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICB0aGlzLmxvZ09wZW4oYCR7Y29udGV4dH0gJHttZXNoLm5hbWUgfHwgXCJcIn1gKTtcclxuXHJcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZSB8fCBgbm9kZSR7bm9kZS5pbmRleH1gO1xyXG5cclxuICAgICAgICBpZiAocHJpbWl0aXZlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gbWVzaC5wcmltaXRpdmVzWzBdO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZE1lc2hQcmltaXRpdmVBc3luYyhgJHtjb250ZXh0fS9wcmltaXRpdmVzLyR7cHJpbWl0aXZlLmluZGV4fWAsIG5hbWUsIG5vZGUsIG1lc2gsIHByaW1pdGl2ZSwgKGJhYnlsb25NZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUgPSBiYWJ5bG9uTWVzaDtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl9wcmltaXRpdmVCYWJ5bG9uTWVzaGVzID0gW2JhYnlsb25NZXNoXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSAhIXRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSA9IG5ldyBUcmFuc2Zvcm1Ob2RlKG5hbWUsIHRoaXMuX2JhYnlsb25TY2VuZSk7XHJcbiAgICAgICAgICAgIG5vZGUuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlLl9wYXJlbnRDb250YWluZXIgPSB0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgbm9kZS5fcHJpbWl0aXZlQmFieWxvbk1lc2hlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRNZXNoUHJpbWl0aXZlQXN5bmMoYCR7Y29udGV4dH0vcHJpbWl0aXZlcy8ke3ByaW1pdGl2ZS5pbmRleH1gLCBgJHtuYW1lfV9wcmltaXRpdmUke3ByaW1pdGl2ZS5pbmRleH1gLCBub2RlLCBtZXNoLCBwcmltaXRpdmUsIChiYWJ5bG9uTWVzaCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5wYXJlbnQgPSBub2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX3ByaW1pdGl2ZUJhYnlsb25NZXNoZXMhLnB1c2goYmFieWxvbk1lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhc3NpZ24obm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUhKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2dDbG9zZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsIERlZmluZSB0aGlzIG1ldGhvZCB0byBtb2RpZnkgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBsb2FkaW5nIGRhdGEgZm9yIG1lc2ggcHJpbWl0aXZlcy5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBtZXNoIG5hbWUgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIGdsVEYgbm9kZSB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbWVzaCBUaGUgZ2xURiBtZXNoIHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBwcmltaXRpdmUgVGhlIGdsVEYgbWVzaCBwcmltaXRpdmUgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBhc3NpZ24gQSBmdW5jdGlvbiBjYWxsZWQgc3luY2hyb25vdXNseSBhZnRlciBwYXJzaW5nIHRoZSBnbFRGIHByb3BlcnRpZXNcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBtZXNoIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGUgb3IgbnVsbCBpZiBub3QgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwdWJsaWMgX2xvYWRNZXNoUHJpbWl0aXZlQXN5bmMoXHJcbiAgICAgICAgY29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIG5hbWU6IHN0cmluZyxcclxuICAgICAgICBub2RlOiBJTm9kZSxcclxuICAgICAgICBtZXNoOiBJTWVzaCxcclxuICAgICAgICBwcmltaXRpdmU6IElNZXNoUHJpbWl0aXZlLFxyXG4gICAgICAgIGFzc2lnbjogKGJhYnlsb25NZXNoOiBBYnN0cmFjdE1lc2gpID0+IHZvaWRcclxuICAgICk6IFByb21pc2U8QWJzdHJhY3RNZXNoPiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uUHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNMb2FkTWVzaFByaW1pdGl2ZUFzeW5jKGNvbnRleHQsIG5hbWUsIG5vZGUsIG1lc2gsIHByaW1pdGl2ZSwgYXNzaWduKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubG9nT3BlbihgJHtjb250ZXh0fWApO1xyXG5cclxuICAgICAgICBjb25zdCBzaG91bGRJbnN0YW5jZSA9IHRoaXMuX2Rpc2FibGVJbnN0YW5jZWRNZXNoID09PSAwICYmIHRoaXMuX3BhcmVudC5jcmVhdGVJbnN0YW5jZXMgJiYgbm9kZS5za2luID09IHVuZGVmaW5lZCAmJiAhbWVzaC5wcmltaXRpdmVzWzBdLnRhcmdldHM7XHJcblxyXG4gICAgICAgIGxldCBiYWJ5bG9uQWJzdHJhY3RNZXNoOiBBYnN0cmFjdE1lc2g7XHJcbiAgICAgICAgbGV0IHByb21pc2U6IFByb21pc2U8dW5rbm93bj47XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRJbnN0YW5jZSAmJiBwcmltaXRpdmUuX2luc3RhbmNlRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgICAgIGJhYnlsb25BYnN0cmFjdE1lc2ggPSBwcmltaXRpdmUuX2luc3RhbmNlRGF0YS5iYWJ5bG9uU291cmNlTWVzaC5jcmVhdGVJbnN0YW5jZShuYW1lKTtcclxuICAgICAgICAgICAgYmFieWxvbkFic3RyYWN0TWVzaC5fcGFyZW50Q29udGFpbmVyID0gdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBwcmltaXRpdmUuX2luc3RhbmNlRGF0YS5wcm9taXNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhYnlsb25NZXNoID0gbmV3IE1lc2gobmFtZSwgdGhpcy5fYmFieWxvblNjZW5lKTtcclxuICAgICAgICAgICAgYmFieWxvbk1lc2guX3BhcmVudENvbnRhaW5lciA9IHRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWVzaC5zaWRlT3JpZW50YXRpb24gPSB0aGlzLl9iYWJ5bG9uU2NlbmUudXNlUmlnaHRIYW5kZWRTeXN0ZW0gPyBNYXRlcmlhbC5Db3VudGVyQ2xvY2tXaXNlU2lkZU9yaWVudGF0aW9uIDogTWF0ZXJpYWwuQ2xvY2tXaXNlU2lkZU9yaWVudGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlTW9ycGhUYXJnZXRzKGNvbnRleHQsIG5vZGUsIG1lc2gsIHByaW1pdGl2ZSwgYmFieWxvbk1lc2gpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFZlcnRleERhdGFBc3luYyhjb250ZXh0LCBwcmltaXRpdmUsIGJhYnlsb25NZXNoKS50aGVuKGFzeW5jIChiYWJ5bG9uR2VvbWV0cnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZE1vcnBoVGFyZ2V0c0FzeW5jKGNvbnRleHQsIHByaW1pdGl2ZSwgYmFieWxvbk1lc2gsIGJhYnlsb25HZW9tZXRyeSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25HZW9tZXRyeS5hcHBseVRvTWVzaChiYWJ5bG9uTWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25HZW9tZXRyeS5fcGFyZW50Q29udGFpbmVyID0gdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYmFieWxvbkRyYXdNb2RlID0gR0xURkxvYWRlci5fR2V0RHJhd01vZGUoY29udGV4dCwgcHJpbWl0aXZlLm1vZGUpO1xyXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlLm1hdGVyaWFsID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJhYnlsb25NYXRlcmlhbCA9IHRoaXMuX2RlZmF1bHRCYWJ5bG9uTWF0ZXJpYWxEYXRhW2JhYnlsb25EcmF3TW9kZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJhYnlsb25NYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbCA9IHRoaXMuX2NyZWF0ZURlZmF1bHRNYXRlcmlhbChcIl9fR0xURkxvYWRlci5fZGVmYXVsdFwiLCBiYWJ5bG9uRHJhd01vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5vbk1hdGVyaWFsTG9hZGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoYmFieWxvbk1hdGVyaWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0QmFieWxvbk1hdGVyaWFsRGF0YVtiYWJ5bG9uRHJhd01vZGVdID0gYmFieWxvbk1hdGVyaWFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1lc2gubWF0ZXJpYWwgPSBiYWJ5bG9uTWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGFyZW50LnNraXBNYXRlcmlhbHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9tYXRlcmlhbGAsIHRoaXMuX2dsdGYubWF0ZXJpYWxzLCBwcmltaXRpdmUubWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkTWF0ZXJpYWxBc3luYyhgL21hdGVyaWFscy8ke21hdGVyaWFsLmluZGV4fWAsIG1hdGVyaWFsLCBiYWJ5bG9uTWVzaCwgYmFieWxvbkRyYXdNb2RlLCAoYmFieWxvbk1hdGVyaWFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25NZXNoLm1hdGVyaWFsID0gYmFieWxvbk1hdGVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNob3VsZEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuX2luc3RhbmNlRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uU291cmNlTWVzaDogYmFieWxvbk1lc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25BYnN0cmFjdE1lc2ggPSBiYWJ5bG9uTWVzaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEdMVEZMb2FkZXIuQWRkUG9pbnRlck1ldGFkYXRhKGJhYnlsb25BYnN0cmFjdE1lc2gsIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudC5vbk1lc2hMb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhiYWJ5bG9uQWJzdHJhY3RNZXNoKTtcclxuICAgICAgICBhc3NpZ24oYmFieWxvbkFic3RyYWN0TWVzaCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9nQ2xvc2UoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYWJ5bG9uQWJzdHJhY3RNZXNoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2xvYWRWZXJ0ZXhEYXRhQXN5bmMoY29udGV4dDogc3RyaW5nLCBwcmltaXRpdmU6IElNZXNoUHJpbWl0aXZlLCBiYWJ5bG9uTWVzaDogTWVzaCk6IFByb21pc2U8R2VvbWV0cnk+IHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25Qcm9taXNlID0gdGhpcy5fZXh0ZW5zaW9uc0xvYWRWZXJ0ZXhEYXRhQXN5bmMoY29udGV4dCwgcHJpbWl0aXZlLCBiYWJ5bG9uTWVzaCk7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvblByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblByb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogQXR0cmlidXRlcyBhcmUgbWlzc2luZ2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTx1bmtub3duPj4oKTtcclxuXHJcbiAgICAgICAgY29uc3QgYmFieWxvbkdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KGJhYnlsb25NZXNoLm5hbWUsIHRoaXMuX2JhYnlsb25TY2VuZSk7XHJcblxyXG4gICAgICAgIGlmIChwcmltaXRpdmUuaW5kaWNlcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmFieWxvbk1lc2guaXNVbkluZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9pbmRpY2VzYCwgdGhpcy5fZ2x0Zi5hY2Nlc3NvcnMsIHByaW1pdGl2ZS5pbmRpY2VzKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRJbmRpY2VzQWNjZXNzb3JBc3luYyhgL2FjY2Vzc29ycy8ke2FjY2Vzc29yLmluZGV4fWAsIGFjY2Vzc29yKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbkdlb21ldHJ5LnNldEluZGljZXMoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbG9hZEF0dHJpYnV0ZSA9IChuYW1lOiBzdHJpbmcsIGtpbmQ6IHN0cmluZywgY2FsbGJhY2s/OiAoYWNjZXNzb3I6IElBY2Nlc3NvcikgPT4gdm9pZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tuYW1lXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYmFieWxvbk1lc2guX2RlbGF5SW5mbyA9IGJhYnlsb25NZXNoLl9kZWxheUluZm8gfHwgW107XHJcbiAgICAgICAgICAgIGlmIChiYWJ5bG9uTWVzaC5fZGVsYXlJbmZvLmluZGV4T2Yoa2luZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5fZGVsYXlJbmZvLnB1c2goa2luZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9hdHRyaWJ1dGVzLyR7bmFtZX1gLCB0aGlzLl9nbHRmLmFjY2Vzc29ycywgYXR0cmlidXRlc1tuYW1lXSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkVmVydGV4QWNjZXNzb3JBc3luYyhgL2FjY2Vzc29ycy8ke2FjY2Vzc29yLmluZGV4fWAsIGFjY2Vzc29yLCBraW5kKS50aGVuKChiYWJ5bG9uVmVydGV4QnVmZmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhYnlsb25WZXJ0ZXhCdWZmZXIuZ2V0S2luZCgpID09PSBWZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kICYmICF0aGlzLnBhcmVudC5hbHdheXNDb21wdXRlQm91bmRpbmdCb3ggJiYgIWJhYnlsb25NZXNoLnNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhYnlsb25Cb3VuZGluZ0luZm8gPSBMb2FkQm91bmRpbmdJbmZvRnJvbVBvc2l0aW9uQWNjZXNzb3IoYWNjZXNzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFieWxvbkJvdW5kaW5nSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbkdlb21ldHJ5Ll9ib3VuZGluZ0luZm8gPSBiYWJ5bG9uQm91bmRpbmdJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbkdlb21ldHJ5LnVzZUJvdW5kaW5nSW5mb0Zyb21HZW9tZXRyeSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbkdlb21ldHJ5LnNldFZlcnRpY2VzQnVmZmVyKGJhYnlsb25WZXJ0ZXhCdWZmZXIsIGFjY2Vzc29yLmNvdW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoa2luZCA9PSBWZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzRXh0cmFLaW5kKSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5udW1Cb25lSW5mbHVlbmNlcnMgPSA4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFjY2Vzc29yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJQT1NJVElPTlwiLCBWZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiTk9STUFMXCIsIFZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiVEFOR0VOVFwiLCBWZXJ0ZXhCdWZmZXIuVGFuZ2VudEtpbmQpO1xyXG4gICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF8wXCIsIFZlcnRleEJ1ZmZlci5VVktpbmQpO1xyXG4gICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF8xXCIsIFZlcnRleEJ1ZmZlci5VVjJLaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiVEVYQ09PUkRfMlwiLCBWZXJ0ZXhCdWZmZXIuVVYzS2luZCk7XHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIlRFWENPT1JEXzNcIiwgVmVydGV4QnVmZmVyLlVWNEtpbmQpO1xyXG4gICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF80XCIsIFZlcnRleEJ1ZmZlci5VVjVLaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiVEVYQ09PUkRfNVwiLCBWZXJ0ZXhCdWZmZXIuVVY2S2luZCk7XHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIkpPSU5UU18wXCIsIFZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiV0VJR0hUU18wXCIsIFZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiSk9JTlRTXzFcIiwgVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0V4dHJhS2luZCk7XHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIldFSUdIVFNfMVwiLCBWZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzRXh0cmFLaW5kKTtcclxuICAgICAgICBsb2FkQXR0cmlidXRlKFwiQ09MT1JfMFwiLCBWZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kLCAoYWNjZXNzb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGFjY2Vzc29yLnR5cGUgPT09IEFjY2Vzc29yVHlwZS5WRUM0KSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5oYXNWZXJ0ZXhBbHBoYSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGJhYnlsb25HZW9tZXRyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jcmVhdGVNb3JwaFRhcmdldHMoY29udGV4dDogc3RyaW5nLCBub2RlOiBJTm9kZSwgbWVzaDogSU1lc2gsIHByaW1pdGl2ZTogSU1lc2hQcmltaXRpdmUsIGJhYnlsb25NZXNoOiBNZXNoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFwcmltaXRpdmUudGFyZ2V0cyB8fCAhdGhpcy5fcGFyZW50LmxvYWRNb3JwaFRhcmdldHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUuX251bU1vcnBoVGFyZ2V0cyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbm9kZS5fbnVtTW9ycGhUYXJnZXRzID0gcHJpbWl0aXZlLnRhcmdldHMubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLnRhcmdldHMubGVuZ3RoICE9PSBub2RlLl9udW1Nb3JwaFRhcmdldHMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBQcmltaXRpdmVzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiB0YXJnZXRzYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXROYW1lcyA9IG1lc2guZXh0cmFzID8gbWVzaC5leHRyYXMudGFyZ2V0TmFtZXMgOiBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgYmFieWxvbk1lc2gubW9ycGhUYXJnZXRNYW5hZ2VyID0gbmV3IE1vcnBoVGFyZ2V0TWFuYWdlcih0aGlzLl9iYWJ5bG9uU2NlbmUpO1xyXG4gICAgICAgIGJhYnlsb25NZXNoLm1vcnBoVGFyZ2V0TWFuYWdlci5fcGFyZW50Q29udGFpbmVyID0gdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgYmFieWxvbk1lc2gubW9ycGhUYXJnZXRNYW5hZ2VyLmFyZVVwZGF0ZXNGcm96ZW4gPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJpbWl0aXZlLnRhcmdldHMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IG5vZGUud2VpZ2h0cyA/IG5vZGUud2VpZ2h0c1tpbmRleF0gOiBtZXNoLndlaWdodHMgPyBtZXNoLndlaWdodHNbaW5kZXhdIDogMDtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRhcmdldE5hbWVzID8gdGFyZ2V0TmFtZXNbaW5kZXhdIDogYG1vcnBoVGFyZ2V0JHtpbmRleH1gO1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWVzaC5tb3JwaFRhcmdldE1hbmFnZXIuYWRkVGFyZ2V0KG5ldyBNb3JwaFRhcmdldChuYW1lLCB3ZWlnaHQsIGJhYnlsb25NZXNoLmdldFNjZW5lKCkpKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogdGVsbCB0aGUgdGFyZ2V0IHdoZXRoZXIgaXQgaGFzIHBvc2l0aW9ucywgbm9ybWFscywgdGFuZ2VudHNcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZE1vcnBoVGFyZ2V0c0FzeW5jKGNvbnRleHQ6IHN0cmluZywgcHJpbWl0aXZlOiBJTWVzaFByaW1pdGl2ZSwgYmFieWxvbk1lc2g6IE1lc2gsIGJhYnlsb25HZW9tZXRyeTogR2VvbWV0cnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIXByaW1pdGl2ZS50YXJnZXRzIHx8ICF0aGlzLl9wYXJlbnQubG9hZE1vcnBoVGFyZ2V0cykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICBjb25zdCBtb3JwaFRhcmdldE1hbmFnZXIgPSBiYWJ5bG9uTWVzaC5tb3JwaFRhcmdldE1hbmFnZXIhO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtb3JwaFRhcmdldE1hbmFnZXIubnVtVGFyZ2V0czsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCBiYWJ5bG9uTW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldE1hbmFnZXIuZ2V0VGFyZ2V0KGluZGV4KTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9sb2FkTW9ycGhUYXJnZXRWZXJ0ZXhEYXRhQXN5bmMoYCR7Y29udGV4dH0vdGFyZ2V0cy8ke2luZGV4fWAsIGJhYnlsb25HZW9tZXRyeSwgcHJpbWl0aXZlLnRhcmdldHNbaW5kZXhdLCBiYWJ5bG9uTW9ycGhUYXJnZXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0TWFuYWdlci5hcmVVcGRhdGVzRnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfbG9hZE1vcnBoVGFyZ2V0VmVydGV4RGF0YUFzeW5jKFxyXG4gICAgICAgIGNvbnRleHQ6IHN0cmluZyxcclxuICAgICAgICBiYWJ5bG9uR2VvbWV0cnk6IEdlb21ldHJ5LFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9LFxyXG4gICAgICAgIGJhYnlsb25Nb3JwaFRhcmdldDogTW9ycGhUYXJnZXRcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvYWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlOiBzdHJpbmcsIGtpbmQ6IHN0cmluZywgc2V0RGF0YTogKGJhYnlsb25WZXJ0ZXhCdWZmZXI6IFZlcnRleEJ1ZmZlciwgZGF0YTogRmxvYXQzMkFycmF5KSA9PiB2b2lkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGJhYnlsb25WZXJ0ZXhCdWZmZXIgPSBiYWJ5bG9uR2VvbWV0cnkuZ2V0VmVydGV4QnVmZmVyKGtpbmQpO1xyXG4gICAgICAgICAgICBpZiAoIWJhYnlsb25WZXJ0ZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgYWNjZXNzb3IgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9LyR7YXR0cmlidXRlfWAsIHRoaXMuX2dsdGYuYWNjZXNzb3JzLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEZsb2F0QWNjZXNzb3JBc3luYyhgL2FjY2Vzc29ycy8ke2FjY2Vzc29yLmluZGV4fWAsIGFjY2Vzc29yKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RGF0YShiYWJ5bG9uVmVydGV4QnVmZmVyLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIlBPU0lUSU9OXCIsIFZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsIChiYWJ5bG9uVmVydGV4QnVmZmVyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBiYWJ5bG9uVmVydGV4QnVmZmVyLmZvckVhY2goZGF0YS5sZW5ndGgsICh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpbmRleF0gPSBkYXRhW2luZGV4XSArIHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25Nb3JwaFRhcmdldC5zZXRQb3NpdGlvbnMocG9zaXRpb25zKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIk5PUk1BTFwiLCBWZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCwgKGJhYnlsb25WZXJ0ZXhCdWZmZXIsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBiYWJ5bG9uVmVydGV4QnVmZmVyLmZvckVhY2gobm9ybWFscy5sZW5ndGgsICh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHNbaW5kZXhdID0gZGF0YVtpbmRleF0gKyB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBiYWJ5bG9uTW9ycGhUYXJnZXQuc2V0Tm9ybWFscyhub3JtYWxzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIlRBTkdFTlRcIiwgVmVydGV4QnVmZmVyLlRhbmdlbnRLaW5kLCAoYmFieWxvblZlcnRleEJ1ZmZlciwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YW5nZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoKGRhdGEubGVuZ3RoIC8gMykgKiA0KTtcclxuICAgICAgICAgICAgbGV0IGRhdGFJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGJhYnlsb25WZXJ0ZXhCdWZmZXIuZm9yRWFjaCgoZGF0YS5sZW5ndGggLyAzKSAqIDQsICh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRhbmdlbnQgZGF0YSBmb3IgbW9ycGggdGFyZ2V0cyBpcyBzdG9yZWQgYXMgeHl6IGRlbHRhLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZlcnRleERhdGEudGFuZ2VudCBpcyBzdG9yZWQgYXMgeHl6dy5cclxuICAgICAgICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gc2tpcCBldmVyeSBmb3VydGggdmVydGV4RGF0YS50YW5nZW50LlxyXG4gICAgICAgICAgICAgICAgaWYgKChpbmRleCArIDEpICUgNCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRzW2RhdGFJbmRleF0gPSBkYXRhW2RhdGFJbmRleF0gKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJhYnlsb25Nb3JwaFRhcmdldC5zZXRUYW5nZW50cyh0YW5nZW50cyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJURVhDT09SRF8wXCIsIFZlcnRleEJ1ZmZlci5VVktpbmQsIChiYWJ5bG9uVmVydGV4QnVmZmVyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBiYWJ5bG9uVmVydGV4QnVmZmVyLmZvckVhY2goZGF0YS5sZW5ndGgsICh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIHV2c1tpbmRleF0gPSBkYXRhW2luZGV4XSArIHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25Nb3JwaFRhcmdldC5zZXRVVnModXZzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbG9hZEF0dHJpYnV0ZShcIlRFWENPT1JEXzFcIiwgVmVydGV4QnVmZmVyLlVWMktpbmQsIChiYWJ5bG9uVmVydGV4QnVmZmVyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBiYWJ5bG9uVmVydGV4QnVmZmVyLmZvckVhY2goZGF0YS5sZW5ndGgsICh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIHV2c1tpbmRleF0gPSBkYXRhW2luZGV4XSArIHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25Nb3JwaFRhcmdldC5zZXRVVjJzKHV2cyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxvYWRBdHRyaWJ1dGUoXCJDT0xPUl8wXCIsIFZlcnRleEJ1ZmZlci5Db2xvcktpbmQsIChiYWJ5bG9uVmVydGV4QnVmZmVyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb2xvcnMgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRTaXplID0gYmFieWxvblZlcnRleEJ1ZmZlci5nZXRTaXplKCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRTaXplID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KChkYXRhLmxlbmd0aCAvIDMpICogNCk7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uVmVydGV4QnVmZmVyLmZvckVhY2goZGF0YS5sZW5ndGgsICh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhpZCA9IE1hdGguZmxvb3IoaW5kZXggLyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gaW5kZXggJSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc1s0ICogcGl4aWQgKyBjaGFubmVsXSA9IGRhdGFbMyAqIHBpeGlkICsgY2hhbm5lbF0gKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAvIDM7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc1s0ICogaSArIDNdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRTaXplID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25WZXJ0ZXhCdWZmZXIuZm9yRWFjaChkYXRhLmxlbmd0aCwgKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc1tpbmRleF0gPSBkYXRhW2luZGV4XSArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06IEludmFsaWQgbnVtYmVyIG9mIGNvbXBvbmVudHMgKCR7Y29tcG9uZW50U2l6ZX0pIGZvciBDT0xPUl8wIGF0dHJpYnV0ZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhYnlsb25Nb3JwaFRhcmdldC5zZXRDb2xvcnMoY29sb3JzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfTG9hZFRyYW5zZm9ybShub2RlOiBJTm9kZSwgYmFieWxvbk5vZGU6IFRyYW5zZm9ybU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZ25vcmUgdGhlIFRSUyBvZiBza2lubmVkIG5vZGVzLlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnMgKHNlY29uZCBpbXBsZW1lbnRhdGlvbiBub3RlKVxyXG4gICAgICAgIGlmIChub2RlLnNraW4gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwb3NpdGlvbiA9IFZlY3RvcjMuWmVybygpO1xyXG4gICAgICAgIGxldCByb3RhdGlvbiA9IFF1YXRlcm5pb24uSWRlbnRpdHkoKTtcclxuICAgICAgICBsZXQgc2NhbGluZyA9IFZlY3RvcjMuT25lKCk7XHJcblxyXG4gICAgICAgIGlmIChub2RlLm1hdHJpeCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBNYXRyaXguRnJvbUFycmF5KG5vZGUubWF0cml4KTtcclxuICAgICAgICAgICAgbWF0cml4LmRlY29tcG9zZShzY2FsaW5nLCByb3RhdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IFZlY3RvcjMuRnJvbUFycmF5KG5vZGUudHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IFF1YXRlcm5pb24uRnJvbUFycmF5KG5vZGUucm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsaW5nID0gVmVjdG9yMy5Gcm9tQXJyYXkobm9kZS5zY2FsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhYnlsb25Ob2RlLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgYmFieWxvbk5vZGUucm90YXRpb25RdWF0ZXJuaW9uID0gcm90YXRpb247XHJcbiAgICAgICAgYmFieWxvbk5vZGUuc2NhbGluZyA9IHNjYWxpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jLCBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfbG9hZFNraW5Bc3luYyhjb250ZXh0OiBzdHJpbmcsIG5vZGU6IElOb2RlLCBza2luOiBJU2tpbiwgYXNzaWduOiAoYmFieWxvblNrZWxldG9uOiBTa2VsZXRvbikgPT4gdm9pZCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICghdGhpcy5fcGFyZW50LmxvYWRTa2lucykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBleHRlbnNpb25Qcm9taXNlID0gdGhpcy5fZXh0ZW5zaW9uc0xvYWRTa2luQXN5bmMoY29udGV4dCwgbm9kZSwgc2tpbik7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvblByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblByb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2tpbi5fZGF0YSkge1xyXG4gICAgICAgICAgICBhc3NpZ24oc2tpbi5fZGF0YS5iYWJ5bG9uU2tlbGV0b24pO1xyXG4gICAgICAgICAgICByZXR1cm4gc2tpbi5fZGF0YS5wcm9taXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2tlbGV0b25JZCA9IGBza2VsZXRvbiR7c2tpbi5pbmRleH1gO1xyXG4gICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISF0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICBjb25zdCBiYWJ5bG9uU2tlbGV0b24gPSBuZXcgU2tlbGV0b24oc2tpbi5uYW1lIHx8IHNrZWxldG9uSWQsIHNrZWxldG9uSWQsIHRoaXMuX2JhYnlsb25TY2VuZSk7XHJcbiAgICAgICAgYmFieWxvblNrZWxldG9uLl9wYXJlbnRDb250YWluZXIgPSB0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl9sb2FkQm9uZXMoY29udGV4dCwgc2tpbiwgYmFieWxvblNrZWxldG9uKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fbG9hZFNraW5JbnZlcnNlQmluZE1hdHJpY2VzRGF0YUFzeW5jKGNvbnRleHQsIHNraW4pLnRoZW4oKGludmVyc2VCaW5kTWF0cmljZXNEYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJvbmVNYXRyaWNlcyhiYWJ5bG9uU2tlbGV0b24sIGludmVyc2VCaW5kTWF0cmljZXNEYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2tpbi5fZGF0YSA9IHtcclxuICAgICAgICAgICAgYmFieWxvblNrZWxldG9uOiBiYWJ5bG9uU2tlbGV0b24sXHJcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYXNzaWduKGJhYnlsb25Ta2VsZXRvbik7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRCb25lcyhjb250ZXh0OiBzdHJpbmcsIHNraW46IElTa2luLCBiYWJ5bG9uU2tlbGV0b246IFNrZWxldG9uKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHNraW4uc2tlbGV0b24gPT0gdW5kZWZpbmVkIHx8IHRoaXMuX3BhcmVudC5hbHdheXNDb21wdXRlU2tlbGV0b25Sb290Tm9kZSkge1xyXG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX2ZpbmRTa2VsZXRvblJvb3ROb2RlKGAke2NvbnRleHR9L2pvaW50c2AsIHNraW4uam9pbnRzKTtcclxuICAgICAgICAgICAgaWYgKHJvb3ROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tpbi5za2VsZXRvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpbi5za2VsZXRvbiA9IHJvb3ROb2RlLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1BhcmVudCA9IChhOiBJTm9kZSwgYjogSU5vZGUpOiBib29sZWFuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGIucGFyZW50OyBiID0gYi5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2tlbGV0b25Ob2RlID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9za2VsZXRvbmAsIHRoaXMuX2dsdGYubm9kZXMsIHNraW4uc2tlbGV0b24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbk5vZGUgIT09IHJvb3ROb2RlICYmICFpc1BhcmVudChza2VsZXRvbk5vZGUsIHJvb3ROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihgJHtjb250ZXh0fS9za2VsZXRvbjogT3ZlcnJpZGluZyB3aXRoIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGFzIHNrZWxldG9uIG5vZGUgaXMgbm90IGEgY29tbW9uIHJvb3RgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpbi5za2VsZXRvbiA9IHJvb3ROb2RlLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKGAke2NvbnRleHR9OiBGYWlsZWQgdG8gZmluZCBjb21tb24gcm9vdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBiYWJ5bG9uQm9uZXM6IHsgW2luZGV4OiBudW1iZXJdOiBCb25lIH0gPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHNraW4uam9pbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2pvaW50cy8ke2luZGV4fWAsIHRoaXMuX2dsdGYubm9kZXMsIGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZEJvbmUobm9kZSwgc2tpbiwgYmFieWxvblNrZWxldG9uLCBiYWJ5bG9uQm9uZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9maW5kU2tlbGV0b25Sb290Tm9kZShjb250ZXh0OiBzdHJpbmcsIGpvaW50czogQXJyYXk8bnVtYmVyPik6IE51bGxhYmxlPElOb2RlPiB7XHJcbiAgICAgICAgaWYgKGpvaW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwYXRoczogeyBbam9pbnQ6IG51bWJlcl06IEFycmF5PElOb2RlPiB9ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBqb2ludHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aDogSU5vZGVbXSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vJHtpbmRleH1gLCB0aGlzLl9nbHRmLm5vZGVzLCBpbmRleCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50ITtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXRoc1tpbmRleF0gPSBwYXRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJvb3ROb2RlOiBOdWxsYWJsZTxJTm9kZT4gPSBudWxsO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyA7ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgcGF0aCA9IHBhdGhzW2pvaW50c1swXV07XHJcbiAgICAgICAgICAgIGlmIChpID49IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwYXRoW2ldO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGpvaW50cy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhzW2pvaW50c1tqXV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXRoLmxlbmd0aCB8fCBub2RlICE9PSBwYXRoW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByb290Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRCb25lKG5vZGU6IElOb2RlLCBza2luOiBJU2tpbiwgYmFieWxvblNrZWxldG9uOiBTa2VsZXRvbiwgYmFieWxvbkJvbmVzOiB7IFtpbmRleDogbnVtYmVyXTogQm9uZSB9KTogQm9uZSB7XHJcbiAgICAgICAgbm9kZS5faXNKb2ludCA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBiYWJ5bG9uQm9uZSA9IGJhYnlsb25Cb25lc1tub2RlLmluZGV4XTtcclxuICAgICAgICBpZiAoYmFieWxvbkJvbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJhYnlsb25Cb25lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBhcmVudEJhYnlsb25Cb25lOiBOdWxsYWJsZTxCb25lPiA9IG51bGw7XHJcbiAgICAgICAgaWYgKG5vZGUuaW5kZXggIT09IHNraW4uc2tlbGV0b24pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50QmFieWxvbkJvbmUgPSB0aGlzLl9sb2FkQm9uZShub2RlLnBhcmVudCwgc2tpbiwgYmFieWxvblNrZWxldG9uLCBiYWJ5bG9uQm9uZXMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNraW4uc2tlbGV0b24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLldhcm4oYC9za2lucy8ke3NraW4uaW5kZXh9L3NrZWxldG9uOiBTa2VsZXRvbiBub2RlIGlzIG5vdCBhIGNvbW1vbiByb290YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJvbmVJbmRleCA9IHNraW4uam9pbnRzLmluZGV4T2Yobm9kZS5pbmRleCk7XHJcbiAgICAgICAgYmFieWxvbkJvbmUgPSBuZXcgQm9uZShub2RlLm5hbWUgfHwgYGpvaW50JHtub2RlLmluZGV4fWAsIGJhYnlsb25Ta2VsZXRvbiwgcGFyZW50QmFieWxvbkJvbmUsIHRoaXMuX2dldE5vZGVNYXRyaXgobm9kZSksIG51bGwsIG51bGwsIGJvbmVJbmRleCk7XHJcbiAgICAgICAgYmFieWxvbkJvbmVzW25vZGUuaW5kZXhdID0gYmFieWxvbkJvbmU7XHJcblxyXG4gICAgICAgIC8vIFdhaXQgdW50aWwgdGhlIHNjZW5lIGlzIGxvYWRlZCB0byBlbnN1cmUgdGhlIHRyYW5zZm9ybSBub2RlcyBhcmUgbG9hZGVkLlxyXG4gICAgICAgIHRoaXMuX3Bvc3RTY2VuZUxvYWRBY3Rpb25zLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBMaW5rIHRoZSBCYWJ5bG9uIGJvbmUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBCYWJ5bG9uIHRyYW5zZm9ybSBub2RlLlxyXG4gICAgICAgICAgICAvLyBBIGdsVEYgam9pbnQgaXMgYSBwb2ludGVyIHRvIGEgZ2xURiBub2RlIGluIHRoZSBnbFRGIG5vZGUgaGllcmFyY2h5IHNpbWlsYXIgdG8gVW5pdHkzRC5cclxuICAgICAgICAgICAgYmFieWxvbkJvbmUubGlua1RyYW5zZm9ybU5vZGUobm9kZS5fYmFieWxvblRyYW5zZm9ybU5vZGUhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJhYnlsb25Cb25lO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRTa2luSW52ZXJzZUJpbmRNYXRyaWNlc0RhdGFBc3luYyhjb250ZXh0OiBzdHJpbmcsIHNraW46IElTa2luKTogUHJvbWlzZTxOdWxsYWJsZTxGbG9hdDMyQXJyYXk+PiB7XHJcbiAgICAgICAgaWYgKHNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9pbnZlcnNlQmluZE1hdHJpY2VzYCwgdGhpcy5fZ2x0Zi5hY2Nlc3NvcnMsIHNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRGbG9hdEFjY2Vzc29yQXN5bmMoYC9hY2Nlc3NvcnMvJHthY2Nlc3Nvci5pbmRleH1gLCBhY2Nlc3Nvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlQm9uZU1hdHJpY2VzKGJhYnlsb25Ta2VsZXRvbjogU2tlbGV0b24sIGludmVyc2VCaW5kTWF0cmljZXNEYXRhOiBOdWxsYWJsZTxGbG9hdDMyQXJyYXk+KTogdm9pZCB7XHJcbiAgICAgICAgZm9yIChjb25zdCBiYWJ5bG9uQm9uZSBvZiBiYWJ5bG9uU2tlbGV0b24uYm9uZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYmFzZU1hdHJpeCA9IE1hdHJpeC5JZGVudGl0eSgpO1xyXG4gICAgICAgICAgICBjb25zdCBib25lSW5kZXggPSBiYWJ5bG9uQm9uZS5faW5kZXghO1xyXG4gICAgICAgICAgICBpZiAoaW52ZXJzZUJpbmRNYXRyaWNlc0RhdGEgJiYgYm9uZUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgTWF0cml4LkZyb21BcnJheVRvUmVmKGludmVyc2VCaW5kTWF0cmljZXNEYXRhLCBib25lSW5kZXggKiAxNiwgYmFzZU1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBiYXNlTWF0cml4LmludmVydFRvUmVmKGJhc2VNYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBiYWJ5bG9uUGFyZW50Qm9uZSA9IGJhYnlsb25Cb25lLmdldFBhcmVudCgpO1xyXG4gICAgICAgICAgICBpZiAoYmFieWxvblBhcmVudEJvbmUpIHtcclxuICAgICAgICAgICAgICAgIGJhc2VNYXRyaXgubXVsdGlwbHlUb1JlZihiYWJ5bG9uUGFyZW50Qm9uZS5nZXRBYnNvbHV0ZUludmVyc2VCaW5kTWF0cml4KCksIGJhc2VNYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYWJ5bG9uQm9uZS51cGRhdGVNYXRyaXgoYmFzZU1hdHJpeCwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgYmFieWxvbkJvbmUuX3VwZGF0ZUFic29sdXRlQmluZE1hdHJpY2VzKHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXROb2RlTWF0cml4KG5vZGU6IElOb2RlKTogTWF0cml4IHtcclxuICAgICAgICByZXR1cm4gbm9kZS5tYXRyaXhcclxuICAgICAgICAgICAgPyBNYXRyaXguRnJvbUFycmF5KG5vZGUubWF0cml4KVxyXG4gICAgICAgICAgICA6IE1hdHJpeC5Db21wb3NlKFxyXG4gICAgICAgICAgICAgICAgICBub2RlLnNjYWxlID8gVmVjdG9yMy5Gcm9tQXJyYXkobm9kZS5zY2FsZSkgOiBWZWN0b3IzLk9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICBub2RlLnJvdGF0aW9uID8gUXVhdGVybmlvbi5Gcm9tQXJyYXkobm9kZS5yb3RhdGlvbikgOiBRdWF0ZXJuaW9uLklkZW50aXR5KCksXHJcbiAgICAgICAgICAgICAgICAgIG5vZGUudHJhbnNsYXRpb24gPyBWZWN0b3IzLkZyb21BcnJheShub2RlLnRyYW5zbGF0aW9uKSA6IFZlY3RvcjMuWmVybygpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ2xURiBjYW1lcmEuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBnbFRGIGNhbWVyYSBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGFzc2lnbiBBIGZ1bmN0aW9uIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIEJhYnlsb24gY2FtZXJhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRDYW1lcmFBc3luYyhjb250ZXh0OiBzdHJpbmcsIGNhbWVyYTogSUNhbWVyYSwgYXNzaWduOiAoYmFieWxvbkNhbWVyYTogQ2FtZXJhKSA9PiB2b2lkID0gKCkgPT4ge30pOiBQcm9taXNlPENhbWVyYT4ge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvblByb21pc2UgPSB0aGlzLl9leHRlbnNpb25zTG9hZENhbWVyYUFzeW5jKGNvbnRleHQsIGNhbWVyYSwgYXNzaWduKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9nT3BlbihgJHtjb250ZXh0fSAke2NhbWVyYS5uYW1lIHx8IFwiXCJ9YCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISF0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICBjb25zdCBiYWJ5bG9uQ2FtZXJhID0gbmV3IEZyZWVDYW1lcmEoY2FtZXJhLm5hbWUgfHwgYGNhbWVyYSR7Y2FtZXJhLmluZGV4fWAsIFZlY3RvcjMuWmVybygpLCB0aGlzLl9iYWJ5bG9uU2NlbmUsIGZhbHNlKTtcclxuICAgICAgICBiYWJ5bG9uQ2FtZXJhLl9wYXJlbnRDb250YWluZXIgPSB0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIGNhbWVyYS5fYmFieWxvbkNhbWVyYSA9IGJhYnlsb25DYW1lcmE7XHJcblxyXG4gICAgICAgIC8vIGdsVEYgY2FtZXJhcyBsb29rIHRvd2FyZHMgdGhlIGxvY2FsIC1aIGF4aXMuXHJcbiAgICAgICAgYmFieWxvbkNhbWVyYS5zZXRUYXJnZXQobmV3IFZlY3RvcjMoMCwgMCwgLTEpKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChjYW1lcmEudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIENhbWVyYVR5cGUuUEVSU1BFQ1RJVkU6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcnNwZWN0aXZlID0gY2FtZXJhLnBlcnNwZWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwZXJzcGVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogQ2FtZXJhIHBlcnNwZWN0aXZlIHByb3BlcnRpZXMgYXJlIG1pc3NpbmdgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQ2FtZXJhLmZvdiA9IHBlcnNwZWN0aXZlLnlmb3Y7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQ2FtZXJhLm1pblogPSBwZXJzcGVjdGl2ZS56bmVhcjtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25DYW1lcmEubWF4WiA9IHBlcnNwZWN0aXZlLnpmYXIgfHwgMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhVHlwZS5PUlRIT0dSQVBISUM6IHtcclxuICAgICAgICAgICAgICAgIGlmICghY2FtZXJhLm9ydGhvZ3JhcGhpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogQ2FtZXJhIG9ydGhvZ3JhcGhpYyBwcm9wZXJ0aWVzIGFyZSBtaXNzaW5nYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYmFieWxvbkNhbWVyYS5tb2RlID0gQ2FtZXJhLk9SVEhPR1JBUEhJQ19DQU1FUkE7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQ2FtZXJhLm9ydGhvTGVmdCA9IC1jYW1lcmEub3J0aG9ncmFwaGljLnhtYWc7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQ2FtZXJhLm9ydGhvUmlnaHQgPSBjYW1lcmEub3J0aG9ncmFwaGljLnhtYWc7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQ2FtZXJhLm9ydGhvQm90dG9tID0gLWNhbWVyYS5vcnRob2dyYXBoaWMueW1hZztcclxuICAgICAgICAgICAgICAgIGJhYnlsb25DYW1lcmEub3J0aG9Ub3AgPSBjYW1lcmEub3J0aG9ncmFwaGljLnltYWc7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQ2FtZXJhLm1pblogPSBjYW1lcmEub3J0aG9ncmFwaGljLnpuZWFyO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbkNhbWVyYS5tYXhaID0gY2FtZXJhLm9ydGhvZ3JhcGhpYy56ZmFyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBJbnZhbGlkIGNhbWVyYSB0eXBlICgke2NhbWVyYS50eXBlfSlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgR0xURkxvYWRlci5BZGRQb2ludGVyTWV0YWRhdGEoYmFieWxvbkNhbWVyYSwgY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Lm9uQ2FtZXJhTG9hZGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoYmFieWxvbkNhbWVyYSk7XHJcbiAgICAgICAgYXNzaWduKGJhYnlsb25DYW1lcmEpO1xyXG5cclxuICAgICAgICB0aGlzLmxvZ0Nsb3NlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYWJ5bG9uQ2FtZXJhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRBbmltYXRpb25zQXN5bmMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2dsdGYuYW5pbWF0aW9ucztcclxuICAgICAgICBpZiAoIWFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTx2b2lkPj4oKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaW5kZXhdO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uQXN5bmMoYC9hbmltYXRpb25zLyR7YW5pbWF0aW9uLmluZGV4fWAsIGFuaW1hdGlvbikudGhlbigoYW5pbWF0aW9uR3JvdXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIGFuaW1hdGlvbiBncm91cCBpZiBpdCBlbmRlZCB1cCBub3QgaGF2aW5nIGFueSBhbmltYXRpb25zIGluIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25Hcm91cC50YXJnZXRlZEFuaW1hdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkdyb3VwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ2xURiBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBnbFRGIGFuaW1hdGlvbiBwcm9wZXJ0eVxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIEJhYnlsb24gYW5pbWF0aW9uIGdyb3VwIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRBbmltYXRpb25Bc3luYyhjb250ZXh0OiBzdHJpbmcsIGFuaW1hdGlvbjogSUFuaW1hdGlvbik6IFByb21pc2U8QW5pbWF0aW9uR3JvdXA+IHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fZXh0ZW5zaW9uc0xvYWRBbmltYXRpb25Bc3luYyhjb250ZXh0LCBhbmltYXRpb24pO1xyXG4gICAgICAgIGlmIChwcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgICAgIHJldHVybiBpbXBvcnQoXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0aW9uR3JvdXBcIikudGhlbigoeyBBbmltYXRpb25Hcm91cCB9KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISF0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29uc3QgYmFieWxvbkFuaW1hdGlvbkdyb3VwID0gbmV3IEFuaW1hdGlvbkdyb3VwKGFuaW1hdGlvbi5uYW1lIHx8IGBhbmltYXRpb24ke2FuaW1hdGlvbi5pbmRleH1gLCB0aGlzLl9iYWJ5bG9uU2NlbmUpO1xyXG4gICAgICAgICAgICBiYWJ5bG9uQW5pbWF0aW9uR3JvdXAuX3BhcmVudENvbnRhaW5lciA9IHRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhbmltYXRpb24uX2JhYnlsb25BbmltYXRpb25Hcm91cCA9IGJhYnlsb25BbmltYXRpb25Hcm91cDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgICAgICBBcnJheUl0ZW0uQXNzaWduKGFuaW1hdGlvbi5jaGFubmVscyk7XHJcbiAgICAgICAgICAgIEFycmF5SXRlbS5Bc3NpZ24oYW5pbWF0aW9uLnNhbXBsZXJzKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBhbmltYXRpb24uY2hhbm5lbHMpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZEFuaW1hdGlvbkNoYW5uZWxBc3luYyhgJHtjb250ZXh0fS9jaGFubmVscy8ke2NoYW5uZWwuaW5kZXh9YCwgY29udGV4dCwgYW5pbWF0aW9uLCBjaGFubmVsLCAoYmFieWxvblRhcmdldCwgYmFieWxvbkFuaW1hdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uVGFyZ2V0LmFuaW1hdGlvbnMgPSBiYWJ5bG9uVGFyZ2V0LmFuaW1hdGlvbnMgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25UYXJnZXQuYW5pbWF0aW9ucy5wdXNoKGJhYnlsb25BbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uQW5pbWF0aW9uR3JvdXAuYWRkVGFyZ2V0ZWRBbmltYXRpb24oYmFieWxvbkFuaW1hdGlvbiwgYmFieWxvblRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uQW5pbWF0aW9uR3JvdXAubm9ybWFsaXplKDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhYnlsb25BbmltYXRpb25Hcm91cDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKiBMb2FkcyBhIGdsVEYgYW5pbWF0aW9uIGNoYW5uZWwuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uQ29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgYW5pbWF0aW9uIHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGdsVEYgYW5pbWF0aW9uIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgZ2xURiBhbmltYXRpb24gY2hhbm5lbCBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIG9uTG9hZCBDYWxsZWQgZm9yIGVhY2ggYW5pbWF0aW9uIGxvYWRlZFxyXG4gICAgICogQHJldHVybnMgQSB2b2lkIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBfbG9hZEFuaW1hdGlvbkNoYW5uZWxBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uQ29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbjogSUFuaW1hdGlvbixcclxuICAgICAgICBjaGFubmVsOiBJQW5pbWF0aW9uQ2hhbm5lbCxcclxuICAgICAgICBvbkxvYWQ6IChiYWJ5bG9uQW5pbWF0YWJsZTogSUFuaW1hdGFibGUsIGJhYnlsb25BbmltYXRpb246IEFuaW1hdGlvbikgPT4gdm9pZFxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNMb2FkQW5pbWF0aW9uQ2hhbm5lbEFzeW5jKGNvbnRleHQsIGFuaW1hdGlvbkNvbnRleHQsIGFuaW1hdGlvbiwgY2hhbm5lbCwgb25Mb2FkKTtcclxuICAgICAgICBpZiAocHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjaGFubmVsLnRhcmdldC5ub2RlID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS90YXJnZXQvbm9kZWAsIHRoaXMuX2dsdGYubm9kZXMsIGNoYW5uZWwudGFyZ2V0Lm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXRQYXRoID0gY2hhbm5lbC50YXJnZXQucGF0aDtcclxuICAgICAgICBjb25zdCBwYXRoSXNXZWlnaHRzID0gY2hhbm5lbFRhcmdldFBhdGggPT09IEFuaW1hdGlvbkNoYW5uZWxUYXJnZXRQYXRoLldFSUdIVFM7XHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBhbmltYXRpb25zIHRoYXQgaGF2ZSBubyBhbmltYXRpb24gdGFyZ2V0cy5cclxuICAgICAgICBpZiAoKHBhdGhJc1dlaWdodHMgJiYgIXRhcmdldE5vZGUuX251bU1vcnBoVGFyZ2V0cykgfHwgKCFwYXRoSXNXZWlnaHRzICYmICF0YXJnZXROb2RlLl9iYWJ5bG9uVHJhbnNmb3JtTm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG9uJ3QgbG9hZCBub2RlIGFuaW1hdGlvbnMgaWYgZGlzYWJsZWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJlbnQubG9hZE5vZGVBbmltYXRpb25zICYmICFwYXRoSXNXZWlnaHRzICYmICF0YXJnZXROb2RlLl9pc0pvaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXN5bmMtbG9hZCB0aGUgYW5pbWF0aW9uIHNhbXBsZXIgdG8gcHJvdmlkZSB0aGUgaW50ZXJwb2xhdGlvbiBvZiB0aGUgY2hhbm5lbFRhcmdldFBhdGhcclxuICAgICAgICBhd2FpdCBpbXBvcnQoXCIuL2dsVEZMb2FkZXJBbmltYXRpb25cIik7XHJcblxyXG4gICAgICAgIGxldCBwcm9wZXJ0aWVzOiBJSW50ZXJwb2xhdGlvblByb3BlcnR5SW5mb1tdO1xyXG4gICAgICAgIHN3aXRjaCAoY2hhbm5lbFRhcmdldFBhdGgpIHtcclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25DaGFubmVsVGFyZ2V0UGF0aC5UUkFOU0xBVElPTjoge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IEdldE1hcHBpbmdGb3JLZXkoXCIvbm9kZXMve30vdHJhbnNsYXRpb25cIik/LmludGVycG9sYXRpb24hO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25DaGFubmVsVGFyZ2V0UGF0aC5ST1RBVElPTjoge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IEdldE1hcHBpbmdGb3JLZXkoXCIvbm9kZXMve30vcm90YXRpb25cIik/LmludGVycG9sYXRpb24hO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25DaGFubmVsVGFyZ2V0UGF0aC5TQ0FMRToge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IEdldE1hcHBpbmdGb3JLZXkoXCIvbm9kZXMve30vc2NhbGVcIik/LmludGVycG9sYXRpb24hO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25DaGFubmVsVGFyZ2V0UGF0aC5XRUlHSFRTOiB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gR2V0TWFwcGluZ0ZvcktleShcIi9ub2Rlcy97fS93ZWlnaHRzXCIpPy5pbnRlcnBvbGF0aW9uITtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fS90YXJnZXQvcGF0aDogSW52YWxpZCB2YWx1ZSAoJHtjaGFubmVsLnRhcmdldC5wYXRofSlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzdGF5IHNhZmVcclxuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9L3RhcmdldC9wYXRoOiBDb3VsZCBub3QgZmluZCBpbnRlcnBvbGF0aW9uIHByb3BlcnRpZXMgZm9yIHRhcmdldCBwYXRoICgke2NoYW5uZWwudGFyZ2V0LnBhdGh9KWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5mbzogSU9iamVjdEluZm88SUludGVycG9sYXRpb25Qcm9wZXJ0eUluZm9bXT4gPSB7XHJcbiAgICAgICAgICAgIG9iamVjdDogdGFyZ2V0Tm9kZSxcclxuICAgICAgICAgICAgaW5mbzogcHJvcGVydGllcyxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZEFuaW1hdGlvbkNoYW5uZWxGcm9tVGFyZ2V0SW5mb0FzeW5jKGNvbnRleHQsIGFuaW1hdGlvbkNvbnRleHQsIGFuaW1hdGlvbiwgY2hhbm5lbCwgdGFyZ2V0SW5mbywgb25Mb2FkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqIExvYWRzIGEgZ2xURiBhbmltYXRpb24gY2hhbm5lbC5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb25Db250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBhbmltYXRpb24gd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgZ2xURiBhbmltYXRpb24gcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBnbFRGIGFuaW1hdGlvbiBjaGFubmVsIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0SW5mbyBUaGUgZ2xURiB0YXJnZXQgYW5kIHByb3BlcnRpZXNcclxuICAgICAqIEBwYXJhbSBvbkxvYWQgQ2FsbGVkIGZvciBlYWNoIGFuaW1hdGlvbiBsb2FkZWRcclxuICAgICAqIEByZXR1cm5zIEEgdm9pZCBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX2xvYWRBbmltYXRpb25DaGFubmVsRnJvbVRhcmdldEluZm9Bc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uQ29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbjogSUFuaW1hdGlvbixcclxuICAgICAgICBjaGFubmVsOiBJQW5pbWF0aW9uQ2hhbm5lbCxcclxuICAgICAgICB0YXJnZXRJbmZvOiBJT2JqZWN0SW5mbzxJSW50ZXJwb2xhdGlvblByb3BlcnR5SW5mb1tdPixcclxuICAgICAgICBvbkxvYWQ6IChiYWJ5bG9uQW5pbWF0YWJsZTogSUFuaW1hdGFibGUsIGJhYnlsb25BbmltYXRpb246IEFuaW1hdGlvbikgPT4gdm9pZFxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgZnBzID0gdGhpcy5wYXJlbnQudGFyZ2V0RnBzO1xyXG4gICAgICAgIGNvbnN0IGludmZwcyA9IDEgLyBmcHM7XHJcblxyXG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L3NhbXBsZXJgLCBhbmltYXRpb24uc2FtcGxlcnMsIGNoYW5uZWwuc2FtcGxlcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRBbmltYXRpb25TYW1wbGVyQXN5bmMoYCR7YW5pbWF0aW9uQ29udGV4dH0vc2FtcGxlcnMvJHtjaGFubmVsLnNhbXBsZXJ9YCwgc2FtcGxlcikudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbnVtQW5pbWF0aW9ucyA9IDA7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRJbmZvLm9iamVjdDtcclxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlJbmZvcyA9IHRhcmdldEluZm8uaW5mbztcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgZnJvbSB0aGUgcmVhZCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8gR0xURiB2YWx1ZXMgbWF5IGJlIGRpc3BhdGNoZWQgdG8gc2V2ZXJhbCBCYWJ5bG9uIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBiYXNlQ29sb3JGYWN0b3IgW2ByYCwgYGdgLCBgYmAsIGBhYF0gaXMgZGlzcGF0Y2hlZCB0b1xyXG4gICAgICAgICAgICAvLyAtIGFsYmVkb0NvbG9yIGFzIENvbG9yMyhgcmAsIGBnYCwgYGJgKVxyXG4gICAgICAgICAgICAvLyAtIGFscGhhIGFzIGBhYFxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5SW5mbyBvZiBwcm9wZXJ0eUluZm9zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpZGUgPSBwcm9wZXJ0eUluZm8uZ2V0U3RyaWRlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGRhdGEuaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBkYXRhLm91dHB1dDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXk8SUFuaW1hdGlvbktleT4oaW5wdXQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5pbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TYW1wbGVySW50ZXJwb2xhdGlvbi5TVEVQOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbnB1dC5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydHlJbmZvLmdldFZhbHVlKHRhcmdldCwgb3V0cHV0LCBvdXRwdXRPZmZzZXQsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0T2Zmc2V0ICs9IHN0cmlkZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzW2luZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZTogaW5wdXRbaW5kZXhdICogZnBzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBBbmltYXRpb25LZXlJbnRlcnBvbGF0aW9uLlNURVAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEFuaW1hdGlvblNhbXBsZXJJbnRlcnBvbGF0aW9uLkNVQklDU1BMSU5FOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbnB1dC5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluVGFuZ2VudCA9IHByb3BlcnR5SW5mby5nZXRWYWx1ZSh0YXJnZXQsIG91dHB1dCwgb3V0cHV0T2Zmc2V0LCBpbnZmcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0T2Zmc2V0ICs9IHN0cmlkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydHlJbmZvLmdldFZhbHVlKHRhcmdldCwgb3V0cHV0LCBvdXRwdXRPZmZzZXQsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0T2Zmc2V0ICs9IHN0cmlkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dFRhbmdlbnQgPSBwcm9wZXJ0eUluZm8uZ2V0VmFsdWUodGFyZ2V0LCBvdXRwdXQsIG91dHB1dE9mZnNldCwgaW52ZnBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dE9mZnNldCArPSBzdHJpZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c1tpbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWU6IGlucHV0W2luZGV4XSAqIGZwcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblRhbmdlbnQ6IGluVGFuZ2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0VGFuZ2VudDogb3V0VGFuZ2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU2FtcGxlckludGVycG9sYXRpb24uTElORUFSOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbnB1dC5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydHlJbmZvLmdldFZhbHVlKHRhcmdldCwgb3V0cHV0LCBvdXRwdXRPZmZzZXQsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0T2Zmc2V0ICs9IHN0cmlkZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzW2luZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZTogaW5wdXRbaW5kZXhdICogZnBzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke2FuaW1hdGlvbi5uYW1lIHx8IGBhbmltYXRpb24ke2FuaW1hdGlvbi5pbmRleH1gfV9jaGFubmVsJHtjaGFubmVsLmluZGV4fV8ke251bUFuaW1hdGlvbnN9YDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uQW5pbWF0aW9ucyA9IHByb3BlcnR5SW5mby5idWlsZEFuaW1hdGlvbnModGFyZ2V0LCBuYW1lLCBmcHMsIGtleXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmFieWxvbkFuaW1hdGlvbiBvZiBiYWJ5bG9uQW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1BbmltYXRpb25zKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZChiYWJ5bG9uQW5pbWF0aW9uLmJhYnlsb25BbmltYXRhYmxlLCBiYWJ5bG9uQW5pbWF0aW9uLmJhYnlsb25BbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRBbmltYXRpb25TYW1wbGVyQXN5bmMoY29udGV4dDogc3RyaW5nLCBzYW1wbGVyOiBJQW5pbWF0aW9uU2FtcGxlcik6IFByb21pc2U8X0lBbmltYXRpb25TYW1wbGVyRGF0YT4ge1xyXG4gICAgICAgIGlmIChzYW1wbGVyLl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVyLl9kYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHNhbXBsZXIuaW50ZXJwb2xhdGlvbiB8fCBBbmltYXRpb25TYW1wbGVySW50ZXJwb2xhdGlvbi5MSU5FQVI7XHJcbiAgICAgICAgc3dpdGNoIChpbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU2FtcGxlckludGVycG9sYXRpb24uU1RFUDpcclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TYW1wbGVySW50ZXJwb2xhdGlvbi5MSU5FQVI6XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU2FtcGxlckludGVycG9sYXRpb24uQ1VCSUNTUExJTkU6IHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fS9pbnRlcnBvbGF0aW9uOiBJbnZhbGlkIHZhbHVlICgke3NhbXBsZXIuaW50ZXJwb2xhdGlvbn0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2lucHV0YCwgdGhpcy5fZ2x0Zi5hY2Nlc3NvcnMsIHNhbXBsZXIuaW5wdXQpO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29yID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9vdXRwdXRgLCB0aGlzLl9nbHRmLmFjY2Vzc29ycywgc2FtcGxlci5vdXRwdXQpO1xyXG4gICAgICAgIHNhbXBsZXIuX2RhdGEgPSBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRGbG9hdEFjY2Vzc29yQXN5bmMoYC9hY2Nlc3NvcnMvJHtpbnB1dEFjY2Vzc29yLmluZGV4fWAsIGlucHV0QWNjZXNzb3IpLFxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkRmxvYXRBY2Nlc3NvckFzeW5jKGAvYWNjZXNzb3JzLyR7b3V0cHV0QWNjZXNzb3IuaW5kZXh9YCwgb3V0cHV0QWNjZXNzb3IpLFxyXG4gICAgICAgIF0pLnRoZW4oKFtpbnB1dERhdGEsIG91dHB1dERhdGFdKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXREYXRhLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvbixcclxuICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0RGF0YSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNhbXBsZXIuX2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIGdsVEYgYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGJ1ZmZlciBUaGUgZ2xURiBidWZmZXIgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBieXRlT2Zmc2V0IFRoZSBieXRlIG9mZnNldCB0byB1c2VcclxuICAgICAqIEBwYXJhbSBieXRlTGVuZ3RoIFRoZSBieXRlIGxlbmd0aCB0byB1c2VcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBkYXRhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRCdWZmZXJBc3luYyhjb250ZXh0OiBzdHJpbmcsIGJ1ZmZlcjogSUJ1ZmZlciwgYnl0ZU9mZnNldDogbnVtYmVyLCBieXRlTGVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyVmlldz4ge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvblByb21pc2UgPSB0aGlzLl9leHRlbnNpb25zTG9hZEJ1ZmZlckFzeW5jKGNvbnRleHQsIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvblByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblByb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWJ1ZmZlci5fZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLnVyaSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyLl9kYXRhID0gdGhpcy5sb2FkVXJpQXN5bmMoYCR7Y29udGV4dH0vdXJpYCwgYnVmZmVyLCBidWZmZXIudXJpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYmluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBVcmkgaXMgbWlzc2luZyBvciB0aGUgYmluYXJ5IGdsVEYgaXMgbWlzc2luZyBpdHMgYmluYXJ5IGNodW5rYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnVmZmVyLl9kYXRhID0gdGhpcy5fYmluLnJlYWRBc3luYygwLCBidWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBidWZmZXIuX2RhdGEudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQgKyBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiAke2UubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBnbFRGIGJ1ZmZlciB2aWV3LlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGJ1ZmZlclZpZXcgVGhlIGdsVEYgYnVmZmVyIHZpZXcgcHJvcGVydHlcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBkYXRhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRCdWZmZXJWaWV3QXN5bmMoY29udGV4dDogc3RyaW5nLCBidWZmZXJWaWV3OiBJQnVmZmVyVmlldyk6IFByb21pc2U8QXJyYXlCdWZmZXJWaWV3PiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uUHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNMb2FkQnVmZmVyVmlld0FzeW5jKGNvbnRleHQsIGJ1ZmZlclZpZXcpO1xyXG4gICAgICAgIGlmIChleHRlbnNpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25Qcm9taXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcuX2RhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlclZpZXcuX2RhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBidWZmZXIgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2J1ZmZlcmAsIHRoaXMuX2dsdGYuYnVmZmVycywgYnVmZmVyVmlldy5idWZmZXIpO1xyXG4gICAgICAgIGJ1ZmZlclZpZXcuX2RhdGEgPSB0aGlzLmxvYWRCdWZmZXJBc3luYyhgL2J1ZmZlcnMvJHtidWZmZXIuaW5kZXh9YCwgYnVmZmVyLCBidWZmZXJWaWV3LmJ5dGVPZmZzZXQgfHwgMCwgYnVmZmVyVmlldy5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclZpZXcuX2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZEFjY2Vzc29yQXN5bmMoY29udGV4dDogc3RyaW5nLCBhY2Nlc3NvcjogSUFjY2Vzc29yLCBjb25zdHJ1Y3RvcjogVHlwZWRBcnJheUNvbnN0cnVjdG9yKTogUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+IHtcclxuICAgICAgICBpZiAoYWNjZXNzb3IuX2RhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc29yLl9kYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IEdMVEZMb2FkZXIuX0dldE51bUNvbXBvbmVudHMoY29udGV4dCwgYWNjZXNzb3IudHlwZSk7XHJcbiAgICAgICAgY29uc3QgYnl0ZVN0cmlkZSA9IG51bUNvbXBvbmVudHMgKiBWZXJ0ZXhCdWZmZXIuR2V0VHlwZUJ5dGVMZW5ndGgoYWNjZXNzb3IuY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbnVtQ29tcG9uZW50cyAqIGFjY2Vzc29yLmNvdW50O1xyXG5cclxuICAgICAgICBpZiAoYWNjZXNzb3IuYnVmZmVyVmlldyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYWNjZXNzb3IuX2RhdGEgPSBQcm9taXNlLnJlc29sdmUobmV3IGNvbnN0cnVjdG9yKGxlbmd0aCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2J1ZmZlclZpZXdgLCB0aGlzLl9nbHRmLmJ1ZmZlclZpZXdzLCBhY2Nlc3Nvci5idWZmZXJWaWV3KTtcclxuICAgICAgICAgICAgYWNjZXNzb3IuX2RhdGEgPSB0aGlzLmxvYWRCdWZmZXJWaWV3QXN5bmMoYC9idWZmZXJWaWV3cy8ke2J1ZmZlclZpZXcuaW5kZXh9YCwgYnVmZmVyVmlldykudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT09IEFjY2Vzc29yQ29tcG9uZW50VHlwZS5GTE9BVCAmJiAhYWNjZXNzb3Iubm9ybWFsaXplZCAmJiAoIWJ1ZmZlclZpZXcuYnl0ZVN0cmlkZSB8fCBidWZmZXJWaWV3LmJ5dGVTdHJpZGUgPT09IGJ5dGVTdHJpZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuX0dldFR5cGVkQXJyYXkoY29udGV4dCwgYWNjZXNzb3IuY29tcG9uZW50VHlwZSwgZGF0YSwgYWNjZXNzb3IuYnl0ZU9mZnNldCwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyBjb25zdHJ1Y3RvcihsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlcnRleEJ1ZmZlci5Gb3JFYWNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci5ieXRlT2Zmc2V0IHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclZpZXcuYnl0ZVN0cmlkZSB8fCBieXRlU3RyaWRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Db21wb25lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3Iubm9ybWFsaXplZCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheVtpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFjY2Vzc29yLnNwYXJzZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzcGFyc2UgPSBhY2Nlc3Nvci5zcGFyc2U7XHJcbiAgICAgICAgICAgIGFjY2Vzc29yLl9kYXRhID0gYWNjZXNzb3IuX2RhdGEudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IGRhdGEgYXMgVHlwZWRBcnJheTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGljZXNCdWZmZXJWaWV3ID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9zcGFyc2UvaW5kaWNlcy9idWZmZXJWaWV3YCwgdGhpcy5fZ2x0Zi5idWZmZXJWaWV3cywgc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXNCdWZmZXJWaWV3ID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9zcGFyc2UvdmFsdWVzL2J1ZmZlclZpZXdgLCB0aGlzLl9nbHRmLmJ1ZmZlclZpZXdzLCBzcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRCdWZmZXJWaWV3QXN5bmMoYC9idWZmZXJWaWV3cy8ke2luZGljZXNCdWZmZXJWaWV3LmluZGV4fWAsIGluZGljZXNCdWZmZXJWaWV3KSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRCdWZmZXJWaWV3QXN5bmMoYC9idWZmZXJWaWV3cy8ke3ZhbHVlc0J1ZmZlclZpZXcuaW5kZXh9YCwgdmFsdWVzQnVmZmVyVmlldyksXHJcbiAgICAgICAgICAgICAgICBdKS50aGVuKChbaW5kaWNlc0RhdGEsIHZhbHVlc0RhdGFdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IEdMVEZMb2FkZXIuX0dldFR5cGVkQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2NvbnRleHR9L3NwYXJzZS9pbmRpY2VzYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc0RhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYXJzZS5jb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICkgYXMgSW5kaWNlc0FycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFyc2VMZW5ndGggPSBudW1Db21wb25lbnRzICogc3BhcnNlLmNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZXM6IFR5cGVkQXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3Nvci5jb21wb25lbnRUeXBlID09PSBBY2Nlc3NvckNvbXBvbmVudFR5cGUuRkxPQVQgJiYgIWFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gR0xURkxvYWRlci5fR2V0VHlwZWRBcnJheShgJHtjb250ZXh0fS9zcGFyc2UvdmFsdWVzYCwgYWNjZXNzb3IuY29tcG9uZW50VHlwZSwgdmFsdWVzRGF0YSwgc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0LCBzcGFyc2VMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYXJzZURhdGEgPSBHTFRGTG9hZGVyLl9HZXRUeXBlZEFycmF5KGAke2NvbnRleHR9L3NwYXJzZS92YWx1ZXNgLCBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLCB2YWx1ZXNEYXRhLCBzcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQsIHNwYXJzZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBjb25zdHJ1Y3RvcihzcGFyc2VMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJ0ZXhCdWZmZXIuRm9yRWFjaChzcGFyc2VEYXRhLCAwLCBieXRlU3RyaWRlLCBudW1Db21wb25lbnRzLCBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLCB2YWx1ZXMubGVuZ3RoLCBhY2Nlc3Nvci5ub3JtYWxpemVkIHx8IGZhbHNlLCAodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlc0luZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRpY2VzSW5kZXggPSAwOyBpbmRpY2VzSW5kZXggPCBpbmRpY2VzLmxlbmd0aDsgaW5kaWNlc0luZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFJbmRleCA9IGluZGljZXNbaW5kaWNlc0luZGV4XSAqIG51bUNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbXBvbmVudEluZGV4ID0gMDsgY29tcG9uZW50SW5kZXggPCBudW1Db21wb25lbnRzOyBjb21wb25lbnRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5W2RhdGFJbmRleCsrXSA9IHZhbHVlc1t2YWx1ZXNJbmRleCsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYWNjZXNzb3IuX2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIF9sb2FkRmxvYXRBY2Nlc3NvckFzeW5jKGNvbnRleHQ6IHN0cmluZywgYWNjZXNzb3I6IElBY2Nlc3Nvcik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRBY2Nlc3NvckFzeW5jKGNvbnRleHQsIGFjY2Vzc29yLCBGbG9hdDMyQXJyYXkpIGFzIFByb21pc2U8RmxvYXQzMkFycmF5PjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX2xvYWRJbmRpY2VzQWNjZXNzb3JBc3luYyhjb250ZXh0OiBzdHJpbmcsIGFjY2Vzc29yOiBJQWNjZXNzb3IpOiBQcm9taXNlPEluZGljZXNBcnJheT4ge1xyXG4gICAgICAgIGlmIChhY2Nlc3Nvci50eXBlICE9PSBBY2Nlc3NvclR5cGUuU0NBTEFSKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fS90eXBlOiBJbnZhbGlkIHZhbHVlICR7YWNjZXNzb3IudHlwZX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgYWNjZXNzb3IuY29tcG9uZW50VHlwZSAhPT0gQWNjZXNzb3JDb21wb25lbnRUeXBlLlVOU0lHTkVEX0JZVEUgJiZcclxuICAgICAgICAgICAgYWNjZXNzb3IuY29tcG9uZW50VHlwZSAhPT0gQWNjZXNzb3JDb21wb25lbnRUeXBlLlVOU0lHTkVEX1NIT1JUICYmXHJcbiAgICAgICAgICAgIGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgIT09IEFjY2Vzc29yQ29tcG9uZW50VHlwZS5VTlNJR05FRF9JTlRcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9L2NvbXBvbmVudFR5cGU6IEludmFsaWQgdmFsdWUgJHthY2Nlc3Nvci5jb21wb25lbnRUeXBlfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFjY2Vzc29yLl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3Nvci5fZGF0YSBhcyBQcm9taXNlPEluZGljZXNBcnJheT47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWNjZXNzb3Iuc3BhcnNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gR0xURkxvYWRlci5fR2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKGAke2NvbnRleHR9L2NvbXBvbmVudFR5cGVgLCBhY2Nlc3Nvci5jb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgYWNjZXNzb3IuX2RhdGEgPSB0aGlzLl9sb2FkQWNjZXNzb3JBc3luYyhjb250ZXh0LCBhY2Nlc3NvciwgY29uc3RydWN0b3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2J1ZmZlclZpZXdgLCB0aGlzLl9nbHRmLmJ1ZmZlclZpZXdzLCBhY2Nlc3Nvci5idWZmZXJWaWV3KTtcclxuICAgICAgICAgICAgYWNjZXNzb3IuX2RhdGEgPSB0aGlzLmxvYWRCdWZmZXJWaWV3QXN5bmMoYC9idWZmZXJWaWV3cy8ke2J1ZmZlclZpZXcuaW5kZXh9YCwgYnVmZmVyVmlldykudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdMVEZMb2FkZXIuX0dldFR5cGVkQXJyYXkoY29udGV4dCwgYWNjZXNzb3IuY29tcG9uZW50VHlwZSwgZGF0YSwgYWNjZXNzb3IuYnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhY2Nlc3Nvci5fZGF0YSBhcyBQcm9taXNlPEluZGljZXNBcnJheT47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIF9sb2FkVmVydGV4QnVmZmVyVmlld0FzeW5jKGJ1ZmZlclZpZXc6IElCdWZmZXJWaWV3KTogUHJvbWlzZTxCdWZmZXI+IHtcclxuICAgICAgICBpZiAoYnVmZmVyVmlldy5fYmFieWxvbkJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyVmlldy5fYmFieWxvbkJ1ZmZlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2JhYnlsb25TY2VuZS5nZXRFbmdpbmUoKTtcclxuICAgICAgICBidWZmZXJWaWV3Ll9iYWJ5bG9uQnVmZmVyID0gdGhpcy5sb2FkQnVmZmVyVmlld0FzeW5jKGAvYnVmZmVyVmlld3MvJHtidWZmZXJWaWV3LmluZGV4fWAsIGJ1ZmZlclZpZXcpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZW5naW5lLCBkYXRhLCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBidWZmZXJWaWV3Ll9iYWJ5bG9uQnVmZmVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBfbG9hZFZlcnRleEFjY2Vzc29yQXN5bmMoY29udGV4dDogc3RyaW5nLCBhY2Nlc3NvcjogSUFjY2Vzc29yLCBraW5kOiBzdHJpbmcpOiBQcm9taXNlPFZlcnRleEJ1ZmZlcj4ge1xyXG4gICAgICAgIGlmIChhY2Nlc3Nvci5fYmFieWxvblZlcnRleEJ1ZmZlcj8uW2tpbmRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3Nvci5fYmFieWxvblZlcnRleEJ1ZmZlcltraW5kXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYWNjZXNzb3IuX2JhYnlsb25WZXJ0ZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgYWNjZXNzb3IuX2JhYnlsb25WZXJ0ZXhCdWZmZXIgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2JhYnlsb25TY2VuZS5nZXRFbmdpbmUoKTtcclxuXHJcbiAgICAgICAgaWYgKGFjY2Vzc29yLnNwYXJzZSB8fCBhY2Nlc3Nvci5idWZmZXJWaWV3ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhY2Nlc3Nvci5fYmFieWxvblZlcnRleEJ1ZmZlcltraW5kXSA9IHRoaXMuX2xvYWRGbG9hdEFjY2Vzc29yQXN5bmMoY29udGV4dCwgYWNjZXNzb3IpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVydGV4QnVmZmVyKGVuZ2luZSwgZGF0YSwga2luZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJWaWV3ID0gQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9idWZmZXJWaWV3YCwgdGhpcy5fZ2x0Zi5idWZmZXJWaWV3cywgYWNjZXNzb3IuYnVmZmVyVmlldyk7XHJcbiAgICAgICAgICAgIGFjY2Vzc29yLl9iYWJ5bG9uVmVydGV4QnVmZmVyW2tpbmRdID0gdGhpcy5fbG9hZFZlcnRleEJ1ZmZlclZpZXdBc3luYyhidWZmZXJWaWV3KS50aGVuKChiYWJ5bG9uQnVmZmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Db21wb25lbnRzID0gR0xURkxvYWRlci5fR2V0TnVtQ29tcG9uZW50cyhjb250ZXh0LCBhY2Nlc3Nvci50eXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVydGV4QnVmZmVyKFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZSxcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uQnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclZpZXcuYnl0ZVN0cmlkZSxcclxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3IuYnl0ZU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICBudW1Db21wb25lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc29yLmNvbXBvbmVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3Iubm9ybWFsaXplZCxcclxuICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhY2Nlc3Nvci5fYmFieWxvblZlcnRleEJ1ZmZlcltraW5kXTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sb2FkTWF0ZXJpYWxNZXRhbGxpY1JvdWdobmVzc1Byb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIHByb3BlcnRpZXM6IElNYXRlcmlhbFBick1ldGFsbGljUm91Z2huZXNzLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5iYXNlQ29sb3JGYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5hbGJlZG9Db2xvciA9IENvbG9yMy5Gcm9tQXJyYXkocHJvcGVydGllcy5iYXNlQ29sb3JGYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFscGhhID0gcHJvcGVydGllcy5iYXNlQ29sb3JGYWN0b3JbM107XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYWxiZWRvQ29sb3IgPSBDb2xvcjMuV2hpdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLm1ldGFsbGljID0gcHJvcGVydGllcy5tZXRhbGxpY0ZhY3RvciA9PSB1bmRlZmluZWQgPyAxIDogcHJvcGVydGllcy5tZXRhbGxpY0ZhY3RvcjtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnJvdWdobmVzcyA9IHByb3BlcnRpZXMucm91Z2huZXNzRmFjdG9yID09IHVuZGVmaW5lZCA/IDEgOiBwcm9wZXJ0aWVzLnJvdWdobmVzc0ZhY3RvcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmJhc2VDb2xvclRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9iYXNlQ29sb3JUZXh0dXJlYCwgcHJvcGVydGllcy5iYXNlQ29sb3JUZXh0dXJlLCAodGV4dHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBgJHtiYWJ5bG9uTWF0ZXJpYWwubmFtZX0gKEJhc2UgQ29sb3IpYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb1RleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLm5vbkNvbG9yRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlYCwgcHJvcGVydGllcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IGAke2JhYnlsb25NYXRlcmlhbC5uYW1lfSAoTWV0YWxsaWMgUm91Z2huZXNzKWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5tZXRhbGxpY1RleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC51c2VNZXRhbGxuZXNzRnJvbU1ldGFsbGljVGV4dHVyZUJsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnVzZVJvdWdobmVzc0Zyb21NZXRhbGxpY1RleHR1cmVHcmVlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwudXNlUm91Z2huZXNzRnJvbU1ldGFsbGljVGV4dHVyZUFscGhhID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIF9sb2FkTWF0ZXJpYWxBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgbWF0ZXJpYWw6IElNYXRlcmlhbCxcclxuICAgICAgICBiYWJ5bG9uTWVzaDogTnVsbGFibGU8TWVzaD4sXHJcbiAgICAgICAgYmFieWxvbkRyYXdNb2RlOiBudW1iZXIsXHJcbiAgICAgICAgYXNzaWduOiAoYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCkgPT4gdm9pZCA9ICgpID0+IHt9XHJcbiAgICApOiBQcm9taXNlPE1hdGVyaWFsPiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uUHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNMb2FkTWF0ZXJpYWxBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1lc2gsIGJhYnlsb25EcmF3TW9kZSwgYXNzaWduKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hdGVyaWFsLl9kYXRhID0gbWF0ZXJpYWwuX2RhdGEgfHwge307XHJcbiAgICAgICAgbGV0IGJhYnlsb25EYXRhID0gbWF0ZXJpYWwuX2RhdGFbYmFieWxvbkRyYXdNb2RlXTtcclxuICAgICAgICBpZiAoIWJhYnlsb25EYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nT3BlbihgJHtjb250ZXh0fSAke21hdGVyaWFsLm5hbWUgfHwgXCJcIn1gKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGJhYnlsb25NYXRlcmlhbCA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoY29udGV4dCwgbWF0ZXJpYWwsIGJhYnlsb25EcmF3TW9kZSk7XHJcblxyXG4gICAgICAgICAgICBiYWJ5bG9uRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbDogYmFieWxvbk1hdGVyaWFsLFxyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1lc2hlczogW10sXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlOiB0aGlzLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKSxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLl9kYXRhW2JhYnlsb25EcmF3TW9kZV0gPSBiYWJ5bG9uRGF0YTtcclxuXHJcbiAgICAgICAgICAgIEdMVEZMb2FkZXIuQWRkUG9pbnRlck1ldGFkYXRhKGJhYnlsb25NYXRlcmlhbCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5vbk1hdGVyaWFsTG9hZGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoYmFieWxvbk1hdGVyaWFsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9nQ2xvc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYWJ5bG9uTWVzaCkge1xyXG4gICAgICAgICAgICBiYWJ5bG9uRGF0YS5iYWJ5bG9uTWVzaGVzLnB1c2goYmFieWxvbk1lc2gpO1xyXG5cclxuICAgICAgICAgICAgYmFieWxvbk1lc2gub25EaXNwb3NlT2JzZXJ2YWJsZS5hZGRPbmNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYmFieWxvbkRhdGEuYmFieWxvbk1lc2hlcy5pbmRleE9mKGJhYnlsb25NZXNoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uRGF0YS5iYWJ5bG9uTWVzaGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXNzaWduKGJhYnlsb25EYXRhLmJhYnlsb25NYXRlcmlhbCk7XHJcblxyXG4gICAgICAgIHJldHVybiBiYWJ5bG9uRGF0YS5wcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gYmFieWxvbkRhdGEuYmFieWxvbk1hdGVyaWFsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZURlZmF1bHRNYXRlcmlhbChuYW1lOiBzdHJpbmcsIGJhYnlsb25EcmF3TW9kZTogbnVtYmVyKTogTWF0ZXJpYWwge1xyXG4gICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gISF0aGlzLl9hc3NldENvbnRhaW5lcjtcclxuICAgICAgICBjb25zdCBiYWJ5bG9uTWF0ZXJpYWwgPSBuZXcgUEJSTWF0ZXJpYWwobmFtZSwgdGhpcy5fYmFieWxvblNjZW5lKTtcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuX3BhcmVudENvbnRhaW5lciA9IHRoaXMuX2Fzc2V0Q29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuX2JhYnlsb25TY2VuZS5fYmxvY2tFbnRpdHlDb2xsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLy8gTW92ZWQgdG8gbWVzaCBzbyB1c2VyIGNhbiBjaGFuZ2UgbWF0ZXJpYWxzIG9uIGdsdGYgbWVzaGVzOiBiYWJ5bG9uTWF0ZXJpYWwuc2lkZU9yaWVudGF0aW9uID0gdGhpcy5fYmFieWxvblNjZW5lLnVzZVJpZ2h0SGFuZGVkU3lzdGVtID8gTWF0ZXJpYWwuQ291bnRlckNsb2NrV2lzZVNpZGVPcmllbnRhdGlvbiA6IE1hdGVyaWFsLkNsb2NrV2lzZVNpZGVPcmllbnRhdGlvbjtcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuZmlsbE1vZGUgPSBiYWJ5bG9uRHJhd01vZGU7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLmVuYWJsZVNwZWN1bGFyQW50aUFsaWFzaW5nID0gdHJ1ZTtcclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwudXNlUmFkaWFuY2VPdmVyQWxwaGEgPSAhdGhpcy5fcGFyZW50LnRyYW5zcGFyZW5jeUFzQ292ZXJhZ2U7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnVzZVNwZWN1bGFyT3ZlckFscGhhID0gIXRoaXMuX3BhcmVudC50cmFuc3BhcmVuY3lBc0NvdmVyYWdlO1xyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC50cmFuc3BhcmVuY3lNb2RlID0gUEJSTWF0ZXJpYWwuUEJSTUFURVJJQUxfT1BBUVVFO1xyXG4gICAgICAgIGJhYnlsb25NYXRlcmlhbC5tZXRhbGxpYyA9IDE7XHJcbiAgICAgICAgYmFieWxvbk1hdGVyaWFsLnJvdWdobmVzcyA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiBiYWJ5bG9uTWF0ZXJpYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQmFieWxvbiBtYXRlcmlhbCBmcm9tIGEgZ2xURiBtYXRlcmlhbC5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBtYXRlcmlhbCBUaGUgZ2xURiBtYXRlcmlhbCBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGJhYnlsb25EcmF3TW9kZSBUaGUgZHJhdyBtb2RlIGZvciB0aGUgQmFieWxvbiBtYXRlcmlhbFxyXG4gICAgICogQHJldHVybnMgVGhlIEJhYnlsb24gbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZU1hdGVyaWFsKGNvbnRleHQ6IHN0cmluZywgbWF0ZXJpYWw6IElNYXRlcmlhbCwgYmFieWxvbkRyYXdNb2RlOiBudW1iZXIpOiBNYXRlcmlhbCB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uUHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNDcmVhdGVNYXRlcmlhbChjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbkRyYXdNb2RlKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBtYXRlcmlhbC5uYW1lIHx8IGBtYXRlcmlhbCR7bWF0ZXJpYWwuaW5kZXh9YDtcclxuICAgICAgICBjb25zdCBiYWJ5bG9uTWF0ZXJpYWwgPSB0aGlzLl9jcmVhdGVEZWZhdWx0TWF0ZXJpYWwobmFtZSwgYmFieWxvbkRyYXdNb2RlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJhYnlsb25NYXRlcmlhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHByb3BlcnRpZXMgZnJvbSBhIGdsVEYgbWF0ZXJpYWwgaW50byBhIEJhYnlsb24gbWF0ZXJpYWwuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbWF0ZXJpYWwgVGhlIGdsVEYgbWF0ZXJpYWwgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBiYWJ5bG9uTWF0ZXJpYWwgVGhlIEJhYnlsb24gbWF0ZXJpYWxcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25Qcm9taXNlID0gdGhpcy5fZXh0ZW5zaW9uc0xvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5sb2FkTWF0ZXJpYWxCYXNlUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpKTtcclxuXHJcbiAgICAgICAgaWYgKG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZE1hdGVyaWFsTWV0YWxsaWNSb3VnaG5lc3NQcm9wZXJ0aWVzQXN5bmMoYCR7Y29udGV4dH0vcGJyTWV0YWxsaWNSb3VnaG5lc3NgLCBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcywgYmFieWxvbk1hdGVyaWFsKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvYWRNYXRlcmlhbEFscGhhUHJvcGVydGllcyhjb250ZXh0LCBtYXRlcmlhbCwgYmFieWxvbk1hdGVyaWFsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSBub3JtYWwsIG9jY2x1c2lvbiwgYW5kIGVtaXNzaXZlIHByb3BlcnRpZXMgZnJvbSBhIGdsVEYgbWF0ZXJpYWwgaW50byBhIEJhYnlsb24gbWF0ZXJpYWwuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbWF0ZXJpYWwgVGhlIGdsVEYgbWF0ZXJpYWwgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBiYWJ5bG9uTWF0ZXJpYWwgVGhlIEJhYnlsb24gbWF0ZXJpYWxcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbEJhc2VQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCEoYmFieWxvbk1hdGVyaWFsIGluc3RhbmNlb2YgUEJSTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogTWF0ZXJpYWwgdHlwZSBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuZW1pc3NpdmVDb2xvciA9IG1hdGVyaWFsLmVtaXNzaXZlRmFjdG9yID8gQ29sb3IzLkZyb21BcnJheShtYXRlcmlhbC5lbWlzc2l2ZUZhY3RvcikgOiBuZXcgQ29sb3IzKDAsIDAsIDApO1xyXG4gICAgICAgIGlmIChtYXRlcmlhbC5kb3VibGVTaWRlZCkge1xyXG4gICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYmFja0ZhY2VDdWxsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC50d29TaWRlZExpZ2h0aW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXRlcmlhbC5ub3JtYWxUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsLm5vcm1hbFRleHR1cmUubm9uQ29sb3JEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vbm9ybWFsVGV4dHVyZWAsIG1hdGVyaWFsLm5vcm1hbFRleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uYW1lID0gYCR7YmFieWxvbk1hdGVyaWFsLm5hbWV9IChOb3JtYWwpYDtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYnVtcFRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5pbnZlcnROb3JtYWxNYXBYID0gIXRoaXMuX2JhYnlsb25TY2VuZS51c2VSaWdodEhhbmRlZFN5c3RlbTtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmludmVydE5vcm1hbE1hcFkgPSB0aGlzLl9iYWJ5bG9uU2NlbmUudXNlUmlnaHRIYW5kZWRTeXN0ZW07XHJcbiAgICAgICAgICAgIGlmIChtYXRlcmlhbC5ub3JtYWxUZXh0dXJlLnNjYWxlICE9IHVuZGVmaW5lZCAmJiBiYWJ5bG9uTWF0ZXJpYWwuYnVtcFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5idW1wVGV4dHVyZS5sZXZlbCA9IG1hdGVyaWFsLm5vcm1hbFRleHR1cmUuc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5mb3JjZUlycmFkaWFuY2VJbkZyYWdtZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUubm9uQ29sb3JEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZFRleHR1cmVJbmZvQXN5bmMoYCR7Y29udGV4dH0vb2NjbHVzaW9uVGV4dHVyZWAsIG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uYW1lID0gYCR7YmFieWxvbk1hdGVyaWFsLm5hbWV9IChPY2NsdXNpb24pYDtcclxuICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwuYW1iaWVudFRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC51c2VBbWJpZW50SW5HcmF5U2NhbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5hbWJpZW50VGV4dHVyZVN0cmVuZ3RoID0gbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkVGV4dHVyZUluZm9Bc3luYyhgJHtjb250ZXh0fS9lbWlzc2l2ZVRleHR1cmVgLCBtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5uYW1lID0gYCR7YmFieWxvbk1hdGVyaWFsLm5hbWV9IChFbWlzc2l2ZSlgO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7fSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgYWxwaGEgcHJvcGVydGllcyBmcm9tIGEgZ2xURiBtYXRlcmlhbCBpbnRvIGEgQmFieWxvbiBtYXRlcmlhbC5cclxuICAgICAqIE11c3QgYmUgY2FsbGVkIGFmdGVyIHRoZSBzZXR0aW5nIHRoZSBhbGJlZG8gdGV4dHVyZSBvZiB0aGUgQmFieWxvbiBtYXRlcmlhbCB3aGVuIHRoZSBtYXRlcmlhbCBoYXMgYW4gYWxiZWRvIHRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbWF0ZXJpYWwgVGhlIGdsVEYgbWF0ZXJpYWwgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBiYWJ5bG9uTWF0ZXJpYWwgVGhlIEJhYnlsb24gbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRNYXRlcmlhbEFscGhhUHJvcGVydGllcyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25NYXRlcmlhbDogTWF0ZXJpYWwpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIShiYWJ5bG9uTWF0ZXJpYWwgaW5zdGFuY2VvZiBQQlJNYXRlcmlhbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9OiBNYXRlcmlhbCB0eXBlIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFscGhhTW9kZSA9IG1hdGVyaWFsLmFscGhhTW9kZSB8fCBNYXRlcmlhbEFscGhhTW9kZS5PUEFRVUU7XHJcbiAgICAgICAgc3dpdGNoIChhbHBoYU1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBNYXRlcmlhbEFscGhhTW9kZS5PUEFRVUU6IHtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC50cmFuc3BhcmVuY3lNb2RlID0gUEJSTWF0ZXJpYWwuUEJSTUFURVJJQUxfT1BBUVVFO1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFscGhhID0gMS4wOyAvLyBGb3JjZSBhbHBoYSB0byAxLjAgZm9yIG9wYXF1ZSBtb2RlLlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBNYXRlcmlhbEFscGhhTW9kZS5NQVNLOiB7XHJcbiAgICAgICAgICAgICAgICBiYWJ5bG9uTWF0ZXJpYWwudHJhbnNwYXJlbmN5TW9kZSA9IFBCUk1hdGVyaWFsLlBCUk1BVEVSSUFMX0FMUEhBVEVTVDtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC5hbHBoYUN1dE9mZiA9IG1hdGVyaWFsLmFscGhhQ3V0b2ZmID09IHVuZGVmaW5lZCA/IDAuNSA6IG1hdGVyaWFsLmFscGhhQ3V0b2ZmO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhYnlsb25NYXRlcmlhbC5hbGJlZG9UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb1RleHR1cmUuaGFzQWxwaGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBNYXRlcmlhbEFscGhhTW9kZS5CTEVORDoge1xyXG4gICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLnRyYW5zcGFyZW5jeU1vZGUgPSBQQlJNYXRlcmlhbC5QQlJNQVRFUklBTF9BTFBIQUJMRU5EO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhYnlsb25NYXRlcmlhbC5hbGJlZG9UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsLmFsYmVkb1RleHR1cmUuaGFzQWxwaGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhYnlsb25NYXRlcmlhbC51c2VBbHBoYUZyb21BbGJlZG9UZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fS9hbHBoYU1vZGU6IEludmFsaWQgdmFsdWUgKCR7bWF0ZXJpYWwuYWxwaGFNb2RlfSlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ2xURiB0ZXh0dXJlIGluZm8uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gdGV4dHVyZUluZm8gVGhlIGdsVEYgdGV4dHVyZSBpbmZvIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gYXNzaWduIEEgZnVuY3Rpb24gY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2FkZWQgQmFieWxvbiB0ZXh0dXJlIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRUZXh0dXJlSW5mb0FzeW5jKGNvbnRleHQ6IHN0cmluZywgdGV4dHVyZUluZm86IElUZXh0dXJlSW5mbywgYXNzaWduOiAoYmFieWxvblRleHR1cmU6IEJhc2VUZXh0dXJlKSA9PiB2b2lkID0gKCkgPT4ge30pOiBQcm9taXNlPEJhc2VUZXh0dXJlPiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uUHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNMb2FkVGV4dHVyZUluZm9Bc3luYyhjb250ZXh0LCB0ZXh0dXJlSW5mbywgYXNzaWduKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubG9nT3BlbihgJHtjb250ZXh0fWApO1xyXG5cclxuICAgICAgICBpZiAodGV4dHVyZUluZm8udGV4Q29vcmQhID49IDYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9L3RleENvb3JkOiBJbnZhbGlkIHZhbHVlICgke3RleHR1cmVJbmZvLnRleENvb3JkfSlgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBBcnJheUl0ZW0uR2V0KGAke2NvbnRleHR9L2luZGV4YCwgdGhpcy5fZ2x0Zi50ZXh0dXJlcywgdGV4dHVyZUluZm8uaW5kZXgpO1xyXG4gICAgICAgIHRleHR1cmUuX3RleHR1cmVJbmZvID0gdGV4dHVyZUluZm87XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9sb2FkVGV4dHVyZUFzeW5jKGAvdGV4dHVyZXMvJHt0ZXh0dXJlSW5mby5pbmRleH1gLCB0ZXh0dXJlLCAoYmFieWxvblRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgYmFieWxvblRleHR1cmUuY29vcmRpbmF0ZXNJbmRleCA9IHRleHR1cmVJbmZvLnRleENvb3JkIHx8IDA7XHJcbiAgICAgICAgICAgIEdMVEZMb2FkZXIuQWRkUG9pbnRlck1ldGFkYXRhKGJhYnlsb25UZXh0dXJlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm9uVGV4dHVyZUxvYWRlZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKGJhYnlsb25UZXh0dXJlKTtcclxuICAgICAgICAgICAgYXNzaWduKGJhYnlsb25UZXh0dXJlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2dDbG9zZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX2xvYWRUZXh0dXJlQXN5bmMoY29udGV4dDogc3RyaW5nLCB0ZXh0dXJlOiBJVGV4dHVyZSwgYXNzaWduOiAoYmFieWxvblRleHR1cmU6IEJhc2VUZXh0dXJlKSA9PiB2b2lkID0gKCkgPT4ge30pOiBQcm9taXNlPEJhc2VUZXh0dXJlPiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uUHJvbWlzZSA9IHRoaXMuX2V4dGVuc2lvbnNMb2FkVGV4dHVyZUFzeW5jKGNvbnRleHQsIHRleHR1cmUsIGFzc2lnbik7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvblByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblByb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvZ09wZW4oYCR7Y29udGV4dH0gJHt0ZXh0dXJlLm5hbWUgfHwgXCJcIn1gKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHRleHR1cmUuc2FtcGxlciA9PSB1bmRlZmluZWQgPyBHTFRGTG9hZGVyLkRlZmF1bHRTYW1wbGVyIDogQXJyYXlJdGVtLkdldChgJHtjb250ZXh0fS9zYW1wbGVyYCwgdGhpcy5fZ2x0Zi5zYW1wbGVycywgdGV4dHVyZS5zYW1wbGVyKTtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vc291cmNlYCwgdGhpcy5fZ2x0Zi5pbWFnZXMsIHRleHR1cmUuc291cmNlKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fY3JlYXRlVGV4dHVyZUFzeW5jKGNvbnRleHQsIHNhbXBsZXIsIGltYWdlLCBhc3NpZ24sIHVuZGVmaW5lZCwgIXRleHR1cmUuX3RleHR1cmVJbmZvLm5vbkNvbG9yRGF0YSk7XHJcblxyXG4gICAgICAgIHRoaXMubG9nQ2xvc2UoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIF9jcmVhdGVUZXh0dXJlQXN5bmMoXHJcbiAgICAgICAgY29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIHNhbXBsZXI6IElTYW1wbGVyLFxyXG4gICAgICAgIGltYWdlOiBJSW1hZ2UsXHJcbiAgICAgICAgYXNzaWduOiAoYmFieWxvblRleHR1cmU6IEJhc2VUZXh0dXJlKSA9PiB2b2lkID0gKCkgPT4ge30sXHJcbiAgICAgICAgdGV4dHVyZUxvYWRlck9wdGlvbnM/OiB1bmtub3duLFxyXG4gICAgICAgIHVzZVNSR0JCdWZmZXI/OiBib29sZWFuXHJcbiAgICApOiBQcm9taXNlPEJhc2VUZXh0dXJlPiB7XHJcbiAgICAgICAgY29uc3Qgc2FtcGxlckRhdGEgPSB0aGlzLl9sb2FkU2FtcGxlcihgL3NhbXBsZXJzLyR7c2FtcGxlci5pbmRleH1gLCBzYW1wbGVyKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTx1bmtub3duPj4oKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQ8dm9pZD4oKTtcclxuICAgICAgICB0aGlzLl9iYWJ5bG9uU2NlbmUuX2Jsb2NrRW50aXR5Q29sbGVjdGlvbiA9ICEhdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZUNyZWF0aW9uT3B0aW9uczogSVRleHR1cmVDcmVhdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG5vTWlwbWFwOiBzYW1wbGVyRGF0YS5ub01pcE1hcHMsXHJcbiAgICAgICAgICAgIGludmVydFk6IGZhbHNlLFxyXG4gICAgICAgICAgICBzYW1wbGluZ01vZGU6IHNhbXBsZXJEYXRhLnNhbXBsaW5nTW9kZSxcclxuICAgICAgICAgICAgb25Mb2FkOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkVycm9yOiAobWVzc2FnZT86IHN0cmluZywgZXhjZXB0aW9uPzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihgJHtjb250ZXh0fTogJHtleGNlcHRpb24gJiYgZXhjZXB0aW9uLm1lc3NhZ2UgPyBleGNlcHRpb24ubWVzc2FnZSA6IG1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gbG9hZCB0ZXh0dXJlXCJ9YCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaW1lVHlwZTogaW1hZ2UubWltZVR5cGUgPz8gR2V0TWltZVR5cGUoaW1hZ2UudXJpID8/IFwiXCIpLFxyXG4gICAgICAgICAgICBsb2FkZXJPcHRpb25zOiB0ZXh0dXJlTG9hZGVyT3B0aW9ucyxcclxuICAgICAgICAgICAgdXNlU1JHQkJ1ZmZlcjogISF1c2VTUkdCQnVmZmVyICYmIHRoaXMuX3BhcmVudC51c2VTUkdCQnVmZmVycyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGJhYnlsb25UZXh0dXJlID0gbmV3IFRleHR1cmUobnVsbCwgdGhpcy5fYmFieWxvblNjZW5lLCB0ZXh0dXJlQ3JlYXRpb25PcHRpb25zKTtcclxuICAgICAgICBiYWJ5bG9uVGV4dHVyZS5fcGFyZW50Q29udGFpbmVyID0gdGhpcy5fYXNzZXRDb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLl9ibG9ja0VudGl0eUNvbGxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGRlZmVycmVkLnByb21pc2UpO1xyXG5cclxuICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZUFzeW5jKGAvaW1hZ2VzLyR7aW1hZ2UuaW5kZXh9YCwgaW1hZ2UpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpbWFnZS51cmkgfHwgYCR7dGhpcy5fZmlsZU5hbWV9I2ltYWdlJHtpbWFnZS5pbmRleH1gO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVVybCA9IGBkYXRhOiR7dGhpcy5fdW5pcXVlUm9vdFVybH0ke25hbWV9YDtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25UZXh0dXJlLnVwZGF0ZVVSTChkYXRhVXJsLCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGludGVybmFsIHRleHR1cmUgbGFiZWwuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbFRleHR1cmUgPSBiYWJ5bG9uVGV4dHVyZS5nZXRJbnRlcm5hbFRleHR1cmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUubGFiZWwgPSBpbWFnZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGJhYnlsb25UZXh0dXJlLndyYXBVID0gc2FtcGxlckRhdGEud3JhcFU7XHJcbiAgICAgICAgYmFieWxvblRleHR1cmUud3JhcFYgPSBzYW1wbGVyRGF0YS53cmFwVjtcclxuICAgICAgICBhc3NpZ24oYmFieWxvblRleHR1cmUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50LnVzZUdsdGZUZXh0dXJlTmFtZXMpIHtcclxuICAgICAgICAgICAgYmFieWxvblRleHR1cmUubmFtZSA9IGltYWdlLm5hbWUgfHwgaW1hZ2UudXJpIHx8IGBpbWFnZSR7aW1hZ2UuaW5kZXh9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYWJ5bG9uVGV4dHVyZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sb2FkU2FtcGxlcihjb250ZXh0OiBzdHJpbmcsIHNhbXBsZXI6IElTYW1wbGVyKTogX0lTYW1wbGVyRGF0YSB7XHJcbiAgICAgICAgaWYgKCFzYW1wbGVyLl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHNhbXBsZXIuX2RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBub01pcE1hcHM6IHNhbXBsZXIubWluRmlsdGVyID09PSBUZXh0dXJlTWluRmlsdGVyLk5FQVJFU1QgfHwgc2FtcGxlci5taW5GaWx0ZXIgPT09IFRleHR1cmVNaW5GaWx0ZXIuTElORUFSLFxyXG4gICAgICAgICAgICAgICAgc2FtcGxpbmdNb2RlOiBHTFRGTG9hZGVyLl9HZXRUZXh0dXJlU2FtcGxpbmdNb2RlKGNvbnRleHQsIHNhbXBsZXIpLFxyXG4gICAgICAgICAgICAgICAgd3JhcFU6IEdMVEZMb2FkZXIuX0dldFRleHR1cmVXcmFwTW9kZShgJHtjb250ZXh0fS93cmFwU2AsIHNhbXBsZXIud3JhcFMpLFxyXG4gICAgICAgICAgICAgICAgd3JhcFY6IEdMVEZMb2FkZXIuX0dldFRleHR1cmVXcmFwTW9kZShgJHtjb250ZXh0fS93cmFwVGAsIHNhbXBsZXIud3JhcFQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNhbXBsZXIuX2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIGdsVEYgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIGdsVEYgaW1hZ2UgcHJvcGVydHlcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBkYXRhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRJbWFnZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgaW1hZ2U6IElJbWFnZSk6IFByb21pc2U8QXJyYXlCdWZmZXJWaWV3PiB7XHJcbiAgICAgICAgaWYgKCFpbWFnZS5fZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ09wZW4oYCR7Y29udGV4dH0gJHtpbWFnZS5uYW1lIHx8IFwiXCJ9YCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW1hZ2UudXJpKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZS5fZGF0YSA9IHRoaXMubG9hZFVyaUFzeW5jKGAke2NvbnRleHR9L3VyaWAsIGltYWdlLCBpbWFnZS51cmkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyVmlldyA9IEFycmF5SXRlbS5HZXQoYCR7Y29udGV4dH0vYnVmZmVyVmlld2AsIHRoaXMuX2dsdGYuYnVmZmVyVmlld3MsIGltYWdlLmJ1ZmZlclZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UuX2RhdGEgPSB0aGlzLmxvYWRCdWZmZXJWaWV3QXN5bmMoYC9idWZmZXJWaWV3cy8ke2J1ZmZlclZpZXcuaW5kZXh9YCwgYnVmZmVyVmlldyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9nQ2xvc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbWFnZS5fZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ2xURiB1cmkuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgVGhlIGdsVEYgcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSB1cmlcclxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGJhc2U2NCBvciByZWxhdGl2ZSB1cmlcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBkYXRhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRVcmlBc3luYyhjb250ZXh0OiBzdHJpbmcsIHByb3BlcnR5OiBJUHJvcGVydHksIHVyaTogc3RyaW5nKTogUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+IHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25Qcm9taXNlID0gdGhpcy5fZXh0ZW5zaW9uc0xvYWRVcmlBc3luYyhjb250ZXh0LCBwcm9wZXJ0eSwgdXJpKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghR0xURkxvYWRlci5fVmFsaWRhdGVVcmkodXJpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06ICcke3VyaX0nIGlzIGludmFsaWRgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChJc0Jhc2U2NERhdGFVcmwodXJpKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoRGVjb2RlQmFzZTY0VXJsVG9CaW5hcnkodXJpKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nKGAke2NvbnRleHR9OiBEZWNvZGVkICR7dXJpLnN1YnN0cmluZygwLCA2NCl9Li4uICgke2RhdGEubGVuZ3RofSBieXRlcylgKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubG9nKGAke2NvbnRleHR9OiBMb2FkaW5nICR7dXJpfWApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LnByZXByb2Nlc3NVcmxBc3luYyh0aGlzLl9yb290VXJsICsgdXJpKS50aGVuKCh1cmwpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fbG9hZEZpbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFieWxvblNjZW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgICAgICAgICAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhgJHtjb250ZXh0fTogTG9hZGVkICR7dXJpfSAoJHsoZGF0YSBhcyBBcnJheUJ1ZmZlcikuYnl0ZUxlbmd0aH0gYnl0ZXMpYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRhdGEgYXMgQXJyYXlCdWZmZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAocmVxdWVzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IExvYWRGaWxlRXJyb3IoYCR7Y29udGV4dH06IEZhaWxlZCB0byBsb2FkICcke3VyaX0nJHtyZXF1ZXN0ID8gXCI6IFwiICsgcmVxdWVzdC5zdGF0dXMgKyBcIiBcIiArIHJlcXVlc3Quc3RhdHVzVGV4dCA6IFwiXCJ9YCwgcmVxdWVzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIEpTT04gcG9pbnRlciB0byB0aGUgX2ludGVybmFsTWV0YWRhdGEgb2YgdGhlIEJhYnlsb24gb2JqZWN0IGF0IGA8b2JqZWN0Pi5faW50ZXJuYWxNZXRhZGF0YS5nbHRmLnBvaW50ZXJzYC5cclxuICAgICAqIEBwYXJhbSBiYWJ5bG9uT2JqZWN0IHRoZSBCYWJ5bG9uIG9iamVjdCB3aXRoIF9pbnRlcm5hbE1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRlciB0aGUgSlNPTiBwb2ludGVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQWRkUG9pbnRlck1ldGFkYXRhKGJhYnlsb25PYmplY3Q6IElXaXRoTWV0YWRhdGEsIHBvaW50ZXI6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGJhYnlsb25PYmplY3QubWV0YWRhdGEgPSBiYWJ5bG9uT2JqZWN0Lm1ldGFkYXRhIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gKGJhYnlsb25PYmplY3QuX2ludGVybmFsTWV0YWRhdGEgPSBiYWJ5bG9uT2JqZWN0Ll9pbnRlcm5hbE1ldGFkYXRhIHx8IHt9KTtcclxuICAgICAgICBjb25zdCBnbHRmID0gKG1ldGFkYXRhLmdsdGYgPSBtZXRhZGF0YS5nbHRmIHx8IHt9KTtcclxuICAgICAgICBjb25zdCBwb2ludGVycyA9IChnbHRmLnBvaW50ZXJzID0gZ2x0Zi5wb2ludGVycyB8fCBbXSk7XHJcbiAgICAgICAgcG9pbnRlcnMucHVzaChwb2ludGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfR2V0VGV4dHVyZVdyYXBNb2RlKGNvbnRleHQ6IHN0cmluZywgbW9kZTogVGV4dHVyZVdyYXBNb2RlIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcclxuICAgICAgICAvLyBTZXQgZGVmYXVsdHMgaWYgdW5kZWZpbmVkXHJcbiAgICAgICAgbW9kZSA9IG1vZGUgPT0gdW5kZWZpbmVkID8gVGV4dHVyZVdyYXBNb2RlLlJFUEVBVCA6IG1vZGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHR1cmVXcmFwTW9kZS5DTEFNUF9UT19FREdFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuQ0xBTVBfQUREUkVTU01PREU7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dHVyZVdyYXBNb2RlLk1JUlJPUkVEX1JFUEVBVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLk1JUlJPUl9BRERSRVNTTU9ERTtcclxuICAgICAgICAgICAgY2FzZSBUZXh0dXJlV3JhcE1vZGUuUkVQRUFUOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuV1JBUF9BRERSRVNTTU9ERTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKGAke2NvbnRleHR9OiBJbnZhbGlkIHZhbHVlICgke21vZGV9KWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuV1JBUF9BRERSRVNTTU9ERTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX0dldFRleHR1cmVTYW1wbGluZ01vZGUoY29udGV4dDogc3RyaW5nLCBzYW1wbGVyOiBJU2FtcGxlcik6IG51bWJlciB7XHJcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzIGlmIHVuZGVmaW5lZFxyXG4gICAgICAgIGNvbnN0IG1hZ0ZpbHRlciA9IHNhbXBsZXIubWFnRmlsdGVyID09IHVuZGVmaW5lZCA/IFRleHR1cmVNYWdGaWx0ZXIuTElORUFSIDogc2FtcGxlci5tYWdGaWx0ZXI7XHJcbiAgICAgICAgY29uc3QgbWluRmlsdGVyID0gc2FtcGxlci5taW5GaWx0ZXIgPT0gdW5kZWZpbmVkID8gVGV4dHVyZU1pbkZpbHRlci5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IHNhbXBsZXIubWluRmlsdGVyO1xyXG5cclxuICAgICAgICBpZiAobWFnRmlsdGVyID09PSBUZXh0dXJlTWFnRmlsdGVyLkxJTkVBUikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1pbkZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLk5FQVJFU1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuTElORUFSX05FQVJFU1Q7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHR1cmVNaW5GaWx0ZXIuTElORUFSOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLkxJTkVBUl9MSU5FQVI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHR1cmVNaW5GaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5MSU5FQVJfTkVBUkVTVF9NSVBORUFSRVNUO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5MSU5FQVJfTElORUFSX01JUE5FQVJFU1Q7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHR1cmVNaW5GaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTElORUFSOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLkxJTkVBUl9ORUFSRVNUX01JUExJTkVBUjtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dHVyZU1pbkZpbHRlci5MSU5FQVJfTUlQTUFQX0xJTkVBUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5MSU5FQVJfTElORUFSX01JUExJTkVBUjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLldhcm4oYCR7Y29udGV4dH0vbWluRmlsdGVyOiBJbnZhbGlkIHZhbHVlICgke21pbkZpbHRlcn0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuTElORUFSX0xJTkVBUl9NSVBMSU5FQVI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobWFnRmlsdGVyICE9PSBUZXh0dXJlTWFnRmlsdGVyLk5FQVJFU1QpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKGAke2NvbnRleHR9L21hZ0ZpbHRlcjogSW52YWxpZCB2YWx1ZSAoJHttYWdGaWx0ZXJ9KWApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG1pbkZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLk5FQVJFU1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuTkVBUkVTVF9ORUFSRVNUO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLkxJTkVBUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5ORUFSRVNUX0xJTkVBUjtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dHVyZU1pbkZpbHRlci5ORUFSRVNUX01JUE1BUF9ORUFSRVNUOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLk5FQVJFU1RfTkVBUkVTVF9NSVBORUFSRVNUO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5ORUFSRVNUX0xJTkVBUl9NSVBORUFSRVNUO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5ORUFSRVNUX05FQVJFU1RfTUlQTElORUFSO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0dXJlTWluRmlsdGVyLkxJTkVBUl9NSVBNQVBfTElORUFSOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0dXJlLk5FQVJFU1RfTElORUFSX01JUExJTkVBUjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLldhcm4oYCR7Y29udGV4dH0vbWluRmlsdGVyOiBJbnZhbGlkIHZhbHVlICgke21pbkZpbHRlcn0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuTkVBUkVTVF9ORUFSRVNUX01JUE5FQVJFU1Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX0dldFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcihjb250ZXh0OiBzdHJpbmcsIGNvbXBvbmVudFR5cGU6IEFjY2Vzc29yQ29tcG9uZW50VHlwZSk6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcihjb21wb25lbnRUeXBlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogJHtlLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9HZXRUeXBlZEFycmF5KGNvbnRleHQ6IHN0cmluZywgY29tcG9uZW50VHlwZTogQWNjZXNzb3JDb21wb25lbnRUeXBlLCBidWZmZXJWaWV3OiBBcnJheUJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQ6IG51bWJlciB8IHVuZGVmaW5lZCwgbGVuZ3RoOiBudW1iZXIpOiBUeXBlZEFycmF5IHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJWaWV3LmJ1ZmZlcjtcclxuICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyVmlldy5ieXRlT2Zmc2V0ICsgKGJ5dGVPZmZzZXQgfHwgMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gR0xURkxvYWRlci5fR2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKGAke2NvbnRleHR9L2NvbXBvbmVudFR5cGVgLCBjb21wb25lbnRUeXBlKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZUxlbmd0aCA9IFZlcnRleEJ1ZmZlci5HZXRUeXBlQnl0ZUxlbmd0aChjb21wb25lbnRUeXBlKTtcclxuICAgICAgICBpZiAoYnl0ZU9mZnNldCAlIGNvbXBvbmVudFR5cGVMZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgLy8gSEFDSzogQ29weSB0aGUgYnVmZmVyIGlmIGJ5dGUgb2Zmc2V0IGlzIG5vdCBhIG11bHRpcGxlIG9mIGNvbXBvbmVudCB0eXBlIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICAgICAgICBMb2dnZXIuV2FybihgJHtjb250ZXh0fTogQ29weWluZyBidWZmZXIgYXMgYnl0ZSBvZmZzZXQgKCR7Ynl0ZU9mZnNldH0pIGlzIG5vdCBhIG11bHRpcGxlIG9mIGNvbXBvbmVudCB0eXBlIGJ5dGUgbGVuZ3RoICgke2NvbXBvbmVudFR5cGVMZW5ndGh9KWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yKGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoICogY29tcG9uZW50VHlwZUxlbmd0aCksIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvcihidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX0dldE51bUNvbXBvbmVudHMoY29udGV4dDogc3RyaW5nLCB0eXBlOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0NBTEFSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgY2FzZSBcIlZFQzJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIFwiVkVDM1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgIGNhc2UgXCJWRUM0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgY2FzZSBcIk1BVDJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICBjYXNlIFwiTUFUM1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJNQVQ0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH06IEludmFsaWQgdHlwZSAoJHt0eXBlfSlgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfVmFsaWRhdGVVcmkodXJpOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gVG9vbHMuSXNCYXNlNjQodXJpKSB8fCB1cmkuaW5kZXhPZihcIi4uXCIpID09PSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIF9HZXREcmF3TW9kZShjb250ZXh0OiBzdHJpbmcsIG1vZGU6IG51bWJlciB8IHVuZGVmaW5lZCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKG1vZGUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1vZGUgPSBNZXNoUHJpbWl0aXZlTW9kZS5UUklBTkdMRVM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBNZXNoUHJpbWl0aXZlTW9kZS5QT0lOVFM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0ZXJpYWwuUG9pbnRMaXN0RHJhd01vZGU7XHJcbiAgICAgICAgICAgIGNhc2UgTWVzaFByaW1pdGl2ZU1vZGUuTElORVM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0ZXJpYWwuTGluZUxpc3REcmF3TW9kZTtcclxuICAgICAgICAgICAgY2FzZSBNZXNoUHJpbWl0aXZlTW9kZS5MSU5FX0xPT1A6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0ZXJpYWwuTGluZUxvb3BEcmF3TW9kZTtcclxuICAgICAgICAgICAgY2FzZSBNZXNoUHJpbWl0aXZlTW9kZS5MSU5FX1NUUklQOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGVyaWFsLkxpbmVTdHJpcERyYXdNb2RlO1xyXG4gICAgICAgICAgICBjYXNlIE1lc2hQcmltaXRpdmVNb2RlLlRSSUFOR0xFUzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRlcmlhbC5UcmlhbmdsZUZpbGxNb2RlO1xyXG4gICAgICAgICAgICBjYXNlIE1lc2hQcmltaXRpdmVNb2RlLlRSSUFOR0xFX1NUUklQOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGVyaWFsLlRyaWFuZ2xlU3RyaXBEcmF3TW9kZTtcclxuICAgICAgICAgICAgY2FzZSBNZXNoUHJpbWl0aXZlTW9kZS5UUklBTkdMRV9GQU46XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0ZXJpYWwuVHJpYW5nbGVGYW5EcmF3TW9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fTogSW52YWxpZCBtZXNoIHByaW1pdGl2ZSBtb2RlICgke21vZGV9KWApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NvbXBpbGVNYXRlcmlhbHNBc3luYygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl9wYXJlbnQuX3N0YXJ0UGVyZm9ybWFuY2VDb3VudGVyKFwiQ29tcGlsZSBtYXRlcmlhbHNcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9nbHRmLm1hdGVyaWFscykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGVyaWFsIG9mIHRoaXMuX2dsdGYubWF0ZXJpYWxzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwuX2RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhYnlsb25EcmF3TW9kZSBpbiBtYXRlcmlhbC5fZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uRGF0YSA9IG1hdGVyaWFsLl9kYXRhW2JhYnlsb25EcmF3TW9kZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmFieWxvbk1lc2ggb2YgYmFieWxvbkRhdGEuYmFieWxvbk1lc2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vblVuaWZvcm1TY2FsaW5nIGlzIHNldCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWJ5bG9uTWVzaC5jb21wdXRlV29ybGRNYXRyaXgodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFieWxvbk1hdGVyaWFsID0gYmFieWxvbkRhdGEuYmFieWxvbk1hdGVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChiYWJ5bG9uTWF0ZXJpYWwuZm9yY2VDb21waWxhdGlvbkFzeW5jKGJhYnlsb25NZXNoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGJhYnlsb25NYXRlcmlhbC5mb3JjZUNvbXBpbGF0aW9uQXN5bmMoYmFieWxvbk1lc2gsIHsgdXNlSW5zdGFuY2VzOiB0cnVlIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQudXNlQ2xpcFBsYW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChiYWJ5bG9uTWF0ZXJpYWwuZm9yY2VDb21waWxhdGlvbkFzeW5jKGJhYnlsb25NZXNoLCB7IGNsaXBQbGFuZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChiYWJ5bG9uTWF0ZXJpYWwuZm9yY2VDb21waWxhdGlvbkFzeW5jKGJhYnlsb25NZXNoLCB7IGNsaXBQbGFuZTogdHJ1ZSwgdXNlSW5zdGFuY2VzOiB0cnVlIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll9lbmRQZXJmb3JtYW5jZUNvdW50ZXIoXCJDb21waWxlIG1hdGVyaWFsc1wiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jb21waWxlU2hhZG93R2VuZXJhdG9yc0FzeW5jKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuX3BhcmVudC5fc3RhcnRQZXJmb3JtYW5jZUNvdW50ZXIoXCJDb21waWxlIHNoYWRvdyBnZW5lcmF0b3JzXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICBjb25zdCBsaWdodHMgPSB0aGlzLl9iYWJ5bG9uU2NlbmUubGlnaHRzO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlnaHQgb2YgbGlnaHRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGxpZ2h0LmdldFNoYWRvd0dlbmVyYXRvcigpO1xyXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdlbmVyYXRvci5mb3JjZUNvbXBpbGF0aW9uQXN5bmMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fZW5kUGVyZm9ybWFuY2VDb3VudGVyKFwiQ29tcGlsZSBzaGFkb3cgZ2VuZXJhdG9yc1wiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9mb3JFYWNoRXh0ZW5zaW9ucyhhY3Rpb246IChleHRlbnNpb246IElHTFRGTG9hZGVyRXh0ZW5zaW9uKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgdGhpcy5fZXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbihleHRlbnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2FwcGx5RXh0ZW5zaW9uczxUPihwcm9wZXJ0eTogSVByb3BlcnR5LCBmdW5jdGlvbk5hbWU6IHN0cmluZywgYWN0aW9uQXN5bmM6IChleHRlbnNpb246IElHTFRGTG9hZGVyRXh0ZW5zaW9uKSA9PiBOdWxsYWJsZTxUPiB8IHVuZGVmaW5lZCk6IE51bGxhYmxlPFQ+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiB0aGlzLl9leHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24uZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBgJHtleHRlbnNpb24ubmFtZX0uJHtmdW5jdGlvbk5hbWV9YDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlclByb3BlcnR5ID0gcHJvcGVydHkgYXMgSUxvYWRlclByb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgbG9hZGVyUHJvcGVydHkuX2FjdGl2ZUxvYWRlckV4dGVuc2lvbkZ1bmN0aW9ucyA9IGxvYWRlclByb3BlcnR5Ll9hY3RpdmVMb2FkZXJFeHRlbnNpb25GdW5jdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVMb2FkZXJFeHRlbnNpb25GdW5jdGlvbnMgPSBsb2FkZXJQcm9wZXJ0eS5fYWN0aXZlTG9hZGVyRXh0ZW5zaW9uRnVuY3Rpb25zO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVMb2FkZXJFeHRlbnNpb25GdW5jdGlvbnNbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlTG9hZGVyRXh0ZW5zaW9uRnVuY3Rpb25zW2lkXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbkFzeW5jKGV4dGVuc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlTG9hZGVyRXh0ZW5zaW9uRnVuY3Rpb25zW2lkXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2V4dGVuc2lvbnNPbkxvYWRpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fZm9yRWFjaEV4dGVuc2lvbnMoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLm9uTG9hZGluZyAmJiBleHRlbnNpb24ub25Mb2FkaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2V4dGVuc2lvbnNPblJlYWR5KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2ZvckVhY2hFeHRlbnNpb25zKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5vblJlYWR5ICYmIGV4dGVuc2lvbi5vblJlYWR5KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfZXh0ZW5zaW9uc0xvYWRTY2VuZUFzeW5jKGNvbnRleHQ6IHN0cmluZywgc2NlbmU6IElTY2VuZSk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlFeHRlbnNpb25zKHNjZW5lLCBcImxvYWRTY2VuZVwiLCAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubG9hZFNjZW5lQXN5bmMgJiYgZXh0ZW5zaW9uLmxvYWRTY2VuZUFzeW5jKGNvbnRleHQsIHNjZW5lKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZE5vZGVBc3luYyhjb250ZXh0OiBzdHJpbmcsIG5vZGU6IElOb2RlLCBhc3NpZ246IChiYWJ5bG9uVHJhbnNmb3JtTm9kZTogVHJhbnNmb3JtTm9kZSkgPT4gdm9pZCk6IE51bGxhYmxlPFByb21pc2U8VHJhbnNmb3JtTm9kZT4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlFeHRlbnNpb25zKG5vZGUsIFwibG9hZE5vZGVcIiwgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLmxvYWROb2RlQXN5bmMgJiYgZXh0ZW5zaW9uLmxvYWROb2RlQXN5bmMoY29udGV4dCwgbm9kZSwgYXNzaWduKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZENhbWVyYUFzeW5jKGNvbnRleHQ6IHN0cmluZywgY2FtZXJhOiBJQ2FtZXJhLCBhc3NpZ246IChiYWJ5bG9uQ2FtZXJhOiBDYW1lcmEpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPENhbWVyYT4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlFeHRlbnNpb25zKGNhbWVyYSwgXCJsb2FkQ2FtZXJhXCIsIChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5sb2FkQ2FtZXJhQXN5bmMgJiYgZXh0ZW5zaW9uLmxvYWRDYW1lcmFBc3luYyhjb250ZXh0LCBjYW1lcmEsIGFzc2lnbikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfZXh0ZW5zaW9uc0xvYWRWZXJ0ZXhEYXRhQXN5bmMoY29udGV4dDogc3RyaW5nLCBwcmltaXRpdmU6IElNZXNoUHJpbWl0aXZlLCBiYWJ5bG9uTWVzaDogTWVzaCk6IE51bGxhYmxlPFByb21pc2U8R2VvbWV0cnk+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RXh0ZW5zaW9ucyhwcmltaXRpdmUsIFwibG9hZFZlcnRleERhdGFcIiwgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLl9sb2FkVmVydGV4RGF0YUFzeW5jICYmIGV4dGVuc2lvbi5fbG9hZFZlcnRleERhdGFBc3luYyhjb250ZXh0LCBwcmltaXRpdmUsIGJhYnlsb25NZXNoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZE1lc2hQcmltaXRpdmVBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIG5vZGU6IElOb2RlLFxyXG4gICAgICAgIG1lc2g6IElNZXNoLFxyXG4gICAgICAgIHByaW1pdGl2ZTogSU1lc2hQcmltaXRpdmUsXHJcbiAgICAgICAgYXNzaWduOiAoYmFieWxvbk1lc2g6IEFic3RyYWN0TWVzaCkgPT4gdm9pZFxyXG4gICAgKTogTnVsbGFibGU8UHJvbWlzZTxBYnN0cmFjdE1lc2g+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RXh0ZW5zaW9ucyhcclxuICAgICAgICAgICAgcHJpbWl0aXZlLFxyXG4gICAgICAgICAgICBcImxvYWRNZXNoUHJpbWl0aXZlXCIsXHJcbiAgICAgICAgICAgIChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5fbG9hZE1lc2hQcmltaXRpdmVBc3luYyAmJiBleHRlbnNpb24uX2xvYWRNZXNoUHJpbWl0aXZlQXN5bmMoY29udGV4dCwgbmFtZSwgbm9kZSwgbWVzaCwgcHJpbWl0aXZlLCBhc3NpZ24pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2V4dGVuc2lvbnNMb2FkTWF0ZXJpYWxBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgbWF0ZXJpYWw6IElNYXRlcmlhbCxcclxuICAgICAgICBiYWJ5bG9uTWVzaDogTnVsbGFibGU8TWVzaD4sXHJcbiAgICAgICAgYmFieWxvbkRyYXdNb2RlOiBudW1iZXIsXHJcbiAgICAgICAgYXNzaWduOiAoYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbCkgPT4gdm9pZFxyXG4gICAgKTogTnVsbGFibGU8UHJvbWlzZTxNYXRlcmlhbD4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlFeHRlbnNpb25zKFxyXG4gICAgICAgICAgICBtYXRlcmlhbCxcclxuICAgICAgICAgICAgXCJsb2FkTWF0ZXJpYWxcIixcclxuICAgICAgICAgICAgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLl9sb2FkTWF0ZXJpYWxBc3luYyAmJiBleHRlbnNpb24uX2xvYWRNYXRlcmlhbEFzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWVzaCwgYmFieWxvbkRyYXdNb2RlLCBhc3NpZ24pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zQ3JlYXRlTWF0ZXJpYWwoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uRHJhd01vZGU6IG51bWJlcik6IE51bGxhYmxlPE1hdGVyaWFsPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RXh0ZW5zaW9ucyhtYXRlcmlhbCwgXCJjcmVhdGVNYXRlcmlhbFwiLCAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24uY3JlYXRlTWF0ZXJpYWwgJiYgZXh0ZW5zaW9uLmNyZWF0ZU1hdGVyaWFsKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uRHJhd01vZGUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2V4dGVuc2lvbnNMb2FkTWF0ZXJpYWxQcm9wZXJ0aWVzQXN5bmMoY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUV4dGVuc2lvbnMoXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLFxyXG4gICAgICAgICAgICBcImxvYWRNYXRlcmlhbFByb3BlcnRpZXNcIixcclxuICAgICAgICAgICAgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLmxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYyAmJiBleHRlbnNpb24ubG9hZE1hdGVyaWFsUHJvcGVydGllc0FzeW5jKGNvbnRleHQsIG1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWwpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgIHByaXZhdGUgX2V4dGVuc2lvbnNMb2FkVGV4dHVyZUluZm9Bc3luYyhjb250ZXh0OiBzdHJpbmcsIHRleHR1cmVJbmZvOiBJVGV4dHVyZUluZm8sIGFzc2lnbjogKGJhYnlsb25UZXh0dXJlOiBCYXNlVGV4dHVyZSkgPT4gdm9pZCk6IE51bGxhYmxlPFByb21pc2U8QmFzZVRleHR1cmU+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RXh0ZW5zaW9ucyh0ZXh0dXJlSW5mbywgXCJsb2FkVGV4dHVyZUluZm9cIiwgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLmxvYWRUZXh0dXJlSW5mb0FzeW5jICYmIGV4dGVuc2lvbi5sb2FkVGV4dHVyZUluZm9Bc3luYyhjb250ZXh0LCB0ZXh0dXJlSW5mbywgYXNzaWduKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZFRleHR1cmVBc3luYyhjb250ZXh0OiBzdHJpbmcsIHRleHR1cmU6IElUZXh0dXJlLCBhc3NpZ246IChiYWJ5bG9uVGV4dHVyZTogQmFzZVRleHR1cmUpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPEJhc2VUZXh0dXJlPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUV4dGVuc2lvbnModGV4dHVyZSwgXCJsb2FkVGV4dHVyZVwiLCAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24uX2xvYWRUZXh0dXJlQXN5bmMgJiYgZXh0ZW5zaW9uLl9sb2FkVGV4dHVyZUFzeW5jKGNvbnRleHQsIHRleHR1cmUsIGFzc2lnbikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfZXh0ZW5zaW9uc0xvYWRBbmltYXRpb25Bc3luYyhjb250ZXh0OiBzdHJpbmcsIGFuaW1hdGlvbjogSUFuaW1hdGlvbik6IE51bGxhYmxlPFByb21pc2U8QW5pbWF0aW9uR3JvdXA+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5RXh0ZW5zaW9ucyhhbmltYXRpb24sIFwibG9hZEFuaW1hdGlvblwiLCAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubG9hZEFuaW1hdGlvbkFzeW5jICYmIGV4dGVuc2lvbi5sb2FkQW5pbWF0aW9uQXN5bmMoY29udGV4dCwgYW5pbWF0aW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZEFuaW1hdGlvbkNoYW5uZWxBc3luYyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uQ29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbjogSUFuaW1hdGlvbixcclxuICAgICAgICBjaGFubmVsOiBJQW5pbWF0aW9uQ2hhbm5lbCxcclxuICAgICAgICBvbkxvYWQ6IChiYWJ5bG9uQW5pbWF0YWJsZTogSUFuaW1hdGFibGUsIGJhYnlsb25BbmltYXRpb246IEFuaW1hdGlvbikgPT4gdm9pZFxyXG4gICAgKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUV4dGVuc2lvbnMoXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICAgICAgXCJsb2FkQW5pbWF0aW9uQ2hhbm5lbFwiLFxyXG4gICAgICAgICAgICAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24uX2xvYWRBbmltYXRpb25DaGFubmVsQXN5bmMgJiYgZXh0ZW5zaW9uLl9sb2FkQW5pbWF0aW9uQ2hhbm5lbEFzeW5jKGNvbnRleHQsIGFuaW1hdGlvbkNvbnRleHQsIGFuaW1hdGlvbiwgY2hhbm5lbCwgb25Mb2FkKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZFNraW5Bc3luYyhjb250ZXh0OiBzdHJpbmcsIG5vZGU6IElOb2RlLCBza2luOiBJU2tpbik6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlFeHRlbnNpb25zKHNraW4sIFwibG9hZFNraW5cIiwgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLl9sb2FkU2tpbkFzeW5jICYmIGV4dGVuc2lvbi5fbG9hZFNraW5Bc3luYyhjb250ZXh0LCBub2RlLCBza2luKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZFVyaUFzeW5jKGNvbnRleHQ6IHN0cmluZywgcHJvcGVydHk6IElQcm9wZXJ0eSwgdXJpOiBzdHJpbmcpOiBOdWxsYWJsZTxQcm9taXNlPEFycmF5QnVmZmVyVmlldz4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlFeHRlbnNpb25zKHByb3BlcnR5LCBcImxvYWRVcmlcIiwgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLl9sb2FkVXJpQXN5bmMgJiYgZXh0ZW5zaW9uLl9sb2FkVXJpQXN5bmMoY29udGV4dCwgcHJvcGVydHksIHVyaSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgcHJpdmF0ZSBfZXh0ZW5zaW9uc0xvYWRCdWZmZXJWaWV3QXN5bmMoY29udGV4dDogc3RyaW5nLCBidWZmZXJWaWV3OiBJQnVmZmVyVmlldyk6IE51bGxhYmxlPFByb21pc2U8QXJyYXlCdWZmZXJWaWV3Pj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUV4dGVuc2lvbnMoYnVmZmVyVmlldywgXCJsb2FkQnVmZmVyVmlld1wiLCAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubG9hZEJ1ZmZlclZpZXdBc3luYyAmJiBleHRlbnNpb24ubG9hZEJ1ZmZlclZpZXdBc3luYyhjb250ZXh0LCBidWZmZXJWaWV3KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25zTG9hZEJ1ZmZlckFzeW5jKGNvbnRleHQ6IHN0cmluZywgYnVmZmVyOiBJQnVmZmVyLCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IE51bGxhYmxlPFByb21pc2U8QXJyYXlCdWZmZXJWaWV3Pj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUV4dGVuc2lvbnMoYnVmZmVyLCBcImxvYWRCdWZmZXJcIiwgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLmxvYWRCdWZmZXJBc3luYyAmJiBleHRlbnNpb24ubG9hZEJ1ZmZlckFzeW5jKGNvbnRleHQsIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIG1ldGhvZCBjYWxsZWQgYnkgYSBsb2FkZXIgZXh0ZW5zaW9uIHRvIGxvYWQgYW4gZ2xURiBleHRlbnNpb24uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgVGhlIGdsVEYgcHJvcGVydHkgdG8gbG9hZCB0aGUgZXh0ZW5zaW9uIGZyb21cclxuICAgICAqIEBwYXJhbSBleHRlbnNpb25OYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGFjdGlvbkFzeW5jIFRoZSBhY3Rpb24gdG8gcnVuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSByZXR1cm5lZCBieSBhY3Rpb25Bc3luYyBvciBudWxsIGlmIHRoZSBleHRlbnNpb24gZG9lcyBub3QgZXhpc3RcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIHB1YmxpYyBzdGF0aWMgTG9hZEV4dGVuc2lvbkFzeW5jPFRFeHRlbnNpb24gPSB1bmtub3duLCBUUmVzdWx0ID0gdm9pZD4oXHJcbiAgICAgICAgY29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIHByb3BlcnR5OiBJUHJvcGVydHksXHJcbiAgICAgICAgZXh0ZW5zaW9uTmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGFjdGlvbkFzeW5jOiAoZXh0ZW5zaW9uQ29udGV4dDogc3RyaW5nLCBleHRlbnNpb246IFRFeHRlbnNpb24pID0+IE51bGxhYmxlPFByb21pc2U8VFJlc3VsdD4+XHJcbiAgICApOiBOdWxsYWJsZTxQcm9taXNlPFRSZXN1bHQ+PiB7XHJcbiAgICAgICAgaWYgKCFwcm9wZXJ0eS5leHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHByb3BlcnR5LmV4dGVuc2lvbnM7XHJcblxyXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gYXMgVEV4dGVuc2lvbjtcclxuICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhY3Rpb25Bc3luYyhgJHtjb250ZXh0fS9leHRlbnNpb25zLyR7ZXh0ZW5zaW9uTmFtZX1gLCBleHRlbnNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIG1ldGhvZCBjYWxsZWQgYnkgYSBsb2FkZXIgZXh0ZW5zaW9uIHRvIGxvYWQgYSBnbFRGIGV4dHJhLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBnbFRGIHByb3BlcnR5IHRvIGxvYWQgdGhlIGV4dHJhIGZyb21cclxuICAgICAqIEBwYXJhbSBleHRlbnNpb25OYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGFjdGlvbkFzeW5jIFRoZSBhY3Rpb24gdG8gcnVuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSByZXR1cm5lZCBieSBhY3Rpb25Bc3luYyBvciBudWxsIGlmIHRoZSBleHRyYSBkb2VzIG5vdCBleGlzdFxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkRXh0cmFBc3luYzxURXh0cmEgPSB1bmtub3duLCBUUmVzdWx0ID0gdm9pZD4oXHJcbiAgICAgICAgY29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIHByb3BlcnR5OiBJUHJvcGVydHksXHJcbiAgICAgICAgZXh0ZW5zaW9uTmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGFjdGlvbkFzeW5jOiAoZXh0cmFDb250ZXh0OiBzdHJpbmcsIGV4dHJhOiBURXh0cmEpID0+IE51bGxhYmxlPFByb21pc2U8VFJlc3VsdD4+XHJcbiAgICApOiBOdWxsYWJsZTxQcm9taXNlPFRSZXN1bHQ+PiB7XHJcbiAgICAgICAgaWYgKCFwcm9wZXJ0eS5leHRyYXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBleHRyYXMgPSBwcm9wZXJ0eS5leHRyYXM7XHJcblxyXG4gICAgICAgIGNvbnN0IGV4dHJhID0gZXh0cmFzW2V4dGVuc2lvbk5hbWVdIGFzIFRFeHRyYTtcclxuICAgICAgICBpZiAoIWV4dHJhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFjdGlvbkFzeW5jKGAke2NvbnRleHR9L2V4dHJhcy8ke2V4dGVuc2lvbk5hbWV9YCwgZXh0cmEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGZvciBwcmVzZW5jZSBvZiBhbiBleHRlbnNpb24uXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB0aGUgcHJlc2VuY2Ugb2YgdGhlIGdpdmVuIGV4dGVuc2lvbiBuYW1lIGluIGBleHRlbnNpb25zVXNlZGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzRXh0ZW5zaW9uVXNlZChuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9nbHRmLmV4dGVuc2lvbnNVc2VkICYmIHRoaXMuX2dsdGYuZXh0ZW5zaW9uc1VzZWQuaW5kZXhPZihuYW1lKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZW1lbnRzIHRoZSBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgbG9ncyBhIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvZ09wZW4obWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9sb2dPcGVuKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjcmVtZW50cyB0aGUgaW5kZW50YXRpb24gbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb2dDbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wYXJlbnQuX2xvZ0Nsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZVxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb2cobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9sb2cobWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBwZXJmb3JtYW5jZSBjb3VudGVyLlxyXG4gICAgICogQHBhcmFtIGNvdW50ZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBwZXJmb3JtYW5jZSBjb3VudGVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGFydFBlcmZvcm1hbmNlQ291bnRlcihjb3VudGVyTmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9zdGFydFBlcmZvcm1hbmNlQ291bnRlcihjb3VudGVyTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGEgcGVyZm9ybWFuY2UgY291bnRlci5cclxuICAgICAqIEBwYXJhbSBjb3VudGVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGVyZm9ybWFuY2UgY291bnRlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5kUGVyZm9ybWFuY2VDb3VudGVyKGNvdW50ZXJOYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wYXJlbnQuX2VuZFBlcmZvcm1hbmNlQ291bnRlcihjb3VudGVyTmFtZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkdMVEZGaWxlTG9hZGVyLl9DcmVhdGVHTFRGMkxvYWRlciA9IChwYXJlbnQpID0+IG5ldyBHTFRGTG9hZGVyKHBhcmVudCk7XHJcbiIsImltcG9ydCB7IEFuaW1hdGlvbiB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0aW9uXCI7XHJcbmltcG9ydCB7IFF1YXRlcm5pb24sIFZlY3RvcjMgfSBmcm9tIFwiY29yZS9NYXRocy9tYXRoLnZlY3RvclwiO1xyXG5pbXBvcnQgdHlwZSB7IElOb2RlIH0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJQW5pbWF0YWJsZSB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0YWJsZS5pbnRlcmZhY2VcIjtcclxuaW1wb3J0IHsgU2V0SW50ZXJwb2xhdGlvbkZvcktleSB9IGZyb20gXCIuL0V4dGVuc2lvbnMvb2JqZWN0TW9kZWxNYXBwaW5nXCI7XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCB0eXBlIEdldFZhbHVlRm4gPSAodGFyZ2V0OiBhbnksIHNvdXJjZTogRmxvYXQzMkFycmF5LCBvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcikgPT4gYW55O1xyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWN0b3IzKF90YXJnZXQ6IGFueSwgc291cmNlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICByZXR1cm4gVmVjdG9yMy5Gcm9tQXJyYXkoc291cmNlLCBvZmZzZXQpLnNjYWxlSW5QbGFjZShzY2FsZSk7XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVhdGVybmlvbihfdGFyZ2V0OiBhbnksIHNvdXJjZTogRmxvYXQzMkFycmF5LCBvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcik6IFF1YXRlcm5pb24ge1xyXG4gICAgcmV0dXJuIFF1YXRlcm5pb24uRnJvbUFycmF5KHNvdXJjZSwgb2Zmc2V0KS5zY2FsZUluUGxhY2Uoc2NhbGUpO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlaWdodHModGFyZ2V0OiBJTm9kZSwgc291cmNlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyKTogQXJyYXk8bnVtYmVyPiB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBBcnJheTxudW1iZXI+KHRhcmdldC5fbnVtTW9ycGhUYXJnZXRzISk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVbaV0gPSBzb3VyY2Vbb2Zmc2V0KytdICogc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBbmltYXRpb25Qcm9wZXJ0eUluZm8ge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBudW1iZXIsXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZyxcclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZ2V0VmFsdWU6IEdldFZhbHVlRm4sXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGdldFN0cmlkZTogKHRhcmdldDogYW55KSA9PiBudW1iZXJcclxuICAgICkge31cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2J1aWxkQW5pbWF0aW9uKG5hbWU6IHN0cmluZywgZnBzOiBudW1iZXIsIGtleXM6IGFueVtdKTogQW5pbWF0aW9uIHtcclxuICAgICAgICBjb25zdCBiYWJ5bG9uQW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihuYW1lLCB0aGlzLm5hbWUsIGZwcywgdGhpcy50eXBlKTtcclxuICAgICAgICBiYWJ5bG9uQW5pbWF0aW9uLnNldEtleXMoa2V5cyk7XHJcbiAgICAgICAgcmV0dXJuIGJhYnlsb25BbmltYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGJ1aWxkQW5pbWF0aW9ucyh0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nLCBmcHM6IG51bWJlciwga2V5czogYW55W10pOiB7IGJhYnlsb25BbmltYXRhYmxlOiBJQW5pbWF0YWJsZTsgYmFieWxvbkFuaW1hdGlvbjogQW5pbWF0aW9uIH1bXTtcclxufVxyXG5cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtTm9kZUFuaW1hdGlvblByb3BlcnR5SW5mbyBleHRlbmRzIEFuaW1hdGlvblByb3BlcnR5SW5mbyB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgYnVpbGRBbmltYXRpb25zKHRhcmdldDogSU5vZGUsIG5hbWU6IHN0cmluZywgZnBzOiBudW1iZXIsIGtleXM6IGFueVtdKSB7XHJcbiAgICAgICAgY29uc3QgYmFieWxvbkFuaW1hdGlvbnM6IHsgYmFieWxvbkFuaW1hdGFibGU6IElBbmltYXRhYmxlOyBiYWJ5bG9uQW5pbWF0aW9uOiBBbmltYXRpb24gfVtdID0gW107XHJcbiAgICAgICAgYmFieWxvbkFuaW1hdGlvbnMucHVzaCh7IGJhYnlsb25BbmltYXRhYmxlOiB0YXJnZXQuX2JhYnlsb25UcmFuc2Zvcm1Ob2RlISwgYmFieWxvbkFuaW1hdGlvbjogdGhpcy5fYnVpbGRBbmltYXRpb24obmFtZSwgZnBzLCBrZXlzKSB9KTtcclxuICAgICAgICByZXR1cm4gYmFieWxvbkFuaW1hdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGNsYXNzIFdlaWdodEFuaW1hdGlvblByb3BlcnR5SW5mbyBleHRlbmRzIEFuaW1hdGlvblByb3BlcnR5SW5mbyB7XHJcbiAgICBwdWJsaWMgYnVpbGRBbmltYXRpb25zKHRhcmdldDogSU5vZGUsIG5hbWU6IHN0cmluZywgZnBzOiBudW1iZXIsIGtleXM6IGFueVtdKSB7XHJcbiAgICAgICAgY29uc3QgYmFieWxvbkFuaW1hdGlvbnM6IHsgYmFieWxvbkFuaW1hdGFibGU6IElBbmltYXRhYmxlOyBiYWJ5bG9uQW5pbWF0aW9uOiBBbmltYXRpb24gfVtdID0gW107XHJcbiAgICAgICAgaWYgKHRhcmdldC5fbnVtTW9ycGhUYXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRhcmdldEluZGV4ID0gMDsgdGFyZ2V0SW5kZXggPCB0YXJnZXQuX251bU1vcnBoVGFyZ2V0czsgdGFyZ2V0SW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFieWxvbkFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oYCR7bmFtZX1fJHt0YXJnZXRJbmRleH1gLCB0aGlzLm5hbWUsIGZwcywgdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb24uc2V0S2V5cyhcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLm1hcCgoa2V5KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZToga2V5LmZyYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpblRhbmdlbnQ6IGtleS5pblRhbmdlbnQgPyBrZXkuaW5UYW5nZW50W3RhcmdldEluZGV4XSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGtleS52YWx1ZVt0YXJnZXRJbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFRhbmdlbnQ6IGtleS5vdXRUYW5nZW50ID8ga2V5Lm91dFRhbmdlbnRbdGFyZ2V0SW5kZXhdIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBrZXkuaW50ZXJwb2xhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5fcHJpbWl0aXZlQmFieWxvbk1lc2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmFieWxvbk1lc2ggb2YgdGFyZ2V0Ll9wcmltaXRpdmVCYWJ5bG9uTWVzaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYWJ5bG9uTWVzaC5tb3JwaFRhcmdldE1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vcnBoVGFyZ2V0ID0gYmFieWxvbk1lc2gubW9ycGhUYXJnZXRNYW5hZ2VyLmdldFRhcmdldCh0YXJnZXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWJ5bG9uQW5pbWF0aW9uQ2xvbmUgPSBiYWJ5bG9uQW5pbWF0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaFRhcmdldC5hbmltYXRpb25zLnB1c2goYmFieWxvbkFuaW1hdGlvbkNsb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhYnlsb25BbmltYXRpb25zLnB1c2goeyBiYWJ5bG9uQW5pbWF0YWJsZTogbW9ycGhUYXJnZXQsIGJhYnlsb25BbmltYXRpb246IGJhYnlsb25BbmltYXRpb25DbG9uZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmFieWxvbkFuaW1hdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuXHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbm9kZXMve30vdHJhbnNsYXRpb25cIiwgW25ldyBUcmFuc2Zvcm1Ob2RlQW5pbWF0aW9uUHJvcGVydHlJbmZvKEFuaW1hdGlvbi5BTklNQVRJT05UWVBFX1ZFQ1RPUjMsIFwicG9zaXRpb25cIiwgZ2V0VmVjdG9yMywgKCkgPT4gMyldKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9ub2Rlcy97fS9yb3RhdGlvblwiLCBbbmV3IFRyYW5zZm9ybU5vZGVBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfUVVBVEVSTklPTiwgXCJyb3RhdGlvblF1YXRlcm5pb25cIiwgZ2V0UXVhdGVybmlvbiwgKCkgPT4gNCldKTtcclxuU2V0SW50ZXJwb2xhdGlvbkZvcktleShcIi9ub2Rlcy97fS9zY2FsZVwiLCBbbmV3IFRyYW5zZm9ybU5vZGVBbmltYXRpb25Qcm9wZXJ0eUluZm8oQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfVkVDVE9SMywgXCJzY2FsaW5nXCIsIGdldFZlY3RvcjMsICgpID0+IDMpXSk7XHJcblNldEludGVycG9sYXRpb25Gb3JLZXkoXCIvbm9kZXMve30vd2VpZ2h0c1wiLCBbbmV3IFdlaWdodEFuaW1hdGlvblByb3BlcnR5SW5mbyhBbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVCwgXCJpbmZsdWVuY2VcIiwgZ2V0V2VpZ2h0cywgKHRhcmdldCkgPT4gdGFyZ2V0Ll9udW1Nb3JwaFRhcmdldHMhKV0pO1xyXG4iLCJpbXBvcnQgdHlwZSB7IE51bGxhYmxlIH0gZnJvbSBcImNvcmUvdHlwZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBBbmltYXRpb24gfSBmcm9tIFwiY29yZS9BbmltYXRpb25zL2FuaW1hdGlvblwiO1xyXG5pbXBvcnQgdHlwZSB7IEFuaW1hdGlvbkdyb3VwIH0gZnJvbSBcImNvcmUvQW5pbWF0aW9ucy9hbmltYXRpb25Hcm91cFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1hdGVyaWFsIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL21hdGVyaWFsXCI7XHJcbmltcG9ydCB0eXBlIHsgQ2FtZXJhIH0gZnJvbSBcImNvcmUvQ2FtZXJhcy9jYW1lcmFcIjtcclxuaW1wb3J0IHR5cGUgeyBHZW9tZXRyeSB9IGZyb20gXCJjb3JlL01lc2hlcy9nZW9tZXRyeVwiO1xyXG5pbXBvcnQgdHlwZSB7IFRyYW5zZm9ybU5vZGUgfSBmcm9tIFwiY29yZS9NZXNoZXMvdHJhbnNmb3JtTm9kZVwiO1xyXG5pbXBvcnQgdHlwZSB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlXCI7XHJcbmltcG9ydCB0eXBlIHsgTWVzaCB9IGZyb20gXCJjb3JlL01lc2hlcy9tZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgQWJzdHJhY3RNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL2Fic3RyYWN0TWVzaFwiO1xyXG5pbXBvcnQgdHlwZSB7IElEaXNwb3NhYmxlIH0gZnJvbSBcImNvcmUvc2NlbmVcIjtcclxuaW1wb3J0IHR5cGUge1xyXG4gICAgSVNjZW5lLFxyXG4gICAgSU5vZGUsXHJcbiAgICBJTWVzaCxcclxuICAgIElTa2luLFxyXG4gICAgSUNhbWVyYSxcclxuICAgIElNZXNoUHJpbWl0aXZlLFxyXG4gICAgSU1hdGVyaWFsLFxyXG4gICAgSVRleHR1cmVJbmZvLFxyXG4gICAgSUFuaW1hdGlvbixcclxuICAgIElUZXh0dXJlLFxyXG4gICAgSUJ1ZmZlclZpZXcsXHJcbiAgICBJQnVmZmVyLFxyXG4gICAgSUFuaW1hdGlvbkNoYW5uZWwsXHJcbn0gZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiBhcyBJR0xURkJhc2VMb2FkZXJFeHRlbnNpb24gfSBmcm9tIFwiLi4vZ2xURkZpbGVMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJUHJvcGVydHkgfSBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB0eXBlIHsgSUFuaW1hdGFibGUgfSBmcm9tIFwiY29yZS9BbmltYXRpb25zL2FuaW1hdGFibGUuaW50ZXJmYWNlXCI7XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIGZvciBhIGdsVEYgbG9hZGVyIGV4dGVuc2lvbi5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZMb2FkZXJFeHRlbnNpb24gZXh0ZW5kcyBJR0xURkJhc2VMb2FkZXJFeHRlbnNpb24sIElEaXNwb3NhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBsb2FkZXIgc3RhdGUgY2hhbmdlcyB0byBMT0FESU5HLlxyXG4gICAgICovXHJcbiAgICBvbkxvYWRpbmc/KCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGxvYWRlciBzdGF0ZSBjaGFuZ2VzIHRvIFJFQURZLlxyXG4gICAgICovXHJcbiAgICBvblJlYWR5PygpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aGVuIGxvYWRpbmcgc2NlbmVzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBnbFRGIHNjZW5lIHByb3BlcnR5XHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlIG9yIG51bGwgaWYgbm90IGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgbG9hZFNjZW5lQXN5bmM/KGNvbnRleHQ6IHN0cmluZywgc2NlbmU6IElTY2VuZSk6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aGVuIGxvYWRpbmcgbm9kZXMuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgZ2xURiBub2RlIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gYXNzaWduIEEgZnVuY3Rpb24gY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2FkZWQgQmFieWxvbiB0cmFuc2Zvcm0gbm9kZSB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlIG9yIG51bGwgaWYgbm90IGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgbG9hZE5vZGVBc3luYz8oY29udGV4dDogc3RyaW5nLCBub2RlOiBJTm9kZSwgYXNzaWduOiAoYmFieWxvbk1lc2g6IFRyYW5zZm9ybU5vZGUpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPFRyYW5zZm9ybU5vZGU+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZSB0aGlzIG1ldGhvZCB0byBtb2RpZnkgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBsb2FkaW5nIGNhbWVyYXMuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBnbFRGIGNhbWVyYSBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGFzc2lnbiBBIGZ1bmN0aW9uIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIEJhYnlsb24gY2FtZXJhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGUgb3IgbnVsbCBpZiBub3QgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICBsb2FkQ2FtZXJhQXN5bmM/KGNvbnRleHQ6IHN0cmluZywgY2FtZXJhOiBJQ2FtZXJhLCBhc3NpZ246IChiYWJ5bG9uQ2FtZXJhOiBDYW1lcmEpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPENhbWVyYT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBEZWZpbmUgdGhpcyBtZXRob2QgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gbG9hZGluZyB2ZXJ0ZXggZGF0YSBmb3IgbWVzaCBwcmltaXRpdmVzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHByaW1pdGl2ZSBUaGUgZ2xURiBtZXNoIHByaW1pdGl2ZSBwcm9wZXJ0eVxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIGdlb21ldHJ5IHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGUgb3IgbnVsbCBpZiBub3QgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICBfbG9hZFZlcnRleERhdGFBc3luYz8oY29udGV4dDogc3RyaW5nLCBwcmltaXRpdmU6IElNZXNoUHJpbWl0aXZlLCBiYWJ5bG9uTWVzaDogTWVzaCk6IE51bGxhYmxlPFByb21pc2U8R2VvbWV0cnk+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aGVuIGxvYWRpbmcgZGF0YSBmb3IgbWVzaCBwcmltaXRpdmVzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG1lc2ggbmFtZSB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgZ2xURiBub2RlIHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBtZXNoIFRoZSBnbFRGIG1lc2ggd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHByaW1pdGl2ZSBUaGUgZ2xURiBtZXNoIHByaW1pdGl2ZSBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGFzc2lnbiBBIGZ1bmN0aW9uIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIG1lc2ggd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZSBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIF9sb2FkTWVzaFByaW1pdGl2ZUFzeW5jPyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIG5vZGU6IElOb2RlLFxyXG4gICAgICAgIG1lc2g6IElNZXNoLFxyXG4gICAgICAgIHByaW1pdGl2ZTogSU1lc2hQcmltaXRpdmUsXHJcbiAgICAgICAgYXNzaWduOiAoYmFieWxvbk1lc2g6IEFic3RyYWN0TWVzaCkgPT4gdm9pZFxyXG4gICAgKTogTnVsbGFibGU8UHJvbWlzZTxBYnN0cmFjdE1lc2g+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aGVuIGxvYWRpbmcgbWF0ZXJpYWxzLiBMb2FkIG1hdGVyaWFsIGNyZWF0ZXMgdGhlIG1hdGVyaWFsIGFuZCB0aGVuIGxvYWRzIG1hdGVyaWFsIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gbWF0ZXJpYWwgVGhlIGdsVEYgbWF0ZXJpYWwgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBhc3NpZ24gQSBmdW5jdGlvbiBjYWxsZWQgc3luY2hyb25vdXNseSBhZnRlciBwYXJzaW5nIHRoZSBnbFRGIHByb3BlcnRpZXNcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBCYWJ5bG9uIG1hdGVyaWFsIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGUgb3IgbnVsbCBpZiBub3QgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICBfbG9hZE1hdGVyaWFsQXN5bmM/KFxyXG4gICAgICAgIGNvbnRleHQ6IHN0cmluZyxcclxuICAgICAgICBtYXRlcmlhbDogSU1hdGVyaWFsLFxyXG4gICAgICAgIGJhYnlsb25NZXNoOiBOdWxsYWJsZTxNZXNoPixcclxuICAgICAgICBiYWJ5bG9uRHJhd01vZGU6IG51bWJlcixcclxuICAgICAgICBhc3NpZ246IChiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKSA9PiB2b2lkXHJcbiAgICApOiBOdWxsYWJsZTxQcm9taXNlPE1hdGVyaWFsPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgdGhpcyBtZXRob2QgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gY3JlYXRpbmcgbWF0ZXJpYWxzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIG1hdGVyaWFsIFRoZSBnbFRGIG1hdGVyaWFsIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gYmFieWxvbkRyYXdNb2RlIFRoZSBkcmF3IG1vZGUgZm9yIHRoZSBCYWJ5bG9uIG1hdGVyaWFsXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQmFieWxvbiBtYXRlcmlhbCBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZU1hdGVyaWFsPyhjb250ZXh0OiBzdHJpbmcsIG1hdGVyaWFsOiBJTWF0ZXJpYWwsIGJhYnlsb25EcmF3TW9kZTogbnVtYmVyKTogTnVsbGFibGU8TWF0ZXJpYWw+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aGVuIGxvYWRpbmcgbWF0ZXJpYWwgcHJvcGVydGllcy5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSBtYXRlcmlhbCBUaGUgZ2xURiBtYXRlcmlhbCBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGJhYnlsb25NYXRlcmlhbCBUaGUgQmFieWxvbiBtYXRlcmlhbFxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZSBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIGxvYWRNYXRlcmlhbFByb3BlcnRpZXNBc3luYz8oY29udGV4dDogc3RyaW5nLCBtYXRlcmlhbDogSU1hdGVyaWFsLCBiYWJ5bG9uTWF0ZXJpYWw6IE1hdGVyaWFsKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgdGhpcyBtZXRob2QgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gbG9hZGluZyB0ZXh0dXJlIGluZm9zLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHRleHR1cmVJbmZvIFRoZSBnbFRGIHRleHR1cmUgaW5mbyBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGFzc2lnbiBBIGZ1bmN0aW9uIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIEJhYnlsb24gdGV4dHVyZSB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlIG9yIG51bGwgaWYgbm90IGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgbG9hZFRleHR1cmVJbmZvQXN5bmM/KGNvbnRleHQ6IHN0cmluZywgdGV4dHVyZUluZm86IElUZXh0dXJlSW5mbywgYXNzaWduOiAoYmFieWxvblRleHR1cmU6IEJhc2VUZXh0dXJlKSA9PiB2b2lkKTogTnVsbGFibGU8UHJvbWlzZTxCYXNlVGV4dHVyZT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBEZWZpbmUgdGhpcyBtZXRob2QgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gbG9hZGluZyB0ZXh0dXJlcy5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHdoZW4gbG9hZGluZyB0aGUgYXNzZXRcclxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIFRoZSBnbFRGIHRleHR1cmUgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBhc3NpZ24gQSBmdW5jdGlvbiBjYWxsZWQgc3luY2hyb25vdXNseSBhZnRlciBwYXJzaW5nIHRoZSBnbFRGIHByb3BlcnRpZXNcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBCYWJ5bG9uIHRleHR1cmUgd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZSBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIF9sb2FkVGV4dHVyZUFzeW5jPyhjb250ZXh0OiBzdHJpbmcsIHRleHR1cmU6IElUZXh0dXJlLCBhc3NpZ246IChiYWJ5bG9uVGV4dHVyZTogQmFzZVRleHR1cmUpID0+IHZvaWQpOiBOdWxsYWJsZTxQcm9taXNlPEJhc2VUZXh0dXJlPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgdGhpcyBtZXRob2QgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gbG9hZGluZyBhbmltYXRpb25zLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgZ2xURiBhbmltYXRpb24gcHJvcGVydHlcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBCYWJ5bG9uIGFuaW1hdGlvbiBncm91cCB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlIG9yIG51bGwgaWYgbm90IGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgbG9hZEFuaW1hdGlvbkFzeW5jPyhjb250ZXh0OiBzdHJpbmcsIGFuaW1hdGlvbjogSUFuaW1hdGlvbik6IE51bGxhYmxlPFByb21pc2U8QW5pbWF0aW9uR3JvdXA+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWh2YWlvciB3aGVuIGxvYWRpbmcgYW5pbWF0aW9uIGNoYW5uZWxzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbkNvbnRleHQgVGhlIGNvbnRleHQgb2YgdGhlIGFuaW1hdGlvbiB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBnbFRGIGFuaW1hdGlvbiBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGdsVEYgYW5pbWF0aW9uIGNoYW5uZWwgcHJvcGVydHlcclxuICAgICAqIEBwYXJhbSBvbkxvYWQgQ2FsbGVkIGZvciBlYWNoIGFuaW1hdGlvbiBsb2FkZWRcclxuICAgICAqIEByZXR1cm5zIEEgdm9pZCBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZSBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIF9sb2FkQW5pbWF0aW9uQ2hhbm5lbEFzeW5jPyhcclxuICAgICAgICBjb250ZXh0OiBzdHJpbmcsXHJcbiAgICAgICAgYW5pbWF0aW9uQ29udGV4dDogc3RyaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbjogSUFuaW1hdGlvbixcclxuICAgICAgICBjaGFubmVsOiBJQW5pbWF0aW9uQ2hhbm5lbCxcclxuICAgICAgICBvbkxvYWQ6IChiYWJ5bG9uQW5pbWF0YWJsZTogSUFuaW1hdGFibGUsIGJhYnlsb25BbmltYXRpb246IEFuaW1hdGlvbikgPT4gdm9pZFxyXG4gICAgKTogTnVsbGFibGU8UHJvbWlzZTx2b2lkPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIERlZmluZSB0aGlzIG1ldGhvZCB0byBtb2RpZnkgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBsb2FkaW5nIHNraW5zLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIGdsVEYgbm9kZSBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIHNraW4gVGhlIGdsVEYgc2tpbiBwcm9wZXJ0eVxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZSBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIF9sb2FkU2tpbkFzeW5jPyhjb250ZXh0OiBzdHJpbmcsIG5vZGU6IElOb2RlLCBza2luOiBJU2tpbik6IE51bGxhYmxlPFByb21pc2U8dm9pZD4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBEZWZpbmUgdGhpcyBtZXRob2QgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gbG9hZGluZyB1cmlzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBnbFRGIHByb3BlcnR5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdXJpXHJcbiAgICAgKiBAcGFyYW0gdXJpIFRoZSB1cmkgdG8gbG9hZFxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9hZGVkIGRhdGEgd2hlbiB0aGUgbG9hZCBpcyBjb21wbGV0ZSBvciBudWxsIGlmIG5vdCBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIF9sb2FkVXJpQXN5bmM/KGNvbnRleHQ6IHN0cmluZywgcHJvcGVydHk6IElQcm9wZXJ0eSwgdXJpOiBzdHJpbmcpOiBOdWxsYWJsZTxQcm9taXNlPEFycmF5QnVmZmVyVmlldz4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoaXMgbWV0aG9kIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aGVuIGxvYWRpbmcgYnVmZmVyIHZpZXdzLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgd2hlbiBsb2FkaW5nIHRoZSBhc3NldFxyXG4gICAgICogQHBhcmFtIGJ1ZmZlclZpZXcgVGhlIGdsVEYgYnVmZmVyIHZpZXcgcHJvcGVydHlcclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGxvYWRlZCBkYXRhIHdoZW4gdGhlIGxvYWQgaXMgY29tcGxldGUgb3IgbnVsbCBpZiBub3QgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICBsb2FkQnVmZmVyVmlld0FzeW5jPyhjb250ZXh0OiBzdHJpbmcsIGJ1ZmZlclZpZXc6IElCdWZmZXJWaWV3KTogTnVsbGFibGU8UHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZSB0aGlzIG1ldGhvZCB0byBtb2RpZnkgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBsb2FkaW5nIGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCB3aGVuIGxvYWRpbmcgdGhlIGFzc2V0XHJcbiAgICAgKiBAcGFyYW0gYnVmZmVyIFRoZSBnbFRGIGJ1ZmZlciBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIGJ5dGVPZmZzZXQgVGhlIGJ5dGUgb2Zmc2V0IHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBieXRlTGVuZ3RoIFRoZSBieXRlIGxlbmd0aCB0byBsb2FkXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBsb2FkZWQgZGF0YSB3aGVuIHRoZSBsb2FkIGlzIGNvbXBsZXRlIG9yIG51bGwgaWYgbm90IGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgbG9hZEJ1ZmZlckFzeW5jPyhjb250ZXh0OiBzdHJpbmcsIGJ1ZmZlcjogSUJ1ZmZlciwgYnl0ZU9mZnNldDogbnVtYmVyLCBieXRlTGVuZ3RoOiBudW1iZXIpOiBOdWxsYWJsZTxQcm9taXNlPEFycmF5QnVmZmVyVmlldz4+O1xyXG59XHJcbiIsImltcG9ydCB0eXBlIHsgR0xURkxvYWRlciB9IGZyb20gXCIuL2dsVEZMb2FkZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBJR0xURkxvYWRlckV4dGVuc2lvbiB9IGZyb20gXCIuL2dsVEZMb2FkZXJFeHRlbnNpb25cIjtcclxuXHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjb3JlL01pc2MvbG9nZ2VyXCI7XHJcblxyXG5pbnRlcmZhY2UgSVJlZ2lzdGVyZWRHTFRGRXh0ZW5zaW9uIHtcclxuICAgIGlzR0xURkV4dGVuc2lvbjogYm9vbGVhbjtcclxuICAgIGZhY3Rvcnk6IEdMVEZFeHRlbnNpb25GYWN0b3J5O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBHTFRGRXh0ZW5zaW9uRmFjdG9yeSA9IChsb2FkZXI6IEdMVEZMb2FkZXIpID0+IElHTFRGTG9hZGVyRXh0ZW5zaW9uIHwgUHJvbWlzZTxJR0xURkxvYWRlckV4dGVuc2lvbj47XHJcblxyXG5jb25zdCBSZWdpc3RlcmVkR0xURkV4dGVuc2lvbnMgPSBuZXcgTWFwPHN0cmluZywgSVJlZ2lzdGVyZWRHTFRGRXh0ZW5zaW9uPigpO1xyXG5cclxuLyoqXHJcbiAqIEFsbCBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbFRGIDIuMCBsb2FkZXIgZXh0ZW5zaW9ucy5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyZWRHTFRGRXh0ZW5zaW9uczogUmVhZG9ubHlNYXA8c3RyaW5nLCBSZWFkb25seTxJUmVnaXN0ZXJlZEdMVEZFeHRlbnNpb24+PiA9IFJlZ2lzdGVyZWRHTFRGRXh0ZW5zaW9ucztcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBsb2FkZXIgZXh0ZW5zaW9uLlxyXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbG9hZGVyIGV4dGVuc2lvbi5cclxuICogQHBhcmFtIGlzR0xURkV4dGVuc2lvbiBJZiB0aGUgbG9hZGVyIGV4dGVuc2lvbiBpcyBhIGdsVEYgZXh0ZW5zaW9uLCB0aGVuIGl0IHdpbGwgb25seSBiZSB1c2VkIGZvciBnbFRGIGZpbGVzIHRoYXQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIGdsVEYgZXh0ZW5zaW9uLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgdXNlZCBmb3IgYWxsIGxvYWRlZCBnbFRGIGZpbGVzLlxyXG4gKiBAcGFyYW0gZmFjdG9yeSBUaGUgZmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGxvYWRlciBleHRlbnNpb24uXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckdMVEZFeHRlbnNpb24obmFtZTogc3RyaW5nLCBpc0dMVEZFeHRlbnNpb246IGJvb2xlYW4sIGZhY3Rvcnk6IEdMVEZFeHRlbnNpb25GYWN0b3J5KTogdm9pZCB7XHJcbiAgICBpZiAodW5yZWdpc3RlckdMVEZFeHRlbnNpb24obmFtZSkpIHtcclxuICAgICAgICBMb2dnZXIuV2FybihgRXh0ZW5zaW9uIHdpdGggdGhlIG5hbWUgJyR7bmFtZX0nIGFscmVhZHkgZXhpc3RzYCk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVnaXN0ZXJlZEdMVEZFeHRlbnNpb25zLnNldChuYW1lLCB7XHJcbiAgICAgICAgaXNHTFRGRXh0ZW5zaW9uLFxyXG4gICAgICAgIGZhY3RvcnksXHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVucmVnaXN0ZXJzIGEgbG9hZGVyIGV4dGVuc2lvbi5cclxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxvYWRlciBleHRlbnNpb24uXHJcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGV4dGVuc2lvbiBoYXMgYmVlbiB1bnJlZ2lzdGVyZWRcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIHVucmVnaXN0ZXJHTFRGRXh0ZW5zaW9uKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIFJlZ2lzdGVyZWRHTFRGRXh0ZW5zaW9ucy5kZWxldGUobmFtZSk7XHJcbn1cclxuIiwiaW1wb3J0IHR5cGUgeyBBbmltYXRpb25Hcm91cCB9IGZyb20gXCJjb3JlL0FuaW1hdGlvbnMvYW5pbWF0aW9uR3JvdXBcIjtcclxuaW1wb3J0IHR5cGUgeyBTa2VsZXRvbiB9IGZyb20gXCJjb3JlL0JvbmVzL3NrZWxldG9uXCI7XHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBUcmFuc2Zvcm1Ob2RlIH0gZnJvbSBcImNvcmUvTWVzaGVzL3RyYW5zZm9ybU5vZGVcIjtcclxuaW1wb3J0IHR5cGUgeyBCdWZmZXIsIFZlcnRleEJ1ZmZlciB9IGZyb20gXCJjb3JlL0J1ZmZlcnMvYnVmZmVyXCI7XHJcbmltcG9ydCB0eXBlIHsgQWJzdHJhY3RNZXNoIH0gZnJvbSBcImNvcmUvTWVzaGVzL2Fic3RyYWN0TWVzaFwiO1xyXG5pbXBvcnQgdHlwZSB7IE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvbWVzaFwiO1xyXG5pbXBvcnQgdHlwZSB7IENhbWVyYSB9IGZyb20gXCJjb3JlL0NhbWVyYXMvY2FtZXJhXCI7XHJcbmltcG9ydCB0eXBlIHsgTGlnaHQgfSBmcm9tIFwiY29yZS9MaWdodHMvbGlnaHRcIjtcclxuXHJcbmltcG9ydCB0eXBlICogYXMgR0xURjIgZnJvbSBcImJhYnlsb25qcy1nbHRmMmludGVyZmFjZVwiO1xyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhbiBpbmRleCBmaWVsZC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFycmF5SXRlbSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGlzIGl0ZW0gaW4gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFjY2Vzc29yIGV4dGVuZHMgR0xURjIuSUFjY2Vzc29yLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9kYXRhPzogUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+O1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9iYWJ5bG9uVmVydGV4QnVmZmVyPzogeyBba2luZDogc3RyaW5nXTogUHJvbWlzZTxWZXJ0ZXhCdWZmZXI+IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQW5pbWF0aW9uQ2hhbm5lbCBleHRlbmRzIEdMVEYyLklBbmltYXRpb25DaGFubmVsLCBJQXJyYXlJdGVtIHt9XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGludGVyZmFjZSBfSUFuaW1hdGlvblNhbXBsZXJEYXRhIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGlucHV0OiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgaW50ZXJwb2xhdGlvbjogR0xURjIuQW5pbWF0aW9uU2FtcGxlckludGVycG9sYXRpb247XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgb3V0cHV0OiBGbG9hdDMyQXJyYXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQW5pbWF0aW9uU2FtcGxlciBleHRlbmRzIEdMVEYyLklBbmltYXRpb25TYW1wbGVyLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9kYXRhPzogUHJvbWlzZTxfSUFuaW1hdGlvblNhbXBsZXJEYXRhPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElBbmltYXRpb24gZXh0ZW5kcyBHTFRGMi5JQW5pbWF0aW9uLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNoYW5uZWxzOiBJQW5pbWF0aW9uQ2hhbm5lbFtdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHNhbXBsZXJzOiBJQW5pbWF0aW9uU2FtcGxlcltdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9iYWJ5bG9uQW5pbWF0aW9uR3JvdXA/OiBBbmltYXRpb25Hcm91cDtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElCdWZmZXIgZXh0ZW5kcyBHTFRGMi5JQnVmZmVyLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9kYXRhPzogUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+O1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUJ1ZmZlclZpZXcgZXh0ZW5kcyBHTFRGMi5JQnVmZmVyVmlldywgSUFycmF5SXRlbSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZGF0YT86IFByb21pc2U8QXJyYXlCdWZmZXJWaWV3PjtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfYmFieWxvbkJ1ZmZlcj86IFByb21pc2U8QnVmZmVyPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDYW1lcmEgZXh0ZW5kcyBHTFRGMi5JQ2FtZXJhLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9iYWJ5bG9uQ2FtZXJhPzogQ2FtZXJhO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUltYWdlIGV4dGVuZHMgR0xURjIuSUltYWdlLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9kYXRhPzogUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXc+O1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm8gZXh0ZW5kcyBHTFRGMi5JTWF0ZXJpYWxOb3JtYWxUZXh0dXJlSW5mbywgSVRleHR1cmVJbmZvIHt9XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1hdGVyaWFsT2NjbHVzaW9uVGV4dHVyZUluZm8gZXh0ZW5kcyBHTFRGMi5JTWF0ZXJpYWxPY2NsdXNpb25UZXh0dXJlSW5mbywgSVRleHR1cmVJbmZvIHt9XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1hdGVyaWFsUGJyTWV0YWxsaWNSb3VnaG5lc3MgZXh0ZW5kcyBHTFRGMi5JTWF0ZXJpYWxQYnJNZXRhbGxpY1JvdWdobmVzcyB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBiYXNlQ29sb3JUZXh0dXJlPzogSVRleHR1cmVJbmZvO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT86IElUZXh0dXJlSW5mbztcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElNYXRlcmlhbCBleHRlbmRzIEdMVEYyLklNYXRlcmlhbCwgSUFycmF5SXRlbSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwYnJNZXRhbGxpY1JvdWdobmVzcz86IElNYXRlcmlhbFBick1ldGFsbGljUm91Z2huZXNzO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIG5vcm1hbFRleHR1cmU/OiBJTWF0ZXJpYWxOb3JtYWxUZXh0dXJlSW5mbztcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBvY2NsdXNpb25UZXh0dXJlPzogSU1hdGVyaWFsT2NjbHVzaW9uVGV4dHVyZUluZm87XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pc3NpdmVUZXh0dXJlPzogSVRleHR1cmVJbmZvO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9kYXRhPzoge1xyXG4gICAgICAgIFtiYWJ5bG9uRHJhd01vZGU6IG51bWJlcl06IHtcclxuICAgICAgICAgICAgYmFieWxvbk1hdGVyaWFsOiBNYXRlcmlhbDtcclxuICAgICAgICAgICAgYmFieWxvbk1lc2hlczogQWJzdHJhY3RNZXNoW107XHJcbiAgICAgICAgICAgIHByb21pc2U6IFByb21pc2U8dm9pZD47XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTWVzaCBleHRlbmRzIEdMVEYyLklNZXNoLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHByaW1pdGl2ZXM6IElNZXNoUHJpbWl0aXZlW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTWVzaFByaW1pdGl2ZSBleHRlbmRzIEdMVEYyLklNZXNoUHJpbWl0aXZlLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9pbnN0YW5jZURhdGE/OiB7XHJcbiAgICAgICAgYmFieWxvblNvdXJjZU1lc2g6IE1lc2g7XHJcbiAgICAgICAgcHJvbWlzZTogUHJvbWlzZTxhbnk+O1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElOb2RlIGV4dGVuZHMgR0xURjIuSU5vZGUsIElBcnJheUl0ZW0ge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcGFyZW50PzogSU5vZGU7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2JhYnlsb25UcmFuc2Zvcm1Ob2RlPzogVHJhbnNmb3JtTm9kZTtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfYmFieWxvblRyYW5zZm9ybU5vZGVGb3JTa2luPzogVHJhbnNmb3JtTm9kZTtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfcHJpbWl0aXZlQmFieWxvbk1lc2hlcz86IEFic3RyYWN0TWVzaFtdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9udW1Nb3JwaFRhcmdldHM/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2lzSm9pbnQ/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGludGVyZmFjZSBfSVNhbXBsZXJEYXRhIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIG5vTWlwTWFwczogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzYW1wbGluZ01vZGU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB3cmFwVTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHdyYXBWOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJU2FtcGxlciBleHRlbmRzIEdMVEYyLklTYW1wbGVyLCBJQXJyYXlJdGVtIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9kYXRhPzogX0lTYW1wbGVyRGF0YTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTY2VuZSBleHRlbmRzIEdMVEYyLklTY2VuZSwgSUFycmF5SXRlbSB7fVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTa2luIGV4dGVuZHMgR0xURjIuSVNraW4sIElBcnJheUl0ZW0ge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2RhdGE/OiB7XHJcbiAgICAgICAgYmFieWxvblNrZWxldG9uOiBTa2VsZXRvbjtcclxuICAgICAgICBwcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRlciBpbnRlcmZhY2Ugd2l0aCBhZGRpdGlvbmFsIG1lbWJlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElUZXh0dXJlIGV4dGVuZHMgR0xURjIuSVRleHR1cmUsIElBcnJheUl0ZW0ge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX3RleHR1cmVJbmZvOiBJVGV4dHVyZUluZm87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJVGV4dHVyZUluZm8gZXh0ZW5kcyBHTFRGMi5JVGV4dHVyZUluZm8ge1xyXG4gICAgLyoqIGZhbHNlIG9yIHVuZGVmaW5lZCBpZiB0aGUgdGV4dHVyZSBob2xkcyBjb2xvciBkYXRhICh0cnVlIGlmIGRhdGEgYXJlIHJvdWdobmVzcywgbm9ybWFsLCAuLi4pICovXHJcbiAgICBub25Db2xvckRhdGE/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZGVyIGludGVyZmFjZSB3aXRoIGFkZGl0aW9uYWwgbWVtYmVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEYgZXh0ZW5kcyBHTFRGMi5JR0xURiB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhY2Nlc3NvcnM/OiBJQWNjZXNzb3JbXTtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhbmltYXRpb25zPzogSUFuaW1hdGlvbltdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGJ1ZmZlcnM/OiBJQnVmZmVyW107XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYnVmZmVyVmlld3M/OiBJQnVmZmVyVmlld1tdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNhbWVyYXM/OiBJQ2FtZXJhW107XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgaW1hZ2VzPzogSUltYWdlW107XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgbWF0ZXJpYWxzPzogSU1hdGVyaWFsW107XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgbWVzaGVzPzogSU1lc2hbXTtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBub2Rlcz86IElOb2RlW107XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc2FtcGxlcnM/OiBJU2FtcGxlcltdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHNjZW5lcz86IElTY2VuZVtdO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHNraW5zPzogSVNraW5bXTtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB0ZXh0dXJlcz86IElUZXh0dXJlW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkZXIgaW50ZXJmYWNlIHdpdGggYWRkaXRpb25hbCBtZW1iZXJzLlxyXG4gKi9cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5leHBvcnQgaW50ZXJmYWNlIElLSFJMaWdodHNQdW5jdHVhbF9MaWdodCBleHRlbmRzIEdMVEYyLklLSFJMaWdodHNQdW5jdHVhbF9MaWdodCwgSUFycmF5SXRlbSB7XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgX2JhYnlsb25MaWdodD86IExpZ2h0O1xyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGludGVyZmFjZSBJRVhUTGlnaHRzSUVTX0xpZ2h0IGV4dGVuZHMgR0xURjIuSUVYVExpZ2h0c0lFU19MaWdodCwgSUFycmF5SXRlbSB7XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgX2JhYnlsb25MaWdodD86IExpZ2h0O1xyXG59XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1pbnRlcm5hbC1tb2R1bGVzICovXHJcbmV4cG9ydCAqIGZyb20gXCIuL2dsVEZMb2FkZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURkxvYWRlckV4dGVuc2lvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9nbFRGTG9hZGVyRXh0ZW5zaW9uUmVnaXN0cnlcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURkxvYWRlckFuaW1hdGlvblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9FeHRlbnNpb25zL2luZGV4XCI7XHJcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8taW50ZXJuYWwtbW9kdWxlc1xyXG5pbXBvcnQgdHlwZSB7IElTY2VuZUxvYWRlclBsdWdpbkV4dGVuc2lvbnMsIElTY2VuZUxvYWRlclBsdWdpbk1ldGFkYXRhIH0gZnJvbSBcImNvcmUvaW5kZXhcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBHTFRGTWFnaWNCYXNlNjRFbmNvZGVkID0gXCJaMnhVUmdcIjsgLy8gXCJnbFRGXCIgYmFzZTY0IGVuY29kZWQgKHdpdGhvdXQgdGhlIHF1b3RlcyEpXHJcblxyXG5leHBvcnQgY29uc3QgR0xURkZpbGVMb2FkZXJNZXRhZGF0YSA9IHtcclxuICAgIG5hbWU6IFwiZ2x0ZlwiLFxyXG5cclxuICAgIGV4dGVuc2lvbnM6IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICAgICAgXCIuZ2x0ZlwiOiB7IGlzQmluYXJ5OiBmYWxzZSwgbWltZVR5cGU6IFwibW9kZWwvZ2x0Zitqc29uXCIgfSxcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICAgICAgXCIuZ2xiXCI6IHsgaXNCaW5hcnk6IHRydWUsIG1pbWVUeXBlOiBcIm1vZGVsL2dsdGYtYmluYXJ5XCIgfSxcclxuICAgIH0gYXMgY29uc3Qgc2F0aXNmaWVzIElTY2VuZUxvYWRlclBsdWdpbkV4dGVuc2lvbnMsXHJcblxyXG4gICAgY2FuRGlyZWN0TG9hZChkYXRhOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAoZGF0YS5pbmRleE9mKFwiYXNzZXRcIikgIT09IC0xICYmIGRhdGEuaW5kZXhPZihcInZlcnNpb25cIikgIT09IC0xKSB8fFxyXG4gICAgICAgICAgICBkYXRhLnN0YXJ0c1dpdGgoXCJkYXRhOmJhc2U2NCxcIiArIEdMVEZNYWdpY0Jhc2U2NEVuY29kZWQpIHx8IC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgaW5jb3JyZWN0LCBidXQgd2lsbCBjb250aW51ZSB0byBzdXBwb3J0IGZvciBiYWNrY29tcGF0LlxyXG4gICAgICAgICAgICBkYXRhLnN0YXJ0c1dpdGgoXCJkYXRhOjtiYXNlNjQsXCIgKyBHTFRGTWFnaWNCYXNlNjRFbmNvZGVkKSB8fFxyXG4gICAgICAgICAgICBkYXRhLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIgKyBHTFRGTWFnaWNCYXNlNjRFbmNvZGVkKSB8fFxyXG4gICAgICAgICAgICBkYXRhLnN0YXJ0c1dpdGgoXCJkYXRhOm1vZGVsL2dsdGYtYmluYXJ5O2Jhc2U2NCxcIiArIEdMVEZNYWdpY0Jhc2U2NEVuY29kZWQpXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcbn0gYXMgY29uc3Qgc2F0aXNmaWVzIElTY2VuZUxvYWRlclBsdWdpbk1ldGFkYXRhO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBnaXRodWIvbm8tdGhlbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnMgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xyXG5pbXBvcnQgdHlwZSAqIGFzIEdMVEYyIGZyb20gXCJiYWJ5bG9uanMtZ2x0ZjJpbnRlcmZhY2VcIjtcclxuaW1wb3J0IHR5cGUgeyBOdWxsYWJsZSB9IGZyb20gXCJjb3JlL3R5cGVzXCI7XHJcbmltcG9ydCB0eXBlIHsgT2JzZXJ2ZXIgfSBmcm9tIFwiY29yZS9NaXNjL29ic2VydmFibGVcIjtcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJjb3JlL01pc2Mvb2JzZXJ2YWJsZVwiO1xyXG5pbXBvcnQgeyBUb29scyB9IGZyb20gXCJjb3JlL01pc2MvdG9vbHNcIjtcclxuaW1wb3J0IHR5cGUgeyBDYW1lcmEgfSBmcm9tIFwiY29yZS9DYW1lcmFzL2NhbWVyYVwiO1xyXG5pbXBvcnQgdHlwZSB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcImNvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlXCI7XHJcbmltcG9ydCB0eXBlIHsgTWF0ZXJpYWwgfSBmcm9tIFwiY29yZS9NYXRlcmlhbHMvbWF0ZXJpYWxcIjtcclxuaW1wb3J0IHR5cGUgeyBBYnN0cmFjdE1lc2ggfSBmcm9tIFwiY29yZS9NZXNoZXMvYWJzdHJhY3RNZXNoXCI7XHJcbmltcG9ydCB0eXBlIHsgSVNjZW5lTG9hZGVyUGx1Z2luRmFjdG9yeSwgSVNjZW5lTG9hZGVyUGx1Z2luQXN5bmMsIElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQsIElTY2VuZUxvYWRlckFzeW5jUmVzdWx0LCBTY2VuZUxvYWRlclBsdWdpbk9wdGlvbnMgfSBmcm9tIFwiY29yZS9Mb2FkaW5nL3NjZW5lTG9hZGVyXCI7XHJcbmltcG9ydCB7IFJlZ2lzdGVyU2NlbmVMb2FkZXJQbHVnaW4gfSBmcm9tIFwiY29yZS9Mb2FkaW5nL3NjZW5lTG9hZGVyXCI7XHJcbmltcG9ydCB7IEFzc2V0Q29udGFpbmVyIH0gZnJvbSBcImNvcmUvYXNzZXRDb250YWluZXJcIjtcclxuaW1wb3J0IHR5cGUgeyBTY2VuZSwgSURpc3Bvc2FibGUgfSBmcm9tIFwiY29yZS9zY2VuZVwiO1xyXG5pbXBvcnQgdHlwZSB7IFdlYlJlcXVlc3QgfSBmcm9tIFwiY29yZS9NaXNjL3dlYlJlcXVlc3RcIjtcclxuaW1wb3J0IHR5cGUgeyBJRmlsZVJlcXVlc3QgfSBmcm9tIFwiY29yZS9NaXNjL2ZpbGVSZXF1ZXN0XCI7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjb3JlL01pc2MvbG9nZ2VyXCI7XHJcbmltcG9ydCB0eXBlIHsgSURhdGFCdWZmZXIgfSBmcm9tIFwiY29yZS9NaXNjL2RhdGFSZWFkZXJcIjtcclxuaW1wb3J0IHsgRGF0YVJlYWRlciB9IGZyb20gXCJjb3JlL01pc2MvZGF0YVJlYWRlclwiO1xyXG5pbXBvcnQgeyBHTFRGVmFsaWRhdGlvbiB9IGZyb20gXCIuL2dsVEZWYWxpZGF0aW9uXCI7XHJcbmltcG9ydCB7IEdMVEZGaWxlTG9hZGVyTWV0YWRhdGEsIEdMVEZNYWdpY0Jhc2U2NEVuY29kZWQgfSBmcm9tIFwiLi9nbFRGRmlsZUxvYWRlci5tZXRhZGF0YVwiO1xyXG5pbXBvcnQgdHlwZSB7IExvYWRGaWxlRXJyb3IgfSBmcm9tIFwiY29yZS9NaXNjL2ZpbGVUb29sc1wiO1xyXG5pbXBvcnQgeyBEZWNvZGVCYXNlNjRVcmxUb0JpbmFyeSB9IGZyb20gXCJjb3JlL01pc2MvZmlsZVRvb2xzXCI7XHJcbmltcG9ydCB7IFJ1bnRpbWVFcnJvciwgRXJyb3JDb2RlcyB9IGZyb20gXCJjb3JlL01pc2MvZXJyb3JcIjtcclxuaW1wb3J0IHR5cGUgeyBUcmFuc2Zvcm1Ob2RlIH0gZnJvbSBcImNvcmUvTWVzaGVzL3RyYW5zZm9ybU5vZGVcIjtcclxuaW1wb3J0IHR5cGUgeyBNb3JwaFRhcmdldE1hbmFnZXIgfSBmcm9tIFwiY29yZS9Nb3JwaC9tb3JwaFRhcmdldE1hbmFnZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIG9wdGlvbnMgZm9yIGdsVEYgbG9hZGVyIGV4dGVuc2lvbnMuIFRoaXMgaW50ZXJmYWNlIGlzIGV4dGVuZGVkIGJ5IHNwZWNpZmljIGV4dGVuc2lvbnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQ+IHt9XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcImNvcmUvTG9hZGluZy9zY2VuZUxvYWRlclwiIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFNjZW5lTG9hZGVyUGx1Z2luT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lcyBvcHRpb25zIGZvciB0aGUgZ2xURiBsb2FkZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgW0dMVEZGaWxlTG9hZGVyTWV0YWRhdGEubmFtZV06IFBhcnRpYWw8R0xURkxvYWRlck9wdGlvbnM+O1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgSUZpbGVSZXF1ZXN0SW5mbyBleHRlbmRzIElGaWxlUmVxdWVzdCB7XHJcbiAgICBfbGVuZ3RoQ29tcHV0YWJsZT86IGJvb2xlYW47XHJcbiAgICBfbG9hZGVkPzogbnVtYmVyO1xyXG4gICAgX3RvdGFsPzogbnVtYmVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkQXN5bmMoYXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyLCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IFByb21pc2U8VWludDhBcnJheT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVmlld0FzeW5jKGFycmF5QnVmZmVyVmlldzogQXJyYXlCdWZmZXJWaWV3LCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IFByb21pc2U8VWludDhBcnJheT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBhcnJheUJ1ZmZlclZpZXcuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk9mZnNldCBpcyBvdXQgb2YgcmFuZ2UuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gYXJyYXlCdWZmZXJWaWV3LmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMZW5ndGggaXMgb3V0IG9mIHJhbmdlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXJWaWV3LmJ1ZmZlciwgYXJyYXlCdWZmZXJWaWV3LmJ5dGVPZmZzZXQgKyBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogTW9kZSB0aGF0IGRldGVybWluZXMgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHVzZS5cclxuICovXHJcbmV4cG9ydCBlbnVtIEdMVEZMb2FkZXJDb29yZGluYXRlU3lzdGVtTW9kZSB7XHJcbiAgICAvKipcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY29udmVydCB0aGUgZ2xURiByaWdodC1oYW5kZWQgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgc3lzdGVtIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNvb3JkaW5hdGUgc3lzdGVtIG1vZGUgb2YgdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBBVVRPLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdXNlUmlnaHRIYW5kZWRTeXN0ZW0gZmxhZyBvbiB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIEZPUkNFX1JJR0hUX0hBTkRFRCxcclxufVxyXG5cclxuLyoqXHJcbiAqIE1vZGUgdGhhdCBkZXRlcm1pbmVzIHdoYXQgYW5pbWF0aW9ucyB3aWxsIHN0YXJ0LlxyXG4gKi9cclxuZXhwb3J0IGVudW0gR0xURkxvYWRlckFuaW1hdGlvblN0YXJ0TW9kZSB7XHJcbiAgICAvKipcclxuICAgICAqIE5vIGFuaW1hdGlvbiB3aWxsIHN0YXJ0LlxyXG4gICAgICovXHJcbiAgICBOT05FLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpcnN0IGFuaW1hdGlvbiB3aWxsIHN0YXJ0LlxyXG4gICAgICovXHJcbiAgICBGSVJTVCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbCBhbmltYXRpb25zIHdpbGwgc3RhcnQuXHJcbiAgICAgKi9cclxuICAgIEFMTCxcclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVyZmFjZSB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIGZvciB0aGUgZ2xURiBhc3NldC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZMb2FkZXJEYXRhIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGdsVEYgSlNPTi5cclxuICAgICAqL1xyXG4gICAganNvbjogb2JqZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIEJJTiBjaHVuayBvZiBhIGJpbmFyeSBnbFRGLlxyXG4gICAgICovXHJcbiAgICBiaW46IE51bGxhYmxlPElEYXRhQnVmZmVyPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVyZmFjZSBmb3IgZXh0ZW5kaW5nIHRoZSBsb2FkZXIuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGTG9hZGVyRXh0ZW5zaW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGlzIGV4dGVuc2lvbiBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB0aGUgb3JkZXIgb2YgdGhpcyBleHRlbnNpb24uXHJcbiAgICAgKiBUaGUgbG9hZGVyIHNvcnRzIHRoZSBleHRlbnNpb25zIHVzaW5nIHRoZXNlIHZhbHVlcyB3aGVuIGxvYWRpbmcuXHJcbiAgICAgKi9cclxuICAgIG9yZGVyPzogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZGVyIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gR0xURkxvYWRlclN0YXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFzc2V0IGlzIGxvYWRpbmcuXHJcbiAgICAgKi9cclxuICAgIExPQURJTkcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXNzZXQgaXMgcmVhZHkgZm9yIHJlbmRlcmluZy5cclxuICAgICAqL1xyXG4gICAgUkVBRFksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXNzZXQgaXMgY29tcGxldGVseSBsb2FkZWQuXHJcbiAgICAgKi9cclxuICAgIENPTVBMRVRFLFxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUdMVEZMb2FkZXIgZXh0ZW5kcyBJRGlzcG9zYWJsZSB7XHJcbiAgICBpbXBvcnRNZXNoQXN5bmM6IChcclxuICAgICAgICBtZXNoZXNOYW1lczogc3RyaW5nIHwgcmVhZG9ubHkgc3RyaW5nW10gfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgICAgIHNjZW5lOiBTY2VuZSxcclxuICAgICAgICBjb250YWluZXI6IE51bGxhYmxlPEFzc2V0Q29udGFpbmVyPixcclxuICAgICAgICBkYXRhOiBJR0xURkxvYWRlckRhdGEsXHJcbiAgICAgICAgcm9vdFVybDogc3RyaW5nLFxyXG4gICAgICAgIG9uUHJvZ3Jlc3M/OiAoZXZlbnQ6IElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQpID0+IHZvaWQsXHJcbiAgICAgICAgZmlsZU5hbWU/OiBzdHJpbmdcclxuICAgICkgPT4gUHJvbWlzZTxJU2NlbmVMb2FkZXJBc3luY1Jlc3VsdD47XHJcbiAgICBsb2FkQXN5bmM6IChzY2VuZTogU2NlbmUsIGRhdGE6IElHTFRGTG9hZGVyRGF0YSwgcm9vdFVybDogc3RyaW5nLCBvblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLCBmaWxlTmFtZT86IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgZGVmYXVsdC9pbXBsaWNpdCBvcHRpb25zIHRvIGV4dGVuc2lvbiBzcGVjaWZpYyBvcHRpb25zLlxyXG4gKi9cclxudHlwZSBEZWZhdWx0RXh0ZW5zaW9uT3B0aW9uczxCYXNlRXh0ZW5zaW9uT3B0aW9ucz4gPSB7XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgdGhlIGV4dGVuc2lvbiBpcyBlbmFibGVkXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZWQ/OiBib29sZWFuO1xyXG59ICYgQmFzZUV4dGVuc2lvbk9wdGlvbnM7XHJcblxyXG5hYnN0cmFjdCBjbGFzcyBHTFRGTG9hZGVyT3B0aW9ucyB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFieWxvbmpzL2F2YWlsYWJsZVxyXG4gICAgcHJvdGVjdGVkIGNvcHlGcm9tKG9wdGlvbnM/OiBQYXJ0aWFsPFJlYWRvbmx5PEdMVEZMb2FkZXJPcHRpb25zPj4pIHtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9uUGFyc2VkID0gb3B0aW9ucy5vblBhcnNlZDtcclxuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRlU3lzdGVtTW9kZSA9IG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbU1vZGUgPz8gdGhpcy5jb29yZGluYXRlU3lzdGVtTW9kZTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGFydE1vZGUgPSBvcHRpb25zLmFuaW1hdGlvblN0YXJ0TW9kZSA/PyB0aGlzLmFuaW1hdGlvblN0YXJ0TW9kZTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkTm9kZUFuaW1hdGlvbnMgPSBvcHRpb25zLmxvYWROb2RlQW5pbWF0aW9ucyA/PyB0aGlzLmxvYWROb2RlQW5pbWF0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5sb2FkU2tpbnMgPSBvcHRpb25zLmxvYWRTa2lucyA/PyB0aGlzLmxvYWRTa2lucztcclxuICAgICAgICAgICAgdGhpcy5sb2FkTW9ycGhUYXJnZXRzID0gb3B0aW9ucy5sb2FkTW9ycGhUYXJnZXRzID8/IHRoaXMubG9hZE1vcnBoVGFyZ2V0cztcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlTWF0ZXJpYWxzID0gb3B0aW9ucy5jb21waWxlTWF0ZXJpYWxzID8/IHRoaXMuY29tcGlsZU1hdGVyaWFscztcclxuICAgICAgICAgICAgdGhpcy51c2VDbGlwUGxhbmUgPSBvcHRpb25zLnVzZUNsaXBQbGFuZSA/PyB0aGlzLnVzZUNsaXBQbGFuZTtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlU2hhZG93R2VuZXJhdG9ycyA9IG9wdGlvbnMuY29tcGlsZVNoYWRvd0dlbmVyYXRvcnMgPz8gdGhpcy5jb21waWxlU2hhZG93R2VuZXJhdG9ycztcclxuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lBc0NvdmVyYWdlID0gb3B0aW9ucy50cmFuc3BhcmVuY3lBc0NvdmVyYWdlID8/IHRoaXMudHJhbnNwYXJlbmN5QXNDb3ZlcmFnZTtcclxuICAgICAgICAgICAgdGhpcy51c2VSYW5nZVJlcXVlc3RzID0gb3B0aW9ucy51c2VSYW5nZVJlcXVlc3RzID8/IHRoaXMudXNlUmFuZ2VSZXF1ZXN0cztcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnN0YW5jZXMgPSBvcHRpb25zLmNyZWF0ZUluc3RhbmNlcyA/PyB0aGlzLmNyZWF0ZUluc3RhbmNlcztcclxuICAgICAgICAgICAgdGhpcy5hbHdheXNDb21wdXRlQm91bmRpbmdCb3ggPSBvcHRpb25zLmFsd2F5c0NvbXB1dGVCb3VuZGluZ0JveCA/PyB0aGlzLmFsd2F5c0NvbXB1dGVCb3VuZGluZ0JveDtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQWxsTWF0ZXJpYWxzID0gb3B0aW9ucy5sb2FkQWxsTWF0ZXJpYWxzID8/IHRoaXMubG9hZEFsbE1hdGVyaWFscztcclxuICAgICAgICAgICAgdGhpcy5sb2FkT25seU1hdGVyaWFscyA9IG9wdGlvbnMubG9hZE9ubHlNYXRlcmlhbHMgPz8gdGhpcy5sb2FkT25seU1hdGVyaWFscztcclxuICAgICAgICAgICAgdGhpcy5za2lwTWF0ZXJpYWxzID0gb3B0aW9ucy5za2lwTWF0ZXJpYWxzID8/IHRoaXMuc2tpcE1hdGVyaWFscztcclxuICAgICAgICAgICAgdGhpcy51c2VTUkdCQnVmZmVycyA9IG9wdGlvbnMudXNlU1JHQkJ1ZmZlcnMgPz8gdGhpcy51c2VTUkdCQnVmZmVycztcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRGcHMgPSBvcHRpb25zLnRhcmdldEZwcyA/PyB0aGlzLnRhcmdldEZwcztcclxuICAgICAgICAgICAgdGhpcy5hbHdheXNDb21wdXRlU2tlbGV0b25Sb290Tm9kZSA9IG9wdGlvbnMuYWx3YXlzQ29tcHV0ZVNrZWxldG9uUm9vdE5vZGUgPz8gdGhpcy5hbHdheXNDb21wdXRlU2tlbGV0b25Sb290Tm9kZTtcclxuICAgICAgICAgICAgdGhpcy51c2VHbHRmVGV4dHVyZU5hbWVzID0gb3B0aW9ucy51c2VHbHRmVGV4dHVyZU5hbWVzID8/IHRoaXMudXNlR2x0ZlRleHR1cmVOYW1lcztcclxuICAgICAgICAgICAgdGhpcy5wcmVwcm9jZXNzVXJsQXN5bmMgPSBvcHRpb25zLnByZXByb2Nlc3NVcmxBc3luYyA/PyB0aGlzLnByZXByb2Nlc3NVcmxBc3luYztcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21Sb290Tm9kZSA9IG9wdGlvbnMuY3VzdG9tUm9vdE5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMub25NZXNoTG9hZGVkID0gb3B0aW9ucy5vbk1lc2hMb2FkZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25Ta2luTG9hZGVkID0gb3B0aW9ucy5vblNraW5Mb2FkZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25UZXh0dXJlTG9hZGVkID0gb3B0aW9ucy5vblRleHR1cmVMb2FkZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25NYXRlcmlhbExvYWRlZCA9IG9wdGlvbnMub25NYXRlcmlhbExvYWRlZDtcclxuICAgICAgICAgICAgdGhpcy5vbkNhbWVyYUxvYWRlZCA9IG9wdGlvbnMub25DYW1lcmFMb2FkZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uT3B0aW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9uT3B0aW9ucyA/PyB0aGlzLmV4dGVuc2lvbk9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21tb24gb3B0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJhaXNlZCB3aGVuIHRoZSBhc3NldCBoYXMgYmVlbiBwYXJzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IG9uUGFyc2VkPzogKChsb2FkZXJEYXRhOiBJR0xURkxvYWRlckRhdGEpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS1cclxuICAgIC8vIFYyIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb29yZGluYXRlIHN5c3RlbSBtb2RlLiBEZWZhdWx0cyB0byBBVVRPLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29vcmRpbmF0ZVN5c3RlbU1vZGUgPSBHTFRGTG9hZGVyQ29vcmRpbmF0ZVN5c3RlbU1vZGUuQVVUTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbmltYXRpb24gc3RhcnQgbW9kZS4gRGVmYXVsdHMgdG8gRklSU1QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhbmltYXRpb25TdGFydE1vZGUgPSBHTFRGTG9hZGVyQW5pbWF0aW9uU3RhcnRNb2RlLkZJUlNUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIHNob3VsZCBsb2FkIG5vZGUgYW5pbWF0aW9ucy4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqIE5PVEU6IFRoZSBhbmltYXRpb24gb2YgdGhpcyBub2RlIHdpbGwgc3RpbGwgbG9hZCBpZiB0aGUgbm9kZSBpcyBhbHNvIGEgam9pbnQgb2YgYSBza2luIGFuZCBgbG9hZFNraW5zYCBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZE5vZGVBbmltYXRpb25zID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgdGhlIGxvYWRlciBzaG91bGQgbG9hZCBza2lucy4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRTa2lucyA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBsb2FkZXIgc2hvdWxkIGxvYWQgbW9ycGggdGFyZ2V0cy4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRNb3JwaFRhcmdldHMgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIHNob3VsZCBjb21waWxlIG1hdGVyaWFscyBiZWZvcmUgcmFpc2luZyB0aGUgc3VjY2VzcyBjYWxsYmFjay4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb21waWxlTWF0ZXJpYWxzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBsb2FkZXIgc2hvdWxkIGFsc28gY29tcGlsZSBtYXRlcmlhbHMgd2l0aCBjbGlwIHBsYW5lcy4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VDbGlwUGxhbmUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgdGhlIGxvYWRlciBzaG91bGQgY29tcGlsZSBzaGFkb3cgZ2VuZXJhdG9ycyBiZWZvcmUgcmFpc2luZyB0aGUgc3VjY2VzcyBjYWxsYmFjay4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb21waWxlU2hhZG93R2VuZXJhdG9ycyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgQWxwaGEgYmxlbmRlZCBtYXRlcmlhbHMgYXJlIG9ubHkgYXBwbGllZCBhcyBjb3ZlcmFnZS5cclxuICAgICAqIElmIGZhbHNlLCAoZGVmYXVsdCkgVGhlIGx1bWluYW5jZSBvZiBlYWNoIHBpeGVsIHdpbGwgcmVkdWNlIGl0cyBvcGFjaXR5IHRvIHNpbXVsYXRlIHRoZSBiZWhhdmlvdXIgb2YgbW9zdCBwaHlzaWNhbCBtYXRlcmlhbHMuXHJcbiAgICAgKiBJZiB0cnVlLCBubyBleHRyYSBlZmZlY3RzIGFyZSBhcHBsaWVkIHRvIHRyYW5zcGFyZW50IHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zcGFyZW5jeUFzQ292ZXJhZ2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgdGhlIGxvYWRlciBzaG91bGQgdXNlIHJhbmdlIHJlcXVlc3RzIHdoZW4gbG9hZCBiaW5hcnkgZ2xURiBmaWxlcyBmcm9tIEhUVFAuXHJcbiAgICAgKiBFbmFibGluZyB3aWxsIGRpc2FibGUgb2ZmbGluZSBzdXBwb3J0IGFuZCBnbFRGIHZhbGlkYXRvci5cclxuICAgICAqIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXNlUmFuZ2VSZXF1ZXN0cyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIHNob3VsZCBjcmVhdGUgaW5zdGFuY2VzIHdoZW4gbXVsdGlwbGUgZ2xURiBub2RlcyBwb2ludCB0byB0aGUgc2FtZSBnbFRGIG1lc2guIERlZmF1bHRzIHRvIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVJbnN0YW5jZXMgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIHNob3VsZCBhbHdheXMgY29tcHV0ZSB0aGUgYm91bmRpbmcgYm94ZXMgb2YgbWVzaGVzIGFuZCBub3QgdXNlIHRoZSBtaW4vbWF4IHZhbHVlcyBmcm9tIHRoZSBwb3NpdGlvbiBhY2Nlc3Nvci4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhbHdheXNDb21wdXRlQm91bmRpbmdCb3ggPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUsIGxvYWQgYWxsIG1hdGVyaWFscyBkZWZpbmVkIGluIHRoZSBmaWxlLCBldmVuIGlmIG5vdCB1c2VkIGJ5IGFueSBtZXNoLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRBbGxNYXRlcmlhbHMgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUsIGxvYWQgb25seSB0aGUgbWF0ZXJpYWxzIGRlZmluZWQgaW4gdGhlIGZpbGUuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZE9ubHlNYXRlcmlhbHMgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUsIGRvIG5vdCBsb2FkIGFueSBtYXRlcmlhbHMgZGVmaW5lZCBpbiB0aGUgZmlsZS4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBza2lwTWF0ZXJpYWxzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlLCBsb2FkIHRoZSBjb2xvciAoZ2FtbWEgZW5jb2RlZCkgdGV4dHVyZXMgaW50byBzUkdCIGJ1ZmZlcnMgKGlmIHN1cHBvcnRlZCBieSB0aGUgR1BVKSwgd2hpY2ggd2lsbCB5aWVsZCBtb3JlIGFjY3VyYXRlIHJlc3VsdHMgd2hlbiBzYW1wbGluZyB0aGUgdGV4dHVyZS4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVNSR0JCdWZmZXJzID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gbG9hZGluZyBnbFRGIGFuaW1hdGlvbnMsIHdoaWNoIGFyZSBkZWZpbmVkIGluIHNlY29uZHMsIHRhcmdldCB0aGVtIHRvIHRoaXMgRlBTLiBEZWZhdWx0cyB0byA2MC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhcmdldEZwcyA9IDYwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIHNob3VsZCBhbHdheXMgY29tcHV0ZSB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3Igb2YgdGhlIHNrZWxldG9uIGpvaW50cyBpbnN0ZWFkIG9mIHVzaW5nIGBza2luLnNrZWxldG9uYC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIGxvYWRpbmcgYXNzZXRzIHdpdGggaW52YWxpZCBgc2tpbi5za2VsZXRvbmAgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWx3YXlzQ29tcHV0ZVNrZWxldG9uUm9vdE5vZGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUsIHRoZSBsb2FkZXIgd2lsbCBkZXJpdmUgdGhlIG5hbWUgZm9yIEJhYnlsb24gdGV4dHVyZXMgZnJvbSB0aGUgZ2xURiB0ZXh0dXJlIG5hbWUsIGltYWdlIG5hbWUsIG9yIGltYWdlIHVybC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgZm9yIG11bHRpcGxlIEJhYnlsb24gdGV4dHVyZXMgdG8gc2hhcmUgdGhlIHNhbWUgbmFtZSB3aGVuIHRoZSBCYWJ5bG9uIHRleHR1cmVzIGxvYWQgZnJvbSB0aGUgc2FtZSBnbFRGIHRleHR1cmUgb3IgaW1hZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VHbHRmVGV4dHVyZU5hbWVzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgYSB1cmwgcmVmZXJlbmNlZCBieSB0aGUgYXNzZXQuXHJcbiAgICAgKiBAcGFyYW0gdXJsIHVybCByZWZlcmVuY2VkIGJ5IHRoZSBhc3NldFxyXG4gICAgICogQHJldHVybnMgQXN5bmMgdXJsIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHByZXByb2Nlc3NVcmxBc3luYyA9ICh1cmw6IHN0cmluZykgPT4gUHJvbWlzZS5yZXNvbHZlKHVybCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGUgcm9vdCBvZiB0aGUgaGllcmFyY2h5IHdoZW4gbG9hZGluZyB0aGUgc2NlbmUgKGRlZmF1bHQ6IHVuZGVmaW5lZCkuIElmIG5vdCBkZWZpbmVkLCBhIHJvb3Qgbm9kZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZC5cclxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIG51bGwgaWYgeW91IGRvbid0IHdhbnQgYSByb290IG5vZGUgdG8gYmUgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGN1c3RvbVJvb3ROb2RlPzogTnVsbGFibGU8VHJhbnNmb3JtTm9kZT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayByYWlzZWQgd2hlbiB0aGUgbG9hZGVyIGNyZWF0ZXMgYSBtZXNoIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgbWVzaC5cclxuICAgICAqIE5vdGUgdGhhdCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIGFzIHNvb24gYXMgdGhlIG1lc2ggb2JqZWN0IGlzIGNyZWF0ZWQsIG1lYW5pbmcgc29tZSBkYXRhIG1heSBub3QgaGF2ZSBiZWVuIHNldHVwIHlldCBmb3IgdGhpcyBtZXNoICh2ZXJ0ZXggZGF0YSwgbW9ycGggdGFyZ2V0cywgbWF0ZXJpYWwsIC4uLilcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IG9uTWVzaExvYWRlZD86ICgobWVzaDogQWJzdHJhY3RNZXNoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIHNraW4gYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzIG9mIHRoZSBza2luIG5vZGUuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9pbXBvcnRlcnMvZ2xURi9nbFRGU2tpbm5pbmcjaWdub3JpbmctdGhlLXRyYW5zZm9ybS1vZi10aGUtc2tpbm5lZC1tZXNoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBvblNraW5Mb2FkZWQ/OiAoKG5vZGU6IFRyYW5zZm9ybU5vZGUsIHNraW5uZWROb2RlOiBUcmFuc2Zvcm1Ob2RlKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIHRleHR1cmUgYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25UZXh0dXJlTG9hZGVkPzogKCh0ZXh0dXJlOiBCYXNlVGV4dHVyZSkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayByYWlzZWQgd2hlbiB0aGUgbG9hZGVyIGNyZWF0ZXMgYSBtYXRlcmlhbCBhZnRlciBwYXJzaW5nIHRoZSBnbFRGIHByb3BlcnRpZXMgb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25NYXRlcmlhbExvYWRlZD86ICgobWF0ZXJpYWw6IE1hdGVyaWFsKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIGNhbWVyYSBhZnRlciBwYXJzaW5nIHRoZSBnbFRGIHByb3BlcnRpZXMgb2YgdGhlIGNhbWVyYS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IG9uQ2FtZXJhTG9hZGVkPzogKChjYW1lcmE6IENhbWVyYSkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIG9wdGlvbnMgZm9yIGdsVEYgZXh0ZW5zaW9ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4dGVuc2lvbk9wdGlvbnM6IHtcclxuICAgICAgICAvLyBOT1RFOiBUaGlzIHR5cGUgaXMgZG9pbmcgdHdvIHRoaW5nczpcclxuICAgICAgICAvLyAxLiBBZGRpbmcgYW4gaW1wbGljaXQgJ2VuYWJsZWQnIHByb3BlcnR5IHRvIHRoZSBvcHRpb25zIGZvciBlYWNoIGV4dGVuc2lvbi5cclxuICAgICAgICAvLyAyLiBDcmVhdGluZyBhIG1hcHBlZCB0eXBlIG9mIGFsbCB0aGUgb3B0aW9ucyBvZiBhbGwgdGhlIGV4dGVuc2lvbnMgdG8gbWFrZSBpdCBqdXN0IGxvb2sgbGlrZSBhIGNvbnNvbGlkYXRlZCBwbGFpbiBvYmplY3QgaW4gaW50ZWxsaXNlbnNlIGZvciB0aGUgdXNlci5cclxuICAgICAgICBbRXh0ZW5zaW9uIGluIGtleW9mIEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zXT86IHtcclxuICAgICAgICAgICAgW09wdGlvbiBpbiBrZXlvZiBEZWZhdWx0RXh0ZW5zaW9uT3B0aW9uczxHTFRGTG9hZGVyRXh0ZW5zaW9uT3B0aW9uc1tFeHRlbnNpb25dPl06IERlZmF1bHRFeHRlbnNpb25PcHRpb25zPEdMVEZMb2FkZXJFeHRlbnNpb25PcHRpb25zW0V4dGVuc2lvbl0+W09wdGlvbl07XHJcbiAgICAgICAgfTtcclxuICAgIH0gPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbGUgbG9hZGVyIGZvciBsb2FkaW5nIGdsVEYgZmlsZXMgaW50byBhIHNjZW5lLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdMVEZGaWxlTG9hZGVyIGV4dGVuZHMgR0xURkxvYWRlck9wdGlvbnMgaW1wbGVtZW50cyBJRGlzcG9zYWJsZSwgSVNjZW5lTG9hZGVyUGx1Z2luQXN5bmMsIElTY2VuZUxvYWRlclBsdWdpbkZhY3Rvcnkge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBfQ3JlYXRlR0xURjFMb2FkZXI6IChwYXJlbnQ6IEdMVEZGaWxlTG9hZGVyKSA9PiBJR0xURkxvYWRlcjtcclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgc3RhdGljIF9DcmVhdGVHTFRGMkxvYWRlcjogKHBhcmVudDogR0xURkZpbGVMb2FkZXIpID0+IElHTFRGTG9hZGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBnbFRGIGZpbGUgbG9hZGVyLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBQYXJ0aWFsPFJlYWRvbmx5PEdMVEZMb2FkZXJPcHRpb25zPj4pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29weUZyb20ob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEJlZ2luIENvbW1vbiBvcHRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmFpc2VkIHdoZW4gdGhlIGFzc2V0IGhhcyBiZWVuIHBhcnNlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25QYXJzZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8SUdMVEZMb2FkZXJEYXRhPigpO1xyXG5cclxuICAgIHByaXZhdGUgX29uUGFyc2VkT2JzZXJ2ZXI6IE51bGxhYmxlPE9ic2VydmVyPElHTFRGTG9hZGVyRGF0YT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmFpc2VkIHdoZW4gdGhlIGFzc2V0IGhhcyBiZWVuIHBhcnNlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG9uUGFyc2VkKGNhbGxiYWNrOiAoKGxvYWRlckRhdGE6IElHTFRGTG9hZGVyRGF0YSkgPT4gdm9pZCkgfCB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25QYXJzZWRPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLm9uUGFyc2VkT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25QYXJzZWRPYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9vblBhcnNlZE9ic2VydmVyID0gdGhpcy5vblBhcnNlZE9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBFbmQgQ29tbW9uIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEJlZ2luIFYxIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIHRvIGRpc2FibGUgaW5jcmVtZW50YWwgbG9hZGluZyB3aGljaCBkZWxheXMgdGhlIGxvYWRlciBmcm9tIGNhbGxpbmcgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgdW50aWwgYWZ0ZXIgbG9hZGluZyB0aGUgbWVzaGVzIGFuZCBzaGFkZXJzLlxyXG4gICAgICogVGV4dHVyZXMgYWx3YXlzIGxvYWRzIGFzeW5jaHJvbm91c2x5LiBGb3IgZXhhbXBsZSwgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgY2FuIGNvbXB1dGUgdGhlIGJvdW5kaW5nIGluZm9ybWF0aW9uIG9mIHRoZSBsb2FkZWQgbWVzaGVzIHdoZW4gaW5jcmVtZW50YWwgbG9hZGluZyBpcyBkaXNhYmxlZC5cclxuICAgICAqIERlZmF1bHRzIHRvIHRydWUuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJbmNyZW1lbnRhbExvYWRpbmcgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoaXMgcHJvcGVydHkgdG8gdHJ1ZSBpbiBvcmRlciB0byB3b3JrIHdpdGggaG9tb2dlbmVvdXMgY29vcmRpbmF0ZXMsIGF2YWlsYWJsZSB3aXRoIHNvbWUgY29udmVydGVycyBhbmQgZXhwb3J0ZXJzLlxyXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UuIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib21vZ2VuZW91c19jb29yZGluYXRlcy5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEhvbW9nZW5lb3VzQ29vcmRpbmF0ZXMgPSBmYWxzZTtcclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gRW5kIFYxIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIG1lc2ggYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzIG9mIHRoZSBtZXNoLlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBvYnNlcnZhYmxlIGlzIHJhaXNlZCBhcyBzb29uIGFzIHRoZSBtZXNoIG9iamVjdCBpcyBjcmVhdGVkLCBtZWFuaW5nIHNvbWUgZGF0YSBtYXkgbm90IGhhdmUgYmVlbiBzZXR1cCB5ZXQgZm9yIHRoaXMgbWVzaCAodmVydGV4IGRhdGEsIG1vcnBoIHRhcmdldHMsIG1hdGVyaWFsLCAuLi4pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBvbk1lc2hMb2FkZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8QWJzdHJhY3RNZXNoPigpO1xyXG5cclxuICAgIHByaXZhdGUgX29uTWVzaExvYWRlZE9ic2VydmVyOiBOdWxsYWJsZTxPYnNlcnZlcjxBYnN0cmFjdE1lc2g+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIG1lc2ggYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzIG9mIHRoZSBtZXNoLlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXMgc29vbiBhcyB0aGUgbWVzaCBvYmplY3QgaXMgY3JlYXRlZCwgbWVhbmluZyBzb21lIGRhdGEgbWF5IG5vdCBoYXZlIGJlZW4gc2V0dXAgeWV0IGZvciB0aGlzIG1lc2ggKHZlcnRleCBkYXRhLCBtb3JwaCB0YXJnZXRzLCBtYXRlcmlhbCwgLi4uKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG9uTWVzaExvYWRlZChjYWxsYmFjazogKChtZXNoOiBBYnN0cmFjdE1lc2gpID0+IHZvaWQpIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uTWVzaExvYWRlZE9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25NZXNoTG9hZGVkT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25NZXNoTG9hZGVkT2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fb25NZXNoTG9hZGVkT2JzZXJ2ZXIgPSB0aGlzLm9uTWVzaExvYWRlZE9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIHNraW4gYWZ0ZXIgcGFyc2luZyB0aGUgZ2xURiBwcm9wZXJ0aWVzIG9mIHRoZSBza2luIG5vZGUuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9pbXBvcnRlcnMvZ2xURi9nbFRGU2tpbm5pbmcjaWdub3JpbmctdGhlLXRyYW5zZm9ybS1vZi10aGUtc2tpbm5lZC1tZXNoXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIHRoZSB0cmFuc2Zvcm0gbm9kZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5hbCBnbFRGIHNraW4gbm9kZSB1c2VkIGZvciBhbmltYXRpb25zXHJcbiAgICAgKiBAcGFyYW0gc2tpbm5lZE5vZGUgLSB0aGUgdHJhbnNmb3JtIG5vZGUgdGhhdCBpcyB0aGUgc2tpbm5lZCBtZXNoIGl0c2VsZiBvciB0aGUgcGFyZW50IG9mIHRoZSBza2lubmVkIG1lc2hlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgb25Ta2luTG9hZGVkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPHsgbm9kZTogVHJhbnNmb3JtTm9kZTsgc2tpbm5lZE5vZGU6IFRyYW5zZm9ybU5vZGUgfT4oKTtcclxuXHJcbiAgICBwcml2YXRlIF9vblNraW5Mb2FkZWRPYnNlcnZlcjogTnVsbGFibGU8T2JzZXJ2ZXI8eyBub2RlOiBUcmFuc2Zvcm1Ob2RlOyBza2lubmVkTm9kZTogVHJhbnNmb3JtTm9kZSB9Pj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayByYWlzZWQgd2hlbiB0aGUgbG9hZGVyIGNyZWF0ZXMgYSBza2luIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgc2tpbiBub2RlLlxyXG4gICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvaW1wb3J0ZXJzL2dsVEYvZ2xURlNraW5uaW5nI2lnbm9yaW5nLXRoZS10cmFuc2Zvcm0tb2YtdGhlLXNraW5uZWQtbWVzaFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG9uU2tpbkxvYWRlZChjYWxsYmFjazogKChub2RlOiBUcmFuc2Zvcm1Ob2RlLCBza2lubmVkTm9kZTogVHJhbnNmb3JtTm9kZSkgPT4gdm9pZCkgfCB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25Ta2luTG9hZGVkT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vblNraW5Mb2FkZWRPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vblNraW5Mb2FkZWRPYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9vblNraW5Mb2FkZWRPYnNlcnZlciA9IHRoaXMub25Ta2luTG9hZGVkT2JzZXJ2YWJsZS5hZGQoKGRhdGEpID0+IGNhbGxiYWNrKGRhdGEubm9kZSwgZGF0YS5za2lubmVkTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmFibGUgcmFpc2VkIHdoZW4gdGhlIGxvYWRlciBjcmVhdGVzIGEgdGV4dHVyZSBhZnRlciBwYXJzaW5nIHRoZSBnbFRGIHByb3BlcnRpZXMgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBvblRleHR1cmVMb2FkZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8QmFzZVRleHR1cmU+KCk7XHJcblxyXG4gICAgcHJpdmF0ZSBfb25UZXh0dXJlTG9hZGVkT2JzZXJ2ZXI6IE51bGxhYmxlPE9ic2VydmVyPEJhc2VUZXh0dXJlPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayByYWlzZWQgd2hlbiB0aGUgbG9hZGVyIGNyZWF0ZXMgYSB0ZXh0dXJlIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBvblRleHR1cmVMb2FkZWQoY2FsbGJhY2s6ICgodGV4dHVyZTogQmFzZVRleHR1cmUpID0+IHZvaWQpIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uVGV4dHVyZUxvYWRlZE9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25UZXh0dXJlTG9hZGVkT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25UZXh0dXJlTG9hZGVkT2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fb25UZXh0dXJlTG9hZGVkT2JzZXJ2ZXIgPSB0aGlzLm9uVGV4dHVyZUxvYWRlZE9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIG1hdGVyaWFsIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBvbk1hdGVyaWFsTG9hZGVkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPE1hdGVyaWFsPigpO1xyXG5cclxuICAgIHByaXZhdGUgX29uTWF0ZXJpYWxMb2FkZWRPYnNlcnZlcjogTnVsbGFibGU8T2JzZXJ2ZXI8TWF0ZXJpYWw+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCB3aGVuIHRoZSBsb2FkZXIgY3JlYXRlcyBhIG1hdGVyaWFsIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgb25NYXRlcmlhbExvYWRlZChjYWxsYmFjazogKChtYXRlcmlhbDogTWF0ZXJpYWwpID0+IHZvaWQpIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uTWF0ZXJpYWxMb2FkZWRPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLm9uTWF0ZXJpYWxMb2FkZWRPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbk1hdGVyaWFsTG9hZGVkT2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fb25NYXRlcmlhbExvYWRlZE9ic2VydmVyID0gdGhpcy5vbk1hdGVyaWFsTG9hZGVkT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmFibGUgcmFpc2VkIHdoZW4gdGhlIGxvYWRlciBjcmVhdGVzIGEgY2FtZXJhIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgY2FtZXJhLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgb25DYW1lcmFMb2FkZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8Q2FtZXJhPigpO1xyXG5cclxuICAgIHByaXZhdGUgX29uQ2FtZXJhTG9hZGVkT2JzZXJ2ZXI6IE51bGxhYmxlPE9ic2VydmVyPENhbWVyYT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgcmFpc2VkIHdoZW4gdGhlIGxvYWRlciBjcmVhdGVzIGEgY2FtZXJhIGFmdGVyIHBhcnNpbmcgdGhlIGdsVEYgcHJvcGVydGllcyBvZiB0aGUgY2FtZXJhLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG9uQ2FtZXJhTG9hZGVkKGNhbGxiYWNrOiAoKGNhbWVyYTogQ2FtZXJhKSA9PiB2b2lkKSB8IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vbkNhbWVyYUxvYWRlZE9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DYW1lcmFMb2FkZWRPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkNhbWVyYUxvYWRlZE9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQ2FtZXJhTG9hZGVkT2JzZXJ2ZXIgPSB0aGlzLm9uQ2FtZXJhTG9hZGVkT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmFibGUgcmFpc2VkIHdoZW4gdGhlIGFzc2V0IGlzIGNvbXBsZXRlbHkgbG9hZGVkLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGxvYWRlciBpcyBkaXNwb3NlZC5cclxuICAgICAqIEZvciBhc3NldHMgd2l0aCBMT0RzLCByYWlzZWQgd2hlbiBhbGwgb2YgdGhlIExPRHMgYXJlIGNvbXBsZXRlLlxyXG4gICAgICogRm9yIGFzc2V0cyB3aXRob3V0IExPRHMsIHJhaXNlZCB3aGVuIHRoZSBtb2RlbCBpcyBjb21wbGV0ZSwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxvYWRlciByZXNvbHZlcyB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG9uQ29tcGxldGVPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8dm9pZD4oKTtcclxuXHJcbiAgICBwcml2YXRlIF9vbkNvbXBsZXRlT2JzZXJ2ZXI6IE51bGxhYmxlPE9ic2VydmVyPHZvaWQ+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCB3aGVuIHRoZSBhc3NldCBpcyBjb21wbGV0ZWx5IGxvYWRlZCwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBsb2FkZXIgaXMgZGlzcG9zZWQuXHJcbiAgICAgKiBGb3IgYXNzZXRzIHdpdGggTE9EcywgcmFpc2VkIHdoZW4gYWxsIG9mIHRoZSBMT0RzIGFyZSBjb21wbGV0ZS5cclxuICAgICAqIEZvciBhc3NldHMgd2l0aG91dCBMT0RzLCByYWlzZWQgd2hlbiB0aGUgbW9kZWwgaXMgY29tcGxldGUsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBsb2FkZXIgcmVzb2x2ZXMgdGhlIHJldHVybmVkIHByb21pc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgb25Db21wbGV0ZShjYWxsYmFjazogKCkgPT4gdm9pZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vbkNvbXBsZXRlT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25Db21wbGV0ZU9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb25Db21wbGV0ZU9ic2VydmVyID0gdGhpcy5vbkNvbXBsZXRlT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2YWJsZSByYWlzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBvbkVycm9yT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPGFueT4oKTtcclxuXHJcbiAgICBwcml2YXRlIF9vbkVycm9yT2JzZXJ2ZXI6IE51bGxhYmxlPE9ic2VydmVyPGFueT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgcmFpc2VkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG9uRXJyb3IoY2FsbGJhY2s6IChyZWFzb246IGFueSkgPT4gdm9pZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vbkVycm9yT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkVycm9yT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25FcnJvck9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb25FcnJvck9ic2VydmVyID0gdGhpcy5vbkVycm9yT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2YWJsZSByYWlzZWQgYWZ0ZXIgdGhlIGxvYWRlciBpcyBkaXNwb3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG9uRGlzcG9zZU9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTx2b2lkPigpO1xyXG5cclxuICAgIHByaXZhdGUgX29uRGlzcG9zZU9ic2VydmVyOiBOdWxsYWJsZTxPYnNlcnZlcjx2b2lkPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayByYWlzZWQgYWZ0ZXIgdGhlIGxvYWRlciBpcyBkaXNwb3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBvbkRpc3Bvc2UoY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25EaXNwb3NlT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRpc3Bvc2VPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkRpc3Bvc2VPYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29uRGlzcG9zZU9ic2VydmVyID0gdGhpcy5vbkRpc3Bvc2VPYnNlcnZhYmxlLmFkZChjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCBhZnRlciBhIGxvYWRlciBleHRlbnNpb24gaXMgY3JlYXRlZC5cclxuICAgICAqIFNldCBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGEgbG9hZGVyIGV4dGVuc2lvbiBpbiB0aGlzIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgb25FeHRlbnNpb25Mb2FkZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8SUdMVEZMb2FkZXJFeHRlbnNpb24+KCk7XHJcblxyXG4gICAgcHJpdmF0ZSBfb25FeHRlbnNpb25Mb2FkZWRPYnNlcnZlcjogTnVsbGFibGU8T2JzZXJ2ZXI8SUdMVEZMb2FkZXJFeHRlbnNpb24+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCBhZnRlciBhIGxvYWRlciBleHRlbnNpb24gaXMgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBvbkV4dGVuc2lvbkxvYWRlZChjYWxsYmFjazogKGV4dGVuc2lvbjogSUdMVEZMb2FkZXJFeHRlbnNpb24pID0+IHZvaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25FeHRlbnNpb25Mb2FkZWRPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLm9uRXh0ZW5zaW9uTG9hZGVkT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25FeHRlbnNpb25Mb2FkZWRPYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29uRXh0ZW5zaW9uTG9hZGVkT2JzZXJ2ZXIgPSB0aGlzLm9uRXh0ZW5zaW9uTG9hZGVkT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIGxvZ2dpbmcgaXMgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBsb2dnaW5nRW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2luZ0VuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBsb2dnaW5nRW5hYmxlZCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2dnaW5nRW5hYmxlZCA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fbG9nZ2luZ0VuYWJsZWQgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xvZ2dpbmdFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyA9IHRoaXMuX2xvZ0VuYWJsZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nID0gdGhpcy5fbG9nRGlzYWJsZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZiB0aGUgbG9hZGVyIHNob3VsZCBjYXB0dXJlIHBlcmZvcm1hbmNlIGNvdW50ZXJzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNhcHR1cmVQZXJmb3JtYW5jZUNvdW50ZXJzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYXB0dXJlUGVyZm9ybWFuY2VDb3VudGVycztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGNhcHR1cmVQZXJmb3JtYW5jZUNvdW50ZXJzKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhcHR1cmVQZXJmb3JtYW5jZUNvdW50ZXJzID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9jYXB0dXJlUGVyZm9ybWFuY2VDb3VudGVycyA9IHZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY2FwdHVyZVBlcmZvcm1hbmNlQ291bnRlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQZXJmb3JtYW5jZUNvdW50ZXIgPSB0aGlzLl9zdGFydFBlcmZvcm1hbmNlQ291bnRlckVuYWJsZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBlcmZvcm1hbmNlQ291bnRlciA9IHRoaXMuX2VuZFBlcmZvcm1hbmNlQ291bnRlckVuYWJsZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQZXJmb3JtYW5jZUNvdW50ZXIgPSB0aGlzLl9zdGFydFBlcmZvcm1hbmNlQ291bnRlckRpc2FibGVkO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRQZXJmb3JtYW5jZUNvdW50ZXIgPSB0aGlzLl9lbmRQZXJmb3JtYW5jZUNvdW50ZXJEaXNhYmxlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBsb2FkZXIgc2hvdWxkIHZhbGlkYXRlIHRoZSBhc3NldC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHZhbGlkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIHJhaXNlZCBhZnRlciB2YWxpZGF0aW9uIHdoZW4gdmFsaWRhdGUgaXMgc2V0IHRvIHRydWUuIFRoZSBldmVudCBkYXRhIGlzIHRoZSByZXN1bHQgb2YgdGhlIHZhbGlkYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBvblZhbGlkYXRlZE9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxHTFRGMi5JR0xURlZhbGlkYXRpb25SZXN1bHRzPigpO1xyXG5cclxuICAgIHByaXZhdGUgX29uVmFsaWRhdGVkT2JzZXJ2ZXI6IE51bGxhYmxlPE9ic2VydmVyPEdMVEYyLklHTFRGVmFsaWRhdGlvblJlc3VsdHM+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHJhaXNlZCBhZnRlciBhIGxvYWRlciBleHRlbnNpb24gaXMgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBvblZhbGlkYXRlZChjYWxsYmFjazogKHJlc3VsdHM6IEdMVEYyLklHTFRGVmFsaWRhdGlvblJlc3VsdHMpID0+IHZvaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25WYWxpZGF0ZWRPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGVkT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25WYWxpZGF0ZWRPYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29uVmFsaWRhdGVkT2JzZXJ2ZXIgPSB0aGlzLm9uVmFsaWRhdGVkT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlcjogTnVsbGFibGU8SUdMVEZMb2FkZXI+ID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3N0YXRlOiBOdWxsYWJsZTxHTFRGTG9hZGVyU3RhdGU+ID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3Byb2dyZXNzQ2FsbGJhY2s/OiAoZXZlbnQ6IElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQpID0+IHZvaWQ7XHJcbiAgICBwcml2YXRlIF9yZXF1ZXN0cyA9IG5ldyBBcnJheTxJRmlsZVJlcXVlc3RJbmZvPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmFtZSBvZiB0aGUgbG9hZGVyIChcImdsdGZcIilcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWUgPSBHTFRGRmlsZUxvYWRlck1ldGFkYXRhLm5hbWU7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGV4dGVuc2lvbnMgPSBHTFRGRmlsZUxvYWRlck1ldGFkYXRhLmV4dGVuc2lvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyB0aGUgbG9hZGVyLCByZWxlYXNlcyByZXNvdXJjZXMgZHVyaW5nIGxvYWQsIGFuZCBjYW5jZWxzIGFueSBvdXRzdGFuZGluZyByZXF1ZXN0cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHRoaXMuX3JlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrO1xyXG5cclxuICAgICAgICB0aGlzLnByZXByb2Nlc3NVcmxBc3luYyA9ICh1cmwpID0+IFByb21pc2UucmVzb2x2ZSh1cmwpO1xyXG5cclxuICAgICAgICB0aGlzLm9uTWVzaExvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm9uU2tpbkxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm9uVGV4dHVyZUxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm9uTWF0ZXJpYWxMb2FkZWRPYnNlcnZhYmxlLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5vbkNhbWVyYUxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm9uQ29tcGxldGVPYnNlcnZhYmxlLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5vbkV4dGVuc2lvbkxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5vbkRpc3Bvc2VPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMub25EaXNwb3NlT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb2FkRmlsZShcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgZmlsZU9yVXJsOiBGaWxlIHwgc3RyaW5nIHwgQXJyYXlCdWZmZXJWaWV3LFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBvblN1Y2Nlc3M6IChkYXRhOiB1bmtub3duLCByZXNwb25zZVVSTD86IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBvblByb2dyZXNzPzogKGV2OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLFxyXG4gICAgICAgIHVzZUFycmF5QnVmZmVyPzogYm9vbGVhbixcclxuICAgICAgICBvbkVycm9yPzogKHJlcXVlc3Q/OiBXZWJSZXF1ZXN0LCBleGNlcHRpb24/OiBMb2FkRmlsZUVycm9yKSA9PiB2b2lkLFxyXG4gICAgICAgIG5hbWU/OiBzdHJpbmdcclxuICAgICk6IE51bGxhYmxlPElGaWxlUmVxdWVzdD4ge1xyXG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZmlsZU9yVXJsKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkQmluYXJ5KHNjZW5lLCBmaWxlT3JVcmwsIHJvb3RVcmwsIG9uU3VjY2Vzcywgb25FcnJvciwgbmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFjayA9IG9uUHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gKGZpbGVPclVybCBhcyBGaWxlKS5uYW1lIHx8IFRvb2xzLkdldEZpbGVuYW1lKGZpbGVPclVybCBhcyBzdHJpbmcpO1xyXG5cclxuICAgICAgICBpZiAodXNlQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXNlUmFuZ2VSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihcImdsVEYgdmFsaWRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gcmFuZ2UgcmVxdWVzdHMgYXJlIGVuYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVJlcXVlc3Q6IElGaWxlUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogKCkgPT4ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZU9ic2VydmFibGU6IG5ldyBPYnNlcnZhYmxlPElGaWxlUmVxdWVzdD4oKSxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJ1ZmZlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkQXN5bmM6IChieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8QXJyYXlCdWZmZXJWaWV3PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRmlsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlT3JVcmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShkYXRhIGFzIEFycmF5QnVmZmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdlYlJlcXVlc3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViUmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7Ynl0ZU9mZnNldH0tJHtieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCAtIDF9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiAwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91bnBhY2tCaW5hcnlBc3luYyhuZXcgRGF0YVJlYWRlcihkYXRhQnVmZmVyKSkudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAobG9hZGVyRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUmVxdWVzdC5vbkNvbXBsZXRlT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoZmlsZVJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MobG9hZGVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yID8gKGVycm9yKSA9PiBvbkVycm9yKHVuZGVmaW5lZCwgZXJyb3IpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUmVxdWVzdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRGaWxlKFxyXG4gICAgICAgICAgICAgICAgc2NlbmUsXHJcbiAgICAgICAgICAgICAgICBmaWxlT3JVcmwsXHJcbiAgICAgICAgICAgICAgICAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKHNjZW5lLCBuZXcgVWludDhBcnJheShkYXRhIGFzIEFycmF5QnVmZmVyLCAwLCAoZGF0YSBhcyBBcnJheUJ1ZmZlcikuYnl0ZUxlbmd0aCksIHJvb3RVcmwsIGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnBhY2tCaW5hcnlBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGFSZWFkZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFzeW5jOiAoYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkgPT4gcmVhZEFzeW5jKGRhdGEgYXMgQXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogKGRhdGEgYXMgQXJyYXlCdWZmZXIpLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9hZGVyRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzKGxvYWRlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yID8gKGVycm9yKSA9PiBvbkVycm9yKHVuZGVmaW5lZCwgZXJyb3IpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkRmlsZShcclxuICAgICAgICAgICAgICAgIHNjZW5lLFxyXG4gICAgICAgICAgICAgICAgZmlsZU9yVXJsLFxyXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShzY2VuZSwgZGF0YSBhcyBzdHJpbmcsIHJvb3RVcmwsIGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzKHsganNvbjogdGhpcy5fcGFyc2VKc29uKGRhdGEgYXMgc3RyaW5nKSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9hZEJpbmFyeShcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgZGF0YTogQXJyYXlCdWZmZXJWaWV3LFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBvblN1Y2Nlc3M6IChkYXRhOiB1bmtub3duLCByZXNwb25zZVVSTD86IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBvbkVycm9yPzogKHJlcXVlc3Q/OiBXZWJSZXF1ZXN0LCBleGNlcHRpb24/OiBMb2FkRmlsZUVycm9yKSA9PiB2b2lkLFxyXG4gICAgICAgIGZpbGVOYW1lPzogc3RyaW5nXHJcbiAgICApOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl92YWxpZGF0ZShzY2VuZSwgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKSwgcm9vdFVybCwgZmlsZU5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3VucGFja0JpbmFyeUFzeW5jKFxyXG4gICAgICAgICAgICBuZXcgRGF0YVJlYWRlcih7XHJcbiAgICAgICAgICAgICAgICByZWFkQXN5bmM6IChieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSA9PiByZWFkVmlld0FzeW5jKGRhdGEsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogZGF0YS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICkudGhlbihcclxuICAgICAgICAgICAgKGxvYWRlckRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzcyhsb2FkZXJEYXRhKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FcnJvciA/IChlcnJvcikgPT4gb25FcnJvcih1bmRlZmluZWQsIGVycm9yKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGltcG9ydE1lc2hBc3luYyhcclxuICAgICAgICBtZXNoZXNOYW1lczogc3RyaW5nIHwgcmVhZG9ubHkgc3RyaW5nW10gfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgICAgIHNjZW5lOiBTY2VuZSxcclxuICAgICAgICBkYXRhOiBJR0xURkxvYWRlckRhdGEsXHJcbiAgICAgICAgcm9vdFVybDogc3RyaW5nLFxyXG4gICAgICAgIG9uUHJvZ3Jlc3M/OiAoZXZlbnQ6IElTY2VuZUxvYWRlclByb2dyZXNzRXZlbnQpID0+IHZvaWQsXHJcbiAgICAgICAgZmlsZU5hbWU/OiBzdHJpbmdcclxuICAgICk6IFByb21pc2U8SVNjZW5lTG9hZGVyQXN5bmNSZXN1bHQ+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub25QYXJzZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5vblBhcnNlZE9ic2VydmFibGUuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgTG9hZGluZyAke2ZpbGVOYW1lIHx8IFwiXCJ9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlciA9IHRoaXMuX2dldExvYWRlcihkYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlci5pbXBvcnRNZXNoQXN5bmMobWVzaGVzTmFtZXMsIHNjZW5lLCBudWxsLCBkYXRhLCByb290VXJsLCBvblByb2dyZXNzLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRBc3luYyhzY2VuZTogU2NlbmUsIGRhdGE6IElHTFRGTG9hZGVyRGF0YSwgcm9vdFVybDogc3RyaW5nLCBvblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLCBmaWxlTmFtZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vblBhcnNlZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLm9uUGFyc2VkT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbG9nKGBMb2FkaW5nICR7ZmlsZU5hbWUgfHwgXCJcIn1gKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyID0gdGhpcy5fZ2V0TG9hZGVyKGRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLmxvYWRBc3luYyhzY2VuZSwgZGF0YSwgcm9vdFVybCwgb25Qcm9ncmVzcywgZmlsZU5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb2FkQXNzZXRDb250YWluZXJBc3luYyhcclxuICAgICAgICBzY2VuZTogU2NlbmUsXHJcbiAgICAgICAgZGF0YTogSUdMVEZMb2FkZXJEYXRhLFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBvblByb2dyZXNzPzogKGV2ZW50OiBJU2NlbmVMb2FkZXJQcm9ncmVzc0V2ZW50KSA9PiB2b2lkLFxyXG4gICAgICAgIGZpbGVOYW1lPzogc3RyaW5nXHJcbiAgICApOiBQcm9taXNlPEFzc2V0Q29udGFpbmVyPiB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9uUGFyc2VkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMub25QYXJzZWRPYnNlcnZhYmxlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sb2coYExvYWRpbmcgJHtmaWxlTmFtZSB8fCBcIlwifWApO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIgPSB0aGlzLl9nZXRMb2FkZXIoZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBhc3NldCBjb250YWluZXIuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBBc3NldENvbnRhaW5lcihzY2VuZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgbWF0ZXJpYWxzL3RleHR1cmVzIHdoZW4gbG9hZGluZyB0byBhZGQgdG8gY29udGFpbmVyXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsczogQXJyYXk8TWF0ZXJpYWw+ID0gW107XHJcbiAgICAgICAgICAgIHRoaXMub25NYXRlcmlhbExvYWRlZE9ic2VydmFibGUuYWRkKChtYXRlcmlhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzLnB1c2gobWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgdGV4dHVyZXM6IEFycmF5PEJhc2VUZXh0dXJlPiA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9uVGV4dHVyZUxvYWRlZE9ic2VydmFibGUuYWRkKCh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY2FtZXJhczogQXJyYXk8Q2FtZXJhPiA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2FtZXJhTG9hZGVkT2JzZXJ2YWJsZS5hZGQoKGNhbWVyYSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhcy5wdXNoKGNhbWVyYSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbW9ycGhUYXJnZXRNYW5hZ2VyczogQXJyYXk8TW9ycGhUYXJnZXRNYW5hZ2VyPiA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9uTWVzaExvYWRlZE9ic2VydmFibGUuYWRkKChtZXNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzaC5tb3JwaFRhcmdldE1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3JwaFRhcmdldE1hbmFnZXJzLnB1c2gobWVzaC5tb3JwaFRhcmdldE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIuaW1wb3J0TWVzaEFzeW5jKG51bGwsIHNjZW5lLCBjb250YWluZXIsIGRhdGEsIHJvb3RVcmwsIG9uUHJvZ3Jlc3MsIGZpbGVOYW1lKS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNvbnRhaW5lci5nZW9tZXRyaWVzLCByZXN1bHQuZ2VvbWV0cmllcyk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjb250YWluZXIubWVzaGVzLCByZXN1bHQubWVzaGVzKTtcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNvbnRhaW5lci5wYXJ0aWNsZVN5c3RlbXMsIHJlc3VsdC5wYXJ0aWNsZVN5c3RlbXMpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY29udGFpbmVyLnNrZWxldG9ucywgcmVzdWx0LnNrZWxldG9ucyk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjb250YWluZXIuYW5pbWF0aW9uR3JvdXBzLCByZXN1bHQuYW5pbWF0aW9uR3JvdXBzKTtcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNvbnRhaW5lci5tYXRlcmlhbHMsIG1hdGVyaWFscyk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjb250YWluZXIudGV4dHVyZXMsIHRleHR1cmVzKTtcclxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNvbnRhaW5lci5saWdodHMsIHJlc3VsdC5saWdodHMpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY29udGFpbmVyLnRyYW5zZm9ybU5vZGVzLCByZXN1bHQudHJhbnNmb3JtTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY29udGFpbmVyLmNhbWVyYXMsIGNhbWVyYXMpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY29udGFpbmVyLm1vcnBoVGFyZ2V0TWFuYWdlcnMsIG1vcnBoVGFyZ2V0TWFuYWdlcnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbkRpcmVjdExvYWQoZGF0YTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIEdMVEZGaWxlTG9hZGVyTWV0YWRhdGEuY2FuRGlyZWN0TG9hZChkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlyZWN0TG9hZChzY2VuZTogU2NlbmUsIGRhdGE6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBkYXRhLnN0YXJ0c1dpdGgoXCJiYXNlNjQsXCIgKyBHTFRGTWFnaWNCYXNlNjRFbmNvZGVkKSB8fCAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGluY29ycmVjdCwgYnV0IHdpbGwgY29udGludWUgdG8gc3VwcG9ydCBmb3IgYmFja2NvbXBhdC5cclxuICAgICAgICAgICAgZGF0YS5zdGFydHNXaXRoKFwiO2Jhc2U2NCxcIiArIEdMVEZNYWdpY0Jhc2U2NEVuY29kZWQpIHx8XHJcbiAgICAgICAgICAgIGRhdGEuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIgKyBHTFRGTWFnaWNCYXNlNjRFbmNvZGVkKSB8fFxyXG4gICAgICAgICAgICBkYXRhLnN0YXJ0c1dpdGgoXCJtb2RlbC9nbHRmLWJpbmFyeTtiYXNlNjQsXCIgKyBHTFRGTWFnaWNCYXNlNjRFbmNvZGVkKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IERlY29kZUJhc2U2NFVybFRvQmluYXJ5KGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoc2NlbmUsIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCAwLCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tCaW5hcnlBc3luYyhcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRhUmVhZGVyKHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkQXN5bmM6IChieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSA9PiByZWFkQXN5bmMoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoc2NlbmUsIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBqc29uOiB0aGlzLl9wYXJzZUpzb24oZGF0YSkgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgdGhhdCBhbGxvd3MgY3VzdG9tIGhhbmRsaW5nIG9mIHRoZSByb290IHVybCBiYXNlZCBvbiB0aGUgcmVzcG9uc2UgdXJsLlxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgdGhlIG9yaWdpbmFsIHJvb3QgdXJsXHJcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VVUkwgdGhlIHJlc3BvbnNlIHVybCBpZiBhdmFpbGFibGVcclxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgcm9vdCB1cmxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJld3JpdGVSb290VVJMPyhyb290VXJsOiBzdHJpbmcsIHJlc3BvbnNlVVJMPzogc3RyaW5nKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVQbHVnaW4ob3B0aW9uczogU2NlbmVMb2FkZXJQbHVnaW5PcHRpb25zKTogSVNjZW5lTG9hZGVyUGx1Z2luQXN5bmMge1xyXG4gICAgICAgIHJldHVybiBuZXcgR0xURkZpbGVMb2FkZXIob3B0aW9uc1tHTFRGRmlsZUxvYWRlck1ldGFkYXRhLm5hbWVdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2FkZXIgc3RhdGUgb3IgbnVsbCBpZiB0aGUgbG9hZGVyIGlzIG5vdCBhY3RpdmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbG9hZGVyU3RhdGUoKTogTnVsbGFibGU8R0xURkxvYWRlclN0YXRlPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2YWJsZSByYWlzZWQgd2hlbiB0aGUgbG9hZGVyIHN0YXRlIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkxvYWRlclN0YXRlQ2hhbmdlZE9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxOdWxsYWJsZTxHTFRGTG9hZGVyU3RhdGU+PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhc3NldCBpcyBjb21wbGV0ZWx5IGxvYWRlZC5cclxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFzc2V0IGlzIGNvbXBsZXRlbHkgbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd2hlbkNvbXBsZXRlQXN5bmMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlT2JzZXJ2YWJsZS5hZGRPbmNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMub25FcnJvck9ic2VydmFibGUuYWRkT25jZSgocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIF9zZXRTdGF0ZShzdGF0ZTogR0xURkxvYWRlclN0YXRlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBzdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMub25Mb2FkZXJTdGF0ZUNoYW5nZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0aGlzLl9zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fbG9nKEdMVEZMb2FkZXJTdGF0ZVt0aGlzLl9zdGF0ZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBfbG9hZEZpbGUoXHJcbiAgICAgICAgc2NlbmU6IFNjZW5lLFxyXG4gICAgICAgIGZpbGVPclVybDogRmlsZSB8IHN0cmluZyxcclxuICAgICAgICBvblN1Y2Nlc3M6IChkYXRhOiBzdHJpbmcgfCBBcnJheUJ1ZmZlcikgPT4gdm9pZCxcclxuICAgICAgICB1c2VBcnJheUJ1ZmZlcj86IGJvb2xlYW4sXHJcbiAgICAgICAgb25FcnJvcj86IChyZXF1ZXN0PzogV2ViUmVxdWVzdCkgPT4gdm9pZCxcclxuICAgICAgICBvbk9wZW5lZD86IChyZXF1ZXN0OiBXZWJSZXF1ZXN0KSA9PiB2b2lkXHJcbiAgICApOiBJRmlsZVJlcXVlc3Qge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzY2VuZS5fbG9hZEZpbGUoXHJcbiAgICAgICAgICAgIGZpbGVPclVybCxcclxuICAgICAgICAgICAgb25TdWNjZXNzLFxyXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uUHJvZ3Jlc3MoZXZlbnQsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICB1c2VBcnJheUJ1ZmZlcixcclxuICAgICAgICAgICAgb25FcnJvcixcclxuICAgICAgICAgICAgb25PcGVuZWRcclxuICAgICAgICApIGFzIElGaWxlUmVxdWVzdEluZm87XHJcbiAgICAgICAgcmVxdWVzdC5vbkNvbXBsZXRlT2JzZXJ2YWJsZS5hZGQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgbGVuZ3RoIGNvbXB1dGFibGUgdG8gYmUgdHJ1ZSBzaW5jZSB3ZSBjYW4gZ3VhcmFudGVlIHRoZSBkYXRhIGlzIGxvYWRlZC5cclxuICAgICAgICAgICAgcmVxdWVzdC5fbGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuX3RvdGFsID0gcmVxdWVzdC5fbG9hZGVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfb25Qcm9ncmVzcyhldmVudDogUHJvZ3Jlc3NFdmVudCwgcmVxdWVzdDogSUZpbGVSZXF1ZXN0SW5mbyk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXF1ZXN0Ll9sZW5ndGhDb21wdXRhYmxlID0gZXZlbnQubGVuZ3RoQ29tcHV0YWJsZTtcclxuICAgICAgICByZXF1ZXN0Ll9sb2FkZWQgPSBldmVudC5sb2FkZWQ7XHJcbiAgICAgICAgcmVxdWVzdC5fdG90YWwgPSBldmVudC50b3RhbDtcclxuXHJcbiAgICAgICAgbGV0IGxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xyXG4gICAgICAgIGxldCBsb2FkZWQgPSAwO1xyXG4gICAgICAgIGxldCB0b3RhbCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHRoaXMuX3JlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Ll9sZW5ndGhDb21wdXRhYmxlID09PSB1bmRlZmluZWQgfHwgcmVxdWVzdC5fbG9hZGVkID09PSB1bmRlZmluZWQgfHwgcmVxdWVzdC5fdG90YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlID0gbGVuZ3RoQ29tcHV0YWJsZSAmJiByZXF1ZXN0Ll9sZW5ndGhDb21wdXRhYmxlO1xyXG4gICAgICAgICAgICBsb2FkZWQgKz0gcmVxdWVzdC5fbG9hZGVkO1xyXG4gICAgICAgICAgICB0b3RhbCArPSByZXF1ZXN0Ll90b3RhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBsZW5ndGhDb21wdXRhYmxlLFxyXG4gICAgICAgICAgICBsb2FkZWQ6IGxvYWRlZCxcclxuICAgICAgICAgICAgdG90YWw6IGxlbmd0aENvbXB1dGFibGUgPyB0b3RhbCA6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGUoc2NlbmU6IFNjZW5lLCBkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5LCByb290VXJsID0gXCJcIiwgZmlsZU5hbWUgPSBcIlwiKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXJ0UGVyZm9ybWFuY2VDb3VudGVyKFwiVmFsaWRhdGUgSlNPTlwiKTtcclxuICAgICAgICBHTFRGVmFsaWRhdGlvbi5WYWxpZGF0ZUFzeW5jKGRhdGEsIHJvb3RVcmwsIGZpbGVOYW1lLCAodXJpKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXByb2Nlc3NVcmxBc3luYyhyb290VXJsICsgdXJpKS50aGVuKCh1cmwpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2VuZS5fbG9hZEZpbGVBc3luYyh1cmwsIHVuZGVmaW5lZCwgdHJ1ZSwgdHJ1ZSkudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLnRoZW4oXHJcbiAgICAgICAgICAgIChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFBlcmZvcm1hbmNlQ291bnRlcihcIlZhbGlkYXRlIEpTT05cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25WYWxpZGF0ZWRPYnNlcnZhYmxlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFBlcmZvcm1hbmNlQ291bnRlcihcIlZhbGlkYXRlIEpTT05cIik7XHJcbiAgICAgICAgICAgICAgICBUb29scy5XYXJuKGBGYWlsZWQgdG8gdmFsaWRhdGU6ICR7cmVhc29uLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGVkT2JzZXJ2YWJsZS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXRMb2FkZXIobG9hZGVyRGF0YTogSUdMVEZMb2FkZXJEYXRhKTogSUdMVEZMb2FkZXIge1xyXG4gICAgICAgIGNvbnN0IGFzc2V0ID0gKDxhbnk+bG9hZGVyRGF0YS5qc29uKS5hc3NldCB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5fbG9nKGBBc3NldCB2ZXJzaW9uOiAke2Fzc2V0LnZlcnNpb259YCk7XHJcbiAgICAgICAgYXNzZXQubWluVmVyc2lvbiAmJiB0aGlzLl9sb2coYEFzc2V0IG1pbmltdW0gdmVyc2lvbjogJHthc3NldC5taW5WZXJzaW9ufWApO1xyXG4gICAgICAgIGFzc2V0LmdlbmVyYXRvciAmJiB0aGlzLl9sb2coYEFzc2V0IGdlbmVyYXRvcjogJHthc3NldC5nZW5lcmF0b3J9YCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBHTFRGRmlsZUxvYWRlci5fcGFyc2VWZXJzaW9uKGFzc2V0LnZlcnNpb24pO1xyXG4gICAgICAgIGlmICghdmVyc2lvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb246IFwiICsgYXNzZXQudmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXNzZXQubWluVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pblZlcnNpb24gPSBHTFRGRmlsZUxvYWRlci5fcGFyc2VWZXJzaW9uKGFzc2V0Lm1pblZlcnNpb24pO1xyXG4gICAgICAgICAgICBpZiAoIW1pblZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWluaW11bSB2ZXJzaW9uOiBcIiArIGFzc2V0Lm1pblZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoR0xURkZpbGVMb2FkZXIuX2NvbXBhcmVWZXJzaW9uKG1pblZlcnNpb24sIHsgbWFqb3I6IDIsIG1pbm9yOiAwIH0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wYXRpYmxlIG1pbmltdW0gdmVyc2lvbjogXCIgKyBhc3NldC5taW5WZXJzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY3JlYXRlTG9hZGVyczogeyBba2V5OiBudW1iZXJdOiAocGFyZW50OiBHTFRGRmlsZUxvYWRlcikgPT4gSUdMVEZMb2FkZXIgfSA9IHtcclxuICAgICAgICAgICAgMTogR0xURkZpbGVMb2FkZXIuX0NyZWF0ZUdMVEYxTG9hZGVyLFxyXG4gICAgICAgICAgICAyOiBHTFRGRmlsZUxvYWRlci5fQ3JlYXRlR0xURjJMb2FkZXIsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgY3JlYXRlTG9hZGVyID0gY3JlYXRlTG9hZGVyc1t2ZXJzaW9uLm1ham9yXTtcclxuICAgICAgICBpZiAoIWNyZWF0ZUxvYWRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2ZXJzaW9uOiBcIiArIGFzc2V0LnZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvYWRlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9wYXJzZUpzb24oanNvbjogc3RyaW5nKTogb2JqZWN0IHtcclxuICAgICAgICB0aGlzLl9zdGFydFBlcmZvcm1hbmNlQ291bnRlcihcIlBhcnNlIEpTT05cIik7XHJcbiAgICAgICAgdGhpcy5fbG9nKGBKU09OIGxlbmd0aDogJHtqc29uLmxlbmd0aH1gKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgICAgIHRoaXMuX2VuZFBlcmZvcm1hbmNlQ291bnRlcihcIlBhcnNlIEpTT05cIik7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91bnBhY2tCaW5hcnlBc3luYyhkYXRhUmVhZGVyOiBEYXRhUmVhZGVyKTogUHJvbWlzZTxJR0xURkxvYWRlckRhdGE+IHtcclxuICAgICAgICB0aGlzLl9zdGFydFBlcmZvcm1hbmNlQ291bnRlcihcIlVucGFjayBCaW5hcnlcIik7XHJcblxyXG4gICAgICAgIC8vIFJlYWQgbWFnaWMgKyB2ZXJzaW9uICsgbGVuZ3RoICsganNvbiBsZW5ndGggKyBqc29uIGZvcm1hdFxyXG4gICAgICAgIHJldHVybiBkYXRhUmVhZGVyLmxvYWRBc3luYygyMCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IEJpbmFyeSA9IHtcclxuICAgICAgICAgICAgICAgIE1hZ2ljOiAweDQ2NTQ2YzY3LFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbWFnaWMgPSBkYXRhUmVhZGVyLnJlYWRVaW50MzIoKTtcclxuICAgICAgICAgICAgaWYgKG1hZ2ljICE9PSBCaW5hcnkuTWFnaWMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJVbmV4cGVjdGVkIG1hZ2ljOiBcIiArIG1hZ2ljLCBFcnJvckNvZGVzLkdMVEZMb2FkZXJVbmV4cGVjdGVkTWFnaWNFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBkYXRhUmVhZGVyLnJlYWRVaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvZ2dpbmdFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coYEJpbmFyeSB2ZXJzaW9uOiAke3ZlcnNpb259YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFSZWFkZXIucmVhZFVpbnQzMigpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXNlUmFuZ2VSZXF1ZXN0cyAmJiBsZW5ndGggIT09IGRhdGFSZWFkZXIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKGBMZW5ndGggaW4gaGVhZGVyIGRvZXMgbm90IG1hdGNoIGFjdHVhbCBkYXRhIGxlbmd0aDogJHtsZW5ndGh9ICE9ICR7ZGF0YVJlYWRlci5idWZmZXIuYnl0ZUxlbmd0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHVucGFja2VkOiBQcm9taXNlPElHTFRGTG9hZGVyRGF0YT47XHJcbiAgICAgICAgICAgIHN3aXRjaCAodmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5wYWNrZWQgPSB0aGlzLl91bnBhY2tCaW5hcnlWMUFzeW5jKGRhdGFSZWFkZXIsIGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcclxuICAgICAgICAgICAgICAgICAgICB1bnBhY2tlZCA9IHRoaXMuX3VucGFja0JpbmFyeVYyQXN5bmMoZGF0YVJlYWRlciwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2ZXJzaW9uOiBcIiArIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9lbmRQZXJmb3JtYW5jZUNvdW50ZXIoXCJVbnBhY2sgQmluYXJ5XCIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVucGFja2VkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3VucGFja0JpbmFyeVYxQXN5bmMoZGF0YVJlYWRlcjogRGF0YVJlYWRlciwgbGVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPElHTFRGTG9hZGVyRGF0YT4ge1xyXG4gICAgICAgIGNvbnN0IENvbnRlbnRGb3JtYXQgPSB7XHJcbiAgICAgICAgICAgIEpTT046IDAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGRhdGFSZWFkZXIucmVhZFVpbnQzMigpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRGb3JtYXQgPSBkYXRhUmVhZGVyLnJlYWRVaW50MzIoKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRlbnRGb3JtYXQgIT09IENvbnRlbnRGb3JtYXQuSlNPTikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY29udGVudCBmb3JtYXQ6ICR7Y29udGVudEZvcm1hdH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJvZHlMZW5ndGggPSBsZW5ndGggLSBkYXRhUmVhZGVyLmJ5dGVPZmZzZXQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGE6IElHTFRGTG9hZGVyRGF0YSA9IHsganNvbjogdGhpcy5fcGFyc2VKc29uKGRhdGFSZWFkZXIucmVhZFN0cmluZyhjb250ZW50TGVuZ3RoKSksIGJpbjogbnVsbCB9O1xyXG4gICAgICAgIGlmIChib2R5TGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Qnl0ZU9mZnNldCA9IGRhdGFSZWFkZXIuYnl0ZU9mZnNldDtcclxuICAgICAgICAgICAgZGF0YS5iaW4gPSB7XHJcbiAgICAgICAgICAgICAgICByZWFkQXN5bmM6IChieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSA9PiBkYXRhUmVhZGVyLmJ1ZmZlci5yZWFkQXN5bmMoc3RhcnRCeXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBib2R5TGVuZ3RoLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91bnBhY2tCaW5hcnlWMkFzeW5jKGRhdGFSZWFkZXI6IERhdGFSZWFkZXIsIGxlbmd0aDogbnVtYmVyKTogUHJvbWlzZTxJR0xURkxvYWRlckRhdGE+IHtcclxuICAgICAgICBjb25zdCBDaHVua0Zvcm1hdCA9IHtcclxuICAgICAgICAgICAgSlNPTjogMHg0ZTRmNTM0YSxcclxuICAgICAgICAgICAgQklOOiAweDAwNGU0OTQyLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFJlYWQgdGhlIEpTT04gY2h1bmsgaGVhZGVyLlxyXG4gICAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gZGF0YVJlYWRlci5yZWFkVWludDMyKCk7XHJcbiAgICAgICAgY29uc3QgY2h1bmtGb3JtYXQgPSBkYXRhUmVhZGVyLnJlYWRVaW50MzIoKTtcclxuICAgICAgICBpZiAoY2h1bmtGb3JtYXQgIT09IENodW5rRm9ybWF0LkpTT04pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgY2h1bmsgZm9ybWF0IGlzIG5vdCBKU09OXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgY2h1bmtzLlxyXG4gICAgICAgIGlmIChkYXRhUmVhZGVyLmJ5dGVPZmZzZXQgKyBjaHVua0xlbmd0aCA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhUmVhZGVyLmxvYWRBc3luYyhjaHVua0xlbmd0aCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBqc29uOiB0aGlzLl9wYXJzZUpzb24oZGF0YVJlYWRlci5yZWFkU3RyaW5nKGNodW5rTGVuZ3RoKSksIGJpbjogbnVsbCB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlYWQgdGhlIEpTT04gY2h1bmsgYW5kIHRoZSBsZW5ndGggYW5kIHR5cGUgb2YgdGhlIG5leHQgY2h1bmsuXHJcbiAgICAgICAgcmV0dXJuIGRhdGFSZWFkZXIubG9hZEFzeW5jKGNodW5rTGVuZ3RoICsgOCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGE6IElHTFRGTG9hZGVyRGF0YSA9IHsganNvbjogdGhpcy5fcGFyc2VKc29uKGRhdGFSZWFkZXIucmVhZFN0cmluZyhjaHVua0xlbmd0aCkpLCBiaW46IG51bGwgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRBc3luYyA9ICgpOiBQcm9taXNlPElHTFRGTG9hZGVyRGF0YT4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtMZW5ndGggPSBkYXRhUmVhZGVyLnJlYWRVaW50MzIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rRm9ybWF0ID0gZGF0YVJlYWRlci5yZWFkVWludDMyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua0Zvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ2h1bmtGb3JtYXQuSlNPTjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIEpTT04gY2h1bmtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ2h1bmtGb3JtYXQuQklOOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Qnl0ZU9mZnNldCA9IGRhdGFSZWFkZXIuYnl0ZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5iaW4gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkQXN5bmM6IChieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSA9PiBkYXRhUmVhZGVyLmJ1ZmZlci5yZWFkQXN5bmMoc3RhcnRCeXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBjaHVua0xlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVJlYWRlci5za2lwQnl0ZXMoY2h1bmtMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdW5yZWNvZ25pemVkIGNodW5rRm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFSZWFkZXIuc2tpcEJ5dGVzKGNodW5rTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkYXRhUmVhZGVyLmJ5dGVPZmZzZXQgIT09IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUmVhZGVyLmxvYWRBc3luYyg4KS50aGVuKHJlYWRBc3luYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWFkQXN5bmMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfcGFyc2VWZXJzaW9uKHZlcnNpb246IHN0cmluZyk6IE51bGxhYmxlPHsgbWFqb3I6IG51bWJlcjsgbWlub3I6IG51bWJlciB9PiB7XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFwiMS4wXCIgfHwgdmVyc2lvbiA9PT0gXCIxLjAuMVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtYWpvcjogMSxcclxuICAgICAgICAgICAgICAgIG1pbm9yOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAodmVyc2lvbiArIFwiXCIpLm1hdGNoKC9eKFxcZCspXFwuKFxcZCspLyk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1ham9yOiBwYXJzZUludChtYXRjaFsxXSksXHJcbiAgICAgICAgICAgIG1pbm9yOiBwYXJzZUludChtYXRjaFsyXSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfY29tcGFyZVZlcnNpb24oYTogeyBtYWpvcjogbnVtYmVyOyBtaW5vcjogbnVtYmVyIH0sIGI6IHsgbWFqb3I6IG51bWJlcjsgbWlub3I6IG51bWJlciB9KTogbnVtYmVyIHtcclxuICAgICAgICBpZiAoYS5tYWpvciA+IGIubWFqb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhLm1ham9yIDwgYi5tYWpvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhLm1pbm9yID4gYi5taW5vcikge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubWlub3IgPCBiLm1pbm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgX2xvZ1NwYWNlcyA9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtcclxuICAgIHByaXZhdGUgX2xvZ0luZGVudExldmVsID0gMDtcclxuICAgIHByaXZhdGUgX2xvZ2dpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIF9sb2cgPSB0aGlzLl9sb2dEaXNhYmxlZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX2xvZ09wZW4obWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbG9nKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0luZGVudExldmVsKys7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIF9sb2dDbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICAtLXRoaXMuX2xvZ0luZGVudExldmVsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvZ0VuYWJsZWQobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgc3BhY2VzID0gR0xURkZpbGVMb2FkZXIuX2xvZ1NwYWNlcy5zdWJzdHJpbmcoMCwgdGhpcy5fbG9nSW5kZW50TGV2ZWwgKiAyKTtcclxuICAgICAgICBMb2dnZXIuTG9nKGAke3NwYWNlc30ke21lc3NhZ2V9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfbG9nRGlzYWJsZWQobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7fVxyXG5cclxuICAgIHByaXZhdGUgX2NhcHR1cmVQZXJmb3JtYW5jZUNvdW50ZXJzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIF9zdGFydFBlcmZvcm1hbmNlQ291bnRlciA9IHRoaXMuX3N0YXJ0UGVyZm9ybWFuY2VDb3VudGVyRGlzYWJsZWQ7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcHVibGljIF9lbmRQZXJmb3JtYW5jZUNvdW50ZXIgPSB0aGlzLl9lbmRQZXJmb3JtYW5jZUNvdW50ZXJEaXNhYmxlZDtcclxuXHJcbiAgICBwcml2YXRlIF9zdGFydFBlcmZvcm1hbmNlQ291bnRlckVuYWJsZWQoY291bnRlck5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIFRvb2xzLlN0YXJ0UGVyZm9ybWFuY2VDb3VudGVyKGNvdW50ZXJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zdGFydFBlcmZvcm1hbmNlQ291bnRlckRpc2FibGVkKGNvdW50ZXJOYW1lOiBzdHJpbmcpOiB2b2lkIHt9XHJcblxyXG4gICAgcHJpdmF0ZSBfZW5kUGVyZm9ybWFuY2VDb3VudGVyRW5hYmxlZChjb3VudGVyTmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgVG9vbHMuRW5kUGVyZm9ybWFuY2VDb3VudGVyKGNvdW50ZXJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9lbmRQZXJmb3JtYW5jZUNvdW50ZXJEaXNhYmxlZChjb3VudGVyTmFtZTogc3RyaW5nKTogdm9pZCB7fVxyXG59XHJcblxyXG5SZWdpc3RlclNjZW5lTG9hZGVyUGx1Z2luKG5ldyBHTFRGRmlsZUxvYWRlcigpKTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgZ2l0aHViL25vLXRoZW4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cclxuaW1wb3J0IHR5cGUgKiBhcyBHTFRGMiBmcm9tIFwiYmFieWxvbmpzLWdsdGYyaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7IFRvb2xzIH0gZnJvbSBcImNvcmUvTWlzYy90b29sc1wiO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5kZWNsYXJlIGxldCBHTFRGVmFsaWRhdG9yOiBHTFRGMi5JR0xURlZhbGlkYXRvcjtcclxuXHJcbi8vIFdvcmtlckdsb2JhbFNjb3BlXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZGVjbGFyZSBmdW5jdGlvbiBpbXBvcnRTY3JpcHRzKC4uLnVybHM6IHN0cmluZ1tdKTogdm9pZDtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG5kZWNsYXJlIGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1lc3NhZ2U6IGFueSwgdHJhbnNmZXI/OiBhbnlbXSk6IHZvaWQ7XHJcblxyXG5mdW5jdGlvbiBWYWxpZGF0ZUFzeW5jKFxyXG4gICAgZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSxcclxuICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgIGZpbGVOYW1lOiBzdHJpbmcsXHJcbiAgICBnZXRFeHRlcm5hbFJlc291cmNlOiAodXJpOiBzdHJpbmcpID0+IFByb21pc2U8VWludDhBcnJheT5cclxuKTogUHJvbWlzZTxHTFRGMi5JR0xURlZhbGlkYXRpb25SZXN1bHRzPiB7XHJcbiAgICBjb25zdCBvcHRpb25zOiBHTFRGMi5JR0xURlZhbGlkYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGV4dGVybmFsUmVzb3VyY2VGdW5jdGlvbjogZ2V0RXh0ZXJuYWxSZXNvdXJjZSxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGZpbGVOYW1lKSB7XHJcbiAgICAgICAgb3B0aW9ucy51cmkgPSByb290VXJsID09PSBcImZpbGU6XCIgPyBmaWxlTmFtZSA6IHJvb3RVcmwgKyBmaWxlTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpID8gR0xURlZhbGlkYXRvci52YWxpZGF0ZUJ5dGVzKGRhdGEsIG9wdGlvbnMpIDogR0xURlZhbGlkYXRvci52YWxpZGF0ZVN0cmluZyhkYXRhLCBvcHRpb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSB3b3JrZXIgZnVuY3Rpb24gdGhhdCBnZXRzIGNvbnZlcnRlZCB0byBhIGJsb2IgdXJsIHRvIHBhc3MgaW50byBhIHdvcmtlci5cclxuICovXHJcbmZ1bmN0aW9uIFdvcmtlckZ1bmMoKTogdm9pZCB7XHJcbiAgICBjb25zdCBwZW5kaW5nRXh0ZXJuYWxSZXNvdXJjZXM6IEFycmF5PHsgcmVzb2x2ZTogKGRhdGE6IGFueSkgPT4gdm9pZDsgcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQgfT4gPSBbXTtcclxuXHJcbiAgICBvbm1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzYWdlLmRhdGE7XHJcbiAgICAgICAgc3dpdGNoIChkYXRhLmlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbml0XCI6IHtcclxuICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoZGF0YS51cmwpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInZhbGlkYXRlXCI6IHtcclxuICAgICAgICAgICAgICAgIFZhbGlkYXRlQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucm9vdFVybCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICh1cmkpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGVuZGluZ0V4dGVybmFsUmVzb3VyY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdFeHRlcm5hbFJlc291cmNlcy5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyBpZDogXCJnZXRFeHRlcm5hbFJlc291cmNlXCIsIGluZGV4OiBpbmRleCwgdXJpOiB1cmkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgaWQ6IFwidmFsaWRhdGUucmVzb2x2ZVwiLCB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgaWQ6IFwidmFsaWRhdGUucmVqZWN0XCIsIHJlYXNvbjogcmVhc29uIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiZ2V0RXh0ZXJuYWxSZXNvdXJjZS5yZXNvbHZlXCI6IHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdFeHRlcm5hbFJlc291cmNlc1tkYXRhLmluZGV4XS5yZXNvbHZlKGRhdGEudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcImdldEV4dGVybmFsUmVzb3VyY2UucmVqZWN0XCI6IHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdFeHRlcm5hbFJlc291cmNlc1tkYXRhLmluZGV4XS5yZWplY3QoZGF0YS5yZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ29uZmlndXJhdGlvbiBmb3IgZ2xURiB2YWxpZGF0aW9uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHTFRGVmFsaWRhdGlvbkNvbmZpZ3VyYXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBnbFRGIHZhbGlkYXRvci5cclxuICAgICAqL1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnbFRGIHZhbGlkYXRpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBHTFRGVmFsaWRhdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uLiBEZWZhdWx0cyB0byBgeyB1cmw6IFwiaHR0cHM6Ly9jZG4uYmFieWxvbmpzLmNvbS9nbHRmX3ZhbGlkYXRvci5qc1wiIH1gLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENvbmZpZ3VyYXRpb246IElHTFRGVmFsaWRhdGlvbkNvbmZpZ3VyYXRpb24gPSB7XHJcbiAgICAgICAgdXJsOiBgJHtUb29scy5fRGVmYXVsdENkblVybH0vZ2x0Zl92YWxpZGF0b3IuanNgLFxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfTG9hZFNjcmlwdFByb21pc2U6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSBhIGdsVEYgYXNzZXQgdXNpbmcgdGhlIGdsVEYtVmFsaWRhdG9yLlxyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIEpTT04gb2YgYSBnbFRGIG9yIHRoZSBhcnJheSBidWZmZXIgb2YgYSBiaW5hcnkgZ2xURlxyXG4gICAgICogQHBhcmFtIHJvb3RVcmwgVGhlIHJvb3QgdXJsIGZvciB0aGUgZ2xURlxyXG4gICAgICogQHBhcmFtIGZpbGVOYW1lIFRoZSBmaWxlIG5hbWUgZm9yIHRoZSBnbFRGXHJcbiAgICAgKiBAcGFyYW0gZ2V0RXh0ZXJuYWxSZXNvdXJjZSBUaGUgY2FsbGJhY2sgdG8gZ2V0IGV4dGVybmFsIHJlc291cmNlcyBmb3IgdGhlIGdsVEYgdmFsaWRhdG9yXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBnbFRGIHZhbGlkYXRpb24gcmVzdWx0cyBvbmNlIGNvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVmFsaWRhdGVBc3luYyhcclxuICAgICAgICBkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5LFxyXG4gICAgICAgIHJvb3RVcmw6IHN0cmluZyxcclxuICAgICAgICBmaWxlTmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGdldEV4dGVybmFsUmVzb3VyY2U6ICh1cmk6IHN0cmluZykgPT4gUHJvbWlzZTxVaW50OEFycmF5PlxyXG4gICAgKTogUHJvbWlzZTxHTFRGMi5JR0xURlZhbGlkYXRpb25SZXN1bHRzPiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2VyQ29udGVudCA9IGAke1ZhbGlkYXRlQXN5bmN9KCR7V29ya2VyRnVuY30pKClgO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2VyQmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlckNvbnRlbnRdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyQmxvYlVybCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnJvcjogRXJyb3JFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKG1lc3NhZ2U6IE1lc3NhZ2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzYWdlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRFeHRlcm5hbFJlc291cmNlXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEV4dGVybmFsUmVzb3VyY2UoZGF0YS51cmkpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IGlkOiBcImdldEV4dGVybmFsUmVzb3VyY2UucmVzb2x2ZVwiLCBpbmRleDogZGF0YS5pbmRleCwgdmFsdWU6IHZhbHVlIH0sIFt2YWx1ZS5idWZmZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IFwiZ2V0RXh0ZXJuYWxSZXNvdXJjZS5yZWplY3RcIiwgaW5kZXg6IGRhdGEuaW5kZXgsIHJlYXNvbjogcmVhc29uIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmFsaWRhdGUucmVzb2x2ZVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbGlkYXRlLnJlamVjdFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkYXRhLnJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZDogXCJpbml0XCIsIHVybDogVG9vbHMuR2V0QmFieWxvblNjcmlwdFVSTCh0aGlzLkNvbmZpZ3VyYXRpb24udXJsKSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2xpY2UgdGhlIGRhdGEgdG8gYXZvaWQgY29weWluZyB0aGUgd2hvbGUgYXJyYXkgYnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlZERhdGEgPSBkYXRhLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IFwidmFsaWRhdGVcIiwgZGF0YTogc2xpY2VkRGF0YSwgcm9vdFVybDogcm9vdFVybCwgZmlsZU5hbWU6IGZpbGVOYW1lIH0sIFtzbGljZWREYXRhLmJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZDogXCJ2YWxpZGF0ZVwiLCBkYXRhOiBkYXRhLCByb290VXJsOiByb290VXJsLCBmaWxlTmFtZTogZmlsZU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fTG9hZFNjcmlwdFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX0xvYWRTY3JpcHRQcm9taXNlID0gVG9vbHMuTG9hZEJhYnlsb25TY3JpcHRBc3luYyh0aGlzLkNvbmZpZ3VyYXRpb24udXJsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX0xvYWRTY3JpcHRQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRlQXN5bmMoZGF0YSwgcm9vdFVybCwgZmlsZU5hbWUsIGdldEV4dGVybmFsUmVzb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURkZpbGVMb2FkZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURlZhbGlkYXRpb25cIjtcclxuaW1wb3J0ICogYXMgR0xURjEgZnJvbSBcIi4vMS4wL2luZGV4XCI7XHJcbmltcG9ydCAqIGFzIEdMVEYyIGZyb20gXCIuLzIuMC9pbmRleFwiO1xyXG5leHBvcnQgeyBHTFRGMSwgR0xURjIgfTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cclxuZXhwb3J0ICogZnJvbSBcIi4vZ2xURi9pbmRleFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9PQkovaW5kZXhcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vU1RML2luZGV4XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL1NQTEFUL2luZGV4XCI7XHJcbiIsImltcG9ydCAqIGFzIEZpbGVMb2FkZXIgZnJvbSBcImxvYWRlcnMvZ2xURi9nbFRGRmlsZUxvYWRlclwiO1xyXG5pbXBvcnQgKiBhcyBWYWxpZGF0aW9uIGZyb20gXCJsb2FkZXJzL2dsVEYvZ2xURlZhbGlkYXRpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFVNRCBtb2R1bGUuXHJcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBmdXR1cmUgRVNNIHBhY2thZ2Ugc2hvdWxkIGJlIGluZGV4LnRzXHJcbiAqL1xyXG5jb25zdCBHbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcclxuaWYgKHR5cGVvZiBHbG9iYWxPYmplY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTiA9ICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTiB8fCB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIEZpbGVMb2FkZXIpIHtcclxuICAgICAgICAoPGFueT5HbG9iYWxPYmplY3QpLkJBQllMT05ba2V5XSA9ICg8YW55PkZpbGVMb2FkZXIpW2tleV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBWYWxpZGF0aW9uKSB7XHJcbiAgICAgICAgKDxhbnk+R2xvYmFsT2JqZWN0KS5CQUJZTE9OW2tleV0gPSAoPGFueT5WYWxpZGF0aW9uKVtrZXldO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgKiBmcm9tIFwibG9hZGVycy9nbFRGL2dsVEZGaWxlTG9hZGVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCJsb2FkZXJzL2dsVEYvZ2xURlZhbGlkYXRpb25cIjtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cclxuaW1wb3J0ICogYXMgR0xURjEgZnJvbSBcImxvYWRlcnMvZ2xURi8xLjAvaW5kZXhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFVNRCBtb2R1bGUuXHJcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBmdXR1cmUgRVNNIHBhY2thZ2Ugc2hvdWxkIGJlIGluZGV4LnRzXHJcbiAqL1xyXG5jb25zdCBHbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcclxuaWYgKHR5cGVvZiBHbG9iYWxPYmplY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTiA9ICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTiB8fCB7fTtcclxuICAgICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTi5HTFRGMSA9ICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTi5HTFRGMSB8fCB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIEdMVEYxKSB7XHJcbiAgICAgICAgKDxhbnk+R2xvYmFsT2JqZWN0KS5CQUJZTE9OLkdMVEYxW2tleV0gPSAoPGFueT5HTFRGMSlba2V5XTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgR0xURjEgfTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cclxuaW1wb3J0ICogYXMgRXh0ZW5zaW9ucyBmcm9tIFwibG9hZGVycy9nbFRGLzIuMC9FeHRlbnNpb25zL2luZGV4XCI7XHJcbmltcG9ydCAqIGFzIEludGVyZmFjZXMgZnJvbSBcImxvYWRlcnMvZ2xURi8yLjAvZ2xURkxvYWRlckludGVyZmFjZXNcIjtcclxuaW1wb3J0ICogYXMgR0xURjIgZnJvbSBcImxvYWRlcnMvZ2xURi8yLjAvaW5kZXhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFVNRCBtb2R1bGUuXHJcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBmdXR1cmUgRVNNIHBhY2thZ2Ugc2hvdWxkIGJlIGluZGV4LnRzXHJcbiAqL1xyXG5jb25zdCBHbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcclxuaWYgKHR5cGVvZiBHbG9iYWxPYmplY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTiA9ICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTiB8fCB7fTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgIGNvbnN0IEJBQllMT04gPSAoPGFueT5HbG9iYWxPYmplY3QpLkJBQllMT047XHJcbiAgICBCQUJZTE9OLkdMVEYyID0gQkFCWUxPTi5HTFRGMiB8fCB7fTtcclxuICAgIEJBQllMT04uR0xURjIuTG9hZGVyID0gQkFCWUxPTi5HTFRGMi5Mb2FkZXIgfHwge307XHJcbiAgICBCQUJZTE9OLkdMVEYyLkxvYWRlci5FeHRlbnNpb25zID0gQkFCWUxPTi5HTFRGMi5Mb2FkZXIuRXh0ZW5zaW9ucyB8fCB7fTtcclxuXHJcbiAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBFeHRlbnNpb25zKSB7XHJcbiAgICAgICAgQkFCWUxPTi5HTFRGMi5Mb2FkZXIuRXh0ZW5zaW9uc1trZXldID0gKDxhbnk+RXh0ZW5zaW9ucylba2V5XTtcclxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIEludGVyZmFjZXMpIHtcclxuICAgICAgICBCQUJZTE9OLkdMVEYyLkxvYWRlcltrZXldID0gKDxhbnk+SW50ZXJmYWNlcylba2V5XTtcclxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBHTFRGMikge1xyXG4gICAgICAgIC8vIFByZXZlbnQgUmVhc3NpZ25tZW50LlxyXG4gICAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQkFCWUxPTi5HTFRGMltrZXldID0gKDxhbnk+R0xURjIpW2tleV07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IEdMVEYyIH07XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1pbnRlcm5hbC1tb2R1bGVzICovXHJcbmltcG9ydCAqIGFzIExvYWRlcnMgZnJvbSBcImxvYWRlcnMvT0JKL2luZGV4XCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHRoZSBVTUQgbW9kdWxlLlxyXG4gKiBUaGUgZW50cnkgcG9pbnQgZm9yIGEgZnV0dXJlIEVTTSBwYWNrYWdlIHNob3VsZCBiZSBpbmRleC50c1xyXG4gKi9cclxuY29uc3QgR2xvYmFsT2JqZWN0ID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XHJcbmlmICh0eXBlb2YgR2xvYmFsT2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBMb2FkZXJzKSB7XHJcbiAgICAgICAgaWYgKCEoPGFueT5HbG9iYWxPYmplY3QpLkJBQllMT05ba2V5XSkge1xyXG4gICAgICAgICAgICAoPGFueT5HbG9iYWxPYmplY3QpLkJBQllMT05ba2V5XSA9ICg8YW55PkxvYWRlcnMpW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgKiBmcm9tIFwibG9hZGVycy9PQkovaW5kZXhcIjtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cclxuaW1wb3J0ICogYXMgTG9hZGVycyBmcm9tIFwibG9hZGVycy9TVEwvaW5kZXhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFVNRCBtb2R1bGUuXHJcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBmdXR1cmUgRVNNIHBhY2thZ2Ugc2hvdWxkIGJlIGluZGV4LnRzXHJcbiAqL1xyXG5jb25zdCBHbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcclxuaWYgKHR5cGVvZiBHbG9iYWxPYmplY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIExvYWRlcnMpIHtcclxuICAgICAgICBpZiAoISg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTltrZXldKSB7XHJcbiAgICAgICAgICAgICg8YW55Pkdsb2JhbE9iamVjdCkuQkFCWUxPTltrZXldID0gKDxhbnk+TG9hZGVycylba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCAqIGZyb20gXCJsb2FkZXJzL1NUTC9pbmRleFwiO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvZXhwb3J0ICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1pbnRlcm5hbC1tb2R1bGVzICovXHJcbmV4cG9ydCAqIGZyb20gXCJsb2FkZXJzL2luZGV4XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2xlZ2FjeS1nbFRGXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2xlZ2FjeS1nbFRGMVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9sZWdhY3ktZ2xURjJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbGVnYWN5LW9iakZpbGVMb2FkZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbGVnYWN5LXN0bEZpbGVMb2FkZXJcIjtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2JhYnlsb25qc19NaXNjX3Rvb2xzX187IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwidmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gKG9iaikgPT4gKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSA6IChvYmopID0+IChvYmouX19wcm90b19fKTtcbnZhciBsZWFmUHJvdG90eXBlcztcbi8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLy8gbW9kZSAmIDE2OiByZXR1cm4gdmFsdWUgd2hlbiBpdCdzIFByb21pc2UtbGlrZVxuLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0aWYobW9kZSAmIDEpIHZhbHVlID0gdGhpcyh2YWx1ZSk7XG5cdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHtcblx0XHRpZigobW9kZSAmIDQpICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0XHRpZigobW9kZSAmIDE2KSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdHZhciBkZWYgPSB7fTtcblx0bGVhZlByb3RvdHlwZXMgPSBsZWFmUHJvdG90eXBlcyB8fCBbbnVsbCwgZ2V0UHJvdG8oe30pLCBnZXRQcm90byhbXSksIGdldFByb3RvKGdldFByb3RvKV07XG5cdGZvcih2YXIgY3VycmVudCA9IG1vZGUgJiAyICYmIHZhbHVlOyB0eXBlb2YgY3VycmVudCA9PSAnb2JqZWN0JyAmJiAhfmxlYWZQcm90b3R5cGVzLmluZGV4T2YoY3VycmVudCk7IGN1cnJlbnQgPSBnZXRQcm90byhjdXJyZW50KSkge1xuXHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnQpLmZvckVhY2goKGtleSkgPT4gKGRlZltrZXldID0gKCkgPT4gKHZhbHVlW2tleV0pKSk7XG5cdH1cblx0ZGVmWydkZWZhdWx0J10gPSAoKSA9PiAodmFsdWUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGRlZik7XG5cdHJldHVybiBucztcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0ICogYXMgbG9hZGVycyBmcm9tIFwiQGx0cy9sb2FkZXJzL2xlZ2FjeS9sZWdhY3lcIjtcclxuZXhwb3J0IHsgbG9hZGVycyB9O1xyXG5leHBvcnQgZGVmYXVsdCBsb2FkZXJzO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=