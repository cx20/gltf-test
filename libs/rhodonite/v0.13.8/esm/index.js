/*! For license information please see index.js.LICENSE.txt */
var t={9929:e=>{e.exports=function(e){var t={};function n(o){if(t[o])return t[o].exports;var a=t[o]={i:o,l:!1,exports:{}};return e[o].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(o,a,function(t){return e[t]}.bind(null,a));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="./../../dist/",n(n.s="./src/index.ts")}({"./src/index.ts":function(e,t,n){var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n("./src/main/Shaderity.ts"));t.default=a.default},"./src/main/PreProcessor.ts":function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{static process(e){const t=/#define[\t ]+(\w+)/,n=/#ifdef[\t ]+(\w+)/,o=/#elif[\t ]+defined\((\w+)\)/,a=/#else/,i=/#endif/,r=[];let s=!0;const l=[],c=[],_=[];for(const u of e){let e=!1;{const n=u.match(t);null!=n&&(l.push(n[1]),e=!0)}if(-1===r.indexOf(!1)){const t=u.match(n);if(null!=t){r.push(s);const n=t[1];c.push([n]),-1===l.indexOf(n)&&(s=!1),e=!0}}if(-1===r.indexOf(!1)){const t=u.match(o);if(null!=t){const n=t[1],o=c[c.length-1];let a=!0;for(const e of o)-1!==l.indexOf(e)&&(a=!1);s=!(!a||-1===l.indexOf(n)),o.push(n),e=!0}}if(-1===r.indexOf(!1)&&null!=u.match(a)){const t=c[c.length-1];let n=!0;for(const e of t)-1!==l.indexOf(e)&&(n=!1);s=n,e=!0}null!=u.match(i)&&(-1===r.indexOf(!1)&&(s=!0),e=!0,c.pop(),r.pop()),s&&!e&&_.push(u)}return _}}},"./src/main/Reflection.ts":function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t){this.__attributeSemanticsMap=new Map,this.__uniformSemanticsMap=new Map,this.__attributes=[],this.__varyings=[],this.__uniforms=[],this.__splittedShaderCode=e,this.__shaderStage=t,this.__setDefaultAttributeAndUniformSemanticsMap()}get attributes(){return this.__attributes}get varyings(){return this.__varyings}get uniforms(){return this.__uniforms}get attributesNames(){return this.__attributes.map((e=>e.name))}get attributesSemantics(){return this.__attributes.map((e=>e.semantic))}get attributesTypes(){return this.__attributes.map((e=>e.type))}addAttributeSemanticsMap(e){this.__attributeSemanticsMap=new Map([...this.__attributeSemanticsMap,...e])}addUniformSemanticsMap(e){this.__uniformSemanticsMap=new Map([...this.__uniformSemanticsMap,...e])}addAttributeSemantics(e,t){this.__attributeSemanticsMap.set(e,t)}addUniformSemantics(e,t){this.__uniformSemanticsMap.set(e,t)}resetAttributeSemantics(){this.__attributeSemanticsMap=new Map}resetUniformSemantics(){this.__uniformSemanticsMap=new Map}reflect(){const e=this.__splittedShaderCode,t=this.__shaderStage;for(const n of e)this.__matchAttribute(n,t)?this.__addAttribute(n):this.__matchVarying(n,t)?this.__addVarying(n,t):n.match(/^(?![\/])[\t ]*uniform[\t ]+/)&&this.__addUniform(n)}__setDefaultAttributeAndUniformSemanticsMap(){this.__attributeSemanticsMap.set("position","POSITION"),this.__attributeSemanticsMap.set("color$","COLOR_0"),this.__attributeSemanticsMap.set("color_?0","COLOR_0"),this.__attributeSemanticsMap.set("texcoord$","TEXCOORD_0"),this.__attributeSemanticsMap.set("texcoord_?0","TEXCOORD_0"),this.__attributeSemanticsMap.set("texcoord_?1","TEXCOORD_1"),this.__attributeSemanticsMap.set("texcoord_?2","TEXCOORD_2"),this.__attributeSemanticsMap.set("normal","NORMAL"),this.__attributeSemanticsMap.set("tangent","TANGENT"),this.__attributeSemanticsMap.set("joint$","JOINTS_0"),this.__attributeSemanticsMap.set("bone$","JOINTS_0"),this.__attributeSemanticsMap.set("joint_?0","JOINTS_0"),this.__attributeSemanticsMap.set("bone_?0","JOINTS_0"),this.__attributeSemanticsMap.set("weight$","WEIGHTS_0"),this.__attributeSemanticsMap.set("weight_?0","WEIGHTS_0"),this.__uniformSemanticsMap.set("worldmatrix","WorldMatrix"),this.__uniformSemanticsMap.set("normalmatrix","NormalMatrix"),this.__uniformSemanticsMap.set("viewmatrix","ViewMatrix"),this.__uniformSemanticsMap.set("projectionmatrix","ProjectionMatrix"),this.__uniformSemanticsMap.set("modelviewmatrix","ModelViewMatrix")}__matchAttribute(e,t){return"vertex"===t&&e.match(/^(?![\/])[\t ]*(attribute|in)[\t ]+.+;/)}__addAttribute(e){const t={name:"",type:"float",semantic:"UNKNOWN"},n=e.match(o.attributeAndVaryingTypeRegExp);if(n){const a=n[1];t.type=a;const i=n[2];t.name=i;const r=e.match(o.semanticRegExp);if(r)t.semantic=r[1];else for(let[e,n]of this.__attributeSemanticsMap)i.match(new RegExp(e,"i"))&&(t.semantic=n)}this.__attributes.push(t)}__matchVarying(e,t){return"vertex"===t?e.match(/^(?![\/])[\t ]*(varying|out)[\t ]+.+;/):e.match(/^(?![\/])[\t ]*(varying|in)[\t ]+.+;/)}__addVarying(e,t){const n={name:"",type:"float",inout:"in"},a=e.match(o.attributeAndVaryingTypeRegExp);if(a){const e=a[1];n.type=e;const o=a[2];n.name=o,n.inout="vertex"===t?"out":"in"}this.__varyings.push(n)}__addUniform(e){const t={name:"",type:"float",semantic:"UNKNOWN"},n=e.match(o.uniformTypeRegExp);if(n){const a=n[1];t.type=a;const i=n[2];t.name=i;const r=e.match(o.semanticRegExp);if(r)t.semantic=r[1];else for(let[e,n]of this.__uniformSemanticsMap)i.match(new RegExp(e,"i"))&&(t.semantic=n)}this.__uniforms.push(t)}}t.default=o,o.attributeAndVaryingTypeRegExp=/[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4)[\t ]+(\w+);/,o.uniformTypeRegExp=/[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4|sampler2D|samplerCube|sampler3D)[\t ]+(\w+);/,o.semanticRegExp=/<.*semantic[\t ]*=[\t ]*(\w+).*>/},"./src/main/ShaderEditor.ts":function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{static _insertDefinition(e,t){const n=t.replace(/#define[\t ]+/,"");e.unshift(`#define ${n}`)}static _fillTemplate(e,t){const n=e.replace(/\/\*[\t ]*shaderity:[\t ]*(@{[\t ]*)(\S+)([\t ]*})[\t ]*\*\//g,"${this.$2}");return new Function("return `"+n+"`;").call(t)}}},"./src/main/ShaderTransformer.ts":function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{static _transformToGLSLES1(e,t,n){return this.__convertOrInsertVersionGLSLES1(e),this.__removeES3Qualifier(e,n),this.__convertIn(e,t),this.__convertOut(e,t,n),this.__removePrecisionForES3(e),this.__convertTextureFunctionToES1(e,t,n),e}static _transformToGLSLES3(e,t){return this.__convertOrInsertVersionGLSLES3(e),this.__convertAttribute(e,t),this.__convertVarying(e,t),this.__convertTextureCube(e),this.__convertTexture2D(e),this.__convertTexture2DProd(e),this.__convertTexture3D(e),this.__convertTexture3DProd(e),e}static _transformTo(e,t,n,o){return e.match(/webgl2|es3/i)?this._transformToGLSLES3(t,n):e.match(/webgl1|es1/i)?this._transformToGLSLES1(t,n,o):(console.error("Invalid Version"),t)}static __convertOrInsertVersionGLSLES1(e){this.__removeFirstMatchingLine(e,/^(?![\/])[\t ]*#[\t ]*version[\t ]+.*/),e.unshift("#version 100")}static __convertOrInsertVersionGLSLES3(e){this.__removeFirstMatchingLine(e,/^(?![\/])[\t ]*#[\t ]*version[\t ]+.*/),e.unshift("#define GLSL_ES3"),e.unshift("#version 300 es")}static __convertIn(e,t){let n;n=t?function(e,t){return"varying "+t}:function(e,t){return"attribute "+t},this.__replaceLine(e,/^(?![\/])[\t ]*in[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*\w+[\t ]*;)/,n)}static __convertOut(e,t,n){if(t){const t=this.__removeOutQualifier(e,n);if(null==t)return;this.__addGLFragColor(t,e,n)}else{const t=/^(?![\/])[\t ]*out[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*\w+[\t ]*;)/,n=function(e,t){return"varying "+t};this.__replaceLine(e,t,n)}}static __removeOutQualifier(e,t){const n=/^(?![\/])[\t ]*out[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*(\w+)[\t ]*;)/;let o;for(let t=0;t<e.length;t++){const a=e[t].match(n);if(a){e[t]=a[1],o=a[3];break}}return o}static __addGLFragColor(e,t,n){const o=/(.*)\}[\n\t ]*$/,a=/[\n\t ]*return[\n\t ]*;/,i=/(^|^(?![\/])[\t\n ]+)void[\t\n ]+main([\t\n ]|\(|$)/,r=`  gl_FragColor = ${e};`;let s=!1;for(let e=t.length-1;e>=0;e--){const n=t[e];if(!s&&n.match(o)&&(t[e]=n.replace(o,`$1\n${r}\n}\n`),s=!0),n.match(a)&&t.splice(e,0,r),n.match(i))break}if(!s){const e="__removeOutQualifier: Not found the closing brackets for the main function";this.__outError(t,t.length,e,n)}}static __removeES3Qualifier(e,t){this.__removeVaryingQualifier(e,t),this.__removeLayout(e)}static __removeVaryingQualifier(e,t){const n=/^(?![\/])[\t ]*(flat|smooth)[\t ]*((in|out)[\t ]+.*)/;for(let o=0;o<e.length;o++)e[o]=e[o].replace(n,((n,a,i)=>"flat"===a?(this.__outError(e,o+1,"__removeVaryingQualifier: glsl es1 does not support flat qualifier",t),n):i))}static __removeLayout(e){this.__replaceLine(e,/^(?![\/])[\t ]*layout[\t ]*\([\t ]*location[\t ]*\=[\t ]*\d[\t ]*\)[\t ]+/g,"")}static __removePrecisionForES3(e){const t=/^(?![\/])[\t ]*precision[\t ]+(highp|mediump|lowp)[\t ]+(\w+)[\t ]*;/;for(let n=0;n<e.length;n++){const o=e[n].match(t);if(null!=o){if("int"===o[2]||"float"===o[2]||"sampler2D"===o[2]||"samplerCube"===o[2])continue;e.splice(n--,1)}}}static __convertTextureFunctionToES1(e,t,n){var o,a;const i=this.__regSymbols(),r=new RegExp(`(${i}+)textureProj(Lod|)(${i}+)`,"g"),s=new RegExp(`(${i}+)texture(Lod|)(${i}+)`,"g");let l;const c=this.__createUniformSamplerMap(e,n);for(let i=0;i<e.length;i++){const _=e[i],u=_.match(/textureProj(Lod|)[\t ]*\([\t ]*(\w+),/);if(u){l=null!=l?l:this.__createArgumentSamplerMap(e,i,n);const a="Lod"===u[1],s=t&&a?"EXT":"",_=u[2],f=null!==(o=null==l?void 0:l.get(_))&&void 0!==o?o:c.get(_);if(null!=f)if("sampler2D"===f)e[i]=e[i].replace(r,`$1texture2DProj$2${s}$3`);else{const t="__convertTextureFunctionToES1: do not support "+f+" type";this.__outError(e,i,t,n)}continue}const f=_.match(/texture(Lod|)[\t ]*\([\t ]*(\w+),/);if(f){l=null!=l?l:this.__createArgumentSamplerMap(e,i,n);const o="Lod"===f[1],r=t&&o?"EXT":"",_=f[2],u=null!==(a=null==l?void 0:l.get(_))&&void 0!==a?a:c.get(_);if(null!=u){let t;if("sampler2D"===u)t="texture2D";else if("samplerCube"===u)t="textureCube";else{t="";const o="__convertTextureFunctionToES1: do not support "+u+" type";this.__outError(e,i,o,n)}""!==t&&(e[i]=e[i].replace(s,`$1${t}$2${r}$3`))}}else _.match(/\}/)&&(l=void 0)}}static __createUniformSamplerMap(e,t){const n=new Map;for(let o=0;o<e.length;o++){const a=e[o].match(/^(?![\/])[\t ]*uniform*[\t ]*(highp|mediump|lowp|)[\t ]*(sampler\w+)[\t ]+(\w+)/);if(a){const i=a[2],r=a[3];if(n.get(r)){const n="__createUniformSamplerMap: duplicate variable name";this.__outError(e,o,n,t)}n.set(r,i)}}return n}static __createArgumentSamplerMap(e,t,n){var o,a;const i=new Map;for(let r=t;r>=0;r--){if(!e[r].match(/\{/))continue;const t=null===(o=this.__getBracketSection(e,r).match(/.*\((.*)\)/))||void 0===o?void 0:o[1];if(null==t)return;const s=t.split(","),l=/[\n\t ]*(highp|mediump|lowp|)[\n\t ]*(sampler\w+)[\n\t ]*(\w+)[\n\t ]*/;if(null!==(a=s[0].match(l))&&void 0!==a?a:s[0].match(/^[\n\t ]*$/)){for(const t of s){const o=t.match(l);if(null==o)continue;const a=o[2],s=o[3];if(i.get(s)){const t="__createArgumentSamplerMap: duplicate variable name";this.__outError(e,r,t,n)}i.set(s,a)}break}}return i}static __getBracketSection(e,t){let n=0;for(let o=t;o>=0;o--)if(e[o].match(/\(/)){n=o;break}let o="";for(let a=n;a<=t;a++)o+=e[a];return o}static __convertAttribute(e,t){t||this.__replaceLine(e,/^(?![\/])[\t ]*attribute[\t ]+/g,"in ")}static __convertVarying(e,t){const n=t?"in ":"out ";this.__replaceLine(e,/^(?![\/])[\t ]*varying[\t ]+/g,n)}static __convertTextureCube(e){const t=this.__regSymbols(),n=new RegExp(`(${t}+)(textureCube)(${t}+)`,"g");this.__replaceLine(e,n,"$1texture$3")}static __convertTexture2D(e){const t=this.__regSymbols(),n=new RegExp(`(${t}+)(texture2D)(${t}+)`,"g");this.__replaceLine(e,n,"$1texture$3")}static __convertTexture2DProd(e){const t=this.__regSymbols(),n=new RegExp(`(${t}+)(texture2DProj)(${t}+)`,"g");this.__replaceLine(e,n,"$1textureProj$3")}static __convertTexture3D(e){const t=this.__regSymbols(),n=new RegExp(`(${t}+)(texture3D)(${t}+)`,"g");this.__replaceLine(e,n,"$1texture$3")}static __convertTexture3DProd(e){const t=this.__regSymbols(),n=new RegExp(`(${t}+)(texture3DProj)(${t}+)`,"g");this.__replaceLine(e,n,"$1textureProj$3")}static __regSymbols(){return"[!\"#$%&'()*+-.,/:;<=>?@[\\]^`{|}~\t\n ]"}static __replaceLine(e,t,n){for(let o=0;o<e.length;o++)e[o]=e[o].replace(t,n)}static __removeFirstMatchingLine(e,t){for(let n=0;n<e.length;n++)if(e[n].match(t)){e.splice(n,1);break}}static __outError(e,t,n,o){if(!o)throw new Error(n);{const o=`// line ${t}: ${n}\n`,a=/(.*)\}[\n\t ]*$/;for(let t=e.length-1;t>=0&&!e[t].match(a);t--)if(e[t]===o)return;console.error(n),e.push(o)}}}},"./src/main/Shaderity.ts":function(e,t,n){var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n("./src/main/Reflection.ts")),i=o(n("./src/main/ShaderTransformer.ts")),r=o(n("./src/main/ShaderEditor.ts")),s=o(n("./src/main/Utility.ts")),l=o(n("./src/main/ShaderityObjectCreator.ts")),c=o(n("./src/main/PreProcessor.ts"));t.default=class{static transformToGLSLES1(e,t=!1){const n=s.default._splitByLineFeedCode(e.code),o=i.default._transformToGLSLES1(n,e.isFragmentShader,t);return{code:s.default._joinSplittedLine(o),shaderStage:e.shaderStage,isFragmentShader:e.isFragmentShader}}static transformToGLSLES3(e){const t=s.default._splitByLineFeedCode(e.code),n=i.default._transformToGLSLES3(t,e.isFragmentShader);return{code:s.default._joinSplittedLine(n),shaderStage:e.shaderStage,isFragmentShader:e.isFragmentShader}}static transformTo(e,t,n=!1){const o=s.default._splitByLineFeedCode(t.code),a=i.default._transformTo(e,o,t.isFragmentShader,n);return{code:s.default._joinSplittedLine(a),shaderStage:t.shaderStage,isFragmentShader:t.isFragmentShader}}static processPragma(e){const t=s.default._splitByLineFeedCode(e.code),n=c.default.process(t);return{code:s.default._joinSplittedLine(n),shaderStage:e.shaderStage,isFragmentShader:e.isFragmentShader}}static createShaderityObjectCreator(e){return new l.default(e)}static fillTemplate(e,t){const n=this.__copyShaderityObject(e);return n.code=r.default._fillTemplate(n.code,t),n}static insertDefinition(e,t){const n=this.__copyShaderityObject(e),o=s.default._splitByLineFeedCode(e.code);return r.default._insertDefinition(o,t),n.code=s.default._joinSplittedLine(o),n}static createReflectionObject(e){const t=s.default._splitByLineFeedCode(e.code);return new a.default(t,e.shaderStage)}static __copyShaderityObject(e){return{code:e.code,shaderStage:e.shaderStage,isFragmentShader:e.isFragmentShader}}}},"./src/main/ShaderityObjectCreator.ts":function(e,t,n){var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=o(n("./src/main/Utility.ts"));class i{constructor(e){this.__functionIdCount=0,this.__defineDirectiveNames=[],this.__extensions=[],this.__globalPrecision={int:"highp",float:"highp",sampler2D:"highp",samplerCube:"highp",sampler3D:"highp",sampler2DArray:"highp",isampler2D:"highp",isamplerCube:"highp",isampler3D:"highp",isampler2DArray:"highp",usampler2D:"highp",usamplerCube:"highp",usampler3D:"highp",usampler2DArray:"highp",sampler2DShadow:"highp",samplerCubeShadow:"highp",sampler2DArrayShadow:"highp"},this.__structDefinitions=[],this.__globalConstantValues=[],this.__globalConstantStructValues=[],this.__attributes=[],this.__varyings=[],this.__uniforms=[],this.__uniformStructs=[],this.__uniformBufferObjects=[],this.__functions=[],this.__mainFunctionCode="void main() {}",this.__outputColorVariableName="renderTarget0",this.__shaderStage=e}addDefineDirective(e){this.__defineDirectiveNames.some((t=>t===e))?console.warn("addDefineDirective: this define directive is already set"):this.__defineDirectiveNames.push(e)}addExtension(e,t="enable"){this.__extensions.some((t=>t.extensionName===e))?console.warn("addExtension: this extension is already set"):this.__extensions.push({extensionName:e,behavior:t})}addStructDefinition(e,t){this.__structDefinitions.some((t=>t.structName===e))?console.error(`addStructDefinition: duplicate struct type name ${e}`):this.__structDefinitions.push({structName:e,memberObjects:t})}addGlobalConstantValue(e,t,n){this.__globalConstantValues.some((t=>t.variableName===e))?console.error(`addGlobalConstantValue: duplicate variable name ${e}`):a.default._isValidComponentCount(t,n)?(a.default._isIntType(t)&&i.__existNonIntegerValue(n)&&console.warn(`addGlobalConstantValue: non-integer value is set to ${e}`),this.__globalConstantValues.push({variableName:e,type:t,values:n})):console.error(`addGlobalConstantValue: the component count of ${e} is invalid`)}addGlobalConstantStructValue(e,t,n){this.__globalConstantStructValues.some((e=>e.variableName===t))?console.error(`addGlobalConstantStructValue: duplicate variable name ${t}`):this.__globalConstantStructValues.push({variableName:t,structName:e,values:n})}addAttributeDeclaration(e,t,n){"vertex"===this.__shaderStage?this.__attributes.some((t=>t.variableName===e))?console.error(`addAttribute: duplicate variable name ${e}`):this.__attributes.push({variableName:e,type:t,precision:null==n?void 0:n.precision,location:null==n?void 0:n.location}):console.error("addAttribute: this method is for vertex shader only")}addVaryingDeclaration(e,t,n){if(this.__varyings.some((t=>t.variableName===e)))return void console.error(`addVarying: duplicate variable name ${e}`);const o=a.default._isIntType(t);let i=null==n?void 0:n.interpolationType;if(o&&"flat"!==i){if(null!=i)return void console.error("addVarying: the interpolationType must be flat for integer types");console.warn("addVarying: set the interpolationType of integer types to flat to avoid compilation error"),i="flat"}this.__varyings.push({variableName:e,type:t,precision:null==n?void 0:n.precision,interpolationType:i})}addUniformDeclaration(e,t,n){this.__uniforms.some((t=>t.variableName===e))?console.error(`addUniform: duplicate variable name ${e}`):("bool"===t&&null!=(null==n?void 0:n.precision)&&(console.warn("addUniform: remove the specification of precision for bool type to avoid compilation error"),n.precision=void 0),this.__uniforms.push({variableName:e,type:t,precision:null==n?void 0:n.precision}))}addUniformStructDeclaration(e,t){this.__uniformStructs.some((e=>e.variableName===t))?console.error(`addUniformStructDeclaration: duplicate variable name ${t}`):this.__uniformStructs.push({variableName:t,structName:e})}addUniformBufferObjectDeclaration(e,t,n){if(this.__uniformBufferObjects.some((t=>t.blockName===e)))console.error(`addUniformBufferObjectDeclaration: duplicate block name ${e}`);else{for(const e of this.__uniformBufferObjects)for(const n of e.variableObjects)for(const e of t)if(n.variableName===e.variableName)return void console.error(`addUniformBufferObjectDeclaration: duplicate variable name ${e.variableName}`);this.__uniformBufferObjects.push({blockName:e,variableObjects:t,instanceName:null==n?void 0:n.instanceName})}}addFunctionDefinition(e,t){var n,o;const a=this.__functionIdCount++,i=null!==(n=null==t?void 0:t.dependencyLevel)&&void 0!==n?n:0;return this.__functions[i]=null!==(o=this.__functions[i])&&void 0!==o?o:[],this.__functions[i].push({functionCode:e,functionId:a}),a}updateGlobalPrecision(e){Object.assign(this.__globalPrecision,e)}updateStructDefinition(e,t){const n=this.__structDefinitions.findIndex((t=>t.structName===e));-1!==n?this.__structDefinitions[n].memberObjects=t:console.error(`updateStructDefinition: the struct type name ${e} is not exist`)}updateGlobalConstantValue(e,t){const n=this.__globalConstantValues.findIndex((t=>t.variableName===e));if(-1===n)return void console.warn(`updateGlobalConstantValue: the variable name ${e} is not exist`);const o=this.__globalConstantValues[n].type;a.default._isValidComponentCount(o,t)?(a.default._isIntType(o)&&i.__existNonIntegerValue(t)&&console.warn(`updateGlobalConstantValue: the ${e} has a non-integer value.`),this.__globalConstantValues[n].values=t):console.error("updateGlobalConstantValue: the component count is invalid")}updateGlobalConstantStructValue(e,t){const n=this.__globalConstantStructValues.findIndex((t=>t.variableName===e));-1!==n?this.__globalConstantStructValues[n].values=t:console.error(`updateGlobalConstantStructValue:  the variable name ${e} is not exist`)}updateMainFunction(e){this.__mainFunctionCode=e}updateOutputColorVariableName(e){"fragment"===this.__shaderStage?0!==e.length?this.__outputColorVariableName=e:console.error("updateOutputColorVariableName: invalid outColorVariableName"):console.error("updateOutputColorVariableName: this method is for fragment shader only")}removeDefineDirective(e){const t=this.__defineDirectiveNames.indexOf(e);-1!==t?this.__defineDirectiveNames.splice(t,1):console.warn("removedDefineDirective: this define directive is not exist")}removeExtension(e){const t=this.__extensions.findIndex((t=>t.extensionName===e));-1!==t?this.__extensions.splice(t,1):console.warn("removeExtension: this extension is not exist")}removeStructDefinition(e){const t=this.__structDefinitions.findIndex((t=>t.structName===e));-1!==t?this.__structDefinitions.splice(t,1):console.error(`removeStructDefinition: the struct type name ${e} is not exist`)}removeGlobalConstantValue(e){const t=this.__globalConstantValues.findIndex((t=>t.variableName===e));-1!==t?this.__globalConstantValues.splice(t,1):console.warn(`removeGlobalConstantValue: the variable name ${e} is not exist`)}removeGlobalConstantStructValue(e){const t=this.__globalConstantStructValues.findIndex((t=>t.variableName===e));-1!==t?this.__globalConstantStructValues.splice(t,1):console.error(`updateGlobalConstantStructValue:  the variable name ${e} is not exist`)}removeAttributeDeclaration(e){const t=this.__attributes.findIndex((t=>t.variableName===e));-1!==t?this.__attributes.splice(t,1):console.warn(`removeAttribute: the variable name ${e} is not exist`)}removeVaryingDeclaration(e){const t=this.__varyings.findIndex((t=>t.variableName===e));-1!==t?this.__varyings.splice(t,1):console.warn(`removeVarying: the variable name ${e} is not exist`)}removeUniformDeclaration(e){const t=this.__uniforms.findIndex((t=>t.variableName===e));-1!==t?this.__uniforms.splice(t,1):console.warn(`removeUniform: the variable name ${e} is not exist`)}removeUniformStructDeclaration(e){const t=this.__uniformStructs.findIndex((t=>t.variableName===e));-1!==t?this.__uniformStructs.splice(t,1):console.warn(`removeUniformStructDeclaration: the variable name ${e} is not exist`)}removeUniformBufferObjectDeclaration(e){const t=this.__uniformBufferObjects.findIndex((t=>t.blockName===e));-1!==t?this.__uniformBufferObjects.splice(t,1):console.warn(`removeUniformStructDeclaration: the variable name ${e} is not exist`)}removeFunctionDefinition(e){this.__fillEmptyFunctions(),(e<0||e>=this.__functionIdCount)&&console.warn("removeFunctionDefinition: invalid function id");for(const t of this.__functions){const n=t.findIndex((t=>t.functionId===e));if(-1!==n)return void t.splice(n,1)}console.warn(`removeFunctionDefinition: not found the function of functionId ${e}`)}createShaderityObject(){return{code:this.__createShaderCode(),shaderStage:this.__shaderStage,isFragmentShader:"fragment"===this.__shaderStage}}static __existNonIntegerValue(e){for(const t of e)if(!Number.isInteger(t))return!0;return!1}__createShaderCode(){return this.__fillEmptyFunctions(),"#version 300 es\n\n"+this.__createDefineDirectiveShaderCode()+this.__createExtensionShaderCode()+this.__createGlobalPrecisionShaderCode()+this.__createStructDefinitionShaderCode()+this.__createGlobalConstantValueShaderCode()+this.__createGlobalConstantStructValueShaderCode()+this.__createAttributeDeclarationShaderCode()+this.__createVaryingDeclarationShaderCode()+this.__createOutputColorDeclarationShaderCode()+this.__createUniformDeclarationShaderCode()+this.__createUniformStructDeclarationShaderCode()+this.__createUniformBufferObjectShaderCode()+this.__createFunctionDefinitionShaderCode()+this.__createMainFunctionDefinitionShaderCode()}__fillEmptyFunctions(){var e;for(let t=0;t<this.__functions.length;t++)this.__functions[t]=null!==(e=this.__functions[t])&&void 0!==e?e:[]}__createDefineDirectiveShaderCode(){let e="";for(const t of this.__defineDirectiveNames)e+=`#define ${t}\n`;return a.default._addLineFeedCodeIfNotNullString(e)}__createExtensionShaderCode(){let e="";for(const t of this.__extensions)e+=`#extension ${t.extensionName}: ${t.behavior}\n`;return a.default._addLineFeedCodeIfNotNullString(e)}__createGlobalPrecisionShaderCode(){let e="";for(const t in this.__globalPrecision){const n=t;e+=`precision ${this.__globalPrecision[n]} ${n};\n`}return a.default._addLineFeedCodeIfNotNullString(e)}__createStructDefinitionShaderCode(){let e="";for(const t of this.__structDefinitions){e+=`struct ${t.structName} {\n`;for(let n=0;n<t.memberObjects.length;n++){const o=t.memberObjects[n];e+="  ",null!=o.precision&&(e+=`${o.precision} `),e+=`${o.type} ${o.memberName};\n`}e+="};\n"}return a.default._addLineFeedCodeIfNotNullString(e)}__createGlobalConstantValueShaderCode(){let e="";for(const t of this.__globalConstantValues){const n=t.type,o=t.variableName,a=t.values;e+=`const ${n} ${o} = ${n}(`;for(let t=0;t<a.length;t++)e+=a[t]+", ";e=e.replace(/,\s$/,");\n")}return a.default._addLineFeedCodeIfNotNullString(e)}__createGlobalConstantStructValueShaderCode(){let e="";for(const t of this.__globalConstantStructValues){const n=this.__structDefinitions.findIndex((e=>e.structName===t.structName));if(-1===n){console.error(`__createGlobalConstantStructValueShaderCode: the struct type ${t.structName} is not defined`);continue}e+=`const ${t.structName} ${t.variableName} = ${t.structName} (\n`;const o=this.__structDefinitions[n];if(o.memberObjects.length===Object.keys(t.values).length)if(o.memberObjects.some((e=>a.default._isSamplerType(e.type))))console.error(`__createGlobalConstantStructValueShaderCode: ConstantStructValue (${t.variableName}) cannot have sampler type parameter`);else{for(let n=0;n<o.memberObjects.length;n++){const i=o.memberObjects[n].memberName,r=t.values[i];if(null==r){console.error(`__createGlobalConstantStructValueShaderCode: ${t.variableName} does not have the value of ${i}`);continue}const s=o.memberObjects[n].type;if(a.default._isValidComponentCount(s,r)){e+=`  ${s}(`;for(let t=0;t<r.length;t++)e+=r[t]+", ";e=e.replace(/,\s$/,"),\n")}else console.error(`__createGlobalConstantStructValueShaderCode: the component count of ${i} in ${t.variableName} is invalid`)}e=e.replace(/,\n$/,"\n);\n")}else console.error(`__createGlobalConstantStructValueShaderCode: Invalid number of variables that ${t.variableName} has`)}return a.default._addLineFeedCodeIfNotNullString(e)}__createAttributeDeclarationShaderCode(){let e="";for(const t of this.__attributes)null!=t.location&&(e+=`layout (location = ${t.location}) `),e+="in ",null!=t.precision&&(e+=`${t.precision} `),e+=`${t.type} ${t.variableName};\n`;return a.default._addLineFeedCodeIfNotNullString(e)}__createVaryingDeclarationShaderCode(){let e="";for(const t of this.__varyings)null!=t.interpolationType&&(e+=`${t.interpolationType} `),e+="vertex"==this.__shaderStage?"out ":"in ",null!=t.precision&&(e+=`${t.precision} `),e+=`${t.type} ${t.variableName};\n`;return a.default._addLineFeedCodeIfNotNullString(e)}__createOutputColorDeclarationShaderCode(){return"fragment"!==this.__shaderStage?"":`layout(location = 0) out vec4 ${this.__outputColorVariableName};\n\n`}__createUniformDeclarationShaderCode(){let e="";for(const t of this.__uniforms)e+="uniform ",null!=t.precision&&(e+=`${t.precision} `),e+=`${t.type} ${t.variableName};\n`;return a.default._addLineFeedCodeIfNotNullString(e)}__createUniformStructDeclarationShaderCode(){let e="";for(const t of this.__uniformStructs){const n=t.structName;this.__structDefinitions.some((e=>e.structName===n))?e+=`uniform ${n} ${t.variableName};\n`:console.error(`__createUniformStructDeclarationShaderCode: the struct type ${n} is not defined`)}return a.default._addLineFeedCodeIfNotNullString(e)}__createUniformBufferObjectShaderCode(){let e="";for(const t of this.__uniformBufferObjects){e+=`layout (std140) uniform ${t.blockName} {\n`;for(let n=0;n<t.variableObjects.length;n++){const o=t.variableObjects[n];e+=`  ${o.type} ${o.variableName};\n`}null!=t.instanceName?e+=`} ${t.instanceName};\n`:e+="};\n"}return a.default._addLineFeedCodeIfNotNullString(e)}__createFunctionDefinitionShaderCode(){let e="";for(let t=0;t<this.__functions.length;t++){const n=this.__functions[t];for(let t=0;t<n.length;t++)e+=n[t].functionCode+"\n"}return a.default._addLineFeedCodeIfNotNullString(e)}__createMainFunctionDefinitionShaderCode(){return this.__mainFunctionCode+"\n"}}t.default=i},"./src/main/Utility.ts":function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class o{static _splitByLineFeedCode(e){return e.split(/\r\n|\n/)}static _joinSplittedLine(e){return e.join("\n")}static _addLineFeedCodeIfNotNullString(e){return""===e?e:e+"\n"}static _componentNumber(e){let t;return"float"===e||"int"===e||"bool"===e||"uint"===e||"sampler2D"===e||"samplerCube"===e||"sampler3D"===e||"sampler2DArray"===e||"isampler2D"===e||"isamplerCube"===e||"isampler3D"===e||"isampler2DArray"===e||"usampler2D"===e||"usamplerCube"===e||"usampler3D"===e||"usampler2DArray"===e||"sampler2DShadow"===e||"samplerCubeShadow"===e||"sampler2DArrayShadow"===e?t=1:"vec2"===e||"ivec2"===e||"bvec2"===e||"uvec2"===e?t=2:"vec3"===e||"ivec3"===e||"bvec3"===e||"uvec3"===e?t=3:"vec4"===e||"ivec4"===e||"bvec4"===e||"uvec4"===e||"mat2"===e||"mat2x2"===e?t=4:"mat2x3"===e||"mat3x2"===e?t=6:"mat2x4"===e||"mat4x2"===e?t=8:"mat3"===e||"mat3x3"===e?t=9:"mat3x4"===e||"mat4x3"===e?t=12:"mat4"===e||"mat4x4"===e?t=16:(t=0,console.error("Utility._componentNumber: detect unknown type")),t}static _isIntType(e){return"int"===e||"ivec2"===e||"ivec3"===e||"ivec4"===e||"uint"===e||"uvec2"===e||"uvec3"===e||"uvec4"===e}static _isValidComponentCount(e,t){return o._componentNumber(e)===t.length}static _isSamplerType(e){return"sampler2D"===e||"samplerCube"===e||"sampler3D"===e||"sampler2DArray"===e||"isampler2D"===e||"isamplerCube"===e||"isampler3D"===e||"isampler2DArray"===e||"usampler2D"===e||"usamplerCube"===e||"usampler3D"===e||"usampler2DArray"===e||"sampler2DShadow"===e||"samplerCubeShadow"===e||"sampler2DArrayShadow"===e}}t.default=o}})},5012:(e,t,n)=>{n.d(t,{a:()=>d});var o=n(8621),a=n(7503),i=n(5368),r=n(7295),s=n(6737),l=n(4289),c=n(4772),_=n(7476),u=n(2229),f=n(3497);class d extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.type="efk",this.playJustAfterLoaded=!1,this.isLoop=!1,this.isPause=!1,this.randomSeed=-1,this.isImageLoadWithCredential=!1,this.__speed=1,this.__isInitialized=!1,this.isLoadEffect=!1}static get componentTID(){return l.N.EffekseerComponentTID}cancelLoop(){clearInterval(this.__timer)}isPlay(){return!!u.Is.exist(this.__handle)&&!!this.__handle.exists&&!this.isPause}play(){return u.Is.not.exist(this.__context)?(f.V.warn("No Effekseer context yet"),!1):u.Is.not.exist(this.__effect)?(f.V.warn("No Effekseer effect yet"),!1):(this.stop(),this.isPause=!1,this.__handle=this.__context.play(this.__effect,0,0,0),u.Is.exist(this.__handle)&&u.Is.exist(this.__handle.setRandomSeed)&&this.randomSeed>0&&this.__handle.setRandomSeed(this.randomSeed),!0)}continue(){this.isPause=!1}pause(){u.Is.exist(this.__handle)&&(this.isPause=!0,clearInterval(this.__timer))}stop(){u.Is.exist(this.__handle)&&(this.__handle.stop(),this.isPause=!0,clearInterval(this.__timer))}set playSpeed(e){this.__handle&&this.__handle.setSpeed(e),this.__speed=e}get playSpeed(){return this.__speed}setTime(e){if(!this.play())return!1;if(u.Is.not.exist(this.__context))return!1;let t=0;const n=.0166;for(t=n;t<=e;)if(this.__context.update(t/n),t+=n,e<t){const o=n-(e-t);this.__context.update(o/n);break}return this.pause(),!0}set translate(e){this.__handle&&this.__handle.setLocation(e.x,e.y,e.z),this.entity.tryToGetTransform().localPosition=e}get translate(){return this.entity.tryToGetTransform().localPosition}set rotate(e){this.__handle&&this.__handle.setRotation(e.x,e.y,e.z),this.entity.tryToGetTransform().localEulerAngles=e}get rotate(){return this.entity.tryToGetTransform().localEulerAngles}set scale(e){this.__handle&&this.__handle.setScale(e.x,e.y,e.z),this.entity.tryToGetTransform().localScale=e}get scale(){return this.entity.tryToGetTransform().localScale}__createEffekseerContext(){if(u.Is.not.exist(this.uri)&&u.Is.not.exist(this.arrayBuffer))return!1;if(effekseer.setImageCrossOrigin(this.isImageLoadWithCredential?"use-credentials":""),this.__context=effekseer.createContext(),u.Is.not.exist(this.__context))return f.V.error("Effekseer context creation fails"),!1;const e=c.f.getWebGLResourceRepository().currentWebGLContextWrapper;this.__isInitialized=!0;const t=e.getRawContext(),n=u.Is.exist(this.uri)?this.uri:this.arrayBuffer;this.__context.init(t,{enablePremultipliedAlpha:!0});const o=()=>{this.playJustAfterLoaded&&(this.play(),this.moveStageTo(i.O.Logic))},a=(e,t)=>{f.V.error(e+", "+t)};if("efkpkg"===this.type){if(u.Is.not.exist(d.Unzip))return f.V.error("Please Set an Unzip object to EffekseerComponent.Unzip"),!1;this.__effect=this.__context.loadEffectPackage(n,d.Unzip,1,o.bind(this),a.bind(this))}else this.__effect=this.__context.loadEffect(n,1,o.bind(this),a.bind(this));return!0}$load(){!this.__isInitialized&&u.Is.not.exist(this.__context)&&u.Is.not.exist(this.__effect)&&(u.Is.exist(d.wasmModuleUri)?effekseer.initRuntime(d.wasmModuleUri,(()=>{this.__createEffekseerContext()&&this.moveStageTo(i.O.Logic)}),(()=>{f.V.error("Failed to initialize Effekseer")})):this.__createEffekseerContext()&&this.moveStageTo(i.O.Logic))}$logic(){if(this.isPause||u.Is.exist(this.__context)&&u.Is.false(this.isPause)&&this.__context.update(),null!=this.__handle){const e=d.__tmp_identityMatrix_0.copyComponents(this.entity.tryToGetSceneGraph().matrixInner);this.__handle.setMatrix(e._v),this.__handle.setSpeed(this.__speed)}this.isPause||this.isLoop&&(this.isPlay()||this.play()),this.moveStageTo(i.O.Render)}_destroy(){super._destroy(),u.Is.exist(this.__context)&&(this.__context.releaseEffect(!this.__effect),effekseer.releaseContext(this.__context),this.__context=void 0),u.Is.exist(this.__handle)&&(this.__handle=void 0),this.__effect=void 0}$render(){if(u.Is.not.exist(this.__effect))return void this.moveStageTo(i.O.Load);const e=s.O.getComponent(r.n,r.n.current),t=d.__tmp_identityMatrix_0,n=d.__tmp_identityMatrix_1;e?(t.copyComponents(e.viewMatrix),n.copyComponents(e.projectionMatrix)):(t.identity(),n.identity()),u.Is.exist(this.__context)&&(this.__context.setProjectionMatrix(n._v),this.__context.setCameraMatrix(t._v),this.__context.draw()),this.moveStageTo(i.O.Logic)}static sort_$render(e){return u.Is.false(e.toRenderEffekseerEffects)?[]:s.O.getComponentsWithType(d).map((e=>e.componentSID))}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getEffekseer(){return this.getComponentByComponentTID(d.componentTID)}}return(0,a.XJ)(e,n),e}}d.ANIMATION_EVENT_PLAY=0,d.ANIMATION_EVENT_PAUSE=1,d.ANIMATION_EVENT_END=2,d.wasmModuleUri=void 0,d.__tmp_identityMatrix_0=_.g.identity(),d.__tmp_identityMatrix_1=_.g.identity()},494:(e,t,n)=>{n.r(t),n.d(t,{Effekseer:()=>s});var o=n(5012),a=n(7503),i=n(1823),r=n(4317);const s=Object.freeze({EffekseerComponent:o.a,createEffekseerEntity:function(){const e=a.YY.createEntity(),t=a.YY.addComponentToEntity(i.W,e),n=a.YY.addComponentToEntity(r.K,t);return a.YY.addComponentToEntity(o.a,n)}})},4930:(e,t,n)=>{n.d(t,{i:()=>i});var o=n(3629),a=n(975);class i{constructor(){this.zNearMax=.1,this.zFarScalingFactor=1e5,this.autoCalculateZNearAndZFar=!0}_calcZNearInner(e,t,n){if(this.autoCalculateZNearAndZFar&&this.__targetEntities.length>0){const i=new o.F;for(const e of this.__targetEntities)i.mergeAABB(e.getSceneGraph().worldMergedAABBWithSkeletal);const r=i,s=a.Pq.lengthBtw(t,r.centerPoint),l=r.centerPoint.x-t.x,c=r.centerPoint.y-t.y,_=r.centerPoint.z-t.z,u=(l*n.x+c*n.y+_*n.z)/(Math.hypot(l,c,_)*n.length());e.zNearInner=Math.max(Math.min(s*u-r.lengthCenterToCorner,this.zNearMax),.01)}else e.zNearInner=e.zNear}_calcZFarInner(e){this.autoCalculateZNearAndZFar?e.zFarInner=e.zNearInner*this.zFarScalingFactor:e.zNearInner=e.zFar}}},2020:(e,t,n)=>{n.d(t,{w:()=>h});var o=n(975),a=n(5697),i=n(6941),r=n(2162),s=n(3870),l=n(7476),c=n(3629),_=n(4930),u=n(2229),f=n(4849),d=n(5338);class h extends _.i{constructor(e){super(),this.dollyScale=2,this.scaleOfLengthCenterToCamera=1,this.moveSpeed=1,this.followTargetAABB=!1,this.autoUpdate=!0,this.__updated=!1,this.__updateCount=0,this.__fixedLengthOfCenterToEye=1,this.__isMouseDown=!1,this.__lastMouseDownTimeStamp=0,this.__lastMouseUpTimeStamp=0,this.__originalY=-1,this.__originalX=-1,this.__buttonNumber=0,this.__mouse_translate_y=0,this.__mouse_translate_x=0,this.__efficiency=1,this.__lengthOfCenterToEye=1,this.__fovyBias=1,this.__scaleOfTranslation=2.8,this.__mouseTranslateVec=a.tp.zero(),this.__newEyeVec=a.tp.zero(),this.__newCenterVec=a.tp.zero(),this.__newUpVec=a.tp.zero(),this.__newTangentVec=a.tp.zero(),this.__isSymmetryMode=!0,this.__rot_bgn_x=0,this.__rot_bgn_y=0,this.__rot_x=0,this.__rot_y=0,this.__dolly=.5,this.__eyeVec=a.tp.zero(),this.__centerVec=a.tp.zero(),this.__upVec=a.tp.zero(),this.__targetEntities=[],this.__scaleOfZNearAndZFar=5e3,this.__doPreventDefault=!1,this.__isPressingShift=!1,this.__isPressingCtrl=!1,this.__pinchInOutControl=!1,this.__pinchInOutOriginalDistance=null,this.__resetDollyTouchTime=0,this.aabbWithSkeletal=!0,this.useInitialTargetAABBForLength=!1,this.__mouseDownFunc=this.__mouseDown.bind(this),this.__mouseUpFunc=this.__mouseUp.bind(this),this.__mouseMoveFunc=this.__mouseMove.bind(this),this.__touchDownFunc=this.__touchDown.bind(this),this.__touchUpFunc=this.__touchUp.bind(this),this.__touchMoveFunc=this.__touchMove.bind(this),this.__pinchInOutFunc=this.__pinchInOut.bind(this),this.__pinchInOutEndFunc=this.__pinchInOutEnd.bind(this),this.__mouseWheelFunc=this.__mouseWheel.bind(this),this.__mouseDblClickFunc=this.__mouseDblClick.bind(this),this.__contextMenuFunc=this.__contextMenu.bind(this),this.__pressShiftFunc=this.__pressShift.bind(this),this.__releaseShiftFunc=this.__releaseShift.bind(this),this.__pressCtrlFunc=this.__pressCtrl.bind(this),this.__releaseCtrlFunc=this.__releaseCtrl.bind(this),this.__resetDollyAndPositionFunc=this.__resetDollyAndPosition.bind(this),this.registerEventListeners(),this.__cameraControllerComponent=e}get updateCount(){return this.__updateCount}_updateCount(){this.__updateCount++,this.__cameraControllerComponent._updateCount(this.__updateCount)}resetDollyAndTranslation(){this.__dolly=.5,this.__mouse_translate_x=0,this.__mouse_translate_y=0,this.__mouseTranslateVec=a.tp.zero()}setTarget(e){this.setTargets([e])}setTargets(e){this.__targetEntities=e,this.__initialTargetAABB=void 0,this.__updated=!1,this._updateCount()}getTargets(){return this.__targetEntities}set doPreventDefault(e){this.__doPreventDefault=e}get doPreventDefault(){return this.__doPreventDefault}__mouseDown(e){this.__tryToPreventDefault(e),this.__isPressingCtrl||(this.__originalX=e.clientX,this.__originalY=e.clientY,this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y,this.__isMouseDown=!0,this.__lastMouseDownTimeStamp=e.timeStamp,this.__updated=!1,this._updateCount())}__mouseMove(e){if(this.__tryToPreventDefault(e),u.Is.false(this.isMouseDown))return;if(this.__isPressingCtrl)return;0===this.__buttonNumber&&(this.__buttonNumber=e.buttons);const t=e.clientX,n=e.clientY;switch(this.__buttonNumber){case 1:this.__isPressingShift?this.__parallelTranslateControl(this.__originalX,this.__originalY,t,n):(this.__rotateControl(this.__originalX,this.__originalY,t,n),this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y);break;case 2:this.__zoomControl(this.__originalX,t);break;case 4:this.__parallelTranslateControl(this.__originalX,this.__originalY,t,n);break;default:return}this.__originalX=t,this.__originalY=n,this.__updated=!1,this._updateCount()}__mouseUp(e){this.__buttonNumber=0,this.__originalX=-1,this.__originalY=-1,this.__isMouseDown=!1,this.__lastMouseUpTimeStamp=e.timeStamp,this.__updated=!1,this._updateCount()}__touchDown(e){this.__tryToPreventDefault(e),1===e.touches.length?(this.__originalX=e.touches[0].clientX,this.__originalY=e.touches[0].clientY,this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y):(this.__originalX=.5*(e.touches[0].clientX+e.touches[1].clientX),this.__originalY=.5*(e.touches[0].clientY+e.touches[1].clientY)),this.__isMouseDown=!0,this.__lastMouseDownTimeStamp=e.timeStamp,this.__updated=!1,this._updateCount()}__touchMove(e){if(this.__tryToPreventDefault(e),u.Is.false(this.isMouseDown))return;let t=e.touches[0].clientX,n=e.touches[0].clientY;1===e.touches.length?(t=e.touches[0].clientX,n=e.touches[0].clientY,this.__rotateControl(this.__originalX,this.__originalY,t,n),this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y):(t=.5*(e.touches[0].clientX+e.touches[1].clientX),n=.5*(e.touches[0].clientY+e.touches[1].clientY),this.__parallelTranslateControl(this.__originalX,this.__originalY,t,n)),this.__originalX=t,this.__originalY=n,this.__updated=!1,this._updateCount()}__touchUp(e){const t=e.touches.length;0===t?(this.__originalX=-1,this.__originalY=-1):1===t?(this.__originalX=e.touches[0].clientX,this.__originalY=e.touches[0].clientY,this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y):(this.__originalX=.5*(e.touches[0].clientX+e.touches[1].clientX),this.__originalY=.5*(e.touches[0].clientY+e.touches[1].clientY)),this.__isMouseDown=!1,this.__lastMouseUpTimeStamp=e.timeStamp,this.__updated=!1,this._updateCount()}set rotX(e){this.__rot_x=e,this.__updated=!1,this._updateCount()}get rotX(){return this.__rot_x}set rotY(e){this.__rot_y=e,this.__updated=!1,this._updateCount()}get rotY(){return this.__rot_y}set maximumY(e){this.__maximum_y=e}set minimumY(e){this.__minimum_y=e}__rotateControl(e,t,n,o){const a=(n-e)*this.__efficiency*.3,i=(o-t)*this.__efficiency*.3;this.__rot_x=this.__rot_bgn_x-a,this.__rot_y=this.__rot_bgn_y-i,null!=this.__maximum_y&&this.__rot_y>this.__maximum_y&&(this.__rot_y=this.__maximum_y),null!=this.__minimum_y&&this.__rot_y<this.__minimum_y&&(this.__rot_y=this.__minimum_y)}__zoomControl(e,t){this.dolly-=(t-e)/1e3*this.__efficiency}__parallelTranslateControl(e,t,n,o){this.__mouse_translate_y=(o-t)/1e3*this.__efficiency,this.__mouse_translate_x=(n-e)/1e3*this.__efficiency;const a=this.__lengthOfCenterToEye*this.__fovyBias*this.__scaleOfTranslation,i=h.__tmpVec3_0;i.copyComponents(this.__newUpVec).normalize().multiply(this.__mouse_translate_y).multiply(a);const r=h.__tmpVec3_1;r.copyComponents(this.__newTangentVec).normalize().multiply(this.__mouse_translate_x).multiply(a),this.__mouseTranslateVec.add(i).add(r)}__getTouchesDistance(e){const t=e.touches,n=t[1].clientX-t[0].clientX,o=t[1].clientY-t[0].clientY;return Math.hypot(n,o)}__pinchInOut(e){if(e.touches.length<2)return;if(null==this.__pinchInOutOriginalDistance)return void(this.__pinchInOutOriginalDistance=this.__getTouchesDistance(e));const t=this.__getTouchesDistance(e),n=this.__pinchInOutOriginalDistance;if(!this.__pinchInOutControl)return void(Math.abs(t-n)>35&&(this.__pinchInOutOriginalDistance=t,this.__pinchInOutControl=!0));const o=n/t;this.dolly*=Math.pow(o*this.__efficiency,2.2/15),this.__pinchInOutOriginalDistance=t,this.__updated=!1,this._updateCount()}__pinchInOutEnd(e){e.touches.length<2&&(this.__pinchInOutControl=!1,this.__pinchInOutOriginalDistance=null),this.__updated=!1,this._updateCount()}__tryToPreventDefault(e){this.__doPreventDefault&&e.preventDefault()}__mouseWheel(e){this.__tryToPreventDefault(e),this.dolly+=Math.sign(e.deltaY)/200,this.__updated=!1,this._updateCount()}__contextMenu(e){this.__tryToPreventDefault(e)}set dolly(e){e=Math.min(e,1),e=Math.max(e,1e-4);let t=Math.pow(e,5);t=Math.max(t,1e-4),this.__dolly=t}get dolly(){return Math.pow(this.__dolly,.2)}__mouseDblClick(e){e.shiftKey?this.__mouseTranslateVec.zero():e.ctrlKey&&(this.__rot_y=0,this.__rot_x=0,this.__rot_bgn_y=0,this.__rot_bgn_x=0)}__resetDollyAndPosition(e){if(e.touches.length>1)return;const t=(new Date).getTime();t-this.__resetDollyTouchTime<300?(this.dolly=Math.pow(.5,1/2.2),this.__mouseTranslateVec.zero(),this.__rot_x=0,this.__rot_y=0):this.__resetDollyTouchTime=t}__pressShift(e){!0===e.shiftKey&&(this.__isPressingShift=!0)}__releaseShift(e){!1===e.shiftKey&&(this.__isPressingShift=!1)}__pressCtrl(e){!0===e.ctrlKey&&(this.__isPressingCtrl=!0)}__releaseCtrl(e){!1===e.ctrlKey&&(this.__isPressingCtrl=!1)}registerEventListeners(){let e=window;u.Is.exist(d.T.eventTargetDom)&&(e=d.T.eventTargetDom),"ontouchend"in document?f.eN.register(f.o9,[{eventName:"touchstart",handler:this.__touchDownFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchmove",handler:this.__touchMoveFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchend",handler:this.__touchUpFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchmove",handler:this.__pinchInOutFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchend",handler:this.__pinchInOutEndFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchstart",handler:this.__resetDollyAndPositionFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"contextmenu",handler:this.__contextMenuFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"dblclick",handler:this.__mouseDblClickFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e}]):f.eN.register(f.o9,[{eventName:"mousedown",handler:this.__mouseDownFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"mouseup",handler:this.__mouseUpFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"mouseleave",handler:this.__mouseUpFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"mousemove",handler:this.__mouseMoveFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"keydown",handler:this.__pressShiftFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"keyup",handler:this.__releaseShiftFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"keydown",handler:this.__pressCtrlFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"keyup",handler:this.__releaseCtrlFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"contextmenu",handler:this.__contextMenuFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"wheel",handler:this.__mouseWheelFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"dblclick",handler:this.__mouseDblClickFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e}])}unregisterEventListeners(){f.eN.unregister(f.o9)}__getFovyFromCamera(e){return e.fovy?e.fovy:i.z.radianToDegree(2*Math.atan(Math.abs(e.top-e.bottom)/(2*e.zNear)))}logic(e){this.__updated&&!this.autoUpdate||(this.__updateTargeting(e),this.__calculateInfluenceOfController(),this.__updateCameraComponent(e),this.__updated=!0)}__getTargetAABB(e){return this.aabbWithSkeletal?e.tryToGetSceneGraph().worldMergedAABBWithSkeletal:e.tryToGetSceneGraph().worldMergedAABB}__updateTargeting(e){const t=e.eye,n=e._direction,o=e._up,r=this.__eyeVec,l=this.__centerVec,_=this.__upVec.copyComponents(o);if(0===this.__targetEntities.length)r.copyComponents(t),l.copyComponents(n);else{if(null==this.__initialTargetAABB){const e=new c.F;for(const t of this.__targetEntities)e.mergeAABB(this.__getTargetAABB(t));this.__initialTargetAABB=e.clone()}let o=this.__initialTargetAABB;if(this.followTargetAABB){const e=new c.F;for(const t of this.__targetEntities)e.mergeAABB(this.__getTargetAABB(t));o=e}l.copyComponents(o.centerPoint);const u=a.tp.subtractTo(t,n,r).normalize();let f=(this.useInitialTargetAABBForLength?this.__initialTargetAABB.lengthCenterToCorner:o.lengthCenterToCorner)*(1+1/Math.tan(i.z.degreeToRadian(e.fovy/2)))*this.scaleOfLengthCenterToCamera;Math.abs(f)<1e-5&&(f=1),u.multiply(f).add(l);const d=e.entity.tryToGetSceneGraph();if(null!=d){const e=s._.invertTo(d.matrixInner,h.__tmpMat44_0);e.multiplyVector3To(l,l),e.multiplyVector3To(r,r),e.multiplyVector3To(_,_)}}}__calculateInfluenceOfController(){const e=a.tp.subtractTo(this.__eyeVec,this.__centerVec,h.__tmpVec3_0);e.multiply(this.__dolly*this.dollyScale),this.__lengthOfCenterToEye=e.length();const t=this.__newUpVec,n=this.__newEyeVec,s=this.__newCenterVec,l=this.__newTangentVec;if(this.__isSymmetryMode){const c=h.__tmpVec3_1;c.setComponents(e.x,0,e.z);let _=o.Pq.angleOfVectors(c,h.__tmp_up);_*=Math.sign(c.cross(h.__tmp_up).y);const u=h.__tmp_rotateM_X,f=h.__tmp_rotateM_Y,d=h.__tmp_rotateM_Reset,m=h.__tmp_rotateM_Revert;u.rotateX(i.z.degreeToRadian(this.__rot_y)),f.rotateY(i.z.degreeToRadian(this.__rot_x)),d.rotateY(i.z.degreeToRadian(_)),m.rotateY(i.z.degreeToRadian(-_));const p=h.__tmp_rotateM;r._.multiplyTo(u,d,p),p.multiplyByLeft(f),p.multiplyByLeft(m),p.multiplyVectorTo(this.__upVec,t),p.multiplyVectorTo(e,n).add(this.__centerVec),s.copyComponents(this.__centerVec);const v=h.__tmpVec3_2;a.tp.subtractTo(s,n,v),a.tp.crossTo(t,v,l),n.add(this.__mouseTranslateVec),s.add(this.__mouseTranslateVec)}else{const o=h.__tmp_rotateM_X,c=h.__tmp_rotateM_Y;o.rotateX(i.z.degreeToRadian(this.__rot_y)),c.rotateY(i.z.degreeToRadian(this.__rot_x));const _=r._.multiplyTo(c,o,h.__tmp_rotateM);_.multiplyVectorTo(this.__upVec,t),_.multiplyVectorTo(e,n).add(this.__centerVec),s.copyComponents(this.__centerVec);const u=h.__tmpVec3_1;a.tp.subtractTo(s,n,u),a.tp.crossTo(t,u,l),n.add(this.__mouseTranslateVec),s.add(this.__mouseTranslateVec)}}__updateCameraComponent(e){const t=h.__tmpVec3_0.copyComponents(this.__newCenterVec);t.subtract(this.__newEyeVec).normalize(),this._calcZNearInner(e,this.__newEyeVec,t),this._calcZFarInner(e);const n=e.zFar/e.zNear/this.__scaleOfZNearAndZFar,o=e.left+n,a=e.right+n,r=e.top+n,s=e.bottom+n,l=this.__getFovyFromCamera(e);this.__fovyBias=Math.tan(i.z.degreeToRadian(l/2)),e.eyeInner=this.__newEyeVec,e.directionInner=this.__newCenterVec,e.upInner=this.__newUpVec,e.leftInner=o,e.rightInner=a,e.topInner=r,e.bottomInner=s,e.fovyInner=l}set scaleOfZNearAndZFar(e){this.__scaleOfZNearAndZFar=e,this.__updated=!1,this._updateCount()}get scaleOfZNearAndZFar(){return this.__scaleOfZNearAndZFar}get isMouseDown(){return this.__isMouseDown}get lastMouseDownTimeStamp(){return this.__lastMouseDownTimeStamp}get lastMouseUpTimeStamp(){return this.__lastMouseUpTimeStamp}}h.__tmp_up=o.Pq.fromCopyArray([0,0,1]),h.__tmpVec3_0=a.tp.zero(),h.__tmpVec3_1=a.tp.zero(),h.__tmpVec3_2=a.tp.zero(),h.__tmp_rotateM_X=r._.identity(),h.__tmp_rotateM_Y=r._.identity(),h.__tmp_rotateM=r._.identity(),h.__tmp_rotateM_Reset=r._.identity(),h.__tmp_rotateM_Revert=r._.identity(),h.__tmpMat44_0=l.g.identity()},4578:(e,t,n)=>{n.d(t,{k:()=>d});var o=n(3870),a=n(8805),i=n(5697),r=n(2162),s=n(7476),l=n(4930),c=n(6941),_=n(2229),u=n(4849),f=n(3629);class d extends l.i{constructor(e,t={eventTargetDom:document,verticalSpeed:1,horizontalSpeed:1,turnSpeed:.25,mouseWheelSpeedScale:1,inverseVerticalRotating:!1,inverseHorizontalRotating:!1}){super(),this.__updateCount=0,this._isKeyDown=!1,this._isMouseDrag=!1,this._lastKeyCode=-1,this._currentDir=i.tp.fromCopyArray([0,0,-1]),this._currentPos=i.tp.fromCopyArray([0,0,0]),this._currentCenter=i.tp.fromCopyArray([0,0,-1]),this._currentHorizontalDir=i.tp.fromCopyArray([0,0,-1]),this._newDir=i.tp.fromCopyArray([0,0,-1]),this._isMouseDown=!1,this._clickedMouseXOnCanvas=-1,this._clickedMouseYOnCanvas=-1,this._draggedMouseXOnCanvas=-1,this._draggedMouseYOnCanvas=-1,this._deltaMouseXOnCanvas=-1,this._deltaMouseYOnCanvas=-1,this._mouseXAdjustScale=1,this._mouseYAdjustScale=1,this._deltaY=-1,this._deltaX=-1,this._mouseUpBind=this._mouseUp.bind(this),this._mouseDownBind=this._mouseDown.bind(this),this._mouseMoveBind=this._mouseMove.bind(this),this._mouseWheelBind=this._mouseWheel.bind(this),this.__doPreventDefault=!1,this._needInitialize=!0,this.__targetEntities=[],this.aabbWithSkeletal=!0,this.__cameraControllerComponent=e,this._horizontalSpeed=t.horizontalSpeed,this._verticalSpeed=t.verticalSpeed,this._turnSpeed=t.turnSpeed,this._mouseXAdjustScale=this._turnSpeed,this._mouseYAdjustScale=this._turnSpeed,this._mouseWheelSpeedScale=t.mouseWheelSpeedScale,this._inverseVerticalRotating=t.inverseVerticalRotating,this._inverseHorizontalRotating=t.inverseHorizontalRotating,this.reset(),this._onKeydown=e=>{this._isKeyDown=!0,this._lastKeyCode=e.keyCode},this._onKeyup=e=>{this._isKeyDown=!1,this._lastKeyCode=-1};const n=t.eventTargetDom;this.registerEventListeners(n)}_updateCount(){this.__updateCount++,this.__cameraControllerComponent._updateCount(this.__updateCount)}get updateCount(){return this.__updateCount}registerEventListeners(e=document){this._eventTargetDom=e;const t=[{eventName:"keydown",handler:this._onKeydown,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"keyup",handler:this._onKeyup,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e}];"ontouchend"in document&&t.push({eventName:"touchstart",handler:this._mouseDownBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchend",handler:this._mouseUpBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"touchmove",handler:this._mouseMoveBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e}),"onmouseup"in document&&t.push({eventName:"mousedown",handler:this._mouseDownBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"mouseup",handler:this._mouseUpBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"mouseleave",handler:this._mouseUpBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e},{eventName:"mousemove",handler:this._mouseMoveBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e}),"onwheel"in document&&t.push({eventName:"wheel",handler:this._mouseWheelBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:e}),u.eN.register(u.o9,t)}unregisterEventListeners(){u.eN.unregister(u.o9)}__tryToPreventDefault(e){this.__doPreventDefault&&e.preventDefault()}_mouseWheel(e){if(null===this._currentDir)return;const t=-1*Math.sign(e.deltaY)*this._mouseWheelSpeedScale*this._horizontalSpeed,n=d.__tmp_Vec3_0;n.setComponents(this._currentDir.x,0,this._currentDir.z).normalize();const o=i.tp.multiplyTo(n,t,d.__tmp_Vec3_1);this._currentPos.add(o),this._currentCenter.add(o),this._updateCount()}_mouseDown(e){this.__tryToPreventDefault(e),this._isMouseDown=!0;const t=e.target.getBoundingClientRect();return this._clickedMouseXOnCanvas=e.clientX-t.left,this._clickedMouseYOnCanvas=e.clientY-t.top,this._updateCount(),!1}_mouseMove(e){if(this.__tryToPreventDefault(e),!this._isMouseDown)return;const t=e.target.getBoundingClientRect();this._draggedMouseXOnCanvas=e.clientX-t.left,this._draggedMouseYOnCanvas=e.clientY-t.top,this._deltaMouseXOnCanvas=this._draggedMouseXOnCanvas-this._clickedMouseXOnCanvas,this._deltaMouseYOnCanvas=this._draggedMouseYOnCanvas-this._clickedMouseYOnCanvas,this._isMouseDrag=!0,this._updateCount()}_mouseUp(e){this._isMouseDown=!1,this._isMouseDrag=!1;const t=e.target;if(null==(null==t?void 0:t.getBoundingClientRect))return;const n=t.getBoundingClientRect();this._clickedMouseXOnCanvas=e.clientX-n.left,this._clickedMouseYOnCanvas=e.clientY-n.top,this._updateCount()}tryReset(){}reset(){this._isKeyDown=!1,this._lastKeyCode=-1,this._currentPos.zero(),this._currentCenter.setComponents(0,0,-1),this._currentDir.setComponents(0,0,-1),this._currentHorizontalDir.setComponents(0,0,-1),this._isMouseDown=!1,this._isMouseDrag=!1,this._draggedMouseXOnCanvas=-1,this._draggedMouseYOnCanvas=-1,this._deltaMouseXOnCanvas=-1,this._deltaMouseYOnCanvas=-1,this._mouseXAdjustScale=this._turnSpeed,this._mouseYAdjustScale=this._turnSpeed,this._deltaY=0,this._deltaX=0,this._newDir.setComponents(0,0,-1)}logic(e){this.__updateCameraComponent(e)}__updateCameraComponent(e){const t=new f.F;for(const e of this.__targetEntities)t.mergeAABB(this.__getTargetAABB(e));const n=t;if(this._needInitialize&&null!=n){const t=n.lengthCenterToCorner*(1+1/Math.tan(c.z.degreeToRadian(e.fovy/2)));this._currentPos.copyComponents(n.centerPoint),this._currentPos.z+=t,this._currentCenter.copyComponents(n.centerPoint),this._currentDir.setComponents(0,0,-1);const a=e.entity.tryToGetSceneGraph();if(_.Is.exist(a)){const e=o._.invertTo(a.matrixInner,d.__tmpInvMat);e.multiplyVector3To(this._currentPos,this._currentPos),e.multiplyVector3To(this._currentCenter,this._currentCenter)}this._needInitialize=!1}const a=this._deltaY/90;this._newDir.x=this._currentDir.x*(1-a),this._newDir.y=a,this._newDir.z=this._currentDir.z*(1-a),this._newDir.normalize(),this._currentHorizontalDir.x=this._currentDir.x,this._currentHorizontalDir.y=0,this._currentHorizontalDir.z=this._currentDir.z,this._currentHorizontalDir.normalize();const r=d.__tmp_Vec3_0.zero();switch(this._lastKeyCode){case 87:case 38:r.x=this._currentHorizontalDir.x*this._horizontalSpeed,r.z=this._currentHorizontalDir.z*this._horizontalSpeed;break;case 65:case 37:r.x=this._currentHorizontalDir.z*this._horizontalSpeed,r.z=-this._currentHorizontalDir.x*this._horizontalSpeed;break;case 83:case 40:r.x=-this._currentHorizontalDir.x*this._horizontalSpeed,r.z=-this._currentHorizontalDir.z*this._horizontalSpeed;break;case 68:case 39:r.x=-this._currentHorizontalDir.z*this._horizontalSpeed,r.z=this._currentHorizontalDir.x*this._horizontalSpeed;break;case 81:r.x=-this._newDir.x*this._horizontalSpeed,r.y=-this._newDir.y*this._horizontalSpeed,r.z=-this._newDir.z*this._horizontalSpeed;break;case 69:r.x=this._newDir.x*this._horizontalSpeed,r.y=this._newDir.y*this._horizontalSpeed,r.z=this._newDir.z*this._horizontalSpeed;break;case 82:r.y=this._verticalSpeed;break;case 70:r.y=-this._verticalSpeed}if(this._currentPos.add(r),this._currentCenter.add(r),this._isMouseDrag){this._inverseHorizontalRotating?this._deltaX=this._deltaMouseXOnCanvas*this._mouseXAdjustScale:this._deltaX=-this._deltaMouseXOnCanvas*this._mouseXAdjustScale,this._inverseVerticalRotating?this._deltaY+=this._deltaMouseYOnCanvas*this._mouseYAdjustScale:this._deltaY+=-this._deltaMouseYOnCanvas*this._mouseYAdjustScale,this._deltaY=Math.max(-120,Math.min(50,this._deltaY));const e=d.__tmpRotateMat.rotateY(c.z.degreeToRadian(this._deltaX));e.multiplyVectorTo(this._currentDir,this._currentDir);const t=i.tp.subtractTo(this._currentCenter,this._currentPos,d.__tmp_Vec3_1);e.multiplyVectorTo(t,t),t.x=t.x*(1-a),t.y=a,t.z=t.z*(1-a),t.normalize(),this._currentCenter.copyComponents(this._currentPos),this._currentCenter.add(t),this._clickedMouseXOnCanvas=this._draggedMouseXOnCanvas,this._clickedMouseYOnCanvas=this._draggedMouseYOnCanvas,this._deltaMouseXOnCanvas=0,this._deltaMouseYOnCanvas=0}e.eyeInner=this._currentPos,e.directionInner=this._currentCenter,e.upInner=e._up,e.leftInner=e.left,e.rightInner=e.right,e.topInner=e.top,e.bottomInner=e.bottom,e.fovyInner=e.fovy,this._calcZNearInner(e,this._currentPos,this._newDir),this._calcZFarInner(e)}getDirection(){return null!==this._currentCenter?this._newDir.clone():null}set horizontalSpeed(e){this._horizontalSpeed=e}get horizontalSpeed(){return this._horizontalSpeed}set verticalSpeed(e){this._verticalSpeed=e}get verticalSpeed(){return this._verticalSpeed}set mouseWheelSpeed(e){this._mouseWheelSpeedScale=e}get mouseWheelSpeed(){return this._mouseWheelSpeedScale}setTarget(e){this.setTargets([e])}__getTargetAABB(e){return this.aabbWithSkeletal?e.tryToGetSceneGraph().worldMergedAABBWithSkeletal:e.tryToGetSceneGraph().worldMergedAABB}setTargets(e){const t=new f.F;for(const n of e)t.mergeAABB(this.__getTargetAABB(n));const n=t.lengthCenterToCorner/10;this.verticalSpeed=n,this.horizontalSpeed=n,this.__targetEntities=e,this._needInitialize=!0,this._updateCount()}getTargets(){return this.__targetEntities}get allInfo(){const e={};return e.verticalSpeed=this.verticalSpeed,e.horizontalSpeed=this.horizontalSpeed,e._turnSpeed=this._turnSpeed,this._currentPos&&(e._currentPos=this._currentPos.clone()),this._currentCenter&&(e._currentCenter=this._currentCenter.clone()),this._currentDir&&(e._currentDir=this._currentDir.clone()),e._deltaY=this._deltaY,e._newDir=this._newDir.clone(),e}set allInfo(e){let t=e;"string"==typeof e&&(t=JSON.parse(e));for(const e in t)t.hasOwnProperty(e)&&e in this&&(this[e]="quaternion"===e?a.n.cloneOfMathObjects(a.n.arrayToQuaternion(t[e])):a.n.cloneOfMathObjects(a.n.arrayToVectorOrMatrix(t[e])))}}d.__tmpInvMat=s.g.identity(),d.__tmpRotateMat=r._.identity(),d.__tmp_Vec3_0=i.tp.zero(),d.__tmp_Vec3_1=i.tp.zero()},7566:(e,t,n)=>{n.d(t,{C:()=>E});var o=n(8621),a=n(6737),i=n(7503),r=n(4289),s=n(375),l=n(7681),c=n(123),_=n(6603),u=n(975),f=n(2229),d=n(833),h=n(8454);function m(e,t,n){const o=n;return t.sampler.interpolationMethod===d.v.CubicSpline?4===t.sampler.outputComponentN?o[h.J6](3*t.sampler.outputComponentN*e+t.sampler.outputComponentN):3===t.sampler.outputComponentN?o[h.wQ](3*t.sampler.outputComponentN*e+t.sampler.outputComponentN):1===t.sampler.outputComponentN?o[h.uq](3*t.sampler.outputComponentN*e+t.sampler.outputComponentN):o[h.VH](3*t.sampler.outputComponentN*e+t.sampler.outputComponentN,t.sampler.outputComponentN):4===t.sampler.outputComponentN?o[h.R8](e):3===t.sampler.outputComponentN?o[h.sb](e):1===t.sampler.outputComponentN?o[h.k0](e):o[h.xZ](e,t.sampler.outputComponentN)}function p(e,t){let n=0,o=0,a=e.length-1,i=0;for(;o<=a&&t>=e[o]&&t<=e[a];)if(n=Math.floor(o+(t-e[o])*(a-o)/(e[a]-e[o])),e[n]<t)o=n+1,i=n;else{if(!(t<e[n]))return n;a=n-1,i=a}return i}function v(e,t,n){var o;const a=e.sampler.input,i=e.sampler.output,r=null!==(o=e.sampler.interpolationMethod)&&void 0!==o?o:d.v.Linear;if(t<=a[0])return m(0,e,i);if(a[a.length-1]<=t)return m(a.length-1,e,i);if(r===d.v.CubicSpline){const o=p(a,t),r=a[o+1]-a[o],l=(t-a[o])/r,{p_0:c,p_1:_,m_0:u,m_1:f}=function(e,t,n,o){const a=e;return 4===n?{p_0:a[h.J6](3*n*t+n),p_1:a[h.J6](3*n*(t+1)+n),m_0:a[h.gp](3*n*t+2*n,o),m_1:a[h.gp](3*n*(t+1),o)}:3===n?{p_0:a[h.wQ](3*n*t+n),p_1:a[h.wQ](3*n*(t+1)+n),m_0:a[h.P4](3*n*t+2*n,o),m_1:a[h.P4](3*n*(t+1),o)}:{p_0:a[h.VH](3*n*t+n,n),p_1:a[h.VH](3*n*(t+1)+n,n),m_0:a[h.G9](3*n*t+2*n,n,o),m_1:a[h.G9](3*n*(t+1),n,o)}}(i,o,e.sampler.outputComponentN,r),d=function(e,t,n,o,a){const i=new Array(e.length);for(let r=0;r<e.length;r++)i[r]=(2*a**3-3*a**2+1)*e[r]+(a**3-2*a**2+a)*n[r]+(-2*a**3+3*a**2)*t[r]+(a**3-a**2)*o[r];return i}(c,_,u,f,l);return n===s.R.Quaternion.index&&d[h.Nj](),d}if(r===d.v.Linear){const o=p(a,t),r=function(e,t,n,o,a){const i=e;return n===s.R.Quaternion.index?i[h.z9](i,t,o,o+1):n===s.R.Weights.index?i[h.UL](i,a,t,o,o+1):i[h.z$](i,t,o,o+1)}(i,(t-a[o])/(a[o+1]-a[o]),n,o,e.sampler.outputComponentN);return r}if(r===d.v.Step){for(let n=0;n<a.length-1;n++)if(a[n]<=t&&t<a[n+1])return m(n,e,i);return m(a.length-1,e,i)}return[]}var x=n(2766),g=n(6253),y=n(5697),b=n(6941);const I=Symbol("AnimationComponentEventChangeAnimationInfo"),A=Symbol("AnimationComponentEventPlayEnd");class E extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.animationBlendingRatio=0,this.__animationTracks=new Map,this.__isEffekseerState=-1,this.__isAnimating=!0,this.isLoop=!0,this.useGlobalTime=!0,this.time=0}$load(){this.moveStageTo(x.Ow.Logic)}$logic(){E.isAnimating&&this.isAnimating&&this.__applyAnimation()}__applyAnimation(){let e=this.time;this.useGlobalTime&&(e=E.globalTime);const t=this.entity.getTransform(),n=this.entity.tryToGetBlendShape(),o=this.entity.tryToGetEffekseer();if(f.Is.exist(this.__firstActiveAnimationTrackName)&&this.animationBlendingRatio<1){this.isLoop&&(e%=E.__animationGlobalInfo.get(this.__firstActiveAnimationTrackName).maxEndInputTime);const a=this.__animationTracks.get(this.__firstActiveAnimationTrackName);if(void 0!==a)for(const[i,r]of a){const a=s.R.fromString(i).index,l=v(r,e,a);a===s.R.Quaternion.index?t.setLocalRotationAsArray4(l):a===s.R.Translate.index?t.setLocalPositionAsArray3(l):a===s.R.Scale.index?t.setLocalScaleAsArray3(l):a===s.R.Weights.index?n.weights=l:a===s.R.Effekseer.index&&(l[0]>.5?0===this.__isEffekseerState&&(null==o||o.play()):1===this.__isEffekseerState&&(null==o||o.pause()),this.__isEffekseerState=l[0])}}if(f.Is.exist(this.__secondActiveAnimationTrackName)&&this.animationBlendingRatio>0){this.isLoop&&(e%=E.__animationGlobalInfo.get(this.__secondActiveAnimationTrackName).maxEndInputTime);const o=this.__animationTracks.get(this.__secondActiveAnimationTrackName);if(void 0!==o)for(const[a,i]of o){const o=s.R.fromString(a).index,r=v(i,e,o);if(o===s.R.Quaternion.index)E.__tmpQuat._v[0]=r[0],E.__tmpQuat._v[1]=r[1],E.__tmpQuat._v[2]=r[2],E.__tmpQuat._v[3]=r[3],t.localRotation=_.P.qlerp(t.localRotationInner,E.__tmpQuat,this.animationBlendingRatio);else if(o===s.R.Translate.index)E.__tmpPos._v[0]=r[0],E.__tmpPos._v[1]=r[1],E.__tmpPos._v[2]=r[2],t.localPosition=u.Pq.lerp(t.localPositionInner,E.__tmpPos,this.animationBlendingRatio);else if(o===s.R.Scale.index)E.__tmpScale._v[0]=r[0],E.__tmpScale._v[1]=r[1],E.__tmpScale._v[2]=r[2],t.localScale=u.Pq.lerp(t.localScaleInner,E.__tmpScale,this.animationBlendingRatio);else if(o===s.R.Weights.index){const e=r;for(let t=0;t<e.length;t++)n.weights[t]=b.z.lerp(n.weights[t],e[t],this.animationBlendingRatio)}else s.R.Effekseer.index}}}static subscribe(e,t){E.__pubsub.subscribe(e,t)}setIsAnimating(e){this.__isAnimating=e}static setActiveAnimationForAll(e){const t=a.O.getComponentsWithType(E);for(const n of t)n.setActiveAnimationTrack(e)}setActiveAnimationTrack(e){return!!this.__animationTracks.has(e)&&(this.__firstActiveAnimationTrackName=e,!0)}setSecondActiveAnimationTrack(e){return!!this.__animationTracks.has(e)&&(this.__secondActiveAnimationTrackName=e,!0)}getActiveAnimationTrack(){return this.__firstActiveAnimationTrackName}hasAnimation(e,t){const n=this.__animationTracks.get(e);return!f.Is.not.exist(n)&&n.has(t)}setAnimation(e,t,n,o,a,i,r=!0){this.__firstActiveAnimationTrackName=r?e:(0,l.pJ)({value:this.__firstActiveAnimationTrackName,defaultValue:e});const s=(0,l.Cw)({value:this.__animationTracks.get(e),compensation:()=>{const t=new Map;return this.__animationTracks.set(e,t),t}}),c={sampler:{input:n,output:o,outputComponentN:a,interpolationMethod:i},target:{pathName:t,entity:this.entity},belongTrackName:e};s.set(t,c);const _=n[0],u=n[n.length-1],f={name:e,minStartInputTime:_,maxEndInputTime:u};E.__animationGlobalInfo.set(e,f),E.__pubsub.publishAsync(E.Event.ChangeAnimationInfo,{infoMap:new Map(E.__animationGlobalInfo)}),this.entity.getTransform()._backupTransformAsRest()}getStartInputValueOfAnimation(e){let t=Number.MAX_VALUE;const n=this.__animationTracks.get(e);return f.Is.not.exist(n)?-1:(n.forEach((e=>{const n=e.sampler.input[0];n<t&&(t=n)})),t)}getEndInputValueOfAnimation(e){const t=this.__animationTracks.get(e);if(f.Is.not.exist(t))return-1;let n=0;return t.forEach((e=>{const t=e.sampler.input[e.sampler.input.length-1];n<t&&(n=t)})),n}static getAnimationList(){return Array.from(this.__animationGlobalInfo.keys())}static getAnimationInfo(){return new Map(this.__animationGlobalInfo)}getAnimationTrackNames(){return Array.from(this.__animationTracks.keys())}getAnimationChannelsOfTrack(e){return this.__animationTracks.get(e)}get isAnimating(){return this.__isAnimating}static get startInputValue(){if(0===a.O.getComponentsWithType(E).length)return 0;{const e=Array.from(this.__animationGlobalInfo.values());return e[e.length-1].minStartInputTime}}static get endInputValue(){if(0===a.O.getComponentsWithType(E).length)return 0;{const e=Array.from(this.__animationGlobalInfo.values());return e[e.length-1].maxEndInputTime}}static get componentTID(){return r.N.AnimationComponentTID}get componentTID(){return r.N.AnimationComponentTID}get entity(){return i.YY.getEntity(this.__entityUid)}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getAnimation(){return this.getComponentByComponentTID(r.N.AnimationComponentTID)}}return(0,i.XJ)(e,n),e}addKeyFrame(e,t,n,o){const a=n/o,i=a,r=(n+1)/o,l=this.__animationTracks.get(e);if(f.Is.not.exist(l))return!1;const c=l.get(t);if(f.Is.not.exist(c))return!1;const _=s.R.fromString(t).index,u=v(c,E.globalTime,_);if(0===c.sampler.input.length){const e=Array.from(c.sampler.input);e.push(i),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.push(...u),c.sampler.output=new Float32Array(t)}else if(1===c.sampler.input.length){const e=c.sampler.input[0];if(r<e){const e=Array.from(c.sampler.input);e.unshift(i),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.unshift(...u),c.sampler.output=new Float32Array(t)}else if(e<a){const e=Array.from(c.sampler.input);e.push(i),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.push(...u),c.sampler.output=new Float32Array(t)}else{const e=Array.from(c.sampler.input);e.splice(0,0,i),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.splice(0,0,...u),c.sampler.output=new Float32Array(t)}}else for(let e=0;e<c.sampler.input.length;e++){const t=c.sampler.input[e];if(a<=t){if(a<=t&&t<=r){c.sampler.input[e]=i;for(let t=0;t<c.sampler.outputComponentN;t++)c.sampler.output[e*c.sampler.outputComponentN+t]=u[t]}else{const t=Array.from(c.sampler.input);t.splice(e,0,i),c.sampler.input=new Float32Array(t);const n=Array.from(c.sampler.output);n.splice(e*c.sampler.outputComponentN,0,...u),c.sampler.output=new Float32Array(n)}break}}return!0}addKeyFrameWithValue(e,t,n,o,a){const i=n/a,r=i,s=(n+1)/a,l=this.__animationTracks.get(e);if(f.Is.not.exist(l))return!1;const c=l.get(t);if(f.Is.not.exist(c))return!1;if(0===c.sampler.input.length){const e=Array.from(c.sampler.input);e.push(r),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.push(...o),c.sampler.output=new Float32Array(t)}else if(1===c.sampler.input.length){const e=c.sampler.input[0];if(s<e){const e=Array.from(c.sampler.input);e.unshift(r),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.unshift(...o),c.sampler.output=new Float32Array(t)}else if(e<i){const e=Array.from(c.sampler.input);e.push(r),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.push(...o),c.sampler.output=new Float32Array(t)}else{const e=Array.from(c.sampler.input);e.splice(0,0,r),c.sampler.input=new Float32Array(e);const t=Array.from(c.sampler.output);t.splice(0,0,...o),c.sampler.output=new Float32Array(t)}}else for(let e=0;e<c.sampler.input.length;e++){const t=c.sampler.input[e];if(i<=t){if(i<=t&&t<=s){c.sampler.input[e]=r;for(let t=0;t<c.sampler.outputComponentN;t++)c.sampler.output[e*c.sampler.outputComponentN+t]=o[t]}else{const t=Array.from(c.sampler.input);t.splice(e,0,r),c.sampler.input=new Float32Array(t);const n=Array.from(c.sampler.output);n.splice(e*c.sampler.outputComponentN,0,...o),c.sampler.output=new Float32Array(n)}break}}return!0}deleteKeysAtFrame(e,t,n,o){const a=n/o,i=(n+1)/o,r=this.__animationTracks.get(e);if(f.Is.not.exist(r))return!1;const s=r.get(t);if(f.Is.not.exist(s))return!1;for(let e=0;e<s.sampler.input.length;e++){const t=s.sampler.input[e];if(a<=t&&t<i){const t=Array.from(s.sampler.input);t.splice(e,1),s.sampler.input=new Float32Array(t);const n=Array.from(s.sampler.output);n.splice(e*s.sampler.outputComponentN,s.sampler.outputComponentN),s.sampler.output=new Float32Array(n)}}return!0}hasKeyFramesAtFrame(e,t,n,o){const a=n/o,i=(n+1)/o,r=this.__animationTracks.get(e);if(f.Is.not.exist(r))return!1;const s=r.get(t);if(f.Is.not.exist(s))return!1;for(let e=0;e<s.sampler.input.length;e++){const t=s.sampler.input[e];if(a<=t&&t<i)return!0}return!1}static setIsAnimating(e){this.isAnimating=e}_shallowCopyFrom(e){const t=e;this.__firstActiveAnimationTrackName=t.__firstActiveAnimationTrackName,this.__animationTracks=new Map(t.__animationTracks),this.__isEffekseerState=t.__isEffekseerState,this.__isAnimating=t.__isAnimating}_setRetarget(e,t){const n=e.getEntity().tryToGetAnimation(),o=this.entity;if(this.entity.getTransform()._backupTransformAsRest(),f.Is.not.exist(n))return[];n.useGlobalTime=!1;const a=[];for(const[e,o]of n.__animationTracks){const l=e+(null!=t?t:"");a.push(l);for(const[e,t]of o){if(null==t)continue;const o=t.sampler.input;if("translate"===t.target.pathName){const a=i(o,n);this.setAnimation(l,e,o,a,3,t.sampler.interpolationMethod,!1)}if("quaternion"===t.target.pathName){const a=r(o,n);this.setAnimation(l,e,o,a,4,t.sampler.interpolationMethod,!1)}if("scale"===t.target.pathName){const a=s(o,n);this.setAnimation(l,e,o,a,3,t.sampler.interpolationMethod,!1)}}}function i(t,n){const a=new Float32Array(3*t.length);for(let i=0;i<t.length;i++){n.time=t[i],n.__applyAnimation();const r=e.retargetTranslate(o);a[3*i+0]=r.x,a[3*i+1]=r.y,a[3*i+2]=r.z}return a}function r(t,n){const a=new Float32Array(4*t.length);for(let i=0;i<t.length;i++){n.time=t[i],n.__applyAnimation();const r=e.retargetQuaternion(o);a[4*i+0]=r.x,a[4*i+1]=r.y,a[4*i+2]=r.z,a[4*i+3]=r.w}return a}function s(t,n){const a=new Float32Array(3*t.length);for(let i=0;i<t.length;i++){n.time=t[i],n.__applyAnimation();const r=e.retargetScale(o);a[3*i+0]=r.x,a[3*i+1]=r.y,a[3*i+2]=r.z}return a}return a}resetAnimationTracks(){this.__animationTracks.clear()}resetAnimationTrack(e){this.__animationTracks.delete(e)}resetAnimationTrackByPostfix(e){const t=this.getAnimationTrackNames();for(const n of t)n.endsWith(e)&&this.__animationTracks.delete(n)}_destroy(){super._destroy(),this.__animationTracks.clear(),this.__isAnimating=!1}}E.__animationGlobalInfo=new Map,E.isAnimating=!0,E.globalTime=0,E.Event={ChangeAnimationInfo:I,PlayEnd:A},E.__tmpQuat=g.h.identity(),E.__tmpPos=y.tp.zero(),E.__tmpScale=y.tp.one(),E.__pubsub=new c.s},103:(e,t,n)=>{n.d(t,{v:()=>s});var o=n(8621),a=n(7503),i=n(5368),r=n(4289);class s extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__activeAnimationTrack="",this.__interpolationStartTime=performance.now(),this.__blendingDuration=1,this.__isBlending=!1,this.__blendingRatio=0,this.moveStageTo(i.O.Logic)}static get componentTID(){return r.N.AnimationStateComponentTID}get componentTID(){return r.N.AnimationStateComponentTID}get isBlending(){return this.__isBlending}get blendingRatio(){return this.__blendingRatio}$logic(){if(!this.__isBlending)return;const e=(performance.now()-this.__interpolationStartTime)/1e3/this.__blendingDuration;e>=1&&(this.__isBlending=!1);const t=Math.min(e,1);this.setAnimationBlendingRatio(t),this.__blendingRatio=t}setFirstActiveAnimationTrack(e){this.__activeAnimationTrack=e,this.setActiveAnimationTrack(e),this.setAnimationBlendingRatio(0),this.__isBlending=!1}forceTransitionTo(e,t){const n=this.__activeAnimationTrack;this.setActiveAnimationTrack(n),this.setSecondActiveAnimationTrack(e),this.__interpolationStartTime=performance.now(),this.__blendingDuration=t,this.__activeAnimationTrack=e,this.__isBlending=!0}setActiveAnimationTrack(e){!function t(n){const o=n.tryToGetAnimation();null!=o&&o.setActiveAnimationTrack(e);for(const e of n.children)t(e.entity)}(this.entity)}setSecondActiveAnimationTrack(e){!function t(n){const o=n.tryToGetAnimation();null!=o&&o.setSecondActiveAnimationTrack(e);for(const e of n.children)t(e.entity)}(this.entity)}setUseGlobalTime(e){!function t(n){const o=n.tryToGetAnimation();null!=o&&(o.useGlobalTime=e);for(const e of n.children)t(e.entity)}(this.entity)}setIsLoop(e){!function t(n){const o=n.tryToGetAnimation();null!=o&&(o.isLoop=e);for(const e of n.children)t(e.entity)}(this.entity)}setTime(e){!function t(n){const o=n.tryToGetAnimation();null!=o&&(o.time=e);for(const e of n.children)t(e.entity)}(this.entity)}setAnimationBlendingRatio(e){!function t(n){const o=n.tryToGetAnimation();null!=o&&(o.animationBlendingRatio=e);for(const e of n.children)t(e.entity)}(this.entity)}_destroy(){super._destroy()}get entity(){return a.YY.getEntity(this.__entityUid)}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getAnimationState(){return this.getComponentByComponentTID(r.N.AnimationStateComponentTID)}}return(0,a.XJ)(e,n),e}}},7193:(e,t,n)=>{n.d(t,{W:()=>s});var o=n(8621),a=n(7503),i=n(4289),r=n(5368);class s extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__weights=[],this.__targetNames=[],this.moveStageTo(r.O.Logic)}static get updateCount(){return this.__updateCount}static get componentTID(){return i.N.BlendShapeComponentTID}get componentTID(){return i.N.BlendShapeComponentTID}set weights(e){this.__weights=e,s.__updateCount++}get weights(){return this.__weights}set targetNames(e){this.__targetNames=e,s.__updateCount++}get targetNames(){return this.__targetNames}setWeightByIndex(e,t){this.__weights[e]=t,s.__updateCount++}$logic(){}_destroy(){super._destroy()}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getBlendShape(){return this.getComponentByComponentTID(i.N.BlendShapeComponentTID)}}return(0,a.XJ)(e,n),e}}s.__updateCount=0},7295:(e,t,n)=>{n.d(t,{n:()=>C});var o=n(6737),a=n(8621),i=n(7503),r=n(4289),s=n(975),l=n(3414),c=n(5250),_=n(3870),u=n(7616),f=n(4114),d=n(7476),h=n(5368),m=n(8924),p=n(5697),v=n(4343),x=n(5338),g=n(3107),y=n(6941),b=n(3583),I=n(2229),A=n(9201),E=n(7670),S=n(3212),T=n(1823),w=n(4415);class C extends a.u{constructor(e,t,n,o){if(super(e,t,n,o),this._eyeInner=p.tp.dummy(),this._direction=p.tp.dummy(),this._directionInner=p.tp.dummy(),this._up=p.tp.dummy(),this._upInner=p.tp.dummy(),this._filmWidth=36,this._filmHeight=24,this._focalLength=20,this.primitiveMode=!1,this._corner=m.Am.dummy(),this._cornerInner=m.Am.dummy(),this._parameters=m.Am.dummy(),this._parametersInner=m.Am.dummy(),this.__type=c.A.Perspective,this._projectionMatrix=d.g.dummy(),this.__isProjectionMatrixUpToDate=!1,this._viewMatrix=d.g.dummy(),this.__isViewMatrixUpToDate=!1,this._xrLeft=!1,this._xrRight=!1,this.isSyncToLight=!1,this.__frustum=new v.P,this.__updateCount=0,this.__lastUpdateCount=-1,this.__lastTransformComponentsUpdateCount=-1,this.__lastLightComponentsUpdateCount=-1,this.__lastCameraControllerComponentsUpdateCount=-1,this._setMaxNumberOfComponent(Math.max(10,Math.floor(x.T.maxEntityNumber/100))),this.setFovyAndChangeFocalLength(90),-1===C.current&&(C.current=t),this.registerMember(u.a.CPUGeneric,"eyeInner",p.tp,f.I.Float,[0,0,0]),this.registerMember(u.a.CPUGeneric,"direction",p.tp,f.I.Float,[0,0,-1]),this.registerMember(u.a.CPUGeneric,"up",p.tp,f.I.Float,[0,1,0]),this.registerMember(u.a.CPUGeneric,"directionInner",p.tp,f.I.Float,[0,0,-1]),this.registerMember(u.a.CPUGeneric,"upInner",p.tp,f.I.Float,[0,1,0]),this.registerMember(u.a.CPUGeneric,"corner",m.Am,f.I.Float,[-1,1,1,-1]),this.registerMember(u.a.CPUGeneric,"cornerInner",m.Am,f.I.Float,[-1,1,1,-1]),this.registerMember(u.a.CPUGeneric,"parameters",m.Am,f.I.Float,[.1,1e4,90,1]),this.registerMember(u.a.CPUGeneric,"parametersInner",m.Am,f.I.Float,[.1,1e4,90,1]),this.registerMember(u.a.CPUGeneric,"projectionMatrix",d.g,f.I.Float,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.registerMember(u.a.CPUGeneric,"viewMatrix",d.g,f.I.Float,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.submitToAllocation(x.T.maxCameraNumber,o),o)return;const a=g.q.getInstance();a.takeOne("viewMatrix"),a.takeOne("projectionMatrix"),a.takeOne("viewPosition")}static set current(e){this.__current=e}static get current(){return this.__current}get updateCount(){return this.__updateCount}static get currentCameraUpdateCount(){var e;const t=o.O.getComponent(C,C.current);return null!==(e=null==t?void 0:t.updateCount)&&void 0!==e?e:0}set type(e){this.__type=e,e===c.A.Orthographic?(this._parameters.z=1,this._parameters.w=1,this._parametersInner.z=1,this._parametersInner.w=1):(this.setFovyAndChangeFocalLength(90),this._parameters.w=1,this._parametersInner.z=90,this._parametersInner.w=1),this.__updateCount++}get type(){return this.__type}get eye(){return C._eye}set eye(e){throw Error("In Rhodonite, eye is always (0,0,0). Use TransformComponent for Camera positioning.")}get eyeInner(){return this._eyeInner}set eyeInner(e){this._eyeInner.copyComponents(e),this.__updateCount++}set upInner(e){this._upInner.copyComponents(e),this.__updateCount++}set up(e){this._up.copyComponents(e),this.__updateCount++}get up(){return this._up.clone()}get upInner(){return this._upInner}set direction(e){const t=this._direction,n=e,o=this._up;let a;if(0===p.tp.crossTo(n,o,C.__tmpVector3_0).length()){const e=p.tp.crossTo(t,o,C.__tmpVector3_1);a=p.tp.crossTo(e,n,C.__tmpVector3_2)}else{const e=p.tp.multiplyTo(n,n.dot(o),C.__tmpVector3_1);a=p.tp.subtractTo(o,e,C.__tmpVector3_2)}this._up.copyComponents(a).normalize(),this._direction.copyComponents(n),this.__updateCount++}set directionInner(e){this._directionInner.copyComponents(e),this.__updateCount++}get direction(){return this._direction.clone()}get directionInner(){return this._directionInner}set corner(e){this._corner.copyComponents(e),this.__updateCount++}get corner(){return this._corner.clone()}set left(e){this._corner.x=e,this.__updateCount++}set leftInner(e){this._cornerInner.x=e,this.__updateCount++}get left(){return this._corner.x}set right(e){this._corner.y=e,this.__updateCount++}set rightInner(e){this._cornerInner.y=e,this.__updateCount++}get right(){return this._corner.y}set top(e){this._corner.z=e,this.__updateCount++}set topInner(e){this._cornerInner.z=e,this.__updateCount++}get top(){return this._corner.z}set bottom(e){this._corner.w=e,this.__updateCount++}set bottomInner(e){this._cornerInner.w=e,this.__updateCount++}get bottom(){return this._corner.w}set cornerInner(e){this._cornerInner.copyComponents(e),this.__updateCount++}get cornerInner(){return this._cornerInner}set parametersInner(e){this._parametersInner.copyComponents(e),this.__updateCount++}get parametersInner(){return this._parametersInner}get parameters(){return this._parameters.clone()}set zNear(e){this._parameters.x=e,this.__updateCount++}set zNearInner(e){this._parametersInner.x=e,this.__updateCount++}get zNearInner(){return this._parametersInner.x}get zNear(){return this._parameters.x}set focalLength(e){this._focalLength=e,this._parameters.z=2*y.z.radianToDegree(Math.atan(this._filmHeight/(2*e))),this.__updateCount++}get focalLength(){return this._focalLength}set focalLengthInner(e){this._parametersInner.z=2*y.z.radianToDegree(Math.atan(this._filmHeight/(2*e))),this.__updateCount++}get focalLengthInner(){return this._parametersInner.z}set zFar(e){this._parameters.y=e,this.__updateCount++}set zFarInner(e){this._parametersInner.y=e,this.__updateCount++}get zFarInner(){return this._parametersInner.y}get zFar(){return this._parameters.y}setFovyAndChangeFilmSize(e){this._parameters.z=e,this._filmHeight=2*this.focalLength*Math.tan(y.z.degreeToRadian(e)/2),this._filmWidth=this._filmHeight*this.aspect,this.__updateCount++}setFovyAndChangeFocalLength(e){this._parameters.z=e,this._focalLength=this._filmHeight/2/Math.tan(y.z.degreeToRadian(e)/2),this.__updateCount++}get fovy(){return this._parameters.z}set fovyInner(e){this._parametersInner.z=e,this.__updateCount++}set aspect(e){this._parameters.w=e,this._filmWidth=this._filmHeight*e,this.__updateCount++}set aspectInner(e){this._parametersInner.w=e,this.__updateCount++}get aspectInner(){return this._parametersInner.w}get aspect(){return this._parameters.w}set xMag(e){this._parameters.z=e,this.__updateCount++}get xMag(){return this._parameters.z}set yMag(e){this._parameters.w=e}get yMag(){return this._parameters.w}static get componentTID(){return r.N.CameraComponentTID}get componentTID(){return r.N.CameraComponentTID}calcProjectionMatrix(){const e=this._parametersInner.x,t=this._parametersInner.y;if(E.l.currentProcessApproach===S.m.WebGPU)if(this.type===c.A.Perspective){const n=this._parametersInner.z;let o=this._parametersInner.w;o<0&&(o=E.l.viewportAspectRatio);const a=1/Math.tan(.5*n*Math.PI/180),i=a/o;if(this._projectionMatrix.m00=i,this._projectionMatrix.m01=0,this._projectionMatrix.m02=0,this._projectionMatrix.m03=0,this._projectionMatrix.m10=0,this._projectionMatrix.m11=a,this._projectionMatrix.m12=0,this._projectionMatrix.m13=0,this._projectionMatrix.m20=0,this._projectionMatrix.m21=0,t===1/0)this._projectionMatrix.m22=-1,this._projectionMatrix.m23=-e;else{const n=1/(e-t);this._projectionMatrix.m22=t*n,this._projectionMatrix.m23=t*e*n}this._projectionMatrix.m30=0,this._projectionMatrix.m31=0,this._projectionMatrix.m32=-1,this._projectionMatrix.m33=0}else if(this.type===c.A.Orthographic){const n=this._parametersInner.z,o=this._parametersInner.w;this._projectionMatrix.setComponents(1/n,0,0,0,0,1/o,0,0,0,0,-1/(t-e),-e/(t-e),0,0,0,1)}else{const n=this._cornerInner.x,o=this._cornerInner.y,a=this._cornerInner.z,i=this._cornerInner.w,r=1/(e-t);this._projectionMatrix.setComponents(2*e/(o-n),0,(o+n)/(o-n),0,0,2*e/(a-i),(a+i)/(a-i),0,0,0,t*r,t*e*r,0,0,-1,0)}else if(this.type===c.A.Perspective){const n=this._parametersInner.z;let o=this._parametersInner.w;o<0&&(o=E.l.viewportAspectRatio);const a=1/Math.tan(.5*n*Math.PI/180),i=a/o;if(this._projectionMatrix.m00=i,this._projectionMatrix.m01=0,this._projectionMatrix.m02=0,this._projectionMatrix.m03=0,this._projectionMatrix.m10=0,this._projectionMatrix.m11=a,this._projectionMatrix.m12=0,this._projectionMatrix.m13=0,this._projectionMatrix.m20=0,this._projectionMatrix.m21=0,t===1/0)this._projectionMatrix.m22=-1,this._projectionMatrix.m23=-2*e;else{const n=1/(e-t);this._projectionMatrix.m22=(t+e)*n,this._projectionMatrix.m23=2*t*e*n}this._projectionMatrix.m30=0,this._projectionMatrix.m31=0,this._projectionMatrix.m32=-1,this._projectionMatrix.m33=0}else if(this.type===c.A.Orthographic){const n=this._parametersInner.z,o=this._parametersInner.w;this._projectionMatrix.setComponents(1/n,0,0,0,0,1/o,0,0,0,0,-2/(t-e),-(t+e)/(t-e),0,0,0,1)}else{const n=this._cornerInner.x,o=this._cornerInner.y,a=this._cornerInner.z,i=this._cornerInner.w,r=1/(e-t);this._projectionMatrix.setComponents(2*e/(o-n),0,(o+n)/(o-n),0,0,2*e/(a-i),(a+i)/(a-i),0,0,0,(t+e)*r,2*t*e*r,0,0,-1,0)}return this._projectionMatrix}calcViewMatrix(){const e=this.eyeInner,t=p.tp.subtractTo(this._directionInner,e,C.__tmpVector3_0).normalize(),n=p.tp.crossTo(t,this._upInner,C.__tmpVector3_1).normalize(),o=p.tp.crossTo(n,t,C.__tmpVector3_2);if(this._viewMatrix.setComponents(n.x,n.y,n.z,-s.Pq.dot(n,e),o.x,o.y,o.z,-s.Pq.dot(o,e),-t.x,-t.y,-t.z,s.Pq.dot(t,e),0,0,0,1),!this.primitiveMode){const e=d.g.invertTo(this.entity.getSceneGraph().matrixInner,C.__tmpMatrix44_0);this._viewMatrix.multiply(e)}return this._viewMatrix}get viewMatrix(){return this._viewMatrix}set viewMatrix(e){this._viewMatrix.copyComponents(e),this.__updateCount++}get projectionMatrix(){if(this._xrLeft||this._xrRight){const e=b.e.getInstance().getModule("xr");if(null==e?void 0:e.WebXRSystem.getInstance().isWebXRMode){const t=e.WebXRSystem.getInstance();if(this._xrLeft)return t.leftProjectionMatrix;if(this._xrRight)return t.rightProjectionMatrix}}return this._projectionMatrix}set projectionMatrix(e){this._projectionMatrix.copyComponents(e),this.__updateCount++}get viewProjectionMatrix(){return d.g.multiplyTo(this._projectionMatrix,this._viewMatrix,C.__tmpMatrix44_0)}get biasViewProjectionMatrix(){return d.g.multiplyTo(this._projectionMatrix,this._viewMatrix,C.__tmpMatrix44_0),d.g.multiplyTo(C.__biasMatrix,C.__tmpMatrix44_0,C.__tmpMatrix44_1)}setValuesToGlobalDataRepositoryOnlyMatrices(){C.__globalDataRepository.setValue("viewMatrix",this.componentSID,this.viewMatrix),C.__globalDataRepository.setValue("projectionMatrix",this.componentSID,this.projectionMatrix)}setValuesToGlobalDataRepository(){C.__globalDataRepository.setValue("viewMatrix",this.componentSID,this.viewMatrix),C.__globalDataRepository.setValue("projectionMatrix",this.componentSID,this.projectionMatrix),C.__globalDataRepository.setValue("viewPosition",this.componentSID,this.worldPosition)}get worldPosition(){return this.entity.getSceneGraph().matrixInner.multiplyVector3To(this.eyeInner,C.returnVector3),C.returnVector3}updateFrustum(){this.__frustum.update(this.viewMatrix,this.projectionMatrix)}get frustum(){return this.__frustum}$load(){this.moveStageTo(h.O.Logic)}$logic(){const e=this.entity.tryToGetLight();let t=null!=e?e.updateCount:-1;if(this.__lastUpdateCount!==this.__updateCount||this.__lastTransformComponentsUpdateCount!==T.W.updateCount||this.__lastLightComponentsUpdateCount!==t||this.__lastCameraControllerComponentsUpdateCount!==w.v.updateCount){if(this.isSyncToLight&&I.Is.exist(e)){if(this._eyeInner.copyComponents(C._eye),this._directionInner.copyComponents(this._direction),this._upInner.copyComponents(this._up),e.type===A.z.Spot)this.type=c.A.Perspective,this.setFovyAndChangeFilmSize(y.z.radianToDegree(e.outerConeAngle)),this._cornerInner.copyComponents(this._corner),this.aspect=1,this.zNear=.1,this.zFar=-1!==e.range?e.range:1e4,this._parametersInner.copyComponents(this._parameters);else if(e.type===A.z.Directional){this.type=c.A.Orthographic;const t=e.shadowAreaSizeForDirectionalLight;this._cornerInner.copyComponents(l.IU.fromCopy4(-t,t,t,-t)),this.aspect=1,this.zNear=.1,this.zFar=-1!==e.range?e.range:100,this._parametersInner.copyComponents(this._parameters)}}else{const e=this.entity.tryToGetCameraController();I.Is.exist(e)?this._parametersInner.w=this._parameters.w:this.primitiveMode||(this._eyeInner.copyComponents(C._eye),this._directionInner.copyComponents(this._direction),this._upInner.copyComponents(this._up),this._cornerInner.copyComponents(this._corner),this._parametersInner.copyComponents(this._parameters))}this.calcViewMatrix(),this._xrLeft||this._xrRight||this.calcProjectionMatrix(),this.setValuesToGlobalDataRepository(),this.__lastUpdateCount=this.__updateCount,this.__lastTransformComponentsUpdateCount=T.W.updateCount,this.__lastLightComponentsUpdateCount=t,this.__lastCameraControllerComponentsUpdateCount=w.v.updateCount}}static getCurrentCameraEntity(){return o.O.getComponent(this,this.current).entity}get entity(){return i.YY.getEntity(this.__entityUid)}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getCamera(){return this.getComponentByComponentTID(r.N.CameraComponentTID)}}return(0,i.XJ)(e,n),e}}C._eye=s.Pq.zero(),C.__current=-1,C.returnVector3=p.tp.zero(),C.__globalDataRepository=g.q.getInstance(),C.__tmpVector3_0=p.tp.zero(),C.__tmpVector3_1=p.tp.zero(),C.__tmpVector3_2=p.tp.zero(),C.__tmpMatrix44_0=d.g.zero(),C.__tmpMatrix44_1=d.g.zero(),C.__biasMatrix=_._.fromCopy16ColumnMajor(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1)},8321:(e,t,n)=>{n.d(t,{v:()=>r});var o=n(7503),a=n(8806),i=n(4289);function r(){const e=(0,a.P)();return o.YY.tryToAddComponentToEntityByTID(i.N.CameraComponentTID,e)}},4415:(e,t,n)=>{n.d(t,{v:()=>u});var o=n(8621),a=n(7503),i=n(4289),r=n(2020),s=n(4578),l=n(5118),c=n(2766),_=n(3497);class u extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__cameraController=new r.w(this)}set type(e){this.__cameraController.unregisterEventListeners(),e===l.E.Orbit?this.__cameraController=new r.w(this):e===l.E.WalkThrough?this.__cameraController=new s.k(this):_.V.warn("Not support type!")}get type(){return this.__cameraController instanceof r.w?l.E.Orbit:l.E.WalkThrough}get controller(){return this.__cameraController}static get componentTID(){return i.N.CameraControllerComponentTID}get componentTID(){return i.N.CameraControllerComponentTID}$load(){this.moveStageTo(c.Ow.Logic)}$logic(){this.__cameraController&&this.__cameraController.logic(this.entity.tryToGetCamera())}_updateCount(e){u.__updateCount=e}static get updateCount(){return u.__updateCount}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getCameraController(){return this.getComponentByComponentTID(i.N.CameraControllerComponentTID)}}return(0,a.XJ)(e,n),e}}u.__updateCount=0},5999:(e,t,n)=>{n.d(t,{J:()=>s});var o=n(8621),a=n(7503),i=n(5368),r=n(4289);class s extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.moveStageTo(i.O.Logic)}get entity(){return a.YY.getEntity(this.__entityUid)}static get componentTID(){return r.N.ConstraintComponentTID}get componentTID(){return r.N.ConstraintComponentTID}$logic(){this.__vrmConstraint&&this.__vrmConstraint.update()}setConstraint(e){this.__vrmConstraint=e}_destroy(){super._destroy(),this.__vrmConstraint=void 0}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getConstraint(){return this.getComponentByComponentTID(r.N.ConstraintComponentTID)}}return(0,a.XJ)(e,n),e}}},6235:(e,t,n)=>{n.d(t,{M:()=>x});var o=n(6737),a=n(8621),i=n(7503),r=n(4289),s=n(9201),l=n(975),c=n(5368),_=n(5338),u=n(3107),f=n(8924),d=n(1124),h=n(626),m=n(2229),p=n(9011),v=n(1650);class x extends a.u{constructor(e,t,n,o){super(e,t,n,o),this.type=s.z.Point,this.__intensity=l.Pq.fromCopyArray([1,1,1]),this.__initialDirection=l.Pq.fromCopyArray([0,0,-1]),this.__direction=l.Pq.fromCopyArray([0,0,-1]),this.innerConeAngle=0,this.outerConeAngle=Math.PI/4,this.range=-1,this.enable=!0,this.shadowAreaSizeForDirectionalLight=10,this.__updateCount=0,this.__lastUpdateCount=-1,this.__lastTransformUpdateCount=-1,this._setMaxNumberOfComponent(Math.max(10,Math.floor(_.T.maxEntityNumber/100)))}static get componentTID(){return r.N.LightComponentTID}get componentTID(){return r.N.LightComponentTID}get updateCount(){return this.__updateCount}get direction(){return this.__direction}set intensity(e){this.__intensity=e,this.__updateCount++}get intensity(){return this.__intensity}get _up(){return l.Pq.fromCopy3(0,1,0)}set isLightGizmoVisible(e){e?(m.Is.not.defined(this.__lightGizmo)&&(this.__lightGizmo=new h.h(this.entity),this.__lightGizmo._setup()),this.__lightGizmo.isVisible=!0):m.Is.defined(this.__lightGizmo)&&(this.__lightGizmo.isVisible=!1),this.__updateCount++}get isLightGizmoVisible(){return!!m.Is.defined(this.__lightGizmo)&&this.__lightGizmo.isVisible}$load(){x.__lightPositions=x.__globalDataRepository.getValue("lightPosition",0),x.__lightDirections=x.__globalDataRepository.getValue("lightDirection",0),x.__lightIntensities=x.__globalDataRepository.getValue("lightIntensity",0),x.__lightProperties=x.__globalDataRepository.getValue("lightProperty",0),x.__lightNumber=x.__globalDataRepository.getValue("lightNumber",0),this.moveStageTo(c.O.Logic)}__updateGizmo(){m.Is.defined(this.__lightGizmo)&&this.__lightGizmo.isSetup&&this.isLightGizmoVisible&&this.__lightGizmo._update()}static common_$logic(){const e=o.O.getComponentsWithType(x);x.__lightNumber._v[0]=e.length}$logic(){if(v.W.updateCount===this.__lastTransformUpdateCount&&this.__lastUpdateCount===this.__updateCount)return;const e=this.entity.getSceneGraph();this.__direction=e.normalMatrixInner.multiplyVector(this.__initialDirection);const t=1/Math.max(.001,Math.cos(this.innerConeAngle)-Math.cos(this.outerConeAngle)),n=-Math.cos(this.outerConeAngle)*t;x.__lightDirections._v[3*this.componentSID+0]=this.__direction.x,x.__lightDirections._v[3*this.componentSID+1]=this.__direction.y,x.__lightDirections._v[3*this.componentSID+2]=this.__direction.z;const o=e.worldPosition;x.__lightPositions._v[3*this.componentSID+0]=o.x,x.__lightPositions._v[3*this.componentSID+1]=o.y,x.__lightPositions._v[3*this.componentSID+2]=o.z,x.__lightIntensities._v[3*this.componentSID+0]=this.__intensity.x,x.__lightIntensities._v[3*this.componentSID+1]=this.__intensity.y,x.__lightIntensities._v[3*this.componentSID+2]=this.__intensity.z,x.__lightProperties._v[4*this.componentSID+0]=this.enable?this.type.index:-1,x.__lightProperties._v[4*this.componentSID+1]=this.range,x.__lightProperties._v[4*this.componentSID+2]=t,x.__lightProperties._v[4*this.componentSID+3]=n,this.__updateGizmo(),this.__lastTransformUpdateCount=v.W.updateCount,this.__lastUpdateCount=this.__updateCount}_destroy(){super._destroy(),x.__lightIntensities._v[3*this.componentSID+0]=0,x.__lightIntensities._v[3*this.componentSID+1]=0,x.__lightIntensities._v[3*this.componentSID+2]=0}get entity(){return i.YY.getEntity(this.__entityUid)}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getLight(){return this.getComponentByComponentTID(r.N.LightComponentTID)}}return(0,i.XJ)(e,n),e}}x.__globalDataRepository=u.q.getInstance(),x.__tmp_vec4=f.Am.zero(),x.__lightPositions=new d.u(new Float32Array(0)),x.__lightDirections=new d.u(new Float32Array(0)),x.__lightIntensities=new d.u(new Float32Array(0)),x.__lightProperties=new d.u(new Float32Array(0)),x.__lightNumber=p.X5.zero()},1257:(e,t,n)=>{n.d(t,{G:()=>r});var o=n(7503),a=n(8806),i=n(4289);function r(){const e=(0,a.P)();return o.YY.tryToAddComponentToEntityByTID(i.N.LightComponentTID,e)}},9447:(e,t,n)=>{n.d(t,{F:()=>p});var o=n(8621),a=n(7503),i=n(4289),r=n(5368),s=n(975),l=n(3414),c=n(3870),_=n(7476),u=n(8805),f=n(5697),d=n(2229),h=n(7681),m=n(3497);class p extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__viewDepth=-Number.MAX_VALUE,this.isPickable=!0}static get componentTID(){return i.N.MeshComponentTID}get componentTID(){return i.N.MeshComponentTID}setMesh(e){this.__mesh=e,e._belongToMeshComponent(this)}unsetMesh(){return null!=this.__mesh&&(this.__mesh=void 0,!0)}get mesh(){return this.__mesh}calcViewDepth(e){if(d.Is.not.exist(this.__mesh))return Number.MAX_VALUE;const t=this.__mesh.AABB.centerPoint,n=this.entity.tryToGetSkeletal();d.Is.exist(n)&&d.Is.exist(n._bindShapeMatrix)&&n._bindShapeMatrix.multiplyVector3To(this.__mesh.AABB.centerPoint,t);const o=this.entity.getSceneGraph().matrixInner.multiplyVector3To(t,p.__tmpVector3_0),a=e.viewMatrix.multiplyVector3To(o,p.__tmpVector3_1);return this.__viewDepth=a.z,this.__viewDepth}get viewDepth(){return this.__viewDepth}static alertNoMeshSet(e){m.V.debug("No mesh is set on this MeshComponent:"+e.componentSID)}castRay(e,t,n=0){if(this.__mesh){let o=e,a=t;const i=this.entity.tryToGetSceneGraph();if(null!=i){const r=c._.invert(i.matrixInner);o=s.Pq.fromCopyVector4(r.multiplyVector(l.IU.fromCopyVector3(e)));const _=s.Pq.add(e,t),u=s.Pq.fromCopyVector4(r.multiplyVector(l.IU.fromCopyVector3(_)));a=s.Pq.normalize(s.Pq.subtract(u,o));const f=this.__mesh.castRay(o,a,n);let h=null;if(d.Is.defined(f.data)&&f.data.t>=0)return h=s.Pq.fromCopyVector4(i.matrixInner.multiplyVector(l.IU.fromCopyVector3(f.data.position))),{result:!0,data:{t:f.data.t,u:f.data.u,v:f.data.v,position:h}}}}return{result:!1}}castRayFromScreenInLocal(e,t,n,o,a=0){if(this.__mesh){const i=this.entity.tryToGetSceneGraph();if(null!=i){const r=_.g.multiplyTo(n.projectionMatrix,n.viewMatrix,p.__tmpMatrix44_0).multiply(i.matrixInner).invert(),s=u.n.unProjectTo(e,t,0,r,o,p.__tmpVector3_0),l=u.n.unProjectTo(e,t,1,r,o,p.__tmpVector3_1),c=f.tp.subtractTo(l,s,p.__tmpVector3_2).normalize(),h=this.__mesh.castRay(s,c,a);if(d.Is.defined(h.data)&&h.data.t>=0)return{result:!0,data:{t:h.data.t,u:h.data.u,v:h.data.v,position:h.data.position}}}}return{result:!1}}castRayFromScreenInWorld(e,t,n,o,a=0){const i=this.castRayFromScreenInLocal(e,t,n,o,a),r=this.entity.tryToGetSceneGraph();if(this.__mesh&&null!=r&&i.result){(0,h.qL)(i.data);const e=r.matrixInner.multiplyVector3To(i.data.position,p.__returnVector3);return{result:!0,data:{t:i.data.t,u:i.data.u,v:i.data.v,position:e}}}return i}$load(){if(null==this.__mesh)return;this.__mesh._calcTangents(),this.__mesh._calcFaceNormalsIfNonNormal();const e=this.entity.tryToGetBlendShape();null!=e&&e.weights.length>0&&this.__mesh._calcBaryCentricCoord(),this.moveStageTo(r.O.Logic)}$logic(){}_shallowCopyFrom(e){const t=e;this.__viewDepth=t.__viewDepth,d.Is.exist(t.__mesh)&&this.setMesh(t.__mesh),this.isPickable=t.isPickable}_destroy(){super._destroy(),this.__mesh&&(this.__mesh=void 0)}get entity(){return a.YY.getEntity(this.__entityUid)}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getMesh(){return this.getComponentByComponentTID(i.N.MeshComponentTID)}}return(0,a.XJ)(e,n),e}}p.__tmpVector3_0=f.tp.zero(),p.__tmpVector3_1=f.tp.zero(),p.__tmpVector3_2=f.tp.zero(),p.__returnVector3=f.tp.zero(),p.__tmpMatrix44_0=_.g.zero(),p.__latestPrimitivePositionAccessorVersion=0},2805:(e,t,n)=>{n.d(t,{e:()=>v});var o=n(6737),a=n(8621),i=n(3212),r=n(5368),s=n(7503),l=n(4289),c=n(7295),_=n(3583),u=n(6054),f=n(1823),d=n(4415),h=n(4317),m=n(7670),p=n(108);class v extends a.u{constructor(e,t,n,o){super(e,t,n,o),this.__diffuseCubeMapContribution=1,this.__specularCubeMapContribution=1,this.__rotationOfCubeMap=0,this.__updateCount=0}static get componentTID(){return l.N.MeshRendererComponentTID}get componentTID(){return l.N.MeshRendererComponentTID}get diffuseCubeMap(){return this.__diffuseCubeMap}get specularCubeMap(){return this.__specularCubeMap}get updateCount(){return this.__updateCount}static get updateCount(){return v.__updateCount}get diffuseCubeMapContribution(){return this.__diffuseCubeMapContribution}set diffuseCubeMapContribution(e){this.__diffuseCubeMapContribution=e,v.__updateCount++}get specularCubeMapContribution(){return this.__specularCubeMapContribution}set specularCubeMapContribution(e){this.__specularCubeMapContribution=e,v.__updateCount++}get rotationOfCubeMap(){return this.__rotationOfCubeMap}set rotationOfCubeMap(e){this.__rotationOfCubeMap=e,v.__updateCount++}setIBLCubeMap(e,t){if(null==e||null==t)return;this.__diffuseCubeMap=e,this.__specularCubeMap=t;const n=[];return e instanceof p._?n.push(new Promise((t=>{e.setIsTextureReady(),t()}))):n.push(new Promise((t=>{e.startedToLoad?e.isTextureReady?t():e.registerOnTextureLoaded((()=>{t()})):e.loadTextureImagesAsync().then((()=>{t()}))}))),t instanceof p._?n.push(new Promise((e=>{t.setIsTextureReady(),e()}))):n.push(new Promise((e=>{t.startedToLoad?t.isTextureReady?e():t.registerOnTextureLoaded((()=>{e()})):t.loadTextureImagesAsync().then((()=>{e()}))}))),Promise.all(n).then((()=>{this.__updateCount++,v.__updateCount++}))}static common_$load({processApproach:e}){const t=_.e.getInstance();if(e===i.m.WebGPU){const e="webgpu",n=t.getModule(e);v.__cgApiRenderingStrategy=n.WebGpuStrategyBasic.getInstance(),v.__cgApiRenderingStrategy.common_$load()}else{const n="webgl",o=t.getModule(n);v.__cgApiRenderingStrategy=o.getRenderingStrategy(e)}}$load(){v.__cgApiRenderingStrategy.$load(this.entity.tryToGetMesh())&&this.moveStageTo(r.O.Unknown)}static sort_$render(e){if(f.W.updateCount===e._lastTransformComponentsUpdateCount&&d.v.updateCount===e._lastCameraControllerComponentsUpdateCount&&h.K.updateCount===e._lastSceneGraphComponentsUpdateCount)return e._lastPrimitiveUids;let t=e.cameraComponent;if(null==t&&(t=o.O.getComponent(c.n,c.n.current)),null==t&&(t=o.O.getComponentsWithType(c.n).find((e=>null!=e&&e._isAlive)),c.n.current=t.componentSID),e.isVrRendering){const e=_.e.getInstance().getModule("xr");if(null!=e){const n=e.WebXRSystem.getInstance();n.isWebXRMode&&(t=n._getCameraComponentAt(0))}}let n=[];const a=e._optimizedMeshComponents;n=v.__cullingWithViewFrustum(t,a),n=Array.from(new Set(n)),n.sort(((e,t)=>{const n=e._sortkey-t._sortkey;return 0!==n?n:e._viewDepth-t._viewDepth}));const i=n.map((e=>e.primitiveUid));i.push(-1);let r=n.length-1,s=n.length-1,l=n.length-1,m=n.length-1;for(let e=0;e<n.length;e++){const t=n[e];if((0,u.eG)(t)){r=e-1;break}if((0,u.pc)(t)){r=e-1;break}if((0,u.VG)(t)){r=e-1;break}}for(let e=r+1;e<n.length;e++){const t=n[e];if((0,u.pc)(t)){s=e-1;break}if((0,u.VG)(t)){s=e-1;break}}for(let e=s+1;e<n.length;e++){const t=n[e];if((0,u.VG)(t)){l=e-1;break}}let p=!1;if(r!=e._lastOpaqueIndex&&(e._lastOpaqueIndex=r,p||(p=!0)),s!=e._lastTranslucentIndex&&(e._lastTranslucentIndex=s,p||(p=!0)),l!=e._lastBlendWithZWriteIndex&&(e._lastBlendWithZWriteIndex=l,p||(p=!0)),m!=e._lastBlendWithoutZWriteIndex&&(e._lastBlendWithoutZWriteIndex=m,p||(p=!0)),i.length!==e._lastPrimitiveUids.length)p||(p=!0);else for(let t=s+1;t<i.length;t++)if(i[t]!==e._lastPrimitiveUids[t]){p||(p=!0);break}return e._isChangedSortRenderResult=p,e._lastPrimitiveUids=i,e._lastTransformComponentsUpdateCount=f.W.updateCount,e._lastCameraControllerComponentsUpdateCount=d.v.updateCount,e._lastSceneGraphComponentsUpdateCount=h.K.updateCount,p&&(e._renderedSomethingBefore=!0),i}static __cullingWithViewFrustum(e,t){let n=[];if(e&&v._isFrustumCullingEnabled){e.updateFrustum();const o=e.frustum,a=(e,t)=>{if("background-assets"===e.entity.getTagValue("type")||o.culling(e)){t.push(e),e.entity.getSceneGraph()._isCulled=!1;const n=e.entity.tryToGetSkeletal();void 0!==n&&(n._isCulled=!1)}else{e.entity.getSceneGraph()._isCulled=!0;const t=e.entity.tryToGetSkeletal();void 0!==t&&(t._isCulled=!0)}};for(const e of t)e._isAlive&&e.entity.getSceneGraph().isVisible&&a(e,n)}else n=t.filter((e=>e._isAlive&&e.entity.getSceneGraph().isVisible));const o=[];for(let t=0;t<n.length;t++){const a=n[t],i=a.mesh;if(void 0!==i){const t=i.primitives;let n=!1;for(let e=0;e<t.length;e++){const a=t[e];o.push(a),(0,u.SQ)(a)&&(n=!0)}if(n){const n=a.calcViewDepth(e);for(let e=0;e<t.length;e++)t[e]._viewDepth=n}}}return o}static common_$prerender(){if(null==v.__cgApiRenderingStrategy){const e=m.l.currentProcessApproach;this.common_$load({processApproach:e})}v.__cgApiRenderingStrategy.prerender()}static common_$render({renderPass:e,processStage:t,renderPassTickCount:n,primitiveUids:o}){return v.__cgApiRenderingStrategy.common_$render(o,e,n)}$render({i:e,renderPass:t,renderPassTickCount:n}){}_shallowCopyFrom(e){const t=e;this.__diffuseCubeMap=t.__diffuseCubeMap,this.__specularCubeMap=t.__specularCubeMap,this.diffuseCubeMapContribution=t.diffuseCubeMapContribution,this.specularCubeMapContribution=t.specularCubeMapContribution,this.rotationOfCubeMap=t.rotationOfCubeMap}_destroy(){super._destroy(),this.__diffuseCubeMap=void 0,this.__specularCubeMap=void 0}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getMeshRenderer(){return this.getComponentByComponentTID(l.N.MeshRendererComponentTID)}}return(0,s.XJ)(e,n),e}}v.isDepthMaskTrueForBlendPrimitives=!1,v.__shaderProgramHandleOfPrimitiveObjectUids=new Map,v.__updateCount=0,v._isFrustumCullingEnabled=!0},2216:(e,t,n)=>{n.d(t,{j:()=>r});var o=n(7503),a=n(8806),i=n(4289);function r(){const e=(0,a.P)(),t=o.YY.tryToAddComponentToEntityByTID(i.N.MeshComponentTID,e);return o.YY.tryToAddComponentToEntityByTID(i.N.MeshRendererComponentTID,t)}},4155:(e,t,n)=>{n.d(t,{l:()=>l});var o=n(8621),a=n(7503),i=n(4289),r=n(5368),s=n(9179);class l extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.moveStageTo(r.O.Logic)}static get componentTID(){return i.N.PhysicsComponentTID}get componentTID(){return i.N.PhysicsComponentTID}setStrategy(e){this.__strategy=e}get strategy(){return this.__strategy}static common_$logic(){s.N.update()}$logic(){var e;null===(e=this.__strategy)||void 0===e||e.update()}_destroy(){super._destroy(),this.__strategy=void 0}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getPhysics(){return this.getComponentByComponentTID(i.N.PhysicsComponentTID)}}return(0,a.XJ)(e,n),e}}},4317:(e,t,n)=>{n.d(t,{K:()=>T});var o=n(8621),a=n(3870),i=n(7503),r=n(4114),s=n(4289),l=n(7616),c=n(5368),_=n(7476),u=n(2162),f=n(975),d=n(3629),h=n(5697),m=n(3498),p=n(1392),v=n(2229),x=n(2335),g=n(9588),y=n(9179),b=n(1823),I=n(1614),A=n(1881),E=n(6253),S=n(6603);class T extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__children=[],this.__gizmoChildren=[],this._worldMatrix=_.g.dummy(),this._worldMatrixRest=_.g.identity(),this._normalMatrix=u._.dummy(),this.__isWorldMatrixUpToDate=!1,this.__isWorldMatrixRestUpToDate=!1,this.__isNormalMatrixUpToDate=!1,this.__worldMergedAABBWithSkeletal=new d.F,this.__worldMergedAABB=new d.F,this.__isWorldAABBDirty=!0,this._isVisible=A.n9.dummy(),this._isBillboard=A.n9.dummy(),this.__transformGizmoSpace="world",this.__latestPrimitivePositionAccessorVersion=0,this.toMakeWorldMatrixTheSameAsLocalMatrix=!1,this.isRootJoint=!1,this.jointIndex=-1,this._isCulled=!1,this.__lastTransformComponentsUpdateCount=-1,T.__sceneGraphs.push(new WeakRef(this)),this.registerMember(l.a.GPUInstanceData,"worldMatrix",_.g,r.I.Float,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.registerMember(l.a.GPUInstanceData,"normalMatrix",u._,r.I.Float,[1,0,0,0,1,0,0,0,1]),this.registerMember(l.a.GPUInstanceData,"isVisible",A.n9,r.I.Float,[1]),this.registerMember(l.a.GPUInstanceData,"isBillboard",A.n9,r.I.Float,[0]),this.submitToAllocation(this.maxNumberOfComponent,o)}set isVisible(e){this._isVisible.setValue(e?1:0),T.__updateCount++}get isVisible(){return 1===this._isVisible.getValue()}static get updateCount(){return T.__updateCount}setVisibilityRecursively(e){this.isVisible=e;for(const t of this.__children)t.setVisibilityRecursively(e)}set isBillboard(e){this._isBillboard.setValue(e?1:0)}get isBillboard(){return 1===this._isBillboard.getValue()}setIsBillboardRecursively(e){this._isBillboard.setValue(e?1:0);for(const t of this.__children)t.isBillboard=e}set isAABBGizmoVisible(e){e?(v.Is.not.defined(this.__aabbGizmo)&&(this.__aabbGizmo=new m.T(this.entity),this.__aabbGizmo._setup()),this.__aabbGizmo.isVisible=!0):v.Is.exist(this.__aabbGizmo)&&(this.__aabbGizmo.isVisible=!1)}get isAABBGizmoVisible(){return!!v.Is.exist(this.__aabbGizmo)&&this.__aabbGizmo.isVisible}set isLocatorGizmoVisible(e){e?(v.Is.not.defined(this.__locatorGizmo)&&(this.__locatorGizmo=new p.r(this.entity),this.__locatorGizmo._setup()),this.__locatorGizmo.isVisible=!0):v.Is.exist(this.__locatorGizmo)&&(this.__locatorGizmo.isVisible=!1)}get isLocatorGizmoVisible(){return!!v.Is.exist(this.__locatorGizmo)&&this.__locatorGizmo.isVisible}set isTranslationGizmoVisible(e){e?(v.Is.not.defined(this.__translationGizmo)&&(this.__translationGizmo=new x.U(this.entity),this.__translationGizmo._setup()),this.__translationGizmo.isVisible=!0):v.Is.exist(this.__translationGizmo)&&(this.__translationGizmo.isVisible=!1)}get isTranslationGizmoVisible(){return!!v.Is.exist(this.__translationGizmo)&&this.__translationGizmo.isVisible}set isScaleGizmoVisible(e){e?(v.Is.not.defined(this.__scaleGizmo)&&(this.__scaleGizmo=new g.t(this.entity),this.__scaleGizmo._setup()),this.__scaleGizmo.isVisible=!0):v.Is.exist(this.__scaleGizmo)&&(this.__scaleGizmo.isVisible=!1)}get isScaleGizmoVisible(){return!!v.Is.exist(this.__scaleGizmo)&&this.__scaleGizmo.isVisible}static getTopLevelComponents(){return T.__sceneGraphs.map((e=>e.deref())).filter((e=>void 0!==e&&e.isTopLevel)).filter((e=>void 0!==e))}isJoint(){return this.jointIndex>=0}static get componentTID(){return s.N.SceneGraphComponentTID}get componentTID(){return s.N.SceneGraphComponentTID}setWorldMatrixRestDirty(){this.matrixRestInner,this.setWorldMatrixRestDirtyRecursively()}setWorldMatrixRestDirtyRecursively(){this.__isWorldMatrixRestUpToDate=!1,this.children.forEach((e=>{e.setWorldMatrixRestDirtyRecursively()}))}setWorldMatrixDirty(){var e;this.setWorldMatrixDirtyRecursively(),null===(e=this.parent)||void 0===e||e.setWorldAABBDirtyParentRecursively()}setWorldMatrixDirtyRecursively(){this.__isWorldMatrixUpToDate=!1,this.__isNormalMatrixUpToDate=!1,this.__isWorldAABBDirty=!0,this.children.forEach((e=>{e.setWorldMatrixDirtyRecursively()}))}setWorldAABBDirtyParentRecursively(){var e;this.__isWorldAABBDirty=!0,null===(e=this.parent)||void 0===e||e.setWorldAABBDirtyParentRecursively()}addChild(e){v.Is.exist(e.__parent)&&e.__parent.removeChild(e),e.__parent=this,this.__children.push(e)}removeChild(e){const t=this.__children.indexOf(e);t>=0&&this.__children.splice(t,1),e.__parent=void 0}_addGizmoChild(e){e.__parent=this,this.__gizmoChildren.push(e)}get isTopLevel(){return null==this.__parent}get children(){return this.__children}get parent(){return this.__parent}get matrixInner(){return this.__isWorldMatrixUpToDate||(this._worldMatrix.copyComponents(this.__calcWorldMatrixRecursively()),this.__isWorldMatrixUpToDate=!0),this._worldMatrix}get matrix(){return this.matrixInner.clone()}get matrixRestInner(){return this.__isWorldMatrixRestUpToDate||(this._worldMatrixRest.copyComponents(this.__calcWorldMatrixRestRecursively()),this.__isWorldMatrixRestUpToDate=!0),this._worldMatrixRest}get matrixRest(){return this.matrixRestInner.clone()}get normalMatrixInner(){return this.__isNormalMatrixUpToDate||(a._.invertTo(this.matrixInner,T.invertedMatrix44),this._normalMatrix.copyComponents(T.invertedMatrix44.transpose()),this.__isNormalMatrixUpToDate=!0),this._normalMatrix}get entityWorldWithSkeletalMatrix(){return this.entityWorldMatrixWithSkeletalInner.clone()}get entityWorldMatrixWithSkeletalInner(){const e=this.entity.tryToGetSkeletal();return v.Is.exist(e)&&e.isWorldMatrixUpdated?e.worldMatrixInner:this.entity.getSceneGraph().matrixInner}get normalMatrix(){return this.normalMatrixInner.clone()}isWorldMatrixUpToDateRecursively(){return!!this.__isWorldMatrixUpToDate&&(!this.__parent||this.__parent.isWorldMatrixUpToDateRecursively())}__calcWorldMatrixRecursively(){if(this.__isWorldMatrixUpToDate)return this._worldMatrix;const e=this.entity.getTransform();if(null==this.__parent||this.toMakeWorldMatrixTheSameAsLocalMatrix)return e.getLocalMatrixInnerTo(T.__tmp_mat4_2),T.__tmp_mat4_2;const t=this.__parent.__calcWorldMatrixRecursively();return e.getLocalMatrixInnerTo(T.__tmp_mat4_3),_.g.multiplyTo(t,T.__tmp_mat4_3,T.__tmp_mat4)}__calcWorldMatrixRestRecursively(){if(this.__isWorldMatrixRestUpToDate)return this._worldMatrixRest;const e=this.entity.getTransform();if(null==this.__parent||this.toMakeWorldMatrixTheSameAsLocalMatrix)return e.getLocalMatrixInnerTo(T.__tmp_mat4_2),T.__tmp_mat4_2;const t=this.__parent.__calcWorldMatrixRestRecursively();return e.getLocalMatrixInnerTo(T.__tmp_mat4_3),_.g.multiplyTo(t,T.__tmp_mat4_3,T.__tmp_mat4)}getQuaternionRecursively(){if(v.Is.not.exist(this.parent))return this.entity.getTransform().localRotation;const e=this.parent.getQuaternionRecursively();return S.P.multiply(e,this.entity.getTransform().localRotation)}get worldPosition(){const e=T.__originVector3;return this.matrixInner.multiplyVector3To(e,T.returnVector3),T.returnVector3}getWorldPositionOf(e){return this.matrixInner.multiplyVector3(e)}getWorldPositionOfTo(e,t){return this.matrixInner.multiplyVector3To(e,t)}getLocalPositionOf(e){return a._.invert(this.matrixInner).multiplyVector3(e)}getLocalPositionOfTo(e,t){return a._.invertTo(this.matrixInner,T.__tmp_mat4).multiplyVector3To(e,t)}getWorldAABB(){const e=new d.F,t=this.entity.tryToGetMesh();return v.Is.exist(t)&&v.Is.exist(t.mesh)?(e.mergeAABB(t.mesh.AABB),d.F.multiplyMatrixTo(this.entity.getSceneGraph().matrixInner,e,T.__tmpAABB)):T.__tmpAABB.initialize(),T.__tmpAABB}calcWorldMergedAABB(){const e=this.getWorldAABB().clone();for(const t of this.children){const n=t.calcWorldMergedAABB();e.mergeAABB(n)}return this.__worldMergedAABB=e,e}get worldMergedAABB(){return this.__isWorldAABBDirty&&(this.calcWorldMergedAABB(),this.__isWorldAABBDirty=!1),this.__worldMergedAABB}getWorldAABBWithSkeletal(){const e=new d.F,t=this.entity.tryToGetMesh();return v.Is.exist(t)&&v.Is.exist(t.mesh)?(e.mergeAABB(t.mesh.AABB),d.F.multiplyMatrixTo(this.entity.getSceneGraph().entityWorldMatrixWithSkeletalInner,e,T.__tmpAABB)):T.__tmpAABB.initialize(),T.__tmpAABB}calcWorldMergedAABBWithSkeletal(){const e=this.getWorldAABBWithSkeletal().clone();for(const t of this.children){const n=t.calcWorldMergedAABBWithSkeletal();e.mergeAABB(n)}return this.__worldMergedAABBWithSkeletal=e,e}get worldMergedAABBWithSkeletal(){return this.__isWorldAABBDirty&&(this.calcWorldMergedAABBWithSkeletal(),this.__isWorldAABBDirty=!1),this.__worldMergedAABBWithSkeletal}castRay(e,t,n=0,o=[]){const a=(0,I.g)(this,!1),i=[];for(const e of a){const t=e.entity.tryToGetMesh();t&&i.push(t)}let r,s,l=Number.MAX_VALUE,c=0,_=0;for(const a of i){if(!a.entity.getSceneGraph().isVisible)continue;if(!a.isPickable)continue;if(-1!==o.indexOf(a))continue;const i=a.castRay(e,t,n);v.Is.defined(i.data)&&i.data.t<l&&(l=i.data.t,r=i.data.position,s=a,c=i.data.u,_=i.data.v)}return v.Is.exist(s)&&v.Is.exist(r)?{result:!0,data:{t:l,u:c,v:_,position:r,selectedMeshComponent:s}}:{result:!1}}castRayFromScreen(e,t,n,o,a=0,i=[]){const r=(0,I.g)(this,!1),s=[];for(const e of r){const t=e.entity.tryToGetMesh();t&&s.push(t)}let l,c,_=Number.MAX_VALUE,u=0,f=0;for(const r of s){if(!r.entity.getSceneGraph().isVisible)continue;if(!r.isPickable)continue;if(-1!==i.indexOf(r))continue;const s=r.castRayFromScreenInWorld(e,t,n,o,a);v.Is.defined(s.data)&&s.data.t<_&&(_=s.data.t,l=s.data.position,c=r,u=s.data.u,f=s.data.v)}return v.Is.exist(c)&&v.Is.exist(l)?{result:!0,data:{t:_,u,v:f,position:l,selectedMeshComponent:c}}:{result:!1}}$load(){this.moveStageTo(c.O.Logic)}$logic(){this.__lastTransformComponentsUpdateCount!==b.W.updateCount&&(this.matrixInner,this.normalMatrixInner,this.__updateGizmos(),this.__lastTransformComponentsUpdateCount=b.W.updateCount)}__updateGizmos(){v.Is.exist(this.__aabbGizmo)&&this.__aabbGizmo.isSetup&&this.__aabbGizmo.isVisible&&this.__aabbGizmo._update(),v.Is.exist(this.__locatorGizmo)&&this.__locatorGizmo.isSetup&&this.__locatorGizmo.isVisible&&this.__locatorGizmo._update(),v.Is.exist(this.__translationGizmo)&&this.__translationGizmo.isSetup&&this.__translationGizmo.isVisible&&this.__translationGizmo._update(),v.Is.exist(this.__scaleGizmo)&&this.__scaleGizmo.isSetup&&this.__scaleGizmo.isVisible&&this.__scaleGizmo._update()}setPositionWithoutPhysics(e){v.Is.not.exist(this.__parent)?this.entity.getTransform().localPosition=e:(_.g.invertTo(this.__parent.entity.getSceneGraph().matrixInner,T.__tmp_mat4),this.entity.getTransform().localPosition=T.__tmp_mat4.multiplyVector3(e))}set position(e){this.setPositionWithoutPhysics(e);const t=this.entity.tryToGetPhysics();void 0!==t&&void 0!==t.strategy&&t.strategy instanceof y.N&&void 0!==this.entity.tryToGetSceneGraph()&&t.strategy.setPosition(e)}get position(){return this.matrixInner.getTranslate()}getPositionTo(e){return this.matrixInner.getTranslateTo(e)}get positionRest(){return this.matrixRestInner.getTranslate()}getPositionRestTo(e){return this.matrixRestInner.getTranslateTo(e)}set eulerAngles(e){if(v.Is.not.exist(this.__parent))this.entity.getTransform().localEulerAngles=e;else{const t=S.P.fromMatrix(this.__parent.entity.getSceneGraph().matrixInner),n=S.P.invert(t),o=S.P.fromMatrix(a._.rotate(e)),i=S.P.multiply(o,n);this.entity.getTransform().localEulerAngles=i.toEulerAngles()}const t=this.entity.tryToGetPhysics();void 0!==t&&void 0!==t.strategy&&t.strategy instanceof y.N&&void 0!==this.entity.tryToGetSceneGraph()&&t.strategy.setEulerAngle(e)}get eulerAngles(){return this.matrixInner.toEulerAngles()}setRotationWithoutPhysics(e){if(v.Is.not.exist(this.__parent))this.entity.getTransform().localRotation=e;else{const t=this.__parent.entity.getSceneGraph().rotation,n=S.P.invert(t);this.entity.getTransform().localRotation=S.P.multiply(e,n)}}set rotation(e){this.setRotationWithoutPhysics(e);const t=this.entity.tryToGetPhysics();void 0!==t&&void 0!==t.strategy&&t.strategy instanceof y.N&&void 0!==this.entity.tryToGetSceneGraph()&&t.strategy.setEulerAngle(e.toEulerAngles())}get rotation(){const e=this.parent;return null!=e?S.P.multiply(e.rotation,this.entity.getTransform().localRotationInner):this.entity.getTransform().localRotationInner}getRotationTo(e){const t=this.parent;if(null!=t)return S.P.multiplyTo(t.getRotationTo(T.__tmp_quat_0),this.entity.getTransform().localRotationInner,e);const n=this.entity.getTransform().localRotationInner;return e.setComponents(n._v[0],n._v[1],n._v[2],n._v[3]),e}get rotationRest(){const e=this.parent;return null!=e?S.P.multiply(e.rotationRest,this.entity.getTransform().localRotationRestInner):this.entity.getTransform().localRotationRestInner}getRotationRest(e){const t=this.parent,n=e(this);return null==t||n?this.entity.getTransform().localRotationRestInner:S.P.multiply(t.getRotationRest(e),this.entity.getTransform().localRotationRestInner)}set scale(e){if(v.Is.not.exist(this.__parent))this.entity.getTransform().localScale=e;else{const t=this.__parent.entity.getSceneGraph().matrix;t._v[12]=0,t._v[13]=0,t._v[14]=0;const n=_.g.invert(t);this.entity.getTransform().localScale=n.multiplyVector3(e)}const t=this.entity.tryToGetPhysics();void 0!==t&&void 0!==t.strategy&&t.strategy instanceof y.N&&void 0!==this.entity.tryToGetSceneGraph()&&t.strategy.setScale(e)}get scale(){return this.matrixInner.getScale()}__copyChild(e){const t=i.YY._shallowCopyEntityInner(e.entity);return t.getSceneGraph().__parent=this,t}_shallowCopyFrom(e){const t=e;this.__parent=t.__parent,this.__children=[];for(let e=0;e<t.__children.length;e++){const n=this.__copyChild(t.__children[e]).getSceneGraph();this.__children.push(n)}this.__gizmoChildren=t.__gizmoChildren.concat(),this._worldMatrix.copyComponents(t._worldMatrix),this._worldMatrixRest.copyComponents(t._worldMatrixRest),this._normalMatrix.copyComponents(t._normalMatrix),this.__isWorldMatrixUpToDate=!1,this.__isWorldMatrixRestUpToDate=!1,this.__isNormalMatrixUpToDate=!1,this.__worldMergedAABBWithSkeletal=t.__worldMergedAABBWithSkeletal.clone(),this.__isWorldAABBDirty=!0,this._isVisible.copyComponents(t._isVisible),this._isBillboard.copyComponents(t._isBillboard),this.__transformGizmoSpace=t.__transformGizmoSpace,this.__latestPrimitivePositionAccessorVersion=t.__latestPrimitivePositionAccessorVersion,this.toMakeWorldMatrixTheSameAsLocalMatrix=t.toMakeWorldMatrixTheSameAsLocalMatrix,this.isRootJoint=t.isRootJoint,this.jointIndex=t.jointIndex}get entity(){return i.YY.getEntity(this.__entityUid)}setTransformGizmoSpace(e){var t,n;this.__transformGizmoSpace=e,null===(t=this.__translationGizmo)||void 0===t||t.setSpace(e),null===(n=this.__scaleGizmo)||void 0===n||n.setSpace(e)}_destroy(){var e,t,n,o,a;super._destroy(),null===(e=this.__aabbGizmo)||void 0===e||e._destroy(),null===(t=this.__locatorGizmo)||void 0===t||t._destroy(),null===(n=this.__translationGizmo)||void 0===n||n._destroy(),null===(o=this.__scaleGizmo)||void 0===o||o._destroy(),null===(a=this.parent)||void 0===a||a.removeChild(this),this.children.forEach((e=>{var t;return null===(t=e.parent)||void 0===t?void 0:t.removeChild(e)}))}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getSceneGraph(){return void 0===this.__sceneGraphComponent&&(this.__sceneGraphComponent=this.getComponentByComponentTID(s.N.SceneGraphComponentTID)),this.__sceneGraphComponent}get parent(){return this.getSceneGraph().parent}get matrix(){return this.getSceneGraph().matrix}get matrixInner(){return this.getSceneGraph().matrixInner}get position(){return this.getSceneGraph().position}set position(e){this.getSceneGraph().position=e}get positionRest(){return this.getSceneGraph().positionRest}get scale(){return this.getSceneGraph().scale}set scale(e){this.getSceneGraph().scale=e}get eulerAngles(){return this.getSceneGraph().eulerAngles}set eulerAngles(e){this.getSceneGraph().eulerAngles=e}get rotation(){return this.getSceneGraph().rotation}set rotation(e){this.getSceneGraph().rotation=e}get rotationRest(){return this.getSceneGraph().rotationRest}addChild(e){this.getSceneGraph().addChild(e)}get children(){return this.getSceneGraph().children}removeChild(e){this.getSceneGraph().removeChild(e)}}return(0,i.XJ)(e,n),e}}T.__originVector3=f.Pq.zero(),T.returnVector3=h.tp.zero(),T.__sceneGraphs=[],T.isJointAABBShouldBeCalculated=!1,T.invertedMatrix44=_.g.fromCopyArray16ColumnMajor([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),T.__tmp_mat4=_.g.identity(),T.__tmp_mat4_2=_.g.identity(),T.__tmp_mat4_3=_.g.identity(),T.__tmp_quat_0=E.h.identity(),T.__tmp_quat_1=E.h.identity(),T.__updateCount=-1,T.__tmpAABB=new d.F},1614:(e,t,n)=>{function o(e,t){const n=[];t&&!e.isJoint()||n.push(e);const a=e.children;for(let e=0;e<a.length;e++){const i=o(a[e],t);Array.prototype.push.apply(n,i)}return n}n.d(t,{g:()=>o})},8806:(e,t,n)=>{n.d(t,{P:()=>r});var o=n(7503),a=n(2253),i=n(4289);function r(){const e=(0,a.Y)();return o.YY.tryToAddComponentToEntityByTID(i.N.SceneGraphComponentTID,e)}},4507:(e,t,n)=>{n.d(t,{i:()=>i});var o=n(6227),a=n(2229);class i{constructor(e){this.__srcEntity=e}getEntity(){return this.__srcEntity}getSrcPGRestQ(e){let t;const n=e.getSceneGraph().parent;return t=a.Is.exist(n)?n.getRotationRest((e=>{const t=e.parent;if(a.Is.exist(t)){const e=t.entity.tryToGetVrm();return a.Is.exist(e)}return!0})):o.PT.identity(),t}getDstPGRestQ(e){let t;const n=e.getSceneGraph().parent;return t=a.Is.exist(n)?n.getRotationRest((e=>{const t=e.parent;if(a.Is.exist(t)){const e=t.entity.tryToGetVrm();return a.Is.exist(e)}return!0})):o.PT.identity(),t}retargetQuaternion(e){const t=this.__srcEntity,n=t.getTransform().localRotationInner,a=t.getTransform().localRotationRestInner,r=this.getSrcPGRestQ(t),s=o.PT.multiply(r,o.PT.multiply(n,o.PT.multiply(o.PT.invert(a),o.PT.invert(r)))),l=e.getTransform().localRotationRestInner,c=this.getDstPGRestQ(e),_=o.PT.multiply(o.PT.invert(c),o.PT.multiply(s,o.PT.multiply(c,l)));return o.PT.multiply(o.PT.multiply(i.__rev,_),o.PT.invert(i.__rev))}retargetTranslate(e){const t=this.__srcEntity,n=t.getTransform().localPositionInner,a=t.getTransform().localPositionRestInner,r=this.getSrcPGRestQ(t),s=o.Pq.subtract(n,a),l=r.transformVector3(s),c=e.getTransform().localPositionRestInner,_=this.getDstPGRestQ(e),u=o.Pq.add(_.transformVector3Inverse(l),c);if(t.uniqueName.indexOf("hips")>=0){const e=o.Pq.multiply(u,t.parent.scale.x);return i.__rev.transformVector3(e)}return u}retargetScale(e){return this.__srcEntity.getTransform().localScaleInner}}i.__rev=o.PT.fromAxisAngle(o.Pq.fromCopy3(0,1,0),Math.PI)},847:(e,t,n)=>{n.d(t,{D:()=>x});var o=n(8621),a=n(7503),i=n(4289),r=n(3870),s=n(5368),l=n(5697),c=n(6253),_=n(6941),u=n(8924),f=n(7476),d=n(3107),h=n(5338),m=n(6195),p=n(6301),v=n(3497);class x extends o.u{constructor(e,t,n,o){super(e,t,n,o),this._jointIndices=[],this.__joints=[],this.isSkinning=!0,this.__qArray=new Float32Array(0),this.__tsArray=new Float32Array(0),this.__tqArray=new Float32Array(0),this.__sqArray=new Float32Array(0),this.__qtsArray=new Float32Array(0),this.__qtsInfo=u.Am.dummy(),this.__matArray=new Float32Array(0),this.__worldMatrix=f.g.identity(),this.__isWorldMatrixVanilla=!0,this._isCulled=!1,this.moveStageTo(s.O.Logic),o||(x.__tookGlobalDataNum<h.T.maxSkeletonNumber?(h.T.boneDataType===m.N.Mat43x1?x.__globalDataRepository.takeOne("boneMatrix"):h.T.boneDataType===m.N.Vec4x2?(x.__globalDataRepository.takeOne("boneTranslatePackedQuat"),x.__globalDataRepository.takeOne("boneScalePackedQuat")):h.T.boneDataType===m.N.Vec4x2Old?(x.__globalDataRepository.takeOne("boneQuaternion"),x.__globalDataRepository.takeOne("boneTranslateScale")):h.T.boneDataType===m.N.Vec4x1&&(x.__globalDataRepository.takeOne("boneTranslateScale"),x.__globalDataRepository.takeOne("boneCompressedChunk")),x.__tookGlobalDataNum++):v.V.warn("The actual number of Skeleton generated exceeds Config.maxSkeletonNumber."))}static get componentTID(){return i.N.SkeletalComponentTID}get componentTID(){return i.N.SkeletalComponentTID}setInverseBindMatricesAccessor(e){this.__inverseBindMatricesAccessor=e}setJoints(e){this.__joints=e;let t=0;this.componentSID<h.T.maxSkeletonNumber&&(t=this.componentSID),h.T.boneDataType===m.N.Mat43x1?this.__matArray=x.__globalDataRepository.getValue("boneMatrix",t)._v:h.T.boneDataType===m.N.Vec4x2?(this.__tqArray=x.__globalDataRepository.getValue("boneTranslatePackedQuat",t)._v,this.__sqArray=x.__globalDataRepository.getValue("boneScalePackedQuat",t)._v):h.T.boneDataType===m.N.Vec4x2Old?(this.__qArray=x.__globalDataRepository.getValue("boneQuaternion",t)._v,this.__tsArray=x.__globalDataRepository.getValue("boneTranslateScale",t)._v):h.T.boneDataType===m.N.Vec4x1&&(this.__tsArray=x.__globalDataRepository.getValue("boneTranslateScale",t)._v,this.__qtsArray=x.__globalDataRepository.getValue("boneCompressedChunk",t)._v,this.__qtsInfo=x.__globalDataRepository.getValue("boneCompressedInfo",0))}getJoints(){return this.__joints.concat()}get rootJointWorldMatrixInner(){var e;return null===(e=this.topOfJointsHierarchy)||void 0===e?void 0:e.matrixInner}get jointMatrices(){return this.__jointMatrices}get jointQuaternionArray(){return this.__qArray}get jointTranslateScaleArray(){return this.__tsArray}get jointTranslatePackedQuat(){return this.__tqArray}get jointScalePackedQuat(){return this.__sqArray}get jointMatricesArray(){return this.__matArray}get jointCompressedChunk(){return this.__qtsArray}get jointCompressedInfo(){return this.__qtsInfo}get worldMatrix(){return this.__worldMatrix.clone()}get worldMatrixInner(){return this.__worldMatrix}get isWorldMatrixUpdated(){return!this.__isWorldMatrixVanilla}$logic(){if(this.isSkinning&&!this._isCulled){for(let e=0;e<this.__joints.length;e++){const t=this.__joints[e],n=t.isVisible?t.matrixInner:t.matrixRestInner;f.g.multiplyTypedArrayTo(n,this.__inverseBindMatricesAccessor.getTypedArray(),x.__tmp_mat4,e),this._bindShapeMatrix&&x.__tmp_mat4.multiply(this._bindShapeMatrix);const o=x.__tmp_mat4;if(0===e&&null!=t.entity.tryToGetAnimation()&&this.__worldMatrix.copyComponents(o),1===e&&null==this.__joints[0].entity.tryToGetAnimation()&&this.__worldMatrix.copyComponents(o),this.__isWorldMatrixVanilla=!1,h.T.boneDataType!==m.N.Mat43x1&&h.T.boneDataType!==m.N.Vec4x1||this.__copyToMatArray(o,e),h.T.boneDataType!==m.N.Mat43x1){const t=x.__tmpVec3_0.setComponents(Math.hypot(o._v[0],o._v[1],o._v[2]),Math.hypot(o._v[4],o._v[5],o._v[6]),Math.hypot(o._v[8],o._v[9],o._v[10]));o.m00/=t.x,o.m01/=t.x,o.m02/=t.x,o.m10/=t.y,o.m11/=t.y,o.m12/=t.y,o.m20/=t.z,o.m21/=t.z,o.m22/=t.z;const n=x.__tmp_q.fromMatrix(o);if(h.T.boneDataType===m.N.Vec4x2Old||h.T.boneDataType===m.N.Vec4x1){let n=1;n=Math.abs(t.x)>Math.abs(t.y)?Math.abs(t.x)>Math.abs(t.z)?t.x:t.z:Math.abs(t.y)>Math.abs(t.z)?t.y:t.z,this.__tsArray[4*e+3]=n}if(h.T.boneDataType===m.N.Vec4x2){const a=_.z.packNormalizedVec4ToVec2(n.x,n.y,n.z,n.w,Math.pow(2,12));this.__tqArray[4*e+0]=o.m03,this.__tqArray[4*e+1]=o.m13,this.__tqArray[4*e+2]=o.m23,this.__sqArray[4*e+0]=t.x,this.__sqArray[4*e+1]=t.y,this.__sqArray[4*e+2]=t.z,this.__tqArray[4*e+3]=a[0],this.__sqArray[4*e+3]=a[1]}else h.T.boneDataType===m.N.Vec4x2Old&&(this.__tsArray[4*e+0]=o.m03,this.__tsArray[4*e+1]=o.m13,this.__tsArray[4*e+2]=o.m23,this.__qArray[4*e+0]=n.x,this.__qArray[4*e+1]=n.y,this.__qArray[4*e+2]=n.z,this.__qArray[4*e+3]=n.w);if(h.T.boneDataType===m.N.Vec4x1){this.__tsArray[4*e+0]=o.m03,this.__tsArray[4*e+1]=o.m13,this.__tsArray[4*e+2]=o.m23;const t=_.z.packNormalizedVec4ToVec2(n.x,n.y,n.z,n.w,Math.pow(2,12));this.__qtsArray[4*e+0]=t[0],this.__qtsArray[4*e+1]=t[1]}}}if(h.T.boneDataType===m.N.Vec4x1){let e=1,t=1,n=1;for(let o=0;o<this.__joints.length;o++){const a=Math.abs(this.__tsArray[4*o+0]);a>e&&(e=a);const i=Math.abs(this.__tsArray[4*o+1]);i>t&&(t=i);const r=Math.abs(this.__tsArray[4*o+2]);r>n&&(n=r)}this.__qtsInfo.x=e,this.__qtsInfo.y=t,this.__qtsInfo.z=n,this.__qtsInfo.w=1;for(let o=0;o<this.__joints.length;o++){const a=this.__tsArray[4*o+0]/e,i=this.__tsArray[4*o+1]/t,r=this.__tsArray[4*o+2]/n,s=this.__tsArray[4*o+3],l=_.z.packNormalizedVec4ToVec2(a,i,r,s,Math.pow(2,12));this.__qtsArray[4*o+2]=l[0],this.__qtsArray[4*o+3]=l[1]}}}}__copyToMatArray(e,t){this.__matArray[12*t+0]=e._v[0],this.__matArray[12*t+1]=e._v[1],this.__matArray[12*t+2]=e._v[2],this.__matArray[12*t+3]=e._v[4],this.__matArray[12*t+4]=e._v[5],this.__matArray[12*t+5]=e._v[6],this.__matArray[12*t+6]=e._v[8],this.__matArray[12*t+7]=e._v[9],this.__matArray[12*t+8]=e._v[10],this.__matArray[12*t+9]=e._v[12],this.__matArray[12*t+10]=e._v[13],this.__matArray[12*t+11]=e._v[14]}getInverseBindMatricesAccessor(){return this.__inverseBindMatricesAccessor}_shallowCopyFrom(e){const t=e;this._jointIndices=t._jointIndices.concat(),this.setJoints(t.__joints.concat()),this.setJoints([]),this.__inverseBindMatricesAccessor=t.__inverseBindMatricesAccessor,p.Is.exist(t._bindShapeMatrix)&&(this._bindShapeMatrix=t._bindShapeMatrix.clone()),p.Is.exist(t.__jointMatrices)&&(this.__jointMatrices=t.__jointMatrices.concat()),this.topOfJointsHierarchy=t.topOfJointsHierarchy,this.isSkinning=t.isSkinning,this.__qArray.set(t.__qArray),this.__tsArray.set(t.__tsArray),this.__tqArray.set(t.__tqArray),this.__sqArray.set(t.__sqArray),this.__qtsArray.set(t.__qtsArray),this.__qtsInfo.copyComponents(t.__qtsInfo),this.__matArray.set(t.__matArray),this.__worldMatrix.copyComponents(t.__worldMatrix),this.__isWorldMatrixVanilla=t.__isWorldMatrixVanilla}get entity(){return a.YY.getEntity(this.__entityUid)}_destroy(){super._destroy()}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getSkeletal(){return this.getComponentByComponentTID(i.N.SkeletalComponentTID)}}return(0,a.XJ)(e,n),e}_getInverseBindMatrices(e){const t=this.__joints.indexOf(e),n=this.__inverseBindMatricesAccessor.getTypedArray();return new r._(n.slice(16*t,16*t+16))}}x.__globalDataRepository=d.q.getInstance(),x.__tookGlobalDataNum=0,x.__tmpVec3_0=l.tp.zero(),x.__tmp_mat4=f.g.identity(),x.__tmp_q=c.h.fromCopy4(0,0,0,1),x.__identityMat=f.g.identity()},1823:(e,t,n)=>{n.d(t,{W:()=>_});var o=n(8621),a=n(7503),i=n(4289),r=n(5368),s=n(6301),l=n(4956),c=n(6253);class _ extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__pose=new l.k,this.__updateCountAtLastLogic=0}static get renderedPropertyCount(){return null}static get componentTID(){return i.N.TransformComponentTID}get componentTID(){return i.N.TransformComponentTID}get restOrPose(){return void 0!==this.__rest?this.__rest:this.__pose}static get updateCount(){return this.__updateCount}_backupTransformAsRest(){void 0===this.__rest&&(this.__rest=this.__pose.clone(),this.entity.tryToGetSceneGraph().setWorldMatrixRestDirty())}_restoreTransformFromRest(){void 0!==this.__rest&&this.__pose.setTransform(this.__rest.positionInner,this.__rest.scaleInner,c.h.fromCopyQuaternion(this.__rest.rotationInner))}get localTransform(){return this.__pose}set localTransform(e){this.__pose.setTransform(e.positionInner,e.scaleInner,c.h.fromCopyQuaternion(e.rotationInner)),_.__updateCount++}get localTransformRest(){return this.restOrPose}set localTransformRest(e){s.Is.undefined(this.__rest)&&(this.__rest=new l.k),this.__rest.setTransform(e.positionInner,e.scaleInner,c.h.fromCopyQuaternion(e.rotationInner)),_.__updateCount++}set localPosition(e){this.__pose.position=e,_.__updateCount++}setLocalPositionAsArray3(e){this.__pose.setPositionAsArray3(e),_.__updateCount++}get localPosition(){return this.__pose.position}get localPositionInner(){return this.__pose.positionInner}set localPositionRest(e){s.Is.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.position=e,_.__updateCount++}get localPositionRest(){return this.restOrPose.position}get localPositionRestInner(){return this.restOrPose.positionInner}set localEulerAngles(e){this.__pose.eulerAngles=e,_.__updateCount++}get localEulerAngles(){return this.__pose.eulerAngles}get localEulerAnglesInner(){return this.__pose.eulerAnglesInner}set localEulerAnglesRest(e){s.Is.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.eulerAngles=e,_.__updateCount++}get localEulerAnglesRest(){return this.restOrPose.eulerAngles}get localEulerAnglesRestInner(){return this.restOrPose.eulerAnglesInner}set localScale(e){this.__pose.scale=e,_.__updateCount++}setLocalScaleAsArray3(e){this.__pose.setScaleAsArray3(e),_.__updateCount++}get localScale(){return this.__pose.scale}get localScaleInner(){return this.__pose.scaleInner}set localScaleRest(e){s.Is.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.scale=e,_.__updateCount++}get localScaleRest(){return this.restOrPose.scale}get localScaleRestInner(){return this.restOrPose.scaleInner}set localRotation(e){this.__pose.rotation=e,_.__updateCount++}setLocalRotationAsArray4(e){this.__pose.setRotationAsArray4(e),_.__updateCount++}get localRotation(){return this.__pose.rotation}get localRotationInner(){return this.__pose.rotationInner}set localRotationRest(e){s.Is.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.rotation=e,_.__updateCount++}get localRotationRest(){return this.restOrPose.rotation}get localRotationRestInner(){return this.restOrPose.rotationInner}set localMatrix(e){this.__pose.matrix=e,_.__updateCount++}get localMatrix(){return this.__pose.matrix}get localMatrixInner(){return this.__pose.matrixInner}getLocalMatrixInnerTo(e){this.__pose.getMatrixInnerTo(e)}set localMatrixRest(e){s.Is.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.matrix=e,_.__updateCount++}get localMatrixRest(){return this.restOrPose.matrix}get localMatrixRestInner(){return this.restOrPose.matrixInner}$load(){this.moveStageTo(r.O.Logic)}$logic(){this.__updateCountAtLastLogic!==this.__pose.updateCount&&(this.entity.tryToGetSceneGraph().setWorldMatrixDirty(),this.__updateCountAtLastLogic=this.__pose.updateCount)}_shallowCopyFrom(e){const t=e;this.__pose=t.__pose.clone(),null!=t.__rest&&(this.__rest=t.__rest.clone()),this.__updateCountAtLastLogic=t.__updateCountAtLastLogic,_.__updateCount++}get entity(){return a.YY.getEntity(this.__entityUid)}_destroy(){super._destroy()}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getTransform(){return void 0===this.__transformComponent&&(this.__transformComponent=this.getComponentByComponentTID(i.N.TransformComponentTID)),this.__transformComponent}set localPosition(e){this.getTransform().localPosition=e}get localPosition(){return this.localPositionInner.clone()}get localPositionInner(){return this.getTransform().localPositionInner}set localPositionRest(e){this.getTransform().localPositionRest=e}get localPositionRest(){return this.getTransform().localPositionRest}get localPositionRestInner(){return this.getTransform().localPositionRestInner}set localScale(e){this.getTransform().localScale=e}get localScale(){return this.localScaleInner.clone()}get localScaleInner(){return this.getTransform().localScaleInner}set localScaleRest(e){this.getTransform().localScaleRest=e}get localScaleRest(){return this.getTransform().localScaleRest}get localScaleRestInner(){return this.getTransform().localScaleRestInner}set localEulerAngles(e){this.getTransform().localEulerAngles=e}get localEulerAngles(){return this.localEulerAnglesInner.clone()}get localEulerAnglesInner(){return this.getTransform().localEulerAnglesInner}set localEulerAnglesRest(e){this.getTransform().localEulerAnglesRest=e}get localEulerAnglesRest(){return this.localEulerAnglesRestInner.clone()}get localEulerAnglesRestInner(){return this.getTransform().localEulerAnglesRestInner}set localRotation(e){this.getTransform().localRotation=e}get localRotation(){return this.localRotationInner.clone()}get localRotationInner(){return this.getTransform().localRotationInner}set localRotationRest(e){this.getTransform().localRotationRest=e}get localRotationRest(){return this.localQuaternionRestInner.clone()}get localRotationRestInner(){return this.getTransform().localRotationRestInner}set localMatrix(e){this.getTransform().localMatrix=e}get localMatrix(){return this.localMatrixInner.clone()}get localMatrixInner(){return this.getTransform().localMatrixInner}set localMatrixRest(e){this.getTransform().localMatrixRest=e}get localMatrixRest(){return this.localMatrixRestInner.clone()}get localMatrixRestInner(){return this.getTransform().localMatrixRestInner}}return(0,a.XJ)(e,n),e}}_.__updateCount=0},2253:(e,t,n)=>{n.d(t,{Y:()=>i});var o=n(7503),a=n(4289);function i(){const e=o.YY.createEntity();return o.YY.tryToAddComponentToEntityByTID(a.N.TransformComponentTID,e)}},1650:(e,t,n)=>{n.d(t,{W:()=>o.W,Y:()=>a.Y});var o=n(1823),a=n(2253)},1663:(e,t,n)=>{n.d(t,{r:()=>l});var o=n(8621),a=n(7503),i=n(5368),r=n(6301),s=n(4289);class l extends o.u{constructor(e,t,n,o){super(e,t,n,o),this.__expressions=new Map,this.__weights=new Map,this._version="",this.moveStageTo(i.O.Logic)}static get componentTID(){return s.N.VrmComponentTID}get componentTID(){return s.N.VrmComponentTID}setVrmExpressions(e){for(const t of e)this.__expressions.set(t.name,t),this.__weights.set(t.name,0)}setExpressionWeight(e,t){const n=this.__expressions.get(e);if(!r.Is.not.exist(n)){this.__weights.set(e,t);for(const e of n.binds){const n=a.YY.getEntity(e.entityIdx).tryToGetBlendShape();r.Is.exist(n)&&n.setWeightByIndex(e.blendShapeIdx,t)}}}getExpressionWeight(e){return this.__weights.get(e)}getExpressionNames(){return Array.from(this.__expressions.keys())}_shallowCopyFrom(e){const t=e;this.__expressions=new Map(t.__expressions),this.__weights=new Map(t.__weights),this._version=t._version}_destroy(){super._destroy()}addThisComponentToEntity(e,t){class n extends e.constructor{constructor(e,t,n){super(e,t,n)}getVrm(){return void 0===this.__vrmComponent&&(this.__vrmComponent=this.getComponentByComponentTID(s.N.VrmComponentTID)),this.__vrmComponent}}return(0,a.XJ)(e,n),e}}},4289:(e,t,n)=>{n.d(t,{N:()=>o});const o=Object.freeze({AnimationStateComponentTID:1,AnimationComponentTID:2,TransformComponentTID:3,SceneGraphComponentTID:4,MeshComponentTID:5,MeshRendererComponentTID:6,LightComponentTID:7,CameraControllerComponentTID:8,CameraComponentTID:9,SkeletalComponentTID:10,BlendShapeComponentTID:11,PhysicsComponentTID:12,EffekseerComponentTID:13,VrmComponentTID:14,ConstraintComponentTID:15,maxWellKnownTidNumber:15})},3050:(e,t,n)=>{n.d(t,{qf:()=>T,C6:()=>o.C,Wu:()=>i.W,np:()=>r.n,vZ:()=>l.v,WB:()=>E,i4:()=>S.i,Mm:()=>f.M,Fl:()=>h.F,ef:()=>m.e,le:()=>v.l,K:()=>y.K,DN:()=>w.D,WZ:()=>R.W,r0:()=>P.r,Nq:()=>_.N,TB:()=>u,vN:()=>s.v,PU:()=>x.P,Gi:()=>d.G,jw:()=>p.j,F6:()=>g,Hf:()=>C,Yd:()=>R.Y,S6:()=>a,gD:()=>b.g});var o=n(7566);const a="Default";var i=n(7193),r=n(7295),s=n(8321),l=n(4415),c=n(7503),_=n(4289);function u(){const e=(0,s.v)();return c.YY.tryToAddComponentToEntityByTID(_.N.CameraControllerComponentTID,e)}var f=n(6235),d=n(1257),h=n(9447),m=n(2805),p=n(2216),v=n(4155),x=n(8806);function g(){const e=(0,x.P)();return c.YY.tryToAddComponentToEntityByTID(_.N.PhysicsComponentTID,e)}var y=n(4317),b=n(1614),I=n(6227),A=n(2229);class E{constructor(e){this.__srcEntity=e}getEntity(){return this.__srcEntity}getSrcPGRestQ(e){let t;const n=e.getSceneGraph().parent;return t=A.Is.exist(n)?n.getRotationRest((e=>{const t=e.parent;if(A.Is.exist(t)){const e=t.entity.tryToGetVrm();return A.Is.exist(e)}return!0})):I.PT.identity(),t}getDstPGRestQ(e){let t;const n=e.getSceneGraph().parent;return t=A.Is.exist(n)?n.getRotationRest((e=>{const t=e.parent;if(A.Is.exist(t)){const e=t.entity.tryToGetVrm();return A.Is.exist(e)}return!0})):I.PT.identity(),t}retargetQuaternion(e){const t=this.__srcEntity,n=t.getTransform().localRotationInner,o=t.getTransform().localRotationRestInner,a=this.getSrcPGRestQ(t),i=I.PT.multiply(a,I.PT.multiply(n,I.PT.multiply(I.PT.invert(o),I.PT.invert(a)))),r=e.getTransform().localRotationRestInner,s=this.getDstPGRestQ(e);return I.PT.multiply(I.PT.invert(s),I.PT.multiply(i,I.PT.multiply(s,r)))}retargetTranslate(e){const t=this.__srcEntity,n=t.getTransform().localPositionInner,o=t.getTransform().localPositionRestInner,a=this.getSrcPGRestQ(t),i=I.Pq.subtract(n,o),r=a.transformVector3(i),s=e.getTransform().localPositionRestInner,l=this.getDstPGRestQ(e),c=I.Pq.add(l.transformVector3Inverse(r),s);return t.uniqueName.indexOf("hips")>=0?I.Pq.multiply(c,t.parent.scale.x):c}retargetScale(e){return this.__srcEntity.getTransform().localScaleInner}}var S=n(4507);class T{constructor(e){this.__srcEntity=e}getEntity(){return this.__srcEntity}retargetQuaternion(e){return this.__srcEntity.getTransform().localRotationInner}retargetTranslate(e){return this.__srcEntity.getTransform().localPositionInner}retargetScale(e){return this.__srcEntity.getTransform().localScaleInner}}var w=n(847);function C(){const e=(0,x.P)();return c.YY.tryToAddComponentToEntityByTID(_.N.SkeletalComponentTID,e)}var R=n(1650),P=n(1663),N=n(5012),M=n(6737),D=n(103),F=n(5999),B=n(1823);M.O.registerComponentClass(D.v),M.O.registerComponentClass(o.C),M.O.registerComponentClass(B.W),M.O.registerComponentClass(y.K),M.O.registerComponentClass(h.F),M.O.registerComponentClass(m.e),M.O.registerComponentClass(f.M),M.O.registerComponentClass(l.v),M.O.registerComponentClass(r.n),M.O.registerComponentClass(w.D),M.O.registerComponentClass(i.W),M.O.registerComponentClass(v.l),M.O.registerComponentClass(N.a),M.O.registerComponentClass(P.r),M.O.registerComponentClass(F.J)},8621:(e,t,n)=>{n.d(t,{u:()=>_});var o=n(7496),a=n(5368),i=n(6737),r=n(5338),s=n(8819),l=n(8556),c=n(6301);class _ extends s.E{constructor(e,t,n,i){super(),this._isAlive=!0,this.__currentProcessStage=a.O.Load,this.__byteOffsetOfThisComponent=-1,this.__maxComponentNumber=r.T.maxEntityNumber,this.__entityUid=e,this._component_sid=t,_._processStages,this.__memoryManager=o.X.getInstance(),this.__entityRepository=n}moveStageTo(e){this.__currentProcessStage=e}_setMaxNumberOfComponent(e){this.__maxComponentNumber=e}get maxNumberOfComponent(){return this.__maxComponentNumber}static get componentTID(){return 0}get componentTID(){return 0}get componentSID(){return this._component_sid}get entityUID(){return this.__entityUid}get currentProcessStage(){return this.__currentProcessStage}static doesTheProcessStageMethodExist(e,t){return null!=e.prototype[t.methodName]}isExistProcessStageMethod(e){return null!=this[e.methodName]}static process(e,t){if(!_.doesTheProcessStageMethodExist(e,t))return;const n=t.methodName,o=i.O.getComponentsWithType(e);for(const e of o)t===e.__currentProcessStage&&e[n]()}static updateComponentsForRenderStage(e,t,n){return(0,e.sort_$render)(n)}static getByteLengthSumOfMembers(e,t){return this.__byteLengthSumOfMembers.get(t).get(e)}registerDependency(e,t){}takeOne(e,t,n,o,a){if(!this["_"+e].isDummy())return;let i;i=o?_.__accessors.get(this.constructor).get(e)._takeExistedOne(a):_.__accessors.get(this.constructor).get(e).takeOne(),this["_"+e]=new t(i,!1,!0);for(let t=0;t<this["_"+e]._v.length;++t)this["_"+e]._v[t]=n[t];return null}static getAccessor(e,t){return this.__accessors.get(t).get(e)}static takeAccessor(e,t,n,a,i,r){this.__accessors.has(n)||this.__accessors.set(n,new Map);const s=this.__accessors.get(n);if(s.has(t))return new l._({message:"Already taken",error:void 0});{const n=a.getNumberOfComponents()*i.getSizeInBytes(),c=o.X.getInstance().createOrGetBuffer(e).takeBufferView({byteLengthToNeed:n*r,byteStride:0});if(c.isErr())return new l._({message:"Failed to take buffer view: "+c.getRnError().message,error:void 0});const _=c.get().takeAccessor({compositionType:a,componentType:i,count:r,byteStride:n});return _.isErr()?new l._({message:"Failed to take accessor: "+_.getRnError().message,error:void 0}):(s.set(t,_.get()),_)}}static getByteOffsetOfThisComponentTypeInBuffer(e,t){return this.__bufferViews.get(t).get(e).byteOffsetInBuffer}static getByteOffsetOfFirstOfThisMemberInBuffer(e,t){return this.__accessors.get(t).get(e).byteOffsetInBuffer}static getByteOffsetOfFirstOfThisMemberInBufferView(e,t){return this.__accessors.get(t).get(e).byteOffsetInBufferView}registerMember(e,t,n,o,a){_.__memberInfo.has(this.constructor)||_.__memberInfo.set(this.constructor,[]),_.__memberInfo.get(this.constructor).push({bufferUse:e,memberName:t,dataClassType:n,compositionType:n.compositionType,componentType:o,initValues:a})}submitToAllocation(e,t){if(this._component_sid>=e){const e=this.constructor;console.error(`%c${e.name}: The number of components is over the limit. This may lead to incorrect processing results. Please consider to increase the limit. You can set the limit on Rn.Config.xxxxxx.`,"color: red; background: yellow; font-size: 2em;")}const n=this.constructor,o=_.__memberInfo.get(n);0===this._component_sid&&function(t){_.__members.has(n)||_.__members.set(n,new Map);const a=_.__members.get(n);o.forEach((e=>{a.set(e.bufferUse,[])})),o.forEach((e=>{a.get(e.bufferUse).push(e)}));for(const e of a.keys()){const t=a.get(e);_.__byteLengthSumOfMembers.has(n)||_.__byteLengthSumOfMembers.set(n,new Map);const o=_.__byteLengthSumOfMembers.get(n);o.has(e)||o.set(e,0),t.forEach((t=>{o.set(e,o.get(e)+t.compositionType.getNumberOfComponents()*t.componentType.getSizeInBytes())})),t.length}for(const o of a.keys())a.get(o).forEach((o=>{const a=_.takeAccessor(o.bufferUse,o.memberName,n,o.compositionType,o.componentType,e);if(a.isErr())throw new c.OD(a.getRnError());t["_byteOffsetOfAccessorInBuffer_"+o.memberName]=a.get().byteOffsetInBuffer,t["_byteOffsetOfAccessorInComponent_"+o.memberName]=a.get().byteOffsetInBufferView}))}(this);const a=_.__members.get(n);for(const e of a.keys())a.get(e).forEach((e=>{this.takeOne(e.memberName,e.dataClassType,e.initValues,t,this._component_sid)}))}get entity(){return this.__entityRepository.getEntity(this.__entityUid)}static getDataByteInfoInner(e,t){const n=e["_"+t]._v,o=n.byteOffset,a=n.byteLength,i=n.length,r=o/4/4;return{byteLength:a,byteOffsetInBuffer:o,byteOffsetInThisComponent:this["_byteOffsetOfAccessorInComponent_"+t]+e.componentSID*i*4,locationOffsetInBuffer:r,locationOffsetInThisComponent:this["_byteOffsetOfAccessorInComponent_"+t]+e.componentSID*i,thisComponentByteOffsetInBuffer:e.__byteOffsetOfThisComponent,thisComponentLocationOffsetInBuffer:e.__byteOffsetOfThisComponent/4/4,componentNumber:i}}getDataByteInfo(e){return _.getDataByteInfoInner(this,e)}static getDataByteInfoByComponentSID(e,t,n){const o=i.O.getComponent(e,t);if(o)return _.getDataByteInfoInner(o,n)}static getLocationOffsetOfMemberOfComponent(e,t){return i.O.getComponent(e,0)["_byteOffsetOfAccessorInBuffer_"+t]/4/4}addThisComponentToEntity(e,t){throw"Invalid Calling"}static getCompositionTypeOfMember(e,t){const n=this.__memberInfo.get(t).find((t=>t.memberName===e));return null!=n?n.compositionType:void 0}static getComponentTypeOfMember(e,t){const n=this.__memberInfo.get(t).find((t=>t.memberName===e));return null!=n?n.componentType:void 0}_destroy(){this._isAlive=!1}_shallowCopyFrom(e){}}_.__bufferViews=new Map,_.__accessors=new Map,_.__byteLengthSumOfMembers=new Map,_.__memberInfo=new Map,_.__members=new Map,_._processStages=[a.O.Load,a.O.Logic,a.O.Render]},6737:(e,t,n)=>{n.d(t,{O:()=>r});var o=n(2229),a=n(5338),i=n(4289);class r{constructor(){}static registerComponentClass(e){r.__componentClasses.set(e.componentTID,e)}static deregisterComponentClass(e){r.__componentClasses.delete(e)}static getComponentClass(e){return this.__componentClasses.get(e)}static createComponent(e,t,n){const a=r.__componentClasses.get(e);if(o.Is.exist(a)){let i=this.__component_sid_count_map.get(e);o.Is.not.exist(i)&&(this.__component_sid_count_map.set(e,0),i=r.invalidComponentSID);const s=this.__components.get(e);let l=-1;if(o.Is.exist(s))for(let e=0;e<s.length;e++)if(o.Is.not.exist(s[e])){l=e;break}let c=-1,_=!1;-1===l?(this.__component_sid_count_map.set(e,++i),c=i):(c=l,_=!0);const u=new a(t,c,n,_);return this.__components.has(e)||(this.__components.set(e,[]),this.__updateComponentTIDs()),this.__components.get(e)[u.componentSID]=u,u}throw new Error("The Component Class object is invalid.")}static deleteComponent(e){const t=r,n=e.componentTID,o=e.componentSID,a=t.__components.get(n);null!=a&&delete a[o]}static getComponent(e,t){return this.getComponentFromComponentTID(e.componentTID,t)}static getComponentFromComponentTID(e,t){const n=this.__components.get(e);if(null!=n)return null!=n[t]?n[t]:void 0}static _getComponents(e){return this.__components.get(e.componentTID)}static _getComponentsIncludingDead(e){return this.__components.get(e.componentTID)}static getMemoryBeginIndex(e){let t=0;for(let n=0;n<e;n++){const e=r.__componentClasses.get(n);null!=e&&(t+=e.sizeOfThisComponent*a.T.maxEntityNumber)}return t}static getComponentsWithType(e){const t=this.__components.get(e.componentTID);return null==t?[]:t.filter((e=>null!=e))}static __updateComponentTIDs(){const e=Array.from(this.__components.keys());e.sort(((e,t)=>e-t)),this.__componentTIDs=e;const t=[];t.push(i.N.MeshRendererComponentTID),this.__components.has(i.N.EffekseerComponentTID)&&t.push(i.N.EffekseerComponentTID),this.__renderingComponentTIDs=t}static getComponentTIDs(){return this.__componentTIDs}static getRenderingComponentTIDs(){return this.__renderingComponentTIDs}}r.__component_sid_count_map=new Map,r.__components=new Map,r.__componentClasses=new Map,r.__componentTIDs=[],r.__renderingComponentTIDs=[],r.invalidComponentSID=-1},5338:(e,t,n)=>{n.d(t,{T:()=>_});var o=n(6195),a=n(6301);let i=41,r=33,s=Math.pow(2,12),l=Math.pow(2,12),c=o.N.Mat43x1;"undefined"!=typeof navigator&&(a.zH.isMobile()||a.zH.isMobileVr())&&(i=4,r=32,s=512,l=512);const _={maxEntityNumber:5e3,maxLightNumberInShader:4,maxVertexMorphNumberInShader:i,maxVertexPrimitiveNumberInShader:10,maxMaterialInstanceForEachType:10,boneDataType:c,maxSkeletonNumber:r,maxCameraNumber:30,maxSizeLimitOfNonCompressedTexture:512,maxSkeletalBoneNumber:300,maxSkeletalBoneNumberForUniformMode:50,dataTextureWidth:s,dataTextureHeight:l,maxMorphTargetNumber:4,totalSizeOfGPUShaderDataStorageExceptMorphData:0,isUboEnabled:!1,eventTargetDom:void 0,cacheWebGpuRenderBundles:!0,cgApiDebugConsoleOutput:!1,multiViewForWebVR:!1,physicsTimeIntervalScale:1,vrmSpringBoneBonAxisCoeff:.5,vrmSpringBoneToCoeff:.4,isMobile:!1}},8223:(e,t,n)=>{n.d(t,{w:()=>r});var o=n(8819),a=n(2229),i=n(4289);class r extends o.E{constructor(e,t,n){super(),this._myLatestCopyEntityUID=r.invalidEntityUID,this.___entity_uid=e,this._isAlive=t,this.__components=a.Is.exist(n)?n:new Map}get entityUID(){return this.___entity_uid}_setComponent(e,t){this.__components.set(e.componentTID,t)}hasComponent(e){return this.__components.has(e.componentTID)}getComponent(e){return this.__components.get(e.componentTID)}getComponentByComponentTID(e){return this.__components.get(e)}_removeComponent(e){this.__components.delete(e)}tryToGetAnimation(){return this.getComponentByComponentTID(i.N.AnimationComponentTID)}tryToGetAnimationState(){return this.getComponentByComponentTID(i.N.AnimationStateComponentTID)}tryToGetBlendShape(){return this.getComponentByComponentTID(i.N.BlendShapeComponentTID)}tryToGetCamera(){return this.getComponentByComponentTID(i.N.CameraComponentTID)}tryToGetCameraController(){return this.getComponentByComponentTID(i.N.CameraControllerComponentTID)}tryToGetLight(){return this.getComponentByComponentTID(i.N.LightComponentTID)}tryToGetMesh(){return this.getComponentByComponentTID(i.N.MeshComponentTID)}tryToGetMeshRenderer(){return this.getComponentByComponentTID(i.N.MeshRendererComponentTID)}tryToGetPhysics(){return this.getComponentByComponentTID(i.N.PhysicsComponentTID)}tryToGetSceneGraph(){return this.getComponentByComponentTID(i.N.SceneGraphComponentTID)}tryToGetSkeletal(){return this.getComponentByComponentTID(i.N.SkeletalComponentTID)}tryToGetTransform(){return this.getComponentByComponentTID(i.N.TransformComponentTID)}tryToGetVrm(){return this.getComponentByComponentTID(i.N.VrmComponentTID)}tryToGetConstraint(){return this.getComponentByComponentTID(i.N.ConstraintComponentTID)}tryToGetEffekseer(){return this.getComponentByComponentTID(i.N.EffekseerComponentTID)}_destroy(){this.__components.forEach((e=>{e._destroy()})),this._isAlive=!1}}r.invalidEntityUID=-1},7503:(e,t,n)=>{n.d(t,{S$:()=>u,XJ:()=>_,YY:()=>c});var o=n(8223),a=n(6737),i=n(7681),r=n(2229),s=n(4289),l=n(6301);class c{constructor(){}static createEntity(){let e=-1;for(let t=0;t<this.__entities.length;t++)null==this.__entities[t]&&(e=t);let t=-1;t=-1===e?++this.__entity_uid_count:e;const n=new o.w(t,!0);return this.__entities[t]=n,this.__updateCount++,n}static deleteEntity(e){var t;if(!r.Is.not.exist(this._components[e])){for(const[t,n]of this._components[e]){if(t===s.N.SceneGraphComponentTID){const e=n.children.concat();for(const t of e)c.deleteEntity(t.entity.entityUID)}a.O.deleteComponent(n)}null===(t=this.__entities[e])||void 0===t||t._destroy(),delete this.__entities[e],delete this._components[e],this.__updateCount++}}static deleteEntityRecursively(e){const t=this.getEntity(e),n=[],o=t.tryToGetSceneGraph();null!=o&&(n.push(o.entity),function e(t){const o=t.children;for(let t=0;t<o.length;t++){const a=o[t];n.push(a.entity),e(a)}}(o));for(const e of n)c.deleteEntity(e.entityUID)}static shallowCopyEntity(e){const t=c._shallowCopyEntityInner(e);return this.__setJoints(e),this.__handleTagData(t),t}static __setJoints(e){const t=c.getEntity(e._myLatestCopyEntityUID).getComponentByComponentTID(s.N.SkeletalComponentTID),n=e.getComponentByComponentTID(s.N.SkeletalComponentTID);if(r.Is.exist(t)&&r.Is.exist(n)){const e=n.getJoints().map((e=>c.getEntity(e.entity._myLatestCopyEntityUID).tryToGetSceneGraph()));t.setJoints(e)}const o=e.tryToGetSceneGraph();r.Is.exist(o)&&o.children.forEach((e=>{c.__setJoints(e.entity)}))}static _shallowCopyEntityInner(e){const t=this.createEntity();t._tags=Object.assign({},e._tags),e._myLatestCopyEntityUID=t.entityUID;for(let n=1;n<=s.N.maxWellKnownTidNumber;n++){const o=e.getComponentByComponentTID(n);if(r.Is.exist(o)){this.tryToAddComponentToEntityByTID(n,t);const e=t.getComponentByComponentTID(n);r.Is.exist(e)&&e._shallowCopyFrom(o)}}return t}static __handleTagData(e){const t=e._tags;if(r.Is.exist(t)){const n=Object.keys(t);for(const t of n){if("rnEntities"===t){const t=e.getTagValue("rnEntities").map((e=>c.getEntity(e._myLatestCopyEntityUID)));e.tryToSetTag({tag:"rnEntities",value:t})}if("rnEntitiesByNames"===t){const t=e.getTagValue("rnEntitiesByNames");for(const e of Object.keys(t)){const n=t.get(e);t.set(e,c.getEntity(n._myLatestCopyEntityUID))}e.tryToSetTag({tag:"rnEntitiesByNames",value:t})}}}const n=e.tryToGetSceneGraph();r.Is.exist(n)&&n.children.forEach((e=>{c.__handleTagData(e.entity)}))}static tryToAddComponentToEntityByTID(e,t){const n=a.O.getComponentClass(e);return r.Is.not.exist(n)?t:this.addComponentToEntity(n,t)}static addComponentToEntity(e,t){if(t.hasComponent(e))return l.Vy.info("This entity already has the Component."),t;const n=a.O.createComponent(e.componentTID,t.entityUID,this);return(0,i.Cw)({value:this._components[t.entityUID],compensation:()=>this._components[t.entityUID]=new Map}).set(e.componentTID,n),n.addThisComponentToEntity(t,e),t._setComponent(e,n),this.__updateCount++,t}static removeComponentFromEntity(e,t){let n=this._components[t.entityUID];null==n&&(n=new Map,this._components[t.entityUID]=n);const o=n.get(e.componentTID);return r.Is.exist(o)&&(o._destroy(),n.delete(e.componentTID),t._removeComponent(e.componentTID)),this.__updateCount++,t}static getEntity(e){return this.__entities[e]}getEntity(e){return c.__entities[e]}static getComponentOfEntity(e,t){const n=this._components[e];let o=null;return null!=n?(o=n.get(t.componentTID),null!=o?o:null):o}static searchByTags(e){const t=[];for(const n of this.__entities)(null==n?void 0:n.matchTags(e))&&t.push(n);return t}static getEntityByUniqueName(e){for(const t of this.__entities)if(null!=t&&t.uniqueName===e)return t}static _getEntities(){return this.__entities.filter((e=>null!=e&&e._isAlive))}static getEntitiesNumber(){return this.__entities.filter((e=>null!=e&&e._isAlive)).length}static get updateCount(){return this.__updateCount}}function _(e,t){Object.getOwnPropertyNames(t.prototype).forEach((n=>{Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t.prototype,n)||Object.create(null))}))}function u(){return c.createEntity()}c.__entity_uid_count=o.w.invalidEntityUID,c.__entities=[],c._components=[],c.__updateCount=0},3107:(e,t,n)=>{n.d(t,{q:()=>b});var o=n(7616),a=n(7496),i=n(7751),r=n(4114),s=n(8805),l=n(4772),c=n(4132),_=n(1124),u=n(5338),f=n(9011),d=n(3414),h=n(975),m=n(7476),p=n(4289),v=n(6195),x=n(3212),g=n(4127),y=n(6227);class b{constructor(){this.__fields=new Map}initialize(e){const t={semantic:"currentComponentSIDs",compositionType:i.h.ScalarArray,componentType:r.I.Float,arrayLength:p.N.maxWellKnownTidNumber,stage:c.C.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,needUniformInDataTextureMode:!0,initialValue:new _.u(new Float32Array(p.N.maxWellKnownTidNumber))};this.__registerProperty(t,1),this.takeOne("currentComponentSIDs");const n={semantic:"viewMatrix",compositionType:i.h.Mat4,componentType:r.I.Float,stage:c.C.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:m.g.identity()},o={semantic:"projectionMatrix",compositionType:i.h.Mat4,componentType:r.I.Float,stage:c.C.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:m.g.identity()},a={semantic:"viewPosition",compositionType:i.h.Vec3,componentType:r.I.Float,stage:c.C.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:h.Pq.fromCopyArray([0,0,1])};this.__registerProperty(n,u.T.maxCameraNumber),this.__registerProperty(o,u.T.maxCameraNumber),this.__registerProperty(a,u.T.maxCameraNumber);const s=x.m.isUniformApproach(e)?u.T.maxSkeletalBoneNumberForUniformMode:u.T.maxSkeletalBoneNumber,l={semantic:"boneMatrix",compositionType:i.h.Mat4x3Array,arrayLength:s,componentType:r.I.Float,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,soloDatum:!0,initialValue:new _.u(new Float32Array(0))},g={semantic:"boneQuaternion",compositionType:i.h.Vec4Array,arrayLength:s,componentType:r.I.Float,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,soloDatum:!0,initialValue:new _.u(new Float32Array(0))},b={semantic:"boneTranslateScale",compositionType:i.h.Vec4Array,arrayLength:s,componentType:r.I.Float,soloDatum:!0,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new _.u(new Float32Array(0))},I={semantic:"boneTranslatePackedQuat",compositionType:i.h.Vec4Array,arrayLength:s,componentType:r.I.Float,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,soloDatum:!0,initialValue:new _.u(new Float32Array(0))},A={semantic:"boneScalePackedQuat",compositionType:i.h.Vec4Array,arrayLength:s,componentType:r.I.Float,soloDatum:!0,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new _.u(new Float32Array(0))},E={semantic:"boneCompressedChunk",compositionType:i.h.Vec4Array,arrayLength:s,componentType:r.I.Float,soloDatum:!0,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new _.u(new Float32Array(0))},S={semantic:"boneCompressedInfo",compositionType:i.h.Vec4,componentType:r.I.Float,soloDatum:!0,stage:c.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:d.IU.zero()},T={semantic:"skinningMode",compositionType:i.h.Scalar,componentType:r.I.Int,stage:c.C.VertexAndPixelShader,min:0,max:1,isInternalSetting:!0,initialValue:f.X5.fromCopyNumber(-1)};u.T.boneDataType===v.N.Mat43x1?this.__registerProperty(l,u.T.maxSkeletonNumber):u.T.boneDataType===v.N.Vec4x2?(this.__registerProperty(I,u.T.maxSkeletonNumber),this.__registerProperty(A,u.T.maxSkeletonNumber)):u.T.boneDataType===v.N.Vec4x2Old?(this.__registerProperty(g,u.T.maxSkeletonNumber),this.__registerProperty(b,u.T.maxSkeletonNumber)):u.T.boneDataType===v.N.Vec4x1&&(this.__registerProperty(b,u.T.maxSkeletonNumber),this.__registerProperty(E,u.T.maxSkeletonNumber),this.__registerProperty(S,1),this.takeOne("boneCompressedInfo")),this.__registerProperty(T,1),this.takeOne("skinningMode");const w={semantic:"lightPosition",compositionType:i.h.Vec3Array,componentType:r.I.Float,stage:c.C.VertexAndPixelShader,arrayLength:u.T.maxLightNumberInShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new _.u(new Float32Array(u.T.maxLightNumberInShader))},C={semantic:"lightDirection",compositionType:i.h.Vec3Array,componentType:r.I.Float,stage:c.C.PixelShader,arrayLength:u.T.maxLightNumberInShader,min:-1,max:1,isInternalSetting:!0,initialValue:new _.u(new Float32Array(u.T.maxLightNumberInShader))},R={semantic:"lightIntensity",compositionType:i.h.Vec3Array,componentType:r.I.Float,stage:c.C.PixelShader,arrayLength:u.T.maxLightNumberInShader,min:0,max:10,isInternalSetting:!0,initialValue:new _.u(new Float32Array(u.T.maxLightNumberInShader))},P={semantic:"lightProperty",compositionType:i.h.Vec4Array,componentType:r.I.Float,stage:c.C.PixelShader,arrayLength:u.T.maxLightNumberInShader,min:0,max:10,isInternalSetting:!0,initialValue:new _.u(new Float32Array(u.T.maxLightNumberInShader))};this.__registerProperty(w,1),this.__registerProperty(C,1),this.__registerProperty(R,1),this.__registerProperty(P,1),this.takeOne("lightDirection"),this.takeOne("lightIntensity"),this.takeOne("lightPosition"),this.takeOne("lightProperty");const N={semantic:"lightNumber",compositionType:i.h.Scalar,componentType:r.I.Int,stage:c.C.VertexAndPixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,initialValue:f.X5.fromCopyNumber(0)};this.__registerProperty(N,1),this.takeOne("lightNumber");const M={semantic:"backBufferTextureSize",compositionType:i.h.Vec2,componentType:r.I.Float,stage:c.C.PixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,needUniformInDataTextureMode:!0,initialValue:y.I9.fromCopy2(0,0)};this.__registerProperty(M,1),this.takeOne("backBufferTextureSize");const D={semantic:"vrState",compositionType:i.h.Vec2,componentType:r.I.Int,stage:c.C.PixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,needUniformInDataTextureMode:!0,initialValue:y.I9.fromCopy2(0,0)};this.__registerProperty(D,1),this.takeOne("vrState");const F={semantic:"time",compositionType:i.h.Scalar,componentType:r.I.Float,stage:c.C.VertexAndPixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,initialValue:f.X5.fromCopyNumber(0)};this.__registerProperty(F,1),this.takeOne("time")}static getInstance(){return this.__instance||(this.__instance=new b),this.__instance}__registerProperty(e,t){const n=a.X.getInstance().createOrGetBuffer(o.a.GPUInstanceData),s=(0,g.o)(e),l=n.takeBufferView({byteLengthToNeed:s*t,byteStride:0}).unwrapForce();let c=e.arrayLength;i.h.isArray(e.compositionType)&&null==c&&(c=100);const _={shaderSemanticsInfo:e,values:[],maxCount:t,accessor:l.takeAccessor({compositionType:e.compositionType,componentType:r.I.Float,count:t,byteStride:s,arrayLength:c}).unwrapForce()};this.__fields.set(e.semantic,_)}takeOne(e){const t=this.__fields.get(e);if(t){const e=t.shaderSemanticsInfo,n=t.accessor.takeOne(),o=t.values.length,a=s.n.initWithFloat32Array(e.initialValue,e.initialValue,n,e.compositionType);return t.values[o]=a,a}}setValue(e,t,n){const o=this.__fields.get(e);if(o){const e=o.values[t];s.n._setForce(e,n)}}getValue(e,t){const n=this.__fields.get(e);if(n)return n.values[t]}getGlobalPropertyStruct(e){return this.__fields.get(e)}getGlobalProperties(){return Array.from(this.__fields.values())}_setUniformLocationsForUniformModeOnly(e){const t=l.f.getWebGLResourceRepository(),n=[];this.__fields.forEach(((e,t)=>{const o=e.shaderSemanticsInfo;n.push(o)})),t.setupUniformLocations(e,n,!0)}_setUniformLocationsForDataTextureModeOnly(e){const t=l.f.getWebGLResourceRepository(),n=[];this.__fields.forEach(((e,t)=>{const o=e.shaderSemanticsInfo;o.needUniformInDataTextureMode&&n.push(o)})),t.setupUniformLocations(e,n,!0)}setUniformValues(e){const t=l.f.getWebGLResourceRepository();this.__fields.forEach(((n,o)=>{const a=n.shaderSemanticsInfo,i=n.values;for(let n=0;n<i.length;n++)t.setUniformValue(e,a.semantic,!0,i[n])}))}getLocationOffsetOfProperty(e){const t=this.__fields.get(e);return t?t.accessor.byteOffsetInBuffer/4/4:-1}getCurrentDataNumberOfTheProperty(e){const t=this.__fields.get(e);return t?t.values.length:0}_addPropertiesStr(e,t,n,o){return this.__fields.forEach((a=>{const i=a.shaderSemanticsInfo;i.stage!==c.C.VertexShader&&i.stage!==c.C.VertexAndPixelShader||(e+=n("",i,!0,o)),i.stage!==c.C.PixelShader&&i.stage!==c.C.VertexAndPixelShader||(t+=n("",i,!0,o))})),[e,t]}}},7496:(e,t,n)=>{n.d(t,{X:()=>s});var o=n(4066),a=n(7616),i=n(5338),r=n(7681);class s{constructor(e,t,n){this.__buffers={},this.__buffersOnDemand=new Map,this.__memorySizeRatios={},this.__memorySizeRatios[a.a.CPUGeneric.str]=e,this.__memorySizeRatios[a.a.GPUInstanceData.str]=t,this.__memorySizeRatios[a.a.GPUVertexData.str]=n}static createInstanceIfNotCreated({cpuGeneric:e,gpuInstanceData:t,gpuVertexData:n}){return this.__instance||(this.__instance=new s(e,t,n)),this.__instance}__makeMultipleOf4byteSize(e){return e+(e%4==0?0:4-e%4)}static getInstance(){return this.__instance}getMemorySize(){return s.bufferWidthLength*s.bufferHeightLength*4*4}__createBuffer(e){const t=this.getMemorySize()*this.__memorySizeRatios[e.str],n=new ArrayBuffer(this.__makeMultipleOf4byteSize(t));let i=4;e!==a.a.GPUInstanceData&&e!==a.a.GPUVertexData||(i=16);const r=new o.h({byteLength:n.byteLength,buffer:n,name:e.str,byteAlign:i});return this.__buffers[r.name]=r,r}getBuffer(e){return this.__buffers[e.toString()]}createOrGetBuffer(e){let t=this.__buffers[e.toString()];return null==t&&(t=this.__createBuffer(e)),t}createBufferOnDemand(e,t,n){const i=new ArrayBuffer(e),r=new o.h({byteLength:i.byteLength,buffer:i,name:a.a.UBOGeneric.toString(),byteAlign:n});return this.__buffersOnDemand.set(t.objectUID,r),r}getBufferOnDemand(e){return this.__buffersOnDemand.get(e.objectUID)}static get bufferWidthLength(){return i.T.dataTextureWidth}static get bufferHeightLength(){return i.T.dataTextureHeight}printMemoryUsage(){const e=this.__buffers[a.a.CPUGeneric.toString()],t=this.__buffers[a.a.GPUInstanceData.toString()],n=this.__buffers[a.a.GPUVertexData.toString()];console.log("Memory Usage in Memory Manager:"),console.log(`CPUGeneric: ${e.takenSizeInByte} byte of ${e.byteLength} bytes. (${e.takenSizeInByte/e.byteLength*100} %) `),console.log(`GPUInstanceData: ${t.takenSizeInByte} byte of ${t.byteLength} bytes. (${t.takenSizeInByte/t.byteLength*100} %) `),null!=n&&console.log(`GPUVertexData: ${n.takenSizeInByte} byte of ${n.byteLength} bytes. (${n.takenSizeInByte/n.byteLength*100} %) `)}dumpBuffer(e){const t=this.__buffers[e.toString()];return r.zH.downloadArrayBuffer(e.toString(),t.getArrayBuffer()),t}}},8819:(e,t,n)=>{n.d(t,{E:()=>a});var o=n(7681);class a{constructor(){this.__objectUid=a.currentMaxObjectCount++,this._tags={},this.__combinedTagString="",this.__uniqueName=`${this.constructor.name}__uid_${this.__objectUid}`,this.__updateInfo(this.__uniqueName)}__updateInfo(e){a.__uniqueNames[this.__objectUid]=e,a.__objects[this.__objectUid]=new WeakRef(this),a.__objectsByNameMap.set(this.__uniqueName,new WeakRef(this))}unregister(){delete a.__objects[this.__objectUid],delete a.__uniqueNames[this.__objectUid],a.__objectsByNameMap.delete(this.__uniqueName)}static searchByTag(e,t){var n;for(const o of a.__objects)if((null===(n=o.deref())||void 0===n?void 0:n.getTagValue(e))===t)return o}get objectUID(){return this.__objectUid}static getRnObject(e){var t;return null===(t=a.__objects[e])||void 0===t?void 0:t.deref()}static getRnObjectByName(e){var t;return null===(t=a.__objectsByNameMap.get(e))||void 0===t?void 0:t.deref()}tryToSetUniqueName(e,t){if(-1!==a.__uniqueNames.indexOf(e)){if(t){const t=e+"_("+this.__objectUid+")";if(-1===a.__uniqueNames.indexOf(t))return a.__objectsByNameMap.delete(this.__uniqueName),this.__uniqueName=t,a.__uniqueNames[this.__objectUid]=this.__uniqueName,a.__objectsByNameMap.set(this.__uniqueName,new WeakRef(this)),!0}return!1}return this.__uniqueName=e,a.__uniqueNames[this.__objectUid]=this.__uniqueName,a.__objectsByNameMap.set(this.__uniqueName,new WeakRef(this)),!0}validateTagString(e){return!new RegExp(/[!"#$%&'()\*\+\-\s\.,\/:;<=>?@\[\\\]^`{|}~]/g).test(e)}tryToSetTag(e){return!!this.validateTagString(e.tag)&&(this.hasTag(e.tag)&&this.removeTag(e.tag),this._tags[e.tag]=e.value,this.__combinedTagString+=`${e.tag}:${e.value} `,!0)}getTagValue(e){return this._tags[e]}getTag(e){return{tag:e,value:this._tags[e]}}hasTag(e){return null!=this._tags[e]}removeTag(e){this._tags[e],this.__combinedTagString.replace(this.__combinedTagString,""),delete this._tags[e]}matchTag(e,t){return this._tags[e]===t}matchTagsAsFreeStrings(e){let t="^";for(let n=0;n<e.length;n++)t+=`(?=.*${e[n]})`;return!!new RegExp(t).test(this.__combinedTagString)}matchTags(e){let t="^";for(const n in e)t+=`(?=.*${[n]}:${e[n]})`;return!!new RegExp(t).test(this.__combinedTagString)}get uniqueName(){return this.__uniqueName}static _reset(){this.currentMaxObjectCount=0,this.__uniqueNames=[],this.__objectsByNameMap=new Map,this.__objects=[]}_copyFrom(e){this._tags=(0,o.bX)(e._tags),this.__combinedTagString=e.__combinedTagString}}a.InvalidObjectUID=-1,a.currentMaxObjectCount=0,a.__uniqueNames=[],a.__objectsByNameMap=new Map,a.__objects=[]},6338:(e,t,n)=>{n.d(t,{K:()=>c});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}toGltfString(){return this.str}}const i=new a({index:0,str:"OPAQUE"}),r=new a({index:1,str:"MASK"}),s=new a({index:2,str:"BLEND"}),l=[i,r,s],c=Object.freeze({Opaque:i,Mask:r,Blend:s,from:function(e){return(0,o.yH)({typeList:l,index:e})},fromString:function(e){return(0,o.Pq)({typeList:l,str:e})},fromGlTFString:function(e){return(0,o.Pq)({typeList:l,str:e})}})},375:(e,t,n)=>{n.d(t,{R:()=>u});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"Quaternion"}),r=new a({index:1,str:"Translate"}),s=new a({index:2,str:"Scale"}),l=new a({index:3,str:"Weights"}),c=new a({index:4,str:"Effekseer"}),_=[i,r,s,l,c],u=Object.freeze({Quaternion:i,Translate:r,Scale:s,Weights:l,Effekseer:c,from:function(e){return(0,o.yH)({typeList:_,index:e})},fromString:function(e){return(0,o.Pq)({typeList:_,str:e})}})},833:(e,t,n)=>{n.d(t,{v:()=>c});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}get GltfString(){return this.str.toUpperCase()}}const i=new a({index:0,str:"Linear"}),r=new a({index:1,str:"Step"}),s=new a({index:2,str:"CubicSpline"}),l=[i,r,s],c=Object.freeze({Linear:i,Step:r,CubicSpline:s,from:function(e){return(0,o.yH)({typeList:l,index:e})},fromString:function(e){return(0,o.Pq)({typeList:l,str:e})}})},7925:(e,t,n)=>{n.d(t,{F:()=>A});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"ETC1"}),r=new a({index:1,str:"ETC2"}),s=new a({index:2,str:"BC1"}),l=new a({index:3,str:"BC3"}),c=new a({index:4,str:"BC4"}),_=new a({index:5,str:"BC5"}),u=new a({index:6,str:"BC7_M6_OPAQUE"}),f=new a({index:7,str:"BC7_M5"}),d=new a({index:8,str:"PVRTC1_RGB"}),h=new a({index:9,str:"PVRTC1_RGBA"}),m=new a({index:10,str:"ASTC"}),p=new a({index:11,str:"ATC_RGB"}),v=new a({index:12,str:"ATC_RGBA"}),x=new a({index:13,str:"RGBA32"}),g=new a({index:14,str:"RGB565"}),y=new a({index:15,str:"BGR565"}),b=new a({index:16,str:"RGBA4444"}),I=[i,r,s,l,c,_,f,u,d,h,m,p,v,x,g,y,b],A=Object.freeze({ETC1:i,ETC2:r,BC1:s,BC3:l,BC4:c,BC5:_,BC7_M5:f,BC7_M6_OPAQUE:u,PVRTC1_RGB:d,PVRTC1_RGBA:h,ASTC:m,ATC_RGB:p,ATC_RGBA:v,RGBA32:x,RGB565:g,BGR565:y,RGBA4444:b,from:function(e){return(0,o.yH)({typeList:I,index:e})},fromString:function(e){return(0,o.Pq)({typeList:I,str:e})}})},3886:(e,t,n)=>{n.d(t,{E:()=>d});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t,webgpu:n}){super({index:e,str:t}),this.__webgpu=n}get webgpu(){if(void 0===this.__webgpu)throw new Error(`does not support ${this.str}`);return this.__webgpu}}const i=new a({index:32774,str:"Equation_FUNC_ADD",webgpu:"add"}),r=new a({index:0,str:"ZERO",webgpu:"zero"}),s=new a({index:1,str:"ONE",webgpu:"one"}),l=new a({index:770,str:"SRC_ALPHA",webgpu:"src-alpha"}),c=new a({index:771,str:"ONE_MINUS_SRC_ALPHA",webgpu:"one-minus-src-alpha"}),_=new a({index:32775,str:"Equation_FUNC_MIN",webgpu:"min"}),u=new a({index:32776,str:"Equation_FUNC_MAX",webgpu:"max"}),f=[i,r,s,l,c,_,u],d=Object.freeze({EquationFuncAdd:i,Zero:r,One:s,SrcAlpha:l,OneMinusSrcAlpha:c,Min:_,Max:u,from:function(e){return(0,o.yH)({typeList:f,index:e})}})},6195:(e,t,n)=>{n.d(t,{N:()=>_});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"Mat43x1"}),r=new a({index:1,str:"Vec4x2"}),s=new a({index:2,str:"Vec4x2Old"}),l=new a({index:3,str:"Vec4x1"}),c=[i,r,l],_=Object.freeze({Mat43x1:i,Vec4x2:r,Vec4x2Old:s,Vec4x1:l,from:function(e){return(0,o.yH)({typeList:c,index:e})},fromString:function(e){return(0,o.Pq)({typeList:c,str:e})}})},7616:(e,t,n)=>{n.d(t,{a:()=>_});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"GPUInstanceData"}),r=new a({index:1,str:"GPUVertexData"}),s=new a({index:2,str:"UBOGeneric"}),l=new a({index:3,str:"CPUGeneric"}),c=[i,r,s,l],_=Object.freeze({GPUInstanceData:i,GPUVertexData:r,UBOGeneric:s,CPUGeneric:l,from:function(e){return(0,o.yH)({typeList:c,index:e})},fromString:function(e){return(0,o.Pq)({typeList:c,str:e})}})},5118:(e,t,n)=>{n.d(t,{E:()=>l});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"Orbit"}),r=new a({index:1,str:"WalkThrough"}),s=[i,r],l=Object.freeze({Orbit:i,WalkThrough:r,from:function(e){return(0,o.yH)({typeList:s,index:e})},fromString:function(e){return(0,o.Pq)({typeList:s,str:e})}})},5250:(e,t,n)=>{n.d(t,{A:()=>c});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"Perspective"}),r=new a({index:1,str:"Orthographic"}),s=new a({index:2,str:"Frustum"}),l=[i,r,s],c=Object.freeze({Perspective:i,Orthographic:r,Frustum:s,from:function(e){return(0,o.yH)({typeList:l,index:e})},fromString:function(e){return(0,o.Pq)({typeList:l,str:e})}})},4114:(e,t,n)=>{n.d(t,{I:()=>v});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t,sizeInBytes:n,wgsl:o,webgpu:a}){super({index:e,str:t}),this.__sizeInBytes=n,this.__webgpu=a,this.__wgsl=o,this.__dummyStr=t}get wgsl(){return this.__wgsl}get webgpu(){return this.__webgpu}getSizeInBytes(){return this.__sizeInBytes}isFloatingPoint(){return 5126===this.index||5127===this.index||36193===this.index}isInteger(){return 5120===this.index||5122===this.index||5124===this.index}isUnsignedInteger(){return 5121===this.index||5123===this.index||5125===this.index}}const i=new a({index:5119,str:"UNKNOWN",sizeInBytes:0,wgsl:"unknown",webgpu:"unknown"}),r=new a({index:5120,str:"BYTE",sizeInBytes:1,wgsl:"i32",webgpu:"sint8"}),s=new a({index:5121,str:"UNSIGNED_BYTE",sizeInBytes:1,wgsl:"u32",webgpu:"uint8"}),l=new a({index:5122,str:"SHORT",sizeInBytes:2,wgsl:"i32",webgpu:"sint16"}),c=new a({index:5123,str:"UNSIGNED_SHORT",sizeInBytes:2,wgsl:"u32",webgpu:"uint16"}),_=new a({index:5124,str:"INT",sizeInBytes:4,wgsl:"i32",webgpu:"sint32"}),u=new a({index:5125,str:"UNSIGNED_INT",sizeInBytes:4,wgsl:"u32",webgpu:"uint32"}),f=new a({index:5126,str:"FLOAT",sizeInBytes:4,wgsl:"f32",webgpu:"float32"}),d=new a({index:5127,str:"DOUBLE",sizeInBytes:8,wgsl:"f32",webgpu:"float64"}),h=new a({index:35670,str:"BOOL",sizeInBytes:1,wgsl:"bool",webgpu:"bool"}),m=new a({index:5131,str:"HALF_FLOAT",sizeInBytes:2,wgsl:"f16",webgpu:"float16"}),p=[i,r,s,l,c,_,u,f,d,m,h],v=Object.freeze({Unknown:i,Byte:r,UnsignedByte:s,Short:l,UnsignedShort:c,Int:_,UnsignedInt:u,Float:f,Double:d,Bool:h,HalfFloat:m,from:function(e){return(0,o.yH)({typeList:p,index:e})},fromTypedArray:function(e){return e instanceof Int8Array?r:e instanceof Uint8Array||e instanceof Uint8ClampedArray?s:e instanceof Int16Array?l:e instanceof Uint16Array?c:e instanceof Int32Array?_:e instanceof Uint32Array?u:e instanceof Float32Array?f:e instanceof Float64Array?d:i},toTypedArray:function(e){return e===r?Int8Array:e===s?Uint8Array:e===l?Int16Array:e===c?Uint16Array:e===_?Int32Array:e===u?Uint32Array:e===f?Float32Array:e===d?Float64Array:void 0},toGltf2AccessorComponentType:function(e){return e.index},fromString:function(e){return(0,o.Pq)({typeList:p,str:e})},fromGlslString:function(e){let t=e;switch(e){case"bool":t="BOOL";break;case"int":case"ivec2":case"ivec3":case"ivec4":case"sampler2D":case"sampler2DShadow":case"sampler2DRect":case"sampler3D":case"samplerCube":t="INT";break;case"float":case"vec2":case"vec3":case"vec4":case"mat2":case"mat3":case"mat4":t="FLOAT"}return(0,o.Pq)({typeList:p,str:t})},fromWgslString:function(e){let t=e;switch(e){case"bool":t="BOOL";break;case"i32":case"vec2<i32>":case"vec3<i32>":case"vec4<i32>":case"sampler_2d":case"sampler_2d_shadow":case"sampler_3d":case"sampler_cube":t="INT";break;case"u32":t="UNSIGNED_INT";break;case"f32":case"vec2<f32>":case"vec3<f32>":case"vec4<f32>":case"mat2x2<f32>":case"mat3x3<f32>":case"mat4x4<f32>":t="FLOAT"}return(0,o.Pq)({typeList:p,str:t})}})},7751:(e,t,n)=>{n.d(t,{h:()=>w});var o=n(4324),a=n(3497);class i extends o.wJ{constructor({index:e,str:t,glslStr:n,hlslStr:o,wgsl:a,webgpu:i,numberOfComponents:r,vec4SizeOfProperty:s,isArray:l=!1}){super({index:e,str:t}),this.__numberOfComponents=r,this.__glslStr=n,this.__hlslStr=o,this.__vec4SizeOfProperty=s,this.__isArray=l,this.__webgpuStr=i,this.__wgslStr=a,this.__dummyStr=t}get webgpu(){return this.__webgpuStr}get wgsl(){return this.__wgslStr}getNumberOfComponents(){return this.__numberOfComponents}getGlslStr(e){return 5126===e.index||5127===e.index||this===w.Texture2D||this===w.Texture2DShadow||this===w.Texture2DRect||this===w.TextureCube?this.__glslStr:5120===e.index||5122===e.index||5124===e.index?this===w.Scalar||this===w.ScalarArray?"int":"i"+this.__glslStr:35670===e.index?"bool":"unknown"}getGlslInitialValue(e){if(5126===e.index||5127===e.index){if(this===w.Scalar)return"0.0";if(2===this.__numberOfComponents)return this.__glslStr+"(0.0, 0.0)";if(3===this.__numberOfComponents)return this.__glslStr+"(0.0, 0.0, 0.0)";if(4===this.__numberOfComponents)return this.__glslStr+"(0.0, 0.0, 0.0, 0.0)";if(9===this.__numberOfComponents)return this.__glslStr+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";if(16===this.__numberOfComponents)return this.__glslStr+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)"}else if(5120===e.index||5122===e.index||5124===e.index){if(this===w.Scalar)return"0";if(2===this.__numberOfComponents)return this.__glslStr+"(0, 0)";if(3===this.__numberOfComponents)return this.__glslStr+"(0, 0, 0)";if(4===this.__numberOfComponents)return this.__glslStr+"(0, 0, 0, 0)";if(9===this.__numberOfComponents)return this.__glslStr+"(0, 0, 0, 0, 0, 0, 0, 0, 0)";if(16===this.__numberOfComponents)return this.__glslStr+"(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)"}else if(35670===e.index){if(this===w.Scalar)return"false";if(2===this.__numberOfComponents)return this.__glslStr+"(false, false)";if(3===this.__numberOfComponents)return this.__glslStr+"(false, false, false)";if(4===this.__numberOfComponents)return this.__glslStr+"(false, false, false, false)"}return"unknown"}getWgslInitialValue(e){const t=this.toWGSLType(e);if(5126===e.index||5127===e.index){if(this===w.Scalar)return"0.0";if(2===this.__numberOfComponents)return t+"(0.0, 0.0)";if(3===this.__numberOfComponents)return t+"(0.0, 0.0, 0.0)";if(4===this.__numberOfComponents)return t+"(0.0, 0.0, 0.0, 0.0)";if(9===this.__numberOfComponents)return t+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";if(16===this.__numberOfComponents)return t+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)"}else if(5120===e.index||5122===e.index||5124===e.index){if(this===w.Scalar)return"0";if(2===this.__numberOfComponents)return t+"(0, 0)";if(3===this.__numberOfComponents)return t+"(0, 0, 0)";if(4===this.__numberOfComponents)return t+"(0, 0, 0, 0)";if(9===this.__numberOfComponents)return t+"(0, 0, 0, 0, 0, 0, 0, 0, 0)";if(16===this.__numberOfComponents)return t+"(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)"}else if(35670===e.index){if(this===w.Scalar)return"false";if(2===this.__numberOfComponents)return t+"(false, false)";if(3===this.__numberOfComponents)return t+"(false, false, false)";if(4===this.__numberOfComponents)return t+"(false, false, false, false)"}return"unknown"}toWGSLType(e){return this.__wgslStr.replace("#",e.wgsl)}getVec4SizeOfProperty(){return this.__vec4SizeOfProperty}}const r=new i({index:-1,str:"UNKNOWN",glslStr:"unknown",hlslStr:"unknown",wgsl:"unknown",webgpu:"unknown",numberOfComponents:0,vec4SizeOfProperty:0}),s=new i({index:0,str:"SCALAR",glslStr:"float",hlslStr:"float",wgsl:"#",webgpu:"",numberOfComponents:1,vec4SizeOfProperty:1}),l=new i({index:1,str:"VEC2",glslStr:"vec2",hlslStr:"float2",wgsl:"vec2<#>",webgpu:"x2",numberOfComponents:2,vec4SizeOfProperty:1}),c=new i({index:2,str:"VEC3",glslStr:"vec3",hlslStr:"float3",wgsl:"vec3<#>",webgpu:"x3",numberOfComponents:3,vec4SizeOfProperty:1}),_=new i({index:3,str:"VEC4",glslStr:"vec4",hlslStr:"float4",wgsl:"vec4<#>",webgpu:"x4",numberOfComponents:4,vec4SizeOfProperty:1}),u=new i({index:4,str:"MAT2",glslStr:"mat2",hlslStr:"float2x2",wgsl:"mat2x2<#>",webgpu:"unknown",numberOfComponents:4,vec4SizeOfProperty:2}),f=new i({index:5,str:"MAT3",glslStr:"mat3",hlslStr:"float3x3",wgsl:"mat3x3<#>",webgpu:"unknown",numberOfComponents:9,vec4SizeOfProperty:3}),d=new i({index:6,str:"MAT4",glslStr:"mat4",hlslStr:"float4x4",wgsl:"mat4x4<#>",webgpu:"unknown",numberOfComponents:16,vec4SizeOfProperty:4}),h=new i({index:7,str:"TEXTURE_2D",glslStr:"sampler2D",hlslStr:"Texture2D",wgsl:"texture_2d",webgpu:"texture_2d",numberOfComponents:1,vec4SizeOfProperty:1}),m=new i({index:8,str:"TEXTURE_CUBE_MAP",glslStr:"samplerCube",hlslStr:"TextureCube",wgsl:"texture_cube",webgpu:"texture_cube",numberOfComponents:1,vec4SizeOfProperty:1}),p=new i({index:9,str:"SCALAR_ARRAY",glslStr:"float",hlslStr:"float",wgsl:"#",webgpu:"unknown",numberOfComponents:1,vec4SizeOfProperty:1,isArray:!0}),v=new i({index:10,str:"VEC2_ARRAY",glslStr:"vec2",hlslStr:"float2",wgsl:"vec2<#>",webgpu:"unknown",numberOfComponents:2,vec4SizeOfProperty:1,isArray:!0}),x=new i({index:11,str:"VEC3_ARRAY",glslStr:"vec3",hlslStr:"float3",wgsl:"vec3<#>",webgpu:"unknown",numberOfComponents:3,vec4SizeOfProperty:1,isArray:!0}),g=new i({index:12,str:"VEC4_ARRAY",glslStr:"vec4",hlslStr:"float4",wgsl:"vec4<#>",webgpu:"unknown",numberOfComponents:4,vec4SizeOfProperty:1,isArray:!0}),y=new i({index:13,str:"MAT4_ARRAY",glslStr:"mat4",hlslStr:"float4x4",wgsl:"mat4x4<#>",webgpu:"unknown",numberOfComponents:16,vec4SizeOfProperty:4,isArray:!0}),b=new i({index:14,str:"MAT3_ARRAY",glslStr:"mat3",hlslStr:"float3x3",wgsl:"mat3x3<#>",webgpu:"unknown",numberOfComponents:9,vec4SizeOfProperty:3,isArray:!0}),I=new i({index:15,str:"MAT2_ARRAY",glslStr:"mat2",hlslStr:"float2x2",wgsl:"mat2x2<#>",webgpu:"unknown",numberOfComponents:4,vec4SizeOfProperty:2,isArray:!0}),A=new i({index:16,str:"TEXTURE_2D_SHADOW",glslStr:"highp sampler2DShadow",hlslStr:"Texture2D",wgsl:"texture_2d",webgpu:"texture_2d",numberOfComponents:1,vec4SizeOfProperty:1}),E=new i({index:17,str:"TEXTURE_2D_RECT",glslStr:"sampler2DRect",hlslStr:"Texture2D",wgsl:"texture_2d",webgpu:"texture_2d",numberOfComponents:1,vec4SizeOfProperty:1}),S=new i({index:18,str:"MAT4x3_ARRAY",glslStr:"mat4x3",hlslStr:"float4x3",wgsl:"mat4x3<#>",webgpu:"unknown",numberOfComponents:12,vec4SizeOfProperty:3,isArray:!0}),T=[r,s,l,c,_,u,f,d,v,x,g,p,I,b,y,h,A,E,m,S],w=Object.freeze({Unknown:r,Scalar:s,Vec2:l,Vec3:c,Vec4:_,Mat2:u,Mat3:f,Mat4:d,ScalarArray:p,Vec2Array:v,Vec3Array:x,Vec4Array:g,Mat2Array:I,Mat3Array:b,Mat4Array:y,Texture2D:h,Texture2DShadow:A,TextureCube:m,Texture2DRect:E,Mat4x3Array:S,from:function(e){return(0,o.yH)({typeList:T,index:e})},fromString:function(e){return(0,o.Pq)({typeList:T,str:e})},vectorFrom:function(e){let t="";switch(e){case 1:t="scalar";break;case 2:t="vec2";break;case 3:t="vec3";break;case 4:t="vec4";break;default:a.V.error("not found appropriate Vectors")}return(0,o.Pq)({typeList:T,str:t})},fromGlslString:function(e){let t=e;switch(e){case"bool":case"int":case"float":t="scalar";break;case"ivec2":t="vec2";break;case"ivec3":t="vec3";break;case"ivec4":t="vec4";break;case"sampler2D":t="TEXTURE_2D";break;case"sampler2DShadow":t="TEXTURE_2D_SHADOW";break;case"sampler2DRect":t="TEXTURE_2D_RECT";break;case"samplerCube":t="TEXTURE_CUBE_MAP"}return(0,o.Pq)({typeList:T,str:t})},fromWgslString:function(e){let t=e;switch(e){case"bool":case"i32":case"u32":case"f32":t="scalar";break;case"vec2<f32>":case"vec2<i32>":t="vec2";break;case"vec3<f32>":case"vec3<i32>":t="vec3";break;case"vec4<f32>":case"vec4<i32>":t="vec4";break;case"mat2x2<f32>":case"mat2x2<i32>":t="mat2";break;case"mat3x3<f32>":case"mat3x3<i32>":t="mat3";break;case"mat4x4<f32>":case"mat4x4<i32>":t="mat4";break;case"sampler_2d":t="TEXTURE_2D";break;case"sampler_2d_shadow":t="TEXTURE_2D_SHADOW";break;case"sampler_cube":t="TEXTURE_CUBE_MAP"}return(0,o.Pq)({typeList:T,str:t})},isArray:function(e){return e===p||e===v||e===x||e===g||e===S||e===y||e===b||e===I},isTexture:function(e){return e===h||e===m||e===A||e===E},toGltf2AnimationAccessorCompositionType:function(e){switch(e){case 1:return s;case 2:return l;case 3:return c;case 4:return _;default:throw new Error("Invalid componentN")}},toGltf2AccessorCompositionTypeString:function(e){switch(e){case 1:return"SCALAR";case 2:return"VEC2";case 3:return"VEC3";case 4:return"VEC4";case 9:return"MAT3";case 16:return"MAT4";default:throw new Error("Invalid componentN")}},toGltf2AnimationAccessorCompositionTypeString:function(e){switch(e){case 1:return"SCALAR";case 2:return"VEC2";case 3:return"VEC3";case 4:return"VEC4";default:throw new Error("Invalid componentN")}},toGltf2SquareMatrixAccessorCompositionTypeString:function(e){switch(e){case 4:return"VEC4";case 9:return"MAT3";case 16:return"MAT4";default:throw new Error("Invalid componentN")}}})},5216:(e,t,n)=>{n.d(t,{s:()=>q});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t,webgpu:n,blockInfo:o}){super({index:e,str:t}),this.__webgpu=n,this.__blockInfo=o}get webgpu(){if(void 0===this.__webgpu)throw new Error(`does not support ${this.str}`);return this.__webgpu}get blockInfo(){if(void 0===this.__blockInfo)throw new Error(`does not support ${this.str}`);return this.__blockInfo}}const i=new a({index:37808,str:"COMPRESSED_RGBA_ASTC_4x4_KHR",webgpu:"astc-4x4-unorm",blockInfo:{byteSize:16,width:4,height:4}}),r=new a({index:37809,str:"COMPRESSED_RGBA_ASTC_5x4_KHR",webgpu:"astc-5x4-unorm"}),s=new a({index:37810,str:"COMPRESSED_RGBA_ASTC_5x5_KHR",webgpu:"astc-5x5-unorm"}),l=new a({index:37811,str:"COMPRESSED_RGBA_ASTC_6x5_KHR",webgpu:"astc-6x5-unorm"}),c=new a({index:37812,str:"COMPRESSED_RGBA_ASTC_6x6_KHR",webgpu:"astc-6x6-unorm"}),_=new a({index:37813,str:"COMPRESSED_RGBA_ASTC_8x5_KHR",webgpu:"astc-8x5-unorm"}),u=new a({index:37814,str:"COMPRESSED_RGBA_ASTC_8x6_KHR",webgpu:"astc-8x6-unorm"}),f=new a({index:37815,str:"COMPRESSED_RGBA_ASTC_8x8_KHR",webgpu:"astc-8x8-unorm"}),d=new a({index:37816,str:"COMPRESSED_RGBA_ASTC_10x5_KHR",webgpu:"astc-10x5-unorm"}),h=new a({index:37817,str:"COMPRESSED_RGBA_ASTC_10x6_KHR",webgpu:"astc-10x6-unorm"}),m=new a({index:37818,str:"COMPRESSED_RGBA_ASTC_10x8_KHR",webgpu:"astc-10x8-unorm"}),p=new a({index:37819,str:"COMPRESSED_RGBA_ASTC_10x10_KHR",webgpu:"astc-10x10-unorm"}),v=new a({index:37820,str:"COMPRESSED_RGBA_ASTC_12x10_KHR",webgpu:"astc-12x10-unorm"}),x=new a({index:37821,str:"COMPRESSED_RGBA_ASTC_12x12_KHR",webgpu:"astc-12x12-unorm"}),g=new a({index:37840,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",webgpu:"astc-4x4-unorm-srgb",blockInfo:{byteSize:16,width:4,height:4}}),y=new a({index:37841,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",webgpu:"astc-5x4-unorm-srgb"}),b=new a({index:37842,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",webgpu:"astc-5x5-unorm-srgb"}),I=new a({index:37843,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",webgpu:"astc-6x5-unorm-srgb"}),A=new a({index:37844,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",webgpu:"astc-6x6-unorm-srgb"}),E=new a({index:37845,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",webgpu:"astc-8x5-unorm-srgb"}),S=new a({index:37846,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",webgpu:"astc-8x6-unorm-srgb"}),T=new a({index:37847,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",webgpu:"astc-8x8-unorm-srgb"}),w=new a({index:37848,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",webgpu:"astc-10x5-unorm-srgb"}),C=new a({index:37849,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",webgpu:"astc-10x6-unorm-srgb"}),R=new a({index:37850,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",webgpu:"astc-10x8-unorm-srgb"}),P=new a({index:37851,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",webgpu:"astc-10x10-unorm-srgb"}),N=new a({index:37852,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",webgpu:"astc-12x10-unorm-srgb"}),M=new a({index:37853,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",webgpu:"astc-12x12-unorm-srgb"}),D=new a({index:33776,str:"COMPRESSED_RGB_S3TC_DXT1_EXT",webgpu:"bc1-rgba-unorm",blockInfo:{byteSize:8,width:4,height:4}}),F=new a({index:33777,str:"COMPRESSED_RGBA_S3TC_DXT1_EXT",webgpu:"bc1-rgba-unorm",blockInfo:{byteSize:8,width:4,height:4}}),B=new a({index:33778,str:"COMPRESSED_RGBA_S3TC_DXT3_EXT",webgpu:"bc2-rgba-unorm",blockInfo:{byteSize:16,width:4,height:4}}),L=new a({index:33779,str:"COMPRESSED_RGBA_S3TC_DXT5_EXT",webgpu:"bc3-rgba-unorm",blockInfo:{byteSize:16,width:4,height:4}}),V=new a({index:36492,str:"COMPRESSED_RGBA_BPTC_UNORM_EXT",webgpu:"bc7-rgba-unorm",blockInfo:{byteSize:16,width:4,height:4}}),z=new a({index:35842,str:"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",blockInfo:{byteSize:8,width:4,height:4}}),G=new a({index:35840,str:"COMPRESSED_RGB_PVRTC_4BPPV1_IMG",blockInfo:{byteSize:8,width:4,height:4}}),O=new a({index:37496,str:"COMPRESSED_RGBA8_ETC2_EAC",webgpu:"etc2-rgba8unorm",blockInfo:{byteSize:16,width:4,height:4}}),U=new a({index:37492,str:"COMPRESSED_RGB8_ETC2",webgpu:"etc2-rgb8unorm",blockInfo:{byteSize:16,width:4,height:4}}),k=new a({index:36196,str:"COMPRESSED_RGB_ETC1_WEBGL"}),W=new a({index:32856,str:"RGBA8_EXT",blockInfo:{byteSize:4,width:1,height:1}}),Q=[i,r,s,l,c,_,u,f,d,h,m,p,v,x,g,y,b,I,A,E,S,T,w,C,R,P,N,M,D,F,B,L,V,z,G,O,U,k,W],q=Object.freeze({ASTC_RGBA_4x4:i,ASTC_RGBA_5x4:r,ASTC_RGBA_5x5:s,ASTC_RGBA_6x5:l,ASTC_RGBA_6x6:c,ASTC_RGBA_8x5:_,ASTC_RGBA_8x6:u,ASTC_RGBA_8x8:f,ASTC_RGBA_10x5:d,ASTC_RGBA_10x6:h,ASTC_RGBA_10x8:m,ASTC_RGBA_10x10:p,ASTC_RGBA_12x10:v,ASTC_RGBA_12x12:x,ASTC_SRGB_4x4:g,ASTC_SRGB_5x4:y,ASTC_SRGB_5x5:b,ASTC_SRGB_6x5:I,ASTC_SRGB_6x6:A,ASTC_SRGB_8x5:E,ASTC_SRGB_8x6:S,ASTC_SRGB_8x8:T,ASTC_SRGB_10x5:w,ASTC_SRGB_10x6:C,ASTC_SRGB_10x8:R,ASTC_SRGB_10x10:P,ASTC_SRGB_12x10:N,ASTC_SRGB_12x12:M,S3TC_RGB_DXT1:D,S3TC_RGBA_DXT1:F,S3TC_RGBA_DXT3:B,S3TC_RGBA_DXT5:L,BPTC_RGBA:V,PVRTC_RGBA_4BPPV1:z,PVRTC_RGB_4BPPV1:G,ETC2_RGBA8_EAC:O,ETC2_RGB8:U,ETC1_RGB:k,RGBA8_EXT:W,from:function(e){return(0,o.yH)({typeList:Q,index:e})},fromString:function(e){return(0,o.Pq)({typeList:Q,str:e})}})},6747:(e,t,n)=>{n.d(t,{p:()=>f});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t,ext:n,brand:o}){super({index:e,str:t}),this.extension=n,this.brand=o}}const i=new a({index:-1,str:"unknown",ext:"unknown",brand:"UnKnown"}),r=new a({index:0,str:"gltf",ext:"gltf",brand:"glTF"}),s=new a({index:1,str:"glb",ext:"glb",brand:"glTF"}),l=new a({index:2,str:"vrm",ext:"vrm",brand:"VRM"}),c=new a({index:3,str:"drc",ext:"drc",brand:"Draco"}),_=new a({index:4,str:"efk",ext:"efk",brand:"EffekseerEffect"}),u=[i,r,s,l,c,_],f=Object.freeze({Unknown:i,Gltf:r,GltfBinary:s,VRM:l,Draco:c,EffekseerEffect:_,from:function(e){return(0,o.yH)({typeList:u,index:e})},fromString:function(e){const t=(0,o.Pq)({typeList:u,str:e});return null!=t?t:i},isGltfOrGlb:function(e){return e===r||e===s}})},9747:(e,t,n)=>{n.d(t,{P:()=>f});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:".ldr_srgb"}),r=new a({index:1,str:".ldr_linear"}),s=new a({index:2,str:".hdr"}),l=new a({index:3,str:".rgbe.png"}),c=new a({index:4,str:".rgb9_e5.png"}),_=new a({index:5,str:".exr"}),u=[i,r,s,l,c,_],f=Object.freeze({LDR_SRGB:i,LDR_LINEAR:r,HDR_LINEAR:s,RGBE_PNG:l,RGB9_E5_PNG:c,OpenEXR:_,from:function(e){return(0,o.yH)({typeList:u,index:e})},fromString:function(e){return(0,o.Pq)({typeList:u,str:e})}})},9201:(e,t,n)=>{n.d(t,{z:()=>_});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"Directional"}),r=new a({index:1,str:"Point"}),s=new a({index:2,str:"Spot"}),l=new a({index:3,str:"Ambient"}),c=[r,i,s,l],_=Object.freeze({Point:r,Directional:i,Spot:s,Ambient:l,from:function(e){return(0,o.yH)({typeList:c,index:e})},fromString:function(e){return(0,o.Pq)({typeList:c,str:e})}})},4958:(e,t,n)=>{n.d(t,{A:()=>m});var o=n(2238),a=n(4324);class i extends a.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const r=new i({index:6402,str:"DEPTH_COMPONENT"}),s=new i({index:34041,str:"DEPTH_STENCIL"}),l=new i({index:6406,str:"ALPHA"}),c=new i({index:o.wfs,str:"RG"}),_=new i({index:6407,str:"RGB"}),u=new i({index:6408,str:"RGBA"}),f=new i({index:6409,str:"LUMINANCE"}),d=new i({index:6410,str:"LUMINANCE_ALPHA"}),h=[r,s,l,c,_,u,f,d],m=Object.freeze({DepthComponent:r,DepthStencil:s,Alpha:l,RG:c,RGB:_,RGBA:u,Luminance:f,LuminanceAlpha:d,from:function(e){return(0,a.yH)({typeList:h,index:e})},getCompositionNumFromPixelFormat:function(e){switch(e){case r:return 1;case s:return 2;case l:return 1;case c:return 2;case _:return 3;case u:return 4;case f:return 1;case d:return 2;default:throw new Error(`Not supported ${e}`)}}})},6947:(e,t,n)=>{n.d(t,{R:()=>h});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}getWebGPUTypeStr(){switch(this.index){case 0:return"point-list";case 1:return"line-list";case 2:case 6:default:throw new Error("Not Supported in WebGPU");case 3:return"line-strip";case 4:return"triangle-list";case 5:return"triangle-strip"}}}const i=new a({index:-1,str:"UNKNOWN"}),r=new a({index:0,str:"POINTS"}),s=new a({index:1,str:"LINES"}),l=new a({index:2,str:"LINE_LOOP"}),c=new a({index:3,str:"LINE_STRIP"}),_=new a({index:4,str:"TRIANGLES"}),u=new a({index:5,str:"TRIANGLE_STRIP"}),f=new a({index:6,str:"TRIANGLE_FAN"}),d=[i,r,s,l,c,_,u,f],h=Object.freeze({Unknown:i,Points:r,Lines:s,LineLoop:l,LineStrip:c,Triangles:_,TriangleStrip:u,TriangleFan:f,from:function(e){return(0,o.yH)({typeList:d,index:e})}})},3212:(e,t,n)=>{n.d(t,{a:()=>a,m:()=>c});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}get webGLVersion(){switch(this){case r:case s:return 2;default:return 0}}}const i=new a({index:0,str:"NONE"}),r=new a({index:1,str:"UNIFORM"}),s=new a({index:2,str:"DataTexture"}),l=new a({index:3,str:"WebGPU"}),c=Object.freeze({isDataTextureApproach:e=>e===s,isUniformApproach:e=>e===r,isWebGpuApproach:e=>e===l,None:i,Uniform:r,DataTexture:s,WebGPU:l,isWebGL2Approach:e=>{switch(e){case r:case s:return!0;default:return!1}}})},5368:(e,t,n)=>{n.d(t,{O:()=>m});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t,methodName:n}){super({index:e,str:t}),this.methodName=n}}const i=new a({index:-1,str:"UNKNOWN",methodName:"$unknown"}),r=new a({index:0,str:"CREATE",methodName:"$create"}),s=new a({index:1,str:"LOAD",methodName:"$load"}),l=new a({index:2,str:"MOUNT",methodName:"$mount"}),c=new a({index:3,str:"LOGIC",methodName:"$logic"}),_=new a({index:4,str:"PRE_RENDER",methodName:"$prerender"}),u=new a({index:5,str:"RENDER",methodName:"$render"}),f=new a({index:6,str:"UNMOUNT",methodName:"$unmount"}),d=new a({index:7,str:"DISCARD",methodName:"$discard"}),h=[i,r,s,l,c,_,u,f,d],m=Object.freeze({Unknown:i,Create:r,Load:s,Mount:l,Logic:c,PreRender:_,Render:u,Unmount:f,Discard:d,from:function(e){return(0,o.yH)({typeList:h,index:e})}})},3686:(e,t,n)=>{n.d(t,{q:()=>E});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}webGLConstantValue(){return-2===this.index?0:-1===this.index?1029:36064+this.index}}const i=new a({index:-2,str:"NONE"}),r=new a({index:-1,str:"BACK"}),s=new a({index:0,str:"COLOR_ATTACHMENT0"}),l=new a({index:1,str:"COLOR_ATTACHMENT1"}),c=new a({index:2,str:"COLOR_ATTACHMENT2"}),_=new a({index:3,str:"COLOR_ATTACHMENT3"}),u=new a({index:4,str:"COLOR_ATTACHMENT4"}),f=new a({index:5,str:"COLOR_ATTACHMENT5"}),d=new a({index:6,str:"COLOR_ATTACHMENT6"}),h=new a({index:7,str:"COLOR_ATTACHMENT7"}),m=new a({index:8,str:"COLOR_ATTACHMENT8"}),p=new a({index:9,str:"COLOR_ATTACHMENT9"}),v=new a({index:10,str:"COLOR_ATTACHMENT10"}),x=new a({index:11,str:"COLOR_ATTACHMENT11"}),g=new a({index:12,str:"COLOR_ATTACHMENT12"}),y=new a({index:13,str:"COLOR_ATTACHMENT13"}),b=new a({index:14,str:"COLOR_ATTACHMENT14"}),I=new a({index:15,str:"COLOR_ATTACHMENT15"}),A=[i,r,s,l,c,_,u,f,d,h,m,p,v,x,g,y,b,I],E=Object.freeze({None:i,Back:r,ColorAttachment0:s,ColorAttachment1:l,ColorAttachment2:c,ColorAttachment3:_,ColorAttachment4:u,ColorAttachment5:f,ColorAttachment6:d,ColorAttachment7:h,ColorAttachment8:m,ColorAttachment9:p,ColorAttachment10:v,ColorAttachment11:x,ColorAttachment12:g,ColorAttachment13:y,ColorAttachment14:b,ColorAttachment15:I,from:function(e){return(0,o.yH)({typeList:A,index:e})}})},9156:(e,t,n)=>{n.d(t,{m:()=>l});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:0,str:"ClassicShading"}),r=new a({index:1,str:"PBRShading"}),s=(new a({index:2,str:"Lerp"}),new a({index:3,str:"Add"}),[i,r]),l=Object.freeze({ClassicShading:i,PBRShading:r,from:function(e){return(0,o.yH)({typeList:s,index:e})},fromString:function(e){return(0,o.Pq)({typeList:s,str:e})}})},9871:(e,t,n)=>{n.d(t,{jc:()=>i,lk:()=>Mt,zb:()=>Nt});var o=n(4324),a=n(7751);class i extends o.wJ{constructor({str:e}){super({index:++i.__indexCount*i._scale,str:e,noCheckStrUnique:!0}),i.__classes[this.index]=this}static getShaderSemanticByIndex(e){return this.__classes[Math.abs(e)-Math.abs(e)%this._scale]}static isNonArrayShaderSemanticIndex(e){return e>=this._scale}static isArrayAndZeroIndexShaderSemanticIndex(e){return e<0&&Math.abs(e)%i._scale==0}static isArrayAndNonZeroIndexShaderSemanticIndex(e){return e<0&&Math.abs(e)%i._scale!=0}static getIndexCount(){return i.__indexCount}}i.__indexCount=-1,i._scale=1e4,i.__classes=[];const r=new i({str:"worldMatrix"}),s=new i({str:"viewMatrix"}),l=new i({str:"isBillboard"}),c=new i({str:"enableViewMatrix"}),_=new i({str:"projectionMatrix"}),u=new i({str:"normalMatrix"}),f=new i({str:"boneMatrix"}),d=new i({str:"baseColorFactor"}),h=new i({str:"baseColorTexture"}),m=new i({str:"normalTexture"}),p=new i({str:"metallicRoughnessTexture"}),v=new i({str:"occlusionTexture"}),x=new i({str:"emissiveFactor"}),g=new i({str:"emissiveTexture"}),y=new i({str:"lightNumber"}),b=new i({str:"lightPosition"}),I=new i({str:"lightDirection"}),A=new i({str:"lightIntensity"}),E=new i({str:"lightProperty"}),S=new i({str:"metallicRoughnessFactor"}),T=new i({str:"brdfLutTexture"}),w=new i({str:"diffuseEnvTexture"}),C=new i({str:"specularEnvTexture"}),R=new i({str:"inverseEnvironment"}),P=new i({str:"iblParameter"}),N=new i({str:"viewPosition"}),M=new i({str:"wireframe"}),D=new i({str:"diffuseColorFactor"}),F=new i({str:"diffuseColorTexture"}),B=new i({str:"shininess"}),L=new i({str:"shadingModel"}),V=new i({str:"skinningMode"}),z=new i({str:"generalTexture"}),G=new i({str:"vertexAttributesExistenceArray"}),O=new i({str:"boneQuaternion"}),U=new i({str:"boneTranslateScale"}),k=new i({str:"boneTranslatePackedQuat"}),W=new i({str:"boneScalePackedQuat"}),Q=new i({str:"boneCompressedChunk"}),q=new i({str:"boneCompressedInfo"}),X=new i({str:"pointSize"}),H=new i({str:"colorEnvTexture"}),j=new i({str:"pointDistanceAttenuation"}),Y=new i({str:"hdriFormat"}),K=new i({str:"screenInfo"}),Z=new i({str:"depthTexture"}),J=new i({str:"lightViewProjectionMatrix"}),$=new i({str:"anisotropy"}),ee=new i({str:"clearcoatParameter"}),te=new i({str:"sheenColorFactor"}),ne=new i({str:"sheenColorTexture"}),oe=new i({str:"sheenRoughnessFactor"}),ae=new i({str:"sheenRoughnessTexture"}),ie=new i({str:"sheenLutTexture"}),re=new i({str:"specularGlossinessFactor"}),se=new i({str:"specularGlossinessTexture"}),le=new i({str:"entityUID"}),ce=new i({str:"morphTargetNumber"}),_e=new i({str:"dataTextureMorphOffsetPosition"}),ue=new i({str:"morphWeights"}),fe=new i({str:"currentComponentSIDs"}),de=new i({str:"alphaCutoff"}),he=new i({str:"alphaTexture"}),me=new i({str:"makeOutputSrgb"}),pe=new i({str:"framebufferSize"}),ve=new i({str:"clearCoatFactor"}),xe=new i({str:"clearCoatTexture"}),ge=new i({str:"clearCoatRoughnessFactor"}),ye=new i({str:"clearCoatRoughnessTexture"}),be=new i({str:"clearCoatNormalTexture"}),Ie=new i({str:"transmissionFactor"}),Ae=new i({str:"transmissionTexture"}),Ee=new i({str:"backBufferTexture"}),Se=new i({str:"backBufferTextureSize"}),Te=new i({str:"thicknessFactor"}),we=new i({str:"thicknessTexture"}),Ce=new i({str:"attenuationDistance"}),Re=new i({str:"attenuationColor"}),Pe=new i({str:"isOutputHDR"}),Ne=new i({str:"baseColorTextureTransform"}),Me=new i({str:"baseColorTextureRotation"}),De=new i({str:"normalTextureTransform"}),Fe=new i({str:"normalTextureRotation"}),Be=new i({str:"metallicRoughnessTextureTransform"}),Le=new i({str:"metallicRoughnessTextureRotation"}),Ve=new i({str:"normalTexcoordIndex"}),ze=new i({str:"baseColorTexcoordIndex"}),Ge=new i({str:"metallicRoughnessTexcoordIndex"}),Oe=new i({str:"occlusionTexcoordIndex"}),Ue=new i({str:"occlusionTextureTransform"}),ke=new i({str:"occlusionTextureRotation"}),We=new i({str:"emissiveTexcoordIndex"}),Qe=new i({str:"emissiveTextureTransform"}),qe=new i({str:"emissiveTextureRotation"}),Xe=new i({str:"normalScale"}),He=new i({str:"occlusionStrength"}),je=new i({str:"envRotation"}),Ye=new i({str:"envHdriFormat"}),Ke=new i({str:"vrState"}),Ze=new i({str:"enableLinearToSrgb"}),Je=new i({str:"specularFactor"}),$e=new i({str:"specularTexture"}),et=new i({str:"specularColorFactor"}),tt=new i({str:"specularColorTexture"}),nt=new i({str:"ior"}),ot=new i({str:"depthBiasPV"}),at=new i({str:"clearCoatTextureTransform"}),it=new i({str:"clearCoatTextureRotation"}),rt=new i({str:"clearCoatRoughnessTextureTransform"}),st=new i({str:"clearCoatRoughnessTextureRotation"}),lt=new i({str:"clearCoatNormalTextureTransform"}),ct=new i({str:"clearCoatNormalTextureRotation"}),_t=new i({str:"clearCoatTexcoordIndex"}),ut=new i({str:"clearCoatRoughnessTexcoordIndex"}),ft=new i({str:"clearCoatNormalTexcoordIndex"}),dt=new i({str:"iridescenceFactor"}),ht=new i({str:"iridescenceTexture"}),mt=new i({str:"iridescenceIor"}),pt=new i({str:"iridescenceThicknessMinimum"}),vt=new i({str:"iridescenceThicknessMaximum"}),xt=new i({str:"iridescenceThicknessTexture"}),gt=new i({str:"gaussianKernelSize"}),yt=new i({str:"gaussianRatio"}),bt=new i({str:"isHorizontal"}),It=new i({str:"anisotropyStrength"}),At=new i({str:"anisotropyRotation"}),Et=new i({str:"anisotropyTexture"}),St=new i({str:"emissiveStrength"}),Tt=new i({str:"time"}),wt=new i({str:"cubeMapFaceId"}),Ct=new i({str:"roughness"}),Rt=new i({str:"distributionType"}),Pt=[r,s,l,c,_,u,f,d,h,m,p,v,x,g,y,b,I,A,E,S,T,w,C,R,P,N,M,D,F,B,L,V,z,G,O,U,k,W,Q,q,X,H,j,Y,K,Z,J,$,ee,te,ne,oe,ae,ie,re,se,le,ce,_e,ue,fe,de,he,me,ve,xe,ge,ye,be,Ie,Ae,Ee,Se,Te,we,Ce,Re,Pe,Ne,Me,De,Fe,Be,Le,Ve,ze,Ge,Oe,Ue,ke,We,Qe,qe,Xe,He,je,Ye,Ke,Ze,Je,$e,et,tt,nt,ot,at,it,rt,st,lt,ct,_t,ut,ft,dt,ht,mt,pt,vt,xt,gt,yt,bt,It,At,Et,St,Tt,wt,Ct,Rt];function Nt(e){return e.index}const Mt=Object.freeze({from:function(e){return(0,o.yH)({typeList:Pt,index:e})},fromString:function(e){return(0,o.Pq)({typeList:Pt,str:e})},fromStringCaseSensitively:function(e){return(0,o.Ol)({typeList:Pt,str:e})},WorldMatrix:r,ViewMatrix:s,IsBillboard:l,EnableViewMatrix:c,ProjectionMatrix:_,NormalMatrix:u,BoneMatrix:f,BaseColorFactor:d,BaseColorTexture:h,NormalTexture:m,MetallicRoughnessTexture:p,OcclusionTexture:v,EmissiveFactor:x,EmissiveTexture:g,LightNumber:y,LightPosition:b,LightDirection:I,LightIntensity:A,LightProperty:E,MetallicRoughnessFactor:S,BrdfLutTexture:T,DiffuseEnvTexture:w,SpecularEnvTexture:C,InverseEnvironment:R,IBLParameter:P,ViewPosition:N,Wireframe:M,DiffuseColorFactor:D,DiffuseColorTexture:F,Shininess:B,ShadingModel:L,SkinningMode:V,GeneralTexture:z,VertexAttributesExistenceArray:G,BoneQuaternion:O,BoneTranslateScale:U,BoneTranslatePackedQuat:k,BoneScalePackedQuat:W,BoneCompressedChunk:Q,BoneCompressedInfo:q,PointSize:X,ColorEnvTexture:H,PointDistanceAttenuation:j,HDRIFormat:Y,ScreenInfo:K,DepthTexture:Z,LightViewProjectionMatrix:J,Anisotropy:$,ClearCoatParameter:ee,SheenColorFactor:te,SheenColorTexture:ne,SheenRoughnessFactor:oe,SheenRoughnessTexture:ae,SheenLutTexture:ie,SpecularGlossinessFactor:re,SpecularGlossinessTexture:se,ClearCoatFactor:ve,ClearCoatTexture:xe,ClearCoatRoughnessFactor:ge,ClearCoatRoughnessTexture:ye,ClearCoatNormalTexture:be,TransmissionFactor:Ie,TransmissionTexture:Ae,BackBufferTexture:Ee,BackBufferTextureSize:Se,ThicknessFactor:Te,ThicknessTexture:we,AttenuationDistance:Ce,AttenuationColor:Re,getShaderProperty:(e,t,n,o)=>{const i=t.compositionType.getGlslStr(t.componentType);let r=t.semantic;const s=t.compositionType.getGlslStr(t.componentType);let l="";t.arrayLength&&(l=`[${t.arrayLength}]`);const c=`  uniform ${s} u_${r}${l};\n`;let _="";a.h.isArray(t.compositionType)?(r.match(/\[.+?\]/)?r=r.replace(/\[.+?\]/g,"[i]"):r+="[i]",_+=`\n        ${i} val;\n          int i = index;\n          return u_${r};\n        `):_+=`return u_${r};`;let u="";return a.h.isTexture(t.compositionType)||(u=`\n  ${i} get_${t.semantic}(float instanceId, int index) {\n    ${_}\n  }\n`),`${c}${u}`},EntityUID:le,MorphTargetNumber:ce,DataTextureMorphOffsetPosition:_e,MorphWeights:ue,CurrentComponentSIDs:fe,AlphaCutoff:de,AlphaTexture:he,MakeOutputSrgb:me,FramebufferSize:pe,IsOutputHDR:Pe,BaseColorTextureTransform:Ne,BaseColorTextureRotation:Me,NormalTextureTransform:De,NormalTextureRotation:Fe,MetallicRoughnessTextureTransform:Be,MetallicRoughnessTextureRotation:Le,NormalTexcoordIndex:Ve,BaseColorTexcoordIndex:ze,MetallicRoughnessTexcoordIndex:Ge,OcclusionTexcoordIndex:Oe,OcclusionTextureTransform:Ue,OcclusionTextureRotation:ke,EmissiveTexcoordIndex:We,EmissiveTextureTransform:Qe,EmissiveTextureRotation:qe,NormalScale:Xe,OcclusionStrength:He,envRotation:je,EnvHdriFormat:Ye,VrState:Ke,EnableLinearToSrgb:Ze,SpecularFactor:Je,SpecularTexture:$e,SpecularColorFactor:et,SpecularColorTexture:tt,Ior:nt,DepthBiasPV:ot,ClearCoatTextureTransform:at,ClearCoatTextureRotation:it,ClearCoatRoughnessTextureTransform:rt,ClearCoatRoughnessTextureRotation:st,ClearCoatNormalTextureTransform:lt,ClearCoatNormalTextureRotation:ct,ClearCoatTexcoordIndex:_t,ClearCoatRoughnessTexcoordIndex:ut,ClearCoatNormalTexcoordIndex:ft,IridescenceFactor:dt,IridescenceTexture:ht,IridescenceIor:mt,IridescenceThicknessMinimum:pt,IridescenceThicknessMaximum:vt,IridescenceThicknessTexture:xt,GaussianKernelSize:gt,GaussianRatio:yt,IsHorizontal:bt,AnisotropyStrength:It,AnisotropyRotation:At,AnisotropyTexture:Et,EmissiveStrength:St,Time:Tt,CubeMapFaceId:wt,Roughness:Ct,DistributionType:Rt})},4127:(e,t,n)=>{n.d(t,{o:()=>i});var o=n(3497),a=n(7751);function i(e){const t=e.compositionType.getNumberOfComponents()*e.componentType.getSizeInBytes();let n=t;if(n%16!=0&&(n=t+16-t%16),a.h.isArray(e.compositionType)){const t=e.arrayLength;null!=t?n*=t:(o.V.error("semanticInfo has invalid maxIndex!"),n*=100)}return n}},4132:(e,t,n)=>{n.d(t,{C:()=>_});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:1,str:"VertexShader"}),r=new a({index:2,str:"PixelShader"}),s=new a({index:3,str:"VertexAndPixelShader"}),l=new a({index:4,str:"ComputeShader"}),c=[i,r,s,l],_=Object.freeze({VertexShader:i,PixelShader:r,VertexAndPixelShader:s,ComputeShader:l,from:function(e){return(0,o.yH)({typeList:c,index:e})},fromString:function(e){return(0,o.Pq)({typeList:c,str:e})}})},9186:(e,t,n)=>{n.d(t,{y:()=>u});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:-1,str:"UNKNOWN"}),r=new a({index:0,str:"CONSTANT"}),s=new a({index:1,str:"LAMBERT"}),l=new a({index:2,str:"BLINN"}),c=new a({index:3,str:"PHONG"}),_=[i,r,s,l,c],u=Object.freeze({Unknown:i,Constant:r,Lambert:s,BlinnPhong:l,Phong:c,from:function(e){return(0,o.yH)({typeList:_,index:e})}})},8393:(e,t,n)=>{n.d(t,{n:()=>E});var o=n(2238),a=n(4324),i=n(4114),r=n(4958);class s extends a.wJ{constructor({index:e,str:t,webgpu:n}){super({index:e,str:t}),this.__webgpu=n}get webgpu(){if(void 0===this.__webgpu)throw new Error(`does not support ${this.str}`);return this.__webgpu}}const l=new s({index:32849,str:"RGB8",webgpu:"rgb8unorm"}),c=new s({index:32856,str:"RGBA8",webgpu:"rgba8unorm"}),_=new s({index:32857,str:"RGB10_A2",webgpu:"rgb10a2unorm"}),u=new s({index:o.Vn9,str:"RG16F",webgpu:"rg16float"}),f=new s({index:o.rBz,str:"RG32F",webgpu:"rg32float"}),d=new s({index:34843,str:"RGB16F",webgpu:"rgba16float"}),h=new s({index:34837,str:"RGB32F",webgpu:"rgba32float"}),m=new s({index:34842,str:"RGBA16F",webgpu:"rgba16float"}),p=new s({index:34836,str:"RGBA32F",webgpu:"rgba32float"}),v=new s({index:35898,str:"R11F_G11F_B10F",webgpu:"rg11b10ufloat"}),x=new s({index:33189,str:"DEPTH_COMPONENT16",webgpu:"depth16unorm"}),g=new s({index:33190,str:"DEPTH_COMPONENT24",webgpu:"depth24plus"}),y=new s({index:36012,str:"DEPTH_COMPONENT32F",webgpu:"depth32float"}),b=new s({index:35056,str:"DEPTH24_STENCIL8",webgpu:"depth24plus-stencil8"}),I=new s({index:36013,str:"DEPTH32F_STENCIL8",webgpu:"depth32float-stencil8"}),A=[l,c,_,u,f,d,h,m,p,v,x,g,y,b,I],E=Object.freeze({RGB8:l,RGBA8:c,RGB10_A2:_,RG16F:u,RG32F:f,RGB16F:d,RGB32F:h,RGBA16F:m,RGBA32F:p,R11F_G11F_B10F:v,Depth16:x,Depth24:g,Depth32F:y,Depth24Stencil8:b,Depth32FStencil8:I,getPixelFormatFromTextureFormat:function(e){switch(e){case l:return r.A.RGB;case c:case _:return r.A.RGBA;case u:case f:return r.A.RG;case d:case h:return r.A.RGB;case m:case p:return r.A.RGBA;case v:return r.A.RGB;case x:case g:case y:return r.A.DepthComponent;case b:case I:return r.A.DepthStencil;default:throw new Error(`Not implemented yet: ${e}`)}},getPixelFormatAndComponentTypeFromTextureFormat:function(e){let t=r.A.RGBA,n=i.I.UnsignedByte;return e===E.RGB8?(t=r.A.RGB,n=i.I.UnsignedByte):e===E.RGBA8||e===E.RGB10_A2?(t=r.A.RGBA,n=i.I.UnsignedByte):e===E.RG16F?(t=r.A.RG,n=i.I.HalfFloat):e===E.RG32F?(t=r.A.RG,n=i.I.Float):e===E.RGB16F?(t=r.A.RGB,n=i.I.HalfFloat):e===E.RGB32F?(t=r.A.RGB,n=i.I.Float):e===E.RGBA16F?(t=r.A.RGBA,n=i.I.HalfFloat):e===E.RGBA32F?(t=r.A.RGBA,n=i.I.Float):e===E.R11F_G11F_B10F?(t=r.A.RGB,n=i.I.Float):e===E.Depth16?(t=r.A.DepthComponent,n=i.I.UnsignedShort):e===E.Depth24||e===E.Depth24Stencil8?(t=r.A.DepthComponent,n=i.I.UnsignedInt):e!==E.Depth32F&&e!==E.Depth32FStencil8||(t=r.A.DepthComponent,n=i.I.Float),{format:t,type:n}},from:function(e){return(0,a.yH)({typeList:A,index:e})}})},1383:(e,t,n)=>{n.d(t,{P:()=>E});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t,webgpu:n}){super({index:e,str:t}),this.__webgpu=n}get webgpu(){if(void 0===this.__webgpu)throw new Error(`does not support ${this.str}`);return this.__webgpu}}const i=new a({index:9728,str:"NEAREST",webgpu:"nearest"}),r=new a({index:9729,str:"LINEAR",webgpu:"linear"}),s=new a({index:9984,str:"NEAREST_MIPMAP_NEAREST",webgpu:"nearest"}),l=new a({index:9985,str:"LINEAR_MIPMAP_NEAREST",webgpu:"linear"}),c=new a({index:9986,str:"NEAREST_MIPMAP_LINEAR",webgpu:"nearest"}),_=new a({index:9987,str:"LINEAR_MIPMAP_LINEAR",webgpu:"linear"}),u=new a({index:10240,str:"TEXTURE_MAG_FILTER"}),f=new a({index:10241,str:"TEXTURE_MIN_FILTER"}),d=new a({index:10242,str:"TEXTURE_WRAP_S"}),h=new a({index:10243,str:"TEXTURE_WRAP_T"}),m=new a({index:3553,str:"TEXTURE_2D"}),p=new a({index:5890,str:"TEXTURE"}),v=new a({index:33984,str:"TEXTURE0"}),x=new a({index:33985,str:"TEXTURE1"}),g=new a({index:34016,str:"ACTIVE_TEXTURE"}),y=new a({index:10497,str:"REPEAT",webgpu:"repeat"}),b=new a({index:33071,str:"CLAMP_TO_EDGE",webgpu:"clamp-to-edge"}),I=new a({index:33648,str:"MIRRORED_REPEAT",webgpu:"mirror-repeat"}),A=[i,r,s,l,c,_,u,f,d,h,m,p,v,x,g,y,b,I],E=Object.freeze({Nearest:i,Linear:r,NearestMipmapNearest:s,LinearMipmapNearest:l,NearestMipmapLinear:c,LinearMipmapLinear:_,TextureMagFilter:u,TextureMinFilter:f,TextureWrapS:d,TextureWrapT:h,Texture2D:m,Texture:p,Texture0:v,Texture1:x,ActiveTexture:g,Repeat:y,ClampToEdge:b,MirroredRepeat:I,from:function(e){return(0,o.yH)({typeList:A,index:e})}})},3639:(e,t,n)=>{n.d(t,{r:()=>b,z:()=>i});var o=n(4324),a=n(9908);class i extends o.wJ{constructor({str:e,shaderStr:t,attributeSlot:n,gltfComponentN:o}){super({index:i.__indexCount++,str:e}),this.__attributeSlot=n,this.__shaderStr=t,this.__gltfComponentN=o}getAttributeSlot(){return this.__attributeSlot}get shaderStr(){return this.__shaderStr}get attributeTypeName(){return this.str}_setShaderStr(e){this.__shaderStr=this.__shaderStr+e}get X(){return`${this.attributeTypeName}.X`}get Y(){return`${this.attributeTypeName}.Y`}get Z(){return`${this.attributeTypeName}.Z`}get W(){return`${this.attributeTypeName}.W`}get XY(){return`${this.attributeTypeName}.X,${this.attributeTypeName}.Y`}get XYZ(){return`${this.attributeTypeName}.X,${this.attributeTypeName}.Y,${this.attributeTypeName}.Z`}get XYZW(){return`${this.attributeTypeName}.X,${this.attributeTypeName}.Y,${this.attributeTypeName}.Z,${this.attributeTypeName}.W`}getVertexAttributeComponentsAsGltf(){if(1===this.__gltfComponentN)return this.X;if(2===this.__gltfComponentN)return this.XY;if(3===this.__gltfComponentN)return this.XYZ;if(4===this.__gltfComponentN)return this.XYZW;throw new a.O({message:"Invalid gltf component number",error:this.__gltfComponentN})}static __createVertexAttributeClass(e){return new i(e)}}i.__indexCount=-1;const r=i.__createVertexAttributeClass({str:"UNKNOWN",shaderStr:"a_unknown",attributeSlot:-1,gltfComponentN:0}),s=i.__createVertexAttributeClass({str:"POSITION",shaderStr:"a_position",attributeSlot:0,gltfComponentN:3}),l=i.__createVertexAttributeClass({str:"NORMAL",shaderStr:"a_normal",attributeSlot:1,gltfComponentN:3}),c=i.__createVertexAttributeClass({str:"TANGENT",shaderStr:"a_tangent",attributeSlot:2,gltfComponentN:4}),_=i.__createVertexAttributeClass({str:"TEXCOORD_0",shaderStr:"a_texcoord_0",attributeSlot:3,gltfComponentN:2}),u=i.__createVertexAttributeClass({str:"TEXCOORD_1",shaderStr:"a_texcoord_1",attributeSlot:4,gltfComponentN:2}),f=i.__createVertexAttributeClass({str:"COLOR_0",shaderStr:"a_color_0",attributeSlot:5,gltfComponentN:4}),d=i.__createVertexAttributeClass({str:"JOINTS_0",shaderStr:"a_joints_0",attributeSlot:6,gltfComponentN:4}),h=i.__createVertexAttributeClass({str:"WEIGHTS_0",shaderStr:"a_weights_0",attributeSlot:7,gltfComponentN:4}),m=i.__createVertexAttributeClass({str:"INSTANCE",shaderStr:"a_instanceInfo",attributeSlot:8,gltfComponentN:4}),p=i.__createVertexAttributeClass({str:"FACE_NORMAL",shaderStr:"a_faceNormal",attributeSlot:9,gltfComponentN:3}),v=i.__createVertexAttributeClass({str:"BARY_CENTRIC_COORD",shaderStr:"a_baryCentricCoord",attributeSlot:10,gltfComponentN:4}),x=i.__createVertexAttributeClass({str:"TEXCOORD_2",shaderStr:"a_texcoord_2",attributeSlot:11,gltfComponentN:2}),g=[r,s,l,c,_,u,f,d,h,m,p,v,x],y=g.length-1,b=Object.freeze({Unknown:r,Position:s,Normal:l,Tangent:c,Texcoord0:_,Texcoord1:u,Color0:f,Joints0:d,Weights0:h,Instance:m,FaceNormal:p,BaryCentricCoord:v,AttributeTypeNumber:y,isInstanceOfVertexAttributeClass:function(e){return e instanceof i},toVertexAttributeSemanticJoinedStringAsGltfStyle:function(e){switch(e){case s:case f:case l:case c:return e.XYZ;case _:case u:case x:return e.XY;case d:case h:case m:case p:case v:return e.XYZW;default:throw new Error("Invalied glTF VertexAttributeEnum")}},toAttributeSlotFromJoinedString:function(e){switch(e){case s.XYZ:return s.getAttributeSlot();case f.XYZ:return f.getAttributeSlot();case l.XYZ:return l.getAttributeSlot();case c.XYZ:return c.getAttributeSlot();case _.XY:return _.getAttributeSlot();case u.XY:return u.getAttributeSlot();case x.XY:return x.getAttributeSlot();case d.XYZW:return d.getAttributeSlot();case h.XYZW:return h.getAttributeSlot();case m.XYZW:return m.getAttributeSlot();case p.XYZ:return p.getAttributeSlot();case v.XYZ:return v.getAttributeSlot();default:throw new Error("Invalied glTF VertexAttributeEnum")}},toVectorComponentN:function(e){return e.split(",").length},from:function(e){return(0,o.yH)({typeList:g,index:e})},fromString:function(e){let t=e;return"COLOR"===e?t="COLOR_0":"TEXCOORD"===e?t="TEXCOORD_0":"JOINTS"===e?t="JOINTS_0":"WEIGHTS"===e&&(t="WEIGHTS_0"),(0,o.Pq)({typeList:g,str:t})}})},2766:(e,t,n)=>{n.d(t,{Km:()=>o.K,R$:()=>a.R,v$:()=>i.v,F:()=>r.F,Nj:()=>s.N,aT:()=>l.a,EA:()=>c.E,Aq:()=>_.A,I5:()=>u.I,hY:()=>f.h,sJ:()=>d.s,pt:()=>h.p,P8:()=>m.P,zY:()=>p.z,Ab:()=>v.A,Rs:()=>x.R,m7:()=>g.m,av:()=>g.a,Ow:()=>y.O,qB:()=>b.q,mq:()=>I.m,lk:()=>A.lk,jc:()=>A.jc,Co:()=>S.C,kj:()=>N,yD:()=>M.y,pC:()=>V,nC:()=>z.n,gu:()=>G.P,JK:()=>ne,rz:()=>O.r,zc:()=>O.z,bv:()=>X,zb:()=>A.zb,oM:()=>E.o});var o=n(6338),a=n(375),i=n(833),r=n(7925),s=n(6195),l=n(7616),c=n(5118),_=n(5250),u=n(4114),f=n(7751),d=n(5216),h=n(6747),m=n(9747),p=n(9201),v=n(4958),x=n(6947),g=n(3212),y=n(5368),b=n(3686),I=n(9156),A=n(9871),E=n(4127),S=n(4132),T=n(4324);class w extends T.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const C=new w({index:1,str:"Varying"}),R=new w({index:2,str:"ReadOnlyData"}),P=[C,R],N=Object.freeze({Varying:C,ReadOnlyData:R,from:function(e){return(0,T.yH)({typeList:P,index:e})},fromString:function(e){return(0,T.Pq)({typeList:P,str:e})}});var M=n(9186);class D extends T.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const F=new D({index:0,str:"Standard"}),B=new D({index:1,str:"Variance"}),L=[F,B],V=Object.freeze({Standard:F,Variance:B,from:function(e){return(0,T.yH)({typeList:L,index:e})},fromString:function(e){return(0,T.Pq)({typeList:L,str:e})}});var z=n(8393),G=n(1383),O=n(3639);class U extends T.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const k=new U({index:0,str:"Neutral"}),W=new U({index:1,str:"Visible"}),Q=new U({index:-1,str:"Invisible"}),q=[W,Q,k],X=Object.freeze({Visible:W,Invisible:Q,Neutral:k,from:function(e){return(0,T.yH)({typeList:q,index:e})},fromString:function(e){return(0,T.Pq)({typeList:q,str:e})}});class H extends T.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const j=new H({index:-1,str:"None"}),Y=new H({index:0,str:"Khronos_PBR_Neutral"}),K=new H({index:1,str:"Reinhard"}),Z=new H({index:2,str:"GT_ToneMap"}),J=new H({index:3,str:"ACES_Filmic_ToneMap_Narkowicz"}),$=new H({index:4,str:"ACES_Filmic_ToneMap_Hill"}),ee=new H({index:5,str:"ACES_Filmic_ToneMap_Hill_Exposure_Boost"}),te=[j,Y,K,Z,J,$,ee],ne=Object.freeze({None:j,KhronosPbrNeutral:Y,Reinhard:K,GT_ToneMap:Z,ACES_Narkowicz:J,ACES_Hill:$,ACES_Hill_Exposure_Boost:ee,from:function(e){return(0,T.yH)({typeList:te,index:e})}})},4343:(e,t,n)=>{n.d(t,{P:()=>s});var o=n(3414),a=n(3870),i=n(7476),r=n(8924);class s{constructor(){this.top=r.Am.zero(),this.bottom=r.Am.zero(),this.right=r.Am.zero(),this.left=r.Am.zero(),this.zNear=r.Am.zero(),this.zFar=r.Am.zero(),this.__updated=!1,this.__vp=i.g.zero(),this.__invProjMat=i.g.zero(),this.__invViewMat=i.g.zero(),this.__tmp_vec4_0=r.Am.zero(),this.__tmp_vec4_1=r.Am.zero(),this.__tmp_vec4_array=[r.Am.zero(),r.Am.zero(),r.Am.zero(),r.Am.zero(),r.Am.zero(),r.Am.zero(),r.Am.zero(),r.Am.zero()],this.__hCorners=[o.IU.fromCopy4(-1,1,1,1),o.IU.fromCopy4(1,1,1,1),o.IU.fromCopy4(1,-1,1,1),o.IU.fromCopy4(-1,-1,1,1),o.IU.fromCopy4(-1,1,-1,1),o.IU.fromCopy4(1,1,-1,1),o.IU.fromCopy4(1,-1,-1,1),o.IU.fromCopy4(-1,-1,-1,1)],this.corners=[]}update(e,t){a._.multiplyTo(t,e,this.__vp),this.zNear.x=this.__vp.m20+this.__vp.m30,this.zNear.y=this.__vp.m21+this.__vp.m31,this.zNear.z=this.__vp.m22+this.__vp.m32,this.zNear.w=this.__vp.m23+this.__vp.m33,this.zFar.x=-this.__vp.m20+this.__vp.m30,this.zFar.y=-this.__vp.m21+this.__vp.m31,this.zFar.z=-this.__vp.m22+this.__vp.m32,this.zFar.w=-this.__vp.m23+this.__vp.m33,this.bottom.x=this.__vp.m10+this.__vp.m30,this.bottom.y=this.__vp.m11+this.__vp.m31,this.bottom.z=this.__vp.m12+this.__vp.m32,this.bottom.w=this.__vp.m13+this.__vp.m33,this.top.x=-this.__vp.m10+this.__vp.m30,this.top.y=-this.__vp.m11+this.__vp.m31,this.top.z=-this.__vp.m12+this.__vp.m32,this.top.w=-this.__vp.m13+this.__vp.m33,this.left.x=this.__vp.m00+this.__vp.m30,this.left.y=this.__vp.m01+this.__vp.m31,this.left.z=this.__vp.m02+this.__vp.m32,this.left.w=this.__vp.m03+this.__vp.m33,this.right.x=-this.__vp.m00+this.__vp.m30,this.right.y=-this.__vp.m01+this.__vp.m31,this.right.z=-this.__vp.m02+this.__vp.m32,this.right.w=-this.__vp.m03+this.__vp.m33,a._.invertTo(t,this.__invProjMat),a._.invertTo(e,this.__invViewMat);for(let e=0;e<8;e++)this.__invProjMat.multiplyVectorTo(this.__hCorners[e],this.__tmp_vec4_0),this.__tmp_vec4_1.x=this.__tmp_vec4_0.x/this.__tmp_vec4_0.w,this.__tmp_vec4_1.y=this.__tmp_vec4_0.y/this.__tmp_vec4_0.w,this.__tmp_vec4_1.z=this.__tmp_vec4_0.z/this.__tmp_vec4_0.w,this.__tmp_vec4_1.w=1,this.__invViewMat.multiplyVectorTo(this.__tmp_vec4_1,this.__tmp_vec4_array[e]),this.corners[e]=this.__tmp_vec4_array[e]}culling(e){const t=e.entity.getSceneGraph().worldMergedAABBWithSkeletal;for(let e=0;e<6;e++){let n=0;const o=this.getPlane(e);if(n+=o.x*t.minPoint.x+o.y*t.minPoint.y+o.z*t.minPoint.z+o.w<0?1:0,n+=o.x*t.maxPoint.x+o.y*t.minPoint.y+o.z*t.minPoint.z+o.w<0?1:0,n+=o.x*t.minPoint.x+o.y*t.maxPoint.y+o.z*t.minPoint.z+o.w<0?1:0,n+=o.x*t.maxPoint.x+o.y*t.maxPoint.y+o.z*t.minPoint.z+o.w<0?1:0,n+=o.x*t.minPoint.x+o.y*t.minPoint.y+o.z*t.maxPoint.z+o.w<0?1:0,n+=o.x*t.maxPoint.x+o.y*t.minPoint.y+o.z*t.maxPoint.z+o.w<0?1:0,n+=o.x*t.minPoint.x+o.y*t.maxPoint.y+o.z*t.maxPoint.z+o.w<0?1:0,n+=o.x*t.maxPoint.x+o.y*t.maxPoint.y+o.z*t.maxPoint.z+o.w<0?1:0,8===n)return!1}let n=0;n=0;for(let e=0;e<8;e++)n+=this.corners[e].x>t.maxPoint.x?1:0;if(8===n)return!1;n=0;for(let e=0;e<8;e++)n+=this.corners[e].x<t.minPoint.x?1:0;if(8===n)return!1;n=0;for(let e=0;e<8;e++)n+=this.corners[e].y>t.maxPoint.y?1:0;if(8===n)return!1;n=0;for(let e=0;e<8;e++)n+=this.corners[e].y<t.minPoint.y?1:0;if(8===n)return!1;n=0;for(let e=0;e<8;e++)n+=this.corners[e].z>t.maxPoint.z?1:0;if(8===n)return!1;n=0;for(let e=0;e<8;e++)n+=this.corners[e].z<t.minPoint.z?1:0;return 8!==n}getPlane(e){switch(e){case 0:return this.top;case 1:return this.bottom;case 2:return this.right;case 3:return this.left;case 4:return this.zNear;case 5:return this.zFar;default:throw new Error("Invalid plane index.")}}}},2212:(e,t,n)=>{n.d(t,{e:()=>v});var o=n(3639),a=n(6947),i=n(7496),r=n(7616),s=n(4114),l=n(7751),c=n(975),_=n(3629),u=n(4772),f=n(5697),d=n(2229),h=n(6054),m=n(5368),p=n(3497);class v{constructor(){this.__primitives=[],this.__opaquePrimitives=[],this.__translucentPrimitives=[],this.__blendWithZWritePrimitives=[],this.__blendWithoutZWritePrimitives=[],this.__morphPrimitives=[],this.__localAABB=new _.F,this.__vaoUids=[],this.__variationVBOUid=u.f.InvalidCGAPIResourceUid,this.__latestPrimitivePositionAccessorVersionForAABB=0,this.__latestPrimitivePositionAccessorVersionForSetUpDone=0,this.__belongToEntities=[],this.tangentCalculationMode=1,this.__hasFaceNormal=!1,this.__primitivePositionUpdateCount=0,this.__meshUID=++v.__mesh_uid_count}getVaoUids(e){return this.__vaoUids[e]}getVaoUidsByPrimitiveUid(e){const t=this.__primitives.findIndex((t=>t.primitiveUid===e));return this.__vaoUids[t]}get meshEntitiesInner(){return this.__belongToEntities}_belongToMeshComponent(e){this.__belongToEntities.push(e.entity)}addPrimitive(e){e._belongToMesh(this),(0,h.qp)(e)?this.__opaquePrimitives.push(e):(0,h.eG)(e)?this.__translucentPrimitives.push(e):(0,h.pc)(e)?this.__blendWithZWritePrimitives.push(e):(0,h.VG)(e)&&this.__blendWithoutZWritePrimitives.push(e),this.__setPrimitives(this.__opaquePrimitives.concat(this.__translucentPrimitives).concat(this.__blendWithZWritePrimitives).concat(this.__blendWithoutZWritePrimitives))}__setPrimitives(e){this.__primitives=e}isExistOpaque(){return this.__opaquePrimitives.length>0}isExistTranslucent(){return this.__translucentPrimitives.length>0}isExistBlendWithZWrite(){return this.__blendWithZWritePrimitives.length>0}isExistBlendWithoutZWrite(){return this.__blendWithoutZWritePrimitives.length>0}getPrimitiveAt(e){return this.__primitives[e]}getPrimitiveNumber(){return this.__primitives.length}updateVariationVBO(){const e=u.f.getCgApiResourceRepository();this.__variationVBOUid!==u.f.InvalidCGAPIResourceUid&&e.deleteVertexBuffer(this.__variationVBOUid);const t=this.__belongToEntities.length,n=new Float32Array(4*t);for(let e=0;e<t;e++){n[4*e+0]=this.__belongToEntities[e].getSceneGraph().componentSID;const t=this.__belongToEntities[e].tryToGetSkeletal();n[4*e+1]=null!=t?t.componentSID:-1;const o=this.__belongToEntities[e].tryToGetBlendShape();n[4*e+2]=null!=o?o.componentSID:-1}return this.__variationVBOUid=e.createVertexBufferFromTypedArray(n),!0}deleteVariationVBO(){const e=u.f.getCgApiResourceRepository();return this.__variationVBOUid!==u.f.InvalidCGAPIResourceUid&&(e.deleteVertexBuffer(this.__variationVBOUid),this.__variationVBOUid=u.f.InvalidCGAPIResourceUid,!0)}updateVAO(){const e=u.f.getWebGLResourceRepository();for(let t=0;t<this.__primitives.length;t++){const n=this.__primitives[t],o=n.vertexHandles;d.Is.undefined(o)?p.V.warn("Need to create 3DAPIVertexData before update VAO"):((isNaN(this.__vaoUids[t])||this.__vaoUids[t]===u.f.InvalidCGAPIResourceUid||o.vaoHandle===u.f.InvalidCGAPIResourceUid)&&(this.__vaoUids[t]=e.createVertexArray(),o.vaoHandle=this.__vaoUids[t]),e.setVertexDataToPipeline(o,n,this.__variationVBOUid))}for(let t=this.__primitives.length;t<this.__vaoUids.length;t++)this.__vaoUids[t]&&(e.deleteVertexArray(this.__vaoUids[t]),this.__vaoUids[t]=u.f.InvalidCGAPIResourceUid)}deleteVAO(){const e=u.f.getWebGLResourceRepository();for(let t=0;t<this.__vaoUids.length;t++)e.deleteVertexArray(this.__vaoUids[t]),this.__vaoUids[t]=u.f.InvalidCGAPIResourceUid}castRay(e,t,n=0){var o;let a,i=Number.MAX_VALUE,r=0,s=0;for(const l of this.__primitives){const c=l.castRay(e,t,!0,!0,n,this.__hasFaceNormal);d.Is.defined(c.data)&&(null===(o=c.data)||void 0===o?void 0:o.t)<i&&(i=c.data.t,a=c.data.position,r=c.data.u,s=c.data.v)}return d.Is.defined(a)?{result:!0,data:{t:i,u:r,v:s,position:a}}:{result:!1}}get primitives(){return this.__primitives}get meshUID(){return this.__meshUID}get _variationVBOUid(){return this.__variationVBOUid}_onPrimitivePositionUpdated(){this.__primitivePositionUpdateCount++;for(const e of this.__belongToEntities)e.getMeshRenderer().moveStageTo(m.O.Load)}get primitivePositionUpdateCount(){return this.__primitivePositionUpdateCount}get AABB(){if(this.__primitivePositionUpdateCount!==this.__latestPrimitivePositionAccessorVersionForAABB&&(this.__localAABB.initialize(),this.__latestPrimitivePositionAccessorVersionForAABB=this.__primitivePositionUpdateCount),this.__localAABB.isVanilla())for(const e of this.__primitives)this.__localAABB.mergeAABB(e.AABB);return this.__localAABB}__calcMorphPrimitives(){for(let e=0;e<this.__primitives.length;e++){const t=this.__morphPrimitives[e],n=this.__primitives[e];n.targets[0].forEach(((e,o)=>{const a=t.getAttribute(o),i=a.elementCount;for(let e=0;e<i;e++)a.setElementFromSameCompositionAccessor(e,n.getAttribute(o))}))}}_calcTangents(){if(this.__usePreCalculatedTangent())for(const e of this.__primitives){if(-1!==e.attributeSemantics.indexOf(o.r.Tangent.XYZ)&&2===this.tangentCalculationMode)continue;const t=e.attributeSemantics.indexOf(o.r.Texcoord0.XY),n=e.attributeSemantics.indexOf(o.r.Normal.XYZ);if(-1!==t&&-1!==n){const c=e.attributeSemantics.indexOf(o.r.Position.XYZ),_=e.attributeAccessors[c],u=e.attributeAccessors[t],f=e.attributeAccessors[n],d=e.indicesAccessor;let h=3;e.primitiveMode!==a.R.TriangleStrip&&e.primitiveMode!==a.R.TriangleFan||(h=1);const m=e.getVertexCountAsIndicesBased(),p=i.X.getInstance().createOrGetBuffer(r.a.CPUGeneric),v=4*_.byteLength/3,x=p.takeBufferView({byteLengthToNeed:v,byteStride:0}).unwrapForce().takeAccessor({compositionType:l.h.Vec4,componentType:s.I.Float,count:_.elementCount}).unwrapForce();for(let e=0;e<m-2;e+=h){const t=_.getVec3(e,{indicesAccessor:d}),n=_.getVec3(e+1,{indicesAccessor:d}),o=_.getVec3(e+2,{indicesAccessor:d}),a=u.getVec2(e,{indicesAccessor:d}),i=u.getVec2(e+1,{indicesAccessor:d}),r=u.getVec2(e+2,{indicesAccessor:d}),s=f.getVec3(e,{indicesAccessor:d});this.__calcTangentFor3Vertices(e,t,n,o,a,i,r,s,x,d)}e.setVertexAttribute(x,o.r.Tangent.XYZ)}}}__calcTangentFor3Vertices(e,t,n,o,a,i,r,s,l,c){const _=this.__calcTangentPerVertex(t,n,o,a,i,r,s,v.__tmpReturnVec3_0),u=this.__calcTangentPerVertex(n,o,t,i,r,a,s,v.__tmpReturnVec3_1),f=this.__calcTangentPerVertex(o,t,n,r,a,i,s,v.__tmpReturnVec3_2);l.setVec4(e,_.x,_.y,_.z,1,{indicesAccessor:c}),l.setVec4(e+1,u.x,u.y,u.z,1,{indicesAccessor:c}),l.setVec4(e+2,f.x,f.y,f.z,1,{indicesAccessor:c})}__calcTangentPerVertex(e,t,n,o,a,i,r,s){const l=[v.__tmpVec3_0.setComponents(e.x,o.x,o.y),v.__tmpVec3_1.setComponents(e.y,o.x,o.y),v.__tmpVec3_2.setComponents(e.z,o.x,o.y)],_=[v.__tmpVec3_3.setComponents(t.x,a.x,a.y),v.__tmpVec3_4.setComponents(t.y,a.x,a.y),v.__tmpVec3_5.setComponents(t.z,a.x,a.y)],u=[v.__tmpVec3_6.setComponents(n.x,i.x,i.y),v.__tmpVec3_7.setComponents(n.y,i.x,i.y),v.__tmpVec3_8.setComponents(n.z,i.x,i.y)],d=[],h=[];for(let e=0;e<3;e++){const t=f.tp.subtractTo(_[e],l[e],v.__tmpVec3_9),n=f.tp.subtractTo(u[e],_[e],v.__tmpVec3_10),o=f.tp.crossTo(t,n,v.__tmpVec3_11),a=Math.abs(o.x)<Number.EPSILON;if(a)return p.V.assert(a,"Polygons or polygons on UV are degenerate!"),c.Pq.fromCopyArray([0,0,0]);d[e]=-o.y/o.x,h[e]=-o.z/o.x}return d[0]*d[0]+d[1]*d[1]+d[2]*d[2]<Number.EPSILON?(f.tp.crossTo(r,t,s),s.normalize()):s.setComponents(d[0],d[1],d[2]).normalize()}__usePreCalculatedTangent(){return 0!==this.tangentCalculationMode&&1!==this.tangentCalculationMode&&3!==this.tangentCalculationMode}_calcBaryCentricCoord(){for(const e of this.__primitives){if(-1!==e.attributeSemantics.indexOf(o.r.BaryCentricCoord.XYZ))return;const t=i.X.getInstance().createOrGetBuffer(r.a.CPUGeneric),n=e.attributeSemantics.indexOf(o.r.Position.XYZ),a=e.attributeAccessors[n].elementCount,c=4*a*4,_=t.takeBufferView({byteLengthToNeed:c,byteStride:0}).unwrapForce().takeAccessor({compositionType:l.h.Vec4,componentType:s.I.Float,count:a}).unwrapForce();for(let e=0;e<a;e++)_.setVec4(e,e%3==0?1:0,e%3==1?1:0,e%3==2?1:0,e,{});e.setVertexAttribute(_,o.r.BaryCentricCoord.XYZ)}}_calcFaceNormalsIfNonNormal(){for(const e of this.__primitives){if(-1!==e.attributeSemantics.indexOf(o.r.Normal.XYZ))return;this.__hasFaceNormal=!0;const t=e.attributeSemantics.indexOf(o.r.Position.XYZ),n=e.attributeAccessors[t],c=e.indicesAccessor;let _=3;e.primitiveMode!==a.R.TriangleStrip&&e.primitiveMode!==a.R.TriangleFan||(_=1);const u=e.getVertexCountAsIndicesBased(),f=i.X.getInstance().createOrGetBuffer(r.a.CPUGeneric),d=n.byteLength,h=f.takeBufferView({byteLengthToNeed:d,byteStride:0}).unwrapForce().takeAccessor({compositionType:l.h.Vec3,componentType:s.I.Float,count:n.elementCount}).unwrapForce();for(let e=0;e<u-2;e+=_){const t=n.getVec3(e,{indicesAccessor:c}),o=n.getVec3(e+1,{indicesAccessor:c}),a=n.getVec3(e+2,{indicesAccessor:c});this.__calcFaceNormalFor3Vertices(e,t,o,a,h,c)}e.setVertexAttribute(h,o.r.Normal.XYZ)}}__calcFaceNormalFor3Vertices(e,t,n,o,a,i){const r=n.x-t.x,s=n.y-t.y,l=n.z-t.z,c=o.x-t.x,_=o.y-t.y,u=o.z-t.z;let f=s*u-l*_,d=l*c-r*u,h=r*_-s*c,m=Math.hypot(f,d,h);m<=1e-6&&(m=1e-4),m=1/m,f*=m,d*=m,h*=m,a.setVec3(e,f,d,h,{indicesAccessor:i}),a.setVec3(e+1,f,d,h,{indicesAccessor:i}),a.setVec3(e+2,f,d,h,{indicesAccessor:i})}getPrimitiveIndexInMesh(e){return this.primitives.indexOf(e)}applyMaterialVariant(e){for(const t of this.primitives)t.applyMaterialVariant(e)}getCurrentVariantName(){const e=this.primitives.map((e=>e.getCurrentVariantName()));return 0===e.length?"":(t=e).every((e=>e===t[0]))?e[0]:"";var t}getVariantNames(){const e=[];for(const t of this.primitives)Array.prototype.push.apply(e,t.getVariantNames());return e}isSetUpDone(){let e=!0;for(const t of this.primitives)if(null==t.vertexHandles){e=!1;break}return!(!e||this.__latestPrimitivePositionAccessorVersionForSetUpDone!==this.__primitivePositionUpdateCount&&(this.__latestPrimitivePositionAccessorVersionForSetUpDone=this.__primitivePositionUpdateCount,1))}}v.invalidateMeshUID=-1,v.__mesh_uid_count=v.invalidateMeshUID,v.__tmpVec3_0=f.tp.zero(),v.__tmpVec3_1=f.tp.zero(),v.__tmpVec3_2=f.tp.zero(),v.__tmpVec3_3=f.tp.zero(),v.__tmpVec3_4=f.tp.zero(),v.__tmpVec3_5=f.tp.zero(),v.__tmpVec3_6=f.tp.zero(),v.__tmpVec3_7=f.tp.zero(),v.__tmpVec3_8=f.tp.zero(),v.__tmpVec3_9=f.tp.zero(),v.__tmpVec3_10=f.tp.zero(),v.__tmpVec3_11=f.tp.zero(),v.__tmpReturnVec3_0=f.tp.zero(),v.__tmpReturnVec3_1=f.tp.zero(),v.__tmpReturnVec3_2=f.tp.zero()},960:(e,t,n)=>{n.d(t,{s:()=>b});var o=n(6947),a=n(3639),i=n(8819),r=n(4114),s=n(7496),l=n(7751),c=n(3629),_=n(9620),u=n(4772),f=n(975),d=n(5697),h=n(2229),m=n(6054),p=n(1276),v=n(5065),x=n(5338),g=n(9908),y=n(3497);class b extends i.E{constructor(){super(),this.__mode=o.R.Unknown,this.__materialVariants=new Map,this.__currentVariantName="",this.__attributes=new Map,this.__oIndices=new p.NV,this.__primitiveUid=-1,this.__aabb=new c.F,this.__targets=[],this._sortkey=0,this._viewDepth=0,this.__latestPositionAccessorVersion=0,this.__positionAccessorVersion=0,this.__fingerPrint="",null==b.__defaultMaterial&&(b.__defaultMaterial=_.m.createClassicUberMaterial({isSkinning:!0,isLighting:!0})),this.__material=b.__defaultMaterial,this._prevMaterial=new WeakRef(b.__defaultMaterial)}calcFingerPrint(){let e="";e+=this.__mode.index,this.__oIndices.has()&&(e+=this.getIndexBitSize()),e+=this.targets.length,e+=b.getPrimitiveIdxHasMorph(this.__primitiveUid);for(const[t,n]of this.__attributes)e+=t,e+=n.componentType.webgpu+n.compositionType.webgpu,e+=n.actualByteStride;this.__fingerPrint=e}_getFingerPrint(){return this.__fingerPrint}static getPrimitiveIdxHasMorph(e){return this.__primitiveUidIdxHasMorph.get(e)}static getPrimitiveHasMorph(e){var t;return null===(t=this.__idxPrimitiveUidHasMorph.get(e))||void 0===t?void 0:t.deref()}getIndexBitSize(){const e=this.__oIndices.unwrapOrUndefined();if(null==e)throw new Error("indexAccessor is null");if(e.componentType===r.I.UnsignedShort)return"uint16";if(e.componentType===r.I.UnsignedInt)return"uint32";if(e.componentType===r.I.UnsignedByte)return"uint16";throw new Error("unknown indexAccessor.componentType")}get _vertexHandles(){return this.__vertexHandles}static get variantUpdateCount(){return this.__variantUpdateCount}setMaterialVariant(e,t){this.__materialVariants.set(e,t),b.__variantUpdateCount++}applyMaterialVariant(e){const t=this.__materialVariants.get(e);t&&(this.material=t,this.__currentVariantName=e,b.__variantUpdateCount++)}getCurrentVariantName(){for(const[e,t]of this.__materialVariants)if(t===this.__material)return e;return""}getVariantNames(){return Array.from(this.__materialVariants.keys())}getVariantMaterial(e){return this.__materialVariants.get(e)}set material(e){this.__material=e,this.setSortKey(m.AE,m.l$,e.materialUID);let t=0;e.isTranslucentOpaque()?t=1:e.isBlend()&&(t=e.zWriteWhenBlend?2:3),this.setSortKey(m.mP,m.nm,t),e._addBelongPrimitive(this)}get material(){return this.__material}setSortKey(e,t,n){const o=n<<e;this._sortkey|=o;let a=(1<<t)-1;this._sortkey&=~(a<<e),this._sortkey|=(n&a)<<e}_belongToMesh(e){this.__mesh=e}get mesh(){return this.__mesh}_backupMaterial(){this._prevMaterial=new WeakRef(this.__material)}_restoreMaterial(){const e=this._prevMaterial.deref();null!=e&&(this.__material=e)}static getPrimitive(e){var t;return null===(t=this.__primitives[e])||void 0===t?void 0:t.deref()}static getPrimitiveCount(){return this.__primitiveCount}onAccessorUpdated(e){this.__positionAccessorVersion=e,null!=this.__mesh&&this.__mesh._onPrimitivePositionUpdated()}setData(e,t,n,o){this.__oIndices=null!=o?new p.p2(o):new p.NV,this.__attributes=e,this.__attributes.get(a.r.Position.XYZ)._primitive=new WeakRef(this),this.material=null!=n?n:_.m.createClassicUberMaterial({isSkinning:!0,isLighting:!0}),this.__mode=t,this.setSortKey(m.a8,m.$y,t.index),this.__primitiveUid=b.__primitiveCount++,b.__primitives[this.__primitiveUid]=new WeakRef(this),this.calcFingerPrint()}static get maxPrimitiveCount(){return 500}copyVertexData({attributes:e,attributeSemantics:t,primitiveMode:n,indices:o,material:i}){let c=0;e.forEach((e=>{c+=e.byteLength}));let _=c;null!=o&&(_+=v.$.addPaddingBytes(o.byteLength,4));const u=s.X.getInstance().createBufferOnDemand(_,this,4);let f,d;if(null!=o){f=r.I.fromTypedArray(o);const e=u.takeBufferView({byteLengthToNeed:o.byteLength,byteStride:0});if(e.isErr())throw new g.O(e.getRnError());const t=e.get().takeAccessor({compositionType:l.h.Scalar,componentType:f,count:o.byteLength/f.getSizeInBytes()});if(t.isErr())throw new g.O(t.getRnError());d=t.get();for(let e=0;e<o.byteLength/d.componentSizeInBytes;e++)d.setScalar(e,o[e],{})}const h=u.takeBufferView({byteLengthToNeed:c,byteStride:0}).unwrapForce(),m=[],p=[];e.forEach(((n,o)=>{const i=l.h.vectorFrom(a.r.toVectorComponentN(t[o]));p[o]=r.I.fromTypedArray(e[o]);const s=h.takeAccessor({compositionType:i,componentType:r.I.fromTypedArray(e[o]),count:n.byteLength/i.getNumberOfComponents()/p[o].getSizeInBytes()}).unwrapForce();s.copyFromTypedArray(n),m.push(s)}));const x=new Map;for(let e=0;e<t.length;e++){const n=t[e];x.set(n,m[e])}this.setData(x,n,i,d)}static createPrimitive(e){const t=new b;return t.copyVertexData(e),t}get indicesAccessor(){return this.__oIndices.unwrapOrUndefined()}getVertexCountAsIndicesBased(){return this.indicesAccessor?this.indicesAccessor.elementCount:this.getVertexCountAsVerticesBased()}getVertexCountAsVerticesBased(){for(const e of this.__attributes.values())return e.elementCount;return 0}getTriangleCountAsIndicesBased(){if(!this.indicesAccessor)return this.getTriangleCountAsVerticesBased();switch(this.__mode){case o.R.Triangles:return this.indicesAccessor.elementCount/3;case o.R.TriangleStrip:case o.R.TriangleFan:return this.indicesAccessor.elementCount-2;default:return 0}}getTriangleCountAsVerticesBased(){for(const e of this.__attributes.values())switch(this.__mode){case o.R.Triangles:return e.elementCount/3;case o.R.TriangleStrip:case o.R.TriangleFan:return e.elementCount-2;default:return 0}return 0}hasIndices(){return this.__oIndices.has()}get attributeAccessors(){const e=[];return this.__attributes.forEach(((t,n)=>{e.push(t)})),e}getAttribute(e){return this.__attributes.get(e)}get attributeSemantics(){const e=[];return this.__attributes.forEach(((t,n)=>{e.push(n)})),e}get attributeEntries(){return this.__attributes.entries()}get attributeCompositionTypes(){const e=[];return this.__attributes.forEach(((t,n)=>{e.push(t.compositionType)})),e}get attributeComponentTypes(){const e=[];return this.__attributes.forEach(((t,n)=>{e.push(t.componentType)})),e}get primitiveMode(){return this.__mode}get primitiveUid(){return this.__primitiveUid}get positionAccessorVersion(){return this.__positionAccessorVersion}get AABB(){if(this.__aabb.isVanilla()||this.positionAccessorVersion!==this.__latestPositionAccessorVersion){const e=this.__attributes.get(a.r.Position.XYZ),t=e.min;this.__aabb.minPoint=b.__tmpVec3_0.setComponents(t[0],t[1],t[2]);const n=e.max;this.__aabb.maxPoint=b.__tmpVec3_0.setComponents(n[0],n[1],n[2]),this.__latestPositionAccessorVersion=e.version}return this.__aabb}setVertexAttribute(e,t){this.__attributes.set(t,e)}removeIndices(){this.__oIndices=new p.NV}setIndices(e){this.__oIndices=new p.p2(e)}setBlendShapeTargets(e){b.__primitiveUidIdxHasMorph.size>=x.T.maxVertexPrimitiveNumberInShader?y.V.error("Primitive.__primitiveUidsHasMorph.size exceeds the Config.maxMorphPrimitiveNumber"):(b.__idxPrimitiveUidHasMorph.set(b.__primitiveCountHasMorph,new WeakRef(this)),b.__primitiveUidIdxHasMorph.set(this.__primitiveUid,b.__primitiveCountHasMorph++)),this.__targets=e,this.calcFingerPrint()}getBlendShapeTargets(){return this.__targets.concat()}get targets(){return this.__targets}isBlend(){return!(null==this.material||!this.material.isBlend())}isOpaque(){return!this.isBlend()}create3DAPIVertexData(){if(null!=this.__vertexHandles)return!1;const e=u.f.getCgApiResourceRepository();return this.__vertexHandles=e.createVertexBufferAndIndexBuffer(this),!0}update3DAPIVertexData(){const e=this.__vertexHandles;return!h.Is.not.exist(this.__vertexHandles)&&(u.f.getCgApiResourceRepository().updateVertexBufferAndIndexBuffer(this,e),!0)}delete3DAPIVertexData(){return null!=this.__vertexHandles&&(u.f.getWebGLResourceRepository().deleteVertexDataResources(this.__vertexHandles),this.__vertexHandles=void 0,!0)}get vertexHandles(){return this.__vertexHandles}castRay(e,t,n,a,i,r){let s=Number.MAX_VALUE,l=3;if(this.__mode===o.R.TriangleStrip)l=1;else if(this.__mode===o.R.Points)return{result:!1};let c=0,_=0,u=0,d=0;if(this.hasIndices()){const o=this.__oIndices.unwrapForce();for(let f=0;f<o.elementCount-2;f++){const m=f*l;if(m+2>o.elementCount-1)break;const p=o.getScalar(m,{}),v=o.getScalar(m+1,{}),x=o.getScalar(m+2,{}),g=this.__castRayInnerTomasMoller(e,t,f,p,v,x,n,a,i,r);h.Is.false(g)||h.Is.not.exist(g.data)||g.data.t<s&&(s=g.data.t,u=g.data.u,d=g.data.v,c=p,_=v,c=x)}}else{let o=0;for(const e of this.__attributes.values()){o=e.elementCount;break}for(let f=0;f<o;f+=l){const o=f,l=f+1,m=f+2,p=this.__castRayInnerTomasMoller(e,t,f,o,l,m,n,a,i,r);if(p.result&&h.Is.defined(p.data)){const e=p.data.t;e<s&&(s=e,u=p.data.u,d=p.data.v,c=o,_=l,c=m)}}}return s===Number.MAX_VALUE?{result:!1}:{result:!0,data:{t:s,u,v:d,position:f.Pq.fromCopy3(t.x*s+e.x,t.y*s+e.y,t.z*s+e.z)}}}__castRayInnerTomasMoller(e,t,n,o,i,r,s,l,c,_){if(_){const e=this.__attributes.get(a.r.Normal.XYZ);if(e){const o=e.getVec3(n,{});if(o.dot(t)<c&&!s)return{result:!1};if(o.dot(t)>-c&&!l)return{result:!1}}}const u=this.__attributes.get(a.r.Position.XYZ),h=u.getVec3(o,{}),m=u.getVec3(i,{}),p=u.getVec3(r,{}),v=d.tp.zero(),x=d.tp.zero(),g=d.tp.zero(),y=d.tp.zero(),b=d.tp.zero();let I=0,A=0;d.tp.subtractTo(m,h,v),d.tp.subtractTo(p,h,x),d.tp.crossTo(t,x,g);const E=f.Pq.dot(v,g);if(E>1e-4){if(d.tp.subtractTo(e,h,y),I=f.Pq.dot(y,g),I<0||I>E)return{result:!1};if(d.tp.crossTo(y,v,b),A=f.Pq.dot(t,b),A<0||I+A>E)return{result:!1}}else{if(!(E<-1e-4))return{result:!1};if(d.tp.subtractTo(e,h,y),I=f.Pq.dot(y,g),I>0||I<E)return{result:!1};if(d.tp.crossTo(y,v,b),A=f.Pq.dot(t,b),A>0||I+A<E)return{result:!1}}const S=1/E;let T=f.Pq.dot(x,b);return T*=S,I*=S,A*=S,{result:!0,data:{t:T,u:I,v:A}}}__calcNormalFromUV(e,t,n,o,i){const r=1-o-i,s=this.__attributes.get(a.r.Position.XYZ),l=s.getVec3(e,{}),c=s.getVec3(t,{}),_=s.getVec3(n,{}),u=f.Pq.multiply(l,r),h=f.Pq.multiply(c,o),m=f.Pq.multiply(_,i);return d.tp.zero().add(u).add(h).add(m)}}b.__primitiveCount=0,b.__primitives=[],b.__primitiveUidIdxHasMorph=new Map,b.__idxPrimitiveUidHasMorph=new Map,b.__primitiveCountHasMorph=0,b.__tmpVec3_0=d.tp.zero(),b.__variantUpdateCount=0},6731:(e,t,n)=>{n.d(t,{I:()=>l});var o=n(6947),a=n(3639),i=n(975),r=n(2229),s=n(4838);class l extends s.d{generate(e){var t;const n={widthVector:null!==(t=e.widthVector)&&void 0!==t?t:i.Pq.fromCopy3(1,1,1),color:e.color,material:e.material},s=[-n.widthVector.x/2,n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,-n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,-n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,-n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,-n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,-n.widthVector.y/2,n.widthVector.z/2,n.widthVector.x/2,-n.widthVector.y/2,n.widthVector.z/2,n.widthVector.x/2,n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,-n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,-n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,n.widthVector.y/2,-n.widthVector.z/2,-n.widthVector.x/2,n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,-n.widthVector.y/2,-n.widthVector.z/2,n.widthVector.x/2,-n.widthVector.y/2,n.widthVector.z/2,n.widthVector.x/2,n.widthVector.y/2,n.widthVector.z/2,n.widthVector.x/2,n.widthVector.y/2,-n.widthVector.z/2,-n.widthVector.x/2,-n.widthVector.y/2,-n.widthVector.z/2,-n.widthVector.x/2,-n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,n.widthVector.y/2,n.widthVector.z/2,-n.widthVector.x/2,n.widthVector.y/2,-n.widthVector.z/2],l=r.Is.not.exist(n.color)?[]:[n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a,n.color.r,n.color.g,n.color.b,n.color.a],c=[a.r.Position.XYZ,a.r.Normal.XYZ,a.r.Texcoord0.XY],_=[new Float32Array(s),new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),new Float32Array([0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1])];r.Is.exist(n.color)&&(c.push(a.r.Color0.XYZ),_.push(new Float32Array(l)));const u=o.R.Triangles;this.copyVertexData({attributes:_,attributeSemantics:c,primitiveMode:u,indices:new Uint16Array([3,1,0,2,1,3,4,5,7,7,5,6,8,9,11,11,9,10,15,13,12,14,13,15,19,17,16,18,17,19,20,21,23,23,21,22]),material:n.material})}}},4838:(e,t,n)=>{n.d(t,{d:()=>a});var o=n(960);class a extends o.s{}},1326:(e,t,n)=>{n.d(t,{Z:()=>r});var o=n(3639),a=n(6947),i=n(4838);class r extends i.d{generate(e){var t,n,i,r,s,l;const c={width:null!==(t=e.width)&&void 0!==t?t:1,height:null!==(n=e.height)&&void 0!==n?n:1,uSpan:null!==(i=e.uSpan)&&void 0!==i?i:1,vSpan:null!==(r=e.vSpan)&&void 0!==r?r:1,isUVRepeat:null!==(s=e.isUVRepeat)&&void 0!==s&&s,flipTextureCoordinateY:null!==(l=e.flipTextureCoordinateY)&&void 0!==l&&l,material:e.material},_=[];for(let e=0;e<=c.vSpan;e++)for(let t=0;t<=c.uSpan;t++)_.push((t/c.uSpan-.5)*c.width),_.push(0),_.push((e/c.vSpan-.5)*c.height);const u=[];for(let e=0;e<c.vSpan;e++){let t=0,n=0;for(let o=0;o<=c.uSpan;o++)u.push(e*(c.uSpan+1)+o),u.push((e+1)*(c.uSpan+1)+o),0===o?t=(e+1)*(c.uSpan+1)+o:o===c.uSpan&&(n=(e+1)*(c.uSpan+1)+o);u.push(n),u.push(t)}const f=[];for(let e=0;e<=c.vSpan;e++)for(let e=0;e<=c.uSpan;e++)f.push(0),f.push(1),f.push(0);const d=[];for(let e=0;e<=c.vSpan;e++){const t=c.flipTextureCoordinateY?e:c.vSpan-e;for(let e=0;e<=c.uSpan;e++)c.isUVRepeat?(d.push(e),d.push(t)):(d.push(e/c.uSpan),d.push(t/c.vSpan))}const h=[o.r.Position.XYZ,o.r.Normal.XYZ,o.r.Texcoord0.XY],m=a.R.TriangleStrip,p=[new Float32Array(_),new Float32Array(f),new Float32Array(d)];this.copyVertexData({attributes:p,attributeSemantics:h,primitiveMode:m,indices:new Uint16Array(u),material:null==c?void 0:c.material})}}},6054:(e,t,n)=>{n.d(t,{$y:()=>i,AE:()=>s,SQ:()=>f,VG:()=>h,a8:()=>r,eG:()=>m,hN:()=>_,l$:()=>a,mP:()=>l,nm:()=>o,pc:()=>d,qp:()=>p,sY:()=>c});const o=2,a=10,i=3,r=0,s=i,l=i+a,c=i+a+o,_=32;function u(e,t,n){let o=(1<<n)-1;return e._sortkey>>t&o}function f(e){const t=u(e,l,o);return 2===t||3===t}function d(e){return 2===u(e,l,o)}function h(e){return 3===u(e,l,o)}function m(e){return 1===u(e,l,o)}function p(e){return 0===u(e,l,o)}},3498:(e,t,n)=>{n.d(t,{T:()=>u});var o=n(2384),a=n(6947),i=n(3639),r=n(960),s=n(975),l=n(2212),c=n(2229),_=n(2216);class u extends o.F{constructor(e){super(e)}get isSetup(){return null!=this.__topEntity}_setup(){if(this.__toSkipSetup())return;this.__topEntity=(0,_.j)(),this.__topEntity.tryToSetUniqueName(`AABBGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());const e=this.__topEntity.tryToGetMesh();u.__mesh=new l.e,u.__mesh.addPrimitive(u.generatePrimitive()),e.setMesh(u.__mesh),this.setGizmoTag(),this._update()}static generatePrimitive(){const e=new Uint32Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,3,3,7,7,4,4,0,1,2,2,6,6,5,5,1,0,1,1,5,5,4,4,0,3,2,2,6,6,7,7,3]),t=new Float32Array([-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1]);return r.s.createPrimitive({indices:e,attributeSemantics:[i.r.Position.XYZ],attributes:[t],primitiveMode:a.R.Lines})}_update(){if(null==this.__topEntity)return;const e=this.__target.getSceneGraph().worldMergedAABBWithSkeletal;this.__topEntity.getTransform().localPosition=e.centerPoint,this.__topEntity.getTransform().localScale=s.Pq.fromCopyArray([e.sizeX/2,e.sizeY/2,e.sizeZ/2])}_destroy(){c.Is.exist(this.__topEntity)&&this.__topEntity._destroy()}}},2384:(e,t,n)=>{n.d(t,{F:()=>i});var o=n(8819),a=n(1614);class i extends o.E{constructor(e){super(),this.__isVisible=!1,this.__target=e,this.setGizmoTag()}set isVisible(e){this.__setVisible(e)}get isVisible(){return this.__isVisible}__setVisible(e){this.__isVisible=e,this.__topEntity&&this.__topEntity.getSceneGraph().setVisibilityRecursively(e)}__toSkipSetup(){return!!this.isSetup||!!this.__target.matchTag("Being","gizmo")}setGizmoTag(){if(this.__topEntity){this.__topEntity.tryToSetTag({tag:"Being",value:"gizmo"}),this.__topEntity.tryToSetTag({tag:"Gizmo",value:"top"});const e=(0,a.g)(this.__topEntity.getSceneGraph(),!1);for(const t of e)t.entity.tryToSetTag({tag:"Being",value:"gizmo"});this.__topEntity.tryToSetTag({tag:"type",value:"background-assets"})}}}},626:(e,t,n)=>{n.d(t,{h:()=>u});var o=n(2216),a=n(6947),i=n(3639),r=n(2212),s=n(960),l=n(975),c=n(2229),_=n(2384);class u extends _.F{constructor(e){super(e)}get isSetup(){return null!=this.__topEntity}_setup(){if(this.__toSkipSetup())return;this.__topEntity=(0,o.j)(),this.__topEntity.tryToSetUniqueName(`LightGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());const e=this.__topEntity.tryToGetMesh();u.__mesh=new r.e,u.__mesh.addPrimitive(u.__generatePrimitive()),e.setMesh(u.__mesh),this.setGizmoTag()}_update(){if(null==this.__topEntity)return;const e=this.__target.getSceneGraph(),t=e.worldMergedAABBWithSkeletal;t.isVanilla()?this.__topEntity.getTransform().localPosition=e.position:this.__topEntity.getTransform().localPosition=t.centerPoint,this.__topEntity.getTransform().localRotation=e.rotation,this.__topEntity.getTransform().localScale=l.Pq.fromCopyArray([Math.max(1,t.isVanilla()?1:t.sizeX/2),Math.max(1,t.isVanilla()?1:t.sizeY/2),Math.max(1,t.isVanilla()?1:t.sizeZ/2)])}_destroy(){c.Is.exist(this.__topEntity)&&this.__topEntity._destroy()}static __generatePrimitive(){const e=new Float32Array([0,0,0,0,0,-this.__length,0,0,-this.__length,-.1,0,.2-this.__length,-.1,0,.2-this.__length,0,0,.2-this.__length]);return s.s.createPrimitive({attributeSemantics:[i.r.Position.XYZ],attributes:[e],primitiveMode:a.R.Lines})}}u.__length=1},1392:(e,t,n)=>{n.d(t,{r:()=>u});var o=n(2216),a=n(6947),i=n(3639),r=n(2212),s=n(960),l=n(975),c=n(2229),_=n(2384);class u extends _.F{constructor(e){super(e)}get isSetup(){return null!=this.__topEntity}set length(e){u.__length=e}get length(){return u.__length}_setup(){if(this.__toSkipSetup())return;this.__topEntity=(0,o.j)(),this.__topEntity.tryToSetUniqueName(`LocatorGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());const e=this.__topEntity.tryToGetMesh();u.__mesh=new r.e,u.__mesh.addPrimitive(u.__generatePrimitive()),e.setMesh(u.__mesh),this.setGizmoTag()}_update(){if(null==this.__topEntity)return;const e=this.__target.getSceneGraph(),t=e.worldMergedAABBWithSkeletal;t.isVanilla()?this.__topEntity.getTransform().localPosition=e.position:this.__topEntity.getTransform().localPosition=t.centerPoint,this.__topEntity.getTransform().localScale=l.Pq.fromCopyArray([Math.max(1,t.isVanilla()?1:t.sizeX/2),Math.max(1,t.isVanilla()?1:t.sizeY/2),Math.max(1,t.isVanilla()?1:t.sizeZ/2)])}static __generatePrimitive(){const e=new Float32Array([0,0,0,this.__length,0,0,0,0,0,0,this.__length,0,0,0,0,0,0,this.__length]),t=new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1]);return s.s.createPrimitive({attributeSemantics:[i.r.Position.XYZ,i.r.Color0.XYZ],attributes:[e,t],primitiveMode:a.R.Lines})}_destroy(){c.Is.exist(this.__topEntity)&&this.__topEntity._destroy()}}u.__length=1},9588:(e,t,n)=>{n.d(t,{t:()=>C});var o=n(7295),a=n(2216),i=n(8806),r=n(6737),s=n(5338),l=n(6338),c=n(6947),_=n(3639),u=n(2212),f=n(960),d=n(6731),h=n(1326),m=n(9620),p=n(6941),v=n(8068),x=n(3870),g=n(2162),y=n(6603),b=n(975),I=n(3414),A=n(2229),E=n(3497),S=n(7681),T=n(4849),w=n(2384);class C extends w.F{constructor(e){super(e),this.__pickStatedPoint=b.Pq.zero(),this.__deltaPoint=b.Pq.one(),this.__targetScaleBackup=b.Pq.one(),this.__isPointerDown=!1,this.__onPointerDownFunc=this.__onPointerDown.bind(this),this.__onPointerMoveFunc=this.__onPointerMove.bind(this),this.__onPointerUpFunc=this.__onPointerUp.bind(this)}get isSetup(){return null!=this.__topEntity}set length(e){C.__length=e}get length(){return C.__length}set isVisible(e){if(!1===this.__isVisible&&!0===e){let e=window;if(A.Is.exist(s.T.eventTargetDom)&&(e=s.T.eventTargetDom),T.eN.register(T.B$,[{eventName:(0,T.Zc)("start"),handler:this.__onPointerDownFunc,options:{},classInstance:this,eventTargetDom:e},{eventName:(0,T.Zc)("move"),handler:this.__onPointerMoveFunc,options:{},classInstance:this,eventTargetDom:e},{eventName:(0,T.Zc)("end"),handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:e},{eventName:"pointerleave",handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:e}]),this.__topEntity.getSceneGraph().addChild(C.__groupEntity.getSceneGraph()),C.__latestTargetEntity=this.__target,"local"===C.__space){const e=this.__target.getSceneGraph();let t=y.P.identity();A.Is.exist(e)&&(t=e.getQuaternionRecursively()),C.__groupEntity.getTransform().localRotation=t}else"world"===C.__space&&(C.__groupEntity.getTransform().localRotation=y.P.fromCopy4(0,0,0,1))}!0===this.__isVisible&&!1===e&&(T.eN.unregister(T.B$),this.__deltaPoint=this.__target.getTransform().localScale,this.__pickStatedPoint=b.Pq.zero(),this.__isPointerDown=!1,this.__targetScaleBackup=this.__target.getTransform().localScale,C.__activeAxis="none"),T.eN.setActive(T.B$,e),this.__setVisible(e),C.__xyPlaneEntity.getSceneGraph().isVisible=!1,C.__yzPlaneEntity.getSceneGraph().isVisible=!1,C.__zxPlaneEntity.getSceneGraph().isVisible=!1}setSpace(e){C.__space=e,this.__isVisible&&(this.isVisible=!1,this.isVisible=!0)}get isVisible(){return this.__isVisible}_setup(){this.__toSkipSetup()||(this.__topEntity=(0,i.P)(),this.__topEntity.tryToSetUniqueName(`ScaleGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph()),A.Is.not.exist(C.__xCubeEntity)&&(this.xMesh(),this.xEdgeMesh()),A.Is.not.exist(C.__yCubeEntity)&&(this.yMesh(),this.yEdgeMesh()),A.Is.not.exist(C.__zCubeEntity)&&(this.zMesh(),this.zEdgeMesh()),A.Is.not.exist(C.__xyPlaneEntity)&&this.xyPlane(),A.Is.not.exist(C.__yzPlaneEntity)&&this.yzPlane(),A.Is.not.exist(C.__zxPlaneEntity)&&this.zxPlane(),A.Is.not.exist(C.__groupEntity)&&(C.__groupEntity=(0,i.P)()),this.__topEntity.getSceneGraph().addChild(C.__groupEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__xCubeEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__yCubeEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__zCubeEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__xyPlaneEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__yzPlaneEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__zxPlaneEntity.getSceneGraph()),C.__latestTargetEntity=this.__target,this.setGizmoTag())}zxPlane(){C.__zxPlaneEntity=(0,a.j)(),C.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_zxPlane",!0),C.__zxPlaneEntity.getSceneGraph().isVisible=!1,C.__zxPlaneMaterial=m.m.createClassicUberMaterial(),C.__zxPlaneMaterial.setParameter("diffuseColorFactor",I.IU.fromCopyArray4([0,.5,0,0])),C.__zxPlaneMaterial.alphaMode=l.K.Blend,C.__zxPlaneMesh=new u.e,C.__zxPlanePrimitive=new h.Z,C.__zxPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:C.__zxPlaneMaterial}),C.__zxPlaneMesh.addPrimitive(C.__zxPlanePrimitive),C.__zxPlaneEntity.getMesh().setMesh(C.__zxPlaneMesh)}yzPlane(){C.__yzPlaneEntity=(0,a.j)(),C.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_yzPlane",!0),C.__yzPlaneEntity.getSceneGraph().isVisible=!1,C.__yzPlaneEntity.getTransform().localEulerAngles=b.Pq.fromCopy3(0,0,p.z.degreeToRadian(90)),C.__yzPlaneMaterial=m.m.createClassicUberMaterial(),C.__yzPlaneMaterial.alphaMode=l.K.Blend,C.__yzPlaneMaterial.setParameter("diffuseColorFactor",I.IU.fromCopyArray4([.5,0,0,0])),C.__yzPlaneMesh=new u.e,C.__yzPlanePrimitive=new h.Z,C.__yzPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:C.__yzPlaneMaterial}),C.__yzPlaneMesh.addPrimitive(C.__yzPlanePrimitive),C.__yzPlaneEntity.getMesh().setMesh(C.__yzPlaneMesh)}xyPlane(){C.__xyPlaneEntity=(0,a.j)(),C.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_xyPlane",!0),C.__xyPlaneEntity.getSceneGraph().isVisible=!1,C.__xyPlaneEntity.getTransform().localEulerAngles=b.Pq.fromCopy3(p.z.degreeToRadian(90),0,0),C.__xyPlaneMaterial=m.m.createClassicUberMaterial(),C.__xyPlaneMaterial.alphaMode=l.K.Blend,C.__xyPlaneMaterial.setParameter("diffuseColorFactor",I.IU.fromCopyArray4([0,0,.5,0])),C.__xyPlaneMesh=new u.e,C.__xyPlanePrimitive=new h.Z,C.__xyPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:C.__xyPlaneMaterial}),C.__xyPlaneMesh.addPrimitive(C.__xyPlanePrimitive),C.__xyPlaneEntity.getMesh().setMesh(C.__xyPlaneMesh)}zMesh(){C.__zCubeEntity=(0,a.j)(),C.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_zCube",!0),C.__zCubeEntity.getTransform().localPosition=b.Pq.fromCopy3(0,0,1),C.__zCubeMesh=new u.e,C.__zCubeMaterial=m.m.createClassicUberMaterial(),C.__zCubeMaterial.setParameter("diffuseColorFactor",I.IU.fromCopyArray4([0,0,1,1])),C.__zCubePrimitive=new d.I,C.__zCubePrimitive.generate({widthVector:b.Pq.fromCopy3(.05,.05,1),material:C.__zCubeMaterial}),C.__zCubeMesh.addPrimitive(C.__zCubePrimitive),C.__zCubeEntity.getMesh().setMesh(C.__zCubeMesh)}yMesh(){C.__yCubeEntity=(0,a.j)(),C.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_yCube",!0),C.__yCubeEntity.getTransform().localPosition=b.Pq.fromCopy3(0,1,0),C.__yCubeMesh=new u.e,C.__yCubeMaterial=m.m.createClassicUberMaterial(),C.__yCubeMaterial.setParameter("diffuseColorFactor",I.IU.fromCopyArray4([0,1,0,1])),C.__yCubePrimitive=new d.I,C.__yCubePrimitive.generate({widthVector:b.Pq.fromCopy3(.05,1,.05),material:C.__yCubeMaterial}),C.__yCubeMesh.addPrimitive(C.__yCubePrimitive),C.__yCubeEntity.getMesh().setMesh(C.__yCubeMesh)}xMesh(){C.__xCubeEntity=(0,a.j)(),C.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_xCube",!0),C.__xCubeEntity.getTransform().localPosition=b.Pq.fromCopy3(1,0,0),C.__xCubeMesh=new u.e,C.__xCubeMaterial=m.m.createClassicUberMaterial(),C.__xCubeMaterial.setParameter("diffuseColorFactor",I.IU.fromCopyArray4([1,0,0,1])),C.__xCubePrimitive=new d.I,C.__xCubePrimitive.generate({widthVector:b.Pq.fromCopy3(1,.05,.05),material:C.__xCubeMaterial}),C.__xCubeMesh.addPrimitive(C.__xCubePrimitive),C.__xCubeEntity.getMesh().setMesh(C.__xCubeMesh)}xEdgeMesh(){C.__xEdgeCubeEntity=(0,a.j)(),C.__xEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_xEdgeCube",!0),C.__xEdgeCubeEntity.getTransform().localPosition=b.Pq.fromCopy3(1,0,0),C.__xEdgeCubeMesh=new u.e,C.__xEdgeCubePrimitive=new d.I,C.__xEdgeCubePrimitive.generate({widthVector:b.Pq.fromCopy3(.1,.1,.1),material:C.__xCubeMaterial}),C.__xEdgeCubeMesh.addPrimitive(C.__xEdgeCubePrimitive),C.__xEdgeCubeEntity.getMesh().setMesh(C.__xEdgeCubeMesh),C.__xCubeEntity.addChild(C.__xEdgeCubeEntity.getSceneGraph())}yEdgeMesh(){C.__yEdgeCubeEntity=(0,a.j)(),C.__yEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_yEdgeCube",!0),C.__yEdgeCubeEntity.getTransform().localPosition=b.Pq.fromCopy3(0,1,0),C.__yEdgeCubeMesh=new u.e,C.__yEdgeCubePrimitive=new d.I,C.__yEdgeCubePrimitive.generate({widthVector:b.Pq.fromCopy3(.1,.1,.1),material:C.__yCubeMaterial}),C.__yEdgeCubeMesh.addPrimitive(C.__yEdgeCubePrimitive),C.__yEdgeCubeEntity.getMesh().setMesh(C.__yEdgeCubeMesh),C.__yCubeEntity.addChild(C.__yEdgeCubeEntity.getSceneGraph())}zEdgeMesh(){C.__zEdgeCubeEntity=(0,a.j)(),C.__zEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_zEdgeCube",!0),C.__zEdgeCubeEntity.getTransform().localPosition=b.Pq.fromCopy3(0,0,1),C.__zEdgeCubeMesh=new u.e,C.__zEdgeCubePrimitive=new d.I,C.__zEdgeCubePrimitive.generate({widthVector:b.Pq.fromCopy3(.1,.1,.1),material:C.__zCubeMaterial}),C.__zEdgeCubeMesh.addPrimitive(C.__zEdgeCubePrimitive),C.__zEdgeCubeEntity.getMesh().setMesh(C.__zEdgeCubeMesh),C.__zCubeEntity.addChild(C.__zEdgeCubeEntity.getSceneGraph())}_update(){if(null==this.__topEntity)return;const e=this.__target.getSceneGraph(),t=e.worldMergedAABBWithSkeletal;t.isVanilla()?this.__topEntity.getTransform().localPosition=e.position:this.__topEntity.getTransform().localPosition=t.centerPoint;const n=Math.max(t.sizeX,t.sizeY,t.sizeZ);this.__topEntity.getTransform().localScale=b.Pq.fromCopyArray([Math.min(1,t.isVanilla()?1:n/2),Math.min(1,t.isVanilla()?1:n/2),Math.min(1,t.isVanilla()?1:n/2)]),this.__isPointerDown&&C.__latestTargetEntity===this.__target&&(this.__target.getTransform().localScale=this.__deltaPoint.clone())}static __generatePrimitive(){const e=new Float32Array([0,0,0,this.__length,0,0,0,0,0,0,this.__length,0,0,0,0,0,0,this.__length]),t=new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1]);return f.s.createPrimitive({attributeSemantics:[_.r.Position.XYZ,_.r.Color0.XYZ],attributes:[e,t],primitiveMode:c.R.Lines})}__onPointerDown(e){e.preventDefault(),this.__isPointerDown=!0,C.__originalX=e.clientX,C.__originalY=e.clientY;const t=this.__target.getSceneGraph().matrix.getRotate(),n=b.Pq.one();let o=v.k.fromCopy9RowMajor(n.x*t.m00,n.x*t.m01,n.x*t.m02,n.y*t.m10,n.y*t.m11,n.y*t.m12,n.z*t.m20,n.z*t.m21,n.z*t.m22);"local"===C.__space?o=v.k.transpose(o):"world"===C.__space&&(o=g._.identity());const{xResult:a,yResult:i,zResult:r}=C.castRay(e);a.result&&((0,S.qL)(a.data),this.__pickStatedPoint=o.multiplyVector(a.data.position.clone()),E.V.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),C.__activeAxis="x"),i.result&&((0,S.qL)(i.data),this.__pickStatedPoint=o.multiplyVector(i.data.position.clone()),E.V.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),C.__activeAxis="y"),r.result&&((0,S.qL)(r.data),this.__pickStatedPoint=o.multiplyVector(r.data.position.clone()),E.V.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),C.__activeAxis="z"),C.__latestTargetEntity===this.__target&&(this.__targetScaleBackup=this.__target.getTransform().localScale)}__onPointerMove(e){if(e.preventDefault(),A.Is.false(this.__isPointerDown))return;const t=e.target.getBoundingClientRect(),n=e.target.clientWidth,a=e.target.clientHeight,i=e.clientX-t.left,s=t.height-(e.clientY-t.top),l=I.IU.fromCopy4(0,0,n,a),c=r.O.getComponent(o.n,o.n.current),_=this.__target.getSceneGraph().matrix.getRotate(),u=b.Pq.one();let f=v.k.fromCopy9RowMajor(u.x*_.m00,u.x*_.m01,u.x*_.m02,u.y*_.m10,u.y*_.m11,u.y*_.m12,u.z*_.m20,u.z*_.m21,u.z*_.m22);"local"===C.__space?f=v.k.transpose(f):"world"===C.__space&&(f=g._.identity());let d=this.__pickStatedPoint.clone();if("x"===C.__activeAxis){const e=C.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(i,s,c,l,0);if(e.result){(0,S.qL)(e.data);const t=f.multiplyVector(e.data.position);d=b.Pq.fromCopy3(t.x,d.y,d.z),E.V.debug("Move:"+e.data.position.toStringApproximately())}T.eN.disableCameraController()}if("y"===C.__activeAxis){const e=C.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(i,s,c,l,0);if(e.result){(0,S.qL)(e.data);const t=f.multiplyVector(e.data.position);d=b.Pq.fromCopy3(d.x,t.y,d.z),E.V.debug("Move:"+e.data.position.toStringApproximately())}T.eN.disableCameraController()}if("z"===C.__activeAxis){const e=C.__yzPlaneEntity.getMesh().castRayFromScreenInWorld(i,s,c,l,0);if(e.result){(0,S.qL)(e.data);const t=f.multiplyVector(e.data.position);d=b.Pq.fromCopy3(d.x,d.y,t.z),E.V.debug("Move:"+e.data.position.toStringApproximately())}T.eN.disableCameraController()}const h=this.__target.getSceneGraph().worldMergedAABBWithSkeletal,m=b.Pq.multiply(b.Pq.subtract(d,this.__pickStatedPoint),1/h.lengthCenterToCorner);if(E.V.debug(`${this.__target.uniqueName}: `+m.toStringApproximately()),"local"===C.__space)this.__deltaPoint=b.Pq.add(this.__targetScaleBackup,m),this.__deltaPoint=b.Pq.fromCopy3(Math.max(this.__deltaPoint.x,.01),Math.max(this.__deltaPoint.y,.01),Math.max(this.__deltaPoint.z,.01));else if("world"===C.__space){const e=x._.fromCopyQuaternion(this.__target.getSceneGraph().getQuaternionRecursively()),t=x._.multiply(e,x._.scale(this.__targetScaleBackup)).getScale();let n=I.IU.add(m,t);n=I.IU.fromCopy4(Math.max(n.x,.01),Math.max(n.y,.01),Math.max(n.z,.01),Math.max(n.w,.01)),this.__deltaPoint=x._.multiply(x._.invert(e),x._.scale(n)).getScale(),this.__deltaPoint=b.Pq.fromCopy3(Math.max(this.__deltaPoint.x,.01),Math.max(this.__deltaPoint.y,.01),Math.max(this.__deltaPoint.z,.01))}}__onPointerUp(e){e.preventDefault(),this.__isPointerDown=!1,C.__activeAxis="none",T.eN.enableCameraController(),C.__latestTargetEntity===this.__target&&(this.__targetScaleBackup=this.__target.getTransform().localScale)}static castRay2(e){const t=e.target.getBoundingClientRect(),n=e.target.clientWidth,a=e.target.clientHeight,i=e.clientX-t.left,s=t.height-(e.clientY-t.top),l=I.IU.fromCopy4(0,0,n,a),c=r.O.getComponent(o.n,o.n.current);return C.__groupEntity.getSceneGraph().castRayFromScreen(i,s,c,l,0,[])}static castRay(e){const t=e.target.getBoundingClientRect(),n=e.target.clientWidth,a=e.target.clientHeight,i=e.clientX-t.left,s=t.height-(e.clientY-t.top),l=I.IU.fromCopy4(0,0,n,a),c=r.O.getComponent(o.n,o.n.current);return{xResult:C.__xCubeEntity.getSceneGraph().castRayFromScreen(i,s,c,l,0),yResult:C.__yCubeEntity.getSceneGraph().castRayFromScreen(i,s,c,l,0),zResult:C.__zCubeEntity.getSceneGraph().castRayFromScreen(i,s,c,l,0)}}_destroy(){A.Is.exist(this.__topEntity)&&this.__topEntity._destroy()}}C.__originalX=0,C.__originalY=0,C.__activeAxis="none",C.__space="world",C.__length=1},2335:(e,t,n)=>{n.d(t,{U:()=>C});var o=n(7295),a=n(6737),i=n(5338),r=n(6338),s=n(6947),l=n(3639),c=n(2212),_=n(960),u=n(6731),f=n(1326),d=n(9620),h=n(3870),m=n(6941),p=n(8068),v=n(2162),x=n(6603),g=n(975),y=n(3414),b=n(2229),I=n(7681),A=n(4849),E=n(2384),S=n(8806),T=n(2216),w=n(3497);class C extends E.F{constructor(e){super(e),this.__pickStatedPoint=g.Pq.zero(),this.__deltaPoint=g.Pq.zero(),this.__targetPointBackup=g.Pq.zero(),this.__isPointerDown=!1,this.__onPointerDownFunc=this.__onPointerDown.bind(this),this.__onPointerMoveFunc=this.__onPointerMove.bind(this),this.__onPointerUpFunc=this.__onPointerUp.bind(this)}get isSetup(){return null!=this.__topEntity}set length(e){C.__length=e}get length(){return C.__length}set isVisible(e){if(!1===this.__isVisible&&!0===e){let e=window;if(b.Is.exist(i.T.eventTargetDom)&&(e=i.T.eventTargetDom),A.eN.register(A.cK,[{eventName:(0,A.Zc)("start"),handler:this.__onPointerDownFunc,options:{},classInstance:this,eventTargetDom:e},{eventName:(0,A.Zc)("move"),handler:this.__onPointerMoveFunc,options:{},classInstance:this,eventTargetDom:e},{eventName:(0,A.Zc)("end"),handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:e},{eventName:"pointerleave",handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:e}]),this.__topEntity.getSceneGraph().addChild(C.__groupEntity.getSceneGraph()),this.__latestTargetEntity=this.__target,"local"===C.__space){const e=this.__target.getSceneGraph().parent;let t=x.P.identity();b.Is.exist(e)&&(t=e.getQuaternionRecursively()),C.__groupEntity.getTransform().localRotation=t}else"world"===C.__space&&(C.__groupEntity.getTransform().localRotation=x.P.fromCopy4(0,0,0,1))}!0===this.__isVisible&&!1===e&&(A.eN.unregister(A.cK),this.__deltaPoint=this.__target.getTransform().localPosition,this.__pickStatedPoint=g.Pq.zero(),this.__isPointerDown=!1,this.__targetPointBackup=this.__target.getTransform().localPosition,C.__activeAxis="none"),A.eN.setActive(A.cK,e),this.__setVisible(e),C.__xyPlaneEntity.getSceneGraph().isVisible=!1,C.__yzPlaneEntity.getSceneGraph().isVisible=!1,C.__zxPlaneEntity.getSceneGraph().isVisible=!1}setSpace(e){C.__space=e,this.__isVisible&&(this.isVisible=!1,this.isVisible=!0)}get isVisible(){return this.__isVisible}_setup(){this.__toSkipSetup()||(this.__topEntity=(0,S.P)(),this.__topEntity.tryToSetUniqueName(`TranslationGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph()),b.Is.not.exist(C.__xCubeEntity)&&(C.__xCubeEntity=(0,T.j)(),C.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_xCube",!0),C.__xCubeEntity.getTransform().localPosition=g.Pq.fromCopy3(1,0,0),C.__xCubeMesh=new c.e,C.__xCubeMaterial=d.m.createClassicUberMaterial(),C.__xCubeMaterial.setParameter("diffuseColorFactor",y.IU.fromCopyArray4([1,0,0,1])),C.__xCubePrimitive=new u.I,C.__xCubePrimitive.generate({widthVector:g.Pq.fromCopy3(1,.05,.05),material:C.__xCubeMaterial}),C.__xCubeMesh.addPrimitive(C.__xCubePrimitive),C.__xCubeEntity.getMesh().setMesh(C.__xCubeMesh)),b.Is.not.exist(C.__yCubeEntity)&&(C.__yCubeEntity=(0,T.j)(),C.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_yCube",!0),C.__yCubeEntity.getTransform().localPosition=g.Pq.fromCopy3(0,1,0),C.__yCubeMesh=new c.e,C.__yCubeMaterial=d.m.createClassicUberMaterial(),C.__yCubeMaterial.setParameter("diffuseColorFactor",y.IU.fromCopyArray4([0,1,0,1])),C.__yCubePrimitive=new u.I,C.__yCubePrimitive.generate({widthVector:g.Pq.fromCopy3(.05,1,.05),material:C.__yCubeMaterial}),C.__yCubeMesh.addPrimitive(C.__yCubePrimitive),C.__yCubeEntity.getMesh().setMesh(C.__yCubeMesh)),b.Is.not.exist(C.__zCubeEntity)&&(C.__zCubeEntity=(0,T.j)(),C.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_zCube",!0),C.__zCubeEntity.getTransform().localPosition=g.Pq.fromCopy3(0,0,1),C.__zCubeMesh=new c.e,C.__zCubeMaterial=d.m.createClassicUberMaterial(),C.__zCubeMaterial.setParameter("diffuseColorFactor",y.IU.fromCopyArray4([0,0,1,1])),C.__zCubePrimitive=new u.I,C.__zCubePrimitive.generate({widthVector:g.Pq.fromCopy3(.05,.05,1),material:C.__zCubeMaterial}),C.__zCubeMesh.addPrimitive(C.__zCubePrimitive),C.__zCubeEntity.getMesh().setMesh(C.__zCubeMesh)),b.Is.not.exist(C.__xyPlaneEntity)&&(C.__xyPlaneEntity=(0,T.j)(),C.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_xyPlane",!0),C.__xyPlaneEntity.getSceneGraph().isVisible=!1,C.__xyPlaneEntity.getTransform().localEulerAngles=g.Pq.fromCopy3(m.z.degreeToRadian(90),0,0),C.__xyPlaneMaterial=d.m.createClassicUberMaterial(),C.__xyPlaneMaterial.alphaMode=r.K.Blend,C.__xyPlaneMaterial.setParameter("diffuseColorFactor",y.IU.fromCopyArray4([0,0,.5,0])),C.__xyPlaneMesh=new c.e,C.__xyPlanePrimitive=new f.Z,C.__xyPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:C.__xyPlaneMaterial}),C.__xyPlaneMesh.addPrimitive(C.__xyPlanePrimitive),C.__xyPlaneEntity.getMesh().setMesh(C.__xyPlaneMesh)),b.Is.not.exist(C.__yzPlaneEntity)&&(C.__yzPlaneEntity=(0,T.j)(),C.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_yzPlane",!0),C.__yzPlaneEntity.getSceneGraph().isVisible=!1,C.__yzPlaneEntity.getTransform().localEulerAngles=g.Pq.fromCopy3(0,0,m.z.degreeToRadian(90)),C.__yzPlaneMaterial=d.m.createClassicUberMaterial(),C.__yzPlaneMaterial.alphaMode=r.K.Blend,C.__yzPlaneMaterial.setParameter("diffuseColorFactor",y.IU.fromCopyArray4([.5,0,0,0])),C.__yzPlaneMesh=new c.e,C.__yzPlanePrimitive=new f.Z,C.__yzPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:C.__yzPlaneMaterial}),C.__yzPlaneMesh.addPrimitive(C.__yzPlanePrimitive),C.__yzPlaneEntity.getMesh().setMesh(C.__yzPlaneMesh)),b.Is.not.exist(C.__zxPlaneEntity)&&(C.__zxPlaneEntity=(0,T.j)(),C.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_zxPlane",!0),C.__zxPlaneEntity.getSceneGraph().isVisible=!1,C.__zxPlaneMaterial=d.m.createClassicUberMaterial(),C.__zxPlaneMaterial.setParameter("diffuseColorFactor",y.IU.fromCopyArray4([0,.5,0,0])),C.__zxPlaneMaterial.alphaMode=r.K.Blend,C.__zxPlaneMesh=new c.e,C.__zxPlanePrimitive=new f.Z,C.__zxPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:C.__zxPlaneMaterial}),C.__zxPlaneMesh.addPrimitive(C.__zxPlanePrimitive),C.__zxPlaneEntity.getMesh().setMesh(C.__zxPlaneMesh)),b.Is.not.exist(C.__groupEntity)&&(C.__groupEntity=(0,S.P)()),this.__topEntity.getSceneGraph().addChild(C.__groupEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__xCubeEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__yCubeEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__zCubeEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__xyPlaneEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__yzPlaneEntity.getSceneGraph()),C.__groupEntity.getSceneGraph().addChild(C.__zxPlaneEntity.getSceneGraph()),this.__latestTargetEntity=this.__target,this.setGizmoTag())}_update(){if(null==this.__topEntity)return;const e=this.__target.getSceneGraph(),t=e.worldMergedAABBWithSkeletal;t.isVanilla()?this.__topEntity.getTransform().localPosition=e.position:this.__topEntity.getTransform().localPosition=t.centerPoint;const n=Math.max(t.sizeX,t.sizeY,t.sizeZ);this.__topEntity.getTransform().localScale=g.Pq.fromCopyArray([Math.min(1,t.isVanilla()?1:n/2),Math.min(1,t.isVanilla()?1:n/2),Math.min(1,t.isVanilla()?1:n/2)]),this.__isPointerDown&&this.__latestTargetEntity===this.__target&&(this.__target.getTransform().localPosition=this.__deltaPoint.clone())}static __generatePrimitive(){const e=new Float32Array([0,0,0,this.__length,0,0,0,0,0,0,this.__length,0,0,0,0,0,0,this.__length]),t=new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1]);return _.s.createPrimitive({attributeSemantics:[l.r.Position.XYZ,l.r.Color0.XYZ],attributes:[e,t],primitiveMode:s.R.Lines})}__onPointerDown(e){e.preventDefault(),this.__isPointerDown=!0,C.__originalX=e.clientX,C.__originalY=e.clientY;const t=this.__target.getSceneGraph().parent;let n=h._.identity();b.Is.exist(t)&&(n=t.matrixInner.getRotate());const o=g.Pq.one();let a=p.k.fromCopy9RowMajor(o.x*n.m00,o.x*n.m01,o.x*n.m02,o.y*n.m10,o.y*n.m11,o.y*n.m12,o.z*n.m20,o.z*n.m21,o.z*n.m22);"local"===C.__space?a=p.k.transpose(a):"world"===C.__space&&(a=v._.identity());const{xResult:i,yResult:r,zResult:s}=C.castRay(e);i.result&&((0,I.qL)(i.data),this.__pickStatedPoint=a.multiplyVector(i.data.position.clone()),w.V.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),C.__activeAxis="x"),r.result&&((0,I.qL)(r.data),this.__pickStatedPoint=a.multiplyVector(r.data.position.clone()),w.V.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),C.__activeAxis="y"),s.result&&((0,I.qL)(s.data),this.__pickStatedPoint=a.multiplyVector(s.data.position.clone()),w.V.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),C.__activeAxis="z"),this.__latestTargetEntity===this.__target&&(this.__targetPointBackup=this.__target.getTransform().localPosition)}__onPointerMove(e){if(e.preventDefault(),b.Is.false(this.__isPointerDown))return;const t=e.target.getBoundingClientRect(),n=e.target.clientWidth,i=e.target.clientHeight,r=e.clientX-t.left,s=t.height-(e.clientY-t.top),l=y.IU.fromCopy4(0,0,n,i),c=a.O.getComponent(o.n,o.n.current),_=this.__target.getSceneGraph().parent;let u=h._.identity();b.Is.exist(_)&&(u=_.matrixInner.getRotate());const f=g.Pq.one();let d=p.k.fromCopy9RowMajor(f.x*u.m00,f.x*u.m01,f.x*u.m02,f.y*u.m10,f.y*u.m11,f.y*u.m12,f.z*u.m20,f.z*u.m21,f.z*u.m22);"local"===C.__space?d=p.k.transpose(d):"world"===C.__space&&(d=v._.identity());let m=this.__pickStatedPoint.clone();if("x"===C.__activeAxis){const e=C.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(r,s,c,l,0);if(e.result){(0,I.qL)(e.data);const t=d.multiplyVector(e.data.position);m=g.Pq.fromCopy3(t.x,m.y,m.z)}A.eN.disableCameraController()}if("y"===C.__activeAxis){const e=C.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(r,s,c,l,0);if(e.result){(0,I.qL)(e.data);const t=d.multiplyVector(e.data.position);m=g.Pq.fromCopy3(m.x,t.y,m.z)}A.eN.disableCameraController()}if("z"===C.__activeAxis){const e=C.__yzPlaneEntity.getMesh().castRayFromScreenInWorld(r,s,c,l,0);if(e.result){(0,I.qL)(e.data);const t=d.multiplyVector(e.data.position);m=g.Pq.fromCopy3(m.x,m.y,t.z)}A.eN.disableCameraController()}const x=g.Pq.subtract(m,this.__pickStatedPoint);if(0!==x.length())if(w.V.debug(`${this.__target.uniqueName}: `+x.toStringApproximately()),"local"===C.__space)this.__deltaPoint=g.Pq.add(x,this.__targetPointBackup);else if("world"===C.__space){const e=this.__target.getSceneGraph().parent;let t=h._.identity();b.Is.exist(e)&&(t=e.matrix.getRotate());const n=g.Pq.one();let o=p.k.fromCopy9RowMajor(n.x*t.m00,n.x*t.m01,n.x*t.m02,n.y*t.m10,n.y*t.m11,n.y*t.m12,n.z*t.m20,n.z*t.m21,n.z*t.m22);o=p.k.transpose(o);const a=g.Pq.add(this.__targetPointBackup,o.multiplyVector(x));this.__deltaPoint=a}}__onPointerUp(e){e.preventDefault(),this.__isPointerDown=!1,C.__activeAxis="none",A.eN.enableCameraController(),this.__latestTargetEntity===this.__target&&(this.__targetPointBackup=this.__target.getTransform().localPosition)}static castRay2(e){const t=e.target.getBoundingClientRect(),n=e.target.clientWidth,i=e.target.clientHeight,r=e.clientX-t.left,s=t.height-(e.clientY-t.top),l=y.IU.fromCopy4(0,0,n,i),c=a.O.getComponent(o.n,o.n.current);return C.__groupEntity.getSceneGraph().castRayFromScreen(r,s,c,l,0,[])}static castRay(e){const t=e.target.getBoundingClientRect(),n=e.target.clientWidth,i=e.target.clientHeight,r=e.clientX-t.left,s=t.height-(e.clientY-t.top),l=y.IU.fromCopy4(0,0,n,i),c=a.O.getComponent(o.n,o.n.current);return{xResult:C.__xCubeEntity.getMesh().castRayFromScreenInWorld(r,s,c,l,0),yResult:C.__yCubeEntity.getMesh().castRayFromScreenInWorld(r,s,c,l,0),zResult:C.__zCubeEntity.getMesh().castRayFromScreenInWorld(r,s,c,l,0)}}_destroy(){b.Is.exist(this.__topEntity)&&this.__topEntity._destroy()}}C.__originalX=0,C.__originalY=0,C.__activeAxis="none",C.__space="world",C.__length=1},9620:(e,t,n)=>{n.d(t,{m:()=>be});var o=n(5338),a=n(4923),i=n(3549),r=n(790),s=n(9516),l=n(643),c=n(5368),_=n(4307),u=n(9920),f=n(2538),d=n(7776),h=n(9494),m=n(581),p=n(4114),v=n(7751),x=n(4132),g=n(1124);const y={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n#ifdef WEBGL2_MULTI_VIEW\n  layout(num_views=2) in;\n#endif\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\nout vec4 v_shadowCoord;\n\nuniform float u_pointSize; // initialValue=30\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\nuniform mat4 u_depthBiasPV; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n  v_shadowCoord = get_depthBiasPV(materialSID, 0) * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},b={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec3 v_baryCentricCoord;\nin vec4 v_shadowCoord;\n\nuniform int u_shadingModel; // initialValue=0\nuniform float u_alphaCutoff; // initialValue=0.01\nuniform float u_shininess; // initialValue=5\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)\nuniform sampler2D u_normalTexture; // initialValue=(1,blue)\nuniform vec4 u_diffuseColorTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_diffuseColorTextureRotation; // initialValue=0\nuniform sampler2DShadow u_depthTexture; // initialValue=(2,white)\n\n/* shaderity: @{renderTargetBegin} */\n\n// #pragma shaderity: require(../common/deliot2019SeamlessTexture.glsl)\n// uniform sampler2D u_tInvTexture; // initialValue=(1,white)\n// uniform vec3 u_colorSpaceOrigin;\n// uniform vec3 u_colorSpaceVector1;\n// uniform vec3 u_colorSpaceVector2;\n// uniform vec3 u_colorSpaceVector3;\n// uniform vec4 u_scaleTranslate;\n\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n\n\n  // diffuseColor (Considered to be premultiplied alpha)\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture (Considered to be premultiplied alpha)\n  vec4 diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);\n  float diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);\n  vec2 diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, v_texcoord_0);\n  vec4 textureColor = texture(u_diffuseColorTexture, diffuseColorTexUv);\n  diffuseColor *= textureColor.rgb;\n  alpha *= textureColor.a;\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (alpha < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n#ifdef RN_IS_LIGHTING\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      // Light\n      Light light = getLight(i, v_position_inWorld.xyz);\n\n      // Diffuse\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      float shininess = get_shininess(materialSID, 0);\n      int shadingModel = get_shadingModel(materialSID, 0);\n\n      vec3 viewPosition = get_viewPosition(cameraSID, 0);\n\n      // Specular\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n#else\n  shadingColor = diffuseColor;\n#endif\n\n  // Shadow\n#ifdef RN_USE_SHADOW_MAPPING\n  float visibility = 1.0;\n  float bias = 0.001;\n\n  // Non PCF\n  // if ( textureProj( u_depthTexture, v_shadowCoord ).r  < (v_shadowCoord.z - bias) / v_shadowCoord.w ) {\n  //   visibility = 0.5;\n  // }\n  // shadingColor *= visibility;\n\n  // Hardware PCF\n  vec4 shadowCoord = v_shadowCoord;\n  shadowCoord.z -= bias;\n  shadingColor *= textureProj( u_depthTexture, shadowCoord ) * 0.5 + 0.5;\n\n  // shadingColor.rgb = texture( u_depthTexture, v_shadowCoord.xy ).rrr;\n  // shadingColor.rgb = vec3(v_shadowCoord.xy, 0.0);\n  // shadingColor.rgb = vec3(diffuseColorTexUv, 0.0);\n  // shadingColor.rgb = vec3(texture( u_depthTexture, diffuseColorTexUv).rrr);\n  // shadingColor.rgb = texture( u_depthTexture, diffuseColorTexUv).rgb;\n  // shadingColor.rgb = vec3(textureProj( u_depthTexture, v_shadowCoord ).z, 0.0, 0.0);\n  alpha = 1.0;\n#endif\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  alpha = 1.0;\n#endif\n\n  rt0 = vec4(shadingColor * alpha, alpha);\n  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);\n  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},I={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\n// #param depthBiasPV: mat4x4<f32>; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n  let instanceId = u32(instance_ids.x);\n\n  let worldMatrix = get_worldMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  let normalMatrix = get_normalMatrix(instanceId);\n  // let isBillboard = get_isBillboard(instanceId);\n\n  let skeletalComponentSID = i32(instance_ids.y);\n  let blendShapeComponentSID = u32(instance_ids.z);\n\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\n  // Skeletal\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  output.position_inWorld = geom.position_inWorld.xyz;\n\n#ifdef RN_USE_COLOR_0\n  output.color_0 = vec4f(color_0);\n#else\n  output.color_0 = vec4f(1.0, 1.0, 1.0, 1.0);\n#endif\n\n  output.normal_inWorld = normalMatrix * normal;\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  output.texcoord_1 = texcoord_1;\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  output.texcoord_2 = texcoord_2;\n#endif\n\n  output.baryCentricCoord = baryCentricCoord.xyz;\n\n  let visibility = get_isVisible(instanceId);\n  if (!visibility)\n  {\n    output.position = vec4f(0.0, 0.0, 0.0, 1.0);\n  }\n\n#ifdef RN_USE_SHADOW_MAPPING\n  output.shadowCoord = get_depthBiasPV(materialSID, 0) * geom.position_inWorld;\n#endif\n\n  return output;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},A={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\nstruct Light {\n  lightType: i32, // 0 = directional, 1 = point, 2 = spot\n  position: vec3<f32>,\n  intensity: vec3<f32>,\n  attenuatedIntensity: vec3<f32>,\n  directionOfLightObject: vec3<f32>,\n  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)\n  pointToLight: vec3<f32>, // not normalized\n  spotAngleScale: f32,\n  spotAngleOffset: f32,\n  effectiveRange: f32,\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfn getRangeAttenuation(light: Light) -> f32\n{\n  let distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfn getSpotAttenuation(light: Light) -> f32\n{\n\n  let cd = dot(light.directionOfLightObject, light.direction);\n  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nfn getLightAttenuated(light: Light) -> Light {\n  var newLight: Light = light;\n  newLight.attenuatedIntensity = light.intensity;\n  // if (light.lightType == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.lightType == 1)\n  {\n    newLight.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.lightType == 2)\n  {\n    newLight.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n\n  return newLight;\n}\n\nfn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {\n  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);\n  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);\n  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);\n  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);\n  var light: Light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  let lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3f(0.0);\n    light.lightType = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.lightType = 1;\n  } else { // is Directional Light\n    light.lightType = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.lightType = 2;\n  }\n\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  let newLight = getLightAttenuated(light);\n\n  return newLight;\n}\n\n#ifdef RN_USE_TANGENT\n  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n    let tangent_inWorld = normalize(input.tangent_inWorld);\n    let binormal_inWorld = normalize(input.binormal_inWorld);\n    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {\n      var uv: vec2f;\n      if (isFront) {\n        uv = uv_;\n      } else {\n        uv = -uv_;\n      }\n\n      // get edge vectors of the pixel triangle\n      let dp1 = dpdx(position);\n      let dp2 = dpdy(position);\n      let duv1 = dpdx(uv);\n      let duv2 = dpdy(uv);\n\n      // solve the linear system\n      let dp2perp = cross(dp2, normal_inWorld);\n      let dp1perp = cross(normal_inWorld, dp1);\n      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nfn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {\n    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);\n}\n\nfn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {\n    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);\n}\n\n\n// The Schlick Approximation to Fresnel\nfn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnel2(f0: vec3f, VdotH: f32) -> vec3f\n{\n  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nfn fresnel2F32(f0: f32, VdotH: f32) -> f32\n{\n  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnelF32(f0, f90, VdotH);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nfn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nfn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f\n{\n  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n\n// GGX NDF\nfn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {\n  let roughnessSqr = alphaRoughness * alphaRoughness;\n  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {\n  let a2 = alphaRoughness * alphaRoughness;\n  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {\n  let D = d_GGX(NH, alphaRoughness);\n  let V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3f(D) * vec3f(V) * F * specularWeight;\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nfn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {\n  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );\n  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );\n  let r = Roughness * c0 + c1;\n  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nfn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n  let D = d_GGX(NdotHc, clearcoatAlpha);\n  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  let f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {\n  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  let D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nfn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;\n    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32\n{\n    let a2 = at * ab;\n    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);\n    let w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,\n    at: f32, ab: f32) -> f32\n{\n    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    let v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nfn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,\n    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,\n    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f\n{\n    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    let ab = alphaRoughness;\n\n    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let invAlpha  = 1.0 / alphaG;\n  let cos2h = NoH * NoH;\n  let sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn charlieL(x: f32, alphaG: f32) -> f32 {\n  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32\n{\n  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);\n}\n\nfn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nfn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {\n  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif // RN_USE_SHEEN\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst XYZ_TO_REC709 = mat3x3<f32>(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nfn fresnelSchlickRoughnessWithIridescence(\n  F0: vec3f, cosTheta: f32, roughness: f32,\n  iridescenceFresnel: vec3f, iridescence: f32\n  ) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nfn Fresnel0ToIor(F0: vec3f) -> vec3f {\n    let sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {\n    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {\n    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nfn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {\n    let phase = 2.0 * M_PI * OPD * 1.0e-9;\n    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    let rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nfn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));\n  let cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3f(1.0);\n  }\n\n  let cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);\n  let R12 = fresnel2F32(R0, cosTheta1);\n  let R21 = R12;\n  let T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);\n  let R23 = fresnel2(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  var phi12 = 0.0;\n  if (iridescenceIor < outsideIor) { phi12 = M_PI; }\n  let phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  var phi23 = vec3f(0.0);\n  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }\n  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }\n  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }\n\n  // OPD (optical path difference)\n  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  let phi = vec3f(phi21) + phi23;\n\n  // Compound terms\n  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));\n  let r123 = sqrt(R123);\n  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  let C0 = R12 + Rs;\n  var I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  var Cm = Rs - T121;\n  for (var m = 1; m <= 2; m++)\n  {\n      Cm *= r123;\n      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);\n      I += Cm * Sm;\n  }\n\n  let F_iridescence = max(I, vec3f(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nfn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f\n{\n    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n\n    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);\n\n    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nfn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f\n{\n    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    let D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nfn lightingWithPunctualLight(\n  light: Light,\n  normal_inWorld: vec3f,\n  viewDirection: vec3f,\n  NdotV: f32,\n  albedo: vec3f,\n  perceptualRoughness: f32,\n  F0: vec3f,\n  F90: vec3f,\n  transmission: f32,\n  ior: f32,\n  clearcoat: f32,\n  clearcoatRoughness: f32,\n  clearcoatNormal_inWorld: vec3f,\n  VdotNc: f32,\n  attenuationColor: vec3f,\n  attenuationDistance: f32,\n  anisotropy: f32,\n  anisotropicT: vec3f,\n  anisotropicB: vec3f,\n  BdotV: f32,\n  TdotV: f32,\n  sheenColor: vec3f,\n  sheenRoughness: f32,\n  albedoSheenScalingNdotV: f32,\n  iridescenceFactor: f32,\n  iridescenceFresnel: vec3f,\n  specularWeight: f32,\n  ) -> vec3f\n{\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  let halfVector = normalize(light.direction + viewDirection);\n  let VdotH = dot(viewDirection, halfVector);\n  let F = fresnel(F0, F90, VdotH);\n\n  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  var transmittedLightFromUnderSurface: Light = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);\n#else\n  let diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n\n#ifdef RN_USE_IRIDESCENCE\n  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  let TdotL = dot(anisotropicT, light.direction);\n  let BdotL = dot(anisotropicB, light.direction);\n  let TdotH = dot(anisotropicT, halfVector);\n  let BdotH = dot(anisotropicB, halfVector);\n  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;\n#else\n  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;\n#endif\n\n  // Base Layer\n  let baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  let albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);\n  let color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  let color = baseLayer;\n  let albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  let coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  let finalColor = coated;\n#else\n  let finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\nfn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {\n  let SIGMA2 = 0.15915494;\n  let KAPPA = 0.18;\n  let dndu  = dpdx(normal);\n  let dndv = dpdy(normal);\n  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n// #param shadingModel: u32; // initialValue=0\n// #param alphaCutoff: f32; // initialValue=0.01\n// #param shininess: f32; // initialValue=5\n// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n@group(1) @binding(0) var diffuseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var diffuseColorSampler: sampler;\n@group(1) @binding(1) var normalTexture: texture_2d<f32>; // initialValue=blue\n@group(2) @binding(1) var normalSampler: sampler;\n// #param diffuseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param diffuseColorTextureRotation: f32; // initialValue=0\n@group(1) @binding(2) var depthTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(2) var depthSampler: sampler;\n\n@fragment\nfn main (\n  input: VertexOutput,\n  @builtin(front_facing) isFront: bool,\n) -> @location(0) vec4<f32> {\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  // Normal\n  let normal_inWorld = normalize(input.normal_inWorld);\n\n  let diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n\n  // diffuseColor (Considered to be premultiplied alpha)\n  var diffuseColor = vec3f(1.0, 1.0, 1.0);\n  var alpha = 1.0;\n#ifdef RN_USE_COLOR_0\n  diffuseColor = input.color_0.rgb;\n  alpha = input.color_0.a;\n#endif\n  diffuseColor *= diffuseColorFactor.rgb;\n  alpha *= diffuseColorFactor.a;\n\n#ifdef RN_USE_TEXCOORD_0\n  // diffuseColorTexture (Considered to be premultiplied alpha)\n  let diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);\n  let diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);\n  let diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, input.texcoord_0);\n  let textureColor = textureSample(diffuseColorTexture, diffuseColorSampler, diffuseColorTexUv);\n  diffuseColor *= textureColor.rgb;\n  alpha *= textureColor.a;\n#endif\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  let alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (baseColor.a < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n  // Lighting\n  var shadingColor = vec3f(0.0, 0.0, 0.0);\n#ifdef RN_IS_LIGHTING\n  let shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n\n    var diffuse = vec3(0.0, 0.0, 0.0);\n    var specular = vec3(0.0, 0.0, 0.0);\n    let lightNumber = u32(get_lightNumber(0u, 0u));\n    for (var i = 0u; i < lightNumber ; i++) {\n\n      // Light\n      let light: Light = getLight(i, input.position_inWorld.xyz);\n\n      // Diffuse\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      let shininess = get_shininess(materialSID, 0);\n      let shadingModel = get_shadingModel(materialSID, 0);\n\n      let viewPosition = get_viewPosition(cameraSID, 0);\n\n      // Specular\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        let viewDirection = normalize(viewPosition - input.position_inWorld.xyz);\n        let halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        let viewDirection = normalize(viewPosition - input.position_inWorld.xyz);\n        let R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n#else\n  shadingColor = diffuseColor;\n#endif\n\n  // Shadow\n// #ifdef RN_USE_SHADOW_MAPPING\n//   float visibility = 1.0;\n//   float bias = 0.001;\n\n// //  Non PCF\n//   if ( textureProj( u_depthTexture, v_shadowCoord ).r  < (v_shadowCoord.z - bias) / v_shadowCoord.w ) {\n//     visibility = 0.5;\n//   }\n//   shadingColor *= visibility;\n\n//   // Hardware PCF\n//   // vec4 shadowCoord = v_shadowCoord;\n//   // shadowCoord.z -= bias;\n//   // shadingColor *= textureProj( u_depthTexture, shadowCoord ) * 0.5 + 0.5;\n\n//   alpha = 1.0;\n// #endif\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  alpha = 1.0;\n#endif\n\n  var finalColor = vec4f(shadingColor * alpha, alpha);\n  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);\n  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);\n\n  return finalColor;\n}\n",shaderStage:"fragment",isFragmentShader:!0},E={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n#ifdef WEBGL2_MULTI_VIEW\n  layout(num_views=2) in;\n#endif\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\nout vec2 v_texcoord_2;\nout vec3 v_baryCentricCoord;\nout float v_instanceInfo;\nout float v_displayIdx;\n#ifdef RN_USE_TANGENT\n  in vec4 a_tangent;\n  out vec3 v_tangent_inWorld;\n  out vec3 v_binormal_inWorld;\n#endif\n#ifdef RN_USE_SHADOW_MAPPING\n  out vec4 v_shadowCoord;\n#endif\n\nuniform float u_pointSize; // initialValue=30, soloDatum=true\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0.0, 0.1, 0.01), soloDatum=true\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\nuniform mat4 u_depthBiasPV; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_texcoord_0 = a_texcoord_0;\n  v_texcoord_1 = a_texcoord_1;\n  v_texcoord_2 = a_texcoord_2;\n\n  #ifdef RN_USE_TANGENT\n    v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n    v_binormal_inWorld = cross(v_tangent_inWorld, v_normal_inWorld) * a_tangent.w;\n  #endif\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  v_instanceInfo = a_instanceInfo.x;\n\n#ifdef WEBGL2_MULTI_VIEW\n  v_displayIdx = float(gl_ViewID_OVR);\n#endif\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n#ifdef RN_USE_SHADOW_MAPPING\n  v_shadowCoord = get_depthBiasPV(materialSID, 0) * v_position_inWorld;\n#endif\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},S={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec2 v_texcoord_1;\nin vec2 v_texcoord_2;\nin vec3 v_baryCentricCoord;\nin float v_instanceInfo;\nin float v_displayIdx;\n\n#ifdef RN_USE_TANGENT\n  in vec3 v_tangent_inWorld;\n  in vec3 v_binormal_inWorld;\n#endif\n\n#ifdef RN_USE_SHADOW_MAPPING\nin vec4 v_shadowCoord;\n#endif\n\nuniform vec4 u_baseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform vec2 u_metallicRoughnessFactor; // initialValue=(1,1)\nuniform sampler2D u_metallicRoughnessTexture; // initialValue=(1,white)\nuniform sampler2D u_occlusionTexture; // initialValue=(3,white)\nuniform vec3 u_emissiveFactor; // initialValue=(0,0,0)\nuniform sampler2D u_emissiveTexture; // initialValue=(4,white)\nuniform float u_emissiveStrength; // initialValue=1\nuniform vec3 u_wireframe; // initialValue=(0,0,1)\nuniform bool u_isOutputHDR; // initialValue=0\nuniform bool u_makeOutputSrgb; // initialValue=1\nuniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true\nuniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true\nuniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true\nuniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true\nuniform vec4 u_baseColorTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_baseColorTextureRotation; // initialValue=0\nuniform vec4 u_metallicRoughnessTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_metallicRoughnessTextureRotation; // initialValue=0\nuniform int u_baseColorTexcoordIndex; // initialValue=0\nuniform int u_metallicRoughnessTexcoordIndex; // initialValue=0\nuniform int u_occlusionTexcoordIndex; // initialValue=0\nuniform vec4 u_occlusionTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_occlusionTextureRotation; // initialValue=0\nuniform int u_emissiveTexcoordIndex; // initialValue=0\nuniform vec4 u_emissiveTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_emissiveTextureRotation; // initialValue=0\nuniform float u_occlusionStrength; // initialValue=1\nuniform bool u_inverseEnvironment; // initialValue=false\nuniform float u_ior; // initialValue=1.5\n\n#ifdef RN_USE_NORMAL_TEXTURE\n  uniform sampler2D u_normalTexture; // initialValue=(2,black)\n  uniform vec4 u_normalTextureTransform; // initialValue=(1,1,0,0)\n  uniform float u_normalTextureRotation; // initialValue=(0)\n  uniform int u_normalTexcoordIndex; // initialValue=(0)\n  uniform float u_normalScale; // initialValue=(1)\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  uniform float u_clearCoatFactor; // initialValue=0\n  uniform float u_clearCoatRoughnessFactor; // initialValue=0\n  uniform vec4 u_clearCoatTextureTransform; // initialValue=(1,1,0,0)\n  uniform float u_clearCoatTextureRotation; // initialValue=0\n  uniform vec4 u_clearCoatRoughnessTextureTransform; // initialValue=(1,1,0,0)\n  uniform float u_clearCoatRoughnessTextureRotation; // initialValue=0\n  uniform vec4 u_clearCoatNormalTextureTransform; // initialValue=(1,1,0,0)\n  uniform float u_clearCoatNormalTextureRotation; // initialValue=0\n  uniform int u_clearCoatTexcoordIndex; // initialValue=(0)\n  uniform int u_clearCoatRoughnessTexcoordIndex; // initialValue=(0)\n  uniform int u_clearCoatNormalTexcoordIndex; // initialValue=(0)\n#endif\n\n#ifdef RN_USE_TRANSMISSION\n  uniform float u_transmissionFactor; // initialValue=(0)\n#endif\n\n#ifdef RN_USE_VOLUME\n  uniform float u_thicknessFactor; // initialValue=(0)\n  uniform float u_attenuationDistance; // initialValue=(0.000001)\n  uniform vec3 u_attenuationColor; // initialValue=(1,1,1)\n#endif\n\n#ifdef RN_USE_SHEEN\n  uniform vec3 u_sheenColorFactor; // initialValue=(0,0,0)\n  uniform float u_sheenRoughnessFactor; // initialValue=(0)\n#endif\n\n#ifdef RN_USE_SPECULAR\n  uniform float u_specularFactor; // initialValue=1.0\n  uniform vec3 u_specularColorFactor; // initialValue=(1,1,1)\n#endif\n\n#ifdef RN_USE_IRIDESCENCE\n  uniform float u_iridescenceFactor; // initialValue=0\n  uniform float u_iridescenceIor; // initialValue=1.3\n  uniform float u_iridescenceThicknessMinimum; // initialValue=100\n  uniform float u_iridescenceThicknessMaximum; // initialValue=400\n#endif\n\n#ifdef RN_USE_ANISOTROPY\n  uniform float u_anisotropyStrength; // initialValue=0\n  uniform vec2 u_anisotropyRotation; // initialValue=(1,0)\n#endif\n\nuniform float u_alphaCutoff; // initialValue=(0.01)\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nfloat angular_n_h(float NH) {\n  return acos(NH);\n}\n\nfloat d_phong(float NH, float c1) {\n  return pow(\n    cos(acos(NH))\n    , c1\n  );\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 envBRDFApprox( float Roughness, float NoV ) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n// GGX NDF\nfloat d_GGX(float NH, float alphaRoughness) {\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\nfloat d_torrance_reiz(float NH, float c3) {\n  float CosSquared = NH*NH;\n  float TanSquared = (1.0 - CosSquared)/CosSquared;\n  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX\n  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry\n}\n\nfloat d_beckmann(float NH, float m) {\n  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);\n  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));\n  return co * expx;\n}\n\n// the same as glTF WebGL sample\n// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188\n// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),\n// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)\n// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\nfloat g_shielding(float NL, float NV, float alphaRoughness) {\n  float r = alphaRoughness;\n\n  // Local Shadowing using \"Schlick-Smith\" Masking Function\n  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\n\n  // Local Masking using \"Schlick-Smith\" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localShadowing * localMasking;\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfloat v_GGXCorrelated(float NL, float NV, float alphaRoughness) {\n  float a2 = alphaRoughness * alphaRoughness;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfloat v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {\n  float a = alphaRoughness;\n  float GGXV = NL * (NV * (1.0 - a) + a);\n  float GGXL = NV * (NL * (1.0 - a) + a);\n  return 0.5 / (GGXV + GGXL);\n}\n\n// The Schlick Approximation to Fresnel\nfloat fresnel(float f0, float f90, float VdotH) {\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nvec3 fresnel(vec3 f0, vec3 f90, float VdotH) {\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nvec3 fresnel(vec3 f0, float f90, float VdotH)\n{\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nfloat fresnel(float f0, float VdotH)\n{\n  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\nvec3 fresnel(vec3 f0, float VdotH)\n{\n  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nvec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness, float specularWeight) {\n  float D = d_GGX(NH, alphaRoughness);\n  float V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3(D) * vec3(V) * F * specularWeight;\n//      float G = g_shielding(NL, NV, alphaRoughness);\n//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);\n\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nvec3 BRDF_lambertian(vec3 albedo, vec3 F, float specularWeight)\n{\n  // (1/pi) * diffuseAlbedo\n  return (vec3(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf\nfloat specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {\n  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  float D = d_GGX(NdotH, alphaRoughness);\n  return V * D;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfloat specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {\n  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  float D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel\nvec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {\n  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel\nvec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {\n  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);\n  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);\n  return mix(base, layer, fr);\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf\nvec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n  return conductor_fresnel(\n    baseColor,\n    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),\n    alphaRoughness,\n    VdotH\n  );\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf\n// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {\n//   vec3 base = BRDF_lambertian(baseColor);\n//   float alphaRoughness = perceptualRoughness * perceptualRoughness;\n//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));\n//   return fresnel_mix(ior, base, layer, VdotH);\n// }\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nvec3 coated_material_s(vec3 base, float perceptualRoughness, float clearcoatRoughness, float clearcoat, float VdotNc, float LdotNc, float NdotHc) {\n  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  float clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n  float D = d_GGX(NdotHc, clearcoatAlpha);\n  float V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  float f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(f_clearcoat * clearcoat);\n}\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\nfloat srgbToLinear(float value) {\n  return pow(value, 2.2);\n}\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nfloat linearToSrgb(float value) {\n  return pow(value, 1.0/2.2);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nvec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)\n{\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nvec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfloat Schlick_to_F0(float f, float f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nvec3 Schlick_to_F0(vec3 f, float VdotH) {\n    return Schlick_to_F0(f, vec3(1.0), VdotH);\n}\n\nfloat Schlick_to_F0(float f, float VdotH) {\n    return Schlick_to_F0(f, 1.0, VdotH);\n}\n\nvec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {\n  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;\n  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;\n  vec3 r = normalize(vec3(t.xy + u.xy, t.z));\n  return r;\n}\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\nfloat IsotropicNDFFiltering(vec3 normal, float roughness2) {\n  float SIGMA2 = 0.15915494;\n  float KAPPA = 0.18;\n  vec3 dndu = dFdx(normal);\n  vec3 dndv = dFdy(normal);\n  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nvec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;\n    vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfloat D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)\n{\n    float a2 = at * ab;\n    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\n    float w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfloat V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,\n    float at, float ab)\n{\n    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    float v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 BRDF_specularAnisotropicGGX(vec3 F, float alphaRoughness,\n    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,\n    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)\n{\n    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    float ab = alphaRoughness;\n\n    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfloat d_Charlie(float sheenPerceptualRoughness, float NoH) {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  float invAlpha  = 1.0 / alphaG;\n  float cos2h = NoH * NoH;\n  float sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfloat sheenSimpleVisibility(float NdotL, float NdotV) {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfloat charlieL(float x, float alphaG) {\n  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfloat lambdaSheen(float cosTheta, float alphaG)\n{\n  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));\n}\n\nfloat sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {\n  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  float sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nvec3 sheen_brdf(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {\n  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst mat3 XYZ_TO_REC709 = mat3(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nvec3 fresnelSchlickRoughnessWithIridescence(\n  vec3 F0, float cosTheta, float roughness,\n  vec3 iridescenceFresnel, float iridescence\n  )\n{\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nvec3 Fresnel0ToIor(vec3 F0) {\n    vec3 sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nvec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\n    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfloat IorToFresnel0(float transmittedIor, float incidentIor) {\n    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nvec3 evalSensitivity(float OPD, vec3 shift) {\n    float phase = 2.0 * M_PI * OPD * 1.0e-9;\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    vec3 rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nvec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));\n  float cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3(1.0);\n  }\n\n  float cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  float R0 = IorToFresnel0(iridescenceIor, outsideIor);\n  float R12 = fresnel(R0, cosTheta1);\n  float R21 = R12;\n  float T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);\n  vec3 R23 = fresnel(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  float phi12 = 0.0;\n  if (iridescenceIor < outsideIor) phi12 = M_PI;\n  float phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  vec3 phi23 = vec3(0.0);\n  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;\n  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;\n  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;\n\n  // OPD (optical path difference)\n  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  vec3 phi = vec3(phi21) + phi23;\n\n  // Compound terms\n  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\n  vec3 r123 = sqrt(R123);\n  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  vec3 C0 = R12 + Rs;\n  vec3 I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  vec3 Cm = Rs - T121;\n  for (int m = 1; m <= 2; ++m)\n  {\n      Cm *= r123;\n      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\n      I += Cm * Sm;\n  }\n\n  vec3 F_iridescence = max(I, vec3(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)\n{\n    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);\n    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nvec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)\n{\n    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    float D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nvec3 lightingWithPunctualLight(\n  Light light,\n  vec3 normal_inWorld,\n  vec3 viewDirection,\n  float NdotV,\n  vec3 albedo,\n  float perceptualRoughness,\n  float metallic,\n  vec3 F0,\n  vec3 F90,\n  float ior,\n  float transmission,\n  float clearcoat,\n  float clearcoatRoughness,\n  vec3 clearcoatNormal_inWorld,\n  float VdotNc,\n  vec3 attenuationColor,\n  float attenuationDistance,\n  float anisotropy,\n  vec3 anisotropicT,\n  vec3 anisotropicB,\n  float BdotV,\n  float TdotV,\n  vec3 sheenColor,\n  float sheenRoughness,\n  float albedoSheenScalingNdotV,\n  float iridescenceFactor,\n  vec3 iridescenceFresnel,\n  float specularWeight\n  )\n{\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  vec3 halfVector = normalize(light.direction + viewDirection);\n  float VdotH = dot(viewDirection, halfVector);\n  vec3 F = fresnel(F0, F90, VdotH);\n\n  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  vec3 diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  vec3 diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n\n  vec3 pureDiffuse = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  vec3 refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  Light transmittedLightFromUnderSurface = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  vec3 transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  vec3 Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  float NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  float NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  vec3 transmittedContrib = (vec3(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  vec3 diffuseContrib = mix(pureDiffuse, vec3(transmittedContrib), transmission);\n#else\n  vec3 diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  float NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n#ifdef RN_USE_IRIDESCENCE\n  vec3 specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  float TdotL = dot(anisotropicT, light.direction);\n  float BdotL = dot(anisotropicB, light.direction);\n  float TdotH = dot(anisotropicT, halfVector);\n  float BdotH = dot(anisotropicB, halfVector);\n  vec3 specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;\n#else\n  vec3 specularContrib = cook_torrance_specular_brdf(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3(NdotL) * light.attenuatedIntensity;\n#endif // RN_USE_ANISOTROPY\n\n  // Base Layer\n  vec3 baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  vec3 sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  float albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);\n  vec3 color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  vec3 color = baseLayer;\n  float albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  float NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  float LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  vec3 coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  vec3 finalColor = coated;\n#else\n  vec3 finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\n\n/* shaderity: @{matricesGetters} */\n\n#ifdef RN_USE_SHADOW_MAPPING\n  uniform float u_pointLightFarPlane; // initialValue=1000.0\n#endif\n\n#ifdef RN_USE_SHADOW_MAPPING\n\nconst float g_minVariance = 0.00001;\n\nfloat chebyshevUpperBound(vec2 moments, float t) {\n  float p = (t <= moments.x) ? 1.0 : 0.0;\n\n  float variance = moments.y - sq(moments.x);\n  variance = max(variance, g_minVariance);\n\n  float d = t - moments.x;\n  float p_max = variance / (variance + sq(d));\n\n  return max(p, p_max);\n}\n\nfloat varianceShadowContribution(vec2 lightTexCoord, float distanceToLight) {\n  vec2 moments = texture(u_depthTexture, lightTexCoord).xy;\n\n  return chebyshevUpperBound(moments, distanceToLight);\n}\n\nfloat varianceShadowContributionParaboloid(vec3 worldPos, vec3 lightPos, float farPlane) {\n  vec3 L = worldPos - lightPos;\n  float currentDist = length(L);\n  vec3 Lnorm = normalize(L);\n\n  // Determine whether it is front or back simply by the sign of the z component\n  bool isFront = (Lnorm.z >= 0.0);\n\n  // Denominators for paraboloid projection\n  float denom = 1.0 + (isFront ? Lnorm.z : -Lnorm.z);\n\n  // Convert to UV coordinates (normalized)\n  // Lnorm.xy / denom is in [-1,1], so map it to [0,1]\n  vec2 uv = (Lnorm.xy / denom) * 0.5 + 0.5;\n\n  vec2 storedMoments = isFront\n      ? texture(u_paraboloidDepthTexture, uv).rg\n      : texture(u_paraboloidDepthTexture, uv).ba;\n\n  float currentDepth = currentDist / farPlane;\n\n\n  return chebyshevUpperBound(storedMoments, currentDepth);\n\n  // float shadow = (currentDepth > storedMoments.r + 0.00001) ? 0.5 : 1.0;\n  // return shadow;\n}\n\n\n#endif\n\n\nvec3 get_irradiance(vec3 normal_forEnv, float materialSID, ivec2 hdriFormat) {\n  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);\n\n  vec3 irradiance;\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    irradiance = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    irradiance = diffuseTexel.rgb;\n  }\n\n  return irradiance;\n}\n\nfloat scaleForLod(float perceptualRoughness, float ior)\n{\n  // Scale roughness to the range [0, 1],\n  // ior=1.0 will be scale 0,\n  // ior=1.5 will be scale 1.0,\n  // ior=2 will be scale 1.0 (clamped)\n  //\n\n  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n  return perceptualRoughness * scale;\n}\n\n#ifdef RN_USE_TRANSMISSION\nvec3 get_sample_from_backbuffer(float materialSID, vec2 sampleCoord, float perceptualRoughness, float ior) {\n  ivec2 vrState = get_vrState(0.0, 0);\n  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));\n  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);\n\n#ifdef WEBGL2_MULTI_VIEW\n  // For VR\n  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n  sampleCoord.x = sampleCoord.x * 0.5;\n  if (v_displayIdx == 1.0) { // For right eye\n    sampleCoord.x += 0.5;\n  }\n#else\n  if (vrState.x == 1) { // For VR\n    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n    sampleCoord.x = sampleCoord.x * 0.5;\n    if (vrState.y == 1) { // For right eye\n      sampleCoord.x += 0.5;\n    }\n  }\n#endif\n\n  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);\n\n  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n    vec3 transmittedLight = texture2DLodEXT(u_backBufferTexture, sampleCoord, framebufferLod).rgb;\n  #elif defined(GLSL_ES3)\n    vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;\n  #else\n    vec3 transmittedLight = texture(u_backBufferTexture, sampleCoord).rgb;\n  #endif\n\n  return transmittedLight;\n}\n#endif\n\nvec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {\n  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n    vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, reflection, lod);\n  #elif defined(GLSL_ES3)\n    vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);\n  #else\n    vec4 specularTexel = texture(u_specularEnvTexture, reflection);\n  #endif\n\n// #pragma shaderity: require(./../common/fetchCubeTexture.glsl)\n\n  vec3 radiance;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    radiance = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    radiance = specularTexel.rgb;\n  }\n\n  return radiance;\n}\n\n// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer\nvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)\n{\n  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);\n\n  vec3 modelScale;\n  modelScale.x = length(vec3(worldMatrix[0].xyz));\n  modelScale.y = length(vec3(worldMatrix[1].xyz));\n  modelScale.z = length(vec3(worldMatrix[2].xyz));\n\n  return normalize(refractionVector) * thickness * modelScale;\n}\n\nstruct IblResult\n{\n  vec3 specular;\n  vec3 diffuse;\n  vec3 FssEss;\n};\n\n#ifdef RN_USE_IRIDESCENCE\nIblResult getIBLRadianceGGXWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceFresnel, float iridescence, float specularWeight)\n{\n  // get radiance\n  float mipCount = iblParameter.x;\n  float lod = (perceptualRoughness * (mipCount - 1.0));\n  vec3 radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  vec3 specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  float IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nIblResult getIBLRadianceLambertianWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceF0, float iridescence, float specularWeight)\n{\n  // get irradiance\n  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);\n\n  // Use the maximum component of the iridescence Fresnel color\n  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n  vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n  // Blend between base F0 and iridescence F0\n  vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescence);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  vec3 diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  float IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n#endif // RN_USE_IRIDESCENCE\n\nIblResult getIBLRadianceLambertian(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, float specularWeight)\n{\n  // get irradiance\n  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  vec3 diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  float IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n\nIblResult getIBLRadianceGGX(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, float specularWeight)\n{\n  // get radiance\n  float mipCount = iblParameter.x;\n  float lod = (perceptualRoughness * (mipCount - 1.0));\n  vec3 radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  vec3 specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  float IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\n#ifdef RN_USE_SHEEN\nvec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)\n{\n  float mipCount = iblParameter.x;\n  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));\n\n  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);\n  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;\n  vec3 sheenLight = get_radiance(reflection, lod, hdriFormat);\n  float IBLSpecularContribution = iblParameter.z;\n  sheenLight *= IBLSpecularContribution;\n\n  return sheenLight * sheenColor * brdf;\n}\n#endif\n\nvec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {\n  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;\n  if (get_inverseEnvironment(materialSID, 0)) {\n    normal_forEnv.x *= -1.0;\n  }\n  return normal_forEnv;\n}\n\nvec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {\n#ifdef RN_USE_ANISOTROPY\n\n  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);\n  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);\n  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);\n  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;\n  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);\n#else\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n#endif\n  if (get_inverseEnvironment(materialSID, 0)) {\n    reflection.x *= -1.0;\n  }\n  return reflection;\n}\n\nvec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,\n  vec3 albedo, vec3 F0, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,\n  float clearcoat, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,\n  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,\n  vec3 iridescenceFresnel, vec3 iridescenceF0, float iridescence, float anisotropy, vec3 anisotropyDirection,\n  float specularWeight)\n{\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float rot = iblParameter.w;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);\n\n  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);\n\n  // IBL\n  #ifdef RN_USE_IRIDESCENCE\n    IblResult baseRadianceResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);\n    IblResult baseLambertianResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);\n  #else\n    IblResult baseRadianceResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n    IblResult baseLambertianResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n  #endif\n\n#ifdef RN_USE_TRANSMISSION\n  vec3 refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior);\n  vec3 refractedRayFromVPosition = v_position_inWorld + refractedRay;\n  vec4 ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayFromVPosition, 1.0);\n  vec2 refractionCoords = ndcPoint.xy / ndcPoint.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  vec3 transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);\n\n#ifdef RN_USE_VOLUME\n  vec3 attenuationColor = get_attenuationColor(materialSID, 0);\n  float attenuationDistance = get_attenuationDistance(materialSID, 0);\n  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));\n#endif\n\n  vec3 transmissionComp = (vec3(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;\n  vec3 diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);\n  vec3 base = diffuse + baseRadianceResult.specular;\n#else\n  vec3 base = baseLambertianResult.diffuse + baseRadianceResult.specular;\n#endif\n\n#ifdef RN_USE_SHEEN\n  vec3 sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);\n  vec3 color = sheen + base * albedoSheenScalingNdotV;\n#else\n  vec3 color = base;\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  float VdotNg = dot(geomNormal_inWorld, viewDirection);\n  vec3 clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  IblResult coatResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3(0.0), F0,\n    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);\n  vec3 coatLayer = coatResult.specular;\n\n  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  vec3 coated = color * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(coatLayer * clearcoat);\n  return coated;\n#else\n  return color;\n#endif\n\n}\n\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nvec2 getTexcoord(int texcoordIndex) {\n  vec2 texcoord;\n  if(texcoordIndex == 2){\n    texcoord = v_texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = v_texcoord_1;\n  }else{\n    texcoord = v_texcoord_0;\n  }\n  return texcoord;\n}\n\n#ifdef RN_USE_TANGENT\n  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {\n    vec3 tangent_inWorld = normalize(v_tangent_inWorld);\n    vec3 binormal_inWorld = normalize(v_binormal_inWorld);\n    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {\n      uv = gl_FrontFacing ? uv : -uv;\n\n      // get edge vectors of the pixel triangle\n      vec3 dp1 = dFdx(position);\n      vec3 dp2 = dFdy(position);\n      vec2 duv1 = dFdx(uv);\n      vec2 duv2 = dFdy(uv);\n\n      // solve the linear system\n      vec3 dp2perp = cross(dp2, normal_inWorld);\n      vec3 dp1perp = cross(normal_inWorld, dp1);\n      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {\n      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // View direction\n  vec3 viewPosition = get_viewPosition(cameraSID, 0);\n  vec3 viewVector = viewPosition - v_position_inWorld.xyz;\n  vec3 viewDirection = normalize(viewVector);\n\n  // BaseColor\n  vec3 baseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);\n  if (v_color != baseColor && baseColorFactor.rgb != baseColor) {\n    baseColor = v_color * baseColorFactor.rgb;\n    alpha = baseColorFactor.a;\n  } else if (v_color == baseColor) {\n    baseColor = baseColorFactor.rgb;\n    alpha = baseColorFactor.a;\n  } else if (baseColorFactor.rgb == baseColor) {\n    baseColor = v_color;\n  } else {\n    baseColor = vec3(1.0, 1.0, 1.0);\n  }\n  vec4 baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);\n  float baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);\n  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);\n  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);\n  vec2 baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);\n  vec4 textureColor = texture(u_baseColorTexture, baseColorTexUv);\n  baseColor *= srgbToLinear(textureColor.rgb);\n  alpha *= textureColor.a;\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (alpha < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n  vec3 geomNormal_inWorld = normal_inWorld;\n  #ifdef RN_USE_NORMAL_TEXTURE\n    vec4 normalTextureTransform = get_normalTextureTransform(materialSID, 0);\n    float normalTextureRotation = get_normalTextureRotation(materialSID, 0);\n    int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);\n    vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);\n    vec2 normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);\n    mat3 TBN = getTBN(normal_inWorld, viewVector, normalTexUv);\n    vec3 normalTexValue = texture(u_normalTexture, normalTexUv).xyz;\n    if(normalTexValue.b >= 128.0 / 255.0) {\n      // normal texture is existence\n      vec3 normalTex = normalTexValue * 2.0 - 1.0;\n      float normalScale = get_normalScale(materialSID, 0);\n      vec3 scaledNormal = normalize(normalTex * vec3(normalScale, normalScale, 1.0));\n      normal_inWorld = normalize(TBN * scaledNormal);\n    }\n  #endif\n\n#ifdef RN_IS_LIGHTING\n  // Metallic & Roughness\n  vec2 metallicRoughnessFactor = get_metallicRoughnessFactor(materialSID, 0);\n  float metallic = metallicRoughnessFactor.x;\n  vec4 metallicRoughnessTextureTransform = get_metallicRoughnessTextureTransform(materialSID, 0);\n  float metallicRoughnessTextureRotation = get_metallicRoughnessTextureRotation(materialSID, 0);\n  int metallicRoughnessTexcoordIndex = get_metallicRoughnessTexcoordIndex(materialSID, 0);\n  vec2 metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex);\n  vec2 metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransform.xy, metallicRoughnessTextureTransform.zw, metallicRoughnessTextureRotation, metallicRoughnessTexcoord);\n  vec4 ormTexel = texture(u_metallicRoughnessTexture, metallicRoughnessTexUv);\n  float perceptualRoughness = ormTexel.g * metallicRoughnessFactor.y;\n  metallic = ormTexel.b * metallic;\n  metallic = clamp(metallic, 0.0, 1.0);\n  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n    // filter NDF for specular AA --- https://jcgt.org/published/0010/02/02/\n  float alphaRoughness2 = alphaRoughness * alphaRoughness;\n  float filteredRoughness2 = IsotropicNDFFiltering(normal_inWorld, alphaRoughness2);\n  perceptualRoughness = sqrt(sqrt(filteredRoughness2));\n\n  // Albedo\n  vec3 black = vec3(0.0);\n  vec3 albedo = mix(baseColor.rgb, black, metallic);\n\n  // NdotV\n  float NdotV = saturateEpsilonToOne(dot(normal_inWorld, viewDirection));\n\n  #ifdef RN_USE_ANISOTROPY\n    float anisotropy = get_anisotropyStrength(materialSID, 0);\n    vec2 anisotropyRotation = get_anisotropyRotation(materialSID, 0);\n    vec2 direction = anisotropyRotation;\n    vec3 anisotropyTex = texture(u_anisotropyTexture, baseColorTexUv).rgb;\n    direction = anisotropyTex.rg * 2.0 - vec2(1.0);\n    direction = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x) * normalize(direction);\n    anisotropy *= anisotropyTex.b;\n    vec3 anisotropicT = normalize(TBN * vec3(direction, 0.0));\n    vec3 anisotropicB = normalize(cross(geomNormal_inWorld, anisotropicT));\n    float BdotV = dot(anisotropicB, viewDirection);\n    float TdotV = dot(anisotropicT, viewDirection);\n  #else\n    float anisotropy = 0.0;\n    vec3 anisotropicT = vec3(0.0, 0.0, 0.0);\n    vec3 anisotropicB = vec3(0.0, 0.0, 0.0);\n    float BdotV = 0.0;\n    float TdotV = 0.0;\n  #endif\n\n    // Clearcoat\n  #ifdef RN_USE_CLEARCOAT\n    float clearcoatFactor = get_clearCoatFactor(materialSID, 0);\n    vec4 clearcoatTextureTransform = get_clearCoatTextureTransform(materialSID, 0);\n    float clearcoatTextureRotation = get_clearCoatTextureRotation(materialSID, 0);\n    int clearCoatTexcoordIndex = get_clearCoatTexcoordIndex(materialSID, 0);\n    vec2 clearCoatTexcoord = getTexcoord(clearCoatTexcoordIndex);\n    vec2 clearcoatTexUv = uvTransform(clearcoatTextureTransform.xy, clearcoatTextureTransform.zw, clearcoatTextureRotation, clearCoatTexcoord);\n    float clearcoatTexture = texture(u_clearCoatTexture, clearcoatTexUv).r;\n    float clearcoat = clearcoatFactor * clearcoatTexture;\n  #else\n    float clearcoat = 0.0;\n  #endif // RN_USE_CLEARCOAT\n\n    // Transmission\n  #ifdef RN_USE_TRANSMISSION\n    float transmissionFactor = get_transmissionFactor(materialSID, 0);\n    float transmissionTexture = texture(u_transmissionTexture, baseColorTexUv).r;\n    float transmission = transmissionFactor * transmissionTexture;\n    // alpha *= transmission;\n  #else\n    float transmission = 0.0;\n  #endif // RN_USE_TRANSMISSION\n\n  #ifdef RN_USE_SPECULAR\n    float specularTexture = texture(u_specularTexture, baseColorTexUv).a;\n    float specular = get_specularFactor(materialSID, 0) * specularTexture;\n    vec3 specularColorTexture = srgbToLinear(texture(u_specularColorTexture, baseColorTexUv).rgb);\n    vec3 specularColor = get_specularColorFactor(materialSID, 0) * specularColorTexture;\n  #else\n    float specular = 1.0;\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n  #endif // RN_USE_SPECULAR\n\n  // F0, F90\n  float ior = get_ior(materialSID, 0);\n  float outsideIor = 1.0;\n  vec3 dielectricSpecularF0 = min(\n    ((ior - outsideIor) / (ior + outsideIor)) * ((ior - outsideIor) / (ior + outsideIor)) * specularColor,\n    vec3(1.0)\n    ) * specular;\n  vec3 dielectricSpecularF90 = vec3(specular);\n  vec3 F0 = mix(dielectricSpecularF0, baseColor.rgb, metallic);\n  vec3 F90 = mix(dielectricSpecularF90, vec3(1.0), metallic);\n\n  // Iridescence\n  #ifdef RN_USE_IRIDESCENCE\n    float iridescenceFactor = get_iridescenceFactor(materialSID, 0);\n    float iridescenceTexture = texture(u_iridescenceTexture, baseColorTexUv).r;\n    float iridescence = iridescenceFactor * iridescenceTexture;\n    float iridescenceIor = get_iridescenceIor(materialSID, 0);\n    float thicknessRatio = texture(u_iridescenceThicknessTexture, baseColorTexUv).r;\n    float iridescenceThicknessMinimum = get_iridescenceThicknessMinimum(materialSID, 0);\n    float iridescenceThicknessMaximum = get_iridescenceThicknessMaximum(materialSID, 0);\n    float iridescenceThickness = mix(iridescenceThicknessMinimum, iridescenceThicknessMaximum, thicknessRatio);\n    vec3 iridescenceFresnel = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, F0);\n    vec3 iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\n  #else\n    float iridescence = 0.0;\n    vec3 iridescenceFresnel = vec3(0.0);\n    vec3 iridescenceF0 = F0;\n  #endif // RN_USE_IRIDESCENCE\n\n  #ifdef RN_USE_CLEARCOAT\n    // Clearcoat\n    float clearcoatRoughnessFactor = get_clearCoatRoughnessFactor(materialSID, 0);\n    int clearCoatRoughnessTexcoordIndex = get_clearCoatRoughnessTexcoordIndex(materialSID, 0);\n    vec2 clearCoatRoughnessTexcoord = getTexcoord(clearCoatRoughnessTexcoordIndex);\n    vec4 clearcoatRoughnessTextureTransform = get_clearCoatRoughnessTextureTransform(materialSID, 0);\n    float clearcoatRoughnessTextureRotation = get_clearCoatRoughnessTextureRotation(materialSID, 0);\n    vec2 clearcoatRoughnessTexUv = uvTransform(clearcoatRoughnessTextureTransform.xy, clearcoatRoughnessTextureTransform.zw, clearcoatRoughnessTextureRotation, clearCoatRoughnessTexcoord);\n    float textureRoughnessTexture = texture(u_clearCoatRoughnessTexture, clearcoatRoughnessTexUv).g;\n    float clearcoatRoughness = clearcoatRoughnessFactor * textureRoughnessTexture;\n\n    int clearCoatNormalTexcoordIndex = get_clearCoatNormalTexcoordIndex(materialSID, 0);\n    vec2 clearCoatNormalTexcoord = getTexcoord(clearCoatNormalTexcoordIndex);\n    vec4 clearcoatNormalTextureTransform = get_clearCoatNormalTextureTransform(materialSID, 0);\n    float clearcoatNormalTextureRotation = get_clearCoatNormalTextureRotation(materialSID, 0);\n    vec2 clearcoatNormalTexUv = uvTransform(clearcoatNormalTextureTransform.xy, clearcoatNormalTextureTransform.zw, clearcoatNormalTextureRotation, clearCoatNormalTexcoord);\n    vec3 textureNormal_tangent = texture(u_clearCoatNormalTexture, clearcoatNormalTexUv).xyz * vec3(2.0) - vec3(1.0);\n    vec3 clearcoatNormal_inWorld = normalize(TBN * textureNormal_tangent);\n    float VdotNc = saturateEpsilonToOne(dot(viewDirection, clearcoatNormal_inWorld));\n  #else\n    float clearcoatRoughness = 0.0;\n    vec3 clearcoatNormal_inWorld = vec3(0.0);\n    float VdotNc = 0.0;\n  #endif // RN_USE_CLEARCOAT\n\n  #ifdef RN_USE_VOLUME\n    // Volume\n    float thicknessFactor = get_thicknessFactor(materialSID, 0);\n    float thicknessTexture = texture(u_thicknessTexture, baseColorTexUv).g;\n    float attenuationDistance = get_attenuationDistance(materialSID, 0);\n    vec3 attenuationColor = get_attenuationColor(materialSID, 0);\n    float thickness = thicknessFactor * thicknessTexture;\n  #else\n    float thickness = 0.0;\n    vec3 attenuationColor = vec3(0.0);\n    float attenuationDistance = 0.000001;\n  #endif // RN_USE_VOLUME\n\n  #ifdef RN_USE_SHEEN\n    // Sheen\n    vec3 sheenColorFactor = get_sheenColorFactor(materialSID, 0);\n    vec3 sheenColorTexture = texture(u_sheenColorTexture, baseColorTexUv).rgb;\n    float sheenRoughnessFactor = get_sheenRoughnessFactor(materialSID, 0);\n    float sheenRoughnessTexture = texture(u_sheenRoughnessTexture, baseColorTexUv).a;\n    vec3 sheenColor = sheenColorFactor * sheenColorTexture;\n    float sheenRoughness = clamp(sheenRoughnessFactor * sheenRoughnessTexture, 0.000001, 1.0);\n    float albedoSheenScalingNdotV = 1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotV, sheenRoughness)).r;\n  #else\n    vec3 sheenColor = vec3(0.0);\n    float sheenRoughness = 0.000001;\n    float albedoSheenScalingNdotV = 1.0;\n  #endif // RN_USE_SHEEN\n\n  rt0 = vec4(0.0, 0.0, 0.0, alpha);\n\n  // Lighting\n  for (int i = 0; i < lightNumber; i++) {\n    Light light = getLight(i, v_position_inWorld.xyz);\n    vec3 lighting = lightingWithPunctualLight(light, normal_inWorld, viewDirection, NdotV, albedo,\n                        perceptualRoughness, metallic, F0, F90, ior, transmission,\n                        clearcoat, clearcoatRoughness, clearcoatNormal_inWorld, VdotNc,\n                        attenuationColor, attenuationDistance,\n                        anisotropy, anisotropicT, anisotropicB, BdotV, TdotV,\n                        sheenColor, sheenRoughness, albedoSheenScalingNdotV,\n                        iridescence, iridescenceFresnel, specular);\n\n  #ifdef RN_USE_SHADOW_MAPPING\n    if (light.type == 1) { // Point Light\n      float pointLightFarPlane = get_pointLightFarPlane(materialSID, 0);\n      float shadowContribution = varianceShadowContributionParaboloid(v_position_inWorld.xyz, light.position, pointLightFarPlane);\n      lighting *= shadowContribution;\n    }\n  #endif\n\n    rt0.rgb += lighting;\n  }\n\n  #ifdef RN_USE_SHADOW_MAPPING\n    // float bias = 0.001;\n    // vec2 shadowCoord = v_shadowCoord.xy / v_shadowCoord.w;\n    // float shadowContribution = 1.0;\n    // if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {\n    //   shadowContribution = varianceShadowContribution(shadowCoord, (v_shadowCoord.z - bias)/v_shadowCoord.w);\n    // }\n    // // rt0.rgb = rt0.rgb * (0.5 + shadowContribution * 0.5);\n    // rt0.rgb = rt0.rgb * shadowContribution;\n  #endif\n\n  vec3 ibl = IBLContribution(materialSID, normal_inWorld, NdotV, viewDirection,\n    albedo, F0, perceptualRoughness, clearcoatRoughness, clearcoatNormal_inWorld,\n    clearcoat, VdotNc, geomNormal_inWorld, cameraSID, transmission, v_position_inWorld.xyz, thickness,\n    sheenColor, sheenRoughness, albedoSheenScalingNdotV,\n    ior, iridescenceFresnel, iridescenceF0, iridescence,\n    anisotropy, anisotropicB, specular);\n\n  int occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);\n  vec2 occlusionTexcoord = getTexcoord(occlusionTexcoordIndex);\n  vec4 occlusionTextureTransform = get_occlusionTextureTransform(materialSID, 0);\n  float occlusionTextureRotation = get_occlusionTextureRotation(materialSID, 0);\n  vec2 occlusionTexUv = uvTransform(occlusionTextureTransform.xy, occlusionTextureTransform.zw, occlusionTextureRotation, occlusionTexcoord);\n  float occlusion = texture(u_occlusionTexture, occlusionTexUv).r;\n  float occlusionStrength = get_occlusionStrength(materialSID, 0);\n\n  // Occlution to Indirect Lights\n  rt0.xyz += mix(ibl, ibl * occlusion, occlusionStrength);\n#else\n  rt0 = vec4(baseColor, alpha);\n#endif // RN_IS_LIGHTING\n\n  // Emissive\n  vec3 emissiveFactor = get_emissiveFactor(materialSID, 0);\n  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);\n  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);\n  vec4 emissiveTextureTransform = get_emissiveTextureTransform(materialSID, 0);\n  float emissiveTextureRotation = get_emissiveTextureRotation(materialSID, 0);\n  vec2 emissiveTexUv = uvTransform(emissiveTextureTransform.xy, emissiveTextureTransform.zw, emissiveTextureRotation, emissiveTexcoord);\n  float emissiveStrength = get_emissiveStrength(materialSID, 0);\n  vec3 emissive = emissiveFactor * srgbToLinear(texture(u_emissiveTexture, emissiveTexUv).xyz) * emissiveStrength;\n\n#ifdef RN_USE_CLEARCOAT\n  vec3 coated_emissive = emissive * mix(vec3(1.0), vec3(0.04 + (1.0 - 0.04) * pow(1.0 - NdotV, 5.0)), clearcoat);\n  rt0.xyz += coated_emissive;\n#else\n  rt0.xyz += emissive;\n#endif // RN_USE_CLEARCOAT\n\n  bool isOutputHDR = get_isOutputHDR(materialSID, 0);\n  if(isOutputHDR){\n/* shaderity: @{renderTargetEnd} */\n\n    return;\n  }\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  rt0.a = 1.0;\n#endif\n\nfloat makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));\nrt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);\n\nrt0.rgb = rt0.rgb * rt0.a; // alpha premultiplied\nrt1 = rt0;\nrt2 = rt0;\nrt3 = rt0;\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},T={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\n// #param depthBiasPV: mat4x4<f32>; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n  let instanceId = u32(instance_ids.x);\n  let worldMatrix = get_worldMatrix(instanceId);\n  let normalMatrix = get_normalMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  let skeletalComponentSID = i32(instance_ids.y);\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\n  let blendShapeComponentSID = u32(instance_ids.z);\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  output.position_inWorld = geom.position_inWorld.xyz;\n  output.normal_inWorld = geom.normal_inWorld;\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  output.texcoord_1 = texcoord_1;\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  output.texcoord_2 = texcoord_2;\n#endif\n\n#ifdef RN_USE_COLOR_0\n  output.color_0 = vec4f(color_0);\n#else\n  output.color_0 = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n#endif\n\n#ifdef RN_USE_TANGENT\n  output.tangent_inWorld = normalMatrix * tangent.xyz;\n  output.binormal_inWorld = cross(output.tangent_inWorld, output.normal_inWorld) * tangent.w;\n#endif\n\n  output.instanceInfo = instance_ids.x;\n\n  let visibility = get_isVisible(instanceId);\n  if (!visibility)\n  {\n    output.position = vec4f(0.0, 0.0, 0.0, 1.0);\n  }\n\n#ifdef RN_USE_SHADOW_MAPPING\n  output.shadowCoord = get_depthBiasPV(materialSID, 0) * geom.position_inWorld;\n#endif\n\n  return output;\n}\n",shaderStage:"vertex",isFragmentShader:!1},w={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\nstruct Light {\n  lightType: i32, // 0 = directional, 1 = point, 2 = spot\n  position: vec3<f32>,\n  intensity: vec3<f32>,\n  attenuatedIntensity: vec3<f32>,\n  directionOfLightObject: vec3<f32>,\n  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)\n  pointToLight: vec3<f32>, // not normalized\n  spotAngleScale: f32,\n  spotAngleOffset: f32,\n  effectiveRange: f32,\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfn getRangeAttenuation(light: Light) -> f32\n{\n  let distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfn getSpotAttenuation(light: Light) -> f32\n{\n\n  let cd = dot(light.directionOfLightObject, light.direction);\n  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nfn getLightAttenuated(light: Light) -> Light {\n  var newLight: Light = light;\n  newLight.attenuatedIntensity = light.intensity;\n  // if (light.lightType == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.lightType == 1)\n  {\n    newLight.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.lightType == 2)\n  {\n    newLight.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n\n  return newLight;\n}\n\nfn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {\n  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);\n  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);\n  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);\n  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);\n  var light: Light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  let lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3f(0.0);\n    light.lightType = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.lightType = 1;\n  } else { // is Directional Light\n    light.lightType = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.lightType = 2;\n  }\n\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  let newLight = getLightAttenuated(light);\n\n  return newLight;\n}\n\n#ifdef RN_USE_TANGENT\n  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n    let tangent_inWorld = normalize(input.tangent_inWorld);\n    let binormal_inWorld = normalize(input.binormal_inWorld);\n    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {\n      var uv: vec2f;\n      if (isFront) {\n        uv = uv_;\n      } else {\n        uv = -uv_;\n      }\n\n      // get edge vectors of the pixel triangle\n      let dp1 = dpdx(position);\n      let dp2 = dpdy(position);\n      let duv1 = dpdx(uv);\n      let duv2 = dpdy(uv);\n\n      // solve the linear system\n      let dp2perp = cross(dp2, normal_inWorld);\n      let dp1perp = cross(normal_inWorld, dp1);\n      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nfn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {\n    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);\n}\n\nfn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {\n    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);\n}\n\n\n// The Schlick Approximation to Fresnel\nfn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnel2(f0: vec3f, VdotH: f32) -> vec3f\n{\n  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nfn fresnel2F32(f0: f32, VdotH: f32) -> f32\n{\n  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnelF32(f0, f90, VdotH);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nfn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nfn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f\n{\n  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n\n// GGX NDF\nfn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {\n  let roughnessSqr = alphaRoughness * alphaRoughness;\n  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {\n  let a2 = alphaRoughness * alphaRoughness;\n  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {\n  let D = d_GGX(NH, alphaRoughness);\n  let V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3f(D) * vec3f(V) * F * specularWeight;\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nfn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {\n  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );\n  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );\n  let r = Roughness * c0 + c1;\n  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nfn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n  let D = d_GGX(NdotHc, clearcoatAlpha);\n  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  let f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {\n  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  let D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nfn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;\n    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32\n{\n    let a2 = at * ab;\n    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);\n    let w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,\n    at: f32, ab: f32) -> f32\n{\n    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    let v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nfn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,\n    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,\n    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f\n{\n    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    let ab = alphaRoughness;\n\n    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let invAlpha  = 1.0 / alphaG;\n  let cos2h = NoH * NoH;\n  let sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn charlieL(x: f32, alphaG: f32) -> f32 {\n  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32\n{\n  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);\n}\n\nfn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nfn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {\n  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif // RN_USE_SHEEN\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst XYZ_TO_REC709 = mat3x3<f32>(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nfn fresnelSchlickRoughnessWithIridescence(\n  F0: vec3f, cosTheta: f32, roughness: f32,\n  iridescenceFresnel: vec3f, iridescence: f32\n  ) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nfn Fresnel0ToIor(F0: vec3f) -> vec3f {\n    let sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {\n    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {\n    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nfn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {\n    let phase = 2.0 * M_PI * OPD * 1.0e-9;\n    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    let rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nfn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));\n  let cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3f(1.0);\n  }\n\n  let cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);\n  let R12 = fresnel2F32(R0, cosTheta1);\n  let R21 = R12;\n  let T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);\n  let R23 = fresnel2(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  var phi12 = 0.0;\n  if (iridescenceIor < outsideIor) { phi12 = M_PI; }\n  let phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  var phi23 = vec3f(0.0);\n  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }\n  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }\n  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }\n\n  // OPD (optical path difference)\n  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  let phi = vec3f(phi21) + phi23;\n\n  // Compound terms\n  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));\n  let r123 = sqrt(R123);\n  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  let C0 = R12 + Rs;\n  var I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  var Cm = Rs - T121;\n  for (var m = 1; m <= 2; m++)\n  {\n      Cm *= r123;\n      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);\n      I += Cm * Sm;\n  }\n\n  let F_iridescence = max(I, vec3f(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nfn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f\n{\n    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n\n    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);\n\n    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nfn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f\n{\n    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    let D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nfn lightingWithPunctualLight(\n  light: Light,\n  normal_inWorld: vec3f,\n  viewDirection: vec3f,\n  NdotV: f32,\n  albedo: vec3f,\n  perceptualRoughness: f32,\n  F0: vec3f,\n  F90: vec3f,\n  transmission: f32,\n  ior: f32,\n  clearcoat: f32,\n  clearcoatRoughness: f32,\n  clearcoatNormal_inWorld: vec3f,\n  VdotNc: f32,\n  attenuationColor: vec3f,\n  attenuationDistance: f32,\n  anisotropy: f32,\n  anisotropicT: vec3f,\n  anisotropicB: vec3f,\n  BdotV: f32,\n  TdotV: f32,\n  sheenColor: vec3f,\n  sheenRoughness: f32,\n  albedoSheenScalingNdotV: f32,\n  iridescenceFactor: f32,\n  iridescenceFresnel: vec3f,\n  specularWeight: f32,\n  ) -> vec3f\n{\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  let halfVector = normalize(light.direction + viewDirection);\n  let VdotH = dot(viewDirection, halfVector);\n  let F = fresnel(F0, F90, VdotH);\n\n  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  var transmittedLightFromUnderSurface: Light = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);\n#else\n  let diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n\n#ifdef RN_USE_IRIDESCENCE\n  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  let TdotL = dot(anisotropicT, light.direction);\n  let BdotL = dot(anisotropicB, light.direction);\n  let TdotH = dot(anisotropicT, halfVector);\n  let BdotH = dot(anisotropicB, halfVector);\n  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;\n#else\n  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;\n#endif\n\n  // Base Layer\n  let baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  let albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);\n  let color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  let color = baseLayer;\n  let albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  let coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  let finalColor = coated;\n#else\n  let finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\nfn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {\n  let SIGMA2 = 0.15915494;\n  let KAPPA = 0.18;\n  let dndu  = dpdx(normal);\n  let dndv = dpdy(normal);\n  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n// #param makeOutputSrgb: bool; // initialValue=1\n\n// Color\n// #param baseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n// #param baseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param baseColorTextureRotation: f32; // initialValue=0\n// #param baseColorTexcoordIndex: f32; // initialValue=0\n\n// #param ior: f32; // initialValue=1.5\n\n// #param metallicRoughnessFactor: vec2<f32>; // initialValue=(1,1)\n@group(1) @binding(1) var metallicRoughnessTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(1) var metallicRoughnessSampler: sampler;\n// #param metallicRoughnessTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param metallicRoughnessTextureRotation: f32; // initialValue=0\n// #param metallicRoughnessTexcoordIndex: f32; // initialValue=0\n\n#ifdef RN_USE_NORMAL_TEXTURE\n  @group(1) @binding(2) var normalTexture: texture_2d<f32>; // initialValue=black\n  @group(2) @binding(2) var normalSampler: sampler;\n  // #param normalTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n  // #param normalTextureRotation: f32; // initialValue=(0)\n  // #param normalTexcoordIndex: f32; // initialValue=(0)\n  // #param normalScale: f32; // initialValue=(1)\n#endif\n\n@group(1) @binding(3) var occlusionTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(3) var occlusionSampler: sampler;\n// #param occlusionTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param occlusionTextureRotation: f32; // initialValue=0\n// #param occlusionTexcoordIndex: u32; // initialValue=0\n// #param occlusionStrength: f32; // initialValue=1\n\n// #param emissiveFactor: vec3<f32>; // initialValue=(0,0,0)\n// #param emissiveTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param emissiveTextureRotation: f32; // initialValue=0\n// #param emissiveTexcoordIndex: u32; // initialValue=0\n@group(1) @binding(4) var emissiveTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(4) var emissiveSampler: sampler;\n// #param emissiveStrength: f32; // initialValue=1\n\n#ifdef RN_USE_CLEARCOAT\n// #param clearCoatFactor: f32; // initialValue=0\n// #param clearCoatRoughnessFactor: f32; // initialValue=0\n// #param clearCoatTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param clearCoatTextureRotation: f32; // initialValue=0\n// #param clearCoatRoughnessTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param clearCoatRoughnessTextureRotation: f32; // initialValue=0\n// #param clearCoatNormalTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param clearCoatNormalTextureRotation: f32; // initialValue=0\n// #param clearCoatTexcoordIndex: u32; // initialValue=(0)\n// #param clearCoatRoughnessTexcoordIndex: u32; // initialValue=(0)\n// #param clearCoatNormalTexcoordIndex: u32; // initialValue=(0)\n#endif // RN_USE_CLEARCOAT\n\n\n#ifdef RN_USE_TRANSMISSION\n// #param transmissionFactor: f32; // initialValue=(0)\n#endif // RN_USE_TRANSMISSION\n\n#ifdef RN_USE_VOLUME\n// #param thicknessFactor: f32; // initialValue=(0)\n// #param attenuationDistance: f32; // initialValue=(0.000001)\n// #param attenuationColor: vec3<f32>; // initialValue=(1,1,1)\n#endif\n\n#ifdef RN_USE_SHEEN\n// #param sheenColorFactor: vec3<f32>; // initialValue=(0,0,0)\n// #param sheenRoughnessFactor: f32; // initialValue=(0)\n#endif\n\n#ifdef RN_USE_SPECULAR\n// #param specularFactor: f32; // initialValue=1.0\n// #param specularColorFactor: vec3<f32>; // initialValue=(1,1,1)\n#endif\n\n#ifdef RN_USE_IRIDESCENCE\n// #param iridescenceFactor: f32; // initialValue=0\n// #param iridescenceIor: f32; // initialValue=1.3\n// #param iridescenceThicknessMinimum: f32; // initialValue=100\n// #param iridescenceThicknessMaximum: f32; // initialValue=400\n#endif\n\n#ifdef RN_USE_ANISOTROPY\n// #param anisotropyStrength: f32; // initialValue=0\n// #param anisotropyRotation: vec2<f32>; // initialValue=(1,0)\n#endif\n\n// #param alphaCutoff: f32; // initialValue=0.01\n\n@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(16) var diffuseEnvSampler: sampler;\n@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(17) var specularEnvSampler: sampler;\n\n\n// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true\n// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true\n// #param inverseEnvironment: bool; // initialValue=false\nfn get_irradiance(normal_forEnv: vec3f, hdriFormat: vec2<i32>) -> vec3f {\n  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);\n\n  var irradiance: vec3f;\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    irradiance = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    irradiance = diffuseTexel.rgb;\n  }\n\n  return irradiance;\n}\n\nfn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {\n  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);\n\n  var radiance: vec3f;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    radiance = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    radiance = specularTexel.rgb;\n  }\n\n  return radiance;\n}\n\n#ifdef RN_USE_SHEEN\nfn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f\n{\n  let mipCount = iblParameter.x;\n  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));\n\n  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);\n  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;\n  var sheenLight = get_radiance(reflection, lod, hdriFormat);\n  let IBLSpecularContribution = iblParameter.z;\n  sheenLight *= IBLSpecularContribution;\n\n  return sheenLight * sheenColor * brdf;\n}\n#endif\n\nfn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {\n  var normal_forEnv = rotEnvMatrix * normal_inWorld;\n  if (get_inverseEnvironment(materialSID, 0)) {\n    normal_forEnv.x *= -1.0;\n  }\n  return normal_forEnv;\n}\n\nfn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,\n  materialSID: u32, perceptualRoughness: f32,\n  anisotropy: f32, anisotropyDirection: vec3f\n  ) -> vec3f {\n#ifdef RN_USE_ANISOTROPY\n  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);\n  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);\n  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);\n  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;\n  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));\n  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);\n#else\n  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n#endif\n  if (get_inverseEnvironment(materialSID, 0)) {\n    reflection.x *= -1.0;\n  }\n  return reflection;\n}\n\nfn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32\n{\n  // Scale roughness to the range [0, 1],\n  // ior=1.0 will be scale 0,\n  // ior=1.5 will be scale 1.0,\n  // ior=2 will be scale 1.0 (clamped)\n  //\n\n  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n  return perceptualRoughness * scale;\n}\n\n#ifdef RN_USE_TRANSMISSION\nfn get_sample_from_backbuffer(materialSID: u32, sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {\n  let vrState: vec2<i32> = get_vrState(0, 0);\n  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));\n  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);\n  var newSampleCoord = sampleCoord;\n  newSampleCoord.y = 1.0 - newSampleCoord.y;\n  if (vrState.x == 1) { // For VR\n    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n    newSampleCoord.x = sampleCoord.x * 0.5;\n    if (vrState.y == 1) { // For right eye\n      newSampleCoord.x += 0.5;\n    }\n  }\n  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);\n\n  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;\n\n  return transmittedLight;\n}\n\n// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer\nfn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f\n{\n  let refractionVector = refract(-v, normalize(n), 1.0 / ior);\n  let worldMatrix = get_worldMatrix(instanceInfo);\n\n  var modelScale: vec3f;\n  modelScale.x = length(vec3f(worldMatrix[0].xyz));\n  modelScale.y = length(vec3f(worldMatrix[1].xyz));\n  modelScale.z = length(vec3f(worldMatrix[2].xyz));\n\n  return normalize(refractionVector) * thickness * modelScale;\n}\n#endif // RN_USE_TRANSMISSION\n\nstruct IblResult\n{\n  specular: vec3f,\n  diffuse: vec3f,\n  FssEss: vec3f,\n};\n\n\n#ifdef RN_USE_IRIDESCENCE\nfn getIBLRadianceGGXWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, iridescenceFresnel: vec3f, iridescence: f32, specularWeight: f32) -> IblResult\n{\n  // get radiance\n  let mipCount = iblParameter.x;\n  let lod = (perceptualRoughness * (mipCount - 1.0));\n  let radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);\n  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss = kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  var specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  let IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nfn getIBLRadianceLambertianWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, iridescenceF0: vec3f, iridescence: f32, specularWeight: f32) -> IblResult\n{\n  // get irradiance\n  let irradiance = get_irradiance(normal_forEnv, hdriFormat);\n\n  // Use the maximum component of the iridescence Fresnel color\n  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n  let iridescenceF0Max = vec3f(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n  // Blend between base F0 and iridescence F0\n  let mixedF0 = mix(F0, iridescenceF0Max, iridescence);\n\n  // Roughness dependent fresnel\n  let kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);\n  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  let Ems = (1.0 - (f_ab.x + f_ab.y));\n  let F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n  let FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  let k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  var diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  let IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n#endif // RN_USE_IRIDESCENCE\n\nfn getIBLRadianceLambertian(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult\n{\n  // get irradiance\n  let irradiance: vec3f = get_irradiance(normal_forEnv, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss: vec3f = specularWeight * kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  let Ems = (1.0 - (f_ab.x + f_ab.y));\n  let F_avg: vec3f = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  let k_D: vec3f = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  var diffuse: vec3f = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  let IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n\nfn getIBLRadianceGGX(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult\n{\n  // get radiance\n  let mipCount = iblParameter.x;\n  let lod = (perceptualRoughness * (mipCount - 1.0));\n  let radiance: vec3f = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss: vec3f = kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  var specular: vec3f = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  let IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nfn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,\n  albedo: vec3f, F0: vec3f, perceptualRoughness: f32,\n  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, VdotNc: f32, geomNormal_inWorld: vec3f,\n  transmission: f32, v_position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,\n  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,\n  iridescenceFresnel: vec3f, iridescenceF0: vec3f, iridescence: f32,\n  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32\n  ) -> vec3f\n{\n  let iblParameter: vec4f = get_iblParameter(materialSID, 0);\n  let rot = iblParameter.w;\n  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);\n\n  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);\n\n  // IBL\n#ifdef RN_USE_IRIDESCENCE\n  let baseRadianceResult: IblResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);\n  let baseLambertianResult: IblResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);\n#else\n  let baseRadianceResult: IblResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n  let baseLambertianResult: IblResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n#endif\n\n#ifdef RN_USE_TRANSMISSION\n  let refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior, instanceInfo);\n  let refractedRayFromVPosition = v_position_inWorld + refractedRay;\n  let ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayFromVPosition, 1.0);\n  var refractionCoords = ndcPoint.xy / ndcPoint.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  var transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);\n\n#ifdef RN_USE_VOLUME\n  let attenuationColor = get_attenuationColor(materialSID, 0);\n  let attenuationDistance = get_attenuationDistance(materialSID, 0);\n  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));\n#endif\n\n  let transmissionComp = (vec3f(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;\n  let diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);\n  let base = diffuse + baseRadianceResult.specular;\n#else\n  let base: vec3f = baseLambertianResult.diffuse + baseRadianceResult.specular;\n#endif\n\n#ifdef RN_USE_SHEEN\n  let sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);\n  let color = sheen + base * albedoSheenScalingNdotV;\n#else\n  let color = base;\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  let VdotNg = dot(geomNormal_inWorld, viewDirection);\n  let clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let coatResult: IblResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3f(0.0), F0,\n    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);\n  let coatLayer = coatResult.specular;\n\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let coated = color * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(coatLayer * clearcoat);\n  return coated;\n#else\n  return color;\n#endif\n}\n\n\n\n@fragment\nfn main(\n  input: VertexOutput,\n  @builtin(front_facing) isFront: bool,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n  let viewPosition = get_viewPosition(cameraSID, 0);\n  let viewVector = viewPosition - input.position_inWorld.xyz;\n  let viewDirection = normalize(viewVector);\n\n// BaseColor\n  var baseColor = vec4<f32>(1, 1, 1, 1);\n  var baseColorFactor = get_baseColorFactor(materialSID, 0u);\n\n#ifdef RN_USE_COLOR_0\n  baseColor = input.color_0;\n#endif\n\n  baseColor *= baseColorFactor;\n\n#ifdef RN_USE_TEXCOORD_0\n  let baseColorTextureTransform: vec4f = get_baseColorTextureTransform(materialSID, 0);\n  let baseColorTextureRotation: f32 = get_baseColorTextureRotation(materialSID, 0);\n  let baseColorTexcoordIndex: u32 = u32(get_baseColorTexcoordIndex(materialSID, 0));\n  let baseColorTexcoord = getTexcoord(baseColorTexcoordIndex, input);\n  let baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);\n  let textureColor = textureSample(baseColorTexture, baseColorSampler, baseColorTexUv);\n  baseColor *= vec4(srgbToLinear(textureColor.rgb), textureColor.a);\n#else\n  let baseColorTexUv = vec2f(0.0, 0.0);\n#endif\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  let alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (baseColor.a < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n\n// Normal\n  var normal_inWorld = normalize(input.normal_inWorld);\n  let geomNormal_inWorld = normal_inWorld;\n  let normalTextureTransform: vec4f = get_normalTextureTransform(materialSID, 0);\n  let normalTextureRotation: f32 = get_normalTextureRotation(materialSID, 0);\n  let normalTexcoordIndex: u32 = u32(get_normalTexcoordIndex(materialSID, 0));\n  let normalTexcoord: vec2f = getTexcoord(normalTexcoordIndex, input);\n  let normalTexUv: vec2f = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);\n  let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewVector, normalTexUv, isFront);\n  #ifdef RN_USE_NORMAL_TEXTURE\n    let normalTexValue: vec3f = textureSample(normalTexture, normalSampler, normalTexUv).xyz;\n    if(normalTexValue.b >= 128.0 / 255.0) {\n      // normal texture is existence\n      let normalTex = normalTexValue * 2.0 - 1.0;\n      let normalScale = get_normalScale(materialSID, 0);\n      let scaledNormal = normalize(normalTex * vec3(normalScale, normalScale, 1.0));\n      normal_inWorld = normalize(TBN * scaledNormal);\n    }\n  #endif\n\n#ifdef RN_IS_LIGHTING\n  // Metallic & Roughness\n  let metallicRoughnessFactor: vec2f = get_metallicRoughnessFactor(materialSID, 0);\n  var metallic = metallicRoughnessFactor.x;\n  let metallicRoughnessTextureTransform = get_metallicRoughnessTextureTransform(materialSID, 0);\n  let metallicRoughnessTextureRotation = get_metallicRoughnessTextureRotation(materialSID, 0);\n  let metallicRoughnessTexcoordIndex = u32(get_metallicRoughnessTexcoordIndex(materialSID, 0));\n  let metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex, input);\n  let metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransform.xy, metallicRoughnessTextureTransform.zw, metallicRoughnessTextureRotation, metallicRoughnessTexcoord);\n  let ormTexel = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, metallicRoughnessTexUv);\n  var perceptualRoughness = ormTexel.g * metallicRoughnessFactor.y;\n  metallic = ormTexel.b * metallic;\n  metallic = clamp(metallic, 0.0, 1.0);\n  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n    // filter NDF for specular AA --- https://jcgt.org/published/0010/02/02/\n  let alphaRoughness2 = alphaRoughness * alphaRoughness;\n  let filteredRoughness2 = IsotropicNDFFiltering(normal_inWorld, alphaRoughness2);\n  perceptualRoughness = sqrt(sqrt(filteredRoughness2));\n\n  // Albedo\n  let black = vec3f(0.0);\n  let albedo = mix(baseColor.rgb, black, metallic);\n\n  // NdotV\n  let NdotV = clamp(dot(normal_inWorld, viewDirection), Epsilon, 1.0);\n\n#ifdef RN_USE_ANISOTROPY\n  // Anisotropy\n  var anisotropy: f32 = get_anisotropyStrength(materialSID, 0);\n  let anisotropyRotation: vec2f = get_anisotropyRotation(materialSID, 0);\n  var direction: vec2f = anisotropyRotation;\n  let anisotropyTex: vec3f = textureSample(anisotropyTexture, anisotropySampler, baseColorTexUv).rgb;\n  direction = anisotropyTex.rg * 2.0 - vec2f(1.0);\n  direction = mat2x2<f32>(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x) * normalize(direction);\n  anisotropy *= anisotropyTex.b;\n  let anisotropicT: vec3f = normalize(TBN * vec3f(direction, 0.0));\n  let anisotropicB: vec3f = normalize(cross(geomNormal_inWorld, anisotropicT));\n  let BdotV: f32 = dot(anisotropicB, viewDirection);\n  let TdotV: f32 = dot(anisotropicT, viewDirection);\n#else\n  let anisotropy = 0.0;\n  let anisotropicT = vec3f(0.0, 0.0, 0.0);\n  let anisotropicB = vec3f(0.0, 0.0, 0.0);\n  let BdotV = 0.0;\n  let TdotV = 0.0;\n#endif\n\n  // Clearcoat\n#ifdef RN_USE_CLEARCOAT\n  let clearcoatFactor = get_clearCoatFactor(materialSID, 0);\n  let clearcoatTextureTransform = get_clearCoatTextureTransform(materialSID, 0);\n  let clearcoatTextureRotation = get_clearCoatTextureRotation(materialSID, 0);\n  let clearCoatTexcoordIndex = get_clearCoatTexcoordIndex(materialSID, 0);\n  let clearCoatTexcoord = getTexcoord(clearCoatTexcoordIndex, input);\n  let clearcoatTexUv = uvTransform(clearcoatTextureTransform.xy, clearcoatTextureTransform.zw, clearcoatTextureRotation, clearCoatTexcoord);\n  let clearcoatTexture = textureSample(clearCoatTexture, clearCoatSampler, clearcoatTexUv).r;\n  let clearcoat = clearcoatFactor * clearcoatTexture;\n#else\n  let clearcoat = 0.0;\n#endif // RN_USE_CLEARCOAT\n\n  // Transmission\n#ifdef RN_USE_TRANSMISSION\n  let transmissionFactor = get_transmissionFactor(materialSID, 0);\n  let transmissionTexture = textureSample(transmissionTexture, transmissionSampler, baseColorTexUv).r;\n  let transmission = transmissionFactor * transmissionTexture;\n    // alpha *= transmission;\n#else\n  let transmission = 0.0;\n#endif // RN_USE_TRANSMISSION\n\n#ifdef RN_USE_SPECULAR\n  let specularTexture: f32 = textureSample(specularTexture, specularSampler, baseColorTexUv).a;\n  let specular: f32 = get_specularFactor(materialSID, 0) * specularTexture;\n  let specularColorTexture: vec3f = srgbToLinear(textureSample(specularColorTexture, specularColorSampler, baseColorTexUv).rgb);\n  let specularColor: vec3f = get_specularColorFactor(materialSID, 0) * specularColorTexture;\n#else\n  let specular = 1.0;\n  let specularColor = vec3f(1.0, 1.0, 1.0);\n#endif // RN_USE_SPECULAR\n\n  // F0, F90\n  let ior = get_ior(materialSID, 0);\n  let outsideIor = 1.0;\n  let dielectricSpecularF0 = min(\n    ((ior - outsideIor) / (ior + outsideIor)) * ((ior - outsideIor) / (ior + outsideIor)) * specularColor,\n    vec3f(1.0)\n    ) * specular;\n  let dielectricSpecularF90 = vec3f(specular);\n  let F0 = mix(dielectricSpecularF0, baseColor.rgb, metallic);\n  let F90 = mix(dielectricSpecularF90, vec3f(1.0), metallic);\n\n// Iridescence\n#ifdef RN_USE_IRIDESCENCE\n  let iridescenceFactor: f32 = get_iridescenceFactor(materialSID, 0);\n  let iridescenceTexture: f32 = textureSample(iridescenceTexture, iridescenceSampler, baseColorTexUv).r;\n  let iridescence: f32 = iridescenceFactor * iridescenceTexture;\n  let iridescenceIor: f32 = get_iridescenceIor(materialSID, 0);\n  let thicknessRatio: f32 = textureSample(iridescenceThicknessTexture, iridescenceThicknessSampler, baseColorTexUv).r;\n  let iridescenceThicknessMinimum: f32 = get_iridescenceThicknessMinimum(materialSID, 0);\n  let iridescenceThicknessMaximum: f32 = get_iridescenceThicknessMaximum(materialSID, 0);\n  let iridescenceThickness: f32 = mix(iridescenceThicknessMinimum, iridescenceThicknessMaximum, thicknessRatio);\n  let iridescenceFresnel: vec3f = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, F0);\n  let iridescenceF0: vec3f = Schlick_to_F0(iridescenceFresnel, NdotV);\n#else\n  let iridescence = 0.0;\n  let iridescenceFresnel = vec3f(0.0);\n  let iridescenceF0: vec3f = F0;\n#endif // RN_USE_IRIDESCENCE\n\n// Clearcoat\n#ifdef RN_USE_CLEARCOAT\n  let clearcoatRoughnessFactor = get_clearCoatRoughnessFactor(materialSID, 0);\n  let clearCoatRoughnessTexcoordIndex = get_clearCoatRoughnessTexcoordIndex(materialSID, 0);\n  let clearCoatRoughnessTexcoord = getTexcoord(clearCoatRoughnessTexcoordIndex, input);\n  let clearcoatRoughnessTextureTransform = get_clearCoatRoughnessTextureTransform(materialSID, 0);\n  let clearcoatRoughnessTextureRotation = get_clearCoatRoughnessTextureRotation(materialSID, 0);\n  let clearcoatRoughnessTexUv = uvTransform(clearcoatRoughnessTextureTransform.xy, clearcoatRoughnessTextureTransform.zw, clearcoatRoughnessTextureRotation, clearCoatRoughnessTexcoord);\n  let textureRoughnessTexture = textureSample(clearCoatRoughnessTexture, clearCoatRoughnessSampler, clearcoatRoughnessTexUv).g;\n  let clearcoatRoughness = clearcoatRoughnessFactor * textureRoughnessTexture;\n\n  let clearCoatNormalTexcoordIndex = get_clearCoatNormalTexcoordIndex(materialSID, 0);\n  let clearCoatNormalTexcoord = getTexcoord(clearCoatNormalTexcoordIndex, input);\n  let clearcoatNormalTextureTransform = get_clearCoatNormalTextureTransform(materialSID, 0);\n  let clearcoatNormalTextureRotation = get_clearCoatNormalTextureRotation(materialSID, 0);\n  let clearcoatNormalTexUv = uvTransform(clearcoatNormalTextureTransform.xy, clearcoatNormalTextureTransform.zw, clearcoatNormalTextureRotation, clearCoatNormalTexcoord);\n  let textureNormal_tangent = textureSample(clearCoatNormalTexture, clearCoatNormalSampler, clearcoatNormalTexUv).xyz * vec3(2.0) - vec3(1.0);\n  let clearcoatNormal_inWorld = normalize(TBN * textureNormal_tangent);\n  let VdotNc = saturateEpsilonToOne(dot(viewDirection, clearcoatNormal_inWorld));\n#else\n  let clearcoatRoughness = 0.0;\n  let clearcoatNormal_inWorld = vec3f(0.0);\n  let VdotNc = 0.0;\n#endif // RN_USE_CLEARCOAT\n\n\n#ifdef RN_USE_VOLUME\n  // Volume\n  let thicknessFactor: f32 = get_thicknessFactor(materialSID, 0);\n  let thicknessTexture: f32 = textureSample(thicknessTexture, thicknessSampler, baseColorTexUv).g;\n  let attenuationDistance: f32 = get_attenuationDistance(materialSID, 0);\n  let attenuationColor: vec3f = get_attenuationColor(materialSID, 0);\n  let thickness: f32 = thicknessFactor * thicknessTexture;\n#else\n  let thickness = 0.0;\n  let attenuationColor = vec3f(0.0);\n  let attenuationDistance = 0.000001;\n#endif // RN_USE_VOLUME\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  let sheenColorFactor: vec3f = get_sheenColorFactor(materialSID, 0);\n  let sheenColorTexture: vec3f = textureSample(sheenColorTexture, sheenColorSampler, baseColorTexUv).rgb;\n  let sheenRoughnessFactor: f32 = get_sheenRoughnessFactor(materialSID, 0);\n  let sheenRoughnessTexture: f32 = textureSample(sheenRoughnessTexture, sheenRoughnessSampler, baseColorTexUv).a;\n  let sheenColor: vec3f = sheenColorFactor * sheenColorTexture;\n  let sheenRoughness: f32 = clamp(sheenRoughnessFactor * sheenRoughnessTexture, 0.000001, 1.0);\n  let albedoSheenScalingNdotV: f32 = 1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotV, sheenRoughness)).r;\n#else\n  let sheenColor = vec3f(0.0);\n  let sheenRoughness = 0.000001;\n  let albedoSheenScalingNdotV = 1.0;\n#endif // RN_USE_SHEEN\n\n  var resultColor = vec3<f32>(0, 0, 0);\n  var resultAlpha = baseColor.a;\n\n  // Lighting\n  let lightNumber = u32(get_lightNumber(0u, 0u));\n  for (var i = 0u; i < lightNumber; i++) {\n    let light: Light = getLight(i, input.position_inWorld);\n    resultColor += lightingWithPunctualLight(light, normal_inWorld, viewDirection,\n                            NdotV, albedo, perceptualRoughness, F0, F90,\n                            transmission, ior,\n                            clearcoat, clearcoatRoughness, clearcoatNormal_inWorld, VdotNc,\n                            attenuationColor, attenuationDistance,\n                            anisotropy, anisotropicT, anisotropicB, BdotV, TdotV,\n                            sheenColor, sheenRoughness, albedoSheenScalingNdotV,\n                            iridescence, iridescenceFresnel, specular\n                            );\n  }\n\n  let ibl: vec3f = IBLContribution(materialSID, cameraSID, normal_inWorld, NdotV, viewDirection,\n    albedo, F0, perceptualRoughness,\n    clearcoatRoughness, clearcoatNormal_inWorld, clearcoat, VdotNc, geomNormal_inWorld,\n    transmission, input.position_inWorld.xyz, u32(input.instanceInfo), thickness, ior,\n    sheenColor, sheenRoughness, albedoSheenScalingNdotV,\n    iridescenceFresnel, iridescenceF0, iridescence,\n    anisotropy, anisotropicB, specular\n  );\n\n  let occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);\n  let occlusionTexcoord = getTexcoord(occlusionTexcoordIndex, input);\n  let occlusionTextureTransform = get_occlusionTextureTransform(materialSID, 0);\n  let occlusionTextureRotation = get_occlusionTextureRotation(materialSID, 0);\n  let occlusionTexUv = uvTransform(occlusionTextureTransform.xy, occlusionTextureTransform.zw, occlusionTextureRotation, occlusionTexcoord);\n  let occlusion = textureSample(occlusionTexture, occlusionSampler, occlusionTexUv).r;\n  let occlusionStrength = get_occlusionStrength(materialSID, 0);\n\n  // Occlution to Indirect Lights\n  resultColor += mix(ibl, ibl * occlusion, occlusionStrength);\n#else\n  var resultColor = baseColor.rgb;\n  var resultAlpha = baseColor.a;\n#endif // RN_IS_LIGHTING\n\n  // Emissive\n  let emissiveFactor = get_emissiveFactor(materialSID, 0);\n  let emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);\n  let emissiveTexcoord = getTexcoord(emissiveTexcoordIndex, input);\n  let emissiveTextureTransform = get_emissiveTextureTransform(materialSID, 0);\n  let emissiveTextureRotation = get_emissiveTextureRotation(materialSID, 0);\n  let emissiveTexUv = uvTransform(emissiveTextureTransform.xy, emissiveTextureTransform.zw, emissiveTextureRotation, emissiveTexcoord);\n  let emissiveStrength = get_emissiveStrength(materialSID, 0);\n  let emissive = emissiveFactor * srgbToLinear(textureSample(emissiveTexture, emissiveSampler, emissiveTexUv).xyz) * emissiveStrength;\n\n#ifdef RN_USE_CLEARCOAT\n  let coated_emissive = emissive * mix(vec3f(1.0), vec3f(0.04 + (1.0 - 0.04) * pow(1.0 - NdotV, 5.0)), clearcoat);\n  resultColor += coated_emissive;\n#else\n  resultColor += emissive;\n#endif // RN_USE_CLEARCOAT\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  resultAlpha = 1.0;\n#endif\n\nlet makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);\nresultColor = select(resultColor.rgb, linearToSrgb(resultColor.rgb), makeOutputSrgb);\n\n  return vec4f(resultColor * resultAlpha, resultAlpha);\n}\n",shaderStage:"fragment",isFragmentShader:!0},C={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n#ifdef WEBGL2_MULTI_VIEW\n  layout(num_views=2) in;\n#endif\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\n\nout vec2 v_texcoord_0;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec3 v_position_inWorld;\n\nuniform bool u_enableViewMatrix; // initialValue=true\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  if (get_enableViewMatrix(materialSID, 0)) {\n    mat4 rotateMatrix = viewMatrix;\n    rotateMatrix[3][0] = 0.0;\n    rotateMatrix[3][1] = 0.0;\n    rotateMatrix[3][2] = 0.0;\n    gl_Position = projectionMatrix * rotateMatrix * worldMatrix * vec4(a_position, 1.0);\n  } else {\n    gl_Position = projectionMatrix * worldMatrix * vec4(a_position, 1.0);\n  }\n\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  v_normal_inWorld = normalMatrix * a_normal;\n\n  v_color = a_color;\n  v_position_inWorld = (worldMatrix * vec4(a_position, 1.0)).xyz;\n  v_texcoord_0 = a_texcoord_0;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},R={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec3 v_position_inWorld;\n\nuniform int u_envHdriFormat; // initialValue=0\nuniform float u_envRotation; // initialValue=0\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform samplerCube u_colorEnvTexture; // initialValue=(0,black)\nuniform bool u_makeOutputSrgb; // initialValue=true\nuniform bool u_inverseEnvironment; // initialValue=false\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\nvoid main() {\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // diffuseColor\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture\n\n  // adapt OpenGL (RenderMan) CubeMap convention\n  float envRotation = get_envRotation(materialSID, 0);\n  float rot = envRotation;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  vec3 envNormal = normalize(rotEnvMatrix * v_position_inWorld);\n\n  if (get_inverseEnvironment(materialSID, 0)) {\n    envNormal.x *= -1.0;\n  }\n\n  vec4 diffuseTexel = texture(u_colorEnvTexture, envNormal);\n  vec3 textureColor;\n  int EnvHdriFormat = get_envHdriFormat(materialSID, 0);\n  if (EnvHdriFormat == 0) { // LDR_SRGB\n    textureColor = srgbToLinear(diffuseTexel.rgb);\n  } else if (EnvHdriFormat == 3) { // RGBE\n    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  } else {\n    textureColor = diffuseTexel.rgb;\n  }\n  diffuseColor *= textureColor;\n\n  rt0 = vec4(diffuseColor, alpha);\n\nfloat makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));\nrt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);\n\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},P={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n// #param enableViewMatrix: bool; // initialValue=true\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n\n  let worldMatrix = get_worldMatrix(u32(instance_ids.x));\n  let viewMatrix = get_viewMatrix(cameraSID, 0u);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);\n\n  if (get_enableViewMatrix(materialSID, 0u)) {\n    var rotateMatrix = viewMatrix;\n    rotateMatrix[3][0] = 0.0;\n    rotateMatrix[3][1] = 0.0;\n    rotateMatrix[3][2] = 0.0;\n    output.position = projectionMatrix * rotateMatrix * worldMatrix * vec4f(position, 1.0);\n  } else {\n    output.position = projectionMatrix * worldMatrix * vec4f(position, 1.0);\n  }\n\n  let normalMatrix = get_normalMatrix(u32(instance_ids.x));\n  output.normal_inWorld = normalMatrix * normal;\n\n#ifdef RN_USE_COLOR_0\n  output.color_0 = color_0;\n#endif\n  output.position_inWorld = (worldMatrix * vec4f(position, 1.0)).xyz;\n  output.texcoord_0 = texcoord_0;\n\n  return output;\n}\n",shaderStage:"vertex",isFragmentShader:!1},N={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n// #param envHdriFormat: i32; // initialValue=0\n// #param envRotation: f32; // initialValue=0\n// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n@group(1) @binding(0) var colorEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(0) var colorEnvSampler: sampler;\n// #param makeOutputSrgb: bool; // initialValue=1\n// #param inverseEnvironment: bool; // initialValue=false\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\n\n@fragment\nfn main(\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var diffuseColor = vec4<f32>(1, 1, 1, 1);\n#ifdef RN_USE_COLOR_0\n  diffuseColor = input.color_0;\n#endif\n  let diffuseColorFactor = get_diffuseColorFactor(materialSID, 0u);\n  diffuseColor *= diffuseColorFactor;\n\n  let envRotation: f32 = get_envRotation(materialSID, 0u);\n  let rot = envRotation;\n  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  var envNormal: vec3f = normalize(rotEnvMatrix * input.position_inWorld);\n\n  if (get_inverseEnvironment(materialSID, 0)) {\n    envNormal.x *= -1.0;\n  }\n\n  let diffuseTexel = textureSampleLevel(colorEnvTexture, colorEnvSampler, envNormal, 0.0);\n  var textureColor: vec3f;\n  let EnvHdriFormat: i32 = get_envHdriFormat(materialSID, 0);\n  if (EnvHdriFormat == 0) { // LDR_SRGB\n    textureColor = srgbToLinear(diffuseTexel.rgb);\n  } else if (EnvHdriFormat == 3) { // RGBE\n    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  } else {\n    textureColor = diffuseTexel.rgb;\n  }\n  diffuseColor *= vec4f(textureColor, 1.0);\n\n  var resultColor = diffuseColor.rgb;\n  let resultAlpha = diffuseColor.a;\n\nlet makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);\nresultColor = select(resultColor.rgb, linearToSrgb(resultColor.rgb), makeOutputSrgb);\n\n\n  return vec4f(resultColor, resultAlpha);\n}\n",shaderStage:"fragment",isFragmentShader:!0},M={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},D={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/**\n * This file contains source code provided by NVIDIA Corporation.\n * FXAA antialiasing is developed by NVIDIA.\n * The codes of this file is modified from original code to work on WebGL1.\n * The modification for GLSL 100 is referred from Three.js, https://github.com/mrdoob/three.js/blob/5ba4c25bcb74577e1b1e14906f345135610a94f3/examples/js/shaders/FXAAShader.js\n * The original FXAA code is https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/80e8ba8f5e8935821513207033490735dd3279d8/samples/es3-kepler/FXAA/FXAA3_11.h\n */\n\n//----------------------------------------------------------------------------------\n// File:        es3-kepler\\FXAA/FXAA3_11.h\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n/*============================================================================\n                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES\n============================================================================*/\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\n\n\n  #define FXAA_PC 1\n  #define FXAA_QUALITYPRESET 39\n  #define FXAA_GREEN_AS_LUMA 0\n  #define FXAA_GLSL_100 1\n\n  /*============================================================================\n                                INTEGRATION KNOBS\n  ============================================================================*/\n  //\n  // FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).\n  // FXAA_360_OPT is a prototype for the new optimized 360 version.\n  //\n  // 1 = Use API.\n  // 0 = Don't use API.\n  //\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PS3\n  #define FXAA_PS3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_360\n  #define FXAA_360 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_360_OPT\n  #define FXAA_360_OPT 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_PC\n  //\n  // FXAA Quality\n  // The high quality PC algorithm.\n  //\n  #define FXAA_PC 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n  //\n  // The console algorithm for PC is included\n  // for developers targeting really low spec machines.\n  // Likely better to just run FXAA_PC, and use a really low preset.\n  //\n  #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n  #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n  #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n  #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n  #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n  #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n  //\n  // For those using non-linear color,\n  // and either not able to get luma in alpha, or not wanting to,\n  // this enables FXAA to run using green as a proxy for luma.\n  // So with this enabled, no need to pack luma in alpha.\n  //\n  // This will turn off AA on anything which lacks some amount of green.\n  // Pure red and blue or combination of only R and B, will get no AA.\n  //\n  // Might want to lower the settings for both,\n  //    fxaaConsoleEdgeThresholdMin\n  //    fxaaQualityEdgeThresholdMin\n  // In order to insure AA does not get turned off on colors\n  // which contain a minor amount of green.\n  //\n  // 1 = On.\n  // 0 = Off.\n  //\n  #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n  //\n  // Controls algorithm's early exit path.\n  // On PS3 turning this ON adds 2 cycles to the shader.\n  // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n  // Turning this off on console will result in a more blurry image.\n  // So this defaults to on.\n  //\n  // 1 = On.\n  // 0 = Off.\n  //\n  #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n  //\n  // Only valid for PC OpenGL currently.\n  // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n  //\n  // 1 = Use discard on pixels which don't need AA.\n  //     For APIs which enable concurrent TEX+ROP from same surface.\n  // 0 = Return unchanged color on pixels which don't need AA.\n  //\n  #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n  //\n  // Used for GLSL 120 only.\n  //\n  // 1 = GL API supports fast pixel offsets\n  // 0 = do not use fast pixel offsets\n  //\n  #ifdef GLEXT_gpu_shader4\n  #define FXAA_FAST_PIXEL_OFFSET 1\n  #endif\n  #ifdef GLNV_gpu_shader5\n  #define FXAA_FAST_PIXEL_OFFSET 1\n  #endif\n  #ifdef GLARB_gpu_shader5\n  #define FXAA_FAST_PIXEL_OFFSET 1\n  #endif\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n  #define FXAA_FAST_PIXEL_OFFSET 0\n  #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n  //\n  // 1 = API supports gather4 on alpha channel.\n  // 0 = API does not support gather4 on alpha channel.\n  //\n  #if (FXAA_HLSL_5 == 1)\n  #define FXAA_GATHER4_ALPHA 1\n  #endif\n  #ifdef GLARB_gpu_shader5\n  #define FXAA_GATHER4_ALPHA 1\n  #endif\n  #ifdef GLNV_gpu_shader5\n  #define FXAA_GATHER4_ALPHA 1\n  #endif\n  #ifndef FXAA_GATHER4_ALPHA\n  #define FXAA_GATHER4_ALPHA 0\n  #endif\n  #endif\n\n  /*============================================================================\n                        FXAA CONSOLE PS3 - TUNING KNOBS\n  ============================================================================*/\n  #ifndef FXAA_CONSOLEPS3_EDGE_SHARPNESS\n  //\n  // Consoles the sharpness of edges on PS3 only.\n  // Non-PS3 tuning is done with shader input.\n  //\n  // Due to the PS3 being ALU bound,\n  // there are only two safe values here: 4 and 8.\n  // These options use the shaders ability to a free *|/ by 2|4|8.\n  //\n  // 8.0 is sharper\n  // 4.0 is softer\n  // 2.0 is really soft (good for vector graphics inputs)\n  //\n  #if 1\n  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 8.0\n  #endif\n  #if 0\n  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 4.0\n  #endif\n  #if 0\n  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 2.0\n  #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_CONSOLEPS3_EDGE_THRESHOLD\n  //\n  // Only effects PS3.\n  // Non-PS3 tuning is done with shader input.\n  //\n  // The minimum amount of local contrast required to apply algorithm.\n  // The console setting has a different mapping than the quality setting.\n  //\n  // This only applies when FXAA_EARLY_EXIT is 1.\n  //\n  // Due to the PS3 being ALU bound,\n  // there are only two safe values here: 0.25 and 0.125.\n  // These options use the shaders ability to a free *|/ by 2|4|8.\n  //\n  // 0.125 leaves less aliasing, but is softer\n  // 0.25 leaves more aliasing, and is sharper\n  //\n  #if 1\n  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.125\n  #else\n  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.25\n  #endif\n  #endif\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITYPRESET\n  //\n  // Choose the quality preset.\n  // This needs to be compiled into the shader as it effects code.\n  // Best option to include multiple presets is to\n  // in each shader define the preset, then include this file.\n  //\n  // OPTIONS\n  // -----------------------------------------------------------------------\n  // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n  // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n  // 39       - no dither, very expensive\n  //\n  // NOTES\n  // -----------------------------------------------------------------------\n  // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n  // 13 = about same speed as FXAA 3.9 and better than 12\n  // 23 = closest to FXAA 3.9 visually and performance wise\n  //  _ = the lowest digit is directly related to performance\n  // _  = the highest digit is directly related to style\n  //\n  #define FXAA_QUALITYPRESET 12\n  #endif\n\n\n  /*============================================================================\n                             FXAA QUALITY - PRESETS\n  ============================================================================*/\n\n  /*============================================================================\n                       FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if(FXAA_QUALITYPRESET == 10)\n#define FXAA_QUALITYPS 3\n#define FXAA_QUALITYP0 1.5\n#define FXAA_QUALITYP1 3.0\n#define FXAA_QUALITYP2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 11)\n#define FXAA_QUALITYPS 4\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 3.0\n#define FXAA_QUALITYP3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 12)\n#define FXAA_QUALITYPS 5\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 4.0\n#define FXAA_QUALITYP4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 13)\n#define FXAA_QUALITYPS 6\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 4.0\n#define FXAA_QUALITYP5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 14)\n#define FXAA_QUALITYPS 7\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 4.0\n#define FXAA_QUALITYP6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 15)\n#define FXAA_QUALITYPS 8\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 4.0\n#define FXAA_QUALITYP7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITYPRESET == 20)\n#define FXAA_QUALITYPS 3\n#define FXAA_QUALITYP0 1.5\n#define FXAA_QUALITYP1 2.0\n#define FXAA_QUALITYP2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 21)\n#define FXAA_QUALITYPS 4\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 22)\n#define FXAA_QUALITYPS 5\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 23)\n#define FXAA_QUALITYPS 6\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 24)\n#define FXAA_QUALITYPS 7\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 3.0\n#define FXAA_QUALITYP6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 25)\n#define FXAA_QUALITYPS 8\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 4.0\n#define FXAA_QUALITYP7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 26)\n#define FXAA_QUALITYPS 9\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 4.0\n#define FXAA_QUALITYP8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 27)\n#define FXAA_QUALITYPS 10\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 4.0\n#define FXAA_QUALITYP9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 28)\n#define FXAA_QUALITYPS 11\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 2.0\n#define FXAA_QUALITYP9 4.0\n#define FXAA_QUALITYP10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 29)\n#define FXAA_QUALITYPS 12\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 2.0\n#define FXAA_QUALITYP9 2.0\n#define FXAA_QUALITYP10 4.0\n#define FXAA_QUALITYP11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITYPRESET == 39)\n#define FXAA_QUALITYPS 12\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.0\n#define FXAA_QUALITYP2 1.0\n#define FXAA_QUALITYP3 1.0\n#define FXAA_QUALITYP4 1.0\n#define FXAA_QUALITYP5 1.5\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 2.0\n#define FXAA_QUALITYP9 2.0\n#define FXAA_QUALITYP10 4.0\n#define FXAA_QUALITYP11 8.0\n#endif\n\n\n\n/*============================================================================\n                                API PORTING\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n#define FxaaBool bool\n#define FxaaDiscard discard\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 ivec2\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTex sampler2D\n#else\n#define FxaaBool bool\n#define FxaaDiscard clip(-1)\n#define FxaaFloat float\n#define FxaaFloat2 float2\n#define FxaaFloat3 float3\n#define FxaaFloat4 float4\n#define FxaaHalf half\n#define FxaaHalf2 half2\n#define FxaaHalf3 half3\n#define FxaaHalf4 half4\n#define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n#define FxaaTexTop(t, p) texture(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n// Requires,\n//  #version 120\n// And at least,\n//  #extension GLEXT_gpu_shader4 : enable\n//  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n#if (FXAA_FAST_PIXEL_OFFSET == 1)\n#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#else\n#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GATHER4_ALPHA == 1)\n// use #extension GLARB_gpu_shader5 : enable\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n// Requires \"#version 130\" or better\n#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n#if (FXAA_GATHER4_ALPHA == 1)\n// use #extension GLARB_gpu_shader5 : enable\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.298912, 0.586611, 0.114478)); }\n  // FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n\n\n\n\n\n/*============================================================================\n                             FXAA3 QUALITY - PC\n============================================================================*/\n#if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = upper left of pixel\n    // {zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {_a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for \"tex\".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for \"tex\".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x_} = -N/screenWidthInPixels\n    // {_y} = -N/screenHeightInPixels\n    // {z_} =  N/screenWidthInPixels\n    // {_w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x_} = -2.0/screenWidthInPixels\n    // {_y} = -2.0/screenHeightInPixels\n    // {z_} =  2.0/screenWidthInPixels\n    // {_w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x_} =  8.0/screenWidthInPixels\n    // {_y} =  8.0/screenHeightInPixels\n    // {z_} = -4.0/screenWidthInPixels\n    // {_w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITYSUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITYEDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITYEDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLEEDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLEPS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLEPS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immedates.\n    // Immedates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat2 posM;\n  posM.x = pos.x;\n  posM.y = pos.y;\n  #if (FXAA_GATHER4_ALPHA == 1)\n  #if (FXAA_DISCARD == 0)\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n  #if (FXAA_GREEN_AS_LUMA == 0)\n  #define lumaM rgbyM.w\n  #else\n  #define lumaM rgbyM.y\n  #endif\n  #endif\n  #if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n  FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n  #else\n  FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n  FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n  #endif\n  #if (FXAA_DISCARD == 1)\n  #define lumaM luma4A.w\n  #endif\n  #define lumaE luma4A.z\n  #define lumaS luma4A.x\n  #define lumaSE luma4A.y\n  #define lumaNW luma4B.w\n  #define lumaN luma4B.z\n  #define lumaW luma4B.x\n  #else\n  FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n  #if (FXAA_GREEN_AS_LUMA == 0)\n  #define lumaM rgbyM.w\n  #else\n  #define lumaM rgbyM.y\n  #endif\n  #if (FXAA_GLSL_100 == 1)\n    FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, -1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n  #else\n  FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, -1), fxaaQualityRcpFrame.xy));\n  #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat maxSM = max(lumaS, lumaM);\n  FxaaFloat minSM = min(lumaS, lumaM);\n  FxaaFloat maxESM = max(lumaE, maxSM);\n  FxaaFloat minESM = min(lumaE, minSM);\n  FxaaFloat maxWN = max(lumaN, lumaW);\n  FxaaFloat minWN = min(lumaN, lumaW);\n  FxaaFloat rangeMax = max(maxWN, maxESM);\n  FxaaFloat rangeMin = min(minWN, minESM);\n  FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n  FxaaFloat range = rangeMax - rangeMin;\n  FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n  FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n  if (earlyExit)\n  #if (FXAA_DISCARD == 1)\n    FxaaDiscard;\n  #else\n  return rgbyM;\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GATHER4_ALPHA == 0)\n  #if (FXAA_GLSL_100 == 1)\n    FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, -1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, -1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n  #else\n  FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, -1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n  #endif\n  #else\n  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n  #endif\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat lumaNS = lumaN + lumaS;\n  FxaaFloat lumaWE = lumaW + lumaE;\n  FxaaFloat subpixRcpRange = 1.0 / range;\n  FxaaFloat subpixNSWE = lumaNS + lumaWE;\n  FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n  FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat lumaNESE = lumaNE + lumaSE;\n  FxaaFloat lumaNWNE = lumaNW + lumaNE;\n  FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n  FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat lumaNWSW = lumaNW + lumaSW;\n  FxaaFloat lumaSWSE = lumaSW + lumaSE;\n  FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n  FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n  FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n  FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n  FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n  FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n  FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n  FxaaBool horzSpan = edgeHorz >= edgeVert;\n  FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n  if (!horzSpan) lumaN = lumaW;\n  if (!horzSpan) lumaS = lumaE;\n  if (horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n  FxaaFloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat gradientN = lumaN - lumaM;\n  FxaaFloat gradientS = lumaS - lumaM;\n  FxaaFloat lumaNN = lumaN + lumaM;\n  FxaaFloat lumaSS = lumaS + lumaM;\n  FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n  FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n  if (pairN) lengthSign = -lengthSign;\n  FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat2 posB;\n  posB.x = posM.x;\n  posB.y = posM.y;\n  FxaaFloat2 offNP;\n  offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n  offNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n  if (!horzSpan) posB.x += lengthSign * 0.5;\n  if (horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat2 posN;\n  posN.x = posB.x - offNP.x * FXAA_QUALITYP0;\n  posN.y = posB.y - offNP.y * FXAA_QUALITYP0;\n  FxaaFloat2 posP;\n  posP.x = posB.x + offNP.x * FXAA_QUALITYP0;\n  posP.y = posB.y + offNP.y * FXAA_QUALITYP0;\n  FxaaFloat subpixD = ((-2.0) * subpixC) + 3.0;\n  FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n  FxaaFloat subpixE = subpixC * subpixC;\n  FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n  if (!pairN) lumaNN = lumaSS;\n  FxaaFloat gradientScaled = gradient * 1.0 / 4.0;\n  FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n  FxaaFloat subpixF = subpixD * subpixE;\n  FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n  lumaEndN -= lumaNN * 0.5;\n  lumaEndP -= lumaNN * 0.5;\n  FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n  FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n  if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP1;\n  if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP1;\n  FxaaBool doneNP = (!doneN) || (!doneP);\n  if (!doneP) posP.x += offNP.x * FXAA_QUALITYP1;\n  if (!doneP) posP.y += offNP.y * FXAA_QUALITYP1;\n  /*--------------------------------------------------------------------------*/\n  if (doneNP) {\n    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n    doneN = abs(lumaEndN) >= gradientScaled;\n    doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP2;\n    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP2;\n    doneNP = (!doneN) || (!doneP);\n    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP2;\n    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP2;\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITYPS > 3)\n      if (doneNP) {\n        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP3;\n        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP3;\n        doneNP = (!doneN) || (!doneP);\n        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP3;\n        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP3;\n        /*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITYPS > 4)\n          if (doneNP) {\n            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP4;\n            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP4;\n            doneNP = (!doneN) || (!doneP);\n            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP4;\n            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP4;\n            /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITYPS > 5)\n              if (doneNP) {\n                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP5;\n                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP5;\n                doneNP = (!doneN) || (!doneP);\n                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP5;\n                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP5;\n                /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITYPS > 6)\n                  if (doneNP) {\n                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP6;\n                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP6;\n                    doneNP = (!doneN) || (!doneP);\n                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP6;\n                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP6;\n                    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITYPS > 7)\n                      if (doneNP) {\n                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP7;\n                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP7;\n                        doneNP = (!doneN) || (!doneP);\n                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP7;\n                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP7;\n                        /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITYPS > 8)\n                          if (doneNP) {\n                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP8;\n                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP8;\n                            doneNP = (!doneN) || (!doneP);\n                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP8;\n                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP8;\n                            /*--------------------------------------------------------------------------*/\n                            #if (FXAA_QUALITYPS > 9)\n                              if (doneNP) {\n                                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                doneN = abs(lumaEndN) >= gradientScaled;\n                                doneP = abs(lumaEndP) >= gradientScaled;\n                                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP9;\n                                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP9;\n                                doneNP = (!doneN) || (!doneP);\n                                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP9;\n                                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP9;\n                                /*--------------------------------------------------------------------------*/\n                                #if (FXAA_QUALITYPS > 10)\n                                  if (doneNP) {\n                                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                    doneN = abs(lumaEndN) >= gradientScaled;\n                                    doneP = abs(lumaEndP) >= gradientScaled;\n                                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP10;\n                                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP10;\n                                    doneNP = (!doneN) || (!doneP);\n                                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP10;\n                                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP10;\n                                    /*--------------------------------------------------------------------------*/\n                                    #if (FXAA_QUALITYPS > 11)\n                                      if (doneNP) {\n                                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                        doneN = abs(lumaEndN) >= gradientScaled;\n                                        doneP = abs(lumaEndP) >= gradientScaled;\n                                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP11;\n                                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP11;\n                                        doneNP = (!doneN) || (!doneP);\n                                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP11;\n                                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP11;\n                                        /*--------------------------------------------------------------------------*/\n                                        #if (FXAA_QUALITYPS > 12)\n                                          if (doneNP) {\n                                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                            doneN = abs(lumaEndN) >= gradientScaled;\n                                            doneP = abs(lumaEndP) >= gradientScaled;\n                                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP12;\n                                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP12;\n                                            doneNP = (!doneN) || (!doneP);\n                                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP12;\n                                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP12;\n                                            /*--------------------------------------------------------------------------*/\n                                          }\n                                        #endif\n                                        /*--------------------------------------------------------------------------*/\n                                      }\n                                    #endif\n                                    /*--------------------------------------------------------------------------*/\n                                  }\n                                #endif\n                                /*--------------------------------------------------------------------------*/\n                              }\n                            #endif\n                            /*--------------------------------------------------------------------------*/\n                          }\n                        #endif\n                        /*--------------------------------------------------------------------------*/\n                      }\n                    #endif\n                    /*--------------------------------------------------------------------------*/\n                  }\n                #endif\n                /*--------------------------------------------------------------------------*/\n              }\n            #endif\n            /*--------------------------------------------------------------------------*/\n          }\n        #endif\n        /*--------------------------------------------------------------------------*/\n      }\n    #endif\n    /*--------------------------------------------------------------------------*/\n  }\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat dstN = posM.x - posN.x;\n  FxaaFloat dstP = posP.x - posM.x;\n  if (!horzSpan) dstN = posM.y - posN.y;\n  if (!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n  FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n  FxaaFloat spanLength = (dstP + dstN);\n  FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n  FxaaFloat spanLengthRcp = 1.0 / spanLength;\n  /*--------------------------------------------------------------------------*/\n  FxaaBool directionN = dstN < dstP;\n  FxaaFloat dst = min(dstN, dstP);\n  FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n  FxaaFloat subpixG = subpixF * subpixF;\n  FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n  FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n  FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n  if (!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n  if (horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n  #if (FXAA_DISCARD == 1)\n    return FxaaTexTop(tex, posM);\n  #else\n  return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n  #endif\n}\n/*==========================================================================*/\n#endif\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 screenInfo = vec2(textureSize(u_baseColorTexture, 0));\n  rt0 = FxaaPixelShader(\n      v_texcoord_0,\n      vec4(0.0),\n      u_baseColorTexture,\n      u_baseColorTexture,\n      u_baseColorTexture,\n      1.0 / screenInfo,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n  );\n  rt0.a = 1.0;\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},F={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},B={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform bool u_enableLinearToSrgb; // initialValue=true\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nvec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);\n\nif (get_enableLinearToSrgb(materialSID, 0)) {\n  baseColor.rgb = linearToSrgb(baseColor.rgb);\n}\n\nrt0 = baseColor;\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},L={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},V={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n// #param enableLinearToSrgb: bool; // initialValue=true\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var baseColor = textureSampleLevel(baseColorTexture, baseColorSampler, input.texcoord_0, 0.0);\n\n  if (get_enableLinearToSrgb(materialSID, 0)) {\n    baseColor = vec4f(linearToSrgb(baseColor.rgb), baseColor.a);\n  }\n\n  return baseColor;\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},z={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},G={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform bool u_enableLinearToSrgb; // initialValue=true\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\n\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\n// Input color is non-negative and resides in the Linear Rec. 709 color space.\n// Output color is also Linear Rec. 709, but in the [0, 1] range.\n// See: https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral\nvec3 PBRNeutralToneMapping( vec3 color ) {\n  const float startCompression = 0.8 - 0.04;\n  const float desaturation = 0.15;\n\n  float x = min(color.r, min(color.g, color.b));\n  float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n  color -= offset;\n\n  float peak = max(color.r, max(color.g, color.b));\n  if (peak < startCompression) return color;\n\n  const float d = 1. - startCompression;\n  float newPeak = 1. - d * d / (peak + d - startCompression);\n  color *= newPeak / peak;\n\n  float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n  return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n#endif\n\n#ifdef RN_USE_REINHARD\nvec3 ReinhardToneMapping( vec3 color ) {\n  return color / (vec3(1.0) + color);\n}\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\n// ACES tone map (faster approximation)\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACES_Narkowicz_ToneMapping(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0);\n}\n#endif\n\n#if defined(RN_USE_ACES_HILL) || defined(RN_USE_ACES_HILL_EXPOSURE_BOOST)\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n  0.59719, 0.07600, 0.02840,\n  0.35458, 0.90834, 0.13383,\n  0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n  1.60475, -0.10208, -0.00327,\n  -0.53108,  1.10813, -0.07276,\n  -0.07367, -0.00605,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n  vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n  vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n  return a / b;\n}\n\nvec3 ACES_Hill_ToneMapping(vec3 color)\n{\n  color = ACESInputMat * color;\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n\n  color = ACESOutputMat * color;\n\n  // Clamp to [0, 1]\n  color = clamp(color, 0.0, 1.0);\n\n  return color;\n}\n#endif\n\n#ifdef RN_USE_GT_TONEMAP\nfloat W_f(float x, float e0, float e1) {\n  if (x <= e0)\n    return 0.;\n  if (x >= e1)\n    return 1.;\n  float a = (x - e0) / (e1 - e0);\n  return a * a * (3. - 2. * a);\n}\nfloat H_f(float x, float e0, float e1) {\n  if (x <= e0)\n    return 0.;\n  if (x >= e1)\n    return 1.;\n  return (x - e0) / (e1 - e0);\n}\n\nconst float e = 2.71828;\n\nfloat GT_ToneMaping(float x) {\n  float P = 1.; // peak luminance\n  float a = 1.; // contrast parameter\n  float m = 0.22; // beginning of the linear part\n  float l = 0.4; // length of the linear part\n  float c = 1.33; // parameter of black color\n  float b = 0.; // parameter of black color\n  float l0 = (P - m) * l / a;\n  float T_x = m * pow(x / m, c) + b;\n  float L_x = m + a * (x - m);\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = a * P / (P - S1);\n  float S_x = P - (P - S1) * pow(e, -(C2 * (x - S0) / P));\n  float w0_x = 1. - W_f(x, 0., m);\n  float w2_x = H_f(x, m + l0, m + l0);\n  float w1_x = 1. - w0_x - w2_x;\n  float f_x = T_x * w0_x + L_x * w1_x + S_x * w2_x;\n  return f_x;\n}\n#endif\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nvec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);\n\n// Apply Tone Mapping\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\nbaseColor.rgb = PBRNeutralToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_REINHARD\nbaseColor.rgb = ReinhardToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\nbaseColor.rgb = ACES_Narkowicz_ToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_ACES_HILL\nbaseColor.rgb = ACES_Hill_ToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_ACES_HILL_EXPOSURE_BOOST\nbaseColor.rgb /= 0.6;\nbaseColor.rgb = ACES_Hill_ToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_GT_TONEMAP\nbaseColor.r = GT_ToneMaping(baseColor.r);\nbaseColor.g = GT_ToneMaping(baseColor.g);\nbaseColor.b = GT_ToneMaping(baseColor.b);\n#endif\n\n\n// Convert linear color to sRGB color space.\nif (get_enableLinearToSrgb(materialSID, 0)) {\n  baseColor.rgb = linearToSrgb(baseColor.rgb);\n}\n\nrt0 = baseColor;\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},O={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},U={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n// #param enableLinearToSrgb: bool; // initialValue=true\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\n\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\n// Input color is non-negative and resides in the Linear Rec. 709 color space.\n// Output color is also Linear Rec. 709, but in the [0, 1] range.\n// See: https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral\nfn PBRNeutralToneMapping( inColor: vec3f ) -> vec3f {\n  let startCompression = 0.8 - 0.04;\n  let desaturation = 0.15;\n\n  let x = min(inColor.r, min(inColor.g, inColor.b));\n  let offset = select(0.04, x - 6.25 * x * x, x < 0.08);\n  var color = inColor - offset;\n\n  let peak = max(color.r, max(color.g, color.b));\n  if (peak < startCompression) {\n    return color;\n  }\n\n  let d = 1.0 - startCompression;\n  let newPeak = 1.0 - d * d / (peak + d - startCompression);\n  color *= newPeak / peak;\n\n  let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);\n  return mix(color, newPeak * vec3f(1.0, 1.0, 1.0), g);\n}\n#endif\n\n#ifdef RN_USE_REINHARD\nfn ReinhardToneMapping(color: vec3<f32> ) -> vec3<f32> {\n  return color / (vec3<f32>(1.0) + color);\n}\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\n// ACES tone map (faster approximation)\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nfn ACES_Narkowicz_ToneMapping(color: vec3<f32>) -> vec3<f32>\n{\n    const A = 2.51;\n    const B = 0.03;\n    const C = 2.43;\n    const D = 0.59;\n    const E = 0.14;\n    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), vec3<f32>(0.0), vec3<f32>(1.0));\n}\n#endif\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst ACESInputMat = mat3x3<f32>\n(\n  0.59719, 0.07600, 0.02840,\n  0.35458, 0.90834, 0.13383,\n  0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst ACESOutputMat = mat3x3<f32>\n(\n  1.60475, -0.10208, -0.00327,\n  -0.53108,  1.10813, -0.07276,\n  -0.07367, -0.00605,  1.07602\n);\n\nfn RRTAndODTFit(v: vec3<f32>) -> vec3<f32>\n{\n  let a = v * (v + 0.0245786f) - 0.000090537f;\n  let b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n  return a / b;\n}\n\nfn ACES_Hill_ToneMapping(inColor: vec3<f32>) -> vec3<f32>\n{\n  var color = ACESInputMat * inColor;\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n\n  color = ACESOutputMat * color;\n\n  // Clamp to [0, 1]\n  color = saturate(color);\n\n  return color;\n}\n\n#ifdef RN_USE_GT_TONEMAP\n  fn W_f(x: f32, e0: f32, e1: f32) -> f32 {\n    if (x <= e0) { return 0.; }\n    if (x >= e1) { return 1.; }\n    let a = (x - e0) / (e1 - e0);\n    return a * a * (3. - 2. * a);\n  }\n  fn H_f(x: f32, e0: f32, e1: f32) -> f32 {\n    if (x <= e0) { return 0.; }\n    if (x >= e1) { return 1.; }\n    return (x - e0) / (e1 - e0);\n  }\n\n  const e = 2.71828;\n\n  fn GT_ToneMaping(x: f32) -> f32 {\n    let P = 1.; // peak luminance\n    let a = 1.; // contrast parameter\n    let m = 0.22; // beginning of the linear part\n    let l = 0.4; // length of the linear part\n    let c = 1.33; // parameter of black color\n    let b = 0.; // parameter of black color\n    let l0 = (P - m) * l / a;\n    let T_x = m * pow(x / m, c) + b;\n    let L_x = m + a * (x - m);\n    let S0 = m + l0;\n    let S1 = m + a * l0;\n    let C2 = a * P / (P - S1);\n    let S_x = P - (P - S1) * pow(e, -(C2 * (x - S0) / P));\n    let w0_x = 1. - W_f(x, 0., m);\n    let w2_x = H_f(x, m + l0, m + l0);\n    let w1_x = 1. - w0_x - w2_x;\n    let f_x = T_x * w0_x + L_x * w1_x + S_x * w2_x;\n    return f_x;\n  }\n#endif\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var baseColor = textureSample(baseColorTexture, baseColorSampler, input.texcoord_0);\n\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\n  baseColor = vec4f(PBRNeutralToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_REINHARD\n  baseColor = vec4f(ReinhardToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\n  baseColor = vec4f(ACES_Narkowicz_ToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_ACES_HILL\n  baseColor = vec4f(ACES_Hill_ToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_ACES_HILL_EXPOSURE_BOOST\n  baseColor /= 0.6;\n  baseColor = vec4f(ACES_Hill_ToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n\n#ifdef RN_USE_GT_TONEMAP\n  baseColor.r = GT_ToneMaping(baseColor.r);\n  baseColor.g = GT_ToneMaping(baseColor.g);\n  baseColor.b = GT_ToneMaping(baseColor.b);\n#endif\n\n  if (get_enableLinearToSrgb(materialSID, 0)) {\n    baseColor = vec4f(linearToSrgb(baseColor.rgb), baseColor.a);\n  }\n\n  return baseColor;\n}\n",shaderStage:"fragment",isFragmentShader:!0},k={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nmat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n\nv_texcoord_0 = a_texcoord_0;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},W={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2DRect u_baseColorTexture; // initialValue=(0,white)\nuniform float u_count; // initialValue=0.0\nuniform float u_direction; // initialValue=0.0\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nfloat i = get_count(materialSID, 0);\nfloat dir = get_direction(materialSID, 0);\n\nrt0 = texture(u_baseColorTexture, gl_FragCoord.xy);\n\nif (dir > 0.0) {\n  // horizontal\n  rt0 += texture(u_baseColorTexture, vec2(gl_FragCoord.x + pow(2.0, i), gl_FragCoord.y));\n} else {\n  // virtical\n  rt0 += texture(u_baseColorTexture, vec2(gl_FragCoord.x, gl_FragCoord.y + pow(2.0, i)));\n}\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},Q={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\n\nuniform float u_pointSize; // initialValue=30\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},q={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec3 v_baryCentricCoord;\n\nuniform int u_shadingModel; // initialValue=0\nuniform float u_alphaCutoff; // initialValue=0.01\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)\nuniform sampler2D u_normalTexture; // initialValue=(1,blue)\nuniform vec4 u_diffuseColorTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_diffuseColorTextureRotation; // initialValue=0\n\n/* shaderity: @{renderTargetBegin} */\n\n\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (alpha < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n\n\n  // diffuseColor (Considered to be premultiplied alpha)\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture (Considered to be premultiplied alpha)\n  vec4 diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);\n  float diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);\n  vec2 diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, v_texcoord_0);\n  vec4 textureColor = texture(u_diffuseColorTexture, diffuseColorTexUv);\n  diffuseColor *= textureColor.rgb;\n  alpha *= textureColor.a;\n\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  alpha = 1.0;\n#endif\n\n  rt0 = vec4(diffuseColor * alpha, alpha);\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n\n",shaderStage:"fragment",isFragmentShader:!0},X={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n\n  let worldMatrix = get_worldMatrix(u32(instance_ids.x));\n  let viewMatrix = get_viewMatrix(cameraSID, 0u);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);\n\n  output.position = projectionMatrix * viewMatrix * worldMatrix * vec4<f32>(position, 1.0);\n\n#ifdef RN_USE_NORMAL\n  output.normal_inWorld = normalize((worldMatrix * vec4<f32>(normal, 0.0)).xyz);\n#endif\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n\n  // output.Position = vec4<f32>(position, 1.0);\n\n  return output;\n}\n",shaderStage:"vertex",isFragmentShader:!1},H={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=blue\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n@fragment\nfn main(\n  input: VertexOutput\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var Normal = input.normal_inWorld * 0.5 + 0.5;\n  // return vec4<f32>(Normal.x, Normal.y, Normal.z, 1);\n\n#ifdef RN_USE_TEXCOORD_0\n  var baseColor = textureSample(baseColorTexture, baseColorSampler, input.texcoord_0);\n  return baseColor;\n#else\n  return vec4<f32>(1, 0, 0, 1);\n#endif\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},j={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nuniform float u_pointSize; // initialValue=30, soloDatum=true\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0.0, 0.1, 0.01), soloDatum=true\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n\n",shaderStage:"vertex",isFragmentShader:!1},Y={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\n\nvoid main (){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float depth = gl_FragCoord.z;\n  float dx = dFdx(depth);\n  float dy = dFdy(depth);\n\n  rt0.x = depth; // M1\n  rt0.y = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2\n  rt0.z = 0.0;\n  rt0.w = 1.0;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n\n",shaderStage:"fragment",isFragmentShader:!0},K={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nuniform bool u_frontHemisphere; // initialValue=true\nuniform int u_lightIndex; // initialValue=0\nuniform float u_farPlane; // initialValue=1000.0\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\n    return;\n  }\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  int lightIndex = get_lightIndex(materialSID, 0);\n  vec3 lightPosition = get_lightPosition(0.0, lightIndex);\n  vec3 L = v_position_inWorld.xyz - lightPosition;\n  float dist = length(L);\n  L = normalize(L);\n\n  bool frontHemisphere = get_frontHemisphere(materialSID, 0);\n  float signHemisphere = frontHemisphere ? 1.0 : -1.0;\n  float denom = 1.0 + signHemisphere * L.z;\n\n  vec2 uv = L.xy / denom;\n\n  if (abs(denom) < 1e-6) {\n    gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);\n    return;\n  }\n  // if ((u_frontHemisphere && L.z < 0.0) ||\n  //      (!u_frontHemisphere && L.z > 0.0))\n  // {\n  //   gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);\n  //   return;\n  // }\n\n  float farPlane = get_farPlane(materialSID, 0);\n  gl_Position = vec4(uv, dist / farPlane, 1.0);\n  v_position_inWorld = vec4(uv, dist / farPlane, signHemisphere * L.z);\n}\n",shaderStage:"vertex",isFragmentShader:!1},Z={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nuniform bool u_frontHemisphere; // initialValue=true\n\nvoid main (){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float denom = v_position_inWorld.w;\n  if (denom < 0.0) {\n    discard;\n  }\n\n  float depth = v_position_inWorld.z;\n  float dx = dFdx(depth);\n  float dy = dFdy(depth);\n\n  bool frontHemisphere = get_frontHemisphere(materialSID, 0);\n  if (frontHemisphere) {\n    rt0.r = depth; // M1\n    rt0.g = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2\n    rt0.b = 1.0;\n    rt0.a = 1.0;\n  } else {\n    rt0.r = 1.0;\n    rt0.g = 1.0;\n    rt0.b = depth; // M1\n    rt0.a = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n\n",shaderStage:"fragment",isFragmentShader:!0};var J=n(7488),$=n(9993),ee=n(589);const te={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},ne={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nin vec2 v_texcoord_0;\n\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 offset = gl_FragCoord.st;\n  ivec2 vrState = get_vrState(0.0, 0);\n  vec2 framebufferSize = get_framebufferSize(materialSID, 0);\n  vec2 blurDirection;\n  bool isHorizontal = get_isHorizontal(materialSID, 0);\n  if (isHorizontal) {\n    blurDirection = vec2(1.0, 0.0);\n  } else { // vertical\n    blurDirection = vec2(0.0, 1.0);\n  }\n\tvec2 tFrag = 1.0 / framebufferSize;\n\n  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n  int gaussianKernelSize = get_gaussianKernelSize(materialSID, 0);\n  float minStrideLength = -float(gaussianKernelSize - 1) / 2.0;\n\n  for(int i = 0; i < gaussianKernelSize; i++) {\n    float strideLength = minStrideLength + float(i);\n    vec2 stride = strideLength * blurDirection;\n    float gaussianRatio = get_gaussianRatio(materialSID, i);\n    vec2 uv = (offset + stride) * tFrag;\n    if (vrState.x == 1 && isHorizontal) { // if in VR mode and horizontal blur\n      if (gl_FragCoord.x < framebufferSize.x / 2.0) { // left eye\n        uv.x = min(uv.x, 0.5);\n      } else { // right eye\n        uv.x = max(uv.x, 0.5);\n      }\n    }\n    color.rgb += texture(u_baseColorTexture, uv).rgb * gaussianRatio;\n  }\n\n  rt0 = color;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},oe={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},ae={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@fragment\nfn main(\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let offset = input.position.xy;\n\n  let framebufferSize: vec2f = get_framebufferSize(materialSID, 0);\n  var blurDirection: vec2f;\n  let isHorizontal: bool = get_isHorizontal(materialSID, 0);\n  if (isHorizontal) {\n    blurDirection = vec2f(1.0, 0.0);\n  } else { // vertical\n    blurDirection = vec2f(0.0, 1.0);\n  }\n\tlet tFrag: vec2f = 1.0 / framebufferSize;\n\n  var color = vec4f(0.0, 0.0, 0.0, 1.0);\n  let gaussianKernelSize: i32 = get_gaussianKernelSize(materialSID, 0);\n  let minStrideLength = - f32(gaussianKernelSize - 1) / 2.0;\n\n  for (var i=0u; i < u32(gaussianKernelSize); i++) {\n\n    let strideLength = minStrideLength + f32(i);\n    let stride: vec2f = strideLength * blurDirection;\n\n    let gaussianRatio = get_gaussianRatio(materialSID, i);\n    var uv = (offset + stride) * tFrag;\n    // uv.y = 1.0 - uv.y;\n    color += vec4f(textureSampleLevel(baseColorTexture, baseColorSampler, uv, 0.0).rgb, 1.0) * gaussianRatio;\n  }\n\n  return color;\n}\n",shaderStage:"fragment",isFragmentShader:!0},ie={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},re={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nfloat decodeRGBAToDepth(vec4 RGBA){\n  const float rMask = 1.0;\n  const float gMask = 1.0 / 255.0;\n  const float bMask = 1.0 / (255.0 * 255.0);\n  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n  return depth;\n}\n\nvec4 encodeDepthToRGBA(float depth){\n  float r = depth;\n  float g = fract(r * 255.0);\n  float b = fract(g * 255.0);\n  float a = fract(b * 255.0);\n  float coef = 1.0 / 255.0;\n  r -= g * coef;\n  g -= b * coef;\n  b -= a * coef;\n  return vec4(r, g, b, a);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float framebufferSize;\n  vec2 offset = gl_FragCoord.st;\n\n  vec2 blurDirection;\n  bool isHorizontal = get_isHorizontal(materialSID, 0);\n  if(isHorizontal){\n    framebufferSize = get_framebufferSize(materialSID, 0).x;\n    blurDirection = vec2(1.0,0.0);\n  }else{\n    framebufferSize = get_framebufferSize(materialSID, 0).y;\n    blurDirection = vec2(0.0,1.0);\n  }\n\tfloat tFrag = 1.0 / framebufferSize;\n\n  float depth = 0.0;\n  int gaussianKernelSize = get_gaussianKernelSize(materialSID, 0);\n  float minStrideLength = -float(gaussianKernelSize - 1) / 2.0;\n\n  for(int i=0; i < 30; i++) {\n    if(gaussianKernelSize == i) {\n      break;\n    }\n\n    float strideLength = minStrideLength + float(i);\n    vec2 stride = strideLength * blurDirection;\n    float depthData = decodeRGBAToDepth(texture(u_baseColorTexture, (offset + stride) * tFrag));\n    if(depthData > 1.0) depthData = 1.0;\n\n    float gaussianRatio = u_gaussianRatio[i];\n    depth +=  depthData * gaussianRatio;\n  }\n\n  rt0 = encodeDepthToRGBA(depth);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},se={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n  \n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n  \n}\n\n",shaderStage:"vertex",isFragmentShader:!1},le={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform int u_cubeMapFaceId; // initialValue=0\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec2 dirToPanoramaUV(vec3 dir)\n{\n\treturn vec2(\n\t\t0.5f + 0.5f * atan(dir.z, dir.x) / PI,\n\t\t1.f - acos(dir.y) / PI);\n}\n\nvec3 uvToDirection(int faceId, vec2 uv)\n{\n\tif(faceId == 0)\n\t\treturn vec3(1.f, uv.y, -uv.x);\n\telse if(faceId == 1)\n\t\treturn vec3(-1.f, uv.y, uv.x);\n\telse if(faceId == 2)\n\t\treturn vec3(+uv.x, -1.f, +uv.y);\n\telse if(faceId == 3)\n\t\treturn vec3(+uv.x, 1.f, -uv.y);\n\telse if(faceId == 4)\n\t\treturn vec3(+uv.x, uv.y, 1.f);\n\telse\n    return vec3(-uv.x, +uv.y, -1.f);\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n\tvec2 uv = v_texcoord_0 * 2.0 - 1.0;\n\tvec3 direction = normalize(uvToDirection(get_cubeMapFaceId(materialSID, 0), uv));\n\tvec2 panoramaUv = dirToPanoramaUV(direction);\n\trt0 = vec4(texture(u_baseColorTexture, panoramaUv).rgb, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},ce={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n\n",shaderStage:"vertex",isFragmentShader:!1},_e={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n// #param cubeMapFaceId: i32; // initialValue=0\n\nfn dirToPanoramaUV(dir: vec3f) -> vec2f\n{\n\treturn vec2f(\n\t\t0.5f + 0.5f * atan2(dir.z, dir.x) / M_PI,\n\t\t1.f - acos(dir.y) / M_PI);\n}\n\nfn uvToDirection(faceId: i32, uv: vec2f) -> vec3f\n{\n\tif (faceId == 0) {\n\t\treturn vec3f(1.f, uv.y, -uv.x);\n  } else if(faceId == 1) {\n\t\treturn vec3f(-1.f, uv.y, uv.x);\n  } else if(faceId == 2) {\n\t\treturn vec3f(uv.x, -1.f, uv.y);\n  } else if(faceId == 3) {\n\t\treturn vec3f(uv.x, 1.f, -uv.y);\n  } else if(faceId == 4) {\n\t\treturn vec3f(uv.x, uv.y, 1.f);\n  } else {\n    return vec3f(-uv.x, uv.y, -1.f);\n  }\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n\tlet uv: vec2f = input.texcoord_0 * 2.0 - 1.0;\n\tlet direction: vec3f = normalize(uvToDirection(get_cubeMapFaceId(materialSID, 0), uv));\n  let panoramaUv: vec2f = dirToPanoramaUV(direction);\n\tlet rt0: vec4f = vec4f(textureSampleLevel(baseColorTexture, baseColorSampler, panoramaUv, 0.0).rgb, 1.0);\n  return rt0;\n}\n",shaderStage:"fragment",isFragmentShader:!0},ue={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n  \n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n  \n}\n\n",shaderStage:"vertex",isFragmentShader:!1},fe={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform samplerCube u_baseColorTexture; // initialValue=(0,white)\nuniform int u_cubeMapFaceId; // initialValue=0\nuniform int u_distributionType; // initialValue=0\nuniform float u_roughness; // initialValue=0.0\nuniform int u_sampleCount; // initialValue=1024\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nconst int cLambertian = 0;\nconst int cGGX = 1;\n\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfloat radicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(int i, int N) {\n    return vec2(float(i)/float(N), radicalInverse_VdC(uint(i)));\n}\n\nmat3 createTBN(vec3 normal)\n{\n    vec3 bitangent = vec3(0.0, 1.0, 0.0);\n    float NdotUp = dot(normal, vec3(0.0, 1.0, 0.0));\n    float epsilon = 0.0000001;\n    if (1.0 - abs(NdotUp) <= epsilon)\n    {\n      bitangent = (NdotUp > 0.0) ? vec3(0.0, 0.0, 1.0) : vec3(0.0, 0.0, -1.0);\n    }\n    vec3 tangent = normalize(cross(bitangent, normal));\n    bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\nvec4 getImportanceSampleLambertian(int sampleIndex, vec3 N, float roughness, float materialSID)\n{\n    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    float sinTheta = sqrt(1.0 - xi.y);\n    float cosTheta = sqrt(xi.y);\n    float phi = 2.0 * PI * xi.x;\n    float pdf = cosTheta / PI;\n\n    vec3 localDirection = normalize(vec3(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    vec3 direction = createTBN(N) * localDirection;\n\n    return vec4(direction, pdf);\n}\n\n// GGX NDF\nfloat d_GGX(float NH, float alphaRoughness) {\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (PI * f * f);\n}\n\n// We learnd a lot from the following resources\n// https://bruop.github.io/ibl/\nvec4 getImportanceSampleGGX(int sampleIndex, vec3 N, float roughness, float materialSID)\n{\n    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    float alpha = roughness * roughness;\n    float cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = 2.0 * PI * xi.x;\n    float pdf = d_GGX(cosTheta, alpha);\n    pdf /= 4.0;\n\n    vec3 localDirection = normalize(vec3(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    vec3 direction = createTBN(N) * localDirection;\n\n    return vec4(direction, pdf);\n}\n\n// We learnd a lot from the following resources\n// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n// https://google.github.io/filament/Filament.html#annex/importancesamplingfortheibl/pre-filteredimportancesampling\nfloat computeLod(float pdf, int width, int sampleCount)\n{\n    // 6.0 is the number of faces of the cubemap\n    // log4 = 0.5 * log2\n    // We don't use the constant K in the filament document\n    return 0.5 * log2( 6.0 * float(width) * float(width) / (float(sampleCount) * pdf));\n}\n\nvec3 prefilter(vec3 N, float materialSID)\n{\n    vec3 color = vec3(0.f);\n    float weight = 0.0f;\n    int sampleCount = get_sampleCount(materialSID, 0);\n\n    ivec2 texSize = textureSize(u_baseColorTexture, 0);\n\n    for(int i = 0; i < get_sampleCount(materialSID, 0); ++i)\n    {\n        vec4 importanceSample;\n\n        int distributionType = get_distributionType(materialSID, 0);\n        if(distributionType == cLambertian) {\n            importanceSample = getImportanceSampleLambertian(i, N, get_roughness(materialSID, 0), materialSID);\n        } else {\n            importanceSample = getImportanceSampleGGX(i, N, get_roughness(materialSID, 0), materialSID);\n        }\n\n        vec3 H = vec3(importanceSample.xyz);\n        float pdf = importanceSample.w;\n        float lod = computeLod(pdf, texSize.x, sampleCount);\n\n        if(distributionType == cLambertian)\n        {\n            vec3 lambertian = textureLod(u_baseColorTexture, H, lod).rgb;\n            color += lambertian;\n        }\n        else if(distributionType == cGGX)\n        {\n            vec3 V = N;\n            vec3 L = normalize(reflect(-V, H));\n            float NdotL = dot(N, L);\n\n            if (NdotL > 0.0)\n            {\n                vec3 sampleColor = textureLod(u_baseColorTexture, L, lod).rgb;\n                color += sampleColor * NdotL;\n                weight += NdotL;\n            }\n        }\n    }\n\n    if(weight != 0.0f)\n    {\n        color /= weight;\n    }\n    else\n    {\n        color /= float(sampleCount);\n    }\n\n    return color.rgb;\n}\n\nvec3 uvToDir(int faceId, vec2 uv)\n{\n\tif(faceId == 0)\n\t\treturn vec3(1.f, uv.y, -uv.x);\n\telse if(faceId == 1)\n\t\treturn vec3(-1.f, uv.y, uv.x);\n\telse if(faceId == 2)\n\t\treturn vec3(+uv.x, -1.f, +uv.y);\n\telse if(faceId == 3)\n\t\treturn vec3(+uv.x, 1.f, -uv.y);\n\telse if(faceId == 4)\n\t\treturn vec3(+uv.x, uv.y, 1.f);\n\telse\n    return vec3(-uv.x, +uv.y, -1.f);\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 uv = v_texcoord_0 * 2.0 - 1.0;\n  vec3 scan = uvToDir(get_cubeMapFaceId(materialSID, 0), uv);\n  vec3 direction = normalize(scan);\n  direction.y = -direction.y;\n\n  rt0 = vec4(prefilter(direction, materialSID), 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},de={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n\n\n",shaderStage:"vertex",isFragmentShader:!1},he={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n\n@group(1) @binding(0) var baseColorTexture: texture_cube<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n// #param cubeMapFaceId: i32; // initialValue=0\n// #param distributionType: i32; // initialValue=0\n// #param roughness: f32; // initialValue=0.0\n// #param sampleCount: i32; // initialValue=1024\n\nconst cLambertian: i32 = 0;\nconst cGGX: i32 = 1;\n\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfn radicalInverse_VdC(_bits: u32) -> f32\n{\n    var bits = (_bits << 16u) | (_bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nfn hammersley2d(i: i32, N: i32) -> vec2f {\n    return vec2f(f32(i)/f32(N), radicalInverse_VdC(u32(i)));\n}\n\nfn createTBN(normal: vec3f) -> mat3x3<f32>\n{\n    var bitangent = vec3f(0.0, 1.0, 0.0);\n    let NdotUp = dot(normal, vec3f(0.0, 1.0, 0.0));\n    let epsilon = 0.0000001;\n    if (1.0 - abs(NdotUp) <= epsilon)\n    {\n      bitangent = select(vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0), NdotUp > 0.0);\n    }\n    let tangent = normalize(cross(bitangent, normal));\n    bitangent = cross(normal, tangent);\n    return mat3x3<f32>(tangent, bitangent, normal);\n}\n\nfn getImportanceSampleLambertian(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f\n{\n    let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    let sinTheta = sqrt(1.0 - xi.y);\n    let cosTheta = sqrt(xi.y);\n    let phi = 2.0 * M_PI * xi.x;\n    let pdf = cosTheta / M_PI;\n\n    let localDirection = normalize(vec3f(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    let direction = createTBN(N) * localDirection;\n\n    return vec4f(direction, pdf);\n}\n\n// GGX NDF\nfn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {\n  let roughnessSqr = alphaRoughness * alphaRoughness;\n  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\n// We learnd a lot from the following resources\n// https://bruop.github.io/ibl/\nfn getImportanceSampleGGX(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f\n{\n    let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    let alpha = roughness * roughness;\n    let cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);\n    let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    let phi = 2.0 * M_PI * xi.x;\n    var pdf = d_GGX(cosTheta, alpha);\n    pdf /= 4.0;\n\n    let localDirection = normalize(vec3f(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    let direction = createTBN(N) * localDirection;\n\n    return vec4f(direction, pdf);\n}\n\n// We learnd a lot from the following resources\n// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n// https://google.github.io/filament/Filament.html#annex/importancesamplingfortheibl/pre-filteredimportancesampling\nfn computeLod(pdf: f32, width: u32, sampleCount: i32) -> f32\n{\n    // 6.0 is the number of faces of the cubemap\n    // log4 = 0.5 * log2\n    // We don't use the constant K in the filament document\n    return 0.5 * log2( 6.0 * f32(width) * f32(width) / (f32(sampleCount) * pdf));\n}\n\nfn prefilter(N: vec3f, materialSID: u32) -> vec3f\n{\n    var color = vec3f(0.f);\n    var weight = 0.0f;\n    let sampleCount = get_sampleCount(materialSID, 0);\n\n    let texSize: vec2<u32> = textureDimensions(baseColorTexture, 0);\n\n    for(var i = 0; i < get_sampleCount(materialSID, 0); i++)\n    {\n        var importanceSample: vec4<f32>;\n\n        let distributionType = get_distributionType(materialSID, 0);\n        if(distributionType == cLambertian) {\n            importanceSample = getImportanceSampleLambertian(i, N, get_roughness(materialSID, 0), materialSID);\n        } else {\n            importanceSample = getImportanceSampleGGX(i, N, get_roughness(materialSID, 0), materialSID);\n        }\n\n        let H = vec3f(importanceSample.xyz);\n        let pdf = importanceSample.w;\n        let lod = computeLod(pdf, texSize.x, sampleCount);\n\n        if(distributionType == cLambertian)\n        {\n            let lambertian = textureSampleLevel(baseColorTexture, baseColorSampler, H, lod).rgb;\n            color += lambertian;\n        }\n        else if(distributionType == cGGX)\n        {\n            let V = N;\n            let L = normalize(reflect(-V, H));\n            let NdotL = dot(N, L);\n\n            if (NdotL > 0.0)\n            {\n                let sampleColor = textureSampleLevel(baseColorTexture, baseColorSampler, L, lod).rgb;\n                color += sampleColor * NdotL;\n                weight += NdotL;\n            }\n        }\n    }\n\n    if(weight != 0.0f)\n    {\n        color /= weight;\n    }\n    else\n    {\n        color /= f32(sampleCount);\n    }\n\n    return color.rgb;\n}\n\nfn uvToDir(faceId: i32, uv: vec2f) -> vec3f\n{\n\tif (faceId == 0) {\n\t\treturn vec3f(1.f, uv.y, -uv.x);\n  } else if(faceId == 1) {\n\t\treturn vec3f(-1.f, uv.y, uv.x);\n  } else if(faceId == 2) {\n\t\treturn vec3f(uv.x, -1.f, uv.y);\n  } else if(faceId == 3) {\n\t\treturn vec3f(uv.x, 1.f, -uv.y);\n  } else if(faceId == 4) {\n\t\treturn vec3f(uv.x, uv.y, 1.f);\n  } else {\n    return vec3f(-uv.x, uv.y, -1.f);\n  }\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let uv = input.texcoord_0 * 2.0 - 1.0;\n  let scan = uvToDir(get_cubeMapFaceId(materialSID, 0), uv);\n  var direction = normalize(scan);\n  direction.y = -direction.y;\n\n  let rt0 = vec4f(prefilter(direction, materialSID), 1.0);\n\n  return rt0;\n}\n",shaderStage:"fragment",isFragmentShader:!0};var me=n(9011),pe=n(2766),ve=n(9936),xe=n(7670),ge=n(6131);function ye(e,t){let n=0,o=!1;do{const a=e.getMaterialSemanticsVariantName()+`__group${n}`;if(o=J.s.isFullOrOverOfThisMaterialType(a),!o)return J.s.registerMaterial(a,e,t),J.s.createMaterial(a,e);n++}while(o);throw new Error("Failed to create material")}const be=Object.freeze({createMaterial:ye,recreateMaterial:function(e,t){const n=e.getMaterialSemanticsVariantName();return J.s.forceRegisterMaterial(n,e,t),J.s.createMaterial(n,e)},reuseOrRecreateCustomMaterial:function(e,t,n,{additionalName:a="",isSkinning:i=!0,isLighting:r=!1,isMorphing:s=!1,maxInstancesNumber:c=o.T.maxMaterialInstanceForEachType}={}){const _=`Custom_${a}_`;let u;u=xe.l.currentProcessApproach===pe.m7.WebGPU?new l.w({name:_,isSkinning:i,isLighting:r,isMorphing:s,vertexShaderWebGpu:{code:t,shaderStage:"vertex",isFragmentShader:!1},pixelShaderWebGpu:{code:n,shaderStage:"fragment",isFragmentShader:!0},additionalShaderSemanticInfo:[]}):new l.w({name:_,isSkinning:i,isLighting:r,isMorphing:s,vertexShader:{code:t,shaderStage:"vertex",isFragmentShader:!1},pixelShader:{code:n,shaderStage:"fragment",isFragmentShader:!0},additionalShaderSemanticInfo:[]});const f=function(e,t,n){let o=e;if(J.s.isMaterialCompatible(o,t))return o._materialContent=t,o.makeShadersInvalidate(),o;{const e=t.getMaterialSemanticsVariantName();return J.s.registerMaterial(e,t,n),o=J.s.createMaterial(e,t),o}}(e,u,c);return f.addShaderDefine("RN_IS_SKINNING"),f},createClassicUberMaterial:function({additionalName:e="",isSkinning:t=!0,isLighting:n=!1,isMorphing:a=!1,isShadow:i=!1,maxInstancesNumber:r=o.T.maxMaterialInstanceForEachType}={}){const s=`ClassicUber_${e}_`,c=[{semantic:"dataTextureMorphOffsetPosition",componentType:p.I.Int,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Int32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:p.I.Float,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Float32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}],_=ye(new l.w({name:s,isSkinning:t,isLighting:n,isMorphing:a,vertexShader:y,pixelShader:b,vertexShaderWebGpu:I,pixelShaderWebGpu:A,additionalShaderSemanticInfo:c}),r);return n&&_.addShaderDefine("RN_IS_LIGHTING"),i&&_.addShaderDefine("RN_USE_SHADOW_MAPPING"),_.addShaderDefine("RN_USE_NORMAL_TEXTURE"),_.addShaderDefine("RN_IS_SKINNING"),_},createDepthMomentEncodeMaterial:function({additionalName:e="",isSkinning:t=!0,isMorphing:n=!1,maxInstancesNumber:a=o.T.maxMaterialInstanceForEachType}={}){const i=`DepthMomentEncode_${e}_`,r=[{semantic:"dataTextureMorphOffsetPosition",componentType:p.I.Int,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Int32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:p.I.Float,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Float32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}],s=ye(new l.w({name:i,isSkinning:t,isLighting:!1,isMorphing:n,vertexShader:j,pixelShader:Y,additionalShaderSemanticInfo:r}),a);return s.addShaderDefine("RN_IS_SKINNING"),s},createParaboloidDepthMomentEncodeMaterial:function({additionalName:e="",isSkinning:t=!0,isMorphing:n=!1,maxInstancesNumber:a=o.T.maxMaterialInstanceForEachType}={}){const i=`ParaboloidDepthMomentEncode_${e}_`,r=[{semantic:"dataTextureMorphOffsetPosition",componentType:p.I.Int,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Int32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:p.I.Float,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Float32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}],s=ye(new l.w({name:i,isSkinning:t,isLighting:!0,isMorphing:n,vertexShader:K,pixelShader:Z,additionalShaderSemanticInfo:r}),a);return s.addShaderDefine("RN_IS_SKINNING"),s},createFlatMaterial:function({additionalName:e="",isSkinning:t=!0,isMorphing:n=!1,maxInstancesNumber:a=o.T.maxMaterialInstanceForEachType}={}){const i=`Flat_${e}_`,r=ye(new l.w({name:i,isSkinning:t,isLighting:!1,isMorphing:n,vertexShader:Q,pixelShader:q,additionalShaderSemanticInfo:[],vertexShaderWebGpu:X,pixelShaderWebGpu:H}),a);return r.addShaderDefine("RN_IS_SKINNING"),r},createPbrUberMaterial:function({additionalName:e="",isMorphing:t=!0,isSkinning:n=!0,isLighting:a=!0,isClearCoat:i=!1,isTransmission:r=!1,isVolume:s=!1,isSheen:c=!1,isSpecular:_=!1,isIridescence:u=!1,isAnisotropy:f=!1,isShadow:d=!1,useTangentAttribute:h=!1,useNormalTexture:m=!0,maxInstancesNumber:y=o.T.maxMaterialInstanceForEachType}={}){const b=`PbrUber_${e}_`;let I=[];I=[{semantic:"dataTextureMorphOffsetPosition",componentType:p.I.Int,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Int32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:p.I.Float,compositionType:v.h.ScalarArray,arrayLength:o.T.maxVertexMorphNumberInShader,stage:x.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new g.u(new Float32Array(o.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}];const A=new $.L({minFilter:pe.gu.Linear,magFilter:pe.gu.Linear,wrapS:pe.gu.ClampToEdge,wrapT:pe.gu.ClampToEdge});let C=8;i&&(I.push({semantic:"clearCoatTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"clearCoatRoughnessTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"clearCoatNormalTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.Uk,A],min:0,max:Number.MAX_VALUE})),r&&(I.push({semantic:"transmissionTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"backBufferTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.rT,A],min:0,max:Number.MAX_VALUE})),s&&I.push({semantic:"thicknessTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),c&&(I.push({semantic:"sheenColorTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"sheenRoughnessTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"sheenLutTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.EY,A],min:0,max:Number.MAX_VALUE})),_&&(I.push({semantic:"specularTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"specularColorTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE})),u&&(I.push({semantic:"iridescenceTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"iridescenceThicknessTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE})),f&&I.push({semantic:"anisotropyTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.OZ,A],min:0,max:Number.MAX_VALUE}),d&&(I.push({semantic:"depthTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}),I.push({semantic:"paraboloidDepthTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[C++,ee.vK,A],min:0,max:Number.MAX_VALUE}));const R=ye(new l.w({name:b,isSkinning:n,isLighting:a,isMorphing:t,vertexShader:E,pixelShader:S,vertexShaderWebGpu:T,pixelShaderWebGpu:w,additionalShaderSemanticInfo:I}),y);return a&&R.addShaderDefine("RN_IS_LIGHTING"),d&&R.addShaderDefine("RN_USE_SHADOW_MAPPING"),m&&R.addShaderDefine("RN_USE_NORMAL_TEXTURE"),i&&R.addShaderDefine("RN_USE_CLEARCOAT"),r&&R.addShaderDefine("RN_USE_TRANSMISSION"),s&&R.addShaderDefine("RN_USE_VOLUME"),c&&R.addShaderDefine("RN_USE_SHEEN"),_&&R.addShaderDefine("RN_USE_SPECULAR"),u&&R.addShaderDefine("RN_USE_IRIDESCENCE"),f&&R.addShaderDefine("RN_USE_ANISOTROPY"),R.addShaderDefine("RN_IS_SKINNING"),R},createEnvConstantMaterial:function({additionalName:e="",maxInstancesNumber:t=5,makeOutputSrgb:n=!0}={}){const o=`EnvConstant_${e}`,a=ye(new l.w({name:o,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:C,pixelShader:R,vertexShaderWebGpu:P,pixelShaderWebGpu:N,additionalShaderSemanticInfo:[]}),t);return a.setParameter("makeOutputSrgb",n?1:0),a},createFXAA3QualityMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`FXAA3Quality_${e}`;return ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:M,pixelShader:D,additionalShaderSemanticInfo:[]}),t)},createDepthEncodeMaterial:function({additionalName:e="",isSkinning:t=!1,depthPow:n=1,maxInstancesNumber:o=10}={}){const i=`DepthEncode_${e}_`,r=ye(new a.g(i,n,{isSkinning:t}),o);return t&&r.addShaderDefine("RN_IS_SKINNING"),r},createShadowMapDecodeClassicSingleMaterial:function({additionalName:e="",isMorphing:t=!1,isSkinning:n=!1,isLighting:o=!0,isDebugging:a=!1,colorAttachmentsNumber:r=0,maxInstancesNumber:s=20}={},l){const c=`ShadowMapDecodeClassic_${e}_`,_=ye(new i.X(c,{isMorphing:t,isSkinning:n,isLighting:o,isDebugging:a,colorAttachmentsNumber:r},l),s);return n&&_.addShaderDefine("RN_IS_SKINNING"),t&&_.addShaderDefine("RN_IS_MORPHING"),o&&_.addShaderDefine("RN_IS_LIGHTING"),a&&_.addShaderDefine("RN_IS_DEBUGGING"),_},createGammaCorrectionMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`GammaCorrection_${e}`;return ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:F,pixelShader:B,vertexShaderWebGpu:L,pixelShaderWebGpu:V,additionalShaderSemanticInfo:[]}),t)},createToneMappingMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`ToneMapping_${e}`,o=ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:z,pixelShader:G,vertexShaderWebGpu:O,pixelShaderWebGpu:U,additionalShaderSemanticInfo:[]}),t);return o.addShaderDefine("RN_USE_GT_TONEMAP"),o},createPanoramaToCubeMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`PanoramaToCube_${e}`;return ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:se,pixelShader:le,vertexShaderWebGpu:ce,pixelShaderWebGpu:_e,additionalShaderSemanticInfo:[]}),t)},createPrefilterIBLMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`PrefilterIBL_${e}`;return ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:ue,pixelShader:fe,vertexShaderWebGpu:de,pixelShaderWebGpu:he,additionalShaderSemanticInfo:[]}),t)},createSummedAreaTableMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`SummedAreaTable_${e}`;return ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:k,pixelShader:W,additionalShaderSemanticInfo:[]}),t)},createVarianceShadowMapDecodeClassicSingleMaterial:function({additionalName:e="",isMorphing:t=!1,isSkinning:n=!1,isDebugging:o=!1,isLighting:a=!0,colorAttachmentsNumberDepth:i=0,colorAttachmentsNumberSquareDepth:r=0,depthCameraComponent:s,maxInstancesNumber:l=10},c){const _=`VarianceShadowMapDecodeClassic_${e}_`,u=ye(new m.w(_,{isMorphing:t,isSkinning:n,isLighting:a,isDebugging:o,colorAttachmentsNumberDepth:i,colorAttachmentsNumberSquareDepth:r,depthCameraComponent:s},c),l);return n&&u.addShaderDefine("RN_IS_SKINNING"),a&&u.addShaderDefine("RN_IS_LIGHTING"),t&&u.addShaderDefine("RN_IS_MORPHING"),o&&u.addShaderDefine("RN_IS_DEBUGGING"),u},createEntityUIDOutputMaterial:function({additionalName:e="",maxInstancesNumber:t=10}={}){const n=`EntityUIDOutput_${e}`,o=ye(new r.v(n),t);return o.addShaderDefine("RN_IS_SKINNING"),o},createMToon0xMaterial:function({additionalName:e="",isMorphing:t=!1,isSkinning:n=!1,isLighting:a=!0,useTangentAttribute:i=!1,isOutline:r=!1,materialProperties:l,textures:c,samplers:_,debugMode:u,maxInstancesNumber:f=o.T.maxMaterialInstanceForEachType,makeOutputSrgb:d=!0}){const h=`MToon0x_${e}_`,m=new s.E(r,l,c,_,t,n,a,i,u,d,h),p=ye(m,f);return m.setMaterialParameters(p,r),p},createMToon1Material:function({additionalName:e="",isMorphing:t=!1,isSkinning:n=!1,isLighting:a=!0,useTangentAttribute:i=!1,isOutline:r=!1,materialJson:s,textures:l,samplers:c,debugMode:_,maxInstancesNumber:u=o.T.maxMaterialInstanceForEachType,makeOutputSrgb:f=!0}){const d=`MToon1_${e}_`,h=new ge.t(d,t,n,a,r),m=ye(h,u);return h.setMaterialParameters(m,r,s),m.setParameter("makeOutputSrgb",me.X5.fromCopyNumber(f?1:0)),m.zWriteWhenBlend=s.extensions.VRMC_materials_mtoon.transparentWithZWrite,null!=s.normalTexture&&m.addShaderDefine("RN_USE_NORMAL_TEXTURE"),m},createFurnaceTestMaterial:function({additionalName:e="",maxInstancesNumber:t=1}={}){const n=`FurnaceTest_${e}`;return ye(new _.P(n),t)},createGaussianBlurForEncodedDepthMaterial:function({additionalName:e="",maxInstancesNumber:t=10}={}){const n=`GaussianBlurForEncodedDepth_${e}`,o=[],a=new Float32Array(30);return o.push({semantic:"isHorizontal",componentType:p.I.Bool,compositionType:v.h.Scalar,stage:x.C.PixelShader,initialValue:me.X5.fromCopyNumber(1),min:0,max:1},{semantic:"gaussianRatio",componentType:p.I.Float,compositionType:v.h.ScalarArray,arrayLength:30,stage:x.C.PixelShader,initialValue:new g.u(a),min:0,max:1,needUniformInDataTextureMode:!0},{semantic:"gaussianKernelSize",componentType:p.I.Int,compositionType:v.h.Scalar,stage:x.C.PixelShader,initialValue:me.X5.fromCopyNumber(1),min:1,max:30},{semantic:"framebufferSize",componentType:p.I.Float,compositionType:v.h.Vec2,stage:x.C.PixelShader,initialValue:ve.I9.fromCopy2(1,1),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"baseColorTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[0,ee.rT],min:0,max:Number.MAX_SAFE_INTEGER}),ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:ie,pixelShader:re,additionalShaderSemanticInfo:o}),t)},createDetectHighLuminanceMaterial:function({additionalName:e="",maxInstancesNumber:t=5}={},n){const o=`DetectHighLuminance_${e}_`;return ye(new u.Q(o,n),t)},createGaussianBlurMaterial:function({additionalName:e="",maxInstancesNumber:t=10}={}){const n=`GaussianBlur_${e}`,o=[],a=new Float32Array(30);return o.push({semantic:"isHorizontal",componentType:p.I.Bool,compositionType:v.h.Scalar,stage:x.C.PixelShader,initialValue:me.X5.fromCopyNumber(1),min:0,max:1},{semantic:"gaussianRatio",componentType:p.I.Float,compositionType:v.h.ScalarArray,arrayLength:30,stage:x.C.PixelShader,initialValue:new g.u(a),min:0,max:1},{semantic:"gaussianKernelSize",componentType:p.I.Int,compositionType:v.h.Scalar,stage:x.C.PixelShader,initialValue:me.X5.fromCopyNumber(1),min:1,max:30},{semantic:"framebufferSize",componentType:p.I.Float,compositionType:v.h.Vec2,stage:x.C.PixelShader,initialValue:ve.I9.fromCopy2(1,1),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"baseColorTexture",componentType:p.I.Int,compositionType:v.h.Texture2D,stage:x.C.PixelShader,initialValue:[0,ee.rT],min:0,max:Number.MAX_SAFE_INTEGER}),ye(new l.w({name:n,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:te,pixelShader:ne,vertexShaderWebGpu:oe,pixelShaderWebGpu:ae,additionalShaderSemanticInfo:o}),t)},createSynthesizeHDRMaterial:function({additionalName:e="",maxInstancesNumber:t=1},n){const o=`SynthesizeHDR_${e}`;return ye(new f.$(o,n),t)},createColorGradingUsingLUTsMaterial:function({additionalName:e="",colorAttachmentsNumber:t=0,uri:n,texture:o,maxInstancesNumber:a=1},i){const r=`ColorGradingUsingLUTs_${e}`;return ye(new d.u(r,i,t,n,o),a)},createMatCapMaterial:function({additionalName:e="",isSkinning:t=!1,uri:n,texture:o,sampler:a,maxInstancesNumber:i=10}){const r=`MatCap_${e}`,s=ye(new h.R(r,t,n,o,a),i);return t&&s.addShaderDefine("RN_IS_SKINNING"),s},changeMaterial:function(e,t,n){const o=e.getMeshRenderer();t.material=n,o.moveStageTo(c.O.Load)}})},148:(e,t,n)=>{n.d(t,{a:()=>c});var o=n(5065),a=n(1692),i=n(2229),r=n(7681),s=n(8556),l=n(3497);class c{constructor(){}static async importFromUri(e,t){var n;const a=await o.$.fetchArrayBuffer(e);return a.isErr()?new s._({message:"fetchArrayBuffer error",error:void 0}):await this._importGltfOrGlbFromArrayBuffers(a.get(),null!==(n=null==t?void 0:t.files)&&void 0!==n?n:{},t,e)}static async importFromArrayBuffers(e,t){for(const n in e){const a=o.$.getExtension(n);if("gltf"===a||"glb"===a)return await this._importGltfOrGlbFromArrayBuffers(e[n],e,t)}return new s._({message:"no gltf or glb file found",error:void 0})}static async _importGltfOrGlbFromArrayBuffers(e,t,n,a){if(1179937895!==new DataView(e,0,20).getUint32(0,!0)){const i=o.$.arrayBufferToString(e),r=JSON.parse(i);try{const e=await this._importGltf(r,t,n,a);return new s.Ok(e)}catch(e){return new s._({message:"this.__importGltf error",error:void 0})}}else try{const o=await this._importGlb(e,t,n);return new s.Ok(o)}catch(e){return new s._({message:"this.importGlb error",error:void 0})}}static _getOptions(e,t,n){var o,a;if(null!=(null===(a=null===(o=t.asset)||void 0===o?void 0:o.extras)||void 0===a?void 0:a.rnLoaderOptions))for(const n in t.asset.extras.rnLoaderOptions)e[n]=t.asset.extras.rnLoaderOptions[n];for(const t in n)e[t]=n[t];return n&&n.loaderExtensionName&&"string"==typeof n.loaderExtensionName&&(null!=Rn[n.loaderExtensionName]?e.loaderExtension=Rn[n.loaderExtensionName].getInstance():(l.V.error(`${n.loaderExtensionName} not found!`),e.loaderExtension=void 0)),e}static async _importGlb(e,t,n){const a=new DataView(e,0,20);if(2!==a.getUint32(4,!0))throw new Error("invalid version field in this binary glTF file.");const i=a.getUint32(12,!0);if(1313821514!==a.getUint32(16,!0))throw new Error("invalid chunkType of chunk0 in this binary glTF file.");const r=new Uint8Array(e,20,i),s=o.$.uint8ArrayToString(r),c=JSON.parse(s),_=o.$.createDefaultGltfOptions();n=this._getOptions(_,c,n);const u=new Uint8Array(e,20+i+8);void 0===c.asset.extras&&(c.asset.extras={fileType:"glTF",version:"2"}),this._mergeExtendedJson(c,n.extendedJson),c.asset.extras.rnLoaderOptions=n;try{await this._loadInner(c,t,n,u)}catch(e){l.V.info("this._loadInner error in _loadAsBinaryJson: "+e)}return c}static async _importGltf(e,t,n,a,i){const r=(null==a?void 0:a.substring(0,null==a?void 0:a.lastIndexOf("/")))+"/";void 0===e.asset.extras&&(e.asset.extras={fileType:"glTF",version:"2"});const s=o.$.createDefaultGltfOptions();n=this._getOptions(s,e,n),this._mergeExtendedJson(e,n.extendedJson),e.asset.extras.rnLoaderOptions=n;try{await this._loadInner(e,t,n,void 0,r,i)}catch(e){l.V.error("this._loadInner error in _loadAsTextJson: "+e)}return e}static _loadInner(e,t,n,o,i,r){const s=[];return s.push(this._loadResources(o,e,t,n,i,r)),s.push(new a.m((t=>{this._loadJsonContent(e),t()}))),a.m.all(s)}static _loadJsonContent(e){this._loadDependenciesOfScenes(e),this._loadDependenciesOfNodes(e),this._loadDependenciesOfMeshes(e),this._loadDependenciesOfMaterials(e),this._loadDependenciesOfTextures(e),this._loadDependenciesOfJoints(e),this._loadDependenciesOfAnimations(e),this._loadDependenciesOfAccessors(e),this._loadDependenciesOfBufferViews(e),void 0===e.asset.extras&&(e.asset.extras={})}static _loadDependenciesOfScenes(e){for(const t of e.scenes){i.Is.undefined(t.nodesObjects)&&(t.nodesObjects=[]);for(const n of t.nodes)t.nodesObjects[n]=e.nodes[t.nodes[n]]}}static _loadDependenciesOfNodes(e){var t,n;for(const o in e.nodes){const a=e.nodes[o];if(a.childrenObjects=null!==(t=a.childrenObjects)&&void 0!==t?t:[],a.children)for(const t of a.children)a.childrenObjects[t]=e.nodes[t],e.nodes[t].parent=parseInt(o),e.nodes[t].parentObject=a;void 0!==a.mesh&&void 0!==e.meshes&&(a.meshObject=e.meshes[a.mesh]),void 0!==a.skin&&void 0!==e.skins&&(a.skinObject=e.skins[a.skin],i.Is.exist(a.skinObject)&&(i.Is.not.exist(null===(n=a.meshObject)||void 0===n?void 0:n.extras)&&(a.meshObject.extras={}),a.meshObject.extras._skin=a.skin)),void 0!==a.camera&&void 0!==e.cameras&&(a.cameraObject=e.cameras[a.camera]),void 0!==a.extensions&&void 0!==a.extensions.KHR_lights_punctual&&void 0!==e.extensions&&void 0!==e.extensions.KHR_lights_punctual&&(a.extensions.KHR_lights_punctual.lightIndex=a.extensions.KHR_lights_punctual.light,a.extensions.KHR_lights_punctual.light=e.extensions.KHR_lights_punctual.lights[a.extensions.KHR_lights_punctual.lightIndex])}}static _loadDependenciesOfMeshes(e){var t;if(!i.Is.not.exist(e.meshes))for(const n of e.meshes)for(const o of n.primitives){if(void 0!==o.material&&(o.materialObject=e.materials[o.material]),null!=(null===(t=o.extensions)||void 0===t?void 0:t.KHR_materials_variants)){o.materialVariants=[];const t=o.extensions.KHR_materials_variants.mappings,n=e.extensions.KHR_materials_variants.variants;for(const a of t){const t=a.variants.map((e=>n[e].name)),i={materialObject:e.materials[a.material],material:a.material,variants:t};o.materialVariants.push(i)}}o.attributesObjects={};for(const t in o.attributes){const n=o.attributes[t],a=e.accessors[n];a.extras={toGetAsTypedArray:!0,attributeName:t},o.attributesObjects[t]=a}if(null!=o.indices&&(o.indicesObject=e.accessors[o.indices]),null!=o.targets){o.targetsObjects=[];for(const t of o.targets){const n={};for(const o in t){const a=t[o];if(a>=0){const t=e.accessors[a];t.extras={toGetAsTypedArray:!0,attributeName:o},n[o]=t}}o.targetsObjects.push(n)}}}}static _checkRnGltfLoaderOptionsExist(e){return!(!e.asset.extras||!e.asset.extras.rnLoaderOptions)}static _loadDependenciesOfMaterials(e){if(e.textures||(e.textures=[]),e.materials)for(const t of e.materials){if(t.pbrMetallicRoughness){const n=t.pbrMetallicRoughness.baseColorTexture;void 0!==n&&(n.texture=e.textures[n.index]);const o=t.pbrMetallicRoughness.metallicRoughnessTexture;void 0!==o&&(o.texture=e.textures[o.index])}const n=t.normalTexture;void 0!==n&&(n.texture=e.textures[n.index]);const o=t.occlusionTexture;void 0!==o&&(o.texture=e.textures[o.index]);const a=t.emissiveTexture;if(void 0!==a&&(a.texture=e.textures[a.index]),this._checkRnGltfLoaderOptionsExist(e)&&e.asset.extras.rnLoaderOptions.loaderExtension&&e.asset.extras.rnLoaderOptions.loaderExtension.setTextures&&e.asset.extras.rnLoaderOptions.loaderExtension.setTextures(e,t),i.Is.exist(t.extensions)){const n=t.extensions;if(i.Is.exist(n.KHR_materials_clearcoat)){const t=n.KHR_materials_clearcoat.clearcoatTexture;void 0!==t&&(t.texture=e.textures[t.index]);const o=n.KHR_materials_clearcoat.clearcoatRoughnessTexture;void 0!==o&&(o.texture=e.textures[o.index]);const a=n.KHR_materials_clearcoat.clearcoatNormalTexture;void 0!==a&&(a.texture=e.textures[a.index])}if(i.Is.exist(n.KHR_materials_transmission)){const t=n.KHR_materials_transmission.transmissionTexture;void 0!==t&&(t.texture=e.textures[t.index])}if(i.Is.exist(n.KHR_materials_volume)){const t=n.KHR_materials_volume.thicknessTexture;void 0!==t&&(t.texture=e.textures[t.index])}if(i.Is.exist(n.KHR_materials_sheen)){const t=n.KHR_materials_sheen.sheenColorTexture;void 0!==t&&(t.texture=e.textures[t.index]);const o=n.KHR_materials_sheen.sheenRoughnessTexture;void 0!==o&&(o.texture=e.textures[o.index])}if(i.Is.exist(n.KHR_materials_specular)){const t=n.KHR_materials_specular.specularTexture;void 0!==t&&(t.texture=e.textures[t.index]);const o=n.KHR_materials_specular.specularColorTexture;void 0!==o&&(o.texture=e.textures[o.index])}if(i.Is.exist(n.KHR_materials_iridescence)){const t=n.KHR_materials_iridescence.iridescenceTexture;void 0!==t&&(t.texture=e.textures[t.index]);const o=n.KHR_materials_iridescence.iridescenceThicknessTexture;void 0!==o&&(o.texture=e.textures[o.index])}if(i.Is.exist(n.KHR_materials_anisotropy)){const t=n.KHR_materials_anisotropy.anisotropyTexture;void 0!==t&&(t.texture=e.textures[t.index])}if(i.Is.exist(n.VRMC_materials_mtoon)){const t=n.VRMC_materials_mtoon,o=t.shadeMultiplyTexture;null!=o&&(o.texture=e.textures[o.index]);const a=t.shadingShiftTexture;null!=a&&(a.texture=e.textures[a.index]);const i=t.matcapTexture;null!=i&&(i.texture=e.textures[i.index]);const r=t.rimMultiplyTexture;null!=r&&(r.texture=e.textures[r.index]);const s=t.outlineWidthMultiplyTexture;null!=s&&(s.texture=e.textures[s.index]);const l=t.uvAnimationMaskTexture;null!=l&&(l.texture=e.textures[l.index])}}}}static _loadDependenciesOfTextures(e){var t,n;if(e.textures)for(const o of e.textures)(0,r.CW)((t=>o.samplerObject=e.samplers[t]),o.sampler),null!=(null===(n=null===(t=o.extensions)||void 0===t?void 0:t.KHR_texture_basisu)||void 0===n?void 0:n.source)?(o.extensions.KHR_texture_basisu.fallbackSourceIndex=o.source,o.source=o.extensions.KHR_texture_basisu.source,o.image=e.images[o.source]):void 0!==o.source&&(o.image=e.images[o.source])}static _loadDependenciesOfJoints(e){if(e.skins)for(const t of e.skins){t.skeletonObject=e.nodes[t.skeleton],t.inverseBindMatricesObject=e.accessors[t.inverseBindMatrices],i.Is.not.exist(t.skeleton)&&(t.skeleton=t.joints[0],t.skeletonObject=e.nodes[t.skeleton]),t.jointsObjects=[];for(const n of t.joints)t.jointsObjects.push(e.nodes[n])}}static _loadDependenciesOfAnimations(e){if(e.animations)for(const t of e.animations)for(const n of t.channels)if(i.Is.exist(n.sampler)){if(n.samplerObject=t.samplers[n.sampler],n.target.nodeObject=e.nodes[n.target.node],n.samplerObject.inputObject=e.accessors[n.samplerObject.input],n.samplerObject.outputObject=e.accessors[n.samplerObject.output],i.Is.undefined(n.samplerObject.outputObject.extras)&&(n.samplerObject.outputObject.extras={}),"weights"===n.target.path){let e=n.samplerObject.outputObject.count/n.samplerObject.inputObject.count;"CUBICSPLINE"===n.samplerObject.interpolation&&(e=n.samplerObject.outputObject.count/n.samplerObject.inputObject.count/3),n.samplerObject.outputObject.extras.weightsArrayLength=e}"rotation"===n.target.path&&(n.samplerObject.outputObject.extras.quaternionIfVec4=!0)}}static _loadDependenciesOfAccessors(e){for(const t of e.accessors)if(null!=t.bufferView&&(t.bufferViewObject=e.bufferViews[t.bufferView]),i.Is.exist(t.sparse)){const n=t.sparse;i.Is.exist(n)&&i.Is.exist(n.indices)&&i.Is.exist(n.values)&&(n.indices.bufferViewObject=e.bufferViews[n.indices.bufferView],n.values.bufferViewObject=e.bufferViews[n.values.bufferView])}}static _loadDependenciesOfBufferViews(e){for(const t of e.bufferViews)void 0!==t.buffer&&(t.bufferObject=e.buffers[t.buffer])}static _mergeExtendedJson(e,t){let n=null;if(t instanceof ArrayBuffer){const e=o.$.arrayBufferToString(t);n=JSON.parse(e)}else"string"==typeof t?n=JSON.parse(t):"object"==typeof t&&(n=t);Object.assign(e,n)}static _loadResources(e,t,n,r,s,c){var _;const u=[];let f;for(const i of t.buffers){let t="";if(i.uri){const e=i.uri.split("/");t=e[e.length-1]}f=void 0===i.uri?new a.m((t=>{i.buffer=e,t(e)})):i.uri.match(/^data:application\/(.*);base64,/)?new a.m((e=>{const t=o.$.dataUriToArrayBuffer(i.uri);i.buffer=new Uint8Array(t),e(t)})):n&&this.__containsFileName(n,t)?new a.m((e=>{const o=this.__getFullPathOfFileName(n,t),a=n[o];i.buffer=new Uint8Array(a),e(a)})):new a.m(o.$.loadResourceAsync(s+i.uri,!0,((e,t)=>{i.buffer=new Uint8Array(t),e(t)}),((e,t)=>{e("HTTP Error Status:"+t)}))),i.bufferPromise=f,u.push(f)}for(const r of null!==(_=t.images)&&void 0!==_?_:[])if(null==r.uri)if(i.Is.exist(e)){const a=o.$.createUint8ArrayFromBufferViewInfo(t,r.bufferView,e),i=o.$.createBlobImageUriFromUint8Array(a,r.mimeType);u.push(this.__loadImageUri(i,r,n))}else{const e=t.bufferViews[r.bufferView].bufferObject;if(i.Is.not.exist(e)){l.V.error("gltf2BufferView.bufferObject not found");continue}const s=e.bufferPromise,c=new a.m((e=>{s.then((a=>{const i=o.$.createUint8ArrayFromBufferViewInfo(t,r.bufferView,a),s=o.$.createBlobImageUriFromUint8Array(i,r.mimeType);this.__loadImageUri(s,r,n).then((()=>{e(a)}))}))})),_=u.indexOf(s);u[_]=c,e.bufferPromise=c}else{const e=r.uri,t=e.split("/"),a=t[t.length-1];let i;if(n&&this.__containsFileName(n,a)){const e=this.__getFullPathOfFileName(n,a),t=n[e];i=o.$.createBlobImageUriFromUint8Array(new Uint8Array(t),r.mimeType)}else i=e.match(/^data:/)?e:s+e;u.push(this.__loadImageUri(i,r,n))}return a.m.all(u,c).catch((e=>{l.V.error("Promise.all error: "+e)}))}static __containsFileName(e,t){for(const n in e){const e=n.split("/");if(e[e.length-1]===t)return!0}return!1}static __getFullPathOfFileName(e,t){for(const n in e){const e=n.split("/");if(e[e.length-1]===t)return n}}static __loadImageUri(e,t,n){var i,r;let s;return s=e.match(/basis$/)?new a.m((n=>{fetch(e,{mode:"cors"}).then((e=>{e.arrayBuffer().then((e=>{const o=new Uint8Array(e);t.basis=o,n(t)}))}))})):(null===(i=t.uri)||void 0===i?void 0:i.match(/basis$/))?new a.m((e=>{t.basis=new Uint8Array(n[t.uri]),e(t)})):e.match(/\.ktx2$/)||e.match(/^data:image\/ktx2/)||null!=t.bufferView&&"image/ktx2"===t.mimeType?new a.m((n=>{fetch(e,{mode:"cors"}).then((e=>{e.arrayBuffer().then((e=>{const o=new Uint8Array(e);t.ktx2=o,n(t)}))}))})):(null===(r=t.uri)||void 0===r?void 0:r.match(/ktx2$/))?new a.m((e=>{t.ktx2=new Uint8Array(n[t.uri]),e(t)})):o.$.createImageFromUri(e,t.mimeType).then((e=>(e.crossOrigin="Anonymous",t.image=e,t))),s}}},3508:(e,t,n)=>{n.d(t,{w:()=>H});var o=n(7503),a=n(9447),i=n(975),r=n(6603),s=n(3870),l=n(960),c=n(4066),_=n(6947),u=n(7751),f=n(4114),d=n(3639),h=n(5250),m=n(1018),p=n(3414),v=n(7566),x=n(833),g=n(6941),y=n(847),b=n(6338),I=n(9620),A=n(9936),E=n(9186),S=n(2212),T=n(8924),w=n(9201),C=n(5338),R=n(7616),P=n(7496),N=n(9011),M=n(1383),D=n(4772),F=n(2229),B=n(5065),L=n(3923),V=n(7193),z=n(6235),G=n(2345),O=n(9993),U=n(103),k=n(8806),W=n(2216),Q=n(1257),q=n(8321),X=n(3497);class H{constructor(){}static __generateGroupEntity(e){const t=(0,k.P)();return this.addTags(t,e),t}static addTags(e,t){e.tryToSetTag({tag:"SourceType",value:t.asset.extras.fileType}),e.tryToSetTag({tag:"SourceTypeVersion",value:t.asset.extras.version})}static __generateMeshEntity(e){const t=(0,W.j)();return this.addTags(t,e),t}static __generateCameraEntity(e){const t=(0,q.v)();return this.addTags(t,e),t}static __generateLightEntity(e){const t=(0,Q.G)();return this.addTags(t,e),t}static __setupMaterials(e){const t=[];if(null!=e.materials)for(const n of e.materials){const o=this.__setupMaterial(e,n);t.push(o)}return t}static convertToRhodoniteObject(e){var t;e.asset.extras.rnMeshesAtGltMeshIdx=[];const n=this.createRnBuffer(e);e.asset.extras.rnMaterials={};const o=this.__setupMaterials(e),{rnEntities:a,rnEntitiesByNames:i}=this.__setupObjects(e,n,o);e.asset.extras.rnEntities=a,this._setupTransform(e,a);const r=this.__generateGroupEntity(e);if(this._setupAnimation(e,a,n,r),this._setupSkeleton(e,a,n),this._setupHierarchy(e,a),r.tryToSetUniqueName("FileRoot",!0),r.tryToSetTag({tag:"ObjectType",value:"top"}),e.scenes[0].nodes)for(const t of e.scenes[0].nodes){const e=a[t].getSceneGraph();r.getSceneGraph().addChild(e)}if(e.asset.extras&&e.asset.extras.rnLoaderOptions){const n=e.asset.extras.rnLoaderOptions;n&&n.loaderExtension&&(null===(t=null==n?void 0:n.loaderExtension)||void 0===t?void 0:t.loadExtensionInfoAndSetToRootGroup)&&n.loaderExtension.loadExtensionInfoAndSetToRootGroup(r,e),n&&n.expression&&n.expression.tryToSetTag({tag:"gltfModel",value:e})}return r.tryToSetTag({tag:"rnEntities",value:a}),r.tryToSetTag({tag:"rnEntitiesByNames",value:i}),r.tryToSetTag({tag:"gltfModel",value:e}),F.Is.not.exist(e.extras)&&(e.extras={}),e.extras.rnEntities=a,e.extras.rnEntitiesByNames=i,G.j.importEffect(e,r),G.j.importBillboard(e,a),F.Is.exist(e.extensionsUsed)&&e.extensionsUsed.indexOf("VRMC_vrm"),r}static createRnBuffer(e){const t=[];for(const n of e.buffers){const e=new c.h({byteLength:n.byteLength,buffer:n.buffer,name:`gltf2Buffer_0_(${n.uri})`,byteAlign:4});t.push(e)}return t}static _setupTransform(e,t){for(const n in e.nodes){const o=t[n],a=e.nodes[n],l=o.getTransform();a.translation&&(l.localPosition=i.Pq.fromCopyArray([a.translation[0],a.translation[1],a.translation[2]])),a.scale&&(l.localScale=i.Pq.fromCopyArray([a.scale[0],a.scale[1],a.scale[2]])),a.rotation&&(l.localRotation=r.P.fromCopy4(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3])),a.matrix&&(l.localMatrix=s._.fromCopyArrayColumnMajor(a.matrix))}}static _setupHierarchy(e,t){const n=t.map((e=>e.getSceneGraph()));for(const t in e.nodes){const o=parseInt(t),a=e.nodes[o];if(F.Is.exist(a.children)){const e=n[o];for(const t of a.children){const o=n[t];e.addChild(o)}}}}static _setupAnimation(e,t,n,a){var i;if(null!=e.animations&&0!==e.animations.length){o.YY.addComponentToEntity(U.v,a);for(const t of e.animations)for(const e of t.samplers)this._readBinaryFromAccessorAndSetItToAccessorExtras(e.inputObject,n),this._readBinaryFromAccessorAndSetItToAccessorExtras(e.outputObject,n);for(const n of e.animations)for(const e of n.channels)if(F.Is.exist(e.samplerObject)){const a=e.samplerObject.inputObject.extras.typedDataArray,r=e.samplerObject.outputObject.extras.typedDataArray,s=null!==(i=e.samplerObject.interpolation)&&void 0!==i?i:"LINEAR";let l="undefined";l="translation"===e.target.path?"translate":"rotation"===e.target.path?"quaternion":e.target.path;const c=t[e.target.node];if(F.Is.exist(c)){let t=c.tryToGetAnimation();if(F.Is.not.exist(t)&&(t=o.YY.addComponentToEntity(v.C,c).getAnimation()),F.Is.exist(t)){const o=e.samplerObject.outputObject.extras.componentN;t.setAnimation(F.Is.exist(n.name)?n.name:"Untitled_Animation",l,a,r,o,x.v.fromString(s))}}}}}static _setupSkeleton(e,t,n){if(null!=e.skins)for(const a in e.nodes){const i=e.nodes[a],r=t[a].getSceneGraph();let l;if(F.Is.exist(i.skinObject)){const e=t[a];if(l=o.YY.addComponentToEntity(y.D,e).getSkeletal(),F.Is.exist(i.skinObject.bindShapeMatrix)&&(l._bindShapeMatrix=s._.fromCopyArrayColumnMajor(i.skinObject.bindShapeMatrix)),F.Is.exist(i.skinObject.skeleton)&&(r.isRootJoint=!0,F.Is.exist(i.mesh))){const e=[];for(const n of i.skinObject.joints)e.push(t[n].getSceneGraph());l.setJoints(e),F.Is.exist(i.skinObject.skeleton)?l.topOfJointsHierarchy=t[i.skinObject.skeleton].getSceneGraph():l.topOfJointsHierarchy=e[0]}for(const e of i.skinObject.joints)t[e].getSceneGraph().jointIndex=e;const c=i.skinObject.inverseBindMatricesObject;if(F.Is.exist(c)){const e=this.__getRnBufferViewAndRnAccessor(c,n);l.setInverseBindMatricesAccessor(e)}}}}static __setupObjects(e,t,n){var i,r,s,l,c;const _=[],u=new Map;for(const f in e.nodes){const d=e.nodes[parseInt(f)];let h;if(null!=d.mesh){const o=d.mesh,r=this.__setupMesh(d.meshObject,o,t,e,n);d.name&&r.tryToSetUniqueName(d.name,!0),(null===(i=d.meshObject)||void 0===i?void 0:i.name)&&r.getComponent(a.F).tryToSetUniqueName(d.meshObject.name,!0),h=r}else if(null!=d.cameraObject){const t=this.__setupCamera(d.cameraObject,e);d.name&&t.tryToSetUniqueName(d.name,!0),h=t}else if(null===(r=d.extensions)||void 0===r?void 0:r.KHR_lights_punctual)h=this.__setupLight(d.extensions.KHR_lights_punctual.light,e);else{const t=this.__generateGroupEntity(e);d.name&&t.tryToSetUniqueName(d.name,!0),h=t}if(this.__isMorphing(d,e)){let e=[];if(d.weights)e=d.weights;else if(null===(s=d.meshObject)||void 0===s?void 0:s.weights)e=d.meshObject.weights;else{let t=0;for(const e of d.meshObject.primitives)F.Is.exist(e.targets)&&e.targets.length>t&&(t=e.targets.length);e=new Array(t).fill(0)}h=o.YY.addComponentToEntity(V.W,h);const t=h.getBlendShape();t.weights=e,(null===(c=null===(l=d.meshObject)||void 0===l?void 0:l.primitives[0].extras)||void 0===c?void 0:c.targetNames)&&(t.targetNames=d.meshObject.primitives[0].extras.targetNames)}h.tryToSetTag({tag:L.q,value:f}),_.push(h),u.set(d.name,h)}return{rnEntities:_,rnEntitiesByNames:u}}static __isMorphing(e,t){var n,o,a;const i=null===(o=null===(n=t.asset.extras)||void 0===n?void 0:n.rnLoaderOptions)||void 0===o?void 0:o.defaultMaterialHelperArgumentArray[0];return!1!==(null==i?void 0:i.isMorphing)&&null!=(null===(a=e.meshObject)||void 0===a?void 0:a.primitives[0].targets)}static __setupLight(e,t){var n,o;const a=this.__generateLightEntity(t),r=a.getComponent(z.M);if(null!=e.name){r.tryToSetUniqueName(e.name,!0),r.type=w.z.fromString(e.type);let t=i.Pq.fromCopyArray3([1,1,1]),a=1;null!=e.color&&(t=i.Pq.fromCopyArray3(e.color)),null!=e.intensity&&(a=e.intensity),r.intensity=i.Pq.multiply(t,a),null!=e.range&&(r.range=e.range),"spot"===e.type&&(null!=(null===(n=e.spot)||void 0===n?void 0:n.innerConeAngle)&&(r.innerConeAngle=e.spot.innerConeAngle),null!=(null===(o=e.spot)||void 0===o?void 0:o.outerConeAngle)&&(r.outerConeAngle=e.spot.outerConeAngle))}return a}static __setupCamera(e,t){const n=this.__generateCameraEntity(t),o=n.getCamera();return o.direction=i.Pq.fromCopyArray([0,0,-1]),t.asset&&t.asset.LastSaved_ApplicationVendor&&(o.direction=i.Pq.fromCopyArray([1,0,0]),o.directionInner=i.Pq.fromCopyArray([1,0,0])),o.up=i.Pq.fromCopyArray([0,1,0]),o.type=h.A.fromString(e.type),o.type===h.A.Perspective?(o.aspect=e.perspective.aspectRatio?e.perspective.aspectRatio:1,o.setFovyAndChangeFocalLength(g.z.radianToDegree(e.perspective.yfov)),o.zNear=e.perspective.znear,o.zFar=e.perspective.zfar?e.perspective.zfar:1e5,o.tryToSetTag({tag:"OriginalFovY",value:o.fovy})):o.type===h.A.Orthographic&&(o.xMag=e.orthographic.xmag,o.yMag=e.orthographic.ymag,o.zNear=e.orthographic.znear,o.zFar=e.orthographic.zfar,o.tryToSetTag({tag:"OriginalXMag",value:o.xMag}),o.tryToSetTag({tag:"OriginalYMag",value:o.yMag})),o.tryToSetTag({tag:"OriginalAspect",value:o.aspect}),n}static __setupMesh(e,t,n,o,a){var i,r,s,c,u;const f=this.__generateMeshEntity(o),h=null===(i=o.asset.extras.rnMeshesAtGltMeshIdx[t])||void 0===i?void 0:i.deref();let m=_.R.Triangles;const p=f.getMesh();if(null!=h)p.setMesh(h);else{const i=new S.e,f=o.asset.extras.rnLoaderOptions;null!=(null==f?void 0:f.tangentCalculationMode)&&(i.tangentCalculationMode=f.tangentCalculationMode);const h=(e,t)=>{const n=t.materialVariants;if(!F.Is.not.exist(n))for(const t of n){const n=a[t.material];for(const o of t.variants)e.setMaterialVariant(o,n)}};for(const t in e.primitives){const p=e.primitives[t];null!=p.mode&&(m=_.R.from(p.mode));const v=new l.s,x=null!=p.material?a[p.material]:this.__setupMaterial(o);if(h(v,p),-1!==x.materialTypeName.indexOf("MToon")){const e=o.extensions.VRM;if(null!=(null==e?void 0:e.rnExtension)){const t=e.rnExtension.renderPassOutline,n=null===(c=null===(s=null===(r=p.materialObject)||void 0===r?void 0:r.extras)||void 0===s?void 0:s.outlineMaterial)||void 0===c?void 0:c.deref();null!=n&&(t.setMaterialForPrimitive(n,v),v.setMaterialVariant("outline",n))}}let g;const y=new Map;if(null===(u=p.extensions)||void 0===u?void 0:u.KHR_draco_mesh_compression){if(g=this.__decodeDraco(p,n,o,y),F.Is.not.exist(g))break}else{F.Is.exist(p.indices)&&(g=this.__getRnBufferViewAndRnAccessor(p.indicesObject,n));const e=new Map;for(const t in p.attributesObjects){const o=p.attributesObjects[t],a=n[o.bufferViewObject.buffer];let i;F.Is.exist(o.bufferView)?(i=e.get(o.bufferView),F.Is.not.exist(i)&&(i=this.__getRnBufferView(o.bufferViewObject,a),e.set(o.bufferView,i))):i=a.takeBufferView({byteLengthToNeed:0,byteStride:0}).unwrapForce();const r=this.__getRnAccessor(o,i),s=d.r.toVertexAttributeSemanticJoinedStringAsGltfStyle(d.r.fromString(o.extras.attributeName));y.set(s,r)}}if(v.setData(y,m,x,g),null!=p.targets){let e=C.T.maxMorphTargetNumber;null!=(null==f?void 0:f.maxMorphTargetNumber)&&(e=f.maxMorphTargetNumber);const t=[];for(let o=0;o<p.targetsObjects.length&&!(o>=e);o++){const e=p.targetsObjects[o],a=new Map;for(const t in e){const o=e[t],i=this.__getRnBufferViewAndRnAccessor(o,n),r=this.__copyRnAccessorAndBufferView(i),s=d.r.fromString(t),l=d.r.toVertexAttributeSemanticJoinedStringAsGltfStyle(s);a.set(l,r)}t.push(a)}v.setBlendShapeTargets(t)}i.addPrimitive(v)}p.setMesh(i),o.asset.extras.rnMeshesAtGltMeshIdx[t]=new WeakRef(i)}return f}static setSparseAccessor(e,t){var n,o,a,i;const r=e.sparse.count,s=e.sparse.indices,l=s.bufferViewObject;let c=s.bufferViewObject.bufferObject.buffer;const _=(null!==(n=l.byteOffset)&&void 0!==n?n:0)+(null!==(o=s.byteOffset)&&void 0!==o?o:0),u=this._checkBytesPerComponent(s),f=u*r,d=new DataView(c.buffer,_+c.byteOffset,f),h=this._checkDataViewMethod(s),m=e.sparse.values,p=m.bufferViewObject;c=m.bufferViewObject.bufferObject.buffer;const v=(null!==(a=p.byteOffset)&&void 0!==a?a:0)+(null!==(i=m.byteOffset)&&void 0!==i?i:0),x=this._checkBytesPerComponent(e),g=this._checkComponentNumber(e),y=x*g*r,b=new DataView(c.buffer,v+c.byteOffset,y),I=this._checkDataViewMethod(e),A=t.getTypedArray(),E=!0;for(let e=0;e<r;e++){const t=d[h](u*e,E);for(let n=0;n<g;n++){const o=b[I](x*g*e+x*n,E);A[t*g+n]=o}}}static __setVRM1Material(e,t,n){var o;const a=e.extensions.VRM,i=null===(o=t.extensions)||void 0===o?void 0:o.VRMC_materials_mtoon;if(null!=i){const o=n.defaultMaterialHelperArgumentArray[0],r=o.additionalName,s=!0,l=!0,c=this.__isLighting(e,t),_=!0,u=o.textures,f=o.samplers,d=o.debugMode,h=o.maxInstancesNumber,m=this.__makeOutputSrgb(e);let p;if(F.Is.exist(null==a?void 0:a.rnExtension)&&(p=a.rnExtension.renderPassOutline,p.isVrRendering=!0,p.tryToSetUniqueName("VRM Outline RenderPass",!0)),null!=p){let e;"none"!==i.outlineWidthMode&&(e=I.m.createMToon1Material({additionalName:r,isMorphing:s,isSkinning:l,isLighting:c,useTangentAttribute:_,isOutline:!0,materialJson:t,textures:u,samplers:f,debugMode:d,maxInstancesNumber:h,makeOutputSrgb:m})),F.Is.exist(e)&&(t.extras.outlineMaterial=new WeakRef(e))}const v=I.m.createMToon1Material({additionalName:r,isMorphing:s,isSkinning:l,isLighting:c,useTangentAttribute:_,isOutline:!1,materialJson:t,textures:u,samplers:f,debugMode:d,maxInstancesNumber:h,makeOutputSrgb:m});return t.extensions.KHR_materials_unlit=void 0,v}}static setMToonTextures(e,t,n,o){const a=e[t.textureProperties._MainTex];null!=a&&n.setTextureParameter("litColorTexture",a,o[t.textureProperties._MainTex]);const i=e[t.textureProperties._ShadeTexture];null!=i&&n.setTextureParameter("shadeColorTexture",i,o[t.textureProperties._ShadeTexture]);const r=e[t.textureProperties._ReceiveShadowTexture];null!=r&&n.setTextureParameter("receiveShadowTexture",r,o[t.textureProperties._ReceiveShadowTexture]);const s=e[t.textureProperties._ShadingGradeTexture];null!=s&&n.setTextureParameter("shadingGradeTexture",s,o[t.textureProperties._ShadingGradeTexture]);const l=e[t.textureProperties._RimTexture];null!=l&&n.setTextureParameter("rimTexture",l,o[t.textureProperties._RimTexture]);const c=e[t.textureProperties._SphereAdd];null!=c&&n.setTextureParameter("matCapTexture",c,o[t.textureProperties._SphereAdd]);const _=e[t.textureProperties._EmissionMap];null!=_&&n.setTextureParameter("emissionTexture",_,o[t.textureProperties._EmissionMap]);const u=e[t.textureProperties._BumpMap];null!=u&&n.setTextureParameter("normalTexture",u,o[t.textureProperties._BumpMap]);const f=e[t.textureProperties._OutlineWidthTexture];null!=f&&n.setTextureParameter("outlineWidthTexture",f,o[t.textureProperties._OutlineWidthTexture]);const d=e[t.textureProperties._UvAnimMaskTexture];null!=d&&n.setTextureParameter("uvAnimationMaskTexture",d,o[t.textureProperties._UvAnimMaskTexture])}static __setVRM0xMaterial(e,t,n){const o=e.extensions.VRM,a=t.extras.vrm0xMaterialProperty;if("VRM/MToon"===a.shader){const i=n.defaultMaterialHelperArgumentArray[0],r=i.additionalName,s=!0,l=!0,c=this.__isLighting(e,t),_=!0,u=i.textures,f=i.samplers,d=i.debugMode,h=i.maxInstancesNumber,m=this.__makeOutputSrgb(e);let p;if(F.Is.exist(null==o?void 0:o.rnExtension)&&(p=o.rnExtension.renderPassOutline,p.isVrRendering=!0,p.tryToSetUniqueName("VRM Outline RenderPass",!0)),null!=p){let e;0!==a.floatProperties._OutlineWidthMode&&(e=I.m.createMToon0xMaterial({additionalName:r,isMorphing:s,isSkinning:l,isLighting:c,useTangentAttribute:_,isOutline:!0,materialProperties:a,textures:u,samplers:f,debugMode:d,maxInstancesNumber:h,makeOutputSrgb:m})),F.Is.exist(e)&&(H.setMToonTextures(u,a,e,f),t.extras.outlineMaterial=new WeakRef(e))}const v=I.m.createMToon0xMaterial({additionalName:r,isMorphing:s,isSkinning:l,isLighting:c,useTangentAttribute:_,isOutline:!1,materialProperties:a,textures:u,samplers:f,debugMode:d,maxInstancesNumber:h,makeOutputSrgb:m});return H.setMToonTextures(u,a,v,f),v}}static __generateAppropriateMaterial(e,t){var n,o,a,i,r,s,l,c,_,u,f,d,h,m,p,v;const x=F.Is.exist(null===(n=null==t?void 0:t.extensions)||void 0===n?void 0:n.KHR_materials_transmission);if(null!=(null===(o=e.asset.extras)||void 0===o?void 0:o.rnLoaderOptions)){const n=e.asset.extras.rnLoaderOptions;if(null!=(null===(a=n.loaderExtension)||void 0===a?void 0:a.isNeededToUseThisMaterial)&&n.loaderExtension.isNeededToUseThisMaterial(e)){const n=null===(r=null===(i=e.asset.extras)||void 0===i?void 0:i.rnLoaderOptions)||void 0===r?void 0:r.loaderExtension;if(null!=(null==n?void 0:n.generateMaterial))return n.generateMaterial(t)}if(n.__isImportVRM0x){const o=this.__setVRM0xMaterial(e,t,n);if(F.Is.exist(o))return o.isTranslucent=x,o}const o=n.defaultMaterialHelperName;if(null!=o)return I.m[o](...n.defaultMaterialHelperArgumentArray)}const g=!0,y=this.__isLighting(e,t);if(F.Is.exist(t)&&null!=(null===(s=t.extensions)||void 0===s?void 0:s.VRMC_materials_mtoon)){const n=e.asset.extras.rnLoaderOptions,o=this.__setVRM1Material(e,t,n);if(F.Is.exist(o))return o.isTranslucent=x,o}const b=C.T.maxMaterialInstanceForEachType;if(parseFloat(null===(l=e.asset)||void 0===l?void 0:l.version)>=2){const n=null!==(_=null===(c=e.asset.extras)||void 0===c?void 0:c.rnLoaderOptions)&&void 0!==_?_:{},o=!0,a=this.__useNormalTexture(e),i=I.m.createPbrUberMaterial({isMorphing:!0,isSkinning:g,isLighting:y,isClearCoat:F.Is.exist(null===(u=null==t?void 0:t.extensions)||void 0===u?void 0:u.KHR_materials_clearcoat),isTransmission:F.Is.exist(null===(f=null==t?void 0:t.extensions)||void 0===f?void 0:f.KHR_materials_transmission),isVolume:F.Is.exist(null===(d=null==t?void 0:t.extensions)||void 0===d?void 0:d.KHR_materials_volume),isSheen:F.Is.exist(null===(h=null==t?void 0:t.extensions)||void 0===h?void 0:h.KHR_materials_sheen),isSpecular:F.Is.exist(null===(m=null==t?void 0:t.extensions)||void 0===m?void 0:m.KHR_materials_specular),isIridescence:F.Is.exist(null===(p=null==t?void 0:t.extensions)||void 0===p?void 0:p.KHR_materials_iridescence),isAnisotropy:F.Is.exist(null===(v=null==t?void 0:t.extensions)||void 0===v?void 0:v.KHR_materials_anisotropy),isShadow:!!n.shadow,useTangentAttribute:o,useNormalTexture:a,additionalName:"",maxInstancesNumber:b}),r=this.__makeOutputSrgb(e);return F.Is.exist(r)&&i.setParameter("makeOutputSrgb",r),i.isTranslucent=x,i}{const e=I.m.createClassicUberMaterial({isSkinning:g,isLighting:y,additionalName:"",maxInstancesNumber:b});return e.isTranslucent=x,e}}static __isLighting(e,t){var n,o,a,i;const r=null===(a=null===(o=null===(n=null==e?void 0:e.asset)||void 0===n?void 0:n.extras)||void 0===o?void 0:o.rnLoaderOptions)||void 0===a?void 0:a.defaultMaterialHelperArgumentArray[0];return null!=(null==r?void 0:r.isLighting)?r.isLighting:null==(null===(i=null==t?void 0:t.extensions)||void 0===i?void 0:i.KHR_materials_unlit)}static __useTangentAttribute(e,t){var n,o,a;switch(null===(a=null===(o=null===(n=null==e?void 0:e.asset)||void 0===n?void 0:n.extras)||void 0===o?void 0:o.rnLoaderOptions)||void 0===a?void 0:a.tangentCalculationMode){case 0:case 3:return!1;case 1:break;case 2:case 4:return!0}for(const e in t.attributes)if("TANGENT"===e)return!0;return!1}static __useNormalTexture(e){var t,n,o,a,i,r;const s=null===(o=null===(n=null===(t=null==e?void 0:e.asset)||void 0===t?void 0:t.extras)||void 0===n?void 0:n.rnLoaderOptions)||void 0===o?void 0:o.defaultMaterialHelperArgumentArray[0];return!1!==(null==s?void 0:s.useNormalTexture)&&0!==(null===(r=null===(i=null===(a=null==e?void 0:e.asset)||void 0===a?void 0:a.extras)||void 0===i?void 0:i.rnLoaderOptions)||void 0===r?void 0:r.tangentCalculationMode)}static __makeOutputSrgb(e){var t,n,o;const a=null===(o=null===(n=null===(t=null==e?void 0:e.asset)||void 0===t?void 0:t.extras)||void 0===n?void 0:n.rnLoaderOptions)||void 0===o?void 0:o.defaultMaterialHelperArgumentArray[0];return null==a?void 0:a.makeOutputSrgb}static __setupMaterial(e,t){var n;const o=this.__generateAppropriateMaterial(e,t);return null==t||(H.setParametersToMaterial(t,e,o,!1),null!=(null===(n=t.extras)||void 0===n?void 0:n.outlineMaterial)&&H.setParametersToMaterial(t,e,t.extras.outlineMaterial.deref(),!0)),o}static setParametersToMaterial(e,t,n,o){var a,r,s,l,c,_,u,f,d,h,m;const v=null!=(null===(a=e.extensions)||void 0===a?void 0:a.KHR_materials_unlit),x=t.asset.extras.rnLoaderOptions,g=e.pbrMetallicRoughness;if(null!=g)!function(e,t,n,o,a){var r;const s=null!=(null===(r=a.extensions)||void 0===r?void 0:r.KHR_materials_unlit),l=e.baseColorFactor;null!=l&&t.setParameter("baseColorFactor",p.IU.fromCopyArray4(l));const c=e.baseColorTexture;if(null!=c){const e=H._createTexture(c.texture,n,{autoDetectTransparency:null==o?void 0:o.autoDetectTextureTransparency}),a=H._createSampler(c.texture);t.setTextureParameter("baseColorTexture",e,a),null!=c.texCoord&&t.setParameter("baseColorTexcoordIndex",c.texCoord),H._setupTextureTransform(c,t,"baseColorTextureTransform","baseColorTextureRotation")}const _=a.occlusionTexture;if(null!=_&&F.Is.falsy(s)){const e=H._createTexture(_.texture,n),o=H._createSampler(_.texture);t.setTextureParameter("occlusionTexture",e,o),null!=_.texCoord&&t.setParameter("occlusionTexcoordIndex",_.texCoord),null!=_.strength&&t.setParameter("occlusionStrength",_.strength),H._setupTextureTransform(_,t,"occlusionTextureTransform","occlusionTextureRotation")}let u=e.metallicFactor;u=s?0:null!=u?u:1;let f=e.roughnessFactor;f=s?1:null!=f?f:1,t.setParameter("metallicRoughnessFactor",A.I9.fromCopyArray2([u,f]));const d=e.metallicRoughnessTexture;if(null!=d&&F.Is.falsy(s)){const e=H._createTexture(d.texture,n),o=H._createSampler(d.texture);t.setTextureParameter("metallicRoughnessTexture",e,o),null!=d.texCoord&&t.setParameter("metallicRoughnessTexcoordIndex",d.texCoord),H._setupTextureTransform(d,t,"metallicRoughnessTextureTransform","metallicRoughnessTextureRotation")}!function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_clearcoat;if(F.Is.exist(a)){const e=F.Is.exist(a.clearcoatFactor)?a.clearcoatFactor:0;t.setParameter("clearCoatFactor",e);const o=a.clearcoatTexture;if(null!=o){const e=H._createTexture(o.texture,n),a=H._createSampler(o.texture);t.setTextureParameter("clearCoatTexture",e,a),null!=o.texCoord&&t.setParameter("clearCoatTexcoordIndex",o.texCoord),H._setupTextureTransform(o,t,"clearCoatTextureTransform","clearCoatTextureRotation")}const i=F.Is.exist(a.clearcoatRoughnessFactor)?a.clearcoatRoughnessFactor:0;t.setParameter("clearCoatRoughnessFactor",i);const r=a.clearcoatRoughnessTexture;if(null!=r){const e=H._createTexture(r.texture,n),o=H._createSampler(r.texture);t.setTextureParameter("clearCoatRoughnessTexture",e,o),null!=r.texCoord&&t.setParameter("clearCoatRoughnessTexcoordIndex",r.texCoord),H._setupTextureTransform(r,t,"clearCoatRoughnessTextureTransform","clearCoatRoughnessTextureRotation")}const s=a.clearcoatNormalTexture;if(null!=s){const e=H._createTexture(s.texture,n),o=H._createSampler(s.texture);t.setTextureParameter("clearCoatNormalTexture",e,o),null!=s.texCoord&&t.setParameter("clearCoatNormalTexcoordIndex",s.texCoord),H._setupTextureTransform(s,t,"clearCoatNormalTextureTransform","clearCoatNormalTextureRotation")}}}(a,t,n);const h=function(e,t,n){var o;const a=null===(o=e.extensions)||void 0===o?void 0:o.KHR_materials_transmission;if(F.Is.exist(a)){const e=F.Is.exist(a.transmissionFactor)?a.transmissionFactor:0;t.setParameter("transmissionFactor",e);const o=a.transmissionTexture;if(F.Is.exist(o)){const e=H._createTexture(o.texture,n),a=H._createSampler(o.texture);t.setTextureParameter("transmissionTexture",e,a)}return!0}return!1}(a,t,n);o.transmission||(o.transmission=h),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_volume;if(F.Is.exist(a)){const e=a.thicknessFactor?a.thicknessFactor:0;null!=e&&t.setParameter("thicknessFactor",e);const o=a.thicknessTexture;if(null!=o){const e=H._createTexture(o.texture,n),a=H._createSampler(o.texture);t.setTextureParameter("thicknessTexture",e,a)}const r=a.attenuationDistance?a.attenuationDistance:0;null!=r&&t.setParameter("attenuationDistance",r);const s=a.attenuationColor?i.Pq.fromCopyArray3(a.attenuationColor):i.Pq.fromCopy3(1,1,1);null!=s&&t.setParameter("attenuationColor",s)}}(a,t,n),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_sheen;if(F.Is.exist(a)){const e=F.Is.exist(a.sheenColorFactor)?a.sheenColorFactor:[0,0,0];t.setParameter("sheenColorFactor",i.Pq.fromCopyArray3(e));const o=a.sheenColorTexture;if(null!=o){const e=H._createTexture(o.texture,n),a=H._createSampler(o.texture);t.setTextureParameter("sheenColorTexture",e,a)}const r=F.Is.exist(a.sheenRoughnessFactor)?a.sheenRoughnessFactor:0;t.setParameter("sheenRoughnessFactor",r);const s=a.sheenRoughnessTexture;if(null!=s){const e=H._createTexture(s.texture,n),o=H._createSampler(s.texture);t.setTextureParameter("sheenRoughnessTexture",e,o)}}}(a,t,n),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_specular;if(F.Is.exist(a)){const e=F.Is.exist(a.specularFactor)?a.specularFactor:1;t.setParameter("specularFactor",e);const o=a.specularTexture;if(null!=o){const e=H._createTexture(o.texture,n),a=H._createSampler(o.texture);t.setTextureParameter("specularTexture",e,a)}const r=F.Is.exist(a.specularColorFactor)?a.specularColorFactor:[1,1,1];t.setParameter("specularColorFactor",i.Pq.fromCopyArray3(r));const s=a.specularColorTexture;if(null!=s){const e=H._createTexture(s.texture,n),o=H._createSampler(s.texture);t.setTextureParameter("specularColorTexture",e,o)}}}(a,t,n),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_ior;if(F.Is.exist(a)){const e=F.Is.exist(a.ior)?a.ior:1.5;t.setParameter("ior",e)}}(a,t),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_iridescence;if(F.Is.exist(a)){const e=F.Is.exist(a.iridescenceFactor)?a.iridescenceFactor:0;t.setParameter("iridescenceFactor",e);const o=a.iridescenceTexture;if(null!=o){const e=H._createTexture(o.texture,n),a=H._createSampler(o.texture);t.setTextureParameter("iridescenceTexture",e,a)}const i=F.Is.exist(a.iridescenceIor)?a.iridescenceIor:1.3;t.setParameter("iridescenceIor",i);const r=F.Is.exist(a.iridescenceThicknessMinimum)?a.iridescenceThicknessMinimum:100;t.setParameter("iridescenceThicknessMinimum",r);const s=F.Is.exist(a.iridescenceThicknessMaximum)?a.iridescenceThicknessMaximum:400;t.setParameter("iridescenceThicknessMaximum",s);const l=a.iridescenceThicknessTexture;if(null!=l){const e=H._createTexture(l.texture,n),o=H._createSampler(l.texture);t.setTextureParameter("iridescenceThicknessTexture",e,o)}}}(a,t,n),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_anisotropy;if(F.Is.exist(a)){const e=F.Is.exist(a.anisotropyStrength)?a.anisotropyStrength:0;t.setParameter("anisotropyStrength",e);const o=F.Is.exist(a.anisotropyRotation)?a.anisotropyRotation:0;t.setParameter("anisotropyRotation",A.I9.fromCopy2(Math.cos(o),Math.sin(o)));const i=a.anisotropyTexture;if(null!=i){const e=H._createTexture(i.texture,n),o=H._createSampler(i.texture);t.setTextureParameter("anisotropyTexture",e,o)}}}(a,t,n),function(e,t,n){var o;const a=null===(o=null==e?void 0:e.extensions)||void 0===o?void 0:o.KHR_materials_emissive_strength;if(F.Is.exist(a)){const e=F.Is.exist(a.emissiveStrength)?a.emissiveStrength:1;t.setParameter("emissiveStrength",e)}}(a,t)}(g,n,t,x,e);else{let t=E.y.Phong.index;if(null===(r=null==e?void 0:e.extras)||void 0===r?void 0:r.technique){switch(e.extras.technique){case E.y.Constant.str:t=E.y.Constant.index;break;case E.y.Lambert.str:t=E.y.Lambert.index;break;case E.y.BlinnPhong.str:t=E.y.BlinnPhong.index;break;case E.y.Phong.str:t=E.y.Phong.index}n.setParameter("shadingModel",N.X5.fromCopyNumber(t))}}const y=v?[0,0,0]:e.emissiveFactor;null!=y&&n.setParameter("emissiveFactor",i.Pq.fromCopyArray3(y));const I=e.emissiveTexture;if(null!=I&&F.Is.falsy(v)){const e=H._createTexture(I.texture,t),o=H._createSampler(I.texture);n.setTextureParameter("emissiveTexture",e,o),parseFloat(null===(s=t.asset)||void 0===s?void 0:s.version)>=2&&null!=I.texCoord&&n.setParameter("emissiveTexcoordIndex",I.texCoord),H._setupTextureTransform(I,n,"emissiveTextureTransform","emissiveTextureRotation")}let S=e.alphaMode;(null==x?void 0:x.alphaMode)&&(S=x.alphaMode),null!=S&&(n.alphaMode=b.K.fromGlTFString(S),n.alphaMode!==b.K.Mask||(null===(c=null===(l=t.asset.extras)||void 0===l?void 0:l.rnLoaderOptions)||void 0===c?void 0:c.__isImportVRM0x)||n.setParameter("alphaCutoff",N.X5.fromCopyNumber(null!==(_=e.alphaCutoff)&&void 0!==_?_:.5))),n.isTranslucent=F.Is.exist(null===(u=e.extensions)||void 0===u?void 0:u.KHR_materials_transmission);const T=e.doubleSided;null==T||o||(n.cullFace=!T);const w=e.normalTexture;if(null!=w&&F.Is.falsy(v)){const e=H._createTexture(w.texture,t),o=H._createSampler(w.texture);n.setTextureParameter("normalTexture",e,o),parseFloat(null===(f=t.asset)||void 0===f?void 0:f.version)>=2&&(null!=w.texCoord&&n.setParameter("normalTexcoordIndex",w.texCoord),null!=w.scale&&n.setParameter("normalScale",w.scale))}if(H._setupTextureTransform(w,n,"normalTextureTransform","normalTextureRotation"),this._checkRnGltfLoaderOptionsExist(t)){const o=null===(h=null===(d=t.asset.extras)||void 0===d?void 0:d.rnLoaderOptions)||void 0===h?void 0:h.loaderExtension;null!=(null==o?void 0:o.setupMaterial)&&o.setupMaterial(t,e,n)}null!=(null===(m=e.extensions)||void 0===m?void 0:m.VRMC_materials_mtoon)&&function(e,t,n){const o=n.extensions.VRMC_materials_mtoon;{const t=o.shadeColorFactor;e.setParameter("shadeColorFactor",i.Pq.fromCopyArray3(t))}{const n=o.shadeMultiplyTexture;if(null!=n){const o=H._createTexture(n.texture,t),a=H._createSampler(n.texture);e.setTextureParameter("shadeMultiplyTexture",o,a),null!=n.texCoord&&e.setParameter("shadeMultiplyTexcoordIndex",n.texCoord)}}{const t=o.shadingShiftFactor;null!=t&&e.setParameter("shadingShiftFactor",t)}{const n=o.shadingShiftTexture;if(null!=n){const o=H._createTexture(n.texture,t),a=H._createSampler(n.texture);e.setTextureParameter("shadingShiftTexture",o,a),null!=n.texCoord&&e.setParameter("shadingShiftTexcoordIndex",n.texCoord);const i=n.scale;null!=i&&e.setParameter("shadingShiftTextureScale",i)}}{const t=o.shadingToonyFactor;null!=t&&e.setParameter("shadingToonyFactor",t)}{const t=o.giEqualizationFactor;null!=t&&e.setParameter("giEqualizationFactor",t)}{const n=o.matcapTexture;if(null!=n){const o=H._createTexture(n.texture,t),a=H._createSampler(n.texture);e.setTextureParameter("matcapTexture",o,a),null!=n.texCoord&&e.setParameter("matcapTexcoordIndex",n.texCoord)}}{const t=o.matcapFactor;null!=t&&e.setParameter("matcapFactor",i.Pq.fromCopyArray3(t))}{const t=o.parametricRimColorFactor;null!=t&&e.setParameter("parametricRimColorFactor",i.Pq.fromCopyArray3(t))}{const t=o.parametricRimFresnelPowerFactor;null!=t&&e.setParameter("parametricRimFresnelPowerFactor",t)}{const t=o.parametricRimLiftFactor;null!=t&&e.setParameter("parametricRimLiftFactor",t)}{const n=o.rimMultiplyTexture;if(null!=n){const o=H._createTexture(n.texture,t),a=H._createSampler(n.texture);e.setTextureParameter("rimMultiplyTexture",o,a),null!=n.texCoord&&e.setParameter("rimMultiplyTexcoordIndex",n.texCoord)}}{const t=o.rimLightingMixFactor;null!=t&&e.setParameter("rimLightingMixFactor",t)}{const t=o.outlineWidthMode;null!=t&&("none"===t?e.setParameter("outlineWidthMode",0):"worldCoordinates"===t?e.setParameter("outlineWidthMode",1):"screenCoordinates"===t&&e.setParameter("outlineWidthMode",2))}{const t=o.outlineWidthFactor;null!=t&&e.setParameter("outlineWidthFactor",t)}{const n=o.outlineWidthMultiplyTexture;if(null!=n){const o=H._createTexture(n.texture,t),a=H._createSampler(n.texture);e.setTextureParameter("outlineWidthMultiplyTexture",o,a)}}{const t=o.outlineColorFactor;null!=t&&e.setParameter("outlineColorFactor",i.Pq.fromCopyArray3(t))}{const t=o.outlineLightingMixFactor;null!=t&&e.setParameter("outlineLightingMixFactor",t)}{const n=o.uvAnimationMaskTexture;if(null!=n){const o=H._createTexture(n.texture,t),a=H._createSampler(n.texture);e.setTextureParameter("uvAnimationMaskTexture",o,a),null!=n.texCoord&&e.setParameter("uvAnimationMaskTexcoordIndex",n.texCoord)}}{const t=o.uvAnimationScrollXSpeedFactor;null!=t&&e.setParameter("uvAnimationScrollXSpeedFactor",t)}{const t=o.uvAnimationScrollYSpeedFactor;null!=t&&e.setParameter("uvAnimationScrollYSpeedFactor",t)}{const t=o.uvAnimationRotationSpeedFactor;null!=t&&e.setParameter("uvAnimationRotationSpeedFactor",t)}}(n,t,e)}static _createSampler(e){var t,n,o,a;const i=new O.L({magFilter:F.Is.exist(null===(t=e.samplerObject)||void 0===t?void 0:t.magFilter)?M.P.from(e.samplerObject.magFilter):M.P.Linear,minFilter:F.Is.exist(null===(n=e.samplerObject)||void 0===n?void 0:n.minFilter)?M.P.from(e.samplerObject.minFilter):M.P.Linear,wrapS:F.Is.exist(null===(o=e.samplerObject)||void 0===o?void 0:o.wrapS)?M.P.from(e.samplerObject.wrapS):M.P.Repeat,wrapT:F.Is.exist(null===(a=e.samplerObject)||void 0===a?void 0:a.wrapT)?M.P.from(e.samplerObject.wrapT):M.P.Repeat});return i.create(),i}static _createTexture(e,t,{autoDetectTransparency:n=!1}={}){var o,a,i,r,s,l,c,_;const u=null===(o=t.asset.extras)||void 0===o?void 0:o.rnLoaderOptions,f=new m.g;f.autoDetectTransparency=n,f.autoResize=!0===(null==u?void 0:u.autoResizeTexture);const d={magFilter:F.Is.exist(null===(a=e.samplerObject)||void 0===a?void 0:a.magFilter)?M.P.from(e.samplerObject.magFilter):M.P.Linear,minFilter:F.Is.exist(null===(i=e.samplerObject)||void 0===i?void 0:i.minFilter)?M.P.from(e.samplerObject.minFilter):M.P.Linear,wrapS:F.Is.exist(null===(r=e.samplerObject)||void 0===r?void 0:r.wrapS)?M.P.from(e.samplerObject.wrapS):M.P.Repeat,wrapT:F.Is.exist(null===(s=e.samplerObject)||void 0===s?void 0:s.wrapT)?M.P.from(e.samplerObject.wrapT):M.P.Repeat},h=e.image;if(h.image){const e=h.image;!(null===(l=D.f.getWebGLResourceRepository().currentWebGLContextWrapper)||void 0===l?void 0:l.isWebGL2)&&!this.__sizeIsPowerOfTwo(e)&&this.__needResizeToPowerOfTwoOnWebGl1(d)&&(f.autoResize=!0),f.generateTextureFromImage(e),f.loadFromImgLazy()}else h.basis?f.generateTextureFromBasis(h.basis,{}):h.ktx2&&f.generateTextureFromKTX2(h.ktx2);if(h.uri)f.name=h.uri;else{const t=null===(c=h.mimeType)||void 0===c?void 0:c.split("/")[1];f.name=null!==(_=h.name)&&void 0!==_?_:e.name+`.${t}`}return f.tryToSetUniqueName(f.name,!0),f}static __needResizeToPowerOfTwoOnWebGl1(e){return e.wrapS!==M.P.ClampToEdge||e.wrapT!==M.P.ClampToEdge||e.minFilter!==M.P.Linear&&e.minFilter!==M.P.Nearest}static __sizeIsPowerOfTwo(e){const t=e.width,n=e.height;return!(t&t-1||n&n-1)}static __needParameterInitialization(e,t){return null!=e}static _checkRnGltfLoaderOptionsExist(e){var t;return!!(null===(t=e.asset.extras)||void 0===t?void 0:t.rnLoaderOptions)}static __rewrapWithTypedArray(e,t,n,o){return new e(t.buffer,n+t.byteOffset,o)}static _checkBytesPerComponent(e){let t=0;switch(e.componentType){case 5120:case 5121:t=1;break;case 5122:case 5123:t=2;break;case 5124:case 5125:case 5126:t=4}return t}static _checkComponentNumber(e){let t=0;switch(e.type){case"SCALAR":t=1;break;case"VEC2":t=2;break;case"VEC3":t=3;break;case"VEC4":t=4;break;case"MAT4":t=16}return t}static _checkDataViewMethod(e){let t="";switch(e.componentType){case 5120:t="getInt8";break;case 5121:t="getUint8";break;case 5122:t="getInt16";break;case 5123:t="getUint16";break;case 5124:t="getInt32";break;case 5125:t="getUint32";break;case 5126:t="getFloat32"}return t}static _isSystemLittleEndian(){return!!new Uint8Array(new Uint16Array([255]).buffer)[0]}static _readBinaryFromAccessorAndSetItToAccessorExtras(e,t){var n,o,a;const i=e.bufferViewObject;let r=(null!==(n=i.byteOffset)&&void 0!==n?n:0)+(null!==(o=e.byteOffset)&&void 0!==o?o:0),s=i.bufferObject.buffer;const l=this._checkComponentNumber(e),c=this._checkBytesPerComponent(e),_=this._checkDataViewMethod(e);F.Is.not.exist(e.extras)&&(e.extras={attributeName:"",toGetAsTypedArray:!0,typedDataArray:new Float32Array,componentN:0,componentBytes:4,dataViewMethod:""}),e.extras.componentN=F.Is.exist(null===(a=e.extras)||void 0===a?void 0:a.weightsArrayLength)?e.extras.weightsArrayLength:l,e.extras.componentBytes=c,e.extras.dataViewMethod=_;const u=c*l*e.count;if(F.Is.exist(t)){const n=t[e.bufferViewObject.buffer],o=this.__getRnBufferView(i,n);s=this.__getRnAccessor(e,o).getUint8Array(),r=0}let f=new Float32Array;const d=[];if(H._isSystemLittleEndian()){let e=new Float32Array;"getFloat32"===_?e=this.__rewrapWithTypedArray(Float32Array,s,r,u/c):"getInt8"===_?e=new Int8Array(s,r,u/c):"getUint8"===_?e=new Uint8Array(s,r,u/c):"getInt16"===_?e=this.__rewrapWithTypedArray(Int16Array,s,r,u/c):"getUint16"===_?e=this.__rewrapWithTypedArray(Uint16Array,s,r,u/c):"getInt32"===_?e=this.__rewrapWithTypedArray(Int32Array,s,r,u/c):"getUint32"===_&&(e=this.__rewrapWithTypedArray(Uint32Array,s,r,u/c)),f=this.__normalizeTypedArrayToFloat32Array(_,e)}else{const t=new DataView(s.buffer,r+s.byteOffset,u),n=c*l,o=!0;for(let a=0;a<u;a+=n)switch(e.type){case"SCALAR":d.push(t[_](a,o));break;case"VEC2":d.push(t[_](a,o)),d.push(t[_](a+c,o));break;case"VEC3":d.push(t[_](a,o)),d.push(t[_](a+c,o)),d.push(t[_](a+2*c,o));break;case"VEC4":for(let e=0;e<4;e++)d.push(t[_](a+c*e,o));break;case"MAT4":for(let e=0;e<16;e++)d.push(t[_](a+c*e,o))}f=this.__normalizeTypedArrayToFloat32Array(_,d)}return e.extras.typedDataArray=f,f}static __normalizeTypedArrayToFloat32Array(e,t){return"getInt8"===e?B.$.normalizedInt8ArrayToFloat32Array(t):"getUint8"===e?B.$.normalizedUint8ArrayToFloat32Array(t):"getInt16"===e?B.$.normalizedInt16ArrayToFloat32Array(t):"getUint16"===e?B.$.normalizedUint16ArrayToFloat32Array(t):"getInt32"===e||"getUint32"===e?(X.V.error("Not considered"),new Float32Array):"getFloat32"===e?new Float32Array(t):(X.V.error("Not considered"),new Float32Array)}static __addOffsetToIndices(e){const t=e.mesh.getPrimitiveNumber();let n=0;for(let o=0;o<t;o++){const t=e.mesh.getPrimitiveAt(o).indicesAccessor;if(t){const e=t.elementCount;for(let o=0;o<e;o++){const e=t.getScalar(o,{});t.setScalar(o,e+n,{})}n+=e}}}static __getRnAccessor(e,t){var n;let o;if(null!=t)o=t.takeAccessorWithByteOffset({compositionType:u.h.fromString(e.type),componentType:f.I.from(e.componentType),count:e.count,byteOffsetInBufferView:null!==(n=e.byteOffset)&&void 0!==n?n:0,byteStride:e.byteStride,max:e.max,min:e.min,normalized:e.normalized}).unwrapForce();else{const t=P.X.getInstance().createOrGetBuffer(R.a.GPUVertexData),n=u.h.fromString(e.type),a=f.I.from(e.componentType);o=t.takeBufferView({byteLengthToNeed:e.count*n.getNumberOfComponents()*a.getSizeInBytes(),byteStride:n.getNumberOfComponents()*a.getSizeInBytes()}).unwrapForce().takeAccessor({compositionType:n,componentType:a,count:e.count,max:e.max,min:e.min,normalized:e.normalized}).unwrapForce()}return F.Is.exist(e.sparse)&&this.setSparseAccessor(e,o),o}static __getRnBufferViewAndRnAccessor(e,t){const n=e.bufferViewObject;let o;if(null!=n){const e=t[n.buffer];o=this.__getRnBufferView(n,e)}return this.__getRnAccessor(e,o)}static __copyRnAccessorAndBufferView(e){const t=3*e.elementCount*4,n=P.X.getInstance().createOrGetBuffer(R.a.GPUVertexData).takeBufferView({byteLengthToNeed:t,byteStride:12}).unwrapForce().takeAccessor({compositionType:u.h.Vec3,componentType:f.I.Float,count:e.elementCount,max:e.max,min:e.min,normalized:e.normalized}).unwrapForce();return n.copyBuffer(e),n}static __takeRnBufferViewAndRnAccessorForDraco(e,t,n){const o=n.takeBufferView({byteLengthToNeed:e.count*t*4,byteStride:0}).unwrapForce();return this.__getRnAccessor(e,o)}static __getRnBufferView(e,t){var n,o;return t.takeBufferViewWithByteOffset({byteLengthToNeed:e.byteLength,byteStride:null!==(n=e.byteStride)&&void 0!==n?n:0,byteOffset:null!==(o=e.byteOffset)&&void 0!==o?o:0}).unwrapForce()}static __getGeometryFromDracoBuffer(e,t,n){const o=new e.DecoderBuffer;o.Init(new Int8Array(n),n.byteLength);const a=t.GetEncodedGeometryType(o);let i,r;if(a===e.TRIANGULAR_MESH)i=new e.Mesh,r=t.DecodeBufferToMesh(o,i);else if(a===e.POINT_CLOUD)i=new e.PointCloud,r=t.DecodeBufferToPointCloud(o,i);else{const e="Unknown geometry type.";X.V.error(e)}if(i.geometryType=a,!r.ok()||0===i.ptr){let n="Decoding failed: ";return n+=r.error_msg(),X.V.error(n),e.destroy(t),void e.destroy(i)}return e.destroy(o),i}static __getIndicesFromDraco(e,t,n,o){if(n.geometryType!==e.TRIANGULAR_MESH)return;let a;if(o){const o=new e.DracoInt32Array;t.GetTriangleStripsFromMesh(n,o),a=new Uint32Array(o.size());for(let e=0;e<o.size();++e)a[e]=o.GetValue(e);e.destroy(o)}else{const o=n.num_faces();a=new Uint32Array(3*o);const i=new e.DracoInt32Array;for(let e=0;e<o;++e){t.GetFaceFromMesh(n,e,i);const o=3*e;a[o]=i.GetValue(0),a[o+1]=i.GetValue(1),a[o+2]=i.GetValue(2)}e.destroy(i)}return a}static __decodeDraco(e,t,n,o){const a=n.bufferViews[e.extensions.KHR_draco_mesh_compression.bufferView],i=this.__getRnBufferView(a,t[a.buffer]),r=new Uint8Array(i.getUint8Array()).buffer,s=new DracoDecoderModule,l=new s.Decoder,c=this.__getGeometryFromDracoBuffer(s,l,r);if(null==c)return s.destroy(c),void s.destroy(l);const f=c.num_points(),h=this.__createBufferForDecompressedData(e,f);let m=!1;_.R.from(e.mode)===_.R.TriangleStrip&&(m=!0);const p=this.__getIndicesFromDraco(s,l,c,m),v=this.__takeRnBufferViewAndRnAccessorForDraco(e.indicesObject,1,h);for(let e=0;e<p.length;e++)v.setScalar(e,p[e],{});for(const n in e.attributes){const a=e.extensions.KHR_draco_mesh_compression.attributes[n],i=e.attributesObjects[n];let r;if(F.Is.not.exist(a))r=this.__getRnBufferViewAndRnAccessor(i,t);else{const e=u.h.fromString(i.type).getNumberOfComponents();r=this.__takeRnBufferViewAndRnAccessorForDraco(i,e,h);const t=l.GetAttributeByUniqueId(c,a),n=new s.DracoFloat32Array;l.GetAttributeFloatForAllPoints(c,t,n);for(let t=0;t<f;t++)1===e?r.setScalar(t,n.GetValue(t*e),{}):2===e?r.setVec2(t,n.GetValue(t*e),n.GetValue(t*e+1),{}):3===e?r.setVec3(t,n.GetValue(t*e),n.GetValue(t*e+1),n.GetValue(t*e+2),{}):4===e&&r.setVec4(t,n.GetValue(t*e),n.GetValue(t*e+1),n.GetValue(t*e+2),n.GetValue(t*e+3),{});s.destroy(n)}F.Is.exist(i.sparse)&&this.setSparseAccessor(i,r);const _=d.r.toVertexAttributeSemanticJoinedStringAsGltfStyle(d.r.fromString(i.extras.attributeName));o.set(_,r)}return s.destroy(c),s.destroy(l),v}static _setupTextureTransform(e,t,n,o){var a;if(null===(a=null==e?void 0:e.extensions)||void 0===a?void 0:a.KHR_texture_transform){const a=T.Am.fromCopyArray([1,1,0,0]);let i=0;const r=e.extensions.KHR_texture_transform;null!=r.scale&&(a.x=r.scale[0],a.y=r.scale[1]),null!=r.offset&&(a.z=r.offset[0],a.w=r.offset[1]),null!=r.rotation&&(i=r.rotation),t.setParameter(n,a),t.setParameter(o,i)}}static __createBufferForDecompressedData(e,t){let n=0;F.Is.exist(e.indices)&&(n+=4*e.indicesObject.count);const o=e.extensions.KHR_draco_mesh_compression.attributes;for(const a in e.attributes){if(null==o[a])continue;const i=e.attributesObjects[a];n+=t*u.h.fromString(i.type).getNumberOfComponents()*4}return new c.h({byteLength:n,buffer:new ArrayBuffer(n),name:"Draco",byteAlign:4})}}},2345:(e,t,n)=>{n.d(t,{j:()=>_});var o=n(5012),a=n(3050),i=n(7503),r=n(2766),s=n(5065),l=n(2229),c=n(3497);class _{static importBillboard(e,t){if(!l.Is.not.exist(e.extensionsUsed)&&-1!==e.extensionsUsed.findIndex((e=>"RHODONITE_billboard"===e)))for(const n in e.nodes){const o=t[n],a=e.nodes[n],i=o.getSceneGraph();void 0!==a.extensions&&void 0!==a.extensions.RHODONITE_billboard&&!0===a.extensions.RHODONITE_billboard.isBillboard&&(i.isBillboard=!0)}}static importEffect(e,t){if(l.Is.not.exist(e.extensions)||l.Is.not.exist(e.extensions.RHODONITE_effekseer)||-1===e.extensionsUsed.findIndex((e=>"RHODONITE_effekseer"===e)))return;const n=t.getTagValue("rnEntities"),a=e.extensions.RHODONITE_effekseer.effects;for(const t of a){const a=n[t.node],r=i.YY.addComponentToEntity(o.a,a),_=r.getEffekseer();_.playJustAfterLoaded=!0,_.isLoop=!0,l.Is.exist(t.bufferView)?e.buffers[0].bufferPromise.then((n=>{const o=s.$.createUint8ArrayFromBufferViewInfo(e,t.bufferView,n);_.arrayBuffer=o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength),_.type="efkpkg"})):l.Is.exist(t.uri)?(_.uri=t.uri,_.type="efk"):c.V.error("No real effect data."),u(r,t)}}}function u(e,t){const n=e.getComponentByComponentTID(a.Nq.EffekseerComponentTID);if(l.Is.exist(n)&&(n.playJustAfterLoaded=!0,n.isLoop=!0,l.Is.exist(t.timelines))){const n=t.timelines;for(const t of n){const n=t.values,o=t.name,s=n.map((e=>({input:e.input,event:e.event})));let c,_=e.tryToGetAnimation();l.Is.not.exist(_)&&(c=i.YY.addComponentToEntity(a.C6,e)),_=c.getAnimation(),_.setAnimation(l.Is.exist(o)?o:"Default","effekseer",new Float32Array(s.map((e=>e.input))),new Float32Array(s.map((e=>"play"===e.event?1:(e.event,0)))),1,r.v$.Step,!0)}}}},7776:(e,t,n)=>{n.d(t,{u:()=>x});var o=n(2664),a=n(7295),i=n(7751),r=n(6737),s=n(4114),l=n(9871),c=n(4132),_=n(1018),u=n(1383),f=n(1255);const d={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord;\nin vec3 a_position;\n\nout vec2 v_texcoord;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nmat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n\n  v_texcoord = a_texcoord;\n}\n",shaderStage:"vertex",isFragmentShader:!1},h={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec2 v_texcoord;\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec4 textureColor = texture(u_baseColorTexture, v_texcoord);\n\n  float r = textureColor.r;\n  float g = textureColor.g;\n  float b = textureColor.b;\n  float r16 = r * 15.0;\n  float g16 = g * 15.0;\n  float b16 = b * 15.0;\n  float rInt = floor(r16);\n  float gInt = floor(g16);\n  float bInt = floor(b16);\n\n  float rRate, gRate, bRate;\n  float rIntAdjust, gIntAdjust, bIntAdjust;\n\n  vec3 newColor = vec3(0.0);\n  for(int i=0; i<8; i++){\n    rRate = 1.0 - fract(r16);\n    gRate = 1.0 - fract(g16);\n    bRate = 1.0 - fract(b16);\n    rIntAdjust = rInt;\n    gIntAdjust = gInt;\n    bIntAdjust = bInt;\n\n    if(fract(float(i) / 2.0) != 0.0){\n      rIntAdjust += 1.0;\n      rRate = 1.0 - rRate;\n    }\n    if(fract(float(i / 2) / 2.0) != 0.0){\n      gIntAdjust += 1.0;\n      gRate = 1.0 - gRate;\n    }\n    if(fract(float(i / 4) / 2.0) != 0.0){\n      bIntAdjust += 1.0;\n      bRate = 1.0 - bRate;\n    }\n\n    if( rRate * gRate * bRate != 0.0){\n      newColor += texture(u_lookupTableTexture, vec2(rIntAdjust / 256.0 + bIntAdjust / 16.0  + 1.0 / 512.0, gIntAdjust / 16.0 + 1.0 / 32.0)).rgb * rRate * gRate * bRate;\n    }\n  }\n\n  rt0 = vec4(newColor, 1.0);\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0};var m=n(9993),p=n(589),v=n(3497);class x extends f.F{constructor(e,t,n,a,r){let l;super(e,{},d,h);const f=t.getFramebuffer();let x;null!=f&&null!=f.colorAttachments[n]?l=f.colorAttachments[n]:(l=p.rT,null!=f?v.V.warn("renderPass does not have framebuffer.colorAttachments["+n+"]"):v.V.warn("renderPass does not have framebuffer")),"string"==typeof a?(x=new _.g,async function(e){x.generateTextureFromUri(e,{type:s.I.UnsignedByte}),await x.loadFromUrlLazy()}(a)):r instanceof o.E?x=r:(v.V.warn("no LUT texture is specified"),x=p.rT);const g=new m.L({minFilter:u.P.Nearest,magFilter:u.P.Nearest,wrapS:u.P.ClampToEdge,wrapT:u.P.ClampToEdge,anisotropy:!1});g.create();const y=[{semantic:"baseColorTexture",componentType:s.I.Int,compositionType:i.h.Texture2D,stage:c.C.PixelShader,initialValue:[0,l],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"lookupTableTexture",componentType:s.I.Int,compositionType:i.h.Texture2D,stage:c.C.PixelShader,initialValue:[1,x,g],min:0,max:Number.MAX_SAFE_INTEGER}];this.setShaderSemanticsInfoArray(y)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){o.setUniform&&this.setWorldMatrix(t,o.worldMatrix);let i=o.renderPass.cameraComponent;null==i&&(i=r.O.getComponent(a.n,a.n.current)),i&&(this.setViewInfo(t,i,o.isVr,o.displayIdx),this.setProjection(t,i,o.isVr,o.displayIdx))}}x.lookupTableTexture=new l.jc({str:"lookupTableTexture"})},643:(e,t,n)=>{n.d(t,{w:()=>m});var o=n(9871),a=n(1255),i=n(6737),r=n(7295),s=n(9747),l=n(3107),c=n(589),_=n(8924),u=n(5882),f=n(4772),d=n(9993),h=n(1383);class m extends a.F{constructor({name:e,isMorphing:t,isSkinning:n,isLighting:o,vertexShader:a,pixelShader:i,additionalShaderSemanticInfo:r,vertexShaderWebGpu:s,pixelShaderWebGpu:l}){super(e,{isMorphing:t,isSkinning:n,isLighting:o});const c=this.doShaderReflection(a,i,s,l);m.__diffuseIblCubeMapSampler.created||m.__diffuseIblCubeMapSampler.create(),m.__specularIblCubeMapSampler.created||m.__specularIblCubeMapSampler.create(),this.setShaderSemanticsInfoArray(c.concat(r))}_setInternalSettingParametersToGpuWebGpu({material:e,args:t}){const{mipmapLevelNumber:n,meshRenderComponent:o,diffuseHdriType:i,specularHdriType:r}=m.__setupHdriParameters(t),s=a.F.__tmp_vector4;s.x=n,s.y=o.diffuseCubeMapContribution,s.z=o.specularCubeMapContribution,s.w=o.rotationOfCubeMap,e.setParameter("iblParameter",s);const l=a.F.__tmp_vector2;l.x=i,l.y=r,e.setParameter("hdriFormat",l);const c=t.entity.tryToGetMeshRenderer();if(null!=c&&null!=c.diffuseCubeMap&&null!=c.specularCubeMap){const t=_.Am.zero(),n=u.A3.zero();t.x=c.specularCubeMap.mipmapLevelNumber,t.y=c.diffuseCubeMapContribution,t.z=c.specularCubeMapContribution,t.w=c.rotationOfCubeMap,e.setParameter("iblParameter",t),n.x=c.diffuseCubeMap.hdriFormat.index,n.y=c.specularCubeMap.hdriFormat.index,e.setParameter("hdriFormat",n)}}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:s}){if(s.setUniform){if(this.setWorldMatrix(t,s.worldMatrix),this.setNormalMatrix(t,s.normalMatrix),this.setIsBillboard(t,s.isBillboard),n||s.isVr){let e=s.renderPass.cameraComponent;null==e&&(e=i.O.getComponent(r.n,r.n.current)),this.setViewInfo(t,e,s.isVr,s.displayIdx),this.setProjection(t,e,s.isVr,s.displayIdx)}this.setLightsInfo(t,s.lightComponents,e,s.setUniform);const o=s.entity.tryToGetSkeletal();this.setSkinning(t,s.setUniform,o)}const l=f.f.getWebGLResourceRepository();if(s.diffuseCube&&s.diffuseCube.isTextureReady?l.setUniform1iForTexture(t,o.lk.DiffuseEnvTexture.str,[5,s.diffuseCube,m.__diffuseIblCubeMapSampler]):l.setUniform1iForTexture(t,o.lk.DiffuseEnvTexture.str,[5,c.cC]),s.specularCube&&s.specularCube.isTextureReady?l.setUniform1iForTexture(t,o.lk.SpecularEnvTexture.str,[6,s.specularCube,m.__specularIblCubeMapSampler]):l.setUniform1iForTexture(t,o.lk.SpecularEnvTexture.str,[6,c.cC]),s.setUniform){if(n){const{mipmapLevelNumber:e,meshRenderComponent:a,diffuseHdriType:i,specularHdriType:r}=m.__setupHdriParameters(s);l.setUniformValue(t,o.lk.IBLParameter.str,n,{x:e,y:a.diffuseCubeMapContribution,z:a.specularCubeMapContribution,w:a.rotationOfCubeMap}),l.setUniformValue(t,o.lk.HDRIFormat.str,n,{x:i,y:r})}}else{const{mipmapLevelNumber:t,meshRenderComponent:n,diffuseHdriType:o,specularHdriType:i}=m.__setupHdriParameters(s),r=a.F.__tmp_vector4;r.x=t,r.y=n.diffuseCubeMapContribution,r.z=n.specularCubeMapContribution,r.w=n.rotationOfCubeMap,e.setParameter("iblParameter",r);const l=a.F.__tmp_vector2;l.x=o,l.y=i,e.setParameter("hdriFormat",l)}}_setInternalSettingParametersToGpuWebGLPerPrimitive({material:e,shaderProgram:t,firstTime:n,args:o}){const a=o.entity.tryToGetBlendShape();this.setMorphInfo(t,o.entity.getMesh(),o.primitive,a)}static __setupHdriParameters(e){let t=1;e.specularCube&&(t=e.specularCube.mipmapLevelNumber);const n=e.entity.getMeshRenderer();let o=s.P.LDR_SRGB.index,a=s.P.LDR_SRGB.index;return n.diffuseCubeMap&&(o=n.diffuseCubeMap.hdriFormat.index),n.specularCubeMap&&(a=n.specularCubeMap.hdriFormat.index),{mipmapLevelNumber:t,meshRenderComponent:n,diffuseHdriType:o,specularHdriType:a}}}m.__globalDataRepository=l.q.getInstance(),m.__diffuseIblCubeMapSampler=new d.L({minFilter:h.P.Linear,magFilter:h.P.Linear,wrapS:h.P.ClampToEdge,wrapT:h.P.ClampToEdge,wrapR:h.P.ClampToEdge}),m.__specularIblCubeMapSampler=new d.L({minFilter:h.P.LinearMipmapLinear,magFilter:h.P.Linear,wrapS:h.P.ClampToEdge,wrapT:h.P.ClampToEdge,wrapR:h.P.ClampToEdge})},4923:(e,t,n)=>{n.d(t,{g:()=>h});var o=n(1255),a=n(7295),i=n(6737),r=n(4114),s=n(7751),l=n(9011),c=n(9871),_=n(4132),u=n(975);const f={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec3 v_normal_inWorld;\nout vec4 v_position_inLocal;\nout vec4 v_position_inWorld;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_position_inLocal = gl_Position;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},d={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec4 v_position_inLocal;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec4 encodeDepthToRGBA(float depth){\n  float r = depth;\n  float g = fract(r * 255.0);\n  float b = fract(g * 255.0);\n  float a = fract(b * 255.0);\n  float coef = 1.0 / 255.0;\n  r -= g * coef;\n  g -= b * coef;\n  b -= a * coef;\n  return vec4(r, g, b, a);\n}\n\nvoid main (){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n  float depth;\n  bool isPointLight = get_isPointLight(materialSID, 0);\n  if(isPointLight){\n    float zNear = get_zNearInner(materialSID, 0);\n    float zFar = get_zFarInner(materialSID, 0);\n    float normalizationCoefficient = 1.0 / (zFar - zNear);\n    depth = normalizationCoefficient * length(v_position_inLocal);\n  }else{\n    depth = gl_FragCoord.z;\n  }\n\n  float depthPow = get_depthPow(materialSID, 0);\n  float depthData = pow(depth, depthPow);\n  vec4 encodedDepth = encodeDepthToRGBA(depthData);\n\n  rt0 = encodedDepth;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0};class h extends o.F{constructor(e,t,{isSkinning:n}){super(e,{isMorphing:!1,isSkinning:n,isLighting:!1},f,d),this.__lastZNear=0,this.__lastZFar=0;const o=[{semantic:"zNearInner",componentType:r.I.Float,compositionType:s.h.Scalar,stage:_.C.PixelShader,isInternalSetting:!0,initialValue:l.X5.fromCopyNumber(.1),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"zFarInner",componentType:r.I.Float,compositionType:s.h.Scalar,stage:_.C.PixelShader,isInternalSetting:!0,initialValue:l.X5.fromCopyNumber(1e4),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"isPointLight",componentType:r.I.Bool,compositionType:s.h.Scalar,stage:_.C.PixelShader,initialValue:l.X5.fromCopyNumber(1),min:0,max:1},{semantic:"depthPow",componentType:r.I.Float,compositionType:s.h.Scalar,stage:_.C.PixelShader,initialValue:l.X5.fromCopyNumber(t),min:1,max:2},{semantic:"pointSize",componentType:r.I.Float,compositionType:s.h.Scalar,stage:_.C.VertexShader,soloDatum:!0,initialValue:l.X5.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:r.I.Float,compositionType:s.h.Vec3,stage:_.C.VertexShader,soloDatum:!0,initialValue:u.Pq.fromCopyArray([0,.1,.01]),min:0,max:1}];this.setShaderSemanticsInfoArray(o)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){let r=o.renderPass.cameraComponent;null==r&&(r=i.O.getComponent(a.n,a.n.current)),o.setUniform?(this.setWorldMatrix(t,o.worldMatrix),this.setNormalMatrix(t,o.normalMatrix),this.setViewInfo(t,r,o.isVr,o.displayIdx),this.setProjection(t,r,o.isVr,o.displayIdx),(n||this.__lastZNear!==r.zNearInner)&&(t._gl.uniform1f(t.zNearInner,r.zNearInner),this.__lastZNear=r.zNearInner),this.__lastZFar!==r.zFarInner&&(t._gl.uniform1f(t.zFarInner,r.zFarInner),this.__lastZFar=r.zFarInner)):(e.setParameter("zNearInner",r.zNearInner),e.setParameter("zFarInner",r.zFarInner));const s=o.entity.tryToGetSkeletal();this.setSkinning(t,o.setUniform,s)}}h.zNearInner=new c.jc({str:"zNearInner"}),h.zFarInner=new c.jc({str:"zFarInner"}),h.isPointLight=new c.jc({str:"isPointLight"}),h.depthPow=new c.jc({str:"depthPow"})},9920:(e,t,n)=>{n.d(t,{Q:()=>g});var o=n(9871),a=n(7751),i=n(4114),r=n(4132),s=n(6737),l=n(7295),c=n(9011),_=n(1255);const u={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},f={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nin vec2 v_texcoord_0;\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);\n\n  float luminance = dot(baseColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n  float luminanceCriterion = get_luminanceCriterion(materialSID, 0);\n\n  baseColor.rgb = mix(vec3(0.0), baseColor.rgb, (luminance - luminanceCriterion) / luminanceCriterion);\n  baseColor.a = 1.0;\n\n  rt0 = baseColor;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},d={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},h={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var baseColor = textureSampleLevel(baseColorTexture, baseColorSampler, input.texcoord_0, 0.0);\n\n  let luminance = dot(baseColor.rgb, vec3f(0.2126, 0.7152, 0.0722));\n\n  let luminanceCriterion: f32 = get_luminanceCriterion(materialSID, 0);\n  baseColor = vec4f(mix(vec3f(0.0), baseColor.rgb, (luminance - luminanceCriterion) / luminanceCriterion), 1.0);\n\n  return baseColor;\n}\n",shaderStage:"fragment",isFragmentShader:!0};var m=n(7670),p=n(3212),v=n(9993),x=n(2766);class g extends _.F{constructor(e,t){super(e,{});const n=new v.L({wrapS:x.gu.ClampToEdge,wrapT:x.gu.ClampToEdge,minFilter:x.gu.Linear,magFilter:x.gu.Linear});n.create();const o=[{semantic:"luminanceCriterion",componentType:i.I.Float,compositionType:a.h.Scalar,stage:r.C.PixelShader,initialValue:c.X5.fromCopyNumber(2),min:0,max:Number.MAX_VALUE},{semantic:"baseColorTexture",componentType:i.I.Int,compositionType:a.h.Texture2D,stage:r.C.PixelShader,initialValue:[0,t,n],min:0,max:Number.MAX_SAFE_INTEGER}];m.l.currentProcessApproach===p.m.WebGPU?(this.__vertexShaderityObject=d,this.__pixelShaderityObject=h):(this.__vertexShaderityObject=u,this.__pixelShaderityObject=f),this.setShaderSemanticsInfoArray(o)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){if(o.setUniform){this.setWorldMatrix(t,o.worldMatrix);let e=o.renderPass.cameraComponent;null==e&&(e=s.O.getComponent(l.n,l.n.current)),e&&(this.setViewInfo(t,e,o.isVr,o.displayIdx),this.setProjection(t,e,o.isVr,o.displayIdx))}}}g.LuminanceCriterion=new o.jc({str:"luminanceCriterion"})},790:(e,t,n)=>{n.d(t,{v:()=>d});var o=n(1255),a=n(7751),i=n(4114),r=n(975),s=n(4132),l=n(9011),c=n(6737),_=n(7295);const u={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout float v_instanceInfo;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\n\nvoid main()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  v_instanceInfo = a_instanceInfo.x;\n}\n",shaderStage:"vertex",isFragmentShader:!1},f={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin float v_instanceInfo;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\n\nvec4 encodeFloatRGBA(float v) {\n  float val = v;\n  float r = mod(val, 255.0);\n  val -= r;\n  float g = mod(val, 65025.0);\n  val -= g;\n  float b = mod(val, 16581375.0);\n  return vec4(r/255.0, g/65025.0, b/16581375.0, 1.0);\n}\n\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  rt0 = encodeFloatRGBA(v_instanceInfo);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0};class d extends o.F{constructor(e){super(e,{isMorphing:!1,isSkinning:!0,isLighting:!1},u,f);const t=[{semantic:"pointSize",componentType:i.I.Float,compositionType:a.h.Scalar,stage:s.C.VertexShader,soloDatum:!0,initialValue:l.X5.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:i.I.Float,compositionType:a.h.Vec3,stage:s.C.VertexShader,soloDatum:!0,initialValue:r.Pq.fromCopyArray([0,.1,.01]),min:0,max:1}];this.setShaderSemanticsInfoArray(t)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){if(o.setUniform){this.setWorldMatrix(t,o.worldMatrix),this.setNormalMatrix(t,o.normalMatrix);let n=o.renderPass.cameraComponent;null==n&&(n=c.O.getComponent(_.n,_.n.current)),this.setViewInfo(t,n,o.isVr,o.displayIdx),this.setProjection(t,n,o.isVr,o.displayIdx);const a=o.entity.tryToGetSkeletal();this.setSkinning(t,o.setUniform,a),this.setLightsInfo(t,o.lightComponents,e,o.setUniform)}}}},4307:(e,t,n)=>{n.d(t,{P:()=>m});var o=n(4114),a=n(7751),i=n(9011),r=n(9871),s=n(4132),l=n(9936),c=n(1255),_=n(6737),u=n(7295);const f={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord;\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec2 v_texcoord;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nmat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_position_inWorld = worldMatrix * vec4(a_position, 1.0);\n  v_texcoord = a_texcoord;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},d={code:'\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n\n/* shaderity: @{getters} */\n\n#define MATH_PI 3.141592\n\n// These codes are referenced from https://github.com/knarkowicz/FurnaceTest\nfloat roughnessRemap(float userRoughness) {\n  return userRoughness * userRoughness;\n}\n\n// GGX NDF\nfloat d_ggx(float userRoughness, float NH) {\n  float alphaRoughness = userRoughness * userRoughness;\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (MATH_PI * f * f);\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 envBRDFApprox( float Roughness, float NoV ) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\nfloat specularIBL(float userRoughness, float NV, float f0) {\n  /// Use specular BRDF LUT\n  // vec3 brdf = texture(u_brdfLutTexture, vec2(NV, 1.0 - userRoughness)).rgb;\n  // float specular = 1.0 * (f0 * brdf.x + brdf.y);\n\n  /// Use specular BRDF Approx\n  vec2 f_ab = envBRDFApprox(userRoughness, NV);\n  vec3 specular = vec3(f0) * f_ab.x + f_ab.y;\n  return specular.x;\n}\n\n// The Schlick Approximation to Fresnel\nfloat fresnel(float f0, float VH) {\n  return f0 + (1.0 - f0) * pow(1.0 - VH, 5.0);\n}\n\nfloat smithG1(float roughness, float NoV)\n{\n\tfloat a = roughnessRemap( roughness );\n\tfloat a2 = a * a;\n\tfloat NoV2 = NoV * NoV;\n\tfloat lambda = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoV2) / NoV2)) * 0.5;\n\treturn 1.0 / (1.0 + lambda);\n}\n\nfloat smithG(float roughness, float NoV, float NoL)\n{\n\tfloat a = roughnessRemap( roughness );\n\tfloat a2 = a * a;\n\tfloat NoV2 = NoV * NoV;\n\tfloat NoL2 = NoL * NoL;\n\tfloat lambdaV = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoV2) / NoV2)) * 0.5;\n\tfloat lambdaL = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoL2) / NoL2)) * 0.5;\n\treturn 1.0 / (1.0 + lambdaV + lambdaL);\n}\n\nfloat g_shieldingForWeak(float alphaRoughness, float NV, float NL) {\n  float r = alphaRoughness;\n\n  // Local Masking using "Schlick-Smith" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localMasking;\n}\n\n\nfloat g_shielding(float roughness, float NV, float NL) {\n  float a = roughnessRemap( roughness );\n  float r = a;\n\n  // Local Shadowing using "Schlick-Smith" Masking Function\n  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\n\n  // Local Masking using "Schlick-Smith" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localShadowing * localMasking;\n}\n\nfloat v_GGXCorrelatedForWeak(float roughness, float NV, float NL) {\n  float a = roughnessRemap( roughness );\n  float a2 = a * a;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  return 0.5 / (GGXV);\n}\n\nfloat v_GGXCorrelated(float roughness, float NV, float NL) {\n  float a = roughnessRemap( roughness );\n  float a2 = a * a;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\n// this is from https://learnopengl.com/PBR/IBL/Specular-IBL\nfloat vanDerCorpus(int n, int base)\n{\n    float invBase = 1.0 / float(base);\n    float denom   = 1.0;\n    float result  = 0.0;\n\n    for(int i = 0; i < 32; ++i)\n    {\n        if(n > 0)\n        {\n            denom   = mod(float(n), 2.0);\n            result += denom * invBase;\n            invBase = invBase / 2.0;\n            n       = int(float(n) / 2.0);\n        }\n    }\n\n    return result;\n}\n\nvec2 hammersleyNoBitOps(int i, int N)\n{\n  return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n}\n\nfloat radicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\nvec3 sampleHemisphereGGX(vec2 Xi, float roughness) {\n  float a = roughnessRemap(roughness);\n\tfloat a2 = a * a;\n\n  float phi = 2.0 * MATH_PI * Xi.x;\n  float cosPhi = cos(phi);\n  float sinPhi = sin(phi);\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y)); // GGX\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n  return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\nfloat weakWhiteFurnaceTest(float roughness, float NoV, float f0, int g_type, int disable_fresnel)\n{\n\tfloat vx = sqrt(1.0 - NoV * NoV);\n\tfloat vy = 0.0;\n\tfloat vz = NoV;\n\n\tfloat integral = 0.0;\n\tconst uint sampleNum = 2048u;\n\tfor (uint i = 0u; i < sampleNum; ++i)\n\t{\n    vec2 Xi = hammersley(i, sampleNum);\n\n    vec3 hvec = sampleHemisphereGGX(Xi, roughness);\n\n\t\tfloat VoHUnsat = vx * hvec.x + vy * hvec.y + vz * hvec.z;\n\n    float lz = 2.0 * VoHUnsat * hvec.z - vz;\n\n    float NoL = max(lz, 0.0);\n\t\tfloat NoH = max(hvec.z, 0.0);\n\t\tfloat VoH = max(VoHUnsat, 0.0);\n\n    float f = fresnel(f0, VoH);\n\n    float g1 = 0.0;\n    if (g_type == 0) {\n      g1 = smithG1(roughness, NoV);\n    } else if (g_type == 1) {\n      g1 = g_shieldingForWeak(roughness, NoV, NoL);\n    } else if (g_type == 2) {\n      g1 = v_GGXCorrelatedForWeak(roughness, NoV, NoL) * 4.0 * NoV * NoL;\n    }\n\n    float pdf = 4.0 * VoH / NoH;\n    float integralValue = (g1 * pdf) / (4.0 * NoV);\n    if (disable_fresnel == 0) {\n      integralValue *= f;\n    }\n    // integralValue *= 0.5; // Set furnace color 0.5\n\n    integral += integralValue;\n\n\t}\n\tintegral /= float(sampleNum);\n\treturn clamp(integral, 0.0, 1.0);\n}\n\nfloat whiteFurnaceTest(float roughness, float NoV, float f0, int g_type, int disable_fresnel)\n{\n\tfloat vx = sqrt(1.0 - NoV * NoV);\n\tfloat vy = 0.0;\n\tfloat vz = NoV;\n\n\tfloat integral = 0.0;\n\tconst uint sampleNum = 4096u;\n\tfor (uint i = 0u; i < sampleNum; ++i)\n\t{\n\n    vec2 Xi = hammersley(i, sampleNum);\n\n    vec3 hvec = sampleHemisphereGGX(Xi, roughness);\n\n\t\tfloat VoHUnsat = vx * hvec.x + vy * hvec.y + vz * hvec.z;\n\t\tfloat lx = 2.0 * VoHUnsat * hvec.x - vx;\n\t\tfloat ly = 2.0 * VoHUnsat * hvec.y - vy;\n\t\tfloat lz = 2.0 * VoHUnsat * hvec.z - vz;\n\n\t\tfloat NoL = max(lz, 0.0);\n\t\tfloat NoH = max(hvec.z, 0.0);\n    float VoH = max(VoHUnsat, 0.0);\n\n    float f = fresnel(f0, VoH);\n\n    float g = 0.0;\n    if (g_type == 0) {\n      g = smithG(roughness, NoV, NoL);\n    } else if (g_type == 1){\n      g = g_shielding(roughness, NoV, NoL);\n    } else if (g_type == 2){\n      g = v_GGXCorrelated(roughness, NoV, NoL) * (4.0 * NoV * NoL);\n    } else if (g_type == 3) {\n      g = 0.0;\n    }\n\n    float pdf = 4.0 * VoH / NoH;\n    float integralValue = (g * pdf) / (4.0 * NoV);\n    if (disable_fresnel == 0 && g_type != 3) {\n      integralValue *= f;\n    }\n    // integralValue *= 0.5; // Set furnace color 0.5\n    integral += integralValue;\n\t}\n  integral /= float(sampleNum);\n  if (g_type == 3) {\n    integral = specularIBL(roughness, NoV, f0);\n  }\n\treturn clamp(integral, 0.0, 1.0);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 quadSizeInPixel = get_screenInfo(materialSID, 0);\n  float roughness = 0.0;\n  float NoV = 0.0; // normal dot view vector\n\n  // 2D mode\n  int mode = get_mode(materialSID, 0);\n  if (mode == 0) {\n    roughness = (gl_FragCoord.y) / quadSizeInPixel.y;\n    NoV = (gl_FragCoord.x) / quadSizeInPixel.x;\n  } else {\n    // object mode\n    // Roughness\n    const float c_MinRoughness = 0.04;\n    vec2 metallicRoughnessFactor = get_metallicRoughnessFactor(materialSID, 0);\n    float userRoughness = metallicRoughnessFactor.y;\n    float metallic = metallicRoughnessFactor.x;\n\n    vec4 ormTexel = texture(u_metallicRoughnessTexture, v_texcoord);\n    userRoughness = ormTexel.g * userRoughness;\n    userRoughness = clamp(userRoughness, c_MinRoughness, 1.0);\n    roughness = userRoughness;\n\n    // vec3 viewVector = normalize(vec3(0.0, 0.0, 10.0) - v_position_inWorld.xyz);\n    // vec3 viewVector = normalize(u_viewPosition - v_position_inWorld.xyz);\n    vec3 viewVector = vec3(0.0, 0.0, 1.0);\n    NoV = dot(v_normal_inWorld, viewVector);\n  }\n\n  int debugView = get_debugView(materialSID, 0);\n  float f0 = get_f0(materialSID, 0);\n  int g_type = get_g_type(materialSID, 0);\n  int disable_fresnel = get_disable_fresnel(materialSID, 0);\n\n  if (debugView == 0) {\n    float whiteFurnaceResult = whiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    rt0 = vec4(whiteFurnaceResult, whiteFurnaceResult, whiteFurnaceResult, 1.0);\n\n  } else if (debugView == 1) {\n    float weakWhiteFurnaceResult = weakWhiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    rt0 = vec4(weakWhiteFurnaceResult, weakWhiteFurnaceResult, weakWhiteFurnaceResult, 1.0);\n\n  } else if (debugView == 2){\n    float nn = NoV*0.5+0.5;\n    rt0 = vec4(nn, nn, nn, 1.0);\n\n  } else if (debugView == 3){\n    rt0 = vec4(v_normal_inWorld.xyz, 1.0);\n\n  } else if (debugView == 4){\n    float whiteFurnaceResult = whiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    float weakWhiteFurnaceResult = weakWhiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    rt0 = vec4(whiteFurnaceResult, weakWhiteFurnaceResult, 0.0, 1.0);\n\n  } else if (debugView == 5){\n    rt0 = vec4(roughness, NoV, 0.0, 1.0);\n\n  } else {\n    rt0 = vec4(1.0, 1.0, 1.0, 1.0);\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n',shaderStage:"fragment",isFragmentShader:!0};var h=n(589);class m extends c.F{constructor(e){super(e,{},f,d);const t=[{semantic:"debugView",componentType:o.I.Int,compositionType:a.h.Scalar,stage:s.C.PixelShader,initialValue:i.X5.fromCopyNumber(0),min:0,max:1},{semantic:"disable_fresnel",componentType:o.I.Int,compositionType:a.h.Scalar,stage:s.C.PixelShader,initialValue:i.X5.fromCopyNumber(0),min:0,max:1},{semantic:"f0",componentType:o.I.Float,compositionType:a.h.Scalar,stage:s.C.PixelShader,initialValue:i.X5.fromCopyNumber(1),min:0,max:1},{semantic:"g_type",componentType:o.I.Int,compositionType:a.h.Scalar,stage:s.C.PixelShader,initialValue:i.X5.fromCopyNumber(0),min:0,max:3},{semantic:"mode",componentType:o.I.Int,compositionType:a.h.Scalar,stage:s.C.PixelShader,initialValue:i.X5.fromCopyNumber(0),min:0,max:1},{semantic:"screenInfo",componentType:o.I.Float,compositionType:a.h.Vec2,stage:s.C.PixelShader,initialValue:l.I9.fromCopyArray2([0,0]),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"metallicRoughnessFactor",componentType:o.I.Float,compositionType:a.h.Vec2,stage:s.C.PixelShader,initialValue:l.I9.fromCopyArray2([1,1]),min:0,max:2},{semantic:"metallicRoughnessTexture",componentType:o.I.Int,compositionType:a.h.Texture2D,stage:s.C.PixelShader,initialValue:[1,h.vK],min:0,max:Number.MAX_SAFE_INTEGER}];this.setShaderSemanticsInfoArray(t)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){if(o.setUniform&&(this.setWorldMatrix(t,o.worldMatrix),this.setNormalMatrix(t,o.normalMatrix),n)){let n=o.renderPass.cameraComponent;null==n&&(n=_.O.getComponent(u.n,u.n.current)),this.setViewInfo(t,n,o.isVr,o.displayIdx),this.setProjection(t,n,o.isVr,o.displayIdx),this.setLightsInfo(t,o.lightComponents,e,o.setUniform)}}}m.mode=new r.jc({str:"mode"}),m.debugView=new r.jc({str:"debugView"}),m.g_type=new r.jc({str:"g_type"}),m.disable_fresnel=new r.jc({str:"disable_fresnel"}),m.f0=new r.jc({str:"f0"})},9516:(e,t,n)=>{n.d(t,{E:()=>P});var o=n(1255),a=n(6338),i=n(7295),r=n(4772),s=n(6737),l=n(4114),c=n(7751),_=n(5338),u=n(9011),f=n(9871),d=n(4132),h=n(975),m=n(3414),p=n(1124);const v={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n// This shader is based on https://github.com/Santarh/MToon\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_baryCentricCoord;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\nout vec3 v_normal_inView;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout float v_instanceInfo;\n\n#ifdef RN_USE_TANGENT\nin vec4 a_tangent;\nout vec3 v_tangent_inWorld;\nout vec3 v_binormal_inWorld; // bitangent_inWorld\n#endif\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      return;\n    #endif\n  #endif\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #if defined(RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE)\n      float outlineTex = texture(u_outlineWidthTexture, a_texcoord_0).r;\n    #else\n      float outlineTex = 1.0;\n    #endif\n\n    #if defined(RN_MTOON_OUTLINE_WIDTH_WORLD)\n      float outlineWidth = get_outlineWidth(materialSID, 0);\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * a_normal;\n      vec4 worldOutlineOffset = worldMatrix * vec4(outlineOffset, 0.0);\n      gl_Position = projectionMatrix * viewMatrix * (v_position_inWorld + worldOutlineOffset);\n\n    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)\n      vec4 vertex = projectionMatrix * viewMatrix * v_position_inWorld;\n\n      vec3 clipNormal = (projectionMatrix * vec4(v_normal_inView, 1.0)).xyz;\n      vec2 projectedNormal = normalize(clipNormal.xy);\n      float outlineScaledMaxDistance = get_outlineScaledMaxDistance(materialSID, 0);\n      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n      float aspect = abs(get_aspect(0.0, 0)); //solo datum\n      projectedNormal.x *= aspect;\n\n      float outlineWidth = get_outlineWidth(materialSID, 0);\n      vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(v_normal_inView.z), 0.0, 1.0); // ignore offset when normal toward camera\n\n      gl_Position = vertex;\n    #else\n      gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n    #endif\n  #else\n    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n  #endif\n\n  #ifdef RN_USE_TANGENT\n    v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n    v_binormal_inWorld = cross(v_normal_inWorld, v_tangent_inWorld) * a_tangent.w;\n  #endif\n\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n  v_instanceInfo = a_instanceInfo.x;\n}\n",shaderStage:"vertex",isFragmentShader:!1},x={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nconst float EPS_COL = 0.00001;\n\nin vec2 v_texcoord_0;\nin vec3 v_baryCentricCoord;\nin vec3 v_normal_inView;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin float v_instanceInfo;\n#ifdef RN_USE_TANGENT\n  in vec3 v_tangent_inWorld;\n  in vec3 v_binormal_inWorld; // bitangent_inWorld\n#endif\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nfloat angular_n_h(float NH) {\n  return acos(NH);\n}\n\nfloat d_phong(float NH, float c1) {\n  return pow(\n    cos(acos(NH))\n    , c1\n  );\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 envBRDFApprox( float Roughness, float NoV ) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n// GGX NDF\nfloat d_GGX(float NH, float alphaRoughness) {\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\nfloat d_torrance_reiz(float NH, float c3) {\n  float CosSquared = NH*NH;\n  float TanSquared = (1.0 - CosSquared)/CosSquared;\n  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX\n  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry\n}\n\nfloat d_beckmann(float NH, float m) {\n  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);\n  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));\n  return co * expx;\n}\n\n// the same as glTF WebGL sample\n// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188\n// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),\n// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)\n// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\nfloat g_shielding(float NL, float NV, float alphaRoughness) {\n  float r = alphaRoughness;\n\n  // Local Shadowing using \"Schlick-Smith\" Masking Function\n  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\n\n  // Local Masking using \"Schlick-Smith\" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localShadowing * localMasking;\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfloat v_GGXCorrelated(float NL, float NV, float alphaRoughness) {\n  float a2 = alphaRoughness * alphaRoughness;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfloat v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {\n  float a = alphaRoughness;\n  float GGXV = NL * (NV * (1.0 - a) + a);\n  float GGXL = NV * (NL * (1.0 - a) + a);\n  return 0.5 / (GGXV + GGXL);\n}\n\n// The Schlick Approximation to Fresnel\nfloat fresnel(float f0, float f90, float VdotH) {\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nvec3 fresnel(vec3 f0, vec3 f90, float VdotH) {\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nvec3 fresnel(vec3 f0, float f90, float VdotH)\n{\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nfloat fresnel(float f0, float VdotH)\n{\n  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\nvec3 fresnel(vec3 f0, float VdotH)\n{\n  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nvec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness, float specularWeight) {\n  float D = d_GGX(NH, alphaRoughness);\n  float V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3(D) * vec3(V) * F * specularWeight;\n//      float G = g_shielding(NL, NV, alphaRoughness);\n//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);\n\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nvec3 BRDF_lambertian(vec3 albedo, vec3 F, float specularWeight)\n{\n  // (1/pi) * diffuseAlbedo\n  return (vec3(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf\nfloat specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {\n  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  float D = d_GGX(NdotH, alphaRoughness);\n  return V * D;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfloat specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {\n  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  float D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel\nvec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {\n  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel\nvec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {\n  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);\n  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);\n  return mix(base, layer, fr);\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf\nvec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n  return conductor_fresnel(\n    baseColor,\n    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),\n    alphaRoughness,\n    VdotH\n  );\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf\n// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {\n//   vec3 base = BRDF_lambertian(baseColor);\n//   float alphaRoughness = perceptualRoughness * perceptualRoughness;\n//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));\n//   return fresnel_mix(ior, base, layer, VdotH);\n// }\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nvec3 coated_material_s(vec3 base, float perceptualRoughness, float clearcoatRoughness, float clearcoat, float VdotNc, float LdotNc, float NdotHc) {\n  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  float clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n  float D = d_GGX(NdotHc, clearcoatAlpha);\n  float V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  float f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(f_clearcoat * clearcoat);\n}\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\nfloat srgbToLinear(float value) {\n  return pow(value, 2.2);\n}\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nfloat linearToSrgb(float value) {\n  return pow(value, 1.0/2.2);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nvec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)\n{\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nvec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfloat Schlick_to_F0(float f, float f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nvec3 Schlick_to_F0(vec3 f, float VdotH) {\n    return Schlick_to_F0(f, vec3(1.0), VdotH);\n}\n\nfloat Schlick_to_F0(float f, float VdotH) {\n    return Schlick_to_F0(f, 1.0, VdotH);\n}\n\nvec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {\n  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;\n  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;\n  vec3 r = normalize(vec3(t.xy + u.xy, t.z));\n  return r;\n}\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\nfloat IsotropicNDFFiltering(vec3 normal, float roughness2) {\n  float SIGMA2 = 0.15915494;\n  float KAPPA = 0.18;\n  vec3 dndu = dFdx(normal);\n  vec3 dndv = dFdy(normal);\n  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nvec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;\n    vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfloat D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)\n{\n    float a2 = at * ab;\n    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\n    float w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfloat V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,\n    float at, float ab)\n{\n    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    float v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 BRDF_specularAnisotropicGGX(vec3 F, float alphaRoughness,\n    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,\n    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)\n{\n    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    float ab = alphaRoughness;\n\n    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfloat d_Charlie(float sheenPerceptualRoughness, float NoH) {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  float invAlpha  = 1.0 / alphaG;\n  float cos2h = NoH * NoH;\n  float sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfloat sheenSimpleVisibility(float NdotL, float NdotV) {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfloat charlieL(float x, float alphaG) {\n  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfloat lambdaSheen(float cosTheta, float alphaG)\n{\n  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));\n}\n\nfloat sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {\n  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  float sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nvec3 sheen_brdf(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {\n  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst mat3 XYZ_TO_REC709 = mat3(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nvec3 fresnelSchlickRoughnessWithIridescence(\n  vec3 F0, float cosTheta, float roughness,\n  vec3 iridescenceFresnel, float iridescence\n  )\n{\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nvec3 Fresnel0ToIor(vec3 F0) {\n    vec3 sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nvec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\n    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfloat IorToFresnel0(float transmittedIor, float incidentIor) {\n    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nvec3 evalSensitivity(float OPD, vec3 shift) {\n    float phase = 2.0 * M_PI * OPD * 1.0e-9;\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    vec3 rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nvec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));\n  float cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3(1.0);\n  }\n\n  float cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  float R0 = IorToFresnel0(iridescenceIor, outsideIor);\n  float R12 = fresnel(R0, cosTheta1);\n  float R21 = R12;\n  float T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);\n  vec3 R23 = fresnel(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  float phi12 = 0.0;\n  if (iridescenceIor < outsideIor) phi12 = M_PI;\n  float phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  vec3 phi23 = vec3(0.0);\n  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;\n  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;\n  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;\n\n  // OPD (optical path difference)\n  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  vec3 phi = vec3(phi21) + phi23;\n\n  // Compound terms\n  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\n  vec3 r123 = sqrt(R123);\n  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  vec3 C0 = R12 + Rs;\n  vec3 I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  vec3 Cm = Rs - T121;\n  for (int m = 1; m <= 2; ++m)\n  {\n      Cm *= r123;\n      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\n      I += Cm * Sm;\n  }\n\n  vec3 F_iridescence = max(I, vec3(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)\n{\n    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);\n    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nvec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)\n{\n    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    float D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nvec3 lightingWithPunctualLight(\n  Light light,\n  vec3 normal_inWorld,\n  vec3 viewDirection,\n  float NdotV,\n  vec3 albedo,\n  float perceptualRoughness,\n  float metallic,\n  vec3 F0,\n  vec3 F90,\n  float ior,\n  float transmission,\n  float clearcoat,\n  float clearcoatRoughness,\n  vec3 clearcoatNormal_inWorld,\n  float VdotNc,\n  vec3 attenuationColor,\n  float attenuationDistance,\n  float anisotropy,\n  vec3 anisotropicT,\n  vec3 anisotropicB,\n  float BdotV,\n  float TdotV,\n  vec3 sheenColor,\n  float sheenRoughness,\n  float albedoSheenScalingNdotV,\n  float iridescenceFactor,\n  vec3 iridescenceFresnel,\n  float specularWeight\n  )\n{\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  vec3 halfVector = normalize(light.direction + viewDirection);\n  float VdotH = dot(viewDirection, halfVector);\n  vec3 F = fresnel(F0, F90, VdotH);\n\n  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  vec3 diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  vec3 diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n\n  vec3 pureDiffuse = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  vec3 refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  Light transmittedLightFromUnderSurface = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  vec3 transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  vec3 Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  float NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  float NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  vec3 transmittedContrib = (vec3(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  vec3 diffuseContrib = mix(pureDiffuse, vec3(transmittedContrib), transmission);\n#else\n  vec3 diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  float NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n#ifdef RN_USE_IRIDESCENCE\n  vec3 specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  float TdotL = dot(anisotropicT, light.direction);\n  float BdotL = dot(anisotropicB, light.direction);\n  float TdotH = dot(anisotropicT, halfVector);\n  float BdotH = dot(anisotropicB, halfVector);\n  vec3 specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;\n#else\n  vec3 specularContrib = cook_torrance_specular_brdf(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3(NdotL) * light.attenuatedIntensity;\n#endif // RN_USE_ANISOTROPY\n\n  // Base Layer\n  vec3 baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  vec3 sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  float albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);\n  vec3 color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  vec3 color = baseLayer;\n  float albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  float NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  float LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  vec3 coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  vec3 finalColor = coated;\n#else\n  vec3 finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\n\n/* shaderity: @{matricesGetters} */\n\nvec3 get_irradiance(vec3 normal_forEnv, float materialSID, ivec2 hdriFormat) {\n  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);\n\n  vec3 irradiance;\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    irradiance = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    irradiance = diffuseTexel.rgb;\n  }\n\n  return irradiance;\n}\n\nfloat scaleForLod(float perceptualRoughness, float ior)\n{\n  // Scale roughness to the range [0, 1],\n  // ior=1.0 will be scale 0,\n  // ior=1.5 will be scale 1.0,\n  // ior=2 will be scale 1.0 (clamped)\n  //\n\n  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n  return perceptualRoughness * scale;\n}\n\n#ifdef RN_USE_TRANSMISSION\nvec3 get_sample_from_backbuffer(float materialSID, vec2 sampleCoord, float perceptualRoughness, float ior) {\n  ivec2 vrState = get_vrState(0.0, 0);\n  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));\n  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);\n\n#ifdef WEBGL2_MULTI_VIEW\n  // For VR\n  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n  sampleCoord.x = sampleCoord.x * 0.5;\n  if (v_displayIdx == 1.0) { // For right eye\n    sampleCoord.x += 0.5;\n  }\n#else\n  if (vrState.x == 1) { // For VR\n    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n    sampleCoord.x = sampleCoord.x * 0.5;\n    if (vrState.y == 1) { // For right eye\n      sampleCoord.x += 0.5;\n    }\n  }\n#endif\n\n  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);\n\n  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n    vec3 transmittedLight = texture2DLodEXT(u_backBufferTexture, sampleCoord, framebufferLod).rgb;\n  #elif defined(GLSL_ES3)\n    vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;\n  #else\n    vec3 transmittedLight = texture(u_backBufferTexture, sampleCoord).rgb;\n  #endif\n\n  return transmittedLight;\n}\n#endif\n\nvec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {\n  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n    vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, reflection, lod);\n  #elif defined(GLSL_ES3)\n    vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);\n  #else\n    vec4 specularTexel = texture(u_specularEnvTexture, reflection);\n  #endif\n\n// #pragma shaderity: require(./../common/fetchCubeTexture.glsl)\n\n  vec3 radiance;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    radiance = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    radiance = specularTexel.rgb;\n  }\n\n  return radiance;\n}\n\n// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer\nvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)\n{\n  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);\n\n  vec3 modelScale;\n  modelScale.x = length(vec3(worldMatrix[0].xyz));\n  modelScale.y = length(vec3(worldMatrix[1].xyz));\n  modelScale.z = length(vec3(worldMatrix[2].xyz));\n\n  return normalize(refractionVector) * thickness * modelScale;\n}\n\nstruct IblResult\n{\n  vec3 specular;\n  vec3 diffuse;\n  vec3 FssEss;\n};\n\n#ifdef RN_USE_IRIDESCENCE\nIblResult getIBLRadianceGGXWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceFresnel, float iridescence, float specularWeight)\n{\n  // get radiance\n  float mipCount = iblParameter.x;\n  float lod = (perceptualRoughness * (mipCount - 1.0));\n  vec3 radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  vec3 specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  float IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nIblResult getIBLRadianceLambertianWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceF0, float iridescence, float specularWeight)\n{\n  // get irradiance\n  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);\n\n  // Use the maximum component of the iridescence Fresnel color\n  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n  vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n  // Blend between base F0 and iridescence F0\n  vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescence);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  vec3 diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  float IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n#endif // RN_USE_IRIDESCENCE\n\nIblResult getIBLRadianceLambertian(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, float specularWeight)\n{\n  // get irradiance\n  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  vec3 diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  float IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n\nIblResult getIBLRadianceGGX(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, float specularWeight)\n{\n  // get radiance\n  float mipCount = iblParameter.x;\n  float lod = (perceptualRoughness * (mipCount - 1.0));\n  vec3 radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  vec3 specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  float IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\n#ifdef RN_USE_SHEEN\nvec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)\n{\n  float mipCount = iblParameter.x;\n  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));\n\n  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);\n  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;\n  vec3 sheenLight = get_radiance(reflection, lod, hdriFormat);\n  float IBLSpecularContribution = iblParameter.z;\n  sheenLight *= IBLSpecularContribution;\n\n  return sheenLight * sheenColor * brdf;\n}\n#endif\n\nvec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {\n  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;\n  if (get_inverseEnvironment(materialSID, 0)) {\n    normal_forEnv.x *= -1.0;\n  }\n  return normal_forEnv;\n}\n\nvec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {\n#ifdef RN_USE_ANISOTROPY\n\n  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);\n  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);\n  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);\n  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;\n  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);\n#else\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n#endif\n  if (get_inverseEnvironment(materialSID, 0)) {\n    reflection.x *= -1.0;\n  }\n  return reflection;\n}\n\nvec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,\n  vec3 albedo, vec3 F0, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,\n  float clearcoat, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,\n  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,\n  vec3 iridescenceFresnel, vec3 iridescenceF0, float iridescence, float anisotropy, vec3 anisotropyDirection,\n  float specularWeight)\n{\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float rot = iblParameter.w;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);\n\n  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);\n\n  // IBL\n  #ifdef RN_USE_IRIDESCENCE\n    IblResult baseRadianceResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);\n    IblResult baseLambertianResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);\n  #else\n    IblResult baseRadianceResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n    IblResult baseLambertianResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n  #endif\n\n#ifdef RN_USE_TRANSMISSION\n  vec3 refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior);\n  vec3 refractedRayFromVPosition = v_position_inWorld + refractedRay;\n  vec4 ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayFromVPosition, 1.0);\n  vec2 refractionCoords = ndcPoint.xy / ndcPoint.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  vec3 transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);\n\n#ifdef RN_USE_VOLUME\n  vec3 attenuationColor = get_attenuationColor(materialSID, 0);\n  float attenuationDistance = get_attenuationDistance(materialSID, 0);\n  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));\n#endif\n\n  vec3 transmissionComp = (vec3(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;\n  vec3 diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);\n  vec3 base = diffuse + baseRadianceResult.specular;\n#else\n  vec3 base = baseLambertianResult.diffuse + baseRadianceResult.specular;\n#endif\n\n#ifdef RN_USE_SHEEN\n  vec3 sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);\n  vec3 color = sheen + base * albedoSheenScalingNdotV;\n#else\n  vec3 color = base;\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  float VdotNg = dot(geomNormal_inWorld, viewDirection);\n  vec3 clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  IblResult coatResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3(0.0), F0,\n    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);\n  vec3 coatLayer = coatResult.specular;\n\n  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  vec3 coated = color * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(coatLayer * clearcoat);\n  return coated;\n#else\n  return color;\n#endif\n\n}\n\n\nuniform bool u_inverseEnvironment; // initialValue=false\nuniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true\nuniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true\n\nuniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true\nuniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true\n\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nconst float PI_2 = 6.28318530718;\n\nvec2 uvAnimation(vec2 origUv, float time, float uvAnimationMask, float uvAnimationScrollXSpeedFactor, float uvAnimationScrollYSpeedFactor, float uvAnimationRotationSpeedFactor) {\n  float uvAnim = uvAnimationMask * time;\n  vec2 uv = origUv;\n  uv += vec2(uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor) * uvAnim;\n  float rotateRad = uvAnimationRotationSpeedFactor * PI_2 * uvAnim;\n  const vec2 rotatePivot = vec2(0.5);\n  uv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (uv - rotatePivot) + rotatePivot;\n  return uv;\n}\n\n#ifdef RN_USE_TANGENT\n  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {\n    vec3 tangent_inWorld = normalize(v_tangent_inWorld);\n    vec3 binormal_inWorld = normalize(v_binormal_inWorld);\n    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {\n      uv = gl_FrontFacing ? uv : -uv;\n\n      // get edge vectors of the pixel triangle\n      vec3 dp1 = dFdx(position);\n      vec3 dp2 = dFdy(position);\n      vec2 duv1 = dFdx(uv);\n      vec2 duv2 = dFdy(uv);\n\n      // solve the linear system\n      vec3 dp2perp = cross(dp2, normal_inWorld);\n      vec3 dp1perp = cross(normal_inWorld, dp1);\n      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {\n      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\n\nvoid main (){\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      discard;\n    #endif\n  #endif\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // uv animation\n  float uvAnimationMaskTexture = texture(u_uvAnimationMaskTexture, v_texcoord_0).r;\n  float uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);\n  float uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);\n  float uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);\n  float time = get_time(0.0, 0);\n  vec2 mainUv = uvAnimation(v_texcoord_0, time, uvAnimationMaskTexture, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n\n  // main color\n  vec4 litTextureColor = texture(u_litColorTexture, mainUv);\n  vec4 litColorFactor = get_litColor(materialSID, 0);\n\n  // alpha\n  float alpha = 1.0;\n\n  #ifdef RN_ALPHATEST_ON\n    alpha = litTextureColor.a * litColorFactor.a;\n    float cutoff = get_cutoff(materialSID, 0);\n    if(alpha < cutoff) discard;\n  #elif defined(RN_ALPHABLEND_ON)\n    alpha = litTextureColor.a * litColorFactor.a;\n  #endif\n\n  if (alpha < 0.01) {\n    discard;\n  }else{\n    rt0.w = alpha;\n  }\n\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED\n      vec3 outlineColor = get_outlineColor(materialSID, 0);\n      rt0.xyz = outlineColor;\n\n      rt0.xyz = srgbToLinear(rt0.xyz);\n/* shaderity: @{renderTargetEnd} */\n\n      return;\n    #endif\n  #endif\n\n  // view vector\n  vec3 viewPosition = get_viewPosition(cameraSID, 0);\n  vec3 viewVector = viewPosition - v_position_inWorld.xyz;\n  vec3 viewDirection = normalize(viewVector);\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n  #ifdef RN_MTOON_HAS_BUMPMAP\n    vec3 normal = texture(u_normalTexture, mainUv).xyz * 2.0 - 1.0;\n    mat3 TBN = getTBN(normal_inWorld, viewDirection, mainUv);\n    normal_inWorld = normalize(TBN * normal);\n  #endif\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    normal_inWorld *= -1.0;\n  #endif\n\n\n  // Lighting, Direct Light\n\n  float shadowAttenuation = 1.0;\n  // TODO: shadowmap computation\n\n  float receiveShadowRate = get_receiveShadowRate(materialSID, 0);\n  float lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * texture(u_receiveShadowTexture, mainUv).r);\n\n  float shadingGradeRate = get_shadingGradeRate(materialSID, 0);\n  float shadingGrade = 1.0 - shadingGradeRate * (1.0 - texture(u_shadingGradeTexture, mainUv).r);\n  float lightColorAttenuation = get_lightColorAttenuation(materialSID, 0);\n\n  vec3 shadeColorFactor = get_shadeColor(materialSID, 0);\n  vec3 shadeColor = shadeColorFactor * srgbToLinear(texture(u_shadeColorTexture, mainUv).xyz);\n\n  vec3 litColor = litColorFactor.xyz * srgbToLinear(litTextureColor.xyz);\n\n  float shadeShift = get_shadeShift(materialSID, 0);\n  float shadeToony = get_shadeToony(materialSID, 0);\n\n  vec3 lightings[/* shaderity: @{Config.maxLightNumberInShader} */];\n  #ifdef RN_MTOON_DEBUG_LITSHADERATE\n    float lightIntensities[/* shaderity: @{Config.maxLightNumberInShader} */];\n  #endif\n  for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n    if (i >= lightNumber) {\n      break;\n    }\n\n    // Light\n    Light light = getLight(i, v_position_inWorld.xyz);\n\n    // lightAttenuation *= distanceAttenuation * spotEffect;\n    float dotNL = dot(light.direction, normal_inWorld);\n    float lightIntensity = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow\n    lightIntensity = lightIntensity * shadingGrade; // darker\n    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float minIntensityThreshold = shadeShift;\n    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);\n    #ifdef RN_MTOON_DEBUG_LITSHADERATE\n      lightIntensities[i] = lightIntensity;\n    #endif\n\n    // Albedo color\n    vec3 col = mix(shadeColor, litColor, lightIntensity);\n\n    // Direct Light\n    vec3 lighting = light.attenuatedIntensity;\n    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten\n\n\n    if(i > 0){\n      lighting *= 0.5; // darken if additional light.\n      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n      // lighting *= shadowAttenuation; // darken if receiving shadow\n      #ifdef RN_ALPHABLEND_ON\n        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.\n      #endif\n    }\n\n    col *= lighting * RECIPROCAL_PI;\n    lightings[i] = lighting;\n\n    rt0.xyz += col;\n\n    lightAttenuation = 1.0;\n  }\n\n\n  // Indirect Light\n  float indirectLightIntensity = get_indirectLightIntensity(materialSID, 0);\n  vec3 worldUpVector = vec3(0.0, 1.0, 0.0);\n  vec3 worldDownVector = vec3(0.0, -1.0, 0.0);\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float rot = iblParameter.w;\n  float IBLDiffuseContribution = iblParameter.y;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);\n  vec3 rawGiUp = get_irradiance(worldUpVector, materialSID, hdriFormat) * IBLDiffuseContribution;\n  vec3 rawGiDown = get_irradiance(worldDownVector, materialSID, hdriFormat) * IBLDiffuseContribution;\n  vec3 rawGiNormal = get_irradiance(normal_forEnv, materialSID, hdriFormat) * IBLDiffuseContribution;\n  vec3 uniformedGi = (rawGiUp + rawGiDown) / 2.0;\n  vec3 passthroughGi = rawGiNormal;\n  vec3 indirectLighting = mix(uniformedGi, passthroughGi, indirectLightIntensity);\n  indirectLighting = mix(indirectLighting, vec3(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten\n\n  rt0.xyz += indirectLighting * litColor * RECIPROCAL_PI;\n  // rt0.xyz = min(rt0.xyz, litColor); // comment out if you want to PBR absolutely.\n\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED\n      vec3 outlineColor = get_outlineColor(materialSID, 0);\n      // outlineColor = srgbToLinear(outlineColor);\n      float outlineLightingMix = get_outlineLightingMix(materialSID, 0);\n      rt0.xyz = outlineColor * mix(vec3(1.0), rt0.xyz, outlineLightingMix);\n    #endif\n  #else\n    float rimFresnelPower = get_rimFresnelPower(materialSID, 0);\n    float rimLift = get_rimLift(materialSID, 0);\n    vec3 rimColorFactor = get_rimColor(materialSID, 0);\n    vec3 rimTextureColor = texture(u_rimTexture, mainUv).xyz;\n    vec3 rimColor = rimColorFactor * srgbToLinear(rimTextureColor);\n    vec3 rim = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;\n\n    float staticRimLighting = 1.0;\n    float rimLightingMix = get_rimLightingMix(materialSID, 0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n      if (i >= lightNumber) break;\n\n      if(i > 0) staticRimLighting = 0.0;\n\n      vec3 rimLighting = mix(vec3(staticRimLighting), lightings[i], vec3(rimLightingMix));\n      rt0.xyz += rim * rimLighting;\n    }\n\n    // additive matcap\n    vec3 cameraUp = get_cameraUp(0.0, 0); //solo datum\n    vec3 worldViewUp = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));\n    vec3 worldViewRight = normalize(cross(viewDirection, worldViewUp));\n    vec2 matcapUv = vec2(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;\n    vec3 matCapColor = srgbToLinear(texture(u_matCapTexture, matcapUv).xyz);\n    rt0.xyz += matCapColor;\n\n\n    // Emission\n    vec3 emissionColor = get_emissionColor(materialSID, 0);\n    vec3 emission = srgbToLinear(texture(u_emissionTexture, mainUv).xyz) * emissionColor;\n    rt0.xyz += emission;\n  #endif\n\n\n  // debug\n  #ifdef RN_MTOON_DEBUG_NORMAL\n    rt0 = vec4(normal_inWorld * 0.5 + 0.5, alpha);\n\n    rt0.xyz = srgbToLinear(rt0.xyz);\n/* shaderity: @{renderTargetEnd} */\n\n    return;\n  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)\n    rt0 = vec4(0.0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n      if (i >= lightNumber) break;\n      rt0 += vec4(lightIntensities[i] * lightings[i], alpha);\n    }\n\n    rt0.xyz = srgbToLinear(rt0.xyz);\n/* shaderity: @{renderTargetEnd} */\n\n    return;\n  #endif\n\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\nfloat makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));\nrt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);\n\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},g={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n// This shader is based on https://github.com/Santarh/MToon\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n  var output : VertexOutput;\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    #endif\n  #endif\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let instanceId = u32(instance_ids.x);\n  let worldMatrix = get_worldMatrix(instanceId);\n  let normalMatrix = get_normalMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let skeletalComponentSID = i32(instance_ids.y);\n  let blendShapeComponentSID = u32(instance_ids.z);\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  output.position_inWorld = geom.position_inWorld.xyz;\n  output.normal_inWorld = geom.normal_inWorld;\n  output.normal_inView = (viewMatrix * vec4(geom.normal_inWorld, 0.0)).xyz;\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE\n      let textureSize = textureDimensions(outlineWidthTexture, 0);\n      let outlineTex = textureLoad(outlineWidthTexture, vec2u(vec2f(textureSize) * texcoord_0), 0).r;\n    #else\n      let outlineTex = 1.0;\n    #endif\n\n    #ifdef RN_MTOON_OUTLINE_WIDTH_WORLD\n      let outlineWidth: f32 = get_outlineWidth(materialSID, 0);\n      let outlineOffset: vec3f = 0.01 * outlineWidth * outlineTex * normal;\n      let worldOutlineOffset: vec4f = worldMatrix * vec4f(outlineOffset, 0.0);\n      output.position = projectionMatrix * viewMatrix * (geom.position_inWorld + worldOutlineOffset);\n\n    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)\n      var vertex: vec4f = projectionMatrix * viewMatrix * geom.position_inWorld;\n\n      let clipNormal: vec3f = (projectionMatrix * vec4f(output.normal_inView, 1.0)).xyz;\n      var projectedNormal: vec2f = normalize(clipNormal.xy);\n      let outlineScaledMaxDistance: f32 = get_outlineScaledMaxDistance(materialSID, 0);\n      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n      let aspect: f32 = abs(get_aspect(0, 0)); //solo datum\n      projectedNormal.x *= aspect;\n\n      let outlineWidth: f32 = get_outlineWidth(materialSID, 0);\n      vertex += vec4f(0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(output.normal_inView.z), 0.0, 1.0), 0.0, 0.0); // ignore offset when normal toward camera\n\n      output.position = vertex;\n    #else\n      output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n    #endif\n  #else\n    output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  #endif\n\n  #ifdef RN_USE_TANGENT\n    output.tangent_inWorld = normalMatrix * tangent.xyz;\n    output.binormal_inWorld = cross(geom.normal_inWorld, output.tangent_inWorld) * tangent.w;\n  #endif\n\n  output.texcoord_0 = texcoord_0;\n  output.baryCentricCoord = baryCentricCoord.xyz;\n\n  return output;\n}\n",shaderStage:"vertex",isFragmentShader:!1},y={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\nconst EPS_COL: f32 = 0.00001;\n\nfn edge_ratio(bary3: vec3f, wireframeWidthInner: f32, wireframeWidthRelativeScale: f32) -> f32 {\n  let d: vec3f = fwidth(bary3);\n  let x: vec3f = bary3 + vec3f(1.0 - wireframeWidthInner) * d;\n  let a3: vec3f = smoothstep(vec3f(0.0), d, x);\n  let factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nstruct Light {\n  lightType: i32, // 0 = directional, 1 = point, 2 = spot\n  position: vec3<f32>,\n  intensity: vec3<f32>,\n  attenuatedIntensity: vec3<f32>,\n  directionOfLightObject: vec3<f32>,\n  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)\n  pointToLight: vec3<f32>, // not normalized\n  spotAngleScale: f32,\n  spotAngleOffset: f32,\n  effectiveRange: f32,\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfn getRangeAttenuation(light: Light) -> f32\n{\n  let distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfn getSpotAttenuation(light: Light) -> f32\n{\n\n  let cd = dot(light.directionOfLightObject, light.direction);\n  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nfn getLightAttenuated(light: Light) -> Light {\n  var newLight: Light = light;\n  newLight.attenuatedIntensity = light.intensity;\n  // if (light.lightType == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.lightType == 1)\n  {\n    newLight.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.lightType == 2)\n  {\n    newLight.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n\n  return newLight;\n}\n\nfn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {\n  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);\n  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);\n  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);\n  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);\n  var light: Light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  let lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3f(0.0);\n    light.lightType = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.lightType = 1;\n  } else { // is Directional Light\n    light.lightType = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.lightType = 2;\n  }\n\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  let newLight = getLightAttenuated(light);\n\n  return newLight;\n}\n\n#ifdef RN_USE_TANGENT\n  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n    let tangent_inWorld = normalize(input.tangent_inWorld);\n    let binormal_inWorld = normalize(input.binormal_inWorld);\n    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {\n      var uv: vec2f;\n      if (isFront) {\n        uv = uv_;\n      } else {\n        uv = -uv_;\n      }\n\n      // get edge vectors of the pixel triangle\n      let dp1 = dpdx(position);\n      let dp2 = dpdy(position);\n      let duv1 = dpdx(uv);\n      let duv2 = dpdy(uv);\n\n      // solve the linear system\n      let dp2perp = cross(dp2, normal_inWorld);\n      let dp1perp = cross(normal_inWorld, dp1);\n      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nfn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {\n    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);\n}\n\nfn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {\n    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);\n}\n\n\n// The Schlick Approximation to Fresnel\nfn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnel2(f0: vec3f, VdotH: f32) -> vec3f\n{\n  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nfn fresnel2F32(f0: f32, VdotH: f32) -> f32\n{\n  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnelF32(f0, f90, VdotH);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nfn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nfn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f\n{\n  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n\n// GGX NDF\nfn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {\n  let roughnessSqr = alphaRoughness * alphaRoughness;\n  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {\n  let a2 = alphaRoughness * alphaRoughness;\n  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {\n  let D = d_GGX(NH, alphaRoughness);\n  let V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3f(D) * vec3f(V) * F * specularWeight;\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nfn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {\n  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );\n  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );\n  let r = Roughness * c0 + c1;\n  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nfn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n  let D = d_GGX(NdotHc, clearcoatAlpha);\n  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  let f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {\n  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  let D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nfn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;\n    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32\n{\n    let a2 = at * ab;\n    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);\n    let w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,\n    at: f32, ab: f32) -> f32\n{\n    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    let v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nfn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,\n    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,\n    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f\n{\n    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    let ab = alphaRoughness;\n\n    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let invAlpha  = 1.0 / alphaG;\n  let cos2h = NoH * NoH;\n  let sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn charlieL(x: f32, alphaG: f32) -> f32 {\n  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32\n{\n  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);\n}\n\nfn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nfn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {\n  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif // RN_USE_SHEEN\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst XYZ_TO_REC709 = mat3x3<f32>(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nfn fresnelSchlickRoughnessWithIridescence(\n  F0: vec3f, cosTheta: f32, roughness: f32,\n  iridescenceFresnel: vec3f, iridescence: f32\n  ) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nfn Fresnel0ToIor(F0: vec3f) -> vec3f {\n    let sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {\n    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {\n    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nfn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {\n    let phase = 2.0 * M_PI * OPD * 1.0e-9;\n    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    let rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nfn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));\n  let cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3f(1.0);\n  }\n\n  let cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);\n  let R12 = fresnel2F32(R0, cosTheta1);\n  let R21 = R12;\n  let T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);\n  let R23 = fresnel2(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  var phi12 = 0.0;\n  if (iridescenceIor < outsideIor) { phi12 = M_PI; }\n  let phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  var phi23 = vec3f(0.0);\n  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }\n  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }\n  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }\n\n  // OPD (optical path difference)\n  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  let phi = vec3f(phi21) + phi23;\n\n  // Compound terms\n  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));\n  let r123 = sqrt(R123);\n  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  let C0 = R12 + Rs;\n  var I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  var Cm = Rs - T121;\n  for (var m = 1; m <= 2; m++)\n  {\n      Cm *= r123;\n      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);\n      I += Cm * Sm;\n  }\n\n  let F_iridescence = max(I, vec3f(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nfn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f\n{\n    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n\n    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);\n\n    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nfn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f\n{\n    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    let D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nfn lightingWithPunctualLight(\n  light: Light,\n  normal_inWorld: vec3f,\n  viewDirection: vec3f,\n  NdotV: f32,\n  albedo: vec3f,\n  perceptualRoughness: f32,\n  F0: vec3f,\n  F90: vec3f,\n  transmission: f32,\n  ior: f32,\n  clearcoat: f32,\n  clearcoatRoughness: f32,\n  clearcoatNormal_inWorld: vec3f,\n  VdotNc: f32,\n  attenuationColor: vec3f,\n  attenuationDistance: f32,\n  anisotropy: f32,\n  anisotropicT: vec3f,\n  anisotropicB: vec3f,\n  BdotV: f32,\n  TdotV: f32,\n  sheenColor: vec3f,\n  sheenRoughness: f32,\n  albedoSheenScalingNdotV: f32,\n  iridescenceFactor: f32,\n  iridescenceFresnel: vec3f,\n  specularWeight: f32,\n  ) -> vec3f\n{\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  let halfVector = normalize(light.direction + viewDirection);\n  let VdotH = dot(viewDirection, halfVector);\n  let F = fresnel(F0, F90, VdotH);\n\n  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  var transmittedLightFromUnderSurface: Light = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);\n#else\n  let diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n\n#ifdef RN_USE_IRIDESCENCE\n  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  let TdotL = dot(anisotropicT, light.direction);\n  let BdotL = dot(anisotropicB, light.direction);\n  let TdotH = dot(anisotropicT, halfVector);\n  let BdotH = dot(anisotropicB, halfVector);\n  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;\n#else\n  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;\n#endif\n\n  // Base Layer\n  let baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  let albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);\n  let color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  let color = baseLayer;\n  let albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  let coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  let finalColor = coated;\n#else\n  let finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\nfn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {\n  let SIGMA2 = 0.15915494;\n  let KAPPA = 0.18;\n  let dndu  = dpdx(normal);\n  let dndv = dpdy(normal);\n  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(16) var diffuseEnvSampler: sampler;\n@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(17) var specularEnvSampler: sampler;\n\n// #param inverseEnvironment: bool; // initialValue=false\n// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true\n// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true\n\nfn get_irradiance(normal_forEnv: vec3f, hdriFormat: vec2<i32>) -> vec3f {\n  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);\n\n  var irradiance: vec3f;\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    irradiance = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    irradiance = diffuseTexel.rgb;\n  }\n\n  return irradiance;\n}\n\nfn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {\n  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);\n\n  var radiance: vec3f;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    radiance = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    radiance = specularTexel.rgb;\n  }\n\n  return radiance;\n}\n\n#ifdef RN_USE_SHEEN\nfn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f\n{\n  let mipCount = iblParameter.x;\n  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));\n\n  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);\n  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;\n  var sheenLight = get_radiance(reflection, lod, hdriFormat);\n  let IBLSpecularContribution = iblParameter.z;\n  sheenLight *= IBLSpecularContribution;\n\n  return sheenLight * sheenColor * brdf;\n}\n#endif\n\nfn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {\n  var normal_forEnv = rotEnvMatrix * normal_inWorld;\n  if (get_inverseEnvironment(materialSID, 0)) {\n    normal_forEnv.x *= -1.0;\n  }\n  return normal_forEnv;\n}\n\nfn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,\n  materialSID: u32, perceptualRoughness: f32,\n  anisotropy: f32, anisotropyDirection: vec3f\n  ) -> vec3f {\n#ifdef RN_USE_ANISOTROPY\n  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);\n  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);\n  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);\n  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;\n  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));\n  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);\n#else\n  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n#endif\n  if (get_inverseEnvironment(materialSID, 0)) {\n    reflection.x *= -1.0;\n  }\n  return reflection;\n}\n\nfn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32\n{\n  // Scale roughness to the range [0, 1],\n  // ior=1.0 will be scale 0,\n  // ior=1.5 will be scale 1.0,\n  // ior=2 will be scale 1.0 (clamped)\n  //\n\n  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n  return perceptualRoughness * scale;\n}\n\n#ifdef RN_USE_TRANSMISSION\nfn get_sample_from_backbuffer(materialSID: u32, sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {\n  let vrState: vec2<i32> = get_vrState(0, 0);\n  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));\n  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);\n  var newSampleCoord = sampleCoord;\n  newSampleCoord.y = 1.0 - newSampleCoord.y;\n  if (vrState.x == 1) { // For VR\n    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n    newSampleCoord.x = sampleCoord.x * 0.5;\n    if (vrState.y == 1) { // For right eye\n      newSampleCoord.x += 0.5;\n    }\n  }\n  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);\n\n  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;\n\n  return transmittedLight;\n}\n\n// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer\nfn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f\n{\n  let refractionVector = refract(-v, normalize(n), 1.0 / ior);\n  let worldMatrix = get_worldMatrix(instanceInfo);\n\n  var modelScale: vec3f;\n  modelScale.x = length(vec3f(worldMatrix[0].xyz));\n  modelScale.y = length(vec3f(worldMatrix[1].xyz));\n  modelScale.z = length(vec3f(worldMatrix[2].xyz));\n\n  return normalize(refractionVector) * thickness * modelScale;\n}\n#endif // RN_USE_TRANSMISSION\n\nstruct IblResult\n{\n  specular: vec3f,\n  diffuse: vec3f,\n  FssEss: vec3f,\n};\n\n\n#ifdef RN_USE_IRIDESCENCE\nfn getIBLRadianceGGXWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, iridescenceFresnel: vec3f, iridescence: f32, specularWeight: f32) -> IblResult\n{\n  // get radiance\n  let mipCount = iblParameter.x;\n  let lod = (perceptualRoughness * (mipCount - 1.0));\n  let radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);\n  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss = kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  var specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  let IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nfn getIBLRadianceLambertianWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, iridescenceF0: vec3f, iridescence: f32, specularWeight: f32) -> IblResult\n{\n  // get irradiance\n  let irradiance = get_irradiance(normal_forEnv, hdriFormat);\n\n  // Use the maximum component of the iridescence Fresnel color\n  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n  let iridescenceF0Max = vec3f(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n  // Blend between base F0 and iridescence F0\n  let mixedF0 = mix(F0, iridescenceF0Max, iridescence);\n\n  // Roughness dependent fresnel\n  let kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);\n  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  let Ems = (1.0 - (f_ab.x + f_ab.y));\n  let F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n  let FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  let k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  var diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  let IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n#endif // RN_USE_IRIDESCENCE\n\nfn getIBLRadianceLambertian(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult\n{\n  // get irradiance\n  let irradiance: vec3f = get_irradiance(normal_forEnv, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss: vec3f = specularWeight * kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  let Ems = (1.0 - (f_ab.x + f_ab.y));\n  let F_avg: vec3f = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  let k_D: vec3f = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  var diffuse: vec3f = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  let IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n\nfn getIBLRadianceGGX(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult\n{\n  // get radiance\n  let mipCount = iblParameter.x;\n  let lod = (perceptualRoughness * (mipCount - 1.0));\n  let radiance: vec3f = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss: vec3f = kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  var specular: vec3f = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  let IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nfn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,\n  albedo: vec3f, F0: vec3f, perceptualRoughness: f32,\n  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, VdotNc: f32, geomNormal_inWorld: vec3f,\n  transmission: f32, v_position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,\n  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,\n  iridescenceFresnel: vec3f, iridescenceF0: vec3f, iridescence: f32,\n  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32\n  ) -> vec3f\n{\n  let iblParameter: vec4f = get_iblParameter(materialSID, 0);\n  let rot = iblParameter.w;\n  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);\n\n  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);\n\n  // IBL\n#ifdef RN_USE_IRIDESCENCE\n  let baseRadianceResult: IblResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);\n  let baseLambertianResult: IblResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);\n#else\n  let baseRadianceResult: IblResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n  let baseLambertianResult: IblResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n#endif\n\n#ifdef RN_USE_TRANSMISSION\n  let refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior, instanceInfo);\n  let refractedRayFromVPosition = v_position_inWorld + refractedRay;\n  let ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayFromVPosition, 1.0);\n  var refractionCoords = ndcPoint.xy / ndcPoint.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  var transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);\n\n#ifdef RN_USE_VOLUME\n  let attenuationColor = get_attenuationColor(materialSID, 0);\n  let attenuationDistance = get_attenuationDistance(materialSID, 0);\n  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));\n#endif\n\n  let transmissionComp = (vec3f(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;\n  let diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);\n  let base = diffuse + baseRadianceResult.specular;\n#else\n  let base: vec3f = baseLambertianResult.diffuse + baseRadianceResult.specular;\n#endif\n\n#ifdef RN_USE_SHEEN\n  let sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);\n  let color = sheen + base * albedoSheenScalingNdotV;\n#else\n  let color = base;\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  let VdotNg = dot(geomNormal_inWorld, viewDirection);\n  let clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let coatResult: IblResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3f(0.0), F0,\n    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);\n  let coatLayer = coatResult.specular;\n\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let coated = color * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(coatLayer * clearcoat);\n  return coated;\n#else\n  return color;\n#endif\n}\n\n\n\nconst PI_2: f32 = 6.28318530718;\n\nfn uvAnimation(origUv: vec2f, time: f32, uvAnimationMask: f32, uvAnimationScrollXSpeedFactor: f32, uvAnimationScrollYSpeedFactor: f32, uvAnimationRotationSpeedFactor: f32) -> vec2f {\n  let uvAnim = uvAnimationMask * time;\n  var uv = origUv;\n  uv += vec2f(uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor) * uvAnim;\n  let rotateRad = uvAnimationRotationSpeedFactor * PI_2 * uvAnim;\n  let rotatePivot = vec2f(0.5);\n  uv = mat2x2f(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (uv - rotatePivot) + rotatePivot;\n  return uv;\n}\n\n@fragment\nfn main (\n  input: VertexOutput,\n  @builtin(front_facing) isFront: bool\n) -> @location(0) vec4<f32> {\n  var rt0 = vec4f(0.0, 0.0, 0.0, 1.0);\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      discard;\n    #endif\n  #endif\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  // uv animation\n  let uvAnimationMaskTexture = textureSample(uvAnimationMaskTexture, uvAnimationMaskSampler, input.texcoord_0).r;\n  let uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);\n  let uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);\n  let uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);\n  let time = get_time(0, 0);\n  let mainUv = uvAnimation(input.texcoord_0, time, uvAnimationMaskTexture, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n\n  // main color\n  let litTextureColor: vec4f = textureSample(litColorTexture, litColorSampler, mainUv);\n  let litColorFactor: vec4f = get_litColor(materialSID, 0);\n\n  // alpha\n  var alpha = 1.0;\n\n  #ifdef RN_ALPHATEST_ON\n    alpha = litTextureColor.a * litColorFactor.a;\n    let cutoff: f32 = get_cutoff(materialSID, 0);\n    if (alpha < cutoff) { discard; }\n  #elif defined(RN_ALPHABLEND_ON)\n    alpha = litTextureColor.a * litColorFactor.a;\n  #endif\n\n  if (alpha < 0.01) {\n    discard;\n  } else {\n    rt0.w = alpha;\n  }\n\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED\n      let outlineColor: vec3f = get_outlineColor(materialSID, 0);\n      rt0 = vec4f(outlineColor, rt0.w);\n\n      rt0 = vec4(srgbToLinear(rt0.xyz), rt0.w);\n      return rt0;\n    #endif\n  #endif\n\n  // view vector\n  let viewPosition: vec3f = get_viewPosition(cameraSID, 0);\n  let viewVector: vec3f = viewPosition - input.position_inWorld.xyz;\n  let viewDirection: vec3f = normalize(viewVector);\n\n  // Normal\n  var normal_inWorld: vec3f = normalize(input.normal_inWorld);\n  #ifdef RN_MTOON_HAS_BUMPMAP\n    let normal: vec3f = textureSample(normalTexture, normalSampler, mainUv).xyz * 2.0 - 1.0;\n    let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewDirection, mainUv, isFront);\n    normal_inWorld = normalize(TBN * normal);\n  #endif\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    normal_inWorld *= -1.0;\n  #endif\n\n\n  // Lighting, Direct Light\n\n  let shadowAttenuation = 1.0;\n  // TODO: shadowmap computation\n\n  let receiveShadowRate: f32 = get_receiveShadowRate(materialSID, 0);\n  var lightAttenuation: f32 = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * textureSample(receiveShadowTexture, receiveShadowSampler, mainUv).r);\n\n  let shadingGradeRate: f32 = get_shadingGradeRate(materialSID, 0);\n  let shadingGrade: f32 = 1.0 - shadingGradeRate * (1.0 - textureSample(shadingGradeTexture, shadingGradeSampler, mainUv).r);\n  let lightColorAttenuation: f32 = get_lightColorAttenuation(materialSID, 0);\n\n  let shadeColorFactor: vec3f = get_shadeColor(materialSID, 0);\n  var shadeColor: vec3f = shadeColorFactor * srgbToLinear(textureSample(shadeColorTexture, shadeColorSampler, mainUv).xyz);\n\n  var litColor: vec3f = litColorFactor.xyz * srgbToLinear(litTextureColor.xyz);\n\n  let shadeShift: f32 = get_shadeShift(materialSID, 0);\n  let shadeToony: f32 = get_shadeToony(materialSID, 0);\n\n  var lightings: array<vec3<f32>, /* shaderity: @{Config.maxLightNumberInShader} */>;\n  #ifdef RN_MTOON_DEBUG_LITSHADERATE\n    var lightIntensities[/* shaderity: @{Config.maxLightNumberInShader} */]: array<f32>;\n  #endif\n  let lightNumber = u32(get_lightNumber(0u, 0u));\n  for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n    if (i >= lightNumber) {\n      break;\n    }\n\n    // Light\n    let light: Light = getLight(i, input.position_inWorld.xyz);\n\n    // lightAttenuation *= distanceAttenuation * spotEffect;\n    let dotNL: f32 = dot(light.direction, normal_inWorld);\n    var lightIntensity: f32 = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow\n    lightIntensity = lightIntensity * shadingGrade; // darker\n    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    let maxIntensityThreshold: f32 = mix(1.0, shadeShift, shadeToony);\n    let minIntensityThreshold: f32 = shadeShift;\n    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);\n    #ifdef RN_MTOON_DEBUG_LITSHADERATE\n      lightIntensities[i] = lightIntensity;\n    #endif\n\n    // Albedo color\n    var col: vec3f = mix(shadeColor, litColor, lightIntensity);\n\n    // Direct Light\n    var lighting: vec3f = light.attenuatedIntensity;\n    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten\n\n\n    if(i > 0){\n      lighting *= 0.5; // darken if additional light.\n      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n      // lighting *= shadowAttenuation; // darken if receiving shadow\n      #ifdef RN_ALPHABLEND_ON\n        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.\n      #endif\n    }\n\n    col *= lighting * RECIPROCAL_PI;\n    lightings[i] = lighting;\n\n    rt0 += vec4f(col, 0.0);\n\n    lightAttenuation = 1.0;\n  }\n\n\n  // Indirect Light\n  let indirectLightIntensity = get_indirectLightIntensity(materialSID, 0);\n  let worldUpVector = vec3f(0.0, 1.0, 0.0);\n  let worldDownVector = vec3f(0.0, -1.0, 0.0);\n  let iblParameter = get_iblParameter(materialSID, 0);\n  let rot = iblParameter.w;\n  let IBLDiffuseContribution = iblParameter.y;\n  let rotEnvMatrix = mat3x3f(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  let normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let hdriFormat = get_hdriFormat(materialSID, 0);\n  let rawGiUp = get_irradiance(worldUpVector, hdriFormat) * IBLDiffuseContribution;\n  let rawGiDown = get_irradiance(worldDownVector, hdriFormat) * IBLDiffuseContribution;\n  let rawGiNormal = get_irradiance(normal_forEnv, hdriFormat) * IBLDiffuseContribution;\n  let uniformedGi = (rawGiUp + rawGiDown) / 2.0;\n  let passthroughGi = rawGiNormal;\n  var indirectLighting = mix(uniformedGi, passthroughGi, indirectLightIntensity);\n  indirectLighting = mix(indirectLighting, vec3f(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten\n  rt0 += vec4f(indirectLighting * litColor * RECIPROCAL_PI, 0.0);\n  // rt0 = vec4f(min(rt0.xyz, litColor), rt0.w); // comment out if you want to PBR absolutely.\n\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED\n      var outlineColor: vec3f = get_outlineColor(materialSID, 0);\n      // outlineColor = srgbToLinear(outlineColor);\n      let outlineLightingMix: f32 = get_outlineLightingMix(materialSID, 0);\n      rt0 = vec4f(outlineColor * mix(vec3f(1.0), rt0.xyz, outlineLightingMix), rt0.w);\n    #endif\n  #else\n    let rimFresnelPower: f32 = get_rimFresnelPower(materialSID, 0);\n    let rimLift: f32 = get_rimLift(materialSID, 0);\n    let rimColorFactor: vec3f = get_rimColor(materialSID, 0);\n    let rimTextureColor: vec3f = textureSample(rimTexture, rimSampler, mainUv).xyz;\n    let rimColor: vec3f = rimColorFactor * srgbToLinear(rimTextureColor);\n    let rim: vec3f = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;\n\n    var staticRimLighting = 1.0;\n    let rimLightingMix: f32 = get_rimLightingMix(materialSID, 0);\n    for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */u; i++) {\n      if (i >= lightNumber) { break; }\n\n      if (i > 0) { staticRimLighting = 0.0; }\n\n      let rimLighting: vec3f = mix(vec3f(staticRimLighting), lightings[i], vec3f(rimLightingMix));\n      rt0 += vec4f(rim * rimLighting, 0.0);\n    }\n\n    // additive matcap\n    let cameraUp: vec3f = get_cameraUp(0u, 0u); //solo datum\n    let worldViewUp: vec3f = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));\n    let worldViewRight: vec3f = normalize(cross(viewDirection, worldViewUp));\n    let matcapUv: vec2f = vec2f(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;\n    let matCapColor: vec3f = srgbToLinear(textureSample(matCapTexture, matCapSampler, matcapUv).xyz);\n    rt0 += vec4f(matCapColor, 0.0);\n\n\n    // Emission\n    let emissionColor: vec3f = get_emissionColor(materialSID, 0);\n    let emission: vec3f = srgbToLinear(textureSample(emissionTexture, emissionSampler, mainUv).xyz) * emissionColor;\n    rt0 += vec4f(emission, 0.0);\n  #endif\n\n\n  // debug\n  #ifdef RN_MTOON_DEBUG_NORMAL\n    rt0 = vec4f(normal_inWorld * 0.5 + 0.5, alpha);\n\n    rt0 = vec4f(srgbToLinear(rt0.xyz), rt0.w);\n    return rt0;\n  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)\n    rt0 = vec4f(0.0);\n    for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */u; i++) {\n      if (i >= lightNumber) { break; }\n      rt0 += vec4f(lightIntensities[i] * lightings[i], alpha);\n    }\n\n    rt0 = vec4f(srgbToLinear(rt0.xyz), rt0.w);\n    return rt0;\n  #endif\n\n\n  // Wireframe\n  let threshold = 0.001;\n  let wireframe: vec3f = get_wireframe(materialSID, 0);\n  let wireframeWidthInner = wireframe.z;\n  let wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  var wireframeResult = rt0;\n  let wireframeColor = vec4f(0.2, 0.75, 0.0, 1.0);\n  let edgeRatio: f32 = edge_ratio(input.baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  let edgeRatioModified: f32 = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult = vec4f(wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified), wireframeResult.a);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n  let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);\n  rt0 = vec4f(select(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb), rt0.w);\n\n  return rt0;\n}\n",shaderStage:"fragment",isFragmentShader:!0};var b=n(2238),I=n(9993),A=n(3886),E=n(589),S=n(7670),T=n(2766),w=n(4289),C=n(8924),R=n(5882);class P extends o.F{constructor(e,t,n,o,a,i,r,s,f,b,I){var A,S,T;super(I,{isMorphing:a,isSkinning:i,isLighting:r}),this.__OutlineWidthModeIsScreen=!1,this.__floatProperties={},this.__vectorProperties={},this.__textureProperties={};const w=this.doShaderReflection(v,x,g,y);switch(P.__diffuseIblCubeMapSampler.created||P.__diffuseIblCubeMapSampler.create(),P.__specularIblCubeMapSampler.created||P.__specularIblCubeMapSampler.create(),null!=t?(this.__floatProperties=t.floatProperties,this.__vectorProperties=t.vectorProperties,this.__textureProperties=JSON.parse(JSON.stringify(t.textureProperties))):(this.__floatProperties._BlendMode=0,this.__floatProperties._BumpScale=1,this.__floatProperties._CullMode=2,this.__floatProperties._Cutoff=.5,this.__floatProperties._DebugMode=0,this.__floatProperties._DstBlend=0,this.__floatProperties._IndirectLightIntensity=.1,this.__floatProperties._LightColorAttenuation=0,this.__floatProperties._OutlineColorMode=0,this.__floatProperties._OutlineCullMode=1,this.__floatProperties._OutlineLightingMix=1,this.__floatProperties._OutlineScaledMaxDistance=1,this.__floatProperties._OutlineWidth=.5,this.__floatProperties._OutlineWidthMode=0,this.__floatProperties._ReceiveShadowRate=1,this.__floatProperties._RimFresnelPower=1,this.__floatProperties._RimLift=0,this.__floatProperties._RimLightingMix=0,this.__floatProperties._ShadeShift=0,this.__floatProperties._ShadeToony=.9,this.__floatProperties._ShadingGradeRate=1,this.__floatProperties._SrcBlend=1,this.__floatProperties._ZWrite=1,this.__floatProperties._UvAnimScrollX=0,this.__floatProperties._UvAnimScrollY=0,this.__floatProperties._UvAnimRotation=0,this.__vectorProperties._Color=[1,1,1,1],this.__vectorProperties._EmissionColor=[0,0,0],this.__vectorProperties._OutlineColor=[0,0,0,1],this.__vectorProperties._ShadeColor=[.97,.81,.86,1],this.__vectorProperties._RimColor=[0,0,0]),f&&(this.__floatProperties._DebugMode=f),w.push({semantic:"cutoff",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._Cutoff),min:0,max:1},{semantic:"litColor",componentType:l.I.Float,compositionType:c.h.Vec4,stage:d.C.PixelShader,initialValue:m.IU.fromCopyArray(this.__vectorProperties._Color),min:0,max:1},{semantic:"shadeColor",componentType:l.I.Float,compositionType:c.h.Vec3,stage:d.C.PixelShader,initialValue:h.Pq.fromCopyArray(this.__vectorProperties._ShadeColor),min:0,max:1},{semantic:"bumpScale",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._BumpScale),min:0,max:1},{semantic:"receiveShadowRate",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._ReceiveShadowRate),min:0,max:1},{semantic:"shadingGradeRate",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._ShadingGradeRate),min:0,max:1},{semantic:"shadeShift",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._ShadeShift),min:0,max:1},{semantic:"shadeToony",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._ShadeToony),min:0,max:1},{semantic:"lightColorAttenuation",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._LightColorAttenuation),min:0,max:1},{semantic:"indirectLightIntensity",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._IndirectLightIntensity),min:0,max:1},{semantic:"rimColor",componentType:l.I.Float,compositionType:c.h.Vec3,stage:d.C.PixelShader,initialValue:h.Pq.fromCopyArray(this.__vectorProperties._RimColor),min:0,max:1},{semantic:"rimLightingMix",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._RimLightingMix),min:0,max:1},{semantic:"rimFresnelPower",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._RimFresnelPower),min:0,max:1},{semantic:"rimLift",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._RimLift),min:0,max:1},{semantic:"cameraUp",componentType:l.I.Float,compositionType:c.h.Vec3,stage:d.C.PixelShader,soloDatum:!0,initialValue:h.Pq.fromCopyArray([0,1,0]),min:0,max:1},{semantic:"emissionColor",componentType:l.I.Float,compositionType:c.h.Vec3,stage:d.C.PixelShader,initialValue:h.Pq.fromCopyArray(this.__vectorProperties._EmissionColor),min:0,max:1},{semantic:"uvAnimationScrollXSpeedFactor",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,isInternalSetting:!1,initialValue:u.X5.fromCopyNumber(null!==(A=this.__floatProperties._UvAnimScrollX)&&void 0!==A?A:0),min:0,max:1},{semantic:"uvAnimationScrollYSpeedFactor",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,isInternalSetting:!1,initialValue:u.X5.fromCopyNumber(null!==(S=this.__floatProperties._UvAnimScrollY)&&void 0!==S?S:0),min:0,max:1},{semantic:"uvAnimationRotationSpeedFactor",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,isInternalSetting:!1,initialValue:u.X5.fromCopyNumber(null!==(T=this.__floatProperties._UvAnimRotation)&&void 0!==T?T:0),min:0,max:1},{semantic:"wireframe",componentType:l.I.Float,compositionType:c.h.Vec3,stage:d.C.PixelShader,initialValue:h.Pq.fromCopyArray([0,0,1]),min:0,max:10},{semantic:"makeOutputSrgb",compositionType:c.h.Scalar,componentType:l.I.Bool,stage:d.C.PixelShader,min:0,max:1,initialValue:u.X5.fromCopyNumber(b?1:0)}),this.__floatProperties._DebugMode){case 1:this.__definitions+="#define RN_MTOON_DEBUG_NORMAL\n";break;case 2:this.__definitions+="#define RN_MTOON_DEBUG_LITSHADERATE\n"}if(e){switch(this.__definitions+="#define RN_MTOON_IS_OUTLINE\n",this.__floatProperties._OutlineWidthMode){case 0:this.__definitions+="#define RN_MTOON_OUTLINE_NONE\n";break;case 1:this.__definitions+="#define RN_MTOON_OUTLINE_WIDTH_WORLD\n";break;case 2:this.__definitions+="#define RN_MTOON_OUTLINE_WIDTH_SCREEN\n",this.__OutlineWidthModeIsScreen=!0}switch(this.__floatProperties._OutlineColorMode){case 0:this.__definitions+="#define RN_MTOON_OUTLINE_COLOR_FIXED\n";break;case 1:this.__definitions+="#define RN_MTOON_OUTLINE_COLOR_MIXED\n"}w.push({semantic:"outlineWidth",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.VertexShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._OutlineWidth),min:0,max:1},{semantic:"outlineScaledMaxDistance",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.VertexShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._OutlineScaledMaxDistance),min:0,max:1},{semantic:"outlineColor",componentType:l.I.Float,compositionType:c.h.Vec3,stage:d.C.PixelShader,initialValue:h.Pq.fromCopyArray(this.__vectorProperties._OutlineColor),min:0,max:1},{semantic:"outlineLightingMix",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.PixelShader,initialValue:u.X5.fromCopyNumber(this.__floatProperties._OutlineLightingMix),min:0,max:1},{semantic:"aspect",componentType:l.I.Float,compositionType:c.h.Scalar,stage:d.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:u.X5.fromCopyNumber(1),min:0,max:1})}r&&(this.__definitions+="#define RN_IS_LIGHTING\n"),i&&(this.__definitions+="#define RN_IS_SKINNING\n"),a&&(this.__definitions+="#define RN_IS_MORPHING\n",w.push({semantic:"dataTextureMorphOffsetPosition",componentType:l.I.Int,compositionType:c.h.ScalarArray,arrayLength:_.T.maxVertexMorphNumberInShader,stage:d.C.VertexShader,isInternalSetting:!0,initialValue:new p.u(new Int32Array(_.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:l.I.Float,compositionType:c.h.ScalarArray,arrayLength:_.T.maxVertexMorphNumberInShader,stage:d.C.VertexShader,isInternalSetting:!0,initialValue:new p.u(new Float32Array(_.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0})),s&&(this.__definitions+="#define RN_USE_TANGENT_ATTRIBUTE\n"),this.__textureProperties._BumpMap>=0&&(this.__definitions+="#define RN_MTOON_HAS_BUMPMAP\n"),this.__textureProperties._OutlineWidthTexture>=0&&(this.__definitions+="#define RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE\n"),n=[E.vK,E.rT],this.__textureProperties._BumpMap=0,this.__textureProperties._EmissionMap=1,this.__textureProperties._MainTex=0,this.__textureProperties._OutlineWidthTexture=0,this.__textureProperties._UvAnimMaskTexture=0,this.__textureProperties._ReceiveShadowTexture=0,this.__textureProperties._RimTexture=1,this.__textureProperties._ShadeTexture=0,this.__textureProperties._ShadingGradeTexture=0,this.__textureProperties._SphereAdd=1,this.__setDummyTextures(n,o,w,e),this.setShaderSemanticsInfoArray(w)}__setDummyTextures(e,t,n,o){n.push({semantic:"litColorTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[0,e[this.__textureProperties._MainTex],t[this.__textureProperties._MainTex]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"shadeColorTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[1,e[this.__textureProperties._ShadeTexture],t[this.__textureProperties._ShadeTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"receiveShadowTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[2,e[this.__textureProperties._ReceiveShadowTexture],t[this.__textureProperties._ReceiveShadowTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"shadingGradeTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[3,e[this.__textureProperties._ShadingGradeTexture],t[this.__textureProperties._ShadingGradeTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"rimTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[4,e[this.__textureProperties._RimTexture],t[this.__textureProperties._RimTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"matCapTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[8,e[this.__textureProperties._SphereAdd],t[this.__textureProperties._SphereAdd]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"emissionTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[9,e[this.__textureProperties._EmissionMap],t[this.__textureProperties._EmissionMap]],min:0,max:Number.MAX_SAFE_INTEGER}),n.push({semantic:"normalTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[10,e[this.__textureProperties._BumpMap],t[this.__textureProperties._BumpMap]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"uvAnimationMaskTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.PixelShader,initialValue:[11,e[this.__textureProperties._UvAnimMaskTexture],t[this.__textureProperties._UvAnimMaskTexture]],min:0,max:Number.MAX_SAFE_INTEGER}),o&&n.push({semantic:"outlineWidthTexture",componentType:l.I.Int,compositionType:c.h.Texture2D,stage:d.C.VertexShader,initialValue:[12,e[this.__textureProperties._OutlineWidthTexture],t[this.__textureProperties._OutlineWidthTexture]],min:0,max:Number.MAX_SAFE_INTEGER})}setMaterialParameters(e,t){if(null==P.usableBlendEquationModeAlpha&&P.__initializeUsableBlendEquationModeAlpha(),0!==this.__floatProperties._BlendMode){switch(this.__floatProperties._BlendMode){case 1:this.__definitions+="#define RN_ALPHATEST_ON\n",e.alphaMode=a.K.Mask;break;case 2:case 3:this.__definitions+="#define RN_ALPHABLEND_ON\n",e.alphaMode=a.K.Blend}const t=32774,n=P.usableBlendEquationModeAlpha,o=P.unityBlendEnumCorrespondence(this.__floatProperties._SrcBlend),i=P.unityBlendEnumCorrespondence(this.__floatProperties._DstBlend);e.setBlendEquationMode(A.E.from(t),null!=n?A.E.from(n):void 0),e.setBlendFuncFactor(A.E.from(o),A.E.from(i))}if(t)switch(this.__floatProperties._OutlineCullMode){case 0:e.cullFace=!1;break;case 1:e.cullFace=!0,e.cullFaceBack=!1;break;case 2:e.cullFace=!0,e.cullFaceBack=!0}else switch(this.__floatProperties._CullMode){case 0:e.cullFace=!1;break;case 1:e.cullFace=!0,e.cullFaceBack=!1;break;case 2:e.cullFace=!0,e.cullFaceBack=!0}e.zWriteWhenBlend=1===this.__floatProperties._ZWrite}static __initializeUsableBlendEquationModeAlpha(){if(S.l.currentProcessApproach===T.m7.WebGPU)P.usableBlendEquationModeAlpha=32776;else{const e=r.f.getWebGLResourceRepository().currentWebGLContextWrapper,t=e.getRawContextAsWebGL2();e.isWebGL2?P.usableBlendEquationModeAlpha=t.MAX:e.webgl1ExtBM?P.usableBlendEquationModeAlpha=e.webgl1ExtBM.MAX_EXT:P.usableBlendEquationModeAlpha=t.FUNC_ADD}}_setInternalSettingParametersToGpuWebGpu({material:e,args:t}){let n=s.O.getComponentFromComponentTID(w.N.CameraComponentTID,t.cameraComponentSid);e.setParameter("cameraUp",n.upInner),this.__OutlineWidthModeIsScreen&&e.setParameter("aspect",n.aspect);const{mipmapLevelNumber:a,meshRenderComponent:i,diffuseHdriType:r,specularHdriType:l}=P.__setupHdriParameters(t),c=o.F.__tmp_vector4;c.x=a,c.y=i.diffuseCubeMapContribution,c.z=i.specularCubeMapContribution,c.w=i.rotationOfCubeMap,e.setParameter("iblParameter",c);const _=o.F.__tmp_vector2;_.x=r,_.y=l,e.setParameter("hdriFormat",_);const u=t.entity.tryToGetMeshRenderer();if(null!=u&&null!=u.diffuseCubeMap&&null!=u.specularCubeMap){const t=C.Am.zero(),n=R.A3.zero();t.x=u.specularCubeMap.mipmapLevelNumber,t.y=u.diffuseCubeMapContribution,t.z=u.specularCubeMapContribution,t.w=u.rotationOfCubeMap,e.setParameter("iblParameter",t),n.x=u.diffuseCubeMap.hdriFormat.index,n.y=u.specularCubeMap.hdriFormat.index,e.setParameter("hdriFormat",n)}}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:a}){let l=a.renderPass.cameraComponent;if(null==l&&(l=s.O.getComponent(i.n,i.n.current)),a.setUniform){this.setWorldMatrix(t,a.worldMatrix),this.setNormalMatrix(t,a.normalMatrix),this.setViewInfo(t,l,a.isVr,a.displayIdx),this.setProjection(t,l,a.isVr,a.displayIdx);const n=a.entity.tryToGetSkeletal();this.setSkinning(t,a.setUniform,n),this.setLightsInfo(t,a.lightComponents,e,a.setUniform),t._gl.uniform3fv(t.cameraUp,l.upInner._v),this.__OutlineWidthModeIsScreen&&t._gl.uniform1f(t.aspect,l.aspect)}else e.setParameter("cameraUp",l.upInner),this.__OutlineWidthModeIsScreen&&e.setParameter("aspect",l.aspect);const c=r.f.getWebGLResourceRepository();if(a.diffuseCube&&a.diffuseCube.isTextureReady?c.setUniform1iForTexture(t,f.lk.DiffuseEnvTexture.str,[5,a.diffuseCube,P.__diffuseIblCubeMapSampler]):c.setUniform1iForTexture(t,f.lk.DiffuseEnvTexture.str,[5,E.cC]),a.specularCube&&a.specularCube.isTextureReady?c.setUniform1iForTexture(t,f.lk.SpecularEnvTexture.str,[6,a.specularCube,P.__specularIblCubeMapSampler]):c.setUniform1iForTexture(t,f.lk.SpecularEnvTexture.str,[6,E.cC]),a.setUniform){if(n){const{mipmapLevelNumber:e,meshRenderComponent:o,diffuseHdriType:i,specularHdriType:r}=P.__setupHdriParameters(a);c.setUniformValue(t,f.lk.IBLParameter.str,n,{x:e,y:o.diffuseCubeMapContribution,z:o.specularCubeMapContribution,w:o.rotationOfCubeMap}),c.setUniformValue(t,f.lk.HDRIFormat.str,n,{x:i,y:r})}}else{const{mipmapLevelNumber:t,meshRenderComponent:n,diffuseHdriType:i,specularHdriType:r}=P.__setupHdriParameters(a),s=o.F.__tmp_vector4;s.x=t,s.y=n.diffuseCubeMapContribution,s.z=n.specularCubeMapContribution,s.w=n.rotationOfCubeMap,e.setParameter("iblParameter",s);const l=o.F.__tmp_vector2;l.x=i,l.y=r,e.setParameter("hdriFormat",l)}const _=a.entity.tryToGetBlendShape();this.setMorphInfo(t,a.entity.getMesh(),a.primitive,_)}static unityBlendEnumCorrespondence(e){let t=b.fFt;switch(e){case 0:t=b.fFt;break;case 1:t=b.RCl;break;case 2:t=b.qBr;break;case 3:t=b.JR_;break;case 4:t=b.Esg;break;case 5:t=b.ovX;break;case 6:t=b.Nb9;break;case 7:t=b.zdb;break;case 8:t=b.LvL;break;case 9:t=b.UZ0;break;case 10:t=b.kF4}return t}static __setupHdriParameters(e){let t=1;e.specularCube&&(t=e.specularCube.mipmapLevelNumber);const n=e.entity.getMeshRenderer();let o=T.P8.LDR_SRGB.index,a=T.P8.LDR_SRGB.index;return n.diffuseCubeMap&&(o=n.diffuseCubeMap.hdriFormat.index),n.specularCubeMap&&(a=n.specularCubeMap.hdriFormat.index),{mipmapLevelNumber:t,meshRenderComponent:n,diffuseHdriType:o,specularHdriType:a}}}P.__diffuseIblCubeMapSampler=new I.L({minFilter:T.gu.Linear,magFilter:T.gu.Linear,wrapS:T.gu.ClampToEdge,wrapT:T.gu.ClampToEdge,wrapR:T.gu.ClampToEdge}),P.__specularIblCubeMapSampler=new I.L({minFilter:T.gu.LinearMipmapLinear,magFilter:T.gu.Linear,wrapS:T.gu.ClampToEdge,wrapT:T.gu.ClampToEdge,wrapR:T.gu.ClampToEdge}),P._Cutoff=new f.jc({str:"cutoff"}),P._Color=new f.jc({str:"litColor"}),P._ShadeColor=new f.jc({str:"shadeColor"}),P._litColorTexture=new f.jc({str:"litColorTexture"}),P._shadeColorTexture=new f.jc({str:"shadeColorTexture"}),P._BumpScale=new f.jc({str:"normalScale"}),P._normalTexture=new f.jc({str:"normalTexture"}),P._ReceiveShadowRate=new f.jc({str:"receiveShadowRate"}),P._receiveShadowTexture=new f.jc({str:"receiveShadowTexture"}),P._ShadingGradeRate=new f.jc({str:"shadingGradeRate"}),P._shadingGradeTexture=new f.jc({str:"shadingGradeTexture"}),P._ShadeShift=new f.jc({str:"shadeShift"}),P._ShadeToony=new f.jc({str:"shadeToony"}),P._LightColorAttenuation=new f.jc({str:"lightColorAttenuation"}),P._AmbientColor=new f.jc({str:"ambientColor"}),P._IndirectLightIntensity=new f.jc({str:"indirectLightIntensity"}),P._rimTexture=new f.jc({str:"rimTexture"}),P._RimColor=new f.jc({str:"rimColor"}),P._RimLightingMix=new f.jc({str:"rimLightingMix"}),P._RimFresnelPower=new f.jc({str:"rimFresnelPower"}),P._RimLift=new f.jc({str:"rimLift"}),P._matCapTexture=new f.jc({str:"matCapTexture"}),P._EmissionColor=new f.jc({str:"emissionColor"}),P._emissionTexture=new f.jc({str:"emissionTexture"}),P._OutlineWidthTexture=new f.jc({str:"outlineWidthTexture"}),P._OutlineWidth=new f.jc({str:"outlineWidth"}),P._OutlineScaledMaxDistance=new f.jc({str:"outlineScaledMaxDistance"}),P._OutlineColor=new f.jc({str:"outlineColor"}),P._OutlineLightingMix=new f.jc({str:"outlineLightingMix"}),P.Aspect=new f.jc({str:"aspect"}),P.CameraUp=new f.jc({str:"cameraUp"})},6131:(e,t,n)=>{n.d(t,{t:()=>A});var o=n(1255);const a={code:'\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_baryCentricCoord;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\nout vec2 v_texcoord_2;\nout vec3 v_baryCentricCoord;\nout vec3 v_normal_inView;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout float v_instanceInfo;\n\n#ifdef RN_USE_TANGENT\nin vec4 a_tangent;\nout vec3 v_tangent_inWorld;\nout vec3 v_binormal_inWorld; // bitangent_inWorld\n#endif\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nuniform int u_outlineWidthMode; // initialValue=0\nuniform float u_outlineWidthFactor; // initialValue=0.0008\nuniform sampler2D u_outlineWidthMultiplyTexture; // initialValue=(0,white)\n\nvoid main(){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));\n\n#ifdef RN_MTOON_IS_OUTLINE\n  int outlineWidthType = get_outlineWidthMode(materialSID, 0);\n  if (outlineWidthType == 0) { // 0 ("none")\n    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n  } else {\n    float worldNormalLength = length(normalMatrix * a_normal);\n    float outlineWidthFactor = get_outlineWidthFactor(materialSID, 0);\n    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * v_normal_inWorld;\n\n    float outlineWidthMultiply = texture(u_outlineWidthMultiplyTexture, a_texcoord_0).g;\n    outlineOffset *= outlineWidthMultiply;\n\n    if (outlineWidthType == 2) { // "screenCoordinates"\n      vec4 vViewPosition = viewMatrix * v_position_inWorld;\n      outlineOffset *= abs(vViewPosition.z) / projectionMatrix[1].y;\n    }\n    gl_Position = projectionMatrix * viewMatrix * vec4(v_position_inWorld.xyz + outlineOffset, 1.0);\n    gl_Position.z += 0.000001 * gl_Position.w;\n  }\n#else\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n#endif\n\n#ifdef RN_USE_TANGENT\n  v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n  v_binormal_inWorld = cross(v_normal_inWorld, v_tangent_inWorld) * a_tangent.w;\n#endif\n\n  v_texcoord_0 = a_texcoord_0;\n  v_texcoord_1 = a_texcoord_1;\n  v_texcoord_2 = a_texcoord_2;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n  v_instanceInfo = a_instanceInfo.x;\n}\n',shaderStage:"vertex",isFragmentShader:!1},i={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\nin vec2 v_texcoord_1;\nin vec2 v_texcoord_2;\nin vec3 v_baryCentricCoord;\nin vec3 v_normal_inView;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin float v_instanceInfo;\n#ifdef RN_USE_TANGENT\n  in vec3 v_tangent_inWorld;\n  in vec3 v_binormal_inWorld; // bitangent_inWorld\n#endif\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nfloat angular_n_h(float NH) {\n  return acos(NH);\n}\n\nfloat d_phong(float NH, float c1) {\n  return pow(\n    cos(acos(NH))\n    , c1\n  );\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 envBRDFApprox( float Roughness, float NoV ) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n// GGX NDF\nfloat d_GGX(float NH, float alphaRoughness) {\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\nfloat d_torrance_reiz(float NH, float c3) {\n  float CosSquared = NH*NH;\n  float TanSquared = (1.0 - CosSquared)/CosSquared;\n  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX\n  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry\n}\n\nfloat d_beckmann(float NH, float m) {\n  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);\n  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));\n  return co * expx;\n}\n\n// the same as glTF WebGL sample\n// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188\n// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),\n// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)\n// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\nfloat g_shielding(float NL, float NV, float alphaRoughness) {\n  float r = alphaRoughness;\n\n  // Local Shadowing using \"Schlick-Smith\" Masking Function\n  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\n\n  // Local Masking using \"Schlick-Smith\" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localShadowing * localMasking;\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfloat v_GGXCorrelated(float NL, float NV, float alphaRoughness) {\n  float a2 = alphaRoughness * alphaRoughness;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfloat v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {\n  float a = alphaRoughness;\n  float GGXV = NL * (NV * (1.0 - a) + a);\n  float GGXL = NV * (NL * (1.0 - a) + a);\n  return 0.5 / (GGXV + GGXL);\n}\n\n// The Schlick Approximation to Fresnel\nfloat fresnel(float f0, float f90, float VdotH) {\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nvec3 fresnel(vec3 f0, vec3 f90, float VdotH) {\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nvec3 fresnel(vec3 f0, float f90, float VdotH)\n{\n  float x = clamp(1.0 - VdotH, 0.0, 1.0);\n  float x2 = x * x;\n  float x5 = x * x2 * x2;\n  return f0 + (f90 - f0) * x5;\n}\n\nfloat fresnel(float f0, float VdotH)\n{\n  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\nvec3 fresnel(vec3 f0, float VdotH)\n{\n  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nvec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness, float specularWeight) {\n  float D = d_GGX(NH, alphaRoughness);\n  float V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3(D) * vec3(V) * F * specularWeight;\n//      float G = g_shielding(NL, NV, alphaRoughness);\n//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);\n\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nvec3 BRDF_lambertian(vec3 albedo, vec3 F, float specularWeight)\n{\n  // (1/pi) * diffuseAlbedo\n  return (vec3(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf\nfloat specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {\n  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  float D = d_GGX(NdotH, alphaRoughness);\n  return V * D;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfloat specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {\n  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  float D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel\nvec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {\n  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel\nvec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {\n  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);\n  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);\n  return mix(base, layer, fr);\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf\nvec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n  return conductor_fresnel(\n    baseColor,\n    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),\n    alphaRoughness,\n    VdotH\n  );\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf\n// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {\n//   vec3 base = BRDF_lambertian(baseColor);\n//   float alphaRoughness = perceptualRoughness * perceptualRoughness;\n//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));\n//   return fresnel_mix(ior, base, layer, VdotH);\n// }\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nvec3 coated_material_s(vec3 base, float perceptualRoughness, float clearcoatRoughness, float clearcoat, float VdotNc, float LdotNc, float NdotHc) {\n  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  float clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n  float D = d_GGX(NdotHc, clearcoatAlpha);\n  float V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  float f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(f_clearcoat * clearcoat);\n}\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\nfloat srgbToLinear(float value) {\n  return pow(value, 2.2);\n}\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nfloat linearToSrgb(float value) {\n  return pow(value, 1.0/2.2);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nvec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)\n{\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nvec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfloat Schlick_to_F0(float f, float f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nvec3 Schlick_to_F0(vec3 f, float VdotH) {\n    return Schlick_to_F0(f, vec3(1.0), VdotH);\n}\n\nfloat Schlick_to_F0(float f, float VdotH) {\n    return Schlick_to_F0(f, 1.0, VdotH);\n}\n\nvec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {\n  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;\n  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;\n  vec3 r = normalize(vec3(t.xy + u.xy, t.z));\n  return r;\n}\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\nfloat IsotropicNDFFiltering(vec3 normal, float roughness2) {\n  float SIGMA2 = 0.15915494;\n  float KAPPA = 0.18;\n  vec3 dndu = dFdx(normal);\n  vec3 dndv = dFdy(normal);\n  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nvec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;\n    vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfloat D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)\n{\n    float a2 = at * ab;\n    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\n    float w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfloat V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,\n    float at, float ab)\n{\n    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    float v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 BRDF_specularAnisotropicGGX(vec3 F, float alphaRoughness,\n    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,\n    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)\n{\n    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    float ab = alphaRoughness;\n\n    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfloat d_Charlie(float sheenPerceptualRoughness, float NoH) {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  float invAlpha  = 1.0 / alphaG;\n  float cos2h = NoH * NoH;\n  float sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfloat sheenSimpleVisibility(float NdotL, float NdotV) {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfloat charlieL(float x, float alphaG) {\n  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfloat lambdaSheen(float cosTheta, float alphaG)\n{\n  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));\n}\n\nfloat sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {\n  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  float sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nvec3 sheen_brdf(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {\n  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst mat3 XYZ_TO_REC709 = mat3(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nvec3 fresnelSchlickRoughnessWithIridescence(\n  vec3 F0, float cosTheta, float roughness,\n  vec3 iridescenceFresnel, float iridescence\n  )\n{\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nvec3 Fresnel0ToIor(vec3 F0) {\n    vec3 sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nvec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\n    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfloat IorToFresnel0(float transmittedIor, float incidentIor) {\n    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nvec3 evalSensitivity(float OPD, vec3 shift) {\n    float phase = 2.0 * M_PI * OPD * 1.0e-9;\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    vec3 rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nvec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));\n  float cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3(1.0);\n  }\n\n  float cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  float R0 = IorToFresnel0(iridescenceIor, outsideIor);\n  float R12 = fresnel(R0, cosTheta1);\n  float R21 = R12;\n  float T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);\n  vec3 R23 = fresnel(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  float phi12 = 0.0;\n  if (iridescenceIor < outsideIor) phi12 = M_PI;\n  float phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  vec3 phi23 = vec3(0.0);\n  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;\n  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;\n  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;\n\n  // OPD (optical path difference)\n  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  vec3 phi = vec3(phi21) + phi23;\n\n  // Compound terms\n  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\n  vec3 r123 = sqrt(R123);\n  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  vec3 C0 = R12 + Rs;\n  vec3 I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  vec3 Cm = Rs - T121;\n  for (int m = 1; m <= 2; ++m)\n  {\n      Cm *= r123;\n      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\n      I += Cm * Sm;\n  }\n\n  vec3 F_iridescence = max(I, vec3(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)\n{\n    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);\n    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nvec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)\n{\n    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    float D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nvec3 lightingWithPunctualLight(\n  Light light,\n  vec3 normal_inWorld,\n  vec3 viewDirection,\n  float NdotV,\n  vec3 albedo,\n  float perceptualRoughness,\n  float metallic,\n  vec3 F0,\n  vec3 F90,\n  float ior,\n  float transmission,\n  float clearcoat,\n  float clearcoatRoughness,\n  vec3 clearcoatNormal_inWorld,\n  float VdotNc,\n  vec3 attenuationColor,\n  float attenuationDistance,\n  float anisotropy,\n  vec3 anisotropicT,\n  vec3 anisotropicB,\n  float BdotV,\n  float TdotV,\n  vec3 sheenColor,\n  float sheenRoughness,\n  float albedoSheenScalingNdotV,\n  float iridescenceFactor,\n  vec3 iridescenceFresnel,\n  float specularWeight\n  )\n{\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  vec3 halfVector = normalize(light.direction + viewDirection);\n  float VdotH = dot(viewDirection, halfVector);\n  vec3 F = fresnel(F0, F90, VdotH);\n\n  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  vec3 diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  vec3 diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n\n  vec3 pureDiffuse = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  vec3 refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  Light transmittedLightFromUnderSurface = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  vec3 transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  vec3 Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  float NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  float NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  vec3 transmittedContrib = (vec3(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  vec3 diffuseContrib = mix(pureDiffuse, vec3(transmittedContrib), transmission);\n#else\n  vec3 diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  float NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n#ifdef RN_USE_IRIDESCENCE\n  vec3 specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  float TdotL = dot(anisotropicT, light.direction);\n  float BdotL = dot(anisotropicB, light.direction);\n  float TdotH = dot(anisotropicT, halfVector);\n  float BdotH = dot(anisotropicB, halfVector);\n  vec3 specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;\n#else\n  vec3 specularContrib = cook_torrance_specular_brdf(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3(NdotL) * light.attenuatedIntensity;\n#endif // RN_USE_ANISOTROPY\n\n  // Base Layer\n  vec3 baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  vec3 sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  float albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);\n  vec3 color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  vec3 color = baseLayer;\n  float albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  float NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  float LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  vec3 coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  vec3 finalColor = coated;\n#else\n  vec3 finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\n\n/* shaderity: @{matricesGetters} */\n\nvec3 get_irradiance(vec3 normal_forEnv, float materialSID, ivec2 hdriFormat) {\n  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);\n\n  vec3 irradiance;\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    irradiance = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    irradiance = diffuseTexel.rgb;\n  }\n\n  return irradiance;\n}\n\nfloat scaleForLod(float perceptualRoughness, float ior)\n{\n  // Scale roughness to the range [0, 1],\n  // ior=1.0 will be scale 0,\n  // ior=1.5 will be scale 1.0,\n  // ior=2 will be scale 1.0 (clamped)\n  //\n\n  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n  return perceptualRoughness * scale;\n}\n\n#ifdef RN_USE_TRANSMISSION\nvec3 get_sample_from_backbuffer(float materialSID, vec2 sampleCoord, float perceptualRoughness, float ior) {\n  ivec2 vrState = get_vrState(0.0, 0);\n  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));\n  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);\n\n#ifdef WEBGL2_MULTI_VIEW\n  // For VR\n  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n  sampleCoord.x = sampleCoord.x * 0.5;\n  if (v_displayIdx == 1.0) { // For right eye\n    sampleCoord.x += 0.5;\n  }\n#else\n  if (vrState.x == 1) { // For VR\n    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n    sampleCoord.x = sampleCoord.x * 0.5;\n    if (vrState.y == 1) { // For right eye\n      sampleCoord.x += 0.5;\n    }\n  }\n#endif\n\n  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);\n\n  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n    vec3 transmittedLight = texture2DLodEXT(u_backBufferTexture, sampleCoord, framebufferLod).rgb;\n  #elif defined(GLSL_ES3)\n    vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;\n  #else\n    vec3 transmittedLight = texture(u_backBufferTexture, sampleCoord).rgb;\n  #endif\n\n  return transmittedLight;\n}\n#endif\n\nvec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {\n  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n    vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, reflection, lod);\n  #elif defined(GLSL_ES3)\n    vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);\n  #else\n    vec4 specularTexel = texture(u_specularEnvTexture, reflection);\n  #endif\n\n// #pragma shaderity: require(./../common/fetchCubeTexture.glsl)\n\n  vec3 radiance;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    radiance = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    radiance = specularTexel.rgb;\n  }\n\n  return radiance;\n}\n\n// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer\nvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)\n{\n  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);\n\n  vec3 modelScale;\n  modelScale.x = length(vec3(worldMatrix[0].xyz));\n  modelScale.y = length(vec3(worldMatrix[1].xyz));\n  modelScale.z = length(vec3(worldMatrix[2].xyz));\n\n  return normalize(refractionVector) * thickness * modelScale;\n}\n\nstruct IblResult\n{\n  vec3 specular;\n  vec3 diffuse;\n  vec3 FssEss;\n};\n\n#ifdef RN_USE_IRIDESCENCE\nIblResult getIBLRadianceGGXWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceFresnel, float iridescence, float specularWeight)\n{\n  // get radiance\n  float mipCount = iblParameter.x;\n  float lod = (perceptualRoughness * (mipCount - 1.0));\n  vec3 radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  vec3 specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  float IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nIblResult getIBLRadianceLambertianWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceF0, float iridescence, float specularWeight)\n{\n  // get irradiance\n  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);\n\n  // Use the maximum component of the iridescence Fresnel color\n  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n  vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n  // Blend between base F0 and iridescence F0\n  vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescence);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  vec3 diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  float IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n#endif // RN_USE_IRIDESCENCE\n\nIblResult getIBLRadianceLambertian(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, float specularWeight)\n{\n  // get irradiance\n  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  vec3 diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  float IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n\nIblResult getIBLRadianceGGX(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,\n  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,\n  vec3 normal_forEnv, vec3 reflection, float specularWeight)\n{\n  // get radiance\n  float mipCount = iblParameter.x;\n  float lod = (perceptualRoughness * (mipCount - 1.0));\n  vec3 radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  vec3 FssEss = kS * f_ab.x + f_ab.y;\n  IblResult result;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  vec3 specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  float IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\n#ifdef RN_USE_SHEEN\nvec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)\n{\n  float mipCount = iblParameter.x;\n  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));\n\n  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);\n  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;\n  vec3 sheenLight = get_radiance(reflection, lod, hdriFormat);\n  float IBLSpecularContribution = iblParameter.z;\n  sheenLight *= IBLSpecularContribution;\n\n  return sheenLight * sheenColor * brdf;\n}\n#endif\n\nvec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {\n  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;\n  if (get_inverseEnvironment(materialSID, 0)) {\n    normal_forEnv.x *= -1.0;\n  }\n  return normal_forEnv;\n}\n\nvec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {\n#ifdef RN_USE_ANISOTROPY\n\n  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);\n  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);\n  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);\n  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;\n  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);\n#else\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n#endif\n  if (get_inverseEnvironment(materialSID, 0)) {\n    reflection.x *= -1.0;\n  }\n  return reflection;\n}\n\nvec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,\n  vec3 albedo, vec3 F0, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,\n  float clearcoat, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,\n  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,\n  vec3 iridescenceFresnel, vec3 iridescenceF0, float iridescence, float anisotropy, vec3 anisotropyDirection,\n  float specularWeight)\n{\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float rot = iblParameter.w;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);\n\n  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);\n\n  // IBL\n  #ifdef RN_USE_IRIDESCENCE\n    IblResult baseRadianceResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);\n    IblResult baseLambertianResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);\n  #else\n    IblResult baseRadianceResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n    IblResult baseLambertianResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,\n      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n  #endif\n\n#ifdef RN_USE_TRANSMISSION\n  vec3 refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior);\n  vec3 refractedRayFromVPosition = v_position_inWorld + refractedRay;\n  vec4 ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayFromVPosition, 1.0);\n  vec2 refractionCoords = ndcPoint.xy / ndcPoint.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  vec3 transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);\n\n#ifdef RN_USE_VOLUME\n  vec3 attenuationColor = get_attenuationColor(materialSID, 0);\n  float attenuationDistance = get_attenuationDistance(materialSID, 0);\n  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));\n#endif\n\n  vec3 transmissionComp = (vec3(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;\n  vec3 diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);\n  vec3 base = diffuse + baseRadianceResult.specular;\n#else\n  vec3 base = baseLambertianResult.diffuse + baseRadianceResult.specular;\n#endif\n\n#ifdef RN_USE_SHEEN\n  vec3 sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);\n  vec3 color = sheen + base * albedoSheenScalingNdotV;\n#else\n  vec3 color = base;\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  float VdotNg = dot(geomNormal_inWorld, viewDirection);\n  vec3 clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  IblResult coatResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3(0.0), F0,\n    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);\n  vec3 coatLayer = coatResult.specular;\n\n  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  vec3 coated = color * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(coatLayer * clearcoat);\n  return coated;\n#else\n  return color;\n#endif\n\n}\n\n\nuniform vec4 u_baseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_baseColorTexture; // initialValue=(1,white)\nuniform int u_baseColorTexcoordIndex; // initialValue=0\nuniform vec4 u_baseColorTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_baseColorTextureRotation; // initialValue=0\n\nuniform sampler2D u_normalTexture; // initialValue=(2,black)\nuniform vec4 u_normalTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_normalTextureRotation; // initialValue=(0)\nuniform int u_normalTexcoordIndex; // initialValue=(0)\nuniform float u_normalScale; // initialValue=(1)\n\nuniform float u_shadingShiftFactor; // initialValue=0.0\nuniform sampler2D u_shadingShiftTexture; // initialValue=(3,black)\nuniform int u_shadingShiftTexcoordIndex; // initialValue=0\nuniform float u_shadingShiftTextureScale; // initialValue=1.0\n\nuniform float u_shadingToonyFactor; // initialValue=0.9\nuniform vec3 u_shadeColorFactor; // initialValue=(0,0,0)\nuniform sampler2D u_shadeMultiplyTexture; // initialValue=(4,white)\nuniform int u_shadeMultiplyTexcoordIndex; // initialValue=0\n\nuniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true\nuniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true\n\nuniform float u_giEqualizationFactor; // initialValue=0.9\n\nuniform sampler2D u_matcapTexture; // initialValue=(8,black)\nuniform vec3 u_matcapFactor; // initialValue=(1,1,1)\nuniform vec3 u_parametricRimColorFactor; // initialValue=(0,0,0)\nuniform float u_parametricRimFresnelPowerFactor; // initialValue=5.0\nuniform float u_parametricRimLiftFactor; // initialValue=0.0\nuniform sampler2D u_rimMultiplyTexture; // initialValue=(9,white)\nuniform int u_rimMultiplyTexcoordIndex; // initialValue=0\nuniform float u_rimLightingMixFactor; // initialValue=1.0\n\nuniform vec3 u_emissiveFactor; // initialValue=(0,0,0)\nuniform sampler2D u_emissiveTexture; // initialValue=(10,white)\nuniform int u_emissiveTexcoordIndex; // initialValue=0\n\nuniform vec3 u_outlineColorFactor; // initialValue=(0,0,0)\nuniform float u_outlineLightingMixFactor; // initialValue=1.0\n\nuniform sampler2D u_uvAnimationMaskTexture; // initialValue=(11,white)\nuniform int u_uvAnimationMaskTexcoordIndex; // initialValue=0\nuniform float u_uvAnimationScrollXSpeedFactor; // initialValue=0.0\nuniform float u_uvAnimationScrollYSpeedFactor; // initialValue=0.0\nuniform float u_uvAnimationRotationSpeedFactor; // initialValue=0.0\n\nuniform bool u_inverseEnvironment; // initialValue=false\nuniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true\nuniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true\nuniform float u_alphaCutoff; // initialValue=0.5\nuniform bool u_makeOutputSrgb; // initialValue=false\n\nfloat linearstep(float a, float b, float t) {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\nvec2 getTexcoord(int texcoordIndex) {\n  vec2 texcoord;\n  if(texcoordIndex == 2){\n    texcoord = v_texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = v_texcoord_1;\n  }else{\n    texcoord = v_texcoord_0;\n  }\n  return texcoord;\n}\n\nvec2 uvAnimation(vec2 origUv, float time, float uvAnimMask, float uvAnimationScrollXSpeedFactor, float uvAnimationScrollYSpeedFactor, float uvAnimationRotationSpeedFactor) {\n  float scrollX = uvAnimationScrollXSpeedFactor * time;\n  float scrollY = uvAnimationScrollYSpeedFactor * time;\n  float rotation = uvAnimationRotationSpeedFactor * time;\n  float rotationCos = cos(rotation * uvAnimMask);\n  float rotationSin = sin(rotation * uvAnimMask);\n  vec2 uv = mat2(rotationCos, -rotationSin, rotationSin, rotationCos) * (origUv - vec2(0.5)) + vec2(0.5);\n  uv += vec2(scrollX, scrollY) * uvAnimMask;\n  return uv;\n}\n\n#ifdef RN_USE_TANGENT\n  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {\n    vec3 tangent_inWorld = normalize(v_tangent_inWorld);\n    vec3 binormal_inWorld = normalize(v_binormal_inWorld);\n    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {\n      uv = gl_FrontFacing ? uv : -uv;\n\n      // get edge vectors of the pixel triangle\n      vec3 dp1 = dFdx(position);\n      vec3 dp2 = dFdy(position);\n      vec2 duv1 = dFdx(uv);\n      vec2 duv2 = dFdy(uv);\n\n      // solve the linear system\n      vec3 dp2perp = cross(dp2, normal_inWorld);\n      vec3 dp1perp = cross(normal_inWorld, dp1);\n      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {\n      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\n\nvoid main() {\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  rt0 = vec4(0.0, 0.0, 0.0, 1.0);\n\n  // uv animation\n  float uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);\n  float uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);\n  float uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);\n  int uvAnimationMaskTexcoordIndex = get_uvAnimationMaskTexcoordIndex(materialSID, 0);\n  vec2 uvAnimationMaskTexcoord = getTexcoord(uvAnimationMaskTexcoordIndex);\n  float uvAnimMask = texture(u_uvAnimationMaskTexture, uvAnimationMaskTexcoord).b;\n  float time = get_time(0.0, 0);\n\n  // base color\n  vec4 baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);\n  float baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);\n  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);\n  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);\n  baseColorTexcoord = uvAnimation(baseColorTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  vec2 baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);\n  vec4 baseColorTexture = texture(u_baseColorTexture, baseColorTexUv);\n  baseColorTexture.rgb = srgbToLinear(baseColorTexture.rgb);\n  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);\n  vec3 baseColorTerm = baseColorTexture.rgb * baseColorFactor.rgb;\n\n  // shade color\n  vec3 shadeColorFactor = get_shadeColorFactor(materialSID, 0);\n  int shadeMultiplyTexcoordIndex = get_shadeMultiplyTexcoordIndex(materialSID, 0);\n  vec2 shadeMultiplyTexcoord = getTexcoord(shadeMultiplyTexcoordIndex);\n  shadeMultiplyTexcoord = uvAnimation(shadeMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  vec4 shadeMultiplyTexture = texture(u_shadeMultiplyTexture, shadeMultiplyTexcoord);\n  shadeMultiplyTexture.rgb = srgbToLinear(shadeMultiplyTexture.rgb);\n  vec3 shadeColorTerm = shadeColorFactor * shadeMultiplyTexture.rgb;\n\n  // shading shift\n  int shadingShiftTexcoordIndex = get_shadingShiftTexcoordIndex(materialSID, 0);\n  vec2 shadingShiftTexcoord = getTexcoord(shadingShiftTexcoordIndex);\n  shadingShiftTexcoord = uvAnimation(shadingShiftTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  float shadingShiftTexture = texture(u_shadingShiftTexture, shadingShiftTexcoord).r;\n  float shadingShiftTextureScale = get_shadingShiftTextureScale(materialSID, 0);\n\n  // emissive\n  vec3 emissiveFactor = get_emissiveFactor(materialSID, 0);\n  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);\n  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);\n  emissiveTexcoord = uvAnimation(emissiveTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  vec4 emissiveTexture = texture(u_emissiveTexture, emissiveTexcoord);\n  emissiveTexture.rgb = srgbToLinear(emissiveTexture.rgb);\n  vec3 emissive = emissiveFactor * emissiveTexture.rgb;\n\n  // alpha\n  float alpha = baseColorTexture.a * baseColorFactor.a;\n#ifdef RN_ALPHATEST_ON\n  float cutoff = get_alphaCutoff(materialSID, 0);\n  if(alpha < cutoff) discard;\n#endif\n\n  // view vector\n  vec3 viewPosition = get_viewPosition(cameraSID, 0);\n  vec3 viewVector = viewPosition - v_position_inWorld.xyz;\n  vec3 viewDirection = normalize(viewVector);\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n#ifdef RN_USE_NORMAL_TEXTURE\n  vec4 normalTextureTransform = get_normalTextureTransform(materialSID, 0);\n  float normalTextureRotation = get_normalTextureRotation(materialSID, 0);\n  int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);\n  vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);\n  normalTexcoord = uvAnimation(normalTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  vec2 normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);\n  vec3 normal = texture(u_normalTexture, normalTexUv).xyz * 2.0 - 1.0;\n  mat3 TBN = getTBN(normal_inWorld, viewDirection, normalTexUv);\n  normal_inWorld = normalize(TBN * normal);\n#endif\n\n#ifdef RN_MTOON_IS_OUTLINE\n  normal_inWorld *= -1.0;\n#endif\n\n  // direct lighting\n  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation\n  vec3 directLighting = vec3(0.0);\n  for (int i = 0; i < lightNumber; i++) {\n    Light light = getLight(i, v_position_inWorld.xyz);\n    float shading = dot(light.direction, normal_inWorld);\n    float shadingShiftFactor = get_shadingShiftFactor(materialSID, 0);\n    shading += shadingShiftFactor + shadingShiftTexture * shadingShiftTextureScale;\n    float shadingToonyFactor = get_shadingToonyFactor(materialSID, 0);\n    shading = linearstep(-1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading);\n\n    vec3 color = mix(shadeColorTerm, baseColorTerm, shading);\n    color = color * light.attenuatedIntensity * RECIPROCAL_PI;\n    directLighting += light.attenuatedIntensity;\n    rt0.xyz += color;\n  }\n\n  // indirect lighting\n  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-1\n  float giEqualizationFactor = get_giEqualizationFactor(materialSID, 0);\n  vec3 worldUpVector = vec3(0.0, 1.0, 0.0);\n  vec3 worldDownVector = vec3(0.0, -1.0, 0.0);\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float rot = iblParameter.w;\n  float IBLDiffuseContribution = iblParameter.y;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);\n  vec3 rawGiUp = get_irradiance(worldUpVector, materialSID, hdriFormat) * IBLDiffuseContribution;\n  vec3 rawGiDown = get_irradiance(worldDownVector, materialSID, hdriFormat) * IBLDiffuseContribution;\n  vec3 rawGiNormal = get_irradiance(normal_forEnv, materialSID, hdriFormat) * IBLDiffuseContribution;\n  vec3 uniformedGi = (rawGiUp + rawGiDown) / 2.0;\n  vec3 passthroughGi = rawGiNormal;\n  vec3 gi = mix(uniformedGi, passthroughGi, giEqualizationFactor);\n  rt0.xyz += gi * baseColorTerm * RECIPROCAL_PI;\n\n  // rim lighting\n  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-2\n  vec3 rim = vec3(0.0);\n  vec3 worldViewX = normalize(vec3(viewDirection.z, 0.0, -viewDirection.x));\n  vec3 worldViewY = cross(viewDirection, worldViewX);\n  vec2 matcapUv = vec2( dot(worldViewX, normal_inWorld), dot(worldViewY, normal_inWorld)) * 0.495 + 0.5;\n  float epsilon = 0.00001;\n  vec3 matcapFactor = srgbToLinear(get_matcapFactor(materialSID, 0));\n  rim = matcapFactor * texture(u_matcapTexture, matcapUv).rgb;\n  float parametricRimLiftFactor = get_parametricRimLiftFactor(materialSID, 0);\n  float parametricRim = clamp( 1.0 - dot(normal_inWorld, viewVector) + parametricRimLiftFactor, 0.0, 1.0);\n  float parametricRimFresnelPowerFactor = get_parametricRimFresnelPowerFactor(materialSID, 0);\n  parametricRim = pow(parametricRim, max(parametricRimFresnelPowerFactor, epsilon));\n  vec3 parametricRimColorFactor = get_parametricRimColorFactor(materialSID, 0);\n  rim += parametricRim * parametricRimColorFactor;\n  int rimMultiplyTexcoordIndex = get_rimMultiplyTexcoordIndex(materialSID, 0);\n  vec2 rimMultiplyTexcoord = getTexcoord(rimMultiplyTexcoordIndex);\n  rimMultiplyTexcoord = uvAnimation(rimMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  rim *= srgbToLinear(texture(u_rimMultiplyTexture, rimMultiplyTexcoord).rgb);\n  float rimLightingMixFactor = get_rimLightingMixFactor(materialSID, 0);\n  rim *= mix(vec3(1.0), directLighting + gi, rimLightingMixFactor);\n  rt0.xyz += rim;\n\n  // emissive\n  rt0.xyz += emissive;\n\n#ifdef RN_MTOON_IS_OUTLINE\n  vec3 outlineColorFactor = get_outlineColorFactor(materialSID, 0);\n  float outlineLightingMixFactor = get_outlineLightingMixFactor(materialSID, 0);\n  rt0.xyz = outlineColorFactor * mix(vec3(1.0), rt0.xyz, outlineLightingMixFactor);\n#endif\n\nfloat makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));\nrt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);\n\n\n  // alpha\n  rt0.w = alpha;\n  rt0.xyz *= alpha; // premultiplied alpha\n  // rt0.xyz = vec3(alpha, 0.0, 0.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0},r={code:'/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n// This shader is based on https://github.com/Santarh/MToon\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n// #param outlineWidthMode: i32; // initialValue=0\n// #param outlineWidthFactor: f32; // initialValue=0.0008\n@group(1) @binding(0) var outlineWidthTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var outlineWidthSampler: sampler;\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n  var output : VertexOutput;\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    #endif\n  #endif\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let instanceId = u32(instance_ids.x);\n  let worldMatrix = get_worldMatrix(instanceId);\n  let normalMatrix = get_normalMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let skeletalComponentSID = i32(instance_ids.y);\n  let blendShapeComponentSID = u32(instance_ids.z);\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  output.position_inWorld = geom.position_inWorld.xyz;\n  output.normal_inWorld = geom.normal_inWorld;\n  output.normal_inView = (viewMatrix * vec4(geom.normal_inWorld, 0.0)).xyz;\n\n#ifdef RN_MTOON_IS_OUTLINE\n  let outlineWidthType = get_outlineWidthMode(materialSID, 0);\n  if (outlineWidthType == 0) { // 0 ("none")\n    output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  } else {\n    let worldNormalLength = length(normalMatrix * normal);\n    let outlineWidthFactor = get_outlineWidthFactor(materialSID, 0);\n    var outlineOffset = outlineWidthFactor * worldNormalLength * geom.normal_inWorld;\n\n    let textureSize = textureDimensions(outlineWidthTexture, 0);\n    let outlineWidthMultiply = textureLoad(outlineWidthTexture, vec2u(vec2f(textureSize) * texcoord_0), 0).r;\n    outlineOffset *= outlineWidthMultiply;\n\n    if (outlineWidthType == 2) { // "screenCoordinates"\n      let vViewPosition = viewMatrix * geom.position_inWorld;\n      outlineOffset *= abs(vViewPosition.z) / projectionMatrix[1].y;\n    }\n    output.position = projectionMatrix * viewMatrix * vec4(geom.position_inWorld.xyz + outlineOffset, 1.0);\n    output.position.z += 0.000001 * output.position.w;\n  }\n#else\n  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n#endif\n\n#ifdef RN_USE_TANGENT\n  output.tangent_inWorld = normalMatrix * tangent.xyz;\n  output.binormal_inWorld = cross(geom.normal_inWorld, output.tangent_inWorld) * tangent.w;\n#endif\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  output.texcoord_1 = texcoord_1;\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  output.texcoord_2 = texcoord_2;\n#endif\n\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  output.baryCentricCoord = baryCentricCoord.xyz;\n#endif\n\n  output.instanceInfo = instance_ids.x;\n\n  return output;\n}\n',shaderStage:"vertex",isFragmentShader:!1},s={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\nconst EPS_COL: f32 = 0.00001;\n\nstruct Light {\n  lightType: i32, // 0 = directional, 1 = point, 2 = spot\n  position: vec3<f32>,\n  intensity: vec3<f32>,\n  attenuatedIntensity: vec3<f32>,\n  directionOfLightObject: vec3<f32>,\n  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)\n  pointToLight: vec3<f32>, // not normalized\n  spotAngleScale: f32,\n  spotAngleOffset: f32,\n  effectiveRange: f32,\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfn getRangeAttenuation(light: Light) -> f32\n{\n  let distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfn getSpotAttenuation(light: Light) -> f32\n{\n\n  let cd = dot(light.directionOfLightObject, light.direction);\n  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nfn getLightAttenuated(light: Light) -> Light {\n  var newLight: Light = light;\n  newLight.attenuatedIntensity = light.intensity;\n  // if (light.lightType == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.lightType == 1)\n  {\n    newLight.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.lightType == 2)\n  {\n    newLight.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n\n  return newLight;\n}\n\nfn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {\n  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);\n  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);\n  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);\n  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);\n  var light: Light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  let lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3f(0.0);\n    light.lightType = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.lightType = 1;\n  } else { // is Directional Light\n    light.lightType = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.lightType = 2;\n  }\n\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  let newLight = getLightAttenuated(light);\n\n  return newLight;\n}\n\n#ifdef RN_USE_TANGENT\n  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n    let tangent_inWorld = normalize(input.tangent_inWorld);\n    let binormal_inWorld = normalize(input.binormal_inWorld);\n    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);\n\n    return tbnMat_tangent_to_world;\n  }\n#else\n    // This is based on http://www.thetenthplanet.de/archives/1180\n    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {\n      var uv: vec2f;\n      if (isFront) {\n        uv = uv_;\n      } else {\n        uv = -uv_;\n      }\n\n      // get edge vectors of the pixel triangle\n      let dp1 = dpdx(position);\n      let dp2 = dpdy(position);\n      let duv1 = dpdx(uv);\n      let duv2 = dpdy(uv);\n\n      // solve the linear system\n      let dp2perp = cross(dp2, normal_inWorld);\n      let dp1perp = cross(normal_inWorld, dp1);\n      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n      bitangent *= -1.0;\n\n      // construct a scale-invariant frame\n      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);\n    }\n\n    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {\n      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);\n\n      return tbnMat_tangent_to_world;\n    }\n#endif\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\n// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66\nfn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {\n    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);\n}\n\nfn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {\n    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);\n}\n\n\n// The Schlick Approximation to Fresnel\nfn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn fresnel2(f0: vec3f, VdotH: f32) -> vec3f\n{\n  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnel(f0, f90, VdotH);\n}\n\nfn fresnel2F32(f0: f32, VdotH: f32) -> f32\n{\n  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n  return fresnelF32(f0, f90, VdotH);\n}\n\n// Roughness Dependent Fresnel\n// https://www.jcgt.org/published/0008/01/03/paper.pdf\nfn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);\n  return k_S;\n}\n\n// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf\nfn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f\n{\n  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;\n}\n\n\n// GGX NDF\nfn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {\n  let roughnessSqr = alphaRoughness * alphaRoughness;\n  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\nfn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {\n  let a2 = alphaRoughness * alphaRoughness;\n  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nfn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {\n  let D = d_GGX(NH, alphaRoughness);\n  let V = v_GGXCorrelated(NL, NV, alphaRoughness);\n  return vec3f(D) * vec3f(V) * F * specularWeight;\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nfn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {\n  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );\n  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );\n  let r = Roughness * c0 + c1;\n  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\nfn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n  let D = d_GGX(NdotHc, clearcoatAlpha);\n  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);\n  let f_clearcoat = clearcoatFresnel * D * V;\n\n  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering\n  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes\nfn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {\n  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n  let D = d_GGX(NdotHt, alphaRoughness);\n  return V * D;\n}\n\n\n////////////////////////////////////////\n// glTF KHR_materials_volume\n////////////////////////////////////////\n\n#ifdef RN_USE_VOLUME\n// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\nfn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f\n{\n  if (attenuationDistance == 0.0) { // means Infinite distance\n    return intensity; // No attenuation\n  } else {\n    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;\n    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);\n    return intensity * attenuatedTransmittance;\n  }\n}\n#endif\n\n\n////////////////////////////////////////\n// glTF KHR_materials_anisotropy\n////////////////////////////////////////\n#ifdef RN_USE_ANISOTROPY\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\nfn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32\n{\n    let a2 = at * ab;\n    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);\n    let w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / M_PI;\n}\n\nfn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,\n    at: f32, ab: f32) -> f32\n{\n    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    let v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\nfn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,\n    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,\n    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f\n{\n    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    let ab = alphaRoughness;\n\n    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);\n    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);\n\n    return F * V * D;\n}\n#endif\n\n////////////////////////////////////////\n// glTF KHR_materials_sheen\n////////////////////////////////////////\n\n#ifdef RN_USE_SHEEN\nfn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let invAlpha  = 1.0 / alphaG;\n  let cos2h = NoH * NoH;\n  let sin2h = 1.0 - cos2h;\n  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {\n  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\n}\n\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility\nfn charlieL(x: f32, alphaG: f32) -> f32 {\n  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n  return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32\n{\n  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);\n}\n\nfn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {\n  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;\n  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n  return sheenVisibility;\n}\n\nfn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {\n  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);\n  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);\n  return sheenColor * sheenDistribution * sheenVisibility;\n}\n#endif // RN_USE_SHEEN\n\n////////////////////////////////////////\n// glTF KHR_materials_irirdescence\n////////////////////////////////////////\n\n#ifdef RN_USE_IRIDESCENCE\n// XYZ to REC709(sRGB) conversion matrix\nconst XYZ_TO_REC709 = mat3x3<f32>(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\nfn fresnelSchlickRoughnessWithIridescence(\n  F0: vec3f, cosTheta: f32, roughness: f32,\n  iridescenceFresnel: vec3f, iridescence: f32\n  ) -> vec3f\n{\n  let Fr = max(vec3f(1.0 - roughness), F0) - F0;\n  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);\n  return k_S;\n}\n\n// Assume air interface for top\nfn Fresnel0ToIor(F0: vec3f) -> vec3f {\n    let sqrtF0 = sqrt(F0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion from IOR to F0\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {\n    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\nfn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {\n    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration\n */\nfn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {\n    let phase = 2.0 * M_PI * OPD * 1.0e-9;\n    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));\n    xyz /= 1.0685e-7;\n\n    let rgb = XYZ_TO_REC709 * xyz;\n    return rgb;\n}\n\n/**\n * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel\n */\nfn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {\n\n\n  // iridescenceIor is the index of refraction of the thin-film layer\n  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n\n  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)\n  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.\n  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.\n  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):\n  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));\n  let cosTheta2Sq = 1.0 - sinTheta2Sq;\n\n  // Handle total internal reflection\n  if (cosTheta2Sq < 0.0) {\n      return vec3f(1.0);\n  }\n\n  let cosTheta2 = sqrt(cosTheta2Sq);\n\n  /// Material Interfaces\n  // The iridescence model defined by Belcour/Barla models two material interfaces\n  // - one from the outside to the thin-film layer\n  // and another one from the thin-film to the base material. These two interfaces are defined as follows:\n\n  // First interface (from the outside to the thin-film layer)\n  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);\n  let R12 = fresnel2F32(R0, cosTheta1);\n  let R21 = R12;\n  let T121 = 1.0 - R12;\n\n  // Second interface (from the thin-film to the base material)\n  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0\n  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);\n  let R23 = fresnel2(R1, cosTheta2);\n\n  // phi12 and phi23 define the base phases per interface and are approximated with 0.0\n  // if the IOR of the hit material (iridescenceIor or baseIor) is higher\n  // than the IOR of the previous material (outsideIor or iridescenceIor) and π otherwise.\n  // Also here, polarization is ignored.  float phi12 = 0.0;\n\n  // First interface (from the outside to the thin-film layer)\n  var phi12 = 0.0;\n  if (iridescenceIor < outsideIor) { phi12 = M_PI; }\n  let phi21 = M_PI - phi12;\n\n  // Second interface (from the thin-film to the base material)\n  var phi23 = vec3f(0.0);\n  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }\n  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }\n  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }\n\n  // OPD (optical path difference)\n  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n  // Phase shift\n  let phi = vec3f(phi21) + phi23;\n\n  // Compound terms\n  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));\n  let r123 = sqrt(R123);\n  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  let C0 = R12 + Rs;\n  var I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  var Cm = Rs - T121;\n  for (var m = 1; m <= 2; m++)\n  {\n      Cm *= r123;\n      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);\n      I += Cm * Sm;\n  }\n\n  let F_iridescence = max(I, vec3f(0.0));\n\n  return F_iridescence;\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nfn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f\n{\n    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n\n    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);\n\n    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n\nfn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f\n{\n    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);\n    let D = d_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#endif // RN_USE_IRIDESCENCE\n\n\n////////////////////////////////////////\n// lighting with a punctual light\n////////////////////////////////////////\nfn lightingWithPunctualLight(\n  light: Light,\n  normal_inWorld: vec3f,\n  viewDirection: vec3f,\n  NdotV: f32,\n  albedo: vec3f,\n  perceptualRoughness: f32,\n  F0: vec3f,\n  F90: vec3f,\n  transmission: f32,\n  ior: f32,\n  clearcoat: f32,\n  clearcoatRoughness: f32,\n  clearcoatNormal_inWorld: vec3f,\n  VdotNc: f32,\n  attenuationColor: vec3f,\n  attenuationDistance: f32,\n  anisotropy: f32,\n  anisotropicT: vec3f,\n  anisotropicB: vec3f,\n  BdotV: f32,\n  TdotV: f32,\n  sheenColor: vec3f,\n  sheenRoughness: f32,\n  albedoSheenScalingNdotV: f32,\n  iridescenceFactor: f32,\n  iridescenceFresnel: vec3f,\n  specularWeight: f32,\n  ) -> vec3f\n{\n  let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // Fresnel\n  let halfVector = normalize(light.direction + viewDirection);\n  let VdotH = dot(viewDirection, halfVector);\n  let F = fresnel(F0, F90, VdotH);\n\n  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);\n\n  // Diffuse\n#ifdef RN_USE_IRIDESCENCE\n  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);\n#else\n  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);\n#endif\n  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;\n\n#ifdef RN_USE_TRANSMISSION\n  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);\n  var transmittedLightFromUnderSurface: Light = light;\n  transmittedLightFromUnderSurface.pointToLight -= refractionVector;\n  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);\n  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;\n\n  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);\n  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));\n  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));\n\n  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;\n\n#ifdef RN_USE_VOLUME\n  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));\n#endif // RN_USE_VOLUME\n\n  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);\n#else\n  let diffuseContrib = pureDiffuse;\n#endif // RN_USE_TRANSMISSION\n\n  // Specular\n  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));\n\n\n#ifdef RN_USE_IRIDESCENCE\n  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;\n#elif defined(RN_USE_ANISOTROPY)\n  let TdotL = dot(anisotropicT, light.direction);\n  let BdotL = dot(anisotropicB, light.direction);\n  let TdotH = dot(anisotropicT, halfVector);\n  let BdotH = dot(anisotropicB, halfVector);\n  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;\n#else\n  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;\n#endif\n\n  // Base Layer\n  let baseLayer = diffuseContrib + specularContrib;\n\n#ifdef RN_USE_SHEEN\n  // Sheen\n  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;\n  let albedoSheenScaling = min(\n    albedoSheenScalingNdotV,\n    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);\n  let color = sheenContrib + baseLayer * albedoSheenScaling;\n#else\n  let color = baseLayer;\n  let albedoSheenScaling = 1.0;\n#endif // RN_USE_SHEEN\n\n#ifdef RN_USE_CLEARCOAT\n  // Clear Coat Layer\n  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));\n  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));\n  let coated = coated_material_s(color, perceptualRoughness,\n    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);\n  let finalColor = coated;\n#else\n  let finalColor = color;\n#endif // RN_USE_CLEARCOAT\n\n  return finalColor;\n}\n\nfn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {\n  let SIGMA2 = 0.15915494;\n  let KAPPA = 0.18;\n  let dndu  = dpdx(normal);\n  let dndv = dpdy(normal);\n  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));\n  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);\n  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);\n  return filteredRoughness2;\n}\n\n\n// #param baseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n@group(1) @binding(1) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(1) var baseColorSampler: sampler;\n// #param baseColorTexcoordIndex: f32; // initialValue=0\n// #param baseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param baseColorTextureRotation: f32; // initialValue=0\n\n@group(1) @binding(2) var normalTexture: texture_2d<f32>; // initialValue=black\n@group(2) @binding(2) var normalSampler: sampler;\n// #param normalTexcoordIndex: f32; // initialValue=0\n// #param normalTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)\n// #param normalTextureRotation: f32; // initialValue=0\n// #param normalScale: f32; // initialValue=1\n\n// #param shadingShiftFactor: f32; // initialValue=0.0\n@group(1) @binding(3) var shadingShiftTexture: texture_2d<f32>; // initialValue=black\n@group(2) @binding(3) var shadingShiftSampler: sampler;\n// #param shadingShiftTexcoordIndex: f32; // initialValue=0\n// #param shadingShiftTextureScale: f32; // initialValue=1.0\n\n// #param shadingToonyFactor: f32; // initialValue=0.9\n// #param shadeColorFactor: vec3<f32>; // initialValue=(0,0,0)\n@group(1) @binding(4) var shadeMultiplyTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(4) var shadeMultiplySampler: sampler;\n// #param shadeMultiplyTexcoordIndex: f32; // initialValue=0\n\n@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(16) var diffuseEnvSampler: sampler;\n@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(17) var specularEnvSampler: sampler;\n\n// #param giEqualizationFactor: f32; // initialValue=0.9\n\n@group(1) @binding(5) var matcapTexture: texture_2d<f32>; // initialValue=black\n@group(2) @binding(5) var matcapSampler: sampler;\n// #param matcapFactor: vec3<f32>; // initialValue=(1,1,1)\n// #param parametricRimColorFactor: vec3<f32>; // initialValue=(0,0,0)\n// #param parametricRimFresnelPowerFactor: f32; // initialValue=5.0\n// #param parametricRimLiftFactor: f32; // initialValue=0.0\n@group(1) @binding(6) var rimMultiplyTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(6) var rimMultiplySampler: sampler;\n// #param rimMultiplyTexcoordIndex: f32; // initialValue=0\n// #param rimLightingMixFactor: f32; // initialValue=1.0\n\n// #param emissiveFactor: vec3<f32>; // initialValue=(0,0,0)\n@group(1) @binding(7) var emissiveTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(7) var emissiveSampler: sampler;\n// #param emissiveTexcoordIndex: f32; // initialValue=0\n\n// #param outlineColorFactor: vec3<f32>; // initialValue=(0,0,0)\n// #param outlineLightingMixFactor: f32; // initialValue=1.0\n\n@group(1) @binding(8) var uvAnimationMaskTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(8) var uvAnimationMaskSampler: sampler;\n// #param uvAnimationMaskTexcoordIndex: f32; // initialValue=0\n// #param uvAnimationScrollXSpeedFactor: f32; // initialValue=0.0\n// #param uvAnimationScrollYSpeedFactor: f32; // initialValue=0.0\n// #param uvAnimationRotationSpeedFactor: f32; // initialValue=0.0\n\n// #param inverseEnvironment: bool; // initialValue=false\n// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true\n// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true\n// #param alphaCutoff: f32; // initialValue=0.5\n// #param makeOutputSrgb: bool; // initialValue=false\n\nfn get_irradiance(normal_forEnv: vec3f, hdriFormat: vec2<i32>) -> vec3f {\n  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);\n\n  var irradiance: vec3f;\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    irradiance = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    irradiance = diffuseTexel.rgb;\n  }\n\n  return irradiance;\n}\n\nfn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {\n  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);\n\n  var radiance: vec3f;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    radiance = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    radiance = specularTexel.rgb;\n  }\n\n  return radiance;\n}\n\n#ifdef RN_USE_SHEEN\nfn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f\n{\n  let mipCount = iblParameter.x;\n  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));\n\n  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);\n  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;\n  var sheenLight = get_radiance(reflection, lod, hdriFormat);\n  let IBLSpecularContribution = iblParameter.z;\n  sheenLight *= IBLSpecularContribution;\n\n  return sheenLight * sheenColor * brdf;\n}\n#endif\n\nfn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {\n  var normal_forEnv = rotEnvMatrix * normal_inWorld;\n  if (get_inverseEnvironment(materialSID, 0)) {\n    normal_forEnv.x *= -1.0;\n  }\n  return normal_forEnv;\n}\n\nfn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,\n  materialSID: u32, perceptualRoughness: f32,\n  anisotropy: f32, anisotropyDirection: vec3f\n  ) -> vec3f {\n#ifdef RN_USE_ANISOTROPY\n  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);\n  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);\n  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);\n  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;\n  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));\n  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);\n#else\n  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n#endif\n  if (get_inverseEnvironment(materialSID, 0)) {\n    reflection.x *= -1.0;\n  }\n  return reflection;\n}\n\nfn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32\n{\n  // Scale roughness to the range [0, 1],\n  // ior=1.0 will be scale 0,\n  // ior=1.5 will be scale 1.0,\n  // ior=2 will be scale 1.0 (clamped)\n  //\n\n  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n  return perceptualRoughness * scale;\n}\n\n#ifdef RN_USE_TRANSMISSION\nfn get_sample_from_backbuffer(materialSID: u32, sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {\n  let vrState: vec2<i32> = get_vrState(0, 0);\n  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));\n  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);\n  var newSampleCoord = sampleCoord;\n  newSampleCoord.y = 1.0 - newSampleCoord.y;\n  if (vrState.x == 1) { // For VR\n    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);\n    newSampleCoord.x = sampleCoord.x * 0.5;\n    if (vrState.y == 1) { // For right eye\n      newSampleCoord.x += 0.5;\n    }\n  }\n  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);\n\n  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;\n\n  return transmittedLight;\n}\n\n// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer\nfn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f\n{\n  let refractionVector = refract(-v, normalize(n), 1.0 / ior);\n  let worldMatrix = get_worldMatrix(instanceInfo);\n\n  var modelScale: vec3f;\n  modelScale.x = length(vec3f(worldMatrix[0].xyz));\n  modelScale.y = length(vec3f(worldMatrix[1].xyz));\n  modelScale.z = length(vec3f(worldMatrix[2].xyz));\n\n  return normalize(refractionVector) * thickness * modelScale;\n}\n#endif // RN_USE_TRANSMISSION\n\nstruct IblResult\n{\n  specular: vec3f,\n  diffuse: vec3f,\n  FssEss: vec3f,\n};\n\n\n#ifdef RN_USE_IRIDESCENCE\nfn getIBLRadianceGGXWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, iridescenceFresnel: vec3f, iridescence: f32, specularWeight: f32) -> IblResult\n{\n  // get radiance\n  let mipCount = iblParameter.x;\n  let lod = (perceptualRoughness * (mipCount - 1.0));\n  let radiance = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);\n  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss = kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  var specular = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  let IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nfn getIBLRadianceLambertianWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, iridescenceF0: vec3f, iridescence: f32, specularWeight: f32) -> IblResult\n{\n  // get irradiance\n  let irradiance = get_irradiance(normal_forEnv, hdriFormat);\n\n  // Use the maximum component of the iridescence Fresnel color\n  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n  let iridescenceF0Max = vec3f(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n  // Blend between base F0 and iridescence F0\n  let mixedF0 = mix(F0, iridescenceF0Max, iridescence);\n\n  // Roughness dependent fresnel\n  let kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);\n  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss = specularWeight * kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  let Ems = (1.0 - (f_ab.x + f_ab.y));\n  let F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n  let FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  let k_D = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  var diffuse = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  let IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n#endif // RN_USE_IRIDESCENCE\n\nfn getIBLRadianceLambertian(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult\n{\n  // get irradiance\n  let irradiance: vec3f = get_irradiance(normal_forEnv, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss: vec3f = specularWeight * kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Multiple scattering, Fdez-Aguera's approach\n  let Ems = (1.0 - (f_ab.x + f_ab.y));\n  let F_avg: vec3f = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  let k_D: vec3f = albedo * (1.0 - FssEss - FmsEms);\n\n  // Diffuse IBL\n  var diffuse: vec3f = (FmsEms + k_D) * irradiance;\n\n  // scale with user parameters\n  let IBLDiffuseContribution = iblParameter.y;\n  diffuse *= IBLDiffuseContribution;\n\n  result.diffuse = diffuse;\n\n  return result;\n}\n\nfn getIBLRadianceGGX(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,\n  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,\n  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult\n{\n  // get radiance\n  let mipCount = iblParameter.x;\n  let lod = (perceptualRoughness * (mipCount - 1.0));\n  let radiance: vec3f = get_radiance(reflection, lod, hdriFormat);\n\n  // Roughness dependent fresnel\n  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);\n  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);\n  let FssEss: vec3f = kS * f_ab.x + f_ab.y;\n  var result: IblResult;\n  result.FssEss = FssEss;\n\n  // Specular IBL\n  var specular: vec3f = FssEss * radiance * specularWeight;\n\n  // scale with user parameters\n  let IBLSpecularContribution = iblParameter.z;\n  specular *= IBLSpecularContribution;\n\n  result.specular = specular;\n\n  return result;\n}\n\nfn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,\n  albedo: vec3f, F0: vec3f, perceptualRoughness: f32,\n  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, VdotNc: f32, geomNormal_inWorld: vec3f,\n  transmission: f32, v_position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,\n  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,\n  iridescenceFresnel: vec3f, iridescenceF0: vec3f, iridescence: f32,\n  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32\n  ) -> vec3f\n{\n  let iblParameter: vec4f = get_iblParameter(materialSID, 0);\n  let rot = iblParameter.w;\n  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);\n\n  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);\n\n  // IBL\n#ifdef RN_USE_IRIDESCENCE\n  let baseRadianceResult: IblResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);\n  let baseLambertianResult: IblResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);\n#else\n  let baseRadianceResult: IblResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n  let baseLambertianResult: IblResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,\n    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);\n#endif\n\n#ifdef RN_USE_TRANSMISSION\n  let refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior, instanceInfo);\n  let refractedRayFromVPosition = v_position_inWorld + refractedRay;\n  let ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayFromVPosition, 1.0);\n  var refractionCoords = ndcPoint.xy / ndcPoint.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  var transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);\n\n#ifdef RN_USE_VOLUME\n  let attenuationColor = get_attenuationColor(materialSID, 0);\n  let attenuationDistance = get_attenuationDistance(materialSID, 0);\n  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));\n#endif\n\n  let transmissionComp = (vec3f(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;\n  let diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);\n  let base = diffuse + baseRadianceResult.specular;\n#else\n  let base: vec3f = baseLambertianResult.diffuse + baseRadianceResult.specular;\n#endif\n\n#ifdef RN_USE_SHEEN\n  let sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);\n  let color = sheen + base * albedoSheenScalingNdotV;\n#else\n  let color = base;\n#endif\n\n#ifdef RN_USE_CLEARCOAT\n  let VdotNg = dot(geomNormal_inWorld, viewDirection);\n  let clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let coatResult: IblResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3f(0.0), F0,\n    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);\n  let coatLayer = coatResult.specular;\n\n  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);\n  let coated = color * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(coatLayer * clearcoat);\n  return coated;\n#else\n  return color;\n#endif\n}\n\n\n\nfn linearstep(a: f32, b: f32, t: f32) -> f32 {\n  return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\nfn uvAnimation(origUv: vec2f, time: f32, uvAnimMask: f32, uvAnimationScrollXSpeedFactor: f32, uvAnimationScrollYSpeedFactor: f32, uvAnimationRotationSpeedFactor: f32) -> vec2f {\n  let scrollX = uvAnimationScrollXSpeedFactor * time;\n  let scrollY = uvAnimationScrollYSpeedFactor * time;\n  let rotation = uvAnimationRotationSpeedFactor * time;\n  let rotationCos = cos(rotation * uvAnimMask);\n  let rotationSin = sin(rotation * uvAnimMask);\n  var uv = mat2x2f(rotationCos, -rotationSin, rotationSin, rotationCos) * (origUv - vec2f(0.5)) + vec2f(0.5);\n  uv += vec2f(scrollX, scrollY) * uvAnimMask;\n  return uv;\n}\n\n@fragment\nfn main (\n  input: VertexOutput,\n  @builtin(front_facing) isFront: bool\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  // uv animation\n  let uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);\n  let uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);\n  let uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);\n  let uvAnimationMaskTexcoordIndex = u32(get_uvAnimationMaskTexcoordIndex(materialSID, 0));\n  let uvAnimationMaskTexcoord = getTexcoord(uvAnimationMaskTexcoordIndex, input);\n  let uvAnimMask = textureSample(uvAnimationMaskTexture, uvAnimationMaskSampler, uvAnimationMaskTexcoord).b;\n  let time = get_time(0, 0);\n\n  // base color\n  let baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);\n  let baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);\n  let baseColorTexcoordIndex = u32(get_baseColorTexcoordIndex(materialSID, 0));\n  var baseColorTexcoord = getTexcoord(baseColorTexcoordIndex, input);\n  baseColorTexcoord = uvAnimation(baseColorTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  let baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);\n  var baseColorTexture = textureSample(baseColorTexture, baseColorSampler, baseColorTexUv);\n  baseColorTexture = vec4(srgbToLinear(baseColorTexture.rgb), baseColorTexture.a);\n  let baseColorFactor = get_baseColorFactor(materialSID, 0);\n  let baseColorTerm = baseColorTexture.rgb * baseColorFactor.rgb;\n\n  // shade color\n  let shadeColorFactor = get_shadeColorFactor(materialSID, 0);\n  let shadeMultiplyTexcoordIndex = u32(get_shadeMultiplyTexcoordIndex(materialSID, 0));\n  var shadeMultiplyTexcoord = getTexcoord(shadeMultiplyTexcoordIndex, input);\n  shadeMultiplyTexcoord = uvAnimation(shadeMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  var shadeMultiplyTexture = textureSample(shadeMultiplyTexture, shadeMultiplySampler, shadeMultiplyTexcoord);\n  shadeMultiplyTexture = vec4(srgbToLinear(shadeMultiplyTexture.rgb), shadeMultiplyTexture.a);\n  let shadeColorTerm = shadeColorFactor * shadeMultiplyTexture.rgb;\n\n  // shading shift\n  let shadingShiftTexcoordIndex = u32(get_shadingShiftTexcoordIndex(materialSID, 0));\n  var shadingShiftTexcoord = getTexcoord(shadingShiftTexcoordIndex, input);\n  shadingShiftTexcoord = uvAnimation(shadingShiftTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  var shadingShiftTexture = textureSample(shadingShiftTexture, shadingShiftSampler, shadingShiftTexcoord).r;\n  let shadingShiftTextureScale = get_shadingShiftTextureScale(materialSID, 0);\n\n  // emissive\n  let emissiveFactor = get_emissiveFactor(materialSID, 0);\n  let emissiveTexcoordIndex = u32(get_emissiveTexcoordIndex(materialSID, 0));\n  var emissiveTexcoord = getTexcoord(emissiveTexcoordIndex, input);\n  emissiveTexcoord = uvAnimation(emissiveTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  var emissiveTexture = textureSample(emissiveTexture, emissiveSampler, emissiveTexcoord);\n  emissiveTexture = vec4(srgbToLinear(emissiveTexture.rgb), emissiveTexture.a);\n  let emissive = emissiveFactor * emissiveTexture.rgb;\n\n  // alpha\n  let alpha = baseColorTexture.a * baseColorFactor.a;\n#ifdef RN_ALPHATEST_ON\n  let cutoff = get_alphaCutoff(materialSID, 0);\n  if(alpha < cutoff) { discard; }\n#endif\n\n  // view vector\n  let viewPosition = get_viewPosition(cameraSID, 0);\n  let viewVector = viewPosition - input.position_inWorld.xyz;\n  let viewDirection = normalize(viewVector);\n\n  // Normal\n  var normal_inWorld = normalize(input.normal_inWorld);\n#ifdef RN_USE_NORMAL_TEXTURE\n  let normalTextureTransform = get_normalTextureTransform(materialSID, 0);\n  let normalTextureRotation = get_normalTextureRotation(materialSID, 0);\n  let normalTexcoordIndex = u32(get_normalTexcoordIndex(materialSID, 0));\n  var normalTexcoord = getTexcoord(normalTexcoordIndex, input);\n  normalTexcoord = uvAnimation(normalTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  let normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);\n  let normal: vec3f = textureSample(normalTexture, normalSampler, normalTexUv).xyz * 2.0 - 1.0;\n  let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewDirection, normalTexUv, isFront);\n  normal_inWorld = normalize(TBN * normal);\n#endif\n\n#ifdef RN_MTOON_IS_OUTLINE\n  normal_inWorld *= -1.0;\n#endif\n\n  // direct lighting\n  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation\n  var rt0 = vec4f(0.0, 0.0, 0.0, 1.0);\n  var directLighting = vec3f(0.0);\n  let lightNumber = u32(get_lightNumber(0u, 0u));\n  for (var i = 0u; i < lightNumber; i++) {\n    let light: Light = getLight(i, input.position_inWorld.xyz);\n    var shading = dot(light.direction, normal_inWorld);\n    let shadingShiftFactor = get_shadingShiftFactor(materialSID, 0);\n    shading += shadingShiftFactor + shadingShiftTexture * shadingShiftTextureScale;\n    let shadingToonyFactor = get_shadingToonyFactor(materialSID, 0);\n    shading = linearstep(-1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading);\n\n    var color = mix(shadeColorTerm, baseColorTerm, shading);\n    color = color * light.attenuatedIntensity * RECIPROCAL_PI;\n    directLighting += light.attenuatedIntensity;\n    rt0 += vec4f(color, rt0.a);\n  }\n\n  // indirect lighting\n  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-1\n  let giEqualizationFactor = get_giEqualizationFactor(materialSID, 0);\n  let worldUpVector = vec3f(0.0, 1.0, 0.0);\n  let worldDownVector = vec3f(0.0, -1.0, 0.0);\n  let iblParameter = get_iblParameter(materialSID, 0);\n  let rot = iblParameter.w;\n  let IBLDiffuseContribution = iblParameter.y;\n  let rotEnvMatrix = mat3x3f(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  let normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);\n  let hdriFormat = get_hdriFormat(materialSID, 0);\n  let rawGiUp = get_irradiance(worldUpVector, hdriFormat) * IBLDiffuseContribution;\n  let rawGiDown = get_irradiance(worldDownVector, hdriFormat) * IBLDiffuseContribution;\n  let rawGiNormal = get_irradiance(normal_forEnv, hdriFormat) * IBLDiffuseContribution;\n  let uniformedGi = (rawGiUp + rawGiDown) / 2.0;\n  let passthroughGi = rawGiNormal;\n  let gi = mix(uniformedGi, passthroughGi, giEqualizationFactor);\n  rt0 += vec4f(gi * baseColorTerm * RECIPROCAL_PI, rt0.a);\n\n  // rim lighting\n  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-2\n  var rim = vec3f(0.0);\n  let worldViewX = normalize(vec3f(viewDirection.z, 0.0, -viewDirection.x));\n  let worldViewY = cross(viewDirection, worldViewX);\n  let matcapUv = vec2f( dot(worldViewX, normal_inWorld), dot(worldViewY, normal_inWorld)) * 0.495 + 0.5;\n  let epsilon = 0.00001;\n  let matcapFactor = srgbToLinear(get_matcapFactor(materialSID, 0));\n  rim = matcapFactor * textureSample(matcapTexture, matcapSampler, matcapUv).rgb;\n  let parametricRimLiftFactor = get_parametricRimLiftFactor(materialSID, 0);\n  var parametricRim = clamp( 1.0 - dot(normal_inWorld, viewVector) + parametricRimLiftFactor, 0.0, 1.0);\n  let parametricRimFresnelPowerFactor = get_parametricRimFresnelPowerFactor(materialSID, 0);\n  parametricRim = pow(parametricRim, max(parametricRimFresnelPowerFactor, epsilon));\n  let parametricRimColorFactor = get_parametricRimColorFactor(materialSID, 0);\n  rim += parametricRim * parametricRimColorFactor;\n  let rimMultiplyTexcoordIndex = u32(get_rimMultiplyTexcoordIndex(materialSID, 0));\n  var rimMultiplyTexcoord = getTexcoord(rimMultiplyTexcoordIndex, input);\n  rimMultiplyTexcoord = uvAnimation(rimMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);\n  rim *= srgbToLinear(textureSample(rimMultiplyTexture, rimMultiplySampler, rimMultiplyTexcoord).rgb);\n  let rimLightingMixFactor = get_rimLightingMixFactor(materialSID, 0);\n  rim *= mix(vec3(1.0), directLighting + gi, rimLightingMixFactor);\n  rt0 += vec4f(rim, rt0.a);\n\n  // emissive\n  rt0 += vec4f(emissive, rt0.a);\n\n#ifdef RN_MTOON_IS_OUTLINE\n  let outlineColorFactor = get_outlineColorFactor(materialSID, 0);\n  let outlineLightingMixFactor = get_outlineLightingMixFactor(materialSID, 0);\n  rt0 = vec4f(outlineColorFactor * mix(vec3f(1.0), rt0.xyz, outlineLightingMixFactor), rt0.a);\n#endif\n\n  let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);\n  rt0 = vec4f(select(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb), rt0.a);\n\n  rt0.a = alpha;\n  rt0 *= vec4f(alpha, alpha, alpha, 1.0);\n\n  return rt0;\n}\n",shaderStage:"fragment",isFragmentShader:!0};var l=n(6737),c=n(7295),_=n(4114),u=n(7751),f=n(5338),d=n(4132),h=n(1124),m=n(4772),p=n(9871),v=n(9993),x=n(1383),g=n(589),y=n(9747),b=n(8924),I=n(5882);class A extends o.F{constructor(e,t,n,o,l){super(e,{isMorphing:t,isSkinning:n,isLighting:o});const c=this.doShaderReflection(a,i,r,s);A.__diffuseIblCubeMapSampler.created||A.__diffuseIblCubeMapSampler.create(),A.__specularIblCubeMapSampler.created||A.__specularIblCubeMapSampler.create(),o&&(this.__definitions+="#define RN_IS_LIGHTING\n"),n&&(this.__definitions+="#define RN_IS_SKINNING\n"),t&&(this.__definitions+="#define RN_IS_MORPHING\n",c.push({semantic:"dataTextureMorphOffsetPosition",componentType:_.I.Int,compositionType:u.h.ScalarArray,arrayLength:f.T.maxVertexMorphNumberInShader,stage:d.C.VertexShader,isInternalSetting:!0,initialValue:new h.u(new Int32Array(f.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:_.I.Float,compositionType:u.h.ScalarArray,arrayLength:f.T.maxVertexMorphNumberInShader,stage:d.C.VertexShader,isInternalSetting:!0,initialValue:new h.u(new Float32Array(f.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0})),l&&(this.__definitions+="#define RN_MTOON_IS_OUTLINE\n"),this.setShaderSemanticsInfoArray(c)}setMaterialParameters(e,t,n){t?(e.cullFace=!0,e.cullFaceBack=!1):n.doubleSided?e.cullFace=!1:(e.cullFace=!0,e.cullFaceBack=!0),"MASK"===n.alphaMode&&(this.__definitions+="#define RN_ALPHATEST_ON\n")}_setInternalSettingParametersToGpuWebGpu({material:e,args:t}){const{mipmapLevelNumber:n,meshRenderComponent:a,diffuseHdriType:i,specularHdriType:r}=A.__setupHdriParameters(t),s=o.F.__tmp_vector4;s.x=n,s.y=a.diffuseCubeMapContribution,s.z=a.specularCubeMapContribution,s.w=a.rotationOfCubeMap,e.setParameter("iblParameter",s);const l=o.F.__tmp_vector2;l.x=i,l.y=r,e.setParameter("hdriFormat",l);const c=t.entity.tryToGetMeshRenderer();if(null!=c&&null!=c.diffuseCubeMap&&null!=c.specularCubeMap){const t=b.Am.zero(),n=I.A3.zero();t.x=c.specularCubeMap.mipmapLevelNumber,t.y=c.diffuseCubeMapContribution,t.z=c.specularCubeMapContribution,t.w=c.rotationOfCubeMap,e.setParameter("iblParameter",t),n.x=c.diffuseCubeMap.hdriFormat.index,n.y=c.specularCubeMap.hdriFormat.index,e.setParameter("hdriFormat",n)}}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:a}){if(a.setUniform){if(this.setWorldMatrix(t,a.worldMatrix),this.setNormalMatrix(t,a.normalMatrix),this.setIsBillboard(t,a.isBillboard),n||a.isVr){let e=a.renderPass.cameraComponent;null==e&&(e=l.O.getComponent(c.n,c.n.current)),this.setViewInfo(t,e,a.isVr,a.displayIdx),this.setProjection(t,e,a.isVr,a.displayIdx)}n&&this.setLightsInfo(t,a.lightComponents,e,a.setUniform);const o=a.entity.tryToGetSkeletal();this.setSkinning(t,a.setUniform,o)}const i=m.f.getWebGLResourceRepository();if(a.diffuseCube&&a.diffuseCube.isTextureReady?i.setUniform1iForTexture(t,p.lk.DiffuseEnvTexture.str,[5,a.diffuseCube,A.__diffuseIblCubeMapSampler]):i.setUniform1iForTexture(t,p.lk.DiffuseEnvTexture.str,[5,g.cC]),a.specularCube&&a.specularCube.isTextureReady?i.setUniform1iForTexture(t,p.lk.SpecularEnvTexture.str,[6,a.specularCube,A.__specularIblCubeMapSampler]):i.setUniform1iForTexture(t,p.lk.SpecularEnvTexture.str,[6,g.cC]),a.setUniform){if(n){const{mipmapLevelNumber:e,meshRenderComponent:o,diffuseHdriType:r,specularHdriType:s}=A.__setupHdriParameters(a);i.setUniformValue(t,p.lk.IBLParameter.str,n,{x:e,y:o.diffuseCubeMapContribution,z:o.specularCubeMapContribution,w:o.rotationOfCubeMap}),i.setUniformValue(t,p.lk.HDRIFormat.str,n,{x:r,y:s})}}else{const{mipmapLevelNumber:t,meshRenderComponent:n,diffuseHdriType:i,specularHdriType:r}=A.__setupHdriParameters(a),s=o.F.__tmp_vector4;s.x=t,s.y=n.diffuseCubeMapContribution,s.z=n.specularCubeMapContribution,s.w=n.rotationOfCubeMap,e.setParameter("iblParameter",s);const l=o.F.__tmp_vector2;l.x=i,l.y=r,e.setParameter("hdriFormat",l)}const r=a.entity.tryToGetBlendShape();this.setMorphInfo(t,a.entity.getMesh(),a.primitive,r)}static __setupHdriParameters(e){let t=1;e.specularCube&&(t=e.specularCube.mipmapLevelNumber);const n=e.entity.getMeshRenderer();let o=y.P.LDR_SRGB.index,a=y.P.LDR_SRGB.index;return n.diffuseCubeMap&&(o=n.diffuseCubeMap.hdriFormat.index),n.specularCubeMap&&(a=n.specularCubeMap.hdriFormat.index),{mipmapLevelNumber:t,meshRenderComponent:n,diffuseHdriType:o,specularHdriType:a}}}A.__diffuseIblCubeMapSampler=new v.L({minFilter:x.P.Linear,magFilter:x.P.Linear,wrapS:x.P.ClampToEdge,wrapT:x.P.ClampToEdge,wrapR:x.P.ClampToEdge}),A.__specularIblCubeMapSampler=new v.L({minFilter:x.P.LinearMipmapLinear,magFilter:x.P.Linear,wrapS:x.P.ClampToEdge,wrapT:x.P.ClampToEdge,wrapR:x.P.ClampToEdge})},9494:(e,t,n)=>{n.d(t,{R:()=>x});var o=n(2664),a=n(7295),i=n(6737),r=n(4114),s=n(7751),l=n(9011),c=n(9871),_=n(4132),u=n(1018),f=n(975),d=n(1255);const h={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec3 a_baryCentricCoord;\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec3 v_baryCentricCoord;\nout vec3 v_normal_inView;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_normal_inView = vec3(viewMatrix * vec4(normalMatrix * a_normal, 0.0));\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  v_baryCentricCoord = a_baryCentricCoord;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},m={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec3 v_baryCentricCoord;\nin vec3 v_normal_inView;\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec3 normal_inView = normalize(v_normal_inView);\n  normal_inView.y *= -1.0;\n  vec2 normalUVCordinate = normal_inView.xy * 0.5 + 0.5;\n  vec4 matCapColor = texture(u_matCapTexture, normalUVCordinate);\n  rt0 = matCapColor;\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0};var p=n(589),v=n(3497);class x extends d.F{constructor(e,t,n,a,i){let c;super(e,{isSkinning:t},h,m),"string"==typeof n?(c=new u.g,async function(e){c.generateTextureFromUri(e,{type:r.I.UnsignedByte}),await c.loadFromUrlLazy()}(n)):a instanceof o.E?c=a:(v.V.warn("no matcap texture"),c=p.rT);const d=[];d.push({semantic:"wireframe",componentType:r.I.Float,compositionType:s.h.Vec3,stage:_.C.PixelShader,initialValue:f.Pq.fromCopyArray([0,0,1]),min:0,max:10}),d.push({semantic:"pointSize",componentType:r.I.Float,compositionType:s.h.Scalar,stage:_.C.VertexShader,soloDatum:!0,initialValue:l.X5.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:r.I.Float,compositionType:s.h.Vec3,stage:_.C.VertexShader,soloDatum:!0,initialValue:f.Pq.fromCopyArray([0,.1,.01]),min:0,max:1}),d.push({semantic:"matCapTexture",componentType:r.I.Int,compositionType:s.h.Texture2D,stage:_.C.PixelShader,initialValue:[0,c,i],min:0,max:Number.MAX_SAFE_INTEGER}),this.setShaderSemanticsInfoArray(d)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){if(o.setUniform){this.setWorldMatrix(t,o.worldMatrix),this.setNormalMatrix(t,o.normalMatrix);let e=o.renderPass.cameraComponent;null==e&&(e=i.O.getComponent(a.n,a.n.current)),this.setViewInfo(t,e,o.isVr,o.displayIdx),this.setProjection(t,e,o.isVr,o.displayIdx);const n=o.entity.tryToGetSkeletal();this.setSkinning(t,o.setUniform,n)}}}x.MatCapTexture=new c.jc({str:"matCapTexture"})},3549:(e,t,n)=>{n.d(t,{X:()=>I});var o=n(9871),a=n(1255),i=n(7751),r=n(4114),s=n(3414),l=n(975),c=n(9186),_=n(4132),u=n(6737),f=n(7295),d=n(1124),h=n(9011),m=n(5338),p=n(4772),v=n(7476);const x={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec4 a_joint;\nin vec4 a_weight;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec4 v_texcoord_1;\nout vec4 v_projPosition_from_light;\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  // Shadow mapping\n  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);\n  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;\n\n  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html\n  mat4 tMatrix = mat4(\n    0.5, 0.0, 0.0, 0.0,\n    0.0, 0.5, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.5, 0.5, 0.0, 1.0\n  );\n  v_texcoord_1 = tMatrix * v_projPosition_from_light;\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},g={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec4 v_texcoord_1;\nin vec4 v_projPosition_from_light;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nfloat decodeRGBAToDepth(vec4 RGBA){\n  const float rMask = 1.0;\n  const float gMask = 1.0 / 255.0;\n  const float bMask = 1.0 / (255.0 * 255.0);\n  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n  return depth;\n}\n\nvoid main (){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  // diffuseColor\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture\n  vec4 textureColor = texture(u_diffuseColorTexture, v_texcoord_0);\n  if (textureColor.r > 0.05) {\n    diffuseColor *= textureColor.rgb;\n    alpha *= textureColor.a;\n  }\n\n  // shadow mapping\n  if(v_projPosition_from_light.w > 0.0){\n    float zNear = get_zNearInner(materialSID, 0);\n    float zFar = get_zFarInner(materialSID, 0);\n    float normalizationCoefficient = 1.0 / (zFar - zNear);\n\n    vec2 shadowMapUV = v_texcoord_1.xy / v_texcoord_1.w;\n\n    #ifdef RN_IS_DEBUGGING\n      bool inShadowMap = (shadowMapUV.x >= 0.0 && shadowMapUV.x <= 1.0) && (shadowMapUV.y >= 0.0 && shadowMapUV.y <= 1.0);\n      if(inShadowMap == false){\n        rt0 = get_debugColorFactor(materialSID, 0);\n/* shaderity: @{renderTargetEnd} */\n\n        return;\n      }\n    #endif\n\n    float measureDepth = normalizationCoefficient * length(v_projPosition_from_light);\n    float textureDepth = decodeRGBAToDepth(texture(u_depthTexture, shadowMapUV));\n    float allowableDepthError = get_allowableDepthError(materialSID, 0);\n\n    if(measureDepth > textureDepth + allowableDepthError){\n      // case of shadow\n      vec4 shadowColorFactor = get_shadowColorFactor(materialSID, 0);\n      diffuseColor = shadowColorFactor.rgb;\n      alpha = shadowColorFactor.a;\n    }\n  }\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    int lightNumber = get_lightNumber(materialSID, 0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      // Light\n      Light light = getLight(i, v_position_inWorld.xyz);\n\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      vec3 viewPosition = get_viewPosition(cameraSID, 0);\n      float shininess = get_shininess(materialSID, 0);\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n\n  rt0 = vec4(shadingColor, alpha);\n  //rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0};var y=n(589),b=n(3497);class I extends a.F{constructor(e,{isMorphing:t,isSkinning:n,isLighting:o,isDebugging:a,colorAttachmentsNumber:u},f){super(e,{isMorphing:t,isSkinning:n,isLighting:o},x,g),this.__encodedDepthRenderPass=f;const p=f.getFramebuffer();if(null==p)return void b.V.error("encodedDepthRenderPass does not have framebuffer");const I=p.colorAttachments[u],A=f.getViewport();A.setComponents(1,1,A.z-1,A.w-1),f.setViewport(A);const E=[{semantic:"lightViewProjectionMatrix",compositionType:i.h.Mat4,componentType:r.I.Float,stage:_.C.VertexShader,initialValue:v.g.zero(),min:-Number.MAX_VALUE,max:Number.MAX_VALUE},{semantic:"shadingModel",compositionType:i.h.Scalar,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(c.y.Constant.index),min:0,max:3},{semantic:"shininess",compositionType:i.h.Scalar,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(5),min:0,max:Number.MAX_VALUE},{semantic:"allowableDepthError",compositionType:i.h.Scalar,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(1e-4),min:0,max:1},{semantic:"shadowColorFactor",compositionType:i.h.Vec4,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:s.IU.fromCopyArray([.5,.5,.5,1]),min:0,max:1},{semantic:"diffuseColorFactor",compositionType:i.h.Vec4,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:s.IU.fromCopyArray([1,1,1,1]),min:0,max:2},{semantic:"isPointLight",componentType:r.I.Bool,compositionType:i.h.Scalar,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(1),min:0,max:1},{semantic:"wireframe",componentType:r.I.Float,compositionType:i.h.Vec3,stage:_.C.PixelShader,initialValue:l.Pq.fromCopyArray([0,0,1]),min:0,max:10},{semantic:"normalTexture",compositionType:i.h.Texture2D,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:[0,y.Uk],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"depthTexture",compositionType:i.h.Texture2D,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:[0,I],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"diffuseColorTexture",compositionType:i.h.Texture2D,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:[1,y.vK],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"zNearInner",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,isInternalSetting:!0,initialValue:h.X5.fromCopyNumber(.1),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"zFarInner",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,isInternalSetting:!0,initialValue:h.X5.fromCopyNumber(1e4),min:1e-4,max:Number.MAX_SAFE_INTEGER}];E.push({semantic:"pointSize",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.VertexShader,soloDatum:!0,initialValue:h.X5.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:r.I.Float,compositionType:i.h.Vec3,stage:_.C.VertexShader,soloDatum:!0,initialValue:l.Pq.fromCopyArray([0,.1,.01]),min:0,max:1}),t&&E.push({semantic:"morphTargetNumber",componentType:r.I.Int,compositionType:i.h.Scalar,stage:_.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:h.X5.fromCopyNumber(0),min:0,max:m.T.maxVertexMorphNumberInShader,needUniformInDataTextureMode:!0},{semantic:"dataTextureMorphOffsetPosition",componentType:r.I.Int,compositionType:i.h.ScalarArray,arrayLength:m.T.maxVertexMorphNumberInShader,stage:_.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new d.u(new Int32Array(m.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:r.I.Float,compositionType:i.h.ScalarArray,arrayLength:m.T.maxVertexMorphNumberInShader,stage:_.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new d.u(new Float32Array(m.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}),a&&E.push({semantic:"debugColorFactor",compositionType:i.h.Vec4,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:s.IU.fromCopyArray([1,0,0,1]),min:0,max:2}),this.setShaderSemanticsInfoArray(E)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:a}){let i=a.renderPass.cameraComponent;null==i&&(i=u.O.getComponent(f.n,f.n.current));const r=this.__encodedDepthRenderPass.cameraComponent;a.setUniform?(this.setWorldMatrix(t,a.worldMatrix),this.setNormalMatrix(t,a.normalMatrix),this.setViewInfo(t,i,a.isVr,a.displayIdx),this.setProjection(t,i,a.isVr,a.displayIdx),I.__lastZNear!==r.zNearInner&&(t._gl.uniform1f(t.zNearInner,r.zNearInner),I.__lastZNear=r.zNearInner),I.__lastZFar!==r.zFarInner&&(t._gl.uniform1f(t.zFarInner,r.zFarInner),I.__lastZFar=r.zFarInner),p.f.getWebGLResourceRepository().setUniformValue(t,o.lk.LightViewProjectionMatrix.str,!0,this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix)):(e.setParameter("zNearInner",r.zNearInner),e.setParameter("zFarInner",r.zFarInner),e.setParameter("lightViewProjectionMatrix",this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix));const s=a.entity.tryToGetSkeletal();this.setSkinning(t,a.setUniform,s),this.setLightsInfo(t,a.lightComponents,e,a.setUniform);const l=a.entity.tryToGetBlendShape();this.setMorphInfo(t,a.entity.getMesh(),a.primitive,l)}}I.ShadowColorFactor=new o.jc({str:"shadowColorFactor"}),I.ShadowAlpha=new o.jc({str:"shadowAlpha"}),I.NonShadowAlpha=new o.jc({str:"nonShadowAlpha"}),I.AllowableDepthError=new o.jc({str:"allowableDepthError"}),I.zNearInner=new o.jc({str:"zNearInner"}),I.zFarInner=new o.jc({str:"zFarInner"}),I.DebugColorFactor=new o.jc({str:"debugColorFactor"}),I.DepthTexture=new o.jc({str:"depthTexture"}),I.IsPointLight=new o.jc({str:"isPointLight"}),I.__lastZNear=0,I.__lastZFar=0},2538:(e,t,n)=>{n.d(t,{$:()=>y});var o=n(7295),a=n(6737),i=n(4114),r=n(7751),s=n(9871),l=n(4132),c=n(1255),_=n(1124);const u={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},f={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nin vec2 v_texcoord_0;\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3 + vec3(1.0 - wireframeWidthInner) * d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float synthesizeCoefficient0 = u_synthesizeCoefficient[0];\n  vec3 color = synthesizeCoefficient0 * texture(u_synthesizeTexture0, v_texcoord_0).rgb;\n\n  float synthesizeCoefficient1 = u_synthesizeCoefficient[1];\n  float synthesizeCoefficient2 = u_synthesizeCoefficient[2];\n  float synthesizeCoefficient3 = u_synthesizeCoefficient[3];\n  float synthesizeCoefficient4 = u_synthesizeCoefficient[4];\n  float synthesizeCoefficient5 = u_synthesizeCoefficient[5];\n\n  color += synthesizeCoefficient1 * texture(u_synthesizeTexture1, v_texcoord_0).rgb;\n  color += synthesizeCoefficient2 * texture(u_synthesizeTexture2, v_texcoord_0).rgb;\n  color += synthesizeCoefficient3 * texture(u_synthesizeTexture3, v_texcoord_0).rgb;\n  color += synthesizeCoefficient4 * texture(u_synthesizeTexture4, v_texcoord_0).rgb;\n  color += synthesizeCoefficient5 * texture(u_synthesizeTexture5, v_texcoord_0).rgb;\n\n  rt0 = vec4(color, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n\n",shaderStage:"fragment",isFragmentShader:!0},d={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},h={code:"/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let synthesizeCoefficient0 = get_synthesizeCoefficient(materialSID, 0);\n  var color: vec3f = synthesizeCoefficient0 * textureSample(synthesizeTexture0, synthesizeSampler0, input.texcoord_0).rgb;\n\n  let synthesizeCoefficient1 = get_synthesizeCoefficient(materialSID, 1);\n  let synthesizeCoefficient2 = get_synthesizeCoefficient(materialSID, 2);\n  let synthesizeCoefficient3 = get_synthesizeCoefficient(materialSID, 3);\n  let synthesizeCoefficient4 = get_synthesizeCoefficient(materialSID, 4);\n  let synthesizeCoefficient5 = get_synthesizeCoefficient(materialSID, 5);\n\n  color += synthesizeCoefficient1 * textureSample(synthesizeTexture1, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient2 * textureSample(synthesizeTexture2, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient3 * textureSample(synthesizeTexture3, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient4 * textureSample(synthesizeTexture4, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient5 * textureSample(synthesizeTexture5, synthesizeSampler0, input.texcoord_0).rgb;\n\n  let rt0 = vec4f(color, 1.0);\n\n  return rt0;\n}\n\n",shaderStage:"fragment",isFragmentShader:!0};var m=n(589),p=n(9993),v=n(1383),x=n(7670),g=n(3212);class y extends c.F{constructor(e,t){var n,o,a,s,c,y;super(e,{}),this.textureNumber=t.length;const b=new p.L({wrapS:v.P.ClampToEdge,wrapT:v.P.ClampToEdge,minFilter:v.P.Linear,magFilter:v.P.Linear});b.create();const I=[{semantic:"synthesizeCoefficient",componentType:i.I.Float,compositionType:r.h.ScalarArray,arrayLength:6,stage:l.C.PixelShader,initialValue:new _.u(new Float32Array(6)),min:0,max:1,needUniformInDataTextureMode:!0},{semantic:"synthesizeTexture0",componentType:i.I.Int,compositionType:r.h.Texture2D,stage:l.C.PixelShader,initialValue:[0,null!==(n=t[0])&&void 0!==n?n:m.rT,b],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture1",componentType:i.I.Int,compositionType:r.h.Texture2D,stage:l.C.PixelShader,initialValue:[1,null!==(o=t[1])&&void 0!==o?o:m.rT,b],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture2",componentType:i.I.Int,compositionType:r.h.Texture2D,stage:l.C.PixelShader,initialValue:[2,null!==(a=t[2])&&void 0!==a?a:m.rT,b],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture3",componentType:i.I.Int,compositionType:r.h.Texture2D,stage:l.C.PixelShader,initialValue:[3,null!==(s=t[3])&&void 0!==s?s:m.rT,b],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture4",componentType:i.I.Int,compositionType:r.h.Texture2D,stage:l.C.PixelShader,initialValue:[4,null!==(c=t[4])&&void 0!==c?c:m.rT,b],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture5",componentType:i.I.Int,compositionType:r.h.Texture2D,stage:l.C.PixelShader,initialValue:[5,null!==(y=t[5])&&void 0!==y?y:m.rT,b],min:0,max:Number.MAX_SAFE_INTEGER}];x.l.currentProcessApproach===g.m.WebGPU?(this.__vertexShaderityObject=d,this.__pixelShaderityObject=h):(this.__vertexShaderityObject=u,this.__pixelShaderityObject=f),this.setShaderSemanticsInfoArray(I)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:i}){if(i.setUniform){this.setWorldMatrix(t,i.worldMatrix);let e=i.renderPass.cameraComponent;null==e&&(e=a.O.getComponent(o.n,o.n.current)),e&&(this.setViewInfo(t,e,i.isVr,i.displayIdx),this.setProjection(t,e,i.isVr,i.displayIdx))}t._gl.uniform1fv(t.synthesizeCoefficient,e.getParameter("synthesizeCoefficient")._v)}get synthesizeTextureNumber(){return this.textureNumber}}y.SynthesizeCoefficient=new s.jc({str:"synthesizeCoefficient"}),y.TargetRegionTexture=new s.jc({str:"targetRegionTexture"}),y.SynthesizeTexture0=new s.jc({str:"synthesizeTexture0"}),y.SynthesizeTexture1=new s.jc({str:"synthesizeTexture1"}),y.SynthesizeTexture2=new s.jc({str:"synthesizeTexture2"}),y.SynthesizeTexture3=new s.jc({str:"synthesizeTexture3"}),y.SynthesizeTexture4=new s.jc({str:"synthesizeTexture4"}),y.SynthesizeTexture5=new s.jc({str:"synthesizeTexture5"})},581:(e,t,n)=>{n.d(t,{w:()=>I});var o=n(9871),a=n(1255),i=n(7751),r=n(4114),s=n(3414),l=n(975),c=n(9186),_=n(4132),u=n(6737),f=n(7295),d=n(1124),h=n(9011),m=n(5338),p=n(4772),v=n(7476);const x={code:"\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec4 v_texcoord_1;\nout vec4 v_projPosition_from_light;\nout vec3 v_baryCentricCoord;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n  v_color = a_color;\n  v_texcoord_0 = a_texcoord_0;\n\n  // Shadow mapping\n  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);\n  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;\n\n  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html\n  mat4 tMatrix = mat4(\n    0.5, 0.0, 0.0, 0.0,\n    0.0, 0.5, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.5, 0.5, 0.0, 1.0\n  );\n  v_texcoord_1 = tMatrix * v_projPosition_from_light;\n\n}\n",shaderStage:"vertex",isFragmentShader:!1},g={code:"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec4 v_texcoord_1;\nin vec4 v_projPosition_from_light;\nin vec3 v_baryCentricCoord;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nfloat decodeRGBAToDepth(vec4 RGBA){\n  const float rMask = 1.0;\n  const float gMask = 1.0 / 255.0;\n  const float bMask = 1.0 / (255.0 * 255.0);\n  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n  return depth;\n}\n\nfloat linstep(float min,float max,float v){\n  return clamp((v-min)/(max-min),0.0,1.0);\n}\n\nfloat reduceLightBleeding(float p_max, float parameter){\n  return linstep(parameter,1.0,p_max);\n}\n\nfloat chebyshevUpperBound(float materialSID){\n  float textureDepth = decodeRGBAToDepth(textureProj(u_depthTexture, v_texcoord_1));\n  float textureSquareDepth = decodeRGBAToDepth(textureProj(u_squareDepthTexture, v_texcoord_1));\n  if(textureDepth == 1.0 || textureSquareDepth == 1.0){\n    return 1.0;\n  }\n\n  float nonShadowProb = 1.0;\n\n  if(v_projPosition_from_light.w > 0.0){\n    float measureDepth;\n    bool isPointLight = get_isPointLight(materialSID, 0);\n    if(isPointLight){\n      float zNear = get_zNearInner(materialSID, 0);\n      float zFar = get_zFarInner(materialSID, 0);\n      float normalizationCoefficient = 1.0 / (zFar - zNear);\n      measureDepth = normalizationCoefficient * length(v_projPosition_from_light);\n    }else{\n      measureDepth = (v_projPosition_from_light / v_projPosition_from_light.w).z;\n    }\n\n    float depthAdjustment = get_depthAdjustment(materialSID, 0);\n    measureDepth += depthAdjustment;\n\n    float textureDepthAdjustment = get_textureDepthAdjustment(materialSID, 0);\n    textureDepth += textureDepthAdjustment;\n\n    float d = measureDepth - textureDepth;\n    if(d < 0.0) return 1.0;\n\n    float variance = textureSquareDepth - textureDepth * textureDepth;\n    float minimumVariance = get_minimumVariance(materialSID, 0);\n    variance = max(variance, minimumVariance);\n\n    nonShadowProb = variance / (variance + d * d);\n\n\n    float lightBleedingParameter = get_lightBleedingParameter(materialSID, 0);\n    nonShadowProb = reduceLightBleeding(nonShadowProb, lightBleedingParameter);\n  }\n  return nonShadowProb;\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  // diffuseColor\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture\n  vec4 textureColor = texture(u_diffuseColorTexture, v_texcoord_0);\n  if (textureColor.r > 0.05) {\n    diffuseColor *= textureColor.rgb;\n    alpha *= textureColor.a;\n  }\n\n  // shadow mapping\n  vec4 shadowColor = get_shadowColor(materialSID, 0);\n\n  float nonShadowProb = chebyshevUpperBound(materialSID);\n  diffuseColor = nonShadowProb * diffuseColor + (1.0 - nonShadowProb) * shadowColor.rgb;\n  alpha = nonShadowProb * alpha + (1.0 - nonShadowProb) * shadowColor.a;\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    int lightNumber = get_lightNumber(materialSID, 0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      // Light\n      Light light = getLight(i, v_position_inWorld.xyz);\n\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      vec3 viewPosition = get_viewPosition(materialSID, 0);\n      float shininess = get_shininess(materialSID, 0);\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n\n  rt0 = vec4(shadingColor, alpha);\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n",shaderStage:"fragment",isFragmentShader:!0};var y=n(589),b=n(3497);class I extends a.F{constructor(e,{isMorphing:t,isSkinning:n,isLighting:o,isDebugging:a,colorAttachmentsNumberDepth:u,colorAttachmentsNumberSquareDepth:f,depthCameraComponent:p},I){super(e,{isMorphing:t,isSkinning:n,isLighting:o},x,g),2!==I.length&&b.V.error("invalid length of renderPasses"),null==p?b.V.warn("need to set depth camera component"):this.__depthCameraComponent=p;for(const e of I){const t=e.getViewport();t.setComponents(1,1,t.z-1,t.w-1),e.setViewport(t)}let A;const E=I[0].getFramebuffer();let S;E?A=E.colorAttachments[u]:(b.V.warn("renderPass of depth does not have framebuffer"),A=y.rT);const T=I[1].getFramebuffer();T?S=T.colorAttachments[f]:(b.V.warn("renderPass of square depth does not have framebuffer"),S=y.rT);const w=[{semantic:"lightViewProjectionMatrix",compositionType:i.h.Mat4,componentType:r.I.Float,stage:_.C.VertexShader,isInternalSetting:!0,initialValue:v.g.zero(),min:-Number.MAX_VALUE,max:Number.MAX_VALUE},{semantic:"shadingModel",compositionType:i.h.Scalar,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(c.y.Constant.index),min:0,max:3},{semantic:"shininess",compositionType:i.h.Scalar,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(5),min:0,max:Number.MAX_VALUE},{semantic:"allowableDepthError",compositionType:i.h.Scalar,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(1e-4),min:0,max:1},{semantic:"shadowColor",compositionType:i.h.Vec4,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:s.IU.fromCopyArray([.5,.5,.5,1]),min:0,max:1},{semantic:"diffuseColorFactor",compositionType:i.h.Vec4,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:s.IU.fromCopyArray([1,1,1,1]),min:0,max:2},{semantic:"zNearInner",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,isInternalSetting:!0,initialValue:h.X5.fromCopyNumber(.1),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"zFarInner",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,isInternalSetting:!0,initialValue:h.X5.fromCopyNumber(1e4),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"isPointLight",componentType:r.I.Bool,compositionType:i.h.Scalar,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(1),min:0,max:1},{semantic:"wireframe",componentType:r.I.Float,compositionType:i.h.Vec3,stage:_.C.PixelShader,initialValue:l.Pq.fromCopyArray([0,0,1]),min:0,max:10},{semantic:"depthAdjustment",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(0),min:0,max:1},{semantic:"lightBleedingParameter",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(0),min:0,max:1},{semantic:"minimumVariance",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(1e-7),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"textureDepthAdjustment",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.PixelShader,initialValue:h.X5.fromCopyNumber(0),min:0,max:1},{semantic:"normalTexture",compositionType:i.h.Texture2D,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:[0,y.Uk],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"diffuseColorTexture",compositionType:i.h.Texture2D,componentType:r.I.Int,stage:_.C.PixelShader,initialValue:[1,y.vK],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"depthTexture",componentType:r.I.Int,compositionType:i.h.Texture2D,stage:_.C.PixelShader,initialValue:[2,A],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"squareDepthTexture",componentType:r.I.Int,compositionType:i.h.Texture2D,stage:_.C.PixelShader,initialValue:[3,S],min:0,max:Number.MAX_SAFE_INTEGER}];w.push({semantic:"pointSize",componentType:r.I.Float,compositionType:i.h.Scalar,stage:_.C.VertexShader,soloDatum:!0,initialValue:h.X5.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:r.I.Float,compositionType:i.h.Vec3,stage:_.C.VertexShader,soloDatum:!0,initialValue:l.Pq.fromCopyArray([0,.1,.01]),min:0,max:1}),t&&w.push({semantic:"morphTargetNumber",componentType:r.I.Int,compositionType:i.h.Scalar,stage:_.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:h.X5.fromCopyNumber(0),min:0,max:m.T.maxVertexMorphNumberInShader,needUniformInDataTextureMode:!0},{semantic:"dataTextureMorphOffsetPosition",componentType:r.I.Int,compositionType:i.h.ScalarArray,arrayLength:m.T.maxVertexMorphNumberInShader,stage:_.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new d.u(new Int32Array(m.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:r.I.Float,compositionType:i.h.ScalarArray,arrayLength:m.T.maxVertexMorphNumberInShader,stage:_.C.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new d.u(new Float32Array(m.T.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}),a&&w.push({semantic:"debugColorFactor",compositionType:i.h.Vec4,componentType:r.I.Float,stage:_.C.PixelShader,initialValue:s.IU.fromCopyArray([1,0,0,1]),min:0,max:2}),this.setShaderSemanticsInfoArray(w)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:a}){var i;let r=a.renderPass.cameraComponent;null==r&&(r=u.O.getComponent(f.n,f.n.current));const s=null!==(i=this.__depthCameraComponent)&&void 0!==i?i:a.renderPass.cameraComponent;a.setUniform?(this.setWorldMatrix(t,a.worldMatrix),this.setNormalMatrix(t,a.normalMatrix),this.setViewInfo(t,r,a.isVr,a.displayIdx),this.setProjection(t,r,a.isVr,a.displayIdx),I.__lastZNear!==s.zNearInner&&(t._gl.uniform1f(t.zNearInner,s.zNearInner),I.__lastZNear=s.zNearInner),I.__lastZFar!==s.zFarInner&&(t._gl.uniform1f(t.zFarInner,s.zFarInner),I.__lastZFar=s.zFarInner),p.f.getWebGLResourceRepository().setUniformValue(t,o.lk.LightViewProjectionMatrix.str,!0,s.viewProjectionMatrix)):(e.setParameter("zNearInner",s.zNearInner),e.setParameter("zFarInner",s.zFarInner),e.setParameter("lightViewProjectionMatrix",s.viewProjectionMatrix));const l=a.entity.tryToGetSkeletal();this.setSkinning(t,a.setUniform,l),this.setLightsInfo(t,a.lightComponents,e,a.setUniform);const c=a.entity.tryToGetBlendShape();this.setMorphInfo(t,a.entity.getMesh(),a.primitive,c),p.f.getWebGLResourceRepository().setUniformValue(t,o.lk.LightViewProjectionMatrix.str,!0,s.viewProjectionMatrix)}set depthCameraComponent(e){this.__depthCameraComponent=e}}I.IsPointLight=new o.jc({str:"isPointLight"}),I.DepthTexture=new o.jc({str:"depthTexture"}),I.SquareDepthTexture=new o.jc({str:"squareDepthTexture"}),I.DepthAdjustment=new o.jc({str:"depthAdjustment"}),I.TextureDepthAdjustment=new o.jc({str:"textureDepthAdjustment"}),I.MinimumVariance=new o.jc({str:"minimumVariance"}),I.LightBleedingParameter=new o.jc({str:"lightBleedingParameter"}),I.ShadowColor=new o.jc({str:"shadowColor"}),I.AllowableDepthError=new o.jc({str:"allowableDepthError"}),I.zNearInner=new o.jc({str:"zNearInner"}),I.zFarInner=new o.jc({str:"zFarInner"}),I.DebugColorFactor=new o.jc({str:"debugColorFactor"}),I.__lastZNear=0,I.__lastZFar=0},1255:(e,t,n)=>{n.d(t,{F:()=>M});var o=n(8819),a=n(5338),i=n(5882),r=n(8924),s=n(975),l=n(7476),c=n(3639),_=n(3212),u=n(6195),f=n(7670),d=n(4132),h=n(3583),m=n(6737),p=n(9929),v=n.n(p),x=n(4114),g=n(7751),y=n(4289),b=n(5697),I=n(2162),A=n(1881),E=n(5572),S=n(589),T=n(2766),w=n(9993),C=n(3497);class R{static fillTemplate(e,t){const n=Object.assign(t,{WellKnownComponentTIDs:y.N,Config:a.T});return v().fillTemplate(e,n)}static getShaderDataReflection(e){const t=this.__copyShaderityObject(e),n=new Map,o=e.code.split(/\r\n|\n/),a=[],i=[];for(const t of o){const o=/^[\t ]*\/\/[\t ]*#param[\t ]+(\w+)[ \t]*:[\t ]*([\w><]+);[\t ]*(\/\/)*[\t ]*(.*)/,r=t.match(o),s=/^[\t ]*@group\(1\) @binding\((\d+)\)[ \t]*var[ \t]*(\w+)[ \t]*:[ \t]*([\w><]+);[\t ]*\/\/*[\t ]*(.*)/,l=t.match(s),c=/^[\t ]*@group\(2\) @binding\((\d+)\)[ \t]*var[ \t]*(\w+)[ \t]*:[ \t]*sampler;/,_=t.match(c);if(r){const t=r[2],n=r[1],o=r[4],a=this.__createShaderSemanticsInfo(t,n,o,e.isFragmentShader);i.push(a)}else if(l){const t=parseInt(l[1]),o=l[2],a=l[3],r=l[4],s=this.__createShaderSemanticInfoForTexture(a,o,t,r,e.isFragmentShader);n.set(t,s),i.push(s)}else if(_){const e=parseInt(_[1]);if(_[2],n.has(e)){const t=n.get(e);if(t){const e=new w.L({magFilter:T.gu.Linear,minFilter:T.gu.Linear,wrapS:T.gu.Repeat,wrapT:T.gu.Repeat,wrapR:T.gu.Repeat,anisotropy:!1});t.initialValue[2]=e}}}else a.push(t)}return t.code=a.join("\n"),{shaderSemanticsInfoArray:i,shaderityObject:t}}static __createShaderSemanticInfoForTexture(e,t,n,o,a){const i=x.I.Int;let r=g.h.Texture2D;-1!==e.indexOf("texture_2d")?r=g.h.Texture2D:-1!==e.indexOf("texture_cube")&&(r=g.h.TextureCube);const s=a?d.C.PixelShader:d.C.VertexShader,l={semantic:t,compositionType:r,componentType:i,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!1,stage:s},c=o.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);if(c){const e=c[1];l.initialValue=this.__getInitialValueFromTextForTexture(l,n,e)}else l.initialValue=this.__getDefaultInitialValue(l);return l}static __createShaderSemanticsInfo(e,t,n,o){const a=x.I.fromWgslString(e),i=g.h.fromWgslString(e),r=o?d.C.PixelShader:d.C.VertexShader,s={semantic:t,compositionType:i,componentType:a,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!1,stage:r};return this.__setRhodoniteOriginalParametersTo(s,n),s}static __setRhodoniteOriginalParametersTo(e,t){const n=t.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/);let o=!1;"true"===(null==n?void 0:n[1])&&(o=!0),e.soloDatum=o;const a=t.match(/isInternalSetting[\t ]*=[\t ]*(\w+)[,\t ]*/);let i=!1;"true"===(null==a?void 0:a[1])&&(i=!0),e.isInternalSetting=i;const r=t.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);if(r){const t=r[1];e.initialValue=this.__getInitialValueFromText(e,t)}else e.initialValue=this.__getDefaultInitialValue(e);const s=t.match(/needUniformInDataTextureMode[\t ]*=[\t ]*(.+)[,\t ]*/);if(s){let t=!1;"true"===(null==s?void 0:s[1])&&(t=!0),e.needUniformInDataTextureMode=t}}static __getInitialValueFromTextForTexture(e,t,n){let o;const a=new w.L({magFilter:T.gu.Linear,minFilter:T.gu.Linear,wrapS:T.gu.ClampToEdge,wrapT:T.gu.ClampToEdge,wrapR:T.gu.ClampToEdge,anisotropy:!1});if(e.compositionType===g.h.Texture2D||e.compositionType===g.h.Texture2DShadow){const e=n.charAt(0).toUpperCase()+n.slice(1);o=[t,S.K1[`dummy${e}Texture`],a]}else if(e.compositionType===g.h.TextureCube){const e=n.charAt(0).toUpperCase()+n.slice(1);o=[t,S.K1[`dummy${e}CubeTexture`],a]}return o}static __getInitialValueFromText(e,t){const n=t.match(/\(([\d\w., ]+)\)/),o=t=>{e.compositionType!==t&&C.V.error("component number of initialValue is invalid:"+e.semantic)};let a;if(n){const e=n[1].split(",");switch(e.length){case 1:o(g.h.Scalar),a="true"===e[0]?new A.n9(new Float32Array([1])):"false"===e[0]?new A.n9(new Float32Array([0])):new A.n9(new Float32Array([parseFloat(e[0])]));break;case 2:o(g.h.Vec2),a=i.A3.fromCopyArray([parseFloat(e[0]),parseFloat(e[1])]);break;case 3:o(g.h.Vec3),a=b.tp.fromCopyArray([parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2])]);break;case 4:o(g.h.Vec4),a=r.Am.fromCopyArray([parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])]);break;case 9:o(g.h.Mat3),a=I._.fromCopy9RowMajor(parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6]),parseFloat(e[7]),parseFloat(e[8]));break;case 16:o(g.h.Mat4),a=l.g.fromCopy16RowMajor(parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6]),parseFloat(e[7]),parseFloat(e[8]),parseFloat(e[9]),parseFloat(e[10]),parseFloat(e[11]),parseFloat(e[12]),parseFloat(e[13]),parseFloat(e[14]),parseFloat(e[15]));break;default:C.V.error("Invalid format")}}else o(g.h.Scalar),a="true"===t?new A.n9(new Float32Array([1])):"false"===t?new A.n9(new Float32Array([0])):new A.n9(new Float32Array([parseFloat(t)]));return a}static __getDefaultInitialValue(e){return e.compositionType===g.h.Scalar?new A.n9(new Float32Array([0])):e.compositionType===g.h.Vec2?i.A3.zero():e.compositionType===g.h.Vec3?b.tp.zero():e.compositionType===g.h.Vec4?r.Am.zero():e.compositionType===g.h.Mat2?E.Q.identity():e.compositionType===g.h.Mat3?I._.identity():e.compositionType===g.h.Mat4?l.g.identity():e.compositionType===g.h.Texture2D||e.compositionType===g.h.Texture2DShadow?[0,S.vK]:e.compositionType===g.h.TextureCube?[0,S.rT]:void C.V.warn("initial value is not found")}static __copyShaderityObject(e){return{code:e.code,shaderStage:e.shaderStage,isFragmentShader:"fragment"===e.shaderStage}}}var P=n(9491),N=n(6301);class M extends o.E{constructor(e,{isMorphing:t=!1,isSkinning:n=!1,isLighting:o=!1}={},a,i){super(),this.__semantics=[],this.__definitions="",this.shaderType=d.C.VertexAndPixelShader,this.__materialName=e,this.__isMorphing=t,this.__isSkinning=n,this.__isLighting=o,this.__vertexShaderityObject=a,this.__pixelShaderityObject=i}getMaterialSemanticsVariantName(){let e="";for(const t of this.__semantics)e+=`${t.semantic} ${t.stage.index} ${t.componentType.index} ${t.compositionType.index} ${t.soloDatum} ${t.isInternalSetting} ${t.arrayLength} ${t.needUniformInDataTextureMode}\n`;const t=N.$j.toCRC32(e);return this.__materialName+"_semanticsVariation"+t}get vertexShaderityObject(){return this.__vertexShaderityObject}get pixelShaderityObject(){return this.__pixelShaderityObject}getDefinitions(){return this.__definitions}static getMaterialNode(e){return M.materialNodes[e]}get _semanticsInfoArray(){return this.__semantics}get isSkinning(){return this.__isSkinning}get isMorphing(){return this.__isMorphing}get isLighting(){return this.__isLighting}setShaderSemanticsInfoArray(e){const t=[];for(const n of e)t.push(n);this.__semantics=t}setupBasicInfo(e,t,n,o,a){if(e.setUniform){if(this.setWorldMatrix(t,e.worldMatrix),this.setNormalMatrix(t,e.normalMatrix),this.setIsBillboard(t,e.isBillboard),n||e.isVr){let n=e.renderPass.cameraComponent;null==n&&(n=m.O.getComponent(a,a.current)),this.setViewInfo(t,n,e.isVr,e.displayIdx),this.setProjection(t,n,e.isVr,e.displayIdx)}if(n){this.setLightsInfo(t,e.lightComponents,o,e.setUniform);const n=e.entity.tryToGetSkeletal();this.setSkinning(t,e.setUniform,n)}}const i=e.entity.tryToGetBlendShape();this.setMorphInfo(t,e.entity.getMesh(),e.primitive,i)}setWorldMatrix(e,t){e._gl.uniformMatrix4fv(e.worldMatrix,!1,t._v)}setNormalMatrix(e,t){e._gl.uniformMatrix3fv(e.normalMatrix,!1,t._v)}setIsBillboard(e,t){e._gl.uniform1i(e.isBillboard,t?1:0)}setViewInfo(e,t,n,o){let a,i;if(n){const e=h.e.getInstance().getModule("xr").WebXRSystem.getInstance();e.isWebXRMode&&(a=e._getViewMatrixAt(o),i=e._getCameraWorldPositionAt(o))}else t?(i=t.worldPosition,a=t.viewMatrix):(a=l.g.identity(),i=s.Pq.fromCopyArray([0,0,10]));e._gl.uniformMatrix4fv(e.viewMatrix,!1,a._v),e._gl.uniform3fv(e.viewPosition,i._v)}setProjection(e,t,n,o){let a;if(n){const e=h.e.getInstance().getModule("xr").WebXRSystem.getInstance();e.isWebXRMode&&(a=e._getProjectMatrixAt(o))}else a=t?t.projectionMatrix:l.g.identity();e._gl.uniformMatrix4fv(e.projectionMatrix,!1,a._v)}setSkinning(e,t,n){if(this.__isSkinning)if(n){if(t){if(a.T.boneDataType===u.N.Mat43x1){const t=n.jointMatricesArray;e._gl.uniformMatrix4x3fv(e.boneMatrix,!1,t)}else if(a.T.boneDataType===u.N.Vec4x2){const t=n.jointTranslatePackedQuat,o=n.jointScalePackedQuat;e._gl.uniform4fv(e.boneTranslatePackedQuat,t),e._gl.uniform4fv(e.boneScalePackedQuat,o)}else if(a.T.boneDataType===u.N.Vec4x2Old){const t=n.jointQuaternionArray,o=n.jointTranslateScaleArray;e._gl.uniform4fv(e.boneQuaternion,t),e._gl.uniform4fv(e.boneTranslateScale,o)}else if(a.T.boneDataType===u.N.Vec4x1){const t=n.jointCompressedChunk,o=n.jointCompressedInfo;e._gl.uniform4fv(e.boneCompressedChunk,t),e._gl.uniform4fv(e.boneCompressedInfo,o._v)}e._gl.uniform1i(e.skinningMode,n.componentSID)}}else t&&e._gl.uniform1i(e.skinningMode,-1)}setLightsInfo(e,t,n,o){if(this.__isLighting&&o){const n=t.filter((e=>e.enable));e._gl.uniform1i(e.lightNumber,n.length);const o=Math.min(n.length,a.T.maxLightNumberInShader);M.__lightPositions.length!==3*o&&(M.__lightPositions=new Float32Array(3*o),M.__lightDirections=new Float32Array(3*o),M.__lightIntensities=new Float32Array(3*o),M.__lightProperties=new Float32Array(4*o));for(let t=0;t<n.length&&!(t>=a.T.maxLightNumberInShader)&&null!=e.lightPosition;t++){const e=n[t],o=e.entity.getSceneGraph().worldPosition,a=e.direction,i=e.intensity;M.__lightPositions[3*t+0]=o.x,M.__lightPositions[3*t+1]=o.y,M.__lightPositions[3*t+2]=o.z;const r=1/Math.max(.001,Math.cos(e.innerConeAngle)-Math.cos(e.outerConeAngle)),s=-Math.cos(e.outerConeAngle)*r;M.__lightDirections[3*t+0]=a.x,M.__lightDirections[3*t+1]=a.y,M.__lightDirections[3*t+2]=a.z,M.__lightIntensities[3*t+0]=i.x,M.__lightIntensities[3*t+1]=i.y,M.__lightIntensities[3*t+2]=i.z,M.__lightProperties[4*t+0]=e.enable?e.type.index:-1,M.__lightProperties[4*t+1]=e.range,M.__lightProperties[4*t+2]=r,M.__lightProperties[4*t+3]=s}o>0&&(e._gl.uniform3fv(e.lightPosition,M.__lightPositions),e._gl.uniform3fv(e.lightDirection,M.__lightDirections),e._gl.uniform3fv(e.lightIntensity,M.__lightIntensities),e._gl.uniform4fv(e.lightProperty,M.__lightProperties))}}setMorphInfo(e,t,n,o){if(!this.__isMorphing)return;if(0===n.targets.length)return void e._gl.uniform1i(e.morphTargetNumber,0);e._gl.uniform1i(e.morphTargetNumber,n.targets.length);const i=n.targets.map((e=>{const t=e.get(c.r.Position.XYZ);let n=0;return _.m.isDataTextureApproach(f.l.currentProcessApproach)&&(n=a.T.totalSizeOfGPUShaderDataStorageExceptMorphData),(n+t.byteOffsetInBuffer)/4/4}));let r;e._gl.uniform1iv(e.dataTextureMorphOffsetPosition,i),r=o.weights.length>0?o.weights:new Float32Array(n.targets.length),e._gl.uniform1fv(e.morphWeights,r)}_setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){}_setInternalSettingParametersToGpuWebGLPerPrimitive({material:e,shaderProgram:t,firstTime:n,args:o}){}_setInternalSettingParametersToGpuWebGpu({material:e,args:t}){}getDefinition(){return""}doShaderReflection(e,t,n,o){let a,i;f.l.currentProcessApproach===_.m.WebGPU?(a=R.getShaderDataReflection(n),i=R.getShaderDataReflection(o),this.__vertexShaderityObject=a.shaderityObject,this.__pixelShaderityObject=i.shaderityObject):(a=P.r.getShaderDataReflection(e),i=P.r.getShaderDataReflection(t),this.__vertexShaderityObject=a.shaderityObject,this.__pixelShaderityObject=i.shaderityObject);const r=[];for(const e of a.shaderSemanticsInfoArray)e.stage=d.C.VertexShader,r.push(e);for(const e of i.shaderSemanticsInfoArray){const t=r.find((t=>t.semantic===e.semantic));t?t.stage=d.C.VertexAndPixelShader:(e.stage=d.C.PixelShader,r.push(e))}return r}}M.materialNodes=[],M.__tmp_vector4=r.Am.zero(),M.__tmp_vector2=i.A3.zero(),M.__lightPositions=new Float32Array(0),M.__lightDirections=new Float32Array(0),M.__lightIntensities=new Float32Array(0),M.__lightProperties=new Float32Array(0)},7014:(e,t,n)=>{n.d(t,{Q:()=>s});var o=n(8819),a=n(4132),i=n(8592),r=n(2766);class s extends o.E{constructor(e,t){super(),this.__inputs=[],this.__outputs=[],this.__inputConnections=[],this._shaderStage="Neutral",this.__shaderFunctionName=e,this.__codeGLSL=t.codeGLSL,this.__codeWGSL=t.codeWGSL,this.__shaderNodeUid=++s.__invalidShaderNodeCount,s._shaderNodes[s.__invalidShaderNodeCount]=this,this.__commonPart=t.commonPart}setShaderStage(e){this._shaderStage=e}getShaderStage(){return this._shaderStage}static getShaderNodeByUid(e){return s._shaderNodes[e]}addInputConnection(e,t,n){let o=-1;for(let e=0;e<this.__inputs.length;e++)if(this.__inputs[e].name===n.name){o=e;break}this.__inputConnections[o]={shaderNodeUid:e.shaderNodeUid,outputNameOfPrev:t.name,inputNameOfThis:n.name}}get shaderFunctionName(){return this.__shaderFunctionName}getShaderFunctionNameDerivative(){return this.__shaderFunctionName}getShaderCode(e){return null!=this.__commonPart?e===a.C.VertexShader?this.__commonPart.vertexShaderDefinitions:this.__commonPart.pixelShaderDefinitions:i.lK.currentProcessApproach===r.m7.WebGPU?this.__codeWGSL:this.__codeGLSL}get shaderNodeUid(){return this.__shaderNodeUid}getInput(e){for(const t of this.__inputs)if(t.name===e)return t}getInputs(){return this.__inputs}getOutput(e){for(const t of this.__outputs)if(t.name===e)return t}getOutputs(){return this.__outputs}get inputConnections(){return this.__inputConnections}makeCallStatement(e,t,n,o,a){let s="";const l=o[e].concat(a[e]);if(t.getInputs().length===o[e].length&&t.getOutputs().length===a[e].length){let t="";if(l.length>0){t+=`${n}(`;for(let n=0;n<l.length;n++)null!=l[n]&&(0!==n&&(t+=", "),i.lK.currentProcessApproach===r.m7.WebGPU&&n>=o[e].length&&(t+="&"),t+=l[n]);t+=");\n"}s+=t}return s}}s._shaderNodes=[],s.__invalidShaderNodeCount=-1},589:(e,t,n)=>{n.d(t,{EY:()=>c,JD:()=>_,K1:()=>d,OZ:()=>u,Uk:()=>r,cC:()=>l,iE:()=>f,rT:()=>s,vK:()=>i});var o=n(8973),a=n(1018);const i=new a.g,r=new a.g,s=new a.g,l=new o.b,c=new a.g,_=new a.g,u=new a.g;async function f(){i.isTextureReady||(i.tryToSetUniqueName("dummyWhiteTexture",!0),r.tryToSetUniqueName("dummyBlueTexture",!0),s.tryToSetUniqueName("dummyBlackTexture",!0),l.tryToSetUniqueName("dummyBlackCubeTexture",!0),c.tryToSetUniqueName("sheenLutTexture",!0),_.tryToSetUniqueName("dummySRGBGrayTexture",!0),u.tryToSetUniqueName("dummyAnisotropyTexture",!0),i.generate1x1TextureFrom(),r.generate1x1TextureFrom("rgba(127.5, 127.5, 255, 1)"),s.generate1x1TextureFrom("rgba(0, 0, 0, 1)"),l.load1x1Texture("rgba(0, 0, 0, 1)"),await c.generateSheenLutTextureFromDataUri(),_.generate1x1TextureFrom("rgba(186, 186, 186, 1)"),u.generate1x1TextureFrom("rgba(255, 127.5, 255, 1)"))}const d={dummyWhiteTexture:i,dummyBlueTexture:r,dummyBlackTexture:s,dummyBlackCubeTexture:l,sheenLutTexture:c,dummySRGBGrayTexture:_,dummyAnisotropyTexture:u}},8374:(e,t,n)=>{n.d(t,{i:()=>S});var o=n(8819),a=n(6338),i=n(7751),r=n(8805),s=n(4772),l=n(4132),c=n(3107),_=n(3886),u=n(9929),f=n.n(u),d=n(5338),h=n(6195),m=n(3212),p=n(7670),v=n(9491),x=n(3583),g=n(2229);class y{static _createShaderProgramWithCache(e,t,n,o,a,i,r){const l=n+o;let c=this.__shaderStringMap.get(l);return c?[c,!1]:(c=s.f.getCgApiResourceRepository().createShaderProgram({material:e,primitive:t,vertexShaderStr:n,fragmentShaderStr:o,attributeNames:a,attributeSemantics:i,onError:r}),this.__shaderStringMap.set(l,c),[c,!0])}}function b(e){const t=v.r.getAttributeReflection(e.vertexShaderityObject);return{attributeNames:t.names,attributeSemantics:t.semantics}}function I(e,t){let n="";const o=s.f.getWebGLResourceRepository(),a=o.currentWebGLContextWrapper;a.isWebGL2&&(n+="#version 300 es\n#define GLSL_ES3\n",d.T.isUboEnabled&&(n+="#define RN_IS_UBO_ENABLED\n")),n+=`#define RN_MATERIAL_TYPE_NAME ${e}\n`,m.m.isDataTextureApproach(p.l.currentProcessApproach)?n+="#define RN_IS_DATATEXTURE_MODE\n":n+="#define RN_IS_UNIFORM_MODE\n";const i=x.e.getInstance().getModule("xr"),r=null==i?void 0:i.WebXRSystem.getInstance();return g.Is.exist(r)&&r.isWebXRMode&&o.isSupportMultiViewVRRendering()&&(n+="#define WEBGL2_MULTI_VIEW\n"),(a.isWebGL2||a.webgl1ExtDRV)&&(n+="#define RN_IS_SUPPORTING_STANDARD_DERIVATIVES\n"),d.T.boneDataType===h.N.Mat43x1?n+="#define RN_BONE_DATA_TYPE_Mat43x1\n":d.T.boneDataType===h.N.Vec4x2?n+="#define RN_BONE_DATA_TYPE_VEC4X2\n":d.T.boneDataType===h.N.Vec4x2Old?n+="#define RN_BONE_DATA_TYPE_VEC4X2_OLD\n":d.T.boneDataType===h.N.Vec4x1&&(n+="#define RN_BONE_DATA_TYPE_VEC4X1\n"),n}function A(e){let t="";const n=e.attributeSemantics;for(const o of n){if(-1!==o.indexOf("POSITION")){t+="#define RN_USE_POSITION\n";const n=e.getAttribute(o);n.componentType.isFloatingPoint()?t+="#define RN_USE_POSITION_FLOAT\n":n.componentType.isInteger()?t+="#define RN_USE_POSITION_INT\n":t+="#define RN_USE_POSITION_UINT\n"}if(-1!==o.indexOf("NORMAL")&&(t+="#define RN_USE_NORMAL\n"),-1!==o.indexOf("TANGENT")&&(t+="#define RN_USE_TANGENT\n"),-1!==o.indexOf("TEXCOORD_0")&&(t+="#define RN_USE_TEXCOORD_0\n"),-1!==o.indexOf("TEXCOORD_1")&&(t+="#define RN_USE_TEXCOORD_1\n"),-1!==o.indexOf("COLOR_0")){t+="#define RN_USE_COLOR_0\n";const n=e.getAttribute(o);n.componentType.isFloatingPoint()?t+="#define RN_USE_COLOR_0_FLOAT\n":n.componentType.isInteger()?t+="#define RN_USE_COLOR_0_INT\n":t+="#define RN_USE_COLOR_0_UINT\n"}-1!==o.indexOf("JOINTS_0")&&(t+="#define RN_USE_JOINTS_0\n"),-1!==o.indexOf("WEIGHTS_0")&&(t+="#define RN_USE_WEIGHTS_0\n"),-1!==o.indexOf("FACE_NORMAL")&&(t+="#define RN_USE_FACE_NORMAL\n"),-1!==o.indexOf("BARY_CENTRIC_COORD")&&(t+="#define RN_USE_BARY_CENTRIC_COORD\n"),-1!==o.indexOf("TEXCOORD_2")&&(t+="#define RN_USE_TEXCOORD_2\n")}return null!=e.targets&&e.targets.length>0&&(t+="#define RN_IS_MORPHING\n"),t+="#define RN_USE_INSTANCE\n",t}y.__shaderStringMap=new Map;var E=n(3497);class S extends o.E{constructor(e,t,n,o,i){super(),this._allFieldVariables=new Map,this._autoFieldVariablesOnly=new Map,this._allFieldsInfo=new Map,this.__belongPrimitives=new Map,this._shaderProgramUidMap=new Map,this.__materialUid=-1,this.__materialSid=-1,this.__alphaMode=a.K.Opaque,this.zWriteWhenBlend=!1,this.colorWriteMask=[!0,!0,!0,!0],this.isTranslucent=!1,this.cullFace=!0,this.cullFrontFaceCCW=!0,this.cullFaceBack=!0,this.__alphaToCoverage=!1,this.__blendEquationMode=_.E.EquationFuncAdd,this.__blendEquationModeAlpha=_.E.EquationFuncAdd,this.__blendFuncSrcFactor=_.E.One,this.__blendFuncDstFactor=_.E.OneMinusSrcAlpha,this.__blendFuncAlphaSrcFactor=_.E.One,this.__blendFuncAlphaDstFactor=_.E.OneMinusSrcAlpha,this.__stateVersion=0,this.__fingerPrint="",this.__shaderDefines=new Set,this._materialContent=i,this.__materialTid=e,this.__materialUid=t,this.__materialSid=n,this.__materialTypeName=o}addShaderDefine(e){this.__shaderDefines.add(e),this.makeShadersInvalidate()}removeShaderDefine(e){this.__shaderDefines.delete(e),this.makeShadersInvalidate()}getShaderDefines(){return this.__shaderDefines}calcFingerPrint(){let e="";e+=this.alphaMode.index,e+=this.blendFuncSrcFactor.webgpu,e+=this.blendFuncDstFactor.webgpu,e+=this.blendFuncAlphaSrcFactor.webgpu,e+=this.blendFuncAlphaDstFactor.webgpu,e+=this.blendEquationMode.webgpu,e+=this.blendEquationModeAlpha.webgpu,e+=this.cullFace?"1":"0",e+=this.cullFrontFaceCCW?"1":"0",e+=this.cullFaceBack?"1":"0",this.__fingerPrint=e}_getFingerPrint(){return this.__fingerPrint}static get stateVersion(){return S.__stateVersion}setParameter(e,t){const n=this._allFieldsInfo.get(e);if(null!=n){let o;o=n.soloDatum?S._soloDatumFields.get(this.__materialTypeName).get(e):this._allFieldVariables.get(e),r.n._setForce(o.value,t)&&(this.__stateVersion++,S.__stateVersion++,this.calcFingerPrint())}}setTextureParameter(e,t,n){if(n.created||n.create(),this._allFieldsInfo.has(e)){const o=async()=>{void 0!==t.loadFromUrlLazy&&(await t.loadFromUrlLazy(),await t.loadFromImgLazy());const o=this._allFieldVariables.get(e),i={value:[o.value[0],t,n],info:o.info};this._allFieldVariables.set(e,i),o.info.isInternalSetting||this._autoFieldVariablesOnly.set(e,i),"diffuseColorTexture"!==e&&"baseColorTexture"!==e||t.isTransparent&&(this.alphaMode=a.K.Blend),this.__stateVersion++,S.__stateVersion++,this.calcFingerPrint()};void 0!==t.hasDataToLoadLazy&&t.hasDataToLoadLazy?setTimeout(o,0):o()}}getTextureParameter(e){if(this._allFieldsInfo.has(e))return this._allFieldVariables.get(e).value[1]}setTextureParameterAsPromise(e,t){t.then((t=>{if(this._allFieldsInfo.has(e)){const n=this._allFieldVariables.get(e),o={value:[n.value[0],t],info:n.info};this._allFieldVariables.set(e,o),n.info.isInternalSetting||this._autoFieldVariablesOnly.set(e,o),"diffuseColorTexture"!==e&&"baseColorTexture"!==e||t.isTransparent&&(this.alphaMode=a.K.Blend)}this.__stateVersion++,S.__stateVersion++,this.calcFingerPrint()}))}getParameter(e){var t,n;const o=this._allFieldsInfo.get(e);if(null!=o)return o.soloDatum?null===(t=S._soloDatumFields.get(this.__materialTypeName).get(e))||void 0===t?void 0:t.value:null===(n=this._allFieldVariables.get(e))||void 0===n?void 0:n.value}isShaderProgramReady(e){return this._shaderProgramUidMap.has(e._getFingerPrint())}_setUniformLocationsOfMaterialNodes(e,t){const n=s.f.getWebGLResourceRepository();let o=[];if(null!=this._materialContent){const e=this._materialContent._semanticsInfoArray;o=o.concat(e)}const a=this._shaderProgramUidMap.get(t._getFingerPrint());n.setupUniformLocations(a,o,e)}getShaderProgramUid(e){var t;const n=e._getFingerPrint();return null!==(t=this._shaderProgramUidMap.get(n))&&void 0!==t?t:-1}_addBelongPrimitive(e){this.__belongPrimitives.set(e.primitiveUid,e)}_createProgramWebGL(e,t,n,o){const{vertexPropertiesStr:a,pixelPropertiesStr:i}=this._getProperties(t,o),[r,l]=function(e,t,n,o,a,i){const r=s.f.getWebGLResourceRepository(),l=e._materialContent;let c=l.getDefinitions();const _=e.getShaderDefines();for(const e of _)c+=`#define ${e}\n`;c+=A(t);let u=I(e.__materialTypeName);u+="#define RN_IS_VERTEX_SHADER\n";let f=I(e.__materialTypeName);f+="#define RN_IS_PIXEL_SHADER\n",e.isBlend()&&(f+="#define RN_IS_ALPHA_MODE_BLEND\n"),e.isMask()&&(f+="#define RN_IS_ALPHA_MODE_MASK\n");const d=v.r.fillTemplate(l.vertexShaderityObject,{getters:n,definitions:c,dataUBODefinition:r.getGlslDataUBODefinitionString(),dataUBOVec4Size:r.getGlslDataUBOVec4SizeString(),matricesGetters:a}),h=v.r.fillTemplate(l.pixelShaderityObject,{renderTargetBegin:r.getGlslRenderTargetBeginString(4),getters:o,definitions:c,dataUBODefinition:r.getGlslDataUBODefinitionString(),dataUBOVec4Size:r.getGlslDataUBOVec4SizeString(),matricesGetters:a,renderTargetEnd:r.getGlslRenderTargetEndString(4)});u+=d.code.replace(/#version\s+(100|300\s+es)/,""),f+=h.code.replace(/#version\s+(100|300\s+es)/,"");const{attributeNames:m,attributeSemantics:p}=b(l),x=function(e,t){let n="\n// Vertex Attributes Binding Info\n";for(let o=0;o<e.length;o++)n+=`// ${e[o]}: ${t[o].str} \n`;return n}(m,p);u+=x;const[g,E]=y._createShaderProgramWithCache(e,t,u,f,m,p);return[g,E]}(this,n,a,i,e);return this._shaderProgramUidMap.set(n._getFingerPrint(),r),S.__stateVersion++,[r,l]}_createProgramWebGpu(e,t,n){const{vertexPropertiesStr:o,pixelPropertiesStr:a}=this._getProperties(n,!0),i=function(e,t,n,o,a){const i=e._materialContent;let r=`// Material Type: ${e.materialTypeName}\n`;r+=i.getDefinitions();const s=e.getShaderDefines();for(const e of s)r+=`#define ${e}\n`;r+=A(t),d.T.boneDataType===h.N.Mat43x1?r+="#define RN_BONE_DATA_TYPE_Mat43x1\n":d.T.boneDataType===h.N.Vec4x2?r+="#define RN_BONE_DATA_TYPE_VEC4X2\n":d.T.boneDataType===h.N.Vec4x2Old?r+="#define RN_BONE_DATA_TYPE_VEC4X2_OLD\n":d.T.boneDataType===h.N.Vec4x1&&(r+="#define RN_BONE_DATA_TYPE_VEC4X1\n");const l=v.r.fillTemplate(i.vertexShaderityObject,{getters:o,definitions:"// RN_IS_VERTEX_SHADER\n#define RN_IS_VERTEX_SHADER\n"+r,matricesGetters:n,maxMorphDataNumber:""+Math.ceil(d.T.maxVertexPrimitiveNumberInShader*d.T.maxVertexMorphNumberInShader/4)});let c="";e.isBlend()&&(c+="#define RN_IS_ALPHA_MODE_BLEND\n"),e.isMask()&&(c+="#define RN_IS_ALPHA_MODE_MASK\n");const _=v.r.fillTemplate(i.pixelShaderityObject,{getters:a,definitions:"// RN_IS_PIXEL_SHADER\n#define RN_IS_PIXEL_SHADER\n"+r+c,matricesGetters:n,maxMorphDataNumber:""+Math.ceil(d.T.maxVertexPrimitiveNumberInShader*d.T.maxVertexMorphNumberInShader/4)}),u=f().processPragma(l),m=f().processPragma(_),[p,x]=y._createShaderProgramWithCache(e,t,u.code,m.code,[],[]);return p}(this,e,t,o,a);this._shaderProgramUidMap.set(e._getFingerPrint(),i),S.__stateVersion++}_createProgramByUpdatedSources(e,t,n){const[o,a]=function(e,t,n,o,a){const{attributeNames:i,attributeSemantics:r}=b(n),[s,l]=y._createShaderProgramWithCache(e,t,o.vertex,o.pixel,i,r,a);return[s,l]}(this,t,this._materialContent,e,n);return this._shaderProgramUidMap.set(t._getFingerPrint(),o),S.__stateVersion++,[o,a]}_setupBasicUniformsLocations(e){const t=s.f.getWebGLResourceRepository(),n=e._getFingerPrint(),o=this._shaderProgramUidMap.get(n);t.setupBasicUniformLocations(o)}_setupAdditionalUniformLocations(e,t,n){const o=s.f.getWebGLResourceRepository(),a=n._getFingerPrint(),i=this._shaderProgramUidMap.get(a);o.setupUniformLocations(i,e,t)}_setInternalSettingParametersToGpuWebGpu({material:e,args:t}){this._materialContent._setInternalSettingParametersToGpuWebGpu({material:e,args:t})}_setParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}){this.__setAutoParametersToGpuWebGL(o.setUniform,n,t),this._materialContent._setInternalSettingParametersToGpuWebGL({material:e,shaderProgram:t,firstTime:n,args:o}),this.__setSoloDatumParametersToGpuWebGL({shaderProgram:t,firstTime:n,isUniformMode:o.setUniform})}_setParametersToGpuWebGLPerPrimitive({material:e,shaderProgram:t,firstTime:n,args:o}){this._materialContent._setInternalSettingParametersToGpuWebGLPerPrimitive({material:e,shaderProgram:t,firstTime:n,args:o})}_setParametersToGpuWebGLWithOutInternalSetting({shaderProgram:e,firstTime:t,isUniformMode:n}){this.__setAutoParametersToGpuWebGL(n,t,e),this.__setSoloDatumParametersToGpuWebGL({shaderProgram:e,firstTime:t,isUniformMode:n})}_getProperties(e,t){let n="",o="";this._allFieldsInfo.forEach((a=>{a.stage!==l.C.VertexShader&&a.stage!==l.C.VertexAndPixelShader||(n+=e(this.__materialTypeName,a,!1,t)),a.stage!==l.C.PixelShader&&a.stage!==l.C.VertexAndPixelShader||(o+=e(this.__materialTypeName,a,!1,t))}));const a=c.q.getInstance();return[n,o]=a._addPropertiesStr(n,o,e,t),{vertexPropertiesStr:n,pixelPropertiesStr:o}}__setAutoParametersToGpuWebGL(e,t,n){null==S.__webglResourceRepository&&(S.__webglResourceRepository=s.f.getWebGLResourceRepository());const o=S.__webglResourceRepository;if(e)this._autoFieldVariablesOnly.forEach((e=>{const a=e.info;o.setUniformValue(n,a.semantic,t,e.value)}));else for(const[e,a]of this._autoFieldVariablesOnly){const e=a.info;i.h.isTexture(e.compositionType)?t?o.setUniform1iForTexture(n,e.semantic,a.value):o.bindTexture(e,a.value):e.needUniformInDataTextureMode&&o.setUniformValue(n,e.semantic,t,a.value)}}__setSoloDatumParametersToGpuWebGL({shaderProgram:e,firstTime:t,isUniformMode:n}){const o=s.f.getWebGLResourceRepository(),a=this.__materialTypeName,r=S._soloDatumFields.get(a);if(null==r)return;const l=r.values();for(const a of l){const r=a.info;(n||i.h.isTexture(r.compositionType))&&(r.isInternalSetting||(t?o.setUniformValue(e,r.semantic,t,a.value):o.bindTexture(r,a.value)))}}setBlendEquationMode(e,t){this.__blendEquationMode=e,this.__blendEquationModeAlpha=null!=t?t:e,this.__treatForMinMax(),this.__stateVersion++,S.__stateVersion++,this.calcFingerPrint()}__treatForMinMax(){this.__blendEquationMode!==_.E.Min&&this.__blendEquationMode!==_.E.Max||(this.__blendFuncDstFactor=_.E.One,this.__blendFuncSrcFactor=_.E.One),this.__blendEquationModeAlpha!==_.E.Min&&this.__blendEquationModeAlpha!==_.E.Max||(this.__blendFuncAlphaDstFactor=_.E.One,this.__blendFuncAlphaSrcFactor=_.E.One)}setBlendFuncSeparateFactor(e,t,n,o){this.__blendFuncSrcFactor=e,this.__blendFuncDstFactor=t,this.__blendFuncAlphaSrcFactor=n,this.__blendFuncAlphaDstFactor=o,this.__treatForMinMax(),this.__stateVersion++,S.__stateVersion++,this.calcFingerPrint()}setBlendFuncFactor(e,t){this.__blendFuncSrcFactor=e,this.__blendFuncDstFactor=t,this.__blendFuncAlphaSrcFactor=e,this.__blendFuncAlphaDstFactor=t,this.__treatForMinMax(),this.__stateVersion++,S.__stateVersion++,this.calcFingerPrint()}isBlend(){return this.alphaMode===a.K.Blend}isTranslucentOpaque(){return!(this.alphaMode===a.K.Blend||!this.isTranslucent)}isBlendOrTranslucent(){return!(this.alphaMode!==a.K.Blend&&!this.isTranslucent)}isOpaque(){return this.alphaMode===a.K.Opaque}isMask(){return this.alphaMode===a.K.Mask}set alphaToCoverage(e){e&&this.alphaMode===a.K.Blend&&E.V.warn("If you set alphaToCoverage = true on a material whose AlphaMode is Translucent, you may get drawing problems."),this.__alphaToCoverage=e,this.makeShadersInvalidate(),this.calcFingerPrint()}get alphaToCoverage(){return this.__alphaToCoverage}get materialTID(){return this.__materialTid}get fieldsInfoArray(){return Array.from(this._allFieldsInfo.values())}get blendEquationMode(){return this.__blendEquationMode}get blendEquationModeAlpha(){return this.__blendEquationModeAlpha}get blendFuncSrcFactor(){return this.__blendFuncSrcFactor}get blendFuncDstFactor(){return this.__blendFuncDstFactor}get blendFuncAlphaSrcFactor(){return this.__blendFuncAlphaSrcFactor}get blendFuncAlphaDstFactor(){return this.__blendFuncAlphaDstFactor}get alphaMode(){return this.__alphaMode}set alphaMode(e){this.__alphaMode=e,this.makeShadersInvalidate()}get materialUID(){return this.__materialUid}get materialSID(){return this.__materialSid}get isSkinning(){return this._materialContent.isSkinning}get isMorphing(){return this._materialContent.isMorphing}get isLighting(){return this._materialContent.isLighting}get materialTypeName(){return this.__materialTypeName}get stateVersion(){return this.__stateVersion}makeShadersInvalidate(){this._shaderProgramUidMap.clear(),this.__stateVersion++,S.__stateVersion++}}S.__stateVersion=0,S._soloDatumFields=new Map},7488:(e,t,n)=>{n.d(t,{s:()=>d});var o=n(5338),a=n(7496),i=n(7616),r=n(4114),s=n(7751),l=n(4127),c=n(8805),_=n(2229),u=n(3497),f=n(8374);class d{static registerMaterial(e,t,n=o.T.maxMaterialInstanceForEachType){return!d.__materialNodes.has(e)&&(d.__registerInner(e,t,n),!0)}static forceRegisterMaterial(e,t,n=o.T.maxMaterialInstanceForEachType){return this.__registerInner(e,t,n),!0}static isRegisteredMaterialType(e){return d.__materialNodes.has(e)}static getMaterialByMaterialUid(e){var t;return null===(t=this.__materialMap.get(e))||void 0===t?void 0:t.deref()}static getAllMaterials(){return Array.from(d.__materialMap.values())}static createMaterial(e,t){let n=d.__materialInstanceCountOfType.get(e);const o=new f.i(d.__materialTids.get(e),++d.__materialUidCount,n++,e,t);return this.__initializeMaterial(o,n),o}static isFullOrOverOfThisMaterialType(e){const t=d.__materialInstanceCountOfType.get(e);if(_.Is.not.exist(t))return!1;const n=d.__maxInstances.get(e);return!_.Is.not.exist(n)&&t>=n}static isMaterialCompatible(e,t){var n;const o=null===(n=d.__materialMap.get(e.materialUID))||void 0===n?void 0:n.deref();if(_.Is.not.exist(o))return!1;const a=Array.from(o._allFieldsInfo.values()),i=t._semanticsInfoArray;return JSON.stringify(a)===JSON.stringify(i)}static __initializeMaterial(e,t){e.tryToSetUniqueName(e.__materialTypeName,!0);{d.__materialMap.set(e.materialUID,new WeakRef(e));let n=d.__instances.get(e.__materialTypeName);_.Is.not.exist(n)&&(n=new Map,d.__instances.set(e.materialTypeName,n)),n.set(e.materialSID,new WeakRef(e)),d.__materialInstanceCountOfType.set(e.materialTypeName,t)}if(_.Is.exist(e._materialContent)){const t=e._materialContent._semanticsInfoArray,n=d.__accessors.get(e.materialTypeName);t.forEach((t=>{if(e._allFieldsInfo.set(t.semantic,t),!t.soloDatum){const o=n.get(t.semantic).takeOne(),a={info:t,value:c.n.initWithFloat32Array(t.initialValue,t.initialValue,o,t.compositionType)};e._allFieldVariables.set(t.semantic,a),t.isInternalSetting||e._autoFieldVariablesOnly.set(t.semantic,a)}}))}}static getLocationOffsetOfMemberOfMaterial(e,t){const n=d.__instances.get(e),o=Array.from(n.values()).find((e=>void 0!==e.deref()));if(_.Is.not.exist(null==o?void 0:o.deref()))return u.V.warn(`Material is not found. getLocationOffsetOfMemberOfMaterial returns invalid 0 value. materialTypeName: ${e}`),0;const a=o.deref();return a._allFieldsInfo.get(t).soloDatum?f.i._soloDatumFields.get(a.materialTypeName).get(t).value._v.byteOffset/4/4:this.__accessors.get(e).get(t).byteOffsetInBuffer/4/4}static __registerInner(e,t,n){const o=++d.__materialTidCount;d.__materialNodes.set(e,t),d.__materialTids.set(e,o),d.__maxInstances.set(e,n),d.__allocateBufferView(e,t),d.__materialInstanceCountOfType.set(e,0)}static __allocateBufferView(e,t){let n=0;const o=[];for(const a of t._semanticsInfoArray){const t=(0,l.o)(a);let i=1;a.soloDatum||(i=d.__maxInstances.get(e)),n+=t*i,o.push({alignedByte:t,semanticInfo:a})}this.__accessors.has(e)||this.__accessors.set(e,new Map);const _=a.X.getInstance().createOrGetBuffer(i.a.GPUInstanceData);let u;this.__bufferViews.has(e)?u=this.__bufferViews.get(e):(u=_.takeBufferView({byteLengthToNeed:n,byteStride:0}).unwrapForce(),this.__bufferViews.set(e,u));for(let t=0;t<o.length;t++){const n=o[t].alignedByte,a=o[t].semanticInfo;let i=1;a.soloDatum||(i=d.__maxInstances.get(e));let l=a.arrayLength;s.h.isArray(a.compositionType)&&null==l&&(l=100);const _=u.takeAccessor({compositionType:a.compositionType,componentType:r.I.Float,count:i,byteStride:n,arrayLength:l}).unwrapForce();if(a.soloDatum){const t=_.takeOne();let n=f.i._soloDatumFields.get(e);null==n&&(n=new Map,f.i._soloDatumFields.set(e,n)),n.set(a.semantic,{info:a,value:c.n.initWithFloat32Array(a.initialValue,a.initialValue,t,a.compositionType)})}else this.__accessors.get(e).set(a.semantic,_)}return u}static _makeShaderInvalidateToAllMaterials(){var e;for(const t of d.__materialMap.values())null===(e=t.deref())||void 0===e||e.makeShadersInvalidate()}}d.__materialMap=new Map,d.__instances=new Map,d.__materialTids=new Map,d.__materialInstanceCountOfType=new Map,d.__materialNodes=new Map,d.__maxInstances=new Map,d.__bufferViews=new Map,d.__accessors=new Map,d.__materialTidCount=-1,d.__materialUidCount=-1},9491:(e,t,n)=>{n.d(t,{r:()=>b});var o=n(9929),a=n.n(o),i=n(4114),r=n(7751),s=n(3639),l=n(7496),c=n(4289),_=n(5338),u=n(5882),f=n(5697),d=n(8924),h=n(2162),m=n(7476),p=n(1881),v=n(5572),x=n(4132),g=n(589),y=n(3497);class b{static fillTemplate(e,t){const n=Object.assign(t,{WellKnownComponentTIDs:c.N,widthOfDataTexture:`const int widthOfDataTexture = ${l.X.bufferWidthLength};`,heightOfDataTexture:`const int heightOfDataTexture = ${l.X.bufferHeightLength};`,Config:_.T});return a().fillTemplate(e,n)}static transformWebGLVersion(e,t){return t?a().transformToGLSLES3(e):a().transformToGLSLES1(e,!0)}static getAttributeReflection(e){const t=a().createReflectionObject(e);return this.__setDefaultAttributeSemanticMap(t),t.reflect(),{names:t.attributesNames,semantics:t.attributesSemantics.map((e=>s.r.fromString(e))),compositions:t.attributesTypes.map((e=>r.h.fromGlslString(e))),components:t.attributesTypes.map((e=>i.I.fromGlslString(e)))}}static __setDefaultAttributeSemanticMap(e){const t=new Map;t.set("instanceinfo","INSTANCE"),t.set("barycentriccoord","BARY_CENTRIC_COORD"),e.addAttributeSemanticsMap(t)}static getShaderDataReflection(e){const t=this.__copyShaderityObject(e),n=e.code.split(/\r\n|\n/),o=[],a=[];for(const t of n){const n=/^(?![/])[\t ]*uniform[\t ]+(\w+)[\t ]+(\w+);[\t ]*(\/\/)*[\t ]*(.*)/,i=t.match(n);if(i){const n=i[1],r=i[2],s=i[4];if(this.__ignoreThisUniformDeclaration(s)){o.push(t);continue}const l=this.__createShaderSemanticsInfo(n,r,s,e.isFragmentShader);a.push(l)}else o.push(t)}return t.code=o.join("\n"),{shaderSemanticsInfoArray:a,shaderityObject:t}}static __copyShaderityObject(e){return{code:e.code,shaderStage:e.shaderStage,isFragmentShader:"fragment"===e.shaderStage}}static __ignoreThisUniformDeclaration(e){const t=e.match(/skipProcess[\t ]*=[\t ]*(\w+)[,\t ]*/);return"true"===(null==t?void 0:t[1])}static __createShaderSemanticsInfo(e,t,n,o){const a=i.I.fromGlslString(e),s=r.h.fromGlslString(e),l=o?x.C.PixelShader:x.C.VertexShader,c=t.match(/u_(\w+)/),_={semantic:t=c[1],compositionType:s,componentType:a,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!1,stage:l};return this.__setRhodoniteOriginalParametersTo(_,n),_}static __setRhodoniteOriginalParametersTo(e,t){const n=t.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/);let o=!1;"true"===(null==n?void 0:n[1])&&(o=!0),e.soloDatum=o;const a=t.match(/isInternalSetting[\t ]*=[\t ]*(\w+)[,\t ]*/);let i=!1;"true"===(null==a?void 0:a[1])&&(i=!0),e.isInternalSetting=i;const r=t.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);if(r){const t=r[1];e.initialValue=this.__getInitialValueFromText(e,t)}else e.initialValue=this.__getDefaultInitialValue(e);const s=t.match(/needUniformInDataTextureMode[\t ]*=[\t ]*(.+)[,\t ]*/);if(s){let t=!1;"true"===(null==s?void 0:s[1])&&(t=!0),e.needUniformInDataTextureMode=t}}static __getInitialValueFromText(e,t){const n=t.match(/\(([\d\w., ]+)\)/),o=t=>{e.compositionType!==t&&y.V.error("component number of initialValue is invalid:"+e.semantic)};let a;if(n){const t=n[1].split(",");switch(t.length){case 1:o(r.h.Scalar),a="true"===t[0]?new p.n9(new Float32Array([1])):"false"===t[0]?new p.n9(new Float32Array([0])):new p.n9(new Float32Array([parseFloat(t[0])]));break;case 2:if(e.compositionType===r.h.Texture2D||e.compositionType===r.h.Texture2DShadow){const e=t[1].charAt(0).toUpperCase()+t[1].slice(1);a=[parseInt(t[0]),g.K1[`dummy${e}Texture`]]}else if(e.compositionType===r.h.TextureCube){const e=t[1].charAt(0).toUpperCase()+t[1].slice(1);a=[parseInt(t[0]),g.K1[`dummy${e}CubeTexture`]]}else o(r.h.Vec2),a=u.A3.fromCopyArray([parseFloat(t[0]),parseFloat(t[1])]);break;case 3:o(r.h.Vec3),a=f.tp.fromCopyArray([parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2])]);break;case 4:o(r.h.Vec4),a=d.Am.fromCopyArray([parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])]);break;case 9:o(r.h.Mat3),a=h._.fromCopy9RowMajor(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]),parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]),parseFloat(t[7]),parseFloat(t[8]));break;case 16:o(r.h.Mat4),a=m.g.fromCopy16RowMajor(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]),parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]),parseFloat(t[7]),parseFloat(t[8]),parseFloat(t[9]),parseFloat(t[10]),parseFloat(t[11]),parseFloat(t[12]),parseFloat(t[13]),parseFloat(t[14]),parseFloat(t[15]));break;default:y.V.error("Invalid format")}}else o(r.h.Scalar),a="true"===t?new p.n9(new Float32Array([1])):"false"===t?new p.n9(new Float32Array([0])):new p.n9(new Float32Array([parseFloat(t)]));return a}static __getDefaultInitialValue(e){return e.compositionType===r.h.Scalar?new p.n9(new Float32Array([0])):e.compositionType===r.h.Vec2?u.A3.zero():e.compositionType===r.h.Vec3?f.tp.zero():e.compositionType===r.h.Vec4?d.Am.zero():e.compositionType===r.h.Mat2?v.Q.identity():e.compositionType===r.h.Mat3?h._.identity():e.compositionType===r.h.Mat4?m.g.identity():e.compositionType===r.h.Texture2D||e.compositionType===r.h.Texture2DShadow?[0,g.vK]:e.compositionType===r.h.TextureCube?[0,g.rT]:void y.V.warn("initial value is not found")}}},3629:(e,t,n)=>{n.d(t,{F:()=>r});var o=n(975),a=n(5697),i=n(6941);class r{constructor(){this.__min=a.tp.fromCopyArray([Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE]),this.__max=a.tp.fromCopyArray([-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]),this.__centerPoint=a.tp.zero(),this.__lengthCenterToCorner=0,this.__isCenterPointDirty=!1,this.__isLengthCenterToCornerDirty=!1,this.__isVanilla=!0}clone(){const e=new r;return e.__max=this.__max.clone(),e.__min=this.__min.clone(),e.__centerPoint=this.__centerPoint.clone(),e.__lengthCenterToCorner=this.__lengthCenterToCorner,e.__isCenterPointDirty=this.__isCenterPointDirty,e.__isLengthCenterToCornerDirty=this.__isLengthCenterToCornerDirty,e.__isVanilla=this.__isVanilla,e}copyComponents(e){return this.__max.copyComponents(e.__max),this.__min.copyComponents(e.__min),this.__centerPoint.copyComponents(e.__centerPoint),this.__lengthCenterToCorner=e.__lengthCenterToCorner,this.__isCenterPointDirty=e.__isCenterPointDirty,this.__isLengthCenterToCornerDirty=e.__isLengthCenterToCornerDirty,this.__isVanilla=!1,this}initialize(){this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__centerPoint.zero(),this.__lengthCenterToCorner=0,this.__isCenterPointDirty=!1,this.__isLengthCenterToCornerDirty=!1,this.__isVanilla=!0}set minPoint(e){this.__min.copyComponents(e),this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1}get minPoint(){return this.__min}set maxPoint(e){this.__max.copyComponents(e),this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1}get maxPoint(){return this.__max}isVanilla(){return this.__isVanilla}addPosition(e){return this.__min.x=e.x<this.__min.x?e.x:this.__min.x,this.__min.y=e.y<this.__min.y?e.y:this.__min.y,this.__min.z=e.z<this.__min.z?e.z:this.__min.z,this.__max.x=this.__max.x<e.x?e.x:this.__max.x,this.__max.y=this.__max.y<e.y?e.y:this.__max.y,this.__max.z=this.__max.z<e.z?e.z:this.__max.z,this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1,e}addPositionWithArray(e,t){return this.__min.x=e[t+0]<this.__min.x?e[t+0]:this.__min.x,this.__min.y=e[t+1]<this.__min.y?e[t+1]:this.__min.y,this.__min.z=e[t+2]<this.__min.z?e[t+2]:this.__min.z,this.__max.x=this.__max.x<e[t+0]?e[t+0]:this.__max.x,this.__max.y=this.__max.y<e[t+1]?e[t+1]:this.__max.y,this.__max.z=this.__max.z<e[t+2]?e[t+2]:this.__max.z,this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1,e}mergeAABB(e){return!e.isVanilla()&&(this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.isVanilla()?(this.__min.copyComponents(e.minPoint),this.__max.copyComponents(e.maxPoint),this.__isVanilla=!1,!0):(e.minPoint.x<this.__min.x&&(this.__min.x=e.minPoint.x),e.minPoint.y<this.__min.y&&(this.__min.y=e.minPoint.y),e.minPoint.z<this.__min.z&&(this.__min.z=e.minPoint.z),this.__max.x<e.maxPoint.x&&(this.__max.x=e.maxPoint.x),this.__max.y<e.maxPoint.y&&(this.__max.y=e.maxPoint.y),this.__max.z<e.maxPoint.z&&(this.__max.z=e.maxPoint.z),!0))}get centerPoint(){return this.__isCenterPointDirty&&(a.tp.addTo(this.__min,this.__max,this.__centerPoint).divide(2),this.__isCenterPointDirty=!1),this.__centerPoint}get lengthCenterToCorner(){return this.__isLengthCenterToCornerDirty&&(this.__lengthCenterToCorner=o.Pq.lengthBtw(this.centerPoint,this.maxPoint),this.__isLengthCenterToCornerDirty=!1),this.__lengthCenterToCorner}get sizeX(){return this.__max.x-this.__min.x}get sizeY(){return this.__max.y-this.__min.y}get sizeZ(){return this.__max.z-this.__min.z}static multiplyMatrixTo(e,t,n){return t.isVanilla()?n.copyComponents(t):(n.initialize(),r.__tmpVector3.x=t.__min.x,r.__tmpVector3.y=t.__min.y,r.__tmpVector3.z=t.__min.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__max.x,r.__tmpVector3.y=t.__min.y,r.__tmpVector3.z=t.__min.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__min.x,r.__tmpVector3.y=t.__max.y,r.__tmpVector3.z=t.__min.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__min.x,r.__tmpVector3.y=t.__min.y,r.__tmpVector3.z=t.__max.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__min.x,r.__tmpVector3.y=t.__max.y,r.__tmpVector3.z=t.__max.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__max.x,r.__tmpVector3.y=t.__min.y,r.__tmpVector3.z=t.__max.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__max.x,r.__tmpVector3.y=t.__max.y,r.__tmpVector3.z=t.__min.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),r.__tmpVector3.x=t.__max.x,r.__tmpVector3.y=t.__max.y,r.__tmpVector3.z=t.__max.z,e.multiplyVector3To(r.__tmpVector3,r.__tmpVector3),n.addPosition(r.__tmpVector3),n)}toString(){return"AABB_min: "+this.__min+"\nAABB_max: "+this.__max+"\ncenterPoint: "+this.__centerPoint+"\nlengthCenterToCorner: "+this.__lengthCenterToCorner}toStringApproximately(){return"AABB_max: "+this.__max.toStringApproximately()+"\nAABB_min: "+this.__min.toStringApproximately()+"\ncenterPoint: "+this.centerPoint.toStringApproximately()+"\nlengthCenterToCorner: "+i.z.financial(this.lengthCenterToCorner)}}r.__tmpVector3=a.tp.zero()},640:(e,t,n)=>{n.d(t,{y:()=>o});class o{constructor(){this._v=new Float32Array}at(e,t){throw new Error("Method not implemented.")}toString(){throw new Error("Method not implemented.")}toStringApproximately(){throw new Error("Method not implemented.")}flattenAsArray(){throw new Error("Method not implemented.")}isDummy(){return 0===this._v.length}v(e){return this._v[e]}determinant(){throw new Error("Method not implemented.")}get className(){return this.constructor.name}get isIdentityMatrixClass(){return!1}isTheSourceSame(e){return this._v.buffer===e}}},1289:(e,t,n)=>{n.d(t,{x:()=>o});class o{constructor(){this._v=new Float32Array}get className(){return this.constructor.name}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return this._v[3]}at(e){return this._v[e]}length(){return Math.hypot(this._v[0],this._v[1],this._v[2],this._v[3])}lengthSquared(){return this._v[0]**2+this._v[1]**2+this._v[2]**2+this._v[3]**2}toString(){throw new Error("Method not implemented.")}toStringApproximately(){throw new Error("Method not implemented.")}flattenAsArray(){throw new Error("Method not implemented.")}isDummy(){throw new Error("Method not implemented.")}isEqual(e,t){throw new Error("Method not implemented.")}isStrictEqual(e){throw new Error("Method not implemented.")}toEulerAnglesTo(e){throw new Error("Method not implemented.")}toEulerAngles(){throw new Error("Method not implemented.")}transformVector3(e){throw new Error("Method not implemented.")}transformVector3To(e,t){throw new Error("Method not implemented.")}transformVector3Inverse(e){throw new Error("Method not implemented.")}dot(e){return this._v[0]*e._v[0]+this._v[1]*e._v[1]+this._v[2]*e._v[2]+this._v[3]*e._v[3]}clone(){throw new Error("Method not implemented.")}}},8422:(e,t,n)=>{n.d(t,{c:()=>o});class o{constructor(){this._v=new Float32Array}get x(){return this._v[0]}get glslStrAsFloat(){throw new Error("Method not implemented.")}get glslStrAsInt(){throw new Error("Method not implemented.")}isEqual(e,t){throw new Error("Method not implemented.")}isStrictEqual(e){throw new Error("Method not implemented.")}length(){throw new Error("Method not implemented.")}lengthSquared(){throw new Error("Method not implemented.")}lengthTo(e){throw new Error("Method not implemented.")}dot(e){throw new Error("Method not implemented.")}at(e){return this._v[e]}toString(){throw new Error("Method not implemented.")}toStringApproximately(){throw new Error("Method not implemented.")}flattenAsArray(){throw new Error("Method not implemented.")}isDummy(){return 0===this._v.length}v(e){return this._v[e]}isTheSourceSame(e){return this._v.buffer===e}get className(){return this.constructor.name}get bytesPerComponent(){throw new Error("Method not implemented.")}}},1525:(e,t,n)=>{n.d(t,{x:()=>a});var o=n(975);class a extends o.Pq{constructor(e){super(e)}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return 1}get r(){return this._v[0]}get g(){return this._v[1]}get b(){return this._v[2]}get a(){return 1}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}static cross(e,t){return super._cross(e,t,Float32Array)}clone(){return super.clone()}}},6222:(e,t,n)=>{n.d(t,{q:()=>r});var o=n(7751),a=n(640),i=n(975);class r extends a.y{constructor(){super(),this._v=r.__v}toString(){return"1 0 0\n0 1 0\n0 0 1\n"}toStringApproximately(){return this.toString()}flattenAsArray(){return[1,0,0,0,1,0,0,0,1]}isDummy(){return!1}isEqual(e,t=Number.EPSILON){return Math.abs(e.m00-1)<t&&Math.abs(e.m10)<t&&Math.abs(e.m20)<t&&Math.abs(e.m01)<t&&Math.abs(e.m11-1)<t&&Math.abs(e.m21)<t&&Math.abs(e.m02)<t&&Math.abs(e.m12)<t&&Math.abs(e.m22-1)<t}isStrictEqual(e){const t=e._v;return 1===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&0===t[4]&&0===t[5]&&0===t[6]&&0===t[7]&&0===t[8]&&0===t[9]&&0===t[10]&&0===t[11]&&0===t[12]&&0===t[13]&&0===t[14]&&0===t[15]}at(e,t){return e===t?1:0}determinant(){return 1}multiplyVector(e){return e}multiplyVectorTo(e,t){const n=e._v;return t._v[0]=n[0],t._v[1]=n[1],t._v[2]=n[2],t._v[3]=n[3],t}getScale(){return i.Pq.fromCopyArray([1,1,1])}getScaleTo(e){const t=e._v;return t[0]=1,t[1]=1,t[2]=1,e}clone(){return new r}getRotate(){return new r}get m00(){return 1}get m10(){return 0}get m20(){return 0}get m30(){return 0}get m01(){return 0}get m11(){return 1}get m21(){return 0}get m31(){return 0}get m02(){return 0}get m12(){return 0}get m22(){return 1}get m32(){return 0}get m03(){return 0}get m13(){return 0}get m23(){return 0}get m33(){return 1}get className(){return"IdentityMatrix33"}static get compositionType(){return o.h.Mat3}get isIdentityMatrixClass(){return!0}}r.__v=new Float32Array([1,0,0,0,1,0,0,0,1])},4992:(e,t,n)=>{n.d(t,{q:()=>r});var o=n(7751),a=n(640),i=n(975);class r extends a.y{constructor(){super(),this._v=r.__v}toString(){return"1 0 0 0\n0 1 0 0\n0 0 1 0\n0 0 0 1\n"}toStringApproximately(){return this.toString()}flattenAsArray(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}isDummy(){return!1}isEqual(e,t=Number.EPSILON){return Math.abs(e.m00-1)<t&&Math.abs(e.m10)<t&&Math.abs(e.m20)<t&&Math.abs(e.m30)<t&&Math.abs(e.m01)<t&&Math.abs(e.m11-1)<t&&Math.abs(e.m21)<t&&Math.abs(e.m31)<t&&Math.abs(e.m02)<t&&Math.abs(e.m12)<t&&Math.abs(e.m22-1)<t&&Math.abs(e.m32)<t&&Math.abs(e.m03)<t&&Math.abs(e.m13)<t&&Math.abs(e.m23)<t&&Math.abs(e.m33-1)<t}isStrictEqual(e){const t=e._v;return 1===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&0===t[4]&&1===t[5]&&0===t[6]&&0===t[7]&&0===t[8]&&0===t[9]&&1===t[10]&&0===t[11]&&0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]}at(e,t){return e===t?1:0}v(e){return e%5==0?1:0}determinant(){return 1}multiplyVector(e){return e}multiplyVector3(e){return e}multiplyVectorTo(e,t){const n=e._v;return t._v[0]=n[0],t._v[1]=n[1],t._v[2]=n[2],t._v[3]=n[3],t}getScale(){return i.Pq.one()}getScaleTo(e){const t=e._v;return t[0]=1,t[1]=1,t[2]=1,e}clone(){return new r}getRotate(){return new r}getTranslate(){return i.Pq.zero()}get m00(){return 1}get m10(){return 0}get m20(){return 0}get m30(){return 0}get m01(){return 0}get m11(){return 1}get m21(){return 0}get m31(){return 0}get m02(){return 0}get m12(){return 0}get m22(){return 1}get m32(){return 0}get m03(){return 0}get m13(){return 0}get m23(){return 0}get m33(){return 1}get translateX(){return 0}get translateY(){return 0}get translateZ(){return 0}get className(){return"IdentityMatrix44"}static get compositionType(){return o.h.Mat4}get isIdentityMatrixClass(){return!0}}r.__v=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])},8805:(e,t,n)=>{n.d(t,{n:()=>y});var o=n(9936),a=n(975),i=n(3414),r=n(6603),s=n(8068),l=n(3870),c=n(7751),_=n(7476),u=n(2162),f=n(8924),d=n(5697),h=n(5882),m=n(9011),p=n(6253),v=n(1881),x=n(1124),g=n(3497);class y{constructor(){}static arrayToVector(e){return Array.isArray(e)?void 0!==e[3]?i.IU.fromCopyArray([e[0],e[1],e[2],e[3]]):void 0!==e[2]?a.Pq.fromCopyArray([e[0],e[1],e[2]]):o.I9.fromCopyArray2([e[0],e[1]]):e}static arrayToVectorOrMatrix(e){return Array.isArray(e)?void 0!==e[15]?l._.fromCopyArrayRowMajor(e):void 0!==e[8]?s.k.fromCopyArrayRowMajor(e):void 0!==e[3]?i.IU.fromCopyArray([e[0],e[1],e[2],e[3]]):void 0!==e[2]?a.Pq.fromCopyArray([e[0],e[1],e[2]]):o.I9.fromCopyArray2([e[0],e[1]]):e}static getImmutableValueClass(e){return e===c.h.Vec2?o.I9:e===c.h.Vec3?a.Pq:e===c.h.Vec4?i.IU:e===c.h.Mat3?s.k:e===c.h.Mat4?l._:void 0}static getMutableValueClass(e){return e===c.h.Vec2?h.A3:e===c.h.Vec3?d.tp:e===c.h.Vec4?f.Am:e===c.h.Mat3?u._:e===c.h.Mat4?_.g:void 0}static cloneOfMathObjects(e){return e instanceof l._||e instanceof s.k||e instanceof i.IU||e instanceof a.Pq||e instanceof o.I9?e.clone():e}static isAcceptableArrayForQuaternion(e){return!(!Array.isArray(e)||void 0===e[3])}static arrayToQuaternion(e){return r.P.fromCopy4(e[0],e[1],e[2],e[3])}static makeSubArray(e,t){return 4===t?[e[0],e[1],e[2],e[3]]:3===t?[e[0],e[1],e[2]]:2===t?[e[0],e[1]]:e[0]}static vectorToArray(e){return e instanceof o.I9?[e.x,e.y]:e instanceof a.Pq?[e.x,e.y,e.z]:e instanceof i.IU||e instanceof r.P?[e.x,e.y,e.z,e.w]:e}static componentNumberOfVector(e){return e instanceof o.I9?2:e instanceof a.Pq?3:e instanceof i.IU||e instanceof r.P?4:Array.isArray(e)?e.length:0}static packNormalizedVec4ToVec2(e,t,n,o,a){let i=0,r=0;return e=(e+1)/2,t=(t+1)/2,n=(n+1)/2,o=(o+1)/2,i=(Math.floor(e*(a-1))*a+Math.floor(t*(a-1)))/a,r=(Math.floor(n*(a-1))*a+Math.floor(o*(a-1)))/a,[i,r]}static unProjectTo(e,t,n,o,a,i){const r=this.__tmpVector4_0.setComponents((e-a.x)/a.z*2-1,(t-a.y)/a.w*2-1,2*n-1,1),s=o.multiplyVectorTo(r,this.__tmpVector4_1);return 0===s.w&&g.V.error("0 division occurred!"),d.tp.multiplyTo(s,1/s.w,i)}static add(e,t){if(isFinite(e))return e+t;if(e instanceof o.I9)return o.I9.add(e,t);if(e instanceof a.Pq)return a.Pq.add(e,t);if(e instanceof i.IU)return i.IU.add(e,t);if(e instanceof r.P)return r.P.add(e,t);if(Array.isArray(e)){const n=[];for(let o=0;o<e.length;o++)n[o]=e[o]+t[o];return n}g.V.error("Non supported type!")}static subtract(e,t){if(isFinite(e))return e-t;if(e instanceof o.I9)return o.I9.subtract(e,t);if(e instanceof a.Pq)return a.Pq.subtract(e,t);if(e instanceof i.IU)return i.IU.subtract(e,t);if(e instanceof r.P)return r.P.subtract(e,t);if(Array.isArray(e)){const n=[];for(let o=0;o<e.length;o++)n[o]=e[o]-t[o];return n}g.V.error("Non supported type!")}static multiplyNumber(e,t){if(isFinite(e))return e*t;if(e instanceof o.I9)return o.I9.multiply(e,t);if(e instanceof a.Pq)return a.Pq.multiply(e,t);if(e instanceof i.IU)return i.IU.multiply(e,t);if(e instanceof r.P)return r.P.multiplyNumber(e,t);if(Array.isArray(e)){const n=[];for(let o=0;o<e.length;o++)n[o]=e[o]*t;return n}g.V.error("Non supported type!")}static divideNumber(e,t){if(isFinite(e))return e/t;if(e instanceof o.I9)return o.I9.multiply(e,1/t);if(e instanceof a.Pq)return a.Pq.multiply(e,1/t);if(e instanceof i.IU)return i.IU.multiply(e,1/t);if(e instanceof r.P)return r.P.multiplyNumber(e,1/t);if(Array.isArray(e)){const n=[];for(let o=0;o<e.length;o++)n[o]=e[o]/t;return n}g.V.error("Non supported type!")}static initWithScalar(e,t){if(isFinite(e))return t;if(e instanceof o.I9)return o.I9.fromCopyArray2([t,t]);if(e instanceof a.Pq)return a.Pq.fromCopyArray([t,t,t]);if(e instanceof i.IU)return i.IU.fromCopyArray([t,t,t,t]);if(e instanceof r.P)return r.P.fromCopy4(0,0,0,1);if(Array.isArray(e)){const n=[];for(let o=0;o<e.length;o++)n[o]=t;return n}g.V.error("Non supported type!")}static initWithFloat32Array(e,t,n,c){let y;if(isFinite(e)){const e=new Float32Array(n);return n._v=void 0,e[0]=t,new m.X5(e)}if(e instanceof m.X5||e instanceof v.n9)n[0]=t.x,y=new v.n9(n);else if(e instanceof o.I9||e instanceof h.A3)n[0]=t.x,n[1]=t.y,y=new h.A3(n);else if(e instanceof a.Pq||e instanceof d.tp)n[0]=t.x,n[1]=t.y,n[2]=t.z,y=d.tp.fromFloat32Array(n);else if(e instanceof i.IU||e instanceof f.Am)n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w,y=new f.Am(n);else if(e instanceof r.P||e instanceof p.h)n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w,y=new p.h(n);else if(e instanceof s.k||e instanceof u._)y=null==y?new u._(n):y,y.m00=t.m00,y.m01=t.m01,y.m02=t.m02,y.m10=t.m10,y.m11=t.m11,y.m12=t.m12,y.m20=t.m20,y.m21=t.m21,y.m22=t.m22;else if(e instanceof l._||e instanceof _.g)y=new _.g(n),y.m00=t.m00,y.m01=t.m01,y.m02=t.m02,y.m03=t.m03,y.m10=t.m10,y.m11=t.m11,y.m12=t.m12,y.m13=t.m13,y.m20=t.m20,y.m21=t.m21,y.m22=t.m22,y.m23=t.m23,y.m30=t.m30,y.m31=t.m31,y.m32=t.m32,y.m33=t.m33;else{if(!(e instanceof x.u)){if(null==e){let e;switch(n.length){case 4:e=i.IU.fromCopyFloat32Array(n);break;case 3:e=a.Pq.fromCopyFloat32Array(n);break;case 2:e=new o.I9(n);break;case 1:e=new m.X5(n)}return n._v=void 0,e}return Array.isArray(e)||ArrayBuffer.isView(e)||ArrayBuffer.isView(e._v)?e:void g.V.error("Non supported type!")}for(let e=0;e<t._v.length;e++)n[e]=t._v[e];y=new x.u(n)}return n._v=void 0,y}static _setForce(e,t){if(e instanceof f.Am||e instanceof i.IU){if(e.isEqual(t))return!1;e._v[0]=t._v[0],e._v[1]=t._v[1],e._v[2]=t._v[2],e._v[3]=t._v[3]}else if(e instanceof h.A3||e instanceof o.I9){if(e.isEqual(t))return!1;e._v[0]=t._v[0],e._v[1]=t._v[1]}else if(e instanceof d.tp||e instanceof a.Pq){if(e.isEqual(t))return!1;e._v[0]=t._v[0],e._v[1]=t._v[1],e._v[2]=t._v[2]}else if(e instanceof v.n9||e instanceof m.X5)if(void 0===t._v){if(e._v[0]==t)return!1;e._v[0]=t}else{if(e._v[0]==t._v[0])return!1;e._v[0]=t._v[0]}else if(e instanceof u._||e instanceof s.k){if(e.isEqual(t))return!1;e._v[0]=t._v[0],e._v[1]=t._v[1],e._v[2]=t._v[2],e._v[3]=t._v[3],e._v[4]=t._v[4],e._v[5]=t._v[5],e._v[6]=t._v[6],e._v[7]=t._v[7],e._v[8]=t._v[8]}else if(e instanceof _.g||e instanceof l._){if(e.isEqual(t))return!1;e._v[0]=t._v[0],e._v[1]=t._v[1],e._v[2]=t._v[2],e._v[3]=t._v[3],e._v[4]=t._v[4],e._v[5]=t._v[5],e._v[6]=t._v[6],e._v[7]=t._v[7],e._v[8]=t._v[8],e._v[9]=t._v[9],e._v[10]=t._v[10],e._v[11]=t._v[11],e._v[12]=t._v[12],e._v[13]=t._v[13],e._v[14]=t._v[14],e._v[15]=t._v[15]}else if(e instanceof p.h||e instanceof r.P){if(e.isEqual(t))return!1;e._v[0]=t._v[0],e._v[1]=t._v[1],e._v[2]=t._v[2],e._v[3]=t._v[3]}else if(e instanceof x.u){let n;n=t instanceof x.u?t._v:t;let o=!0;for(let t=0;t<n.length;t++)if(e._v[t]!==n[t]){o=!1;break}if(o)return!1;for(let t=0;t<n.length;t++)e._v[t]=n[t]}else if(Array.isArray(e)){let n=!0;for(let o=0;o<e.length;o++)if(e[o]!==t._v[o]){n=!1;break}if(n)return!1;for(let n=0;n<e.length;n++)e[n]=t._v[n]}else if(isNaN(e._v.length))g.V.warn("Unknown type _setForce");else{let n=!0;for(let o=0;o<e._v.length;o++)if(Array.isArray(t)){if(e._v[o]!==t[o]){n=!1;break}}else if(e._v[o]!==t._v[o]){n=!1;break}if(n)return!1;for(let n=0;n<e._v.length;n++)Array.isArray(t)?e._v[n]=t[n]:e._v[n]=t._v[n]}return!0}}y.__tmpVector4_0=f.Am.zero(),y.__tmpVector4_1=f.Am.zero()},6941:(e,t,n)=>{function o(e){return!(e&e-1)}n.d(t,{z:()=>a});const a=Object.freeze({radianToDegree:function(e){return 180*e/Math.PI},degreeToRadian:function(e){return e*Math.PI/180},toHalfFloat:()=>function(e){const t=new Float32Array(1),n=new Int32Array(t.buffer);t[0]=e;const o=n[0];let a=o>>16&32768,i=o>>12&2047;const r=o>>23&255;return r<103?a:r>142?(a|=31744,a|=(255==r?0:1)&&8388607&o,a):r<113?(i|=2048,a|=(i>>114-r)+(i>>113-r&1),a):(a|=r-112<<10|i>>1,a+=1&i,a)},isPowerOfTwo:o,isPowerOfTwoTexture:function(e,t){return o(e)&&o(t)},packNormalizedVec4ToVec2:function(e,t,n,o,a){return e=(e+1)/2,t=(t+1)/2,n=(n+1)/2,o=(o+1)/2,[(Math.floor(e*(a-1))*a+Math.floor(t*(a-1)))/a,(Math.floor(n*(a-1))*a+Math.floor(o*(a-1)))/a]},convertToStringAsGLSLFloat:function(e){return Number.isInteger(e)?`${e}.0`:""+e},nearZeroToZero:function(e){return Math.abs(e)<1e-5?e=0:.99999<e&&e<1.00001?e=1:-1.00001<e&&e<-.99999&&(e=-1),e},gaussianCdf:function(e,t,n){return.5*(1+function(e){let t=1;e<0&&(t=-1);const n=1/(1+.3275911*(e=Math.abs(e)));return t*(1-((((1.061405429*n-1.453152027)*n+1.421413741)*n-.284496736)*n+.254829592)*n*Math.exp(-e*e))}((e-t)/(n*Math.sqrt(2))))},invGaussianCdf:function(e,t,n){return n*Math.sqrt(2)*function(e){let t,n=0;return t=-Math.log((1-e)*(1+e)),t<5?(t-=2.5,n=2.81022636e-8,n=3.43273939e-7+n*t,n=n*t-35233877e-13,n=n*t-439150654e-14,n=.00021858087+n*t,n=n*t-.00125372503,n=n*t-.00417768164,n=.246640727+n*t,n=1.50140941+n*t):(t=Math.sqrt(t)-3,n=-.000200214257,n=.000100950558+n*t,n=.00134934322+n*t,n=n*t-.00367342844,n=.00573950773+n*t,n=n*t-.0076224613,n=.00943887047+n*t,n=1.00167406+n*t,n=2.83297682+n*t),n*e}(2*e-1)+t},computeEigenValuesAndVectors:function(e,t,n){let o=0,a=0,i=0,r=0,s=0,l=0,c=0,_=0,u=0,f=0;for(let e=0;e<3;e++){t.setAt(e,e,1);for(let n=0;n<e;n++)t.setAt(e,n,0),t.setAt(n,e,0)}for(let t=0;t<3;t++)n.setAt(t,e.at(t,t));o=0;for(let e=0;e<3;e++)o+=Math.abs(n.at(e));o*=o;for(let o=0;o<50;o++){a=0;for(let t=0;t<3;t++)for(let n=t+1;n<3;n++)a+=Math.abs(e.at(t,n));if(0==a)return 0;f=o<4?.2*a/9:0;for(let a=0;a<3;a++)for(let d=a+1;d<3;d++)if(l=100*Math.abs(e.at(a,d)),o>4&&Math.abs(n.at(a))+l==Math.abs(n.at(a))&&Math.abs(n.at(d))+l==Math.abs(n.at(d)))e.setAt(a,d,0);else if(Math.abs(e.at(a,d))>f){c=n.at(d)-n.at(a),Math.abs(c)+l==Math.abs(c)?s=e.at(a,d)/c:(u=.5*c/e.at(a,d),s=u<0?-1/(Math.sqrt(1+u*u)-u):1/(Math.sqrt(1+u*u)+u)),r=1/Math.sqrt(1+s*s),i=s*r,_=s*e.at(a,d),e.setAt(a,d,0),n.setAt(a,n.at(a)-_),n.setAt(d,n.at(d)+_);for(let t=0;t<a;t++)s=e.at(t,a),e.setAt(t,a,r*s-i*e.at(t,d)),e.setAt(t,d,i*s+r*e.at(t,d));for(let t=a+1;t<d;t++)s=e.at(a,t),e.setAt(a,t,r*s-i*e.at(t,d)),e.setAt(t,d,i*s+r*e.at(t,d));for(let t=d+1;t<3;t++)s=e.at(a,t),e.setAt(a,t,r*s-i*e.at(d,t)),e.setAt(d,t,i*s+r*e.at(d,t));for(let e=0;e<3;e++)s=t.at(e,a),t.setAt(e,a,r*s-i*t.at(e,d)),t.setAt(e,d,i*s+r*t.at(e,d))}}return-1},computeGaussianDistributionRatioWhoseSumIsOne:function({kernelSize:e,variance:t,mean:n=0,effectiveDigit:o=4}){const a=Math.ceil(e/2),i=new Array(a);let r=0;for(let e=0;e<a;e++)i[e]=Math.exp(-((e-n)**2)/(2*t)),r+=i[e];r*=2,e/2%2!=0&&(r-=i[0]);const s=new Array(e);let l=0;const c=Math.pow(10,o);for(let t=0;t<a-1;t++){let n=i[a-1-t]/r;n*=c,n=Math.round(n),n/=c,s[t]=n,s[e-1-t]=n,l+=2*n}if(e%2==0){const e=(1-l)/2;s[a-1]=e,s[a]=e}else{const e=1-l;s[a-1]=e}return s},roundAsFloat:function(e){return Math.round(1e7*e)/1e7},financial:function(e){const t=Number.parseFloat(e).toFixed(7);return e>=0?" "+t:t},lerp:function(e,t,n){return e*(1-n)+t*n}})},8718:(e,t,n)=>{n.d(t,{q:()=>l});var o=n(7751),a=n(9936),i=n(6941),r=n(640),s=n(3497);class l extends r.y{constructor(e){super(),this._v=e}get m00(){return this._v[0]}get m10(){return this._v[1]}get m01(){return this._v[2]}get m11(){return this._v[3]}get className(){return"Matrix22"}static get compositionType(){return o.h.Mat2}static zero(){return l.fromCopy4RowMajor(0,0,0,0)}static identity(){return l.fromCopy4RowMajor(1,0,0,1)}static dummy(){return new this(new Float32Array(0))}static transpose(e){return l.fromCopy4RowMajor(e._v[0],e._v[1],e._v[2],e._v[3])}static invert(e){const t=e.determinant();0===t&&s.V.error("the determinant is 0!");const n=e._v[3]/t,o=e._v[2]/t*-1,a=e._v[1]/t*-1,i=e._v[0]/t;return l.fromCopy4RowMajor(n,o,a,i)}static invertTo(e,t){const n=e.determinant();0===n&&s.V.error("the determinant is 0!");const o=e._v[3]/n,a=e._v[2]/n*-1,i=e._v[1]/n*-1,r=e._v[0]/n;return t.setComponents(o,a,i,r)}static rotate(e){const t=Math.cos(e),n=Math.sin(e);return l.fromCopy4RowMajor(t,-n,n,t)}static scale(e){return l.fromCopy4RowMajor(e._v[0],0,0,e._v[1])}static multiply(e,t){const n=e._v[0]*t._v[0]+e._v[2]*t._v[1],o=e._v[1]*t._v[0]+e._v[3]*t._v[1],a=e._v[0]*t._v[2]+e._v[2]*t._v[3],i=e._v[1]*t._v[2]+e._v[3]*t._v[3];return l.fromCopy4RowMajor(n,a,o,i)}static multiplyTo(e,t,n){const o=e._v[0]*t._v[0]+e._v[2]*t._v[1],a=e._v[1]*t._v[0]+e._v[3]*t._v[1],i=e._v[0]*t._v[2]+e._v[2]*t._v[3],r=e._v[1]*t._v[2]+e._v[3]*t._v[3];return n.setComponents(o,i,a,r)}toString(){return this._v[0]+" "+this._v[2]+"\n"+this._v[1]+" "+this._v[3]+" \n"}toStringApproximately(){return i.z.financial(this._v[0])+" "+i.z.financial(this._v[2])+"\n"+i.z.financial(this._v[1])+" "+i.z.financial(this._v[3])+" \n"}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){return Math.abs(e._v[0]-this._v[0])<t&&Math.abs(e._v[1]-this._v[1])<t&&Math.abs(e._v[2]-this._v[2])<t&&Math.abs(e._v[3]-this._v[3])<t}isStrictEqual(e){return e._v[0]===this._v[0]&&e._v[1]===this._v[1]&&e._v[2]===this._v[2]&&e._v[3]===this._v[3]}at(e,t){return this._v[e+2*t]}determinant(){return this._v[0]*this._v[3]-this._v[1]*this._v[2]}multiplyVector(e){const t=this._v[0]*e._v[0]+this._v[2]*e._v[1],n=this._v[1]*e._v[0]+this._v[3]*e._v[1];return a.I9.fromCopyArray2([t,n])}multiplyVectorTo(e,t){const n=this._v[0]*e._v[0]+this._v[2]*e._v[1],o=this._v[1]*e._v[0]+this._v[3]*e._v[1];return t._v[0]=n,t._v[1]=o,t}getScale(){return a.I9.fromCopyArray2([Math.hypot(this.m00,this.m01),Math.hypot(this.m10,this.m11)])}getScaleTo(e){return e._v[0]=Math.hypot(this._v[0],this._v[2]),e._v[1]=Math.hypot(this._v[1],this._v[3]),e}clone(){return this.constructor.fromCopy4RowMajor(this._v[0],this._v[2],this._v[1],this._v[3])}static fromCopy4RowMajor(e,t,n,o){const a=new Float32Array(4);return a[0]=e,a[2]=t,a[1]=n,a[3]=o,new l(a)}static fromCopy4ColumnMajor(e,t,n,o){const a=new Float32Array(4);return a[0]=e,a[2]=n,a[1]=t,a[3]=o,new l(a)}static fromFloat32ArrayColumnMajor(e){return new l(e)}static fromCopyFloat32ArrayColumnMajor(e){const t=new Float32Array(4);return t.set(e),new l(t)}static fromCopyFloat32ArrayRowMajor(e){const t=new Float32Array(4);return t[0]=e[0],t[3]=e[1],t[1]=e[2],t[4]=e[3],new l(t)}static fromCopyMatrix22(e){const t=new Float32Array(4);return t[0]=e._v[0],t[3]=e._v[1],t[1]=e._v[2],t[4]=e._v[3],new l(t)}static fromCopyArray9ColumnMajor(e){const t=new Float32Array(4);return t.set(e),new l(t)}static fromCopyArrayColumnMajor(e){const t=new Float32Array(4);return t.set(e),new l(t)}static fromCopyArray9RowMajor(e){const t=new Float32Array(4);return t[0]=e[0],t[3]=e[1],t[1]=e[2],t[4]=e[3],new l(t)}static fromCopyArrayRowMajor(e){const t=new Float32Array(4);return t[0]=e[0],t[3]=e[1],t[1]=e[2],t[4]=e[3],new l(t)}}},8068:(e,t,n)=>{n.d(t,{k:()=>c});var o=n(975),a=n(7751),i=n(6941),r=n(640),s=n(6222),l=n(3497);class c extends r.y{constructor(e){super(),this._v=e}get m00(){return this._v[0]}get m10(){return this._v[1]}get m20(){return this._v[2]}get m01(){return this._v[3]}get m11(){return this._v[4]}get m21(){return this._v[5]}get m02(){return this._v[6]}get m12(){return this._v[7]}get m22(){return this._v[8]}get className(){return"Matrix33"}static get compositionType(){return a.h.Mat3}static zero(){return c.fromCopy9RowMajor(0,0,0,0,0,0,0,0,0)}static identity(){return new s.q}static dummy(){return new this(new Float32Array(0))}static transpose(e){return e.isIdentityMatrixClass?e:c.fromCopy9RowMajor(e._v[0],e._v[1],e._v[2],e._v[3],e._v[4],e._v[5],e._v[6],e._v[7],e._v[8])}static invert(e){if(e.isIdentityMatrixClass)return e;const t=e.determinant();0===t&&l.V.error("the determinant is 0!");const n=(e._v[4]*e._v[8]-e._v[7]*e._v[5])/t,o=(e._v[6]*e._v[5]-e._v[3]*e._v[8])/t,a=(e._v[3]*e._v[7]-e._v[6]*e._v[4])/t,i=(e._v[7]*e._v[2]-e._v[1]*e._v[8])/t,r=(e._v[0]*e._v[8]-e._v[6]*e._v[2])/t,s=(e._v[6]*e._v[1]-e._v[0]*e._v[7])/t,_=(e._v[1]*e._v[5]-e._v[4]*e._v[2])/t,u=(e._v[3]*e._v[2]-e._v[0]*e._v[5])/t,f=(e._v[0]*e._v[4]-e._v[3]*e._v[1])/t;return c.fromCopy9RowMajor(n,o,a,i,r,s,_,u,f)}static invertTo(e,t){if(e.isIdentityMatrixClass)return t.copyComponents(e);const n=e.determinant();0===n&&l.V.error("the determinant is 0!");const o=(e._v[4]*e._v[8]-e._v[7]*e._v[5])/n,a=(e._v[6]*e._v[5]-e._v[3]*e._v[8])/n,i=(e._v[3]*e._v[7]-e._v[6]*e._v[4])/n,r=(e._v[7]*e._v[2]-e._v[1]*e._v[8])/n,s=(e._v[0]*e._v[8]-e._v[6]*e._v[2])/n,c=(e._v[6]*e._v[1]-e._v[0]*e._v[7])/n,_=(e._v[1]*e._v[5]-e._v[4]*e._v[2])/n,u=(e._v[3]*e._v[2]-e._v[0]*e._v[5])/n,f=(e._v[0]*e._v[4]-e._v[3]*e._v[1])/n;return t.setComponents(o,a,i,r,s,c,_,u,f)}static rotateX(e){const t=Math.cos(e),n=Math.sin(e);return c.fromCopy9RowMajor(1,0,0,0,t,-n,0,n,t)}static rotateY(e){const t=Math.cos(e),n=Math.sin(e);return c.fromCopy9RowMajor(t,0,n,0,1,0,-n,0,t)}static rotateZ(e){const t=Math.cos(e),n=Math.sin(e);return c.fromCopy9RowMajor(t,-n,0,n,t,0,0,0,1)}static rotateXYZ(e,t,n){const o=Math.cos(e),a=Math.sin(e),i=Math.cos(t),r=Math.sin(t),s=Math.cos(n),l=Math.sin(n),_=-a,u=-l,f=r*a,d=r*o,h=s*i,m=s*f+u*o,p=s*d+u*_,v=l*i,x=l*f+s*o,g=l*d+s*_,y=-r,b=i*a,I=i*o;return c.fromCopy9RowMajor(h,m,p,v,x,g,y,b,I)}static rotate(e){return this.rotateXYZ(e._v[0],e._v[1],e._v[2])}static scale(e){return c.fromCopy9RowMajor(e._v[0],0,0,0,e._v[1],0,0,0,e._v[2])}static multiply(e,t){if(e.isIdentityMatrixClass)return t;if(t.isIdentityMatrixClass)return e;const n=e._v[0]*t._v[0]+e._v[3]*t._v[1]+e._v[6]*t._v[2],o=e._v[1]*t._v[0]+e._v[4]*t._v[1]+e._v[7]*t._v[2],a=e._v[2]*t._v[0]+e._v[5]*t._v[1]+e._v[8]*t._v[2],i=e._v[0]*t._v[3]+e._v[3]*t._v[4]+e._v[6]*t._v[5],r=e._v[1]*t._v[3]+e._v[4]*t._v[4]+e._v[7]*t._v[5],s=e._v[2]*t._v[3]+e._v[5]*t._v[4]+e._v[8]*t._v[5],l=e._v[0]*t._v[6]+e._v[3]*t._v[7]+e._v[6]*t._v[8],_=e._v[1]*t._v[6]+e._v[4]*t._v[7]+e._v[7]*t._v[8],u=e._v[2]*t._v[6]+e._v[5]*t._v[7]+e._v[8]*t._v[8];return c.fromCopy9RowMajor(n,i,l,o,r,_,a,s,u)}static multiplyTo(e,t,n){if(e.isIdentityMatrixClass)return n.copyComponents(t);if(t.isIdentityMatrixClass)return n.copyComponents(e);const o=e._v[0]*t._v[0]+e._v[3]*t._v[1]+e._v[6]*t._v[2],a=e._v[1]*t._v[0]+e._v[4]*t._v[1]+e._v[7]*t._v[2],i=e._v[2]*t._v[0]+e._v[5]*t._v[1]+e._v[8]*t._v[2],r=e._v[0]*t._v[3]+e._v[3]*t._v[4]+e._v[6]*t._v[5],s=e._v[1]*t._v[3]+e._v[4]*t._v[4]+e._v[7]*t._v[5],l=e._v[2]*t._v[3]+e._v[5]*t._v[4]+e._v[8]*t._v[5],c=e._v[0]*t._v[6]+e._v[3]*t._v[7]+e._v[6]*t._v[8],_=e._v[1]*t._v[6]+e._v[4]*t._v[7]+e._v[7]*t._v[8],u=e._v[2]*t._v[6]+e._v[5]*t._v[7]+e._v[8]*t._v[8];return n.setComponents(o,r,c,a,s,_,i,l,u)}toString(){return this._v[0]+" "+this._v[3]+" "+this._v[6]+"\n"+this._v[1]+" "+this._v[4]+" "+this._v[7]+"\n"+this._v[2]+" "+this._v[5]+" "+this._v[8]+"\n"}toStringApproximately(){return i.z.financial(this._v[0])+" "+i.z.financial(this._v[3])+" "+i.z.financial(this._v[6])+"\n"+i.z.financial(this._v[1])+" "+i.z.financial(this._v[4])+" "+i.z.financial(this._v[7])+" \n"+i.z.financial(this._v[2])+" "+i.z.financial(this._v[5])+" "+i.z.financial(this._v[8])+"\n"}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3],this._v[4],this._v[5],this._v[6],this._v[7],this._v[8]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){return Math.abs(e._v[0]-this._v[0])<t&&Math.abs(e._v[1]-this._v[1])<t&&Math.abs(e._v[2]-this._v[2])<t&&Math.abs(e._v[3]-this._v[3])<t&&Math.abs(e._v[4]-this._v[4])<t&&Math.abs(e._v[5]-this._v[5])<t&&Math.abs(e._v[6]-this._v[6])<t&&Math.abs(e._v[7]-this._v[7])<t&&Math.abs(e._v[8]-this._v[8])<t}isStrictEqual(e){return e._v[0]===this._v[0]&&e._v[1]===this._v[1]&&e._v[2]===this._v[2]&&e._v[3]===this._v[3]&&e._v[4]===this._v[4]&&e._v[5]===this._v[5]&&e._v[6]===this._v[6]&&e._v[7]===this._v[7]&&e._v[8]===this._v[8]}at(e,t){return this._v[e+3*t]}v(e){return this._v[e]}determinant(){return this._v[0]*this._v[4]*this._v[8]+this._v[1]*this._v[5]*this._v[6]+this._v[2]*this._v[3]*this._v[7]-this._v[0]*this._v[5]*this._v[7]-this._v[2]*this._v[4]*this._v[6]-this._v[1]*this._v[3]*this._v[8]}multiplyVector(e){const t=this._v[0]*e._v[0]+this._v[3]*e._v[1]+this._v[6]*e._v[2],n=this._v[1]*e._v[0]+this._v[4]*e._v[1]+this._v[7]*e._v[2],o=this._v[2]*e._v[0]+this._v[5]*e._v[1]+this._v[8]*e._v[2];return new e.constructor(new Float32Array([t,n,o]))}multiplyVectorTo(e,t){const n=this._v[0]*e._v[0]+this._v[3]*e._v[1]+this._v[6]*e._v[2],o=this._v[1]*e._v[0]+this._v[4]*e._v[1]+this._v[7]*e._v[2],a=this._v[2]*e._v[0]+this._v[5]*e._v[1]+this._v[8]*e._v[2];return t._v[0]=n,t._v[1]=o,t._v[2]=a,t}getScale(){return o.Pq.fromCopyArray([Math.hypot(this._v[0],this._v[1],this._v[2]),Math.hypot(this._v[3],this._v[4],this._v[5]),Math.hypot(this._v[6],this._v[7],this._v[8])])}getScaleTo(e){return e._v[0]=Math.hypot(this._v[0],this._v[1],this._v[2]),e._v[1]=Math.hypot(this._v[3],this._v[4],this._v[5]),e._v[2]=Math.hypot(this._v[6],this._v[7],this._v[8]),e}clone(){return this.constructor.fromCopy9RowMajor(this._v[0],this._v[3],this._v[6],this._v[1],this._v[4],this._v[7],this._v[2],this._v[5],this._v[8])}static fromCopy9RowMajor(e,t,n,o,a,i,r,s,l){const _=new Float32Array(9);return _[0]=e,_[3]=t,_[6]=n,_[1]=o,_[4]=a,_[7]=i,_[2]=r,_[5]=s,_[8]=l,new c(_)}static fromCopy9ColumnMajor(e,t,n,o,a,i,r,s,l){const _=new Float32Array(9);return _[0]=e,_[3]=o,_[6]=r,_[1]=t,_[4]=a,_[7]=s,_[2]=n,_[5]=i,_[8]=l,new c(_)}static fromCopyMatrix44(e){const t=new Float32Array(9);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],t[3]=e._v[5],t[4]=e._v[6],t[5]=e._v[7],t[6]=e._v[9],t[7]=e._v[10],t[8]=e._v[11],new c(t)}static fromFloat32ArrayColumnMajor(e){return new c(e)}static fromCopyFloat32ArrayColumnMajor(e){const t=new Float32Array(9);return t.set(e),new c(t)}static fromCopyFloat32ArrayRowMajor(e){const t=new Float32Array(9);return t[0]=e[0],t[3]=e[1],t[6]=e[2],t[1]=e[3],t[4]=e[4],t[7]=e[5],t[2]=e[6],t[5]=e[7],t[8]=e[8],new c(t)}static fromCopyMatrix33(e){const t=new Float32Array(9);return t[0]=e._v[0],t[3]=e._v[3],t[6]=e._v[6],t[1]=e._v[1],t[4]=e._v[4],t[7]=e._v[7],t[2]=e._v[2],t[5]=e._v[5],t[8]=e._v[8],new c(t)}static fromCopyArray9ColumnMajor(e){const t=new Float32Array(9);return t.set(e),new c(t)}static fromCopyArrayColumnMajor(e){const t=new Float32Array(9);return t.set(e),new c(t)}static fromCopyArray9RowMajor(e){const t=new Float32Array(9);return t[0]=e[0],t[3]=e[1],t[6]=e[2],t[1]=e[3],t[4]=e[4],t[7]=e[5],t[2]=e[6],t[5]=e[7],t[8]=e[8],new c(t)}static fromCopyArrayRowMajor(e){const t=new Float32Array(9);return t[0]=e[0],t[3]=e[1],t[6]=e[2],t[1]=e[3],t[4]=e[4],t[7]=e[5],t[2]=e[6],t[5]=e[7],t[8]=e[8],new c(t)}static fromCopyQuaternion(e){const t=e._v[0]*e._v[0],n=e._v[1]*e._v[1],o=e._v[2]*e._v[2],a=e._v[1]*e._v[2],i=e._v[0]*e._v[2],r=e._v[0]*e._v[1],s=e._v[3]*e._v[0],l=e._v[3]*e._v[1],_=e._v[3]*e._v[2],u=new Float32Array(9);return u[0]=1-2*(n+o),u[3]=2*(r-_),u[6]=2*(i+l),u[1]=2*(r+_),u[4]=1-2*(t+o),u[7]=2*(a-s),u[2]=2*(i-l),u[5]=2*(a+s),u[8]=1-2*(t+n),new c(u)}}},3870:(e,t,n)=>{n.d(t,{_:()=>u});var o=n(975),a=n(3414),i=n(7751),r=n(6941),s=n(4992),l=n(640),c=n(8454),_=n(3497);class u extends l.y{constructor(e){super(),this._v=e}get m00(){return this._v[0]}get m10(){return this._v[1]}get m20(){return this._v[2]}get m30(){return this._v[3]}get m01(){return this._v[4]}get m11(){return this._v[5]}get m21(){return this._v[6]}get m31(){return this._v[7]}get m02(){return this._v[8]}get m12(){return this._v[9]}get m22(){return this._v[10]}get m32(){return this._v[11]}get m03(){return this._v[12]}get m13(){return this._v[13]}get m23(){return this._v[14]}get m33(){return this._v[15]}get translateX(){return this._v[12]}get translateY(){return this._v[13]}get translateZ(){return this._v[14]}static get compositionType(){return i.h.Mat4}static zero(){return u.fromCopy16RowMajor(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}static identity(){return new s.q}static dummy(){return new this(new Float32Array(0))}static transpose(e){return e.isIdentityMatrixClass?e:u.fromCopyFloat32ArrayRowMajor(e._v)}static invert(e){if(e.isIdentityMatrixClass)return e;const t=e._v[0]*e._v[5]-e._v[4]*e._v[1],n=e._v[0]*e._v[9]-e._v[8]*e._v[1],o=e._v[0]*e._v[13]-e._v[12]*e._v[1],a=e._v[4]*e._v[9]-e._v[8]*e._v[5],i=e._v[4]*e._v[13]-e._v[12]*e._v[5],r=e._v[8]*e._v[13]-e._v[12]*e._v[9],s=e._v[2]*e._v[7]-e._v[6]*e._v[3],l=e._v[2]*e._v[11]-e._v[10]*e._v[3],c=e._v[2]*e._v[15]-e._v[14]*e._v[3],f=e._v[6]*e._v[11]-e._v[10]*e._v[7],d=e._v[6]*e._v[15]-e._v[14]*e._v[7],h=e._v[10]*e._v[15]-e._v[14]*e._v[11],m=t*h-n*d+o*f+a*c-i*l+r*s;0===m&&_.V.error("the determinant is 0!");const p=1/m,v=(e._v[5]*h-e._v[9]*d+e._v[13]*f)*p,x=(e._v[8]*d-e._v[4]*h-e._v[12]*f)*p,g=(e._v[7]*r-e._v[11]*i+e._v[15]*a)*p,y=(e._v[10]*i-e._v[6]*r-e._v[14]*a)*p,b=(e._v[9]*c-e._v[1]*h-e._v[13]*l)*p,I=(e._v[0]*h-e._v[8]*c+e._v[12]*l)*p,A=(e._v[11]*o-e._v[3]*r-e._v[15]*n)*p,E=(e._v[2]*r-e._v[10]*o+e._v[14]*n)*p,S=(e._v[1]*d-e._v[5]*c+e._v[13]*s)*p,T=(e._v[4]*c-e._v[0]*d-e._v[12]*s)*p,w=(e._v[3]*i-e._v[7]*o+e._v[15]*t)*p,C=(e._v[6]*o-e._v[2]*i-e._v[14]*t)*p,R=(e._v[5]*l-e._v[1]*f-e._v[9]*s)*p,P=(e._v[0]*f-e._v[4]*l+e._v[8]*s)*p,N=(e._v[7]*n-e._v[3]*a-e._v[11]*t)*p,M=(e._v[2]*a-e._v[6]*n+e._v[10]*t)*p;return u.fromCopy16RowMajor(v,x,g,y,b,I,A,E,S,T,w,C,R,P,N,M)}static invertTo(e,t){if(e.isIdentityMatrixClass)return t.copyComponents(e);const n=e._v[0]*e._v[5]-e._v[4]*e._v[1],o=e._v[0]*e._v[9]-e._v[8]*e._v[1],a=e._v[0]*e._v[13]-e._v[12]*e._v[1],i=e._v[4]*e._v[9]-e._v[8]*e._v[5],r=e._v[4]*e._v[13]-e._v[12]*e._v[5],s=e._v[8]*e._v[13]-e._v[12]*e._v[9],l=e._v[2]*e._v[7]-e._v[6]*e._v[3],c=e._v[2]*e._v[11]-e._v[10]*e._v[3],u=e._v[2]*e._v[15]-e._v[14]*e._v[3],f=e._v[6]*e._v[11]-e._v[10]*e._v[7],d=e._v[6]*e._v[15]-e._v[14]*e._v[7],h=e._v[10]*e._v[15]-e._v[14]*e._v[11],m=n*h-o*d+a*f+i*u-r*c+s*l;0===m&&_.V.error("the determinant is 0!");const p=1/m,v=(e._v[5]*h-e._v[9]*d+e._v[13]*f)*p,x=(e._v[8]*d-e._v[4]*h-e._v[12]*f)*p,g=(e._v[7]*s-e._v[11]*r+e._v[15]*i)*p,y=(e._v[10]*r-e._v[6]*s-e._v[14]*i)*p,b=(e._v[9]*u-e._v[1]*h-e._v[13]*c)*p,I=(e._v[0]*h-e._v[8]*u+e._v[12]*c)*p,A=(e._v[11]*a-e._v[3]*s-e._v[15]*o)*p,E=(e._v[2]*s-e._v[10]*a+e._v[14]*o)*p,S=(e._v[1]*d-e._v[5]*u+e._v[13]*l)*p,T=(e._v[4]*u-e._v[0]*d-e._v[12]*l)*p,w=(e._v[3]*r-e._v[7]*a+e._v[15]*n)*p,C=(e._v[6]*a-e._v[2]*r-e._v[14]*n)*p,R=(e._v[5]*c-e._v[1]*f-e._v[9]*l)*p,P=(e._v[0]*f-e._v[4]*c+e._v[8]*l)*p,N=(e._v[7]*o-e._v[3]*i-e._v[11]*n)*p,M=(e._v[2]*i-e._v[6]*o+e._v[10]*n)*p;return t.setComponents(v,x,g,y,b,I,A,E,S,T,w,C,R,P,N,M)}static translate(e){return u.fromCopy16RowMajor(1,0,0,e._v[0],0,1,0,e._v[1],0,0,1,e._v[2],0,0,0,1)}static rotateX(e){const t=Math.cos(e),n=Math.sin(e);return u.fromCopy16RowMajor(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1)}static rotateY(e){const t=Math.cos(e),n=Math.sin(e);return u.fromCopy16RowMajor(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1)}static rotateZ(e){const t=Math.cos(e),n=Math.sin(e);return u.fromCopy16RowMajor(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1)}static rotateXYZ(e,t,n){const o=Math.cos(e),a=Math.sin(e),i=Math.cos(t),r=Math.sin(t),s=Math.cos(n),l=Math.sin(n),c=-a,_=-l,f=r*a,d=r*o,h=s*i,m=s*f+_*o,p=s*d+_*c,v=l*i,x=l*f+s*o,g=l*d+s*c,y=-r,b=i*a,I=i*o;return u.fromCopy16RowMajor(h,m,p,0,v,x,g,0,y,b,I,0,0,0,0,1)}static rotate(e){return this.rotateXYZ(e._v[0],e._v[1],e._v[2])}static scale(e){return u.fromCopy16RowMajor(e._v[0],0,0,0,0,e._v[1],0,0,0,0,e._v[2],0,0,0,0,1)}static multiply(e,t){if(e.isIdentityMatrixClass)return t;if(t.isIdentityMatrixClass)return e;const n=e._v,o=t._v,a=n[0]*o[0]+n[4]*o[1]+n[8]*o[2]+n[12]*o[3],i=n[1]*o[0]+n[5]*o[1]+n[9]*o[2]+n[13]*o[3],r=n[2]*o[0]+n[6]*o[1]+n[10]*o[2]+n[14]*o[3],s=n[3]*o[0]+n[7]*o[1]+n[11]*o[2]+n[15]*o[3],l=n[0]*o[4]+n[4]*o[5]+n[8]*o[6]+n[12]*o[7],c=n[1]*o[4]+n[5]*o[5]+n[9]*o[6]+n[13]*o[7],_=n[2]*o[4]+n[6]*o[5]+n[10]*o[6]+n[14]*o[7],f=n[3]*o[4]+n[7]*o[5]+n[11]*o[6]+n[15]*o[7],d=n[0]*o[8]+n[4]*o[9]+n[8]*o[10]+n[12]*o[11],h=n[1]*o[8]+n[5]*o[9]+n[9]*o[10]+n[13]*o[11],m=n[2]*o[8]+n[6]*o[9]+n[10]*o[10]+n[14]*o[11],p=n[3]*o[8]+n[7]*o[9]+n[11]*o[10]+n[15]*o[11],v=n[0]*o[12]+n[4]*o[13]+n[8]*o[14]+n[12]*o[15],x=n[1]*o[12]+n[5]*o[13]+n[9]*o[14]+n[13]*o[15],g=n[2]*o[12]+n[6]*o[13]+n[10]*o[14]+n[14]*o[15],y=n[3]*o[12]+n[7]*o[13]+n[11]*o[14]+n[15]*o[15];return u.fromCopy16RowMajor(a,l,d,v,i,c,h,x,r,_,m,g,s,f,p,y)}static multiplyTo(e,t,n){if(e.isIdentityMatrixClass)return n.copyComponents(t);if(t.isIdentityMatrixClass)return n.copyComponents(e);const o=e._v,a=t._v,i=o[0]*a[0]+o[4]*a[1]+o[8]*a[2]+o[12]*a[3],r=o[1]*a[0]+o[5]*a[1]+o[9]*a[2]+o[13]*a[3],s=o[2]*a[0]+o[6]*a[1]+o[10]*a[2]+o[14]*a[3],l=o[3]*a[0]+o[7]*a[1]+o[11]*a[2]+o[15]*a[3],c=o[0]*a[4]+o[4]*a[5]+o[8]*a[6]+o[12]*a[7],_=o[1]*a[4]+o[5]*a[5]+o[9]*a[6]+o[13]*a[7],u=o[2]*a[4]+o[6]*a[5]+o[10]*a[6]+o[14]*a[7],f=o[3]*a[4]+o[7]*a[5]+o[11]*a[6]+o[15]*a[7],d=o[0]*a[8]+o[4]*a[9]+o[8]*a[10]+o[12]*a[11],h=o[1]*a[8]+o[5]*a[9]+o[9]*a[10]+o[13]*a[11],m=o[2]*a[8]+o[6]*a[9]+o[10]*a[10]+o[14]*a[11],p=o[3]*a[8]+o[7]*a[9]+o[11]*a[10]+o[15]*a[11],v=o[0]*a[12]+o[4]*a[13]+o[8]*a[14]+o[12]*a[15],x=o[1]*a[12]+o[5]*a[13]+o[9]*a[14]+o[13]*a[15],g=o[2]*a[12]+o[6]*a[13]+o[10]*a[14]+o[14]*a[15],y=o[3]*a[12]+o[7]*a[13]+o[11]*a[14]+o[15]*a[15];return n.setComponents(i,c,d,v,r,_,h,x,s,u,m,g,l,f,p,y)}static multiplyTypedArrayTo(e,t,n,o){return t[c.cS](o,e._v,0,n._v),n}static fromQuaternionTo(e,t){const n=e._v[0]*e._v[0],o=e._v[1]*e._v[1],a=e._v[2]*e._v[2],i=e._v[1]*e._v[2],r=e._v[0]*e._v[2],s=e._v[0]*e._v[1],l=e._v[3]*e._v[0],c=e._v[3]*e._v[1],_=e._v[3]*e._v[2],u=1-2*(o+a),f=2*(s-_),d=2*(r+c),h=2*(s+_),m=1-2*(n+a),p=2*(i-l),v=2*(r-c),x=2*(i+l),g=1-2*(n+o);return t.setComponents(u,f,d,0,h,m,p,0,v,x,g,0,0,0,0,1)}toString(){return this._v[0]+" "+this._v[4]+" "+this._v[8]+" "+this._v[12]+" \n"+this._v[1]+" "+this._v[5]+" "+this._v[9]+" "+this._v[13]+" \n"+this._v[2]+" "+this._v[6]+" "+this._v[10]+" "+this._v[14]+" \n"+this._v[3]+" "+this._v[7]+" "+this._v[11]+" "+this._v[15]+" \n"}toStringApproximately(){return r.z.financial(this._v[0])+" "+r.z.financial(this._v[4])+" "+r.z.financial(this._v[8])+" "+r.z.financial(this._v[12])+" \n"+r.z.financial(this._v[1])+" "+r.z.financial(this._v[5])+" "+r.z.financial(this._v[9])+" "+r.z.financial(this._v[13])+" \n"+r.z.financial(this._v[2])+" "+r.z.financial(this._v[6])+" "+r.z.financial(this._v[10])+" "+r.z.financial(this._v[14])+" \n"+r.z.financial(this._v[3])+" "+r.z.financial(this._v[7])+" "+r.z.financial(this._v[11])+" "+r.z.financial(this._v[15])+" \n"}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3],this._v[4],this._v[5],this._v[6],this._v[7],this._v[8],this._v[9],this._v[10],this._v[11],this._v[12],this._v[13],this._v[14],this._v[15]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){const n=e._v;return Math.abs(n[0]-this._v[0])<t&&Math.abs(n[1]-this._v[1])<t&&Math.abs(n[2]-this._v[2])<t&&Math.abs(n[3]-this._v[3])<t&&Math.abs(n[4]-this._v[4])<t&&Math.abs(n[5]-this._v[5])<t&&Math.abs(n[6]-this._v[6])<t&&Math.abs(n[7]-this._v[7])<t&&Math.abs(n[8]-this._v[8])<t&&Math.abs(n[9]-this._v[9])<t&&Math.abs(n[10]-this._v[10])<t&&Math.abs(n[11]-this._v[11])<t&&Math.abs(n[12]-this._v[12])<t&&Math.abs(n[13]-this._v[13])<t&&Math.abs(n[14]-this._v[14])<t&&Math.abs(n[15]-this._v[15])<t}isStrictEqual(e){return e._v[0]===this._v[0]&&e._v[1]===this._v[1]&&e._v[2]===this._v[2]&&e._v[3]===this._v[3]&&e._v[4]===this._v[4]&&e._v[5]===this._v[5]&&e._v[6]===this._v[6]&&e._v[7]===this._v[7]&&e._v[8]===this._v[8]&&e._v[9]===this._v[9]&&e._v[10]===this._v[10]&&e._v[11]===this._v[11]&&e._v[12]===this._v[12]&&e._v[13]===this._v[13]&&e._v[14]===this._v[14]&&e._v[15]===this._v[15]}at(e,t){return this._v[e+4*t]}determinant(){return this._v[0]*this._v[5]*this._v[10]*this._v[15]+this._v[0]*this._v[9]*this._v[14]*this._v[7]+this._v[0]*this._v[13]*this._v[6]*this._v[11]+this._v[4]*this._v[1]*this._v[14]*this._v[11]+this._v[4]*this._v[9]*this._v[2]*this._v[15]+this._v[4]*this._v[13]*this._v[10]*this._v[3]+this._v[8]*this._v[1]*this._v[6]*this._v[15]+this._v[8]*this._v[5]*this._v[14]*this._v[3]+this._v[8]*this._v[13]*this._v[2]*this._v[7]+this._v[12]*this._v[1]*this._v[10]*this._v[7]+this._v[12]*this._v[5]*this._v[2]*this._v[11]+this._v[12]*this._v[9]*this._v[6]*this._v[3]-this._v[0]*this._v[5]*this._v[14]*this._v[11]-this._v[0]*this._v[9]*this._v[6]*this._v[15]-this._v[0]*this._v[13]*this._v[10]*this._v[7]-this._v[4]*this._v[1]*this._v[10]*this._v[15]-this._v[4]*this._v[9]*this._v[14]*this._v[3]-this._v[4]*this._v[13]*this._v[2]*this._v[11]-this._v[8]*this._v[1]*this._v[14]*this._v[7]-this._v[8]*this._v[5]*this._v[2]*this._v[15]-this._v[8]*this._v[13]*this._v[6]*this._v[3]-this._v[12]*this._v[1]*this._v[6]*this._v[11]-this._v[12]*this._v[5]*this._v[10]*this._v[3]-this._v[12]*this._v[9]*this._v[2]*this._v[7]}multiplyVector(e){const t=this._v[0]*e._v[0]+this._v[4]*e._v[1]+this._v[8]*e._v[2]+this._v[12]*e._v[3],n=this._v[1]*e._v[0]+this._v[5]*e._v[1]+this._v[9]*e._v[2]+this._v[13]*e._v[3],o=this._v[2]*e._v[0]+this._v[6]*e._v[1]+this._v[10]*e._v[2]+this._v[14]*e._v[3],i=this._v[3]*e._v[0]+this._v[7]*e._v[1]+this._v[11]*e._v[2]+this._v[15]*e._v[3];return a.IU.fromCopyArray([t,n,o,i])}multiplyVectorTo(e,t){const n=this._v[0]*e._v[0]+this._v[4]*e._v[1]+this._v[8]*e._v[2]+this._v[12]*e._v[3],o=this._v[1]*e._v[0]+this._v[5]*e._v[1]+this._v[9]*e._v[2]+this._v[13]*e._v[3],a=this._v[2]*e._v[0]+this._v[6]*e._v[1]+this._v[10]*e._v[2]+this._v[14]*e._v[3],i=this._v[3]*e._v[0]+this._v[7]*e._v[1]+this._v[11]*e._v[2]+this._v[15]*e._v[3];return t._v[0]=n,t._v[1]=o,t._v[2]=a,t._v[3]=i,t}multiplyVectorToVec3(e,t){const n=this._v[0]*e._v[0]+this._v[4]*e._v[1]+this._v[8]*e._v[2]+this._v[12]*e._v[3],o=this._v[1]*e._v[0]+this._v[5]*e._v[1]+this._v[9]*e._v[2]+this._v[13]*e._v[3],a=this._v[2]*e._v[0]+this._v[6]*e._v[1]+this._v[10]*e._v[2]+this._v[14]*e._v[3];return t._v[0]=n,t._v[1]=o,t._v[2]=a,t}multiplyVector3(e){const t=this._v[0]*e._v[0]+this._v[4]*e._v[1]+this._v[8]*e._v[2]+this._v[12],n=this._v[1]*e._v[0]+this._v[5]*e._v[1]+this._v[9]*e._v[2]+this._v[13],a=this._v[2]*e._v[0]+this._v[6]*e._v[1]+this._v[10]*e._v[2]+this._v[14];return o.Pq.fromCopyArray([t,n,a])}multiplyVector3To(e,t){const n=this._v[0]*e._v[0]+this._v[4]*e._v[1]+this._v[8]*e._v[2]+this._v[12],o=this._v[1]*e._v[0]+this._v[5]*e._v[1]+this._v[9]*e._v[2]+this._v[13],a=this._v[2]*e._v[0]+this._v[6]*e._v[1]+this._v[10]*e._v[2]+this._v[14];return t._v[0]=n,t._v[1]=o,t._v[2]=a,t}getTranslate(){return o.Pq.fromCopyArray([this._v[12],this._v[13],this._v[14]])}getTranslateTo(e){return e._v[0]=this._v[12],e._v[1]=this._v[13],e._v[2]=this._v[14],e}getScale(){return o.Pq.fromCopyArray([Math.hypot(this._v[0],this._v[1],this._v[2]),Math.hypot(this._v[4],this._v[5],this._v[6]),Math.hypot(this._v[8],this._v[9],this._v[10])])}getScaleTo(e){return e._v[0]=Math.hypot(this._v[0],this._v[1],this._v[2]),e._v[1]=Math.hypot(this._v[4],this._v[5],this._v[6]),e._v[2]=Math.hypot(this._v[8],this._v[9],this._v[10]),e}toEulerAngles(){let e;if(1!==Math.abs(this._v[2])){const t=-Math.asin(this._v[2]),n=Math.atan2(this._v[6]/Math.cos(t),this._v[10]/Math.cos(t)),a=Math.atan2(this._v[1]/Math.cos(t),this._v[0]/Math.cos(t));e=o.Pq.fromCopyArray([n,t,a])}else e=-1===this._v[2]?o.Pq.fromCopyArray([Math.atan2(this._v[4],this._v[8]),Math.PI/2,0]):o.Pq.fromCopyArray([Math.atan2(-this._v[4],-this._v[8]),-Math.PI/2,0]);return e}toEulerAnglesTo(e){if(1!==Math.abs(this._v[2])){const t=-Math.asin(this._v[2]),n=Math.atan2(this._v[6]/Math.cos(t),this._v[10]/Math.cos(t)),o=Math.atan2(this._v[1]/Math.cos(t),this._v[0]/Math.cos(t));e._v[0]=n,e._v[1]=t,e._v[2]=o}else-1===this._v[2]?(e._v[0]=Math.atan2(this._v[4],this._v[8]),e._v[1]=Math.PI/2,e._v[2]=0):(e._v[0]=Math.atan2(-this._v[4],-this._v[8]),e._v[1]=-Math.PI/2,e._v[2]=0);return e}clone(){return this.constructor.fromCopy16RowMajor(this._v[0],this._v[4],this._v[8],this._v[12],this._v[1],this._v[5],this._v[9],this._v[13],this._v[2],this._v[6],this._v[10],this._v[14],this._v[3],this._v[7],this._v[11],this._v[15])}getRotate(){const e=Math.hypot(this._v[0],this._v[1],this._v[2]),t=Math.hypot(this._v[4],this._v[5],this._v[6]),n=Math.hypot(this._v[8],this._v[9],this._v[10]);return u.fromCopy16RowMajor(this._v[0]/e,this._v[4],this._v[8],0,this._v[1],this._v[5]/t,this._v[9],0,this._v[2],this._v[6],this._v[10]/n,0,0,0,0,1)}static fromCopy16RowMajor(e,t,n,o,a,i,r,s,l,c,_,f,d,h,m,p){const v=new Float32Array(16);return v[0]=e,v[4]=t,v[8]=n,v[12]=o,v[1]=a,v[5]=i,v[9]=r,v[13]=s,v[2]=l,v[6]=c,v[10]=_,v[14]=f,v[3]=d,v[7]=h,v[11]=m,v[15]=p,new u(v)}static fromCopy16ColumnMajor(e,t,n,o,a,i,r,s,l,c,_,f,d,h,m,p){const v=new Float32Array(16);return v[0]=e,v[4]=a,v[8]=l,v[12]=d,v[1]=t,v[5]=i,v[9]=c,v[13]=h,v[2]=n,v[6]=r,v[10]=_,v[14]=m,v[3]=o,v[7]=s,v[11]=f,v[15]=p,new u(v)}static fromCopyMatrix44(e){const t=new Float32Array(16);return t.set(e._v),new u(t)}static fromFloat32ArrayColumnMajor(e){return new u(e)}static fromCopyFloat32ArrayColumnMajor(e){const t=new Float32Array(16);return t.set(e),new u(t)}static fromCopyFloat32ArrayRowMajor(e){const t=new Float32Array(16);return t[0]=e[0],t[4]=e[1],t[8]=e[2],t[12]=e[3],t[1]=e[4],t[5]=e[5],t[9]=e[6],t[13]=e[7],t[2]=e[8],t[6]=e[9],t[10]=e[10],t[14]=e[11],t[3]=e[12],t[7]=e[13],t[11]=e[14],t[15]=e[15],new u(t)}static fromCopyMatrix33(e){const t=new Float32Array(16);return t[0]=e._v[0],t[4]=e._v[3],t[8]=e._v[6],t[12]=0,t[1]=e._v[1],t[5]=e._v[4],t[9]=e._v[7],t[13]=0,t[2]=e._v[2],t[6]=e._v[5],t[10]=e._v[8],t[14]=0,t[3]=0,t[7]=0,t[11]=0,t[15]=1,new u(t)}static fromCopyArray16ColumnMajor(e){const t=new Float32Array(16);return t.set(e),new u(t)}static fromCopyArrayColumnMajor(e){const t=new Float32Array(16);return t.set(e),new u(t)}static fromCopyArray16RowMajor(e){const t=new Float32Array(16);return t[0]=e[0],t[4]=e[1],t[8]=e[2],t[12]=e[3],t[1]=e[4],t[5]=e[5],t[9]=e[6],t[13]=e[7],t[2]=e[8],t[6]=e[9],t[10]=e[10],t[14]=e[11],t[3]=e[12],t[7]=e[13],t[11]=e[14],t[15]=e[15],new u(t)}static fromCopyArrayRowMajor(e){const t=new Float32Array(16);return t[0]=e[0],t[4]=e[1],t[8]=e[2],t[12]=e[3],t[1]=e[4],t[5]=e[5],t[9]=e[6],t[13]=e[7],t[2]=e[8],t[6]=e[9],t[10]=e[10],t[14]=e[11],t[3]=e[12],t[7]=e[13],t[11]=e[14],t[15]=e[15],new u(t)}static fromCopyQuaternion(e){const t=e._v[0]*e._v[0],n=e._v[1]*e._v[1],o=e._v[2]*e._v[2],a=e._v[1]*e._v[2],i=e._v[0]*e._v[2],r=e._v[0]*e._v[1],s=e._v[3]*e._v[0],l=e._v[3]*e._v[1],c=e._v[3]*e._v[2],_=new Float32Array(16);return _[0]=1-2*(n+o),_[4]=2*(r-c),_[8]=2*(i+l),_[12]=0,_[1]=2*(r+c),_[5]=1-2*(t+o),_[9]=2*(a-s),_[13]=0,_[2]=2*(i-l),_[6]=2*(a+s),_[10]=1-2*(t+n),_[14]=0,_[3]=0,_[7]=0,_[11]=0,_[15]=1,new u(_)}}},5572:(e,t,n)=>{n.d(t,{Q:()=>i});var o=n(8718),a=n(3497);class i extends o.q{constructor(e){super(e)}set m00(e){this._v[0]=e}get m00(){return this._v[0]}set m10(e){this._v[1]=e}get m10(){return this._v[1]}set m01(e){this._v[2]=e}get m01(){return this._v[2]}set m11(e){this._v[3]=e}get m11(){return this._v[3]}get className(){return"MutableMatrix22"}static zero(){return super.zero()}static identity(){return super.identity()}static dummy(){return super.dummy()}static transpose(e){return super.transpose(e)}static invert(e){return super.invert(e)}static rotate(e){return super.rotate(e)}static scale(e){return super.scale(e)}static multiply(e,t){return super.multiply(e,t)}clone(){return super.clone()}raw(){return this._v}setAt(e,t,n){return this._v[e+2*t]=n,this}setComponents(e,t,n,o){return this._v[0]=e,this._v[2]=t,this._v[1]=n,this._v[3]=o,this}copyComponents(e){return this._v[0]=e.m00,this._v[2]=e.m01,this._v[1]=e.m10,this._v[3]=e.m11,this}zero(){return this.setComponents(0,0,0,0)}identity(){return this.setComponents(1,0,0,1)}_swap(e,t){this._v[t]=[this._v[e],this._v[e]=this._v[t]][0]}transpose(){return this._swap(1,2),this}invert(){const e=this.determinant();0===e&&a.V.error("the determinant is 0!");const t=this._v[3]/e,n=this._v[2]/e*-1,o=this._v[1]/e*-1,i=this._v[0]/e;return this.setComponents(t,n,o,i)}rotate(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(t,-n,n,t)}scale(e){return this.setComponents(e._v[0],0,0,e._v[1])}multiplyScale(e){return this._v[0]*=e._v[0],this._v[2]*=e._v[0],this._v[1]*=e._v[1],this._v[3]*=e._v[1],this}multiply(e){const t=this._v[0]*e._v[0]+this._v[2]*e._v[1],n=this._v[0]*e._v[2]+this._v[2]*e._v[3],o=this._v[1]*e._v[0]+this._v[3]*e._v[1],a=this._v[1]*e._v[2]+this._v[3]*e._v[3];return this.setComponents(t,n,o,a)}multiplyByLeft(e){const t=e._v[0]*this._v[0]+e._v[2]*this._v[1],n=e._v[0]*this._v[2]+e._v[2]*this._v[3],o=e._v[1]*this._v[0]+e._v[3]*this._v[1],a=e._v[1]*this._v[2]+e._v[3]*this._v[3];return this.setComponents(t,n,o,a)}static fromCopy4RowMajor(e,t,n,o){const a=new Float32Array(4);return a[0]=e,a[2]=t,a[1]=n,a[3]=o,new i(a)}static fromCopy4ColumnMajor(e,t,n,o){const a=new Float32Array(4);return a[0]=e,a[2]=n,a[1]=t,a[3]=o,new i(a)}static fromFloat32ArrayColumnMajor(e){return new i(e)}static fromCopyFloat32ArrayColumnMajor(e){const t=new Float32Array(4);return t.set(e),new i(t)}static fromCopyFloat32ArrayRowMajor(e){const t=new Float32Array(4);return t[0]=e[0],t[3]=e[1],t[1]=e[2],t[4]=e[3],new i(t)}static fromCopyMatrix22(e){const t=new Float32Array(4);return t[0]=e._v[0],t[3]=e._v[1],t[1]=e._v[2],t[4]=e._v[3],new i(t)}static fromCopyArray9ColumnMajor(e){const t=new Float32Array(4);return t.set(e),new i(t)}static fromCopyArrayColumnMajor(e){const t=new Float32Array(4);return t.set(e),new i(t)}static fromCopyArray9RowMajor(e){const t=new Float32Array(4);return t[0]=e[0],t[3]=e[1],t[1]=e[2],t[4]=e[3],new i(t)}static fromCopyArrayRowMajor(e){const t=new Float32Array(4);return t[0]=e[0],t[3]=e[1],t[1]=e[2],t[4]=e[3],new i(t)}}},2162:(e,t,n)=>{n.d(t,{_:()=>i});var o=n(8068),a=n(3497);class i extends o.k{constructor(e){super(e)}set m00(e){this._v[0]=e}get m00(){return this._v[0]}set m10(e){this._v[1]=e}get m10(){return this._v[1]}set m20(e){this._v[2]=e}get m20(){return this._v[2]}set m01(e){this._v[3]=e}get m01(){return this._v[3]}set m11(e){this._v[4]=e}get m11(){return this._v[4]}set m21(e){this._v[5]=e}get m21(){return this._v[5]}set m02(e){this._v[6]=e}get m02(){return this._v[6]}set m12(e){this._v[7]=e}get m12(){return this._v[7]}set m22(e){this._v[8]=e}get m22(){return this._v[8]}get className(){return"MutableMatrix33"}static zero(){return super.zero()}static identity(){return i.fromCopy9RowMajor(1,0,0,0,1,0,0,0,1)}static dummy(){return super.dummy()}static transpose(e){return super.transpose(e)}static invert(e){return super.invert(e)}static rotateX(e){return super.rotateX(e)}static rotateY(e){return super.rotateY(e)}static rotateZ(e){return super.rotateZ(e)}static rotateXYZ(e,t,n){return super.rotateXYZ(e,t,n)}static rotate(e){return super.rotateXYZ(e._v[0],e._v[1],e._v[2])}static scale(e){return super.scale(e)}static multiply(e,t){return super.multiply(e,t)}clone(){return super.clone()}raw(){return this._v}setAt(e,t,n){return this._v[e+3*t]=n,this}setComponents(e,t,n,o,a,i,r,s,l){return this._v[0]=e,this._v[3]=t,this._v[6]=n,this._v[1]=o,this._v[4]=a,this._v[7]=i,this._v[2]=r,this._v[5]=s,this._v[8]=l,this}copyComponents(e){return this._v[0]=e.m00,this._v[3]=e.m01,this._v[6]=e.m02,this._v[1]=e.m10,this._v[4]=e.m11,this._v[7]=e.m12,this._v[2]=e.m20,this._v[5]=e.m21,this._v[8]=e.m22,this}zero(){return this.setComponents(0,0,0,0,0,0,0,0,0)}identity(){return this.setComponents(1,0,0,0,1,0,0,0,1)}_swap(e,t){this._v[t]=[this._v[e],this._v[e]=this._v[t]][0]}transpose(){return this._swap(1,3),this._swap(2,6),this._swap(5,8),this}invert(){const e=this.determinant();0===e&&a.V.error("the determinant is 0!");const t=(this._v[4]*this._v[8]-this._v[7]*this._v[5])/e,n=(this._v[6]*this._v[5]-this._v[3]*this._v[8])/e,o=(this._v[3]*this._v[7]-this._v[6]*this._v[4])/e,i=(this._v[7]*this._v[2]-this._v[1]*this._v[8])/e,r=(this._v[0]*this._v[8]-this._v[6]*this._v[2])/e,s=(this._v[6]*this._v[1]-this._v[0]*this._v[7])/e,l=(this._v[1]*this._v[5]-this._v[4]*this._v[2])/e,c=(this._v[3]*this._v[2]-this._v[0]*this._v[5])/e,_=(this._v[0]*this._v[4]-this._v[3]*this._v[1])/e;return this.setComponents(t,n,o,i,r,s,l,c,_)}rotateX(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(1,0,0,0,t,-n,0,n,t)}rotateY(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(t,0,n,0,1,0,-n,0,t)}rotateZ(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(t,-n,0,n,t,0,0,0,1)}rotateXYZ(e,t,n){const o=Math.cos(e),a=Math.sin(e),i=Math.cos(t),r=Math.sin(t),s=Math.cos(n),l=Math.sin(n),c=-a,_=-l,u=r*a,f=r*o,d=s*i,h=s*u+_*o,m=s*f+_*c,p=l*i,v=l*u+s*o,x=l*f+s*c,g=-r,y=i*a,b=i*o;return this.setComponents(d,h,m,p,v,x,g,y,b)}rotate(e){return this.rotateXYZ(e._v[0],e._v[1],e._v[2])}scale(e){return this.setComponents(e._v[0],0,0,0,e._v[1],0,0,0,e._v[2])}multiplyScale(e){return this._v[0]*=e._v[0],this._v[3]*=e._v[0],this._v[6]*=e._v[0],this._v[1]*=e._v[1],this._v[4]*=e._v[1],this._v[7]*=e._v[1],this._v[2]*=e._v[2],this._v[5]*=e._v[2],this._v[8]*=e._v[2],this}multiply(e){if(e.isIdentityMatrixClass)return this;const t=this._v[0]*e._v[0]+this._v[3]*e._v[1]+this._v[6]*e._v[2],n=this._v[0]*e._v[3]+this._v[3]*e._v[4]+this._v[6]*e._v[5],o=this._v[0]*e._v[6]+this._v[3]*e._v[7]+this._v[6]*e._v[8],a=this._v[1]*e._v[0]+this._v[4]*e._v[1]+this._v[7]*e._v[2],i=this._v[1]*e._v[3]+this._v[4]*e._v[4]+this._v[7]*e._v[5],r=this._v[1]*e._v[6]+this._v[4]*e._v[7]+this._v[7]*e._v[8],s=this._v[2]*e._v[0]+this._v[5]*e._v[1]+this._v[8]*e._v[2],l=this._v[2]*e._v[3]+this._v[5]*e._v[4]+this._v[8]*e._v[5],c=this._v[2]*e._v[6]+this._v[5]*e._v[7]+this._v[8]*e._v[8];return this.setComponents(t,n,o,a,i,r,s,l,c)}multiplyByLeft(e){if(e.isIdentityMatrixClass)return this;const t=e._v[0]*this._v[0]+e._v[3]*this._v[1]+e._v[6]*this._v[2],n=e._v[0]*this._v[3]+e._v[3]*this._v[4]+e._v[6]*this._v[5],o=e._v[0]*this._v[6]+e._v[3]*this._v[7]+e._v[6]*this._v[8],a=e._v[1]*this._v[0]+e._v[4]*this._v[1]+e._v[7]*this._v[2],i=e._v[1]*this._v[3]+e._v[4]*this._v[4]+e._v[7]*this._v[5],r=e._v[1]*this._v[6]+e._v[4]*this._v[7]+e._v[7]*this._v[8],s=e._v[2]*this._v[0]+e._v[5]*this._v[1]+e._v[8]*this._v[2],l=e._v[2]*this._v[3]+e._v[5]*this._v[4]+e._v[8]*this._v[5],c=e._v[2]*this._v[6]+e._v[5]*this._v[7]+e._v[8]*this._v[8];return this.setComponents(t,n,o,a,i,r,s,l,c)}static fromCopy9RowMajor(e,t,n,o,a,r,s,l,c){const _=new Float32Array(9);return _[0]=e,_[3]=t,_[6]=n,_[1]=o,_[4]=a,_[7]=r,_[2]=s,_[5]=l,_[8]=c,new i(_)}static fromCopy9ColumnMajor(e,t,n,o,a,r,s,l,c){const _=new Float32Array(9);return _[0]=e,_[3]=o,_[6]=s,_[1]=t,_[4]=a,_[7]=l,_[2]=n,_[5]=r,_[8]=c,new i(_)}static fromCopyMatrix44(e){const t=new Float32Array(9);return t.set(e._v),new i(t)}static fromFloat32ArrayColumnMajor(e){return new i(e)}static fromCopyFloat32ArrayColumnMajor(e){const t=new Float32Array(9);return t.set(e),new i(t)}static fromCopyFloat32ArrayRowMajor(e){const t=new Float32Array(9);return t[0]=e[0],t[3]=e[1],t[6]=e[2],t[1]=e[3],t[4]=e[4],t[7]=e[5],t[2]=e[6],t[5]=e[7],t[8]=e[8],new i(t)}static fromCopyMatrix33(e){const t=new Float32Array(9);return t[0]=e._v[0],t[3]=e._v[3],t[6]=e._v[6],t[1]=e._v[1],t[4]=e._v[4],t[7]=e._v[7],t[2]=e._v[2],t[5]=e._v[5],t[8]=e._v[8],new i(t)}static fromCopyArray9ColumnMajor(e){const t=new Float32Array(9);return t.set(e),new i(t)}static fromCopyArrayColumnMajor(e){const t=new Float32Array(9);return t.set(e),new i(t)}static fromCopyArray9RowMajor(e){const t=new Float32Array(9);return t[0]=e[0],t[3]=e[1],t[6]=e[2],t[1]=e[3],t[4]=e[4],t[7]=e[5],t[2]=e[6],t[5]=e[7],t[8]=e[8],new i(t)}static fromCopyArrayRowMajor(e){const t=new Float32Array(9);return t[0]=e[0],t[3]=e[1],t[6]=e[2],t[1]=e[3],t[4]=e[4],t[7]=e[5],t[2]=e[6],t[5]=e[7],t[8]=e[8],new i(t)}static fromCopyQuaternion(e){const t=e._v[0]*e._v[0],n=e._v[1]*e._v[1],o=e._v[2]*e._v[2],a=e._v[1]*e._v[2],r=e._v[0]*e._v[2],s=e._v[0]*e._v[1],l=e._v[3]*e._v[0],c=e._v[3]*e._v[1],_=e._v[3]*e._v[2],u=new Float32Array(9);return u[0]=1-2*(n+o),u[3]=2*(s-_),u[6]=2*(r+c),u[1]=2*(s+_),u[4]=1-2*(t+o),u[7]=2*(a-l),u[2]=2*(r-c),u[5]=2*(a+l),u[8]=1-2*(t+n),new i(u)}}},7476:(e,t,n)=>{n.d(t,{g:()=>i});var o=n(3870),a=n(3497);class i extends o._{constructor(e){super(e)}set m00(e){this._v[0]=e}get m00(){return this._v[0]}set m10(e){this._v[1]=e}get m10(){return this._v[1]}set m20(e){this._v[2]=e}get m20(){return this._v[2]}set m30(e){this._v[3]=e}get m30(){return this._v[3]}set m01(e){this._v[4]=e}get m01(){return this._v[4]}set m11(e){this._v[5]=e}get m11(){return this._v[5]}set m21(e){this._v[6]=e}get m21(){return this._v[6]}set m31(e){this._v[7]=e}get m31(){return this._v[7]}set m02(e){this._v[8]=e}get m02(){return this._v[8]}set m12(e){this._v[9]=e}get m12(){return this._v[9]}set m22(e){this._v[10]=e}get m22(){return this._v[10]}set m32(e){this._v[11]=e}get m32(){return this._v[11]}set m03(e){this._v[12]=e}get m03(){return this._v[12]}set m13(e){this._v[13]=e}get m13(){return this._v[13]}set m23(e){this._v[14]=e}get m23(){return this._v[14]}set m33(e){this._v[15]=e}get m33(){return this._v[15]}get translateX(){return this._v[12]}set translateX(e){this._v[12]=e}get translateY(){return this._v[13]}set translateY(e){this._v[13]=e}get translateZ(){return this._v[14]}set translateZ(e){this._v[14]=e}get className(){return"MutableMatrix44"}static zero(){return i.fromCopy16RowMajor(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}static identity(){return i.fromCopy16RowMajor(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}static dummy(){return super.dummy()}static transpose(e){return e.isIdentityMatrixClass?e:i.fromCopyFloat32ArrayRowMajor(e._v)}static invert(e){return super.invert(e)}static translate(e){return super.translate(e)}static rotateX(e){return super.rotateX(e)}static rotateY(e){return super.rotateY(e)}static rotateZ(e){return super.rotateZ(e)}static rotateXYZ(e,t,n){return super.rotateXYZ(e,t,n)}static rotate(e){return super.rotateXYZ(e._v[0],e._v[1],e._v[2])}static scale(e){return super.scale(e)}static multiply(e,t){return super.multiply(e,t)}clone(){return super.clone()}getRotate(){return super.getRotate()}getTranslate(){return super.getTranslate()}getTranslateTo(e){return super.getTranslateTo(e)}getScale(){return super.getScale()}raw(){return this._v}setAt(e,t,n){return this._v[e+4*t]=n,this}setComponents(e,t,n,o,a,i,r,s,l,c,_,u,f,d,h,m){return this._v[0]=e,this._v[4]=t,this._v[8]=n,this._v[12]=o,this._v[1]=a,this._v[5]=i,this._v[9]=r,this._v[13]=s,this._v[2]=l,this._v[6]=c,this._v[10]=_,this._v[14]=u,this._v[3]=f,this._v[7]=d,this._v[11]=h,this._v[15]=m,this}copyComponents(e){return this._v[0]=e._v[0],this._v[4]=e._v[4],this._v[8]=e._v[8],this._v[12]=e._v[12],this._v[1]=e._v[1],this._v[5]=e._v[5],this._v[9]=e._v[9],this._v[13]=e._v[13],this._v[2]=e._v[2],this._v[6]=e._v[6],this._v[10]=e._v[10],this._v[14]=e._v[14],this._v[3]=e._v[3],this._v[7]=e._v[7],this._v[11]=e._v[11],this._v[15]=e._v[15],this}zero(){return this.setComponents(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}identity(){return this.setComponents(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}_swap(e,t){this._v[t]=[this._v[e],this._v[e]=this._v[t]][0]}transpose(){return this._swap(1,4),this._swap(2,8),this._swap(3,12),this._swap(6,9),this._swap(7,13),this._swap(11,14),this}invert(){const e=this._v[0]*this._v[5]-this._v[4]*this._v[1],t=this._v[0]*this._v[9]-this._v[8]*this._v[1],n=this._v[0]*this._v[13]-this._v[12]*this._v[1],o=this._v[4]*this._v[9]-this._v[8]*this._v[5],i=this._v[4]*this._v[13]-this._v[12]*this._v[5],r=this._v[8]*this._v[13]-this._v[12]*this._v[9],s=this._v[2]*this._v[7]-this._v[6]*this._v[3],l=this._v[2]*this._v[11]-this._v[10]*this._v[3],c=this._v[2]*this._v[15]-this._v[14]*this._v[3],_=this._v[6]*this._v[11]-this._v[10]*this._v[7],u=this._v[6]*this._v[15]-this._v[14]*this._v[7],f=this._v[10]*this._v[15]-this._v[14]*this._v[11],d=e*f-t*u+n*_+o*c-i*l+r*s;0===d&&a.V.error("the determinant is 0!");const h=(this._v[5]*f-this._v[9]*u+this._v[13]*_)/d,m=(this._v[8]*u-this._v[4]*f-this._v[12]*_)/d,p=(this._v[7]*r-this._v[11]*i+this._v[15]*o)/d,v=(this._v[10]*i-this._v[6]*r-this._v[14]*o)/d,x=(this._v[9]*c-this._v[1]*f-this._v[13]*l)/d,g=(this._v[0]*f-this._v[8]*c+this._v[12]*l)/d,y=(this._v[11]*n-this._v[3]*r-this._v[15]*t)/d,b=(this._v[2]*r-this._v[10]*n+this._v[14]*t)/d,I=(this._v[1]*u-this._v[5]*c+this._v[13]*s)/d,A=(this._v[4]*c-this._v[0]*u-this._v[12]*s)/d,E=(this._v[3]*i-this._v[7]*n+this._v[15]*e)/d,S=(this._v[6]*n-this._v[2]*i-this._v[14]*e)/d,T=(this._v[5]*l-this._v[1]*_-this._v[9]*s)/d,w=(this._v[0]*_-this._v[4]*l+this._v[8]*s)/d,C=(this._v[7]*t-this._v[3]*o-this._v[11]*e)/d,R=(this._v[2]*o-this._v[6]*t+this._v[10]*e)/d;return this.setComponents(h,m,p,v,x,g,y,b,I,A,E,S,T,w,C,R)}translate(e){return this.setComponents(1,0,0,e._v[0],0,1,0,e._v[1],0,0,1,e._v[2],0,0,0,1)}putTranslate(e){return this._v[12]=e._v[0],this._v[13]=e._v[1],this._v[14]=e._v[2],this}addTranslate(e){return this._v[12]+=e._v[0],this._v[13]+=e._v[1],this._v[14]+=e._v[2],this}rotateX(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1)}rotateY(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1)}rotateZ(e){const t=Math.cos(e),n=Math.sin(e);return this.setComponents(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1)}rotateXYZ(e,t,n){const o=Math.cos(e),a=Math.sin(e),i=Math.cos(t),r=Math.sin(t),s=Math.cos(n),l=Math.sin(n),c=-a,_=-l,u=r*a,f=r*o,d=s*i,h=s*u+_*o,m=s*f+_*c,p=l*i,v=l*u+s*o,x=l*f+s*c,g=-r,y=i*a,b=i*o;return this.setComponents(d,h,m,0,p,v,x,0,g,y,b,0,0,0,0,1)}rotate(e){return this.rotateXYZ(e._v[0],e._v[1],e._v[2])}scale(e){return this.setComponents(e._v[0],0,0,0,0,e._v[1],0,0,0,0,e._v[2],0,0,0,0,1)}multiplyScale(e){return this._v[0]*=e._v[0],this._v[4]*=e._v[0],this._v[8]*=e._v[0],this._v[12]*=e._v[0],this._v[1]*=e._v[1],this._v[5]*=e._v[1],this._v[9]*=e._v[1],this._v[13]*=e._v[1],this._v[2]*=e._v[2],this._v[6]*=e._v[2],this._v[10]*=e._v[2],this._v[14]*=e._v[2],this}multiply(e){if(e.isIdentityMatrixClass)return this;const t=this._v[0]*e._v[0]+this._v[4]*e._v[1]+this._v[8]*e._v[2]+this._v[12]*e._v[3],n=this._v[0]*e._v[4]+this._v[4]*e._v[5]+this._v[8]*e._v[6]+this._v[12]*e._v[7],o=this._v[0]*e._v[8]+this._v[4]*e._v[9]+this._v[8]*e._v[10]+this._v[12]*e._v[11],a=this._v[0]*e._v[12]+this._v[4]*e._v[13]+this._v[8]*e._v[14]+this._v[12]*e._v[15],i=this._v[1]*e._v[0]+this._v[5]*e._v[1]+this._v[9]*e._v[2]+this._v[13]*e._v[3],r=this._v[1]*e._v[4]+this._v[5]*e._v[5]+this._v[9]*e._v[6]+this._v[13]*e._v[7],s=this._v[1]*e._v[8]+this._v[5]*e._v[9]+this._v[9]*e._v[10]+this._v[13]*e._v[11],l=this._v[1]*e._v[12]+this._v[5]*e._v[13]+this._v[9]*e._v[14]+this._v[13]*e._v[15],c=this._v[2]*e._v[0]+this._v[6]*e._v[1]+this._v[10]*e._v[2]+this._v[14]*e._v[3],_=this._v[2]*e._v[4]+this._v[6]*e._v[5]+this._v[10]*e._v[6]+this._v[14]*e._v[7],u=this._v[2]*e._v[8]+this._v[6]*e._v[9]+this._v[10]*e._v[10]+this._v[14]*e._v[11],f=this._v[2]*e._v[12]+this._v[6]*e._v[13]+this._v[10]*e._v[14]+this._v[14]*e._v[15],d=this._v[3]*e._v[0]+this._v[7]*e._v[1]+this._v[11]*e._v[2]+this._v[15]*e._v[3],h=this._v[3]*e._v[4]+this._v[7]*e._v[5]+this._v[11]*e._v[6]+this._v[15]*e._v[7],m=this._v[3]*e._v[8]+this._v[7]*e._v[9]+this._v[11]*e._v[10]+this._v[15]*e._v[11],p=this._v[3]*e._v[12]+this._v[7]*e._v[13]+this._v[11]*e._v[14]+this._v[15]*e._v[15];return this.setComponents(t,n,o,a,i,r,s,l,c,_,u,f,d,h,m,p)}multiplyByLeft(e){if(e.isIdentityMatrixClass)return this;const t=e._v[0]*this._v[0]+e._v[4]*this._v[1]+e._v[8]*this._v[2]+e._v[12]*this._v[3],n=e._v[0]*this._v[4]+e._v[4]*this._v[5]+e._v[8]*this._v[6]+e._v[12]*this._v[7],o=e._v[0]*this._v[8]+e._v[4]*this._v[9]+e._v[8]*this._v[10]+e._v[12]*this._v[11],a=e._v[0]*this._v[12]+e._v[4]*this._v[13]+e._v[8]*this._v[14]+e._v[12]*this._v[15],i=e._v[1]*this._v[0]+e._v[5]*this._v[1]+e._v[9]*this._v[2]+e._v[13]*this._v[3],r=e._v[1]*this._v[4]+e._v[5]*this._v[5]+e._v[9]*this._v[6]+e._v[13]*this._v[7],s=e._v[1]*this._v[8]+e._v[5]*this._v[9]+e._v[9]*this._v[10]+e._v[13]*this._v[11],l=e._v[1]*this._v[12]+e._v[5]*this._v[13]+e._v[9]*this._v[14]+e._v[13]*this._v[15],c=e._v[2]*this._v[0]+e._v[6]*this._v[1]+e._v[10]*this._v[2]+e._v[14]*this._v[3],_=e._v[2]*this._v[4]+e._v[6]*this._v[5]+e._v[10]*this._v[6]+e._v[14]*this._v[7],u=e._v[2]*this._v[8]+e._v[6]*this._v[9]+e._v[10]*this._v[10]+e._v[14]*this._v[11],f=e._v[2]*this._v[12]+e._v[6]*this._v[13]+e._v[10]*this._v[14]+e._v[14]*this._v[15],d=e._v[3]*this._v[0]+e._v[7]*this._v[1]+e._v[11]*this._v[2]+e._v[15]*this._v[3],h=e._v[3]*this._v[4]+e._v[7]*this._v[5]+e._v[11]*this._v[6]+e._v[15]*this._v[7],m=e._v[3]*this._v[8]+e._v[7]*this._v[9]+e._v[11]*this._v[10]+e._v[15]*this._v[11],p=e._v[3]*this._v[12]+e._v[7]*this._v[13]+e._v[11]*this._v[14]+e._v[15]*this._v[15];return this.setComponents(t,n,o,a,i,r,s,l,c,_,u,f,d,h,m,p)}fromQuaternion(e){const t=e._v[0]*e._v[0],n=e._v[1]*e._v[1],o=e._v[2]*e._v[2],a=e._v[1]*e._v[2],i=e._v[0]*e._v[2],r=e._v[0]*e._v[1],s=e._v[3]*e._v[0],l=e._v[3]*e._v[1],c=e._v[3]*e._v[2],_=1-2*(n+o),u=2*(r-c),f=2*(i+l),d=2*(r+c),h=1-2*(t+o),m=2*(a-s),p=2*(i-l),v=2*(a+s),x=1-2*(t+n);return this.setComponents(_,u,f,0,d,h,m,0,p,v,x,0,0,0,0,1)}static fromCopy16RowMajor(e,t,n,o,a,r,s,l,c,_,u,f,d,h,m,p){const v=new Float32Array(16);return v[0]=e,v[4]=t,v[8]=n,v[12]=o,v[1]=a,v[5]=r,v[9]=s,v[13]=l,v[2]=c,v[6]=_,v[10]=u,v[14]=f,v[3]=d,v[7]=h,v[11]=m,v[15]=p,new i(v)}static fromCopy16ColumnMajor(e,t,n,o,a,r,s,l,c,_,u,f,d,h,m,p){const v=new Float32Array(16);return v[0]=e,v[4]=a,v[8]=c,v[12]=d,v[1]=t,v[5]=r,v[9]=_,v[13]=h,v[2]=n,v[6]=s,v[10]=u,v[14]=m,v[3]=o,v[7]=l,v[11]=f,v[15]=p,new i(v)}static fromCopyMatrix44(e){const t=new Float32Array(16);return t.set(e._v),new i(t)}static fromFloat32ArrayColumnMajor(e){return new i(e)}static fromCopyFloat32ArrayColumnMajor(e){const t=new Float32Array(16);return t.set(e),new i(t)}static fromCopyFloat32ArrayRowMajor(e){const t=new Float32Array(16);return t[0]=e[0],t[4]=e[1],t[8]=e[2],t[12]=e[3],t[1]=e[4],t[5]=e[5],t[9]=e[6],t[13]=e[7],t[2]=e[8],t[6]=e[9],t[10]=e[10],t[14]=e[11],t[3]=e[12],t[7]=e[13],t[11]=e[14],t[15]=e[15],new i(t)}static fromCopyMatrix33(e){const t=new Float32Array(16);return t[0]=e._v[0],t[4]=e._v[3],t[8]=e._v[6],t[12]=0,t[1]=e._v[1],t[5]=e._v[4],t[9]=e._v[7],t[13]=0,t[2]=e._v[2],t[6]=e._v[5],t[10]=e._v[8],t[14]=0,t[3]=0,t[7]=0,t[11]=0,t[15]=1,new i(t)}static fromCopyArray16ColumnMajor(e){const t=new Float32Array(16);return t.set(e),new i(t)}static fromCopyArrayColumnMajor(e){const t=new Float32Array(16);return t.set(e),new i(t)}static fromCopyArray16RowMajor(e){const t=new Float32Array(16);return t[0]=e[0],t[4]=e[1],t[8]=e[2],t[12]=e[3],t[1]=e[4],t[5]=e[5],t[9]=e[6],t[13]=e[7],t[2]=e[8],t[6]=e[9],t[10]=e[10],t[14]=e[11],t[3]=e[12],t[7]=e[13],t[11]=e[14],t[15]=e[15],new i(t)}static fromCopyArrayRowMajor(e){const t=new Float32Array(16);return t[0]=e[0],t[4]=e[1],t[8]=e[2],t[12]=e[3],t[1]=e[4],t[5]=e[5],t[9]=e[6],t[13]=e[7],t[2]=e[8],t[6]=e[9],t[10]=e[10],t[14]=e[11],t[3]=e[12],t[7]=e[13],t[11]=e[14],t[15]=e[15],new i(t)}static fromCopyQuaternion(e){const t=e._v[0]*e._v[0],n=e._v[1]*e._v[1],o=e._v[2]*e._v[2],a=e._v[1]*e._v[2],r=e._v[0]*e._v[2],s=e._v[0]*e._v[1],l=e._v[3]*e._v[0],c=e._v[3]*e._v[1],_=e._v[3]*e._v[2],u=new Float32Array(16);return u[0]=1-2*(n+o),u[4]=2*(s-_),u[8]=2*(r+c),u[12]=0,u[1]=2*(s+_),u[5]=1-2*(t+o),u[9]=2*(a-l),u[13]=0,u[2]=2*(r-c),u[6]=2*(a+l),u[10]=1-2*(t+n),u[14]=0,u[3]=0,u[7]=0,u[11]=0,u[15]=1,new i(u)}}},6253:(e,t,n)=>{n.d(t,{h:()=>r});var o=n(6603),a=n(7476),i=n(3497);class r extends o.P{constructor(e){super(e)}set x(e){this._v[0]=e}get x(){return this._v[0]}set y(e){this._v[1]=e}get y(){return this._v[1]}set z(e){this._v[2]=e}get z(){return this._v[2]}set w(e){this._v[3]=e}get w(){return this._v[3]}get className(){return"MutableQuaternion"}static identity(){return r.fromCopy4(0,0,0,1)}static dummy(){return new this(new Float32Array(0))}static invert(e){return super.invert(e)}static qlerp(e,t,n){return super.qlerp(e,t,n)}static lerp(e,t,n){return super.lerp(e,t,n)}static axisAngle(e,t){return super.axisAngle(e,t)}static fromMatrix(e){return super.fromMatrix(e)}static fromPosition(e){return super.fromPosition(e)}static add(e,t){return super.add(e,t)}static subtract(e,t){return super.subtract(e,t)}static multiply(e,t){return super.multiply(e,t)}static multiplyNumber(e,t){return super.multiplyNumber(e,t)}static divideNumber(e,t){return super.divideNumber(e,t)}raw(){return this._v}setAt(e,t){return this._v[e]=t,this}setComponents(e,t,n,o){return this._v[0]=e,this._v[1]=t,this._v[2]=n,this._v[3]=o,this}copyComponents(e){return this.setComponents(e._v[0],e._v[1],e._v[2],e._v[3])}identity(){return this.setComponents(0,0,0,1)}normalize(){const e=this.length();return this.divideNumber(e)}invert(){const e=this.length();return 0===e||(this._v[0]=-this._v[0]/e,this._v[1]=-this._v[1]/e,this._v[2]=-this._v[2]/e,this._v[3]=this._v[3]/e),this}qlerp(e,t,n){let o=e._v[3]*t._v[3]+e._v[0]*t._v[0]+e._v[1]*t._v[1]+e._v[2]*t._v[2];if(0==1-o*o)return this.copyComponents(e);{o>1?o=.999:o<-1&&(o=-.999);let a,i=Math.acos(o);o<0&&i>Math.PI/2?(o=-e._v[3]*t._v[3]-e._v[0]*t._v[0]-e._v[1]*t._v[1]-e._v[2]*t._v[2],i=Math.acos(o),a=-1*Math.sin(i*n)/Math.sin(i)):a=Math.sin(i*n)/Math.sin(i);const r=Math.sin(i*(1-n))/Math.sin(i);this._v[0]=e._v[0]*r+t._v[0]*a,this._v[1]=e._v[1]*r+t._v[1]*a,this._v[2]=e._v[2]*r+t._v[2]*a,this._v[3]=e._v[3]*r+t._v[3]*a}return this}lerp(e,t,n){return this._v[0]=e._v[0]*(1-n)+t._v[0]*n,this._v[1]=e._v[1]*(1-n)+t._v[1]*n,this._v[2]=e._v[2]*(1-n)+t._v[2]*n,this._v[3]=e._v[3]*(1-n)+t._v[3]*n,this}axisAngle(e,t){const n=.5*t,o=Math.sin(n),a=e.length();return 0===a&&i.V.error("0 division occurred!"),this._v[3]=Math.cos(n),this._v[0]=o*e._v[0]/a,this._v[1]=o*e._v[1]/a,this._v[2]=o*e._v[2]/a,this}fromMatrix(e){let t=Math.hypot(e.m00,e.m10,e.m20);const n=Math.hypot(e.m01,e.m11,e.m21),o=Math.hypot(e.m02,e.m12,e.m22);e.determinant()<0&&(t=-t);const i=a.g.fromCopyMatrix44(e),r=1/t,s=1/n,l=1/o;i.m00*=r,i.m10*=r,i.m20*=r,i.m01*=s,i.m11*=s,i.m21*=s,i.m02*=l,i.m12*=l,i.m22*=l;const c=i.m00+i.m11+i.m22;if(c>0){const e=.5/Math.sqrt(c+1);this._v[0]=(i.m21-i.m12)*e,this._v[1]=(i.m02-i.m20)*e,this._v[2]=(i.m10-i.m01)*e,this._v[3]=.25/e}else if(i.m00>i.m11&&i.m00>i.m22){const e=2*Math.sqrt(1+i.m00-i.m11-i.m22);this._v[0]=.25*e,this._v[1]=(i.m01+i.m10)/e,this._v[2]=(i.m02+i.m20)/e,this._v[3]=(i.m21-i.m12)/e}else if(i.m11>i.m22){const e=2*Math.sqrt(1+i.m11-i.m00-i.m22);this._v[0]=(i.m01+i.m10)/e,this._v[1]=.25*e,this._v[2]=(i.m12+i.m21)/e,this._v[3]=(i.m02-i.m20)/e}else{const e=2*Math.sqrt(1+i.m22-i.m00-i.m11);this._v[0]=(i.m02+i.m20)/e,this._v[1]=(i.m12+i.m21)/e,this._v[2]=.25*e,this._v[3]=(i.m10-i.m01)/e}return this}fromPosition(e){return this.setComponents(e._v[0],e._v[1],e._v[2],0)}add(e){return this._v[0]+=e._v[0],this._v[1]+=e._v[1],this._v[2]+=e._v[2],this._v[3]+=e._v[3],this}subtract(e){return this._v[0]-=e._v[0],this._v[1]-=e._v[1],this._v[2]-=e._v[2],this._v[3]-=e._v[3],this}multiply(e){const t=e._v[3]*this._v[0]+e._v[2]*this._v[1]+e._v[1]*this._v[2]-e._v[0]*this._v[3],n=-e._v[2]*this._v[0]+e._v[3]*this._v[1]+e._v[0]*this._v[2]-e._v[1]*this._v[3],o=e._v[1]*this._v[0]+e._v[0]*this._v[1]+e._v[3]*this._v[2]-e._v[2]*this._v[3],a=-e._v[0]*this._v[0]-e._v[1]*this._v[1]-e._v[2]*this._v[2]-e._v[3]*this._v[3];return this.setComponents(t,n,o,a)}multiplyNumber(e){return this._v[0]*=e,this._v[1]*=e,this._v[2]*=e,this._v[3]*=e,this}divideNumber(e){return 0!==e?(this._v[0]/=e,this._v[1]/=e,this._v[2]/=e,this._v[3]/=e):(i.V.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0,this._v[2]=1/0,this._v[3]=1/0),this}clone(){return r.fromCopy4(this._v[0],this._v[1],this._v[2],this._v[3])}static fromFloat32Array(e){return new r(e)}static fromCopyArray4(e){return new r(new Float32Array(e))}static fromCopyArray(e){return new r(new Float32Array(e.slice(0,4)))}static fromCopy4(e,t,n,o){return new r(new Float32Array([e,t,n,o]))}static fromCopyQuaternion(e){const t=new Float32Array(4);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],t[3]=e._v[3],new r(t)}static fromCopyVector4(e){const t=new Float32Array(4);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],t[3]=e._v[3],new r(t)}static fromCopyLogQuaternion(e){const t=e._v[0]*e._v[0]+e._v[1]*e._v[1]+e._v[2]*e._v[2],n=Math.sin(t),o=new Float32Array(4);return o[0]=e._v[0]*(n/t),o[1]=e._v[1]*(n/t),o[2]=e._v[2]*(n/t),o[3]=Math.cos(t),new r(o)}}},1881:(e,t,n)=>{n.d(t,{Zt:()=>s,eZ:()=>i,n9:()=>r});var o=n(9011),a=n(7751);class i extends o.Cj{constructor(e,{type:t}){super(e,{type:t})}copyComponents(e){this._v[0]=e._v[0]}get x(){return this._v[0]}set x(e){this._v[0]=e}get y(){return 0}get z(){return 0}get w(){return 1}toString(){return"("+this._v[0]+")"}setValue(e){return this.x=e,this}static get compositionType(){return a.h.Scalar}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}}class r extends i{constructor(e){super(e,{type:Float32Array})}clone(){return new r(new Float32Array([this.x]))}static one(){return new r(new Float32Array([1]))}static dummy(){return new r(new Float32Array([]))}static zero(){return new r(new Float32Array([0]))}get className(){return"MutableScalar"}}class s extends i{constructor(e){super(e,{type:Float64Array})}clone(){return new s(new Float64Array([this.x]))}static one(){return new s(new Float64Array([1]))}static dummy(){return new s(new Float64Array([]))}static zero(){return new s(new Float64Array([0]))}}},5882:(e,t,n)=>{n.d(t,{A3:()=>r,eE:()=>s,ly:()=>i});var o=n(9936),a=n(3497);class i extends o.VS{constructor(e,{type:t}){super(e,{type:t})}set x(e){this._v[0]=e}get x(){return this._v[0]}set y(e){this._v[1]=e}get y(){return this._v[1]}get z(){return 0}get w(){return 1}raw(){return this._v}setAt(e,t){return this._v[e]=t,this}setComponents(e,t){return this._v[0]=e,this._v[1]=t,this}copyComponents(e){return this.setComponents(e._v[0],e._v[1])}zero(){return this.setComponents(0,0)}one(){return this.setComponents(1,1)}normalize(){const e=this.length();return this.divide(e),this}add(e){return this._v[0]+=e._v[0],this._v[1]+=e._v[1],this}subtract(e){return this._v[0]-=e._v[0],this._v[1]-=e._v[1],this}multiply(e){return this._v[0]*=e,this._v[1]*=e,this}multiplyVector(e){return this._v[0]*=e._v[0],this._v[1]*=e._v[1],this}divide(e){return 0!==e?(this._v[0]/=e,this._v[1]/=e):(a.V.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0),this}divideVector(e){return 0!==e._v[0]&&0!==e._v[1]?(this._v[0]/=e._v[0],this._v[1]/=e._v[1]):(a.V.error("0 division occurred!"),this._v[0]=0===e._v[0]?1/0:this._v[0]/e._v[0],this._v[1]=0===e._v[1]?1/0:this._v[1]/e._v[1]),this}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}}class r extends i{constructor(e){super(e,{type:Float32Array})}static fromCopyArray2(e){return new r(new Float32Array(e))}static fromCopyArray(e){return new r(new Float32Array(e.slice(0,2)))}static fromFloat32Array(e){return new r(e)}static fromCopyFloat32Array(e){return new r(new Float32Array(e.buffer.slice(0)))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}get className(){return"MutableVector2"}clone(){return super.clone()}}class s extends i{constructor(e){super(e,{type:Float64Array})}static fromCopyArray(e){return new s(new Float64Array(e))}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(e){return super._normalize(e,Float64Array)}static add(e,t){return super._add(e,t,Float64Array)}static subtract(e,t){return super._subtract(e,t,Float64Array)}static multiply(e,t){return super._multiply(e,t,Float64Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float64Array)}static divide(e,t){return super._divide(e,t,Float64Array)}static divideVector(e,t){return super._divideVector(e,t,Float64Array)}clone(){return super.clone()}}},5697:(e,t,n)=>{n.d(t,{Qj:()=>i,tp:()=>r,vv:()=>s});var o=n(975),a=n(3497);class i extends o.wr{constructor(e,{type:t}){super(e,{type:t})}set x(e){this._v[0]=e}get x(){return this._v[0]}set y(e){this._v[1]=e}get y(){return this._v[1]}set z(e){this._v[2]=e}get z(){return this._v[2]}get w(){return 1}raw(){return this._v}setAt(e,t){return this._v[e]=t,this}setComponents(e,t,n){return this._v[0]=e,this._v[1]=t,this._v[2]=n,this}copyComponents(e){return this.setComponents(e._v[0],e._v[1],e._v[2])}zero(){return this.setComponents(0,0,0)}one(){return this.setComponents(1,1,1)}normalize(){const e=this.length();return this.divide(e),this}add(e){return this._v[0]+=e._v[0],this._v[1]+=e._v[1],this._v[2]+=e._v[2],this}subtract(e){return this._v[0]-=e._v[0],this._v[1]-=e._v[1],this._v[2]-=e._v[2],this}multiply(e){return this._v[0]*=e,this._v[1]*=e,this._v[2]*=e,this}multiplyVector(e){return this._v[0]*=e._v[0],this._v[1]*=e._v[1],this._v[2]*=e._v[2],this}divide(e){return 0!==e?(this._v[0]/=e,this._v[1]/=e,this._v[2]/=e):(a.V.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0,this._v[2]=1/0),this}divideVector(e){return 0!==e._v[0]&&0!==e._v[1]&&0!==e._v[2]?(this._v[0]/=e._v[0],this._v[1]/=e._v[1],this._v[2]/=e._v[2]):(a.V.error("0 division occurred!"),this._v[0]=0===e._v[0]?1/0:this._v[0]/e._v[0],this._v[1]=0===e._v[1]?1/0:this._v[1]/e._v[1],this._v[2]=0===e._v[2]?1/0:this._v[2]/e._v[2]),this}cross(e){const t=this._v[1]*e._v[2]-this._v[2]*e._v[1],n=this._v[2]*e._v[0]-this._v[0]*e._v[2],o=this._v[0]*e._v[1]-this._v[1]*e._v[0];return this.setComponents(t,n,o)}multiplyQuaternion(e){const t=2*e._v[0],n=2*e._v[1],o=2*e._v[2],a=e._v[0]*t,i=e._v[1]*n,r=e._v[2]*o,s=e._v[0]*n,l=e._v[0]*o,c=e._v[1]*o,_=e._v[3]*t,u=e._v[3]*n,f=e._v[3]*o,d=(1-(i+r))*this._v[0]+(s-f)*this._v[1]+(l+u)*this._v[2],h=(s+f)*this._v[0]+(1-(a+r))*this._v[1]+(c-_)*this._v[2],m=(l-u)*this._v[0]+(c+_)*this._v[1]+(1-(a+i))*this._v[2];return this.setComponents(d,h,m)}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}static _fromCopy3(e,t,n,o){return new this(new o([e,t,n]),{type:o})}}class r extends i{constructor(e){super(e,{type:Float32Array})}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}static cross(e,t){return super._cross(e,t,Float32Array)}static multiplyQuaternion(e,t){return super._multiplyQuaternion(e,t,Float32Array)}get className(){return"MutableVector3"}static fromCopy3(e,t,n){return super._fromCopy3(e,t,n,Float32Array)}static fromCopy1(e){return super._fromCopy3(e,e,e,Float32Array)}static fromCopyArray3(e){return new r(new Float32Array(e))}static fromCopyArray(e){return new r(new Float32Array(e.slice(0,3)))}static fromFloat32Array(e){return new r(e)}static fromCopyFloat32Array(e){return new r(new Float32Array(e.buffer.slice(0)))}static fromCopyVector3(e){return super._fromCopyVector3(e,Float32Array)}static fromCopyVector4(e){return super._fromCopyVector4(e,Float32Array)}clone(){return super.clone()}static rotateX(e,t,n){const o=Math.cos(t),a=Math.sin(t);n.y=e.y*o-e.z*a,n.z=e.y*a+e.z*o}static rotateY(e,t,n){const o=Math.cos(t),a=Math.sin(t);n.x=e.x*o+e.z*a,n.z=-e.x*a+e.z*o}static rotateZ(e,t,n){const o=Math.cos(t),a=Math.sin(t);n.x=e.x*o-e.y*a,n.y=e.x*a+e.y*o}}class s extends i{constructor(e){super(e,{type:Float64Array})}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(e){return super._normalize(e,Float64Array)}static add(e,t){return super._add(e,t,Float64Array)}static subtract(e,t){return super._subtract(e,t,Float64Array)}static multiply(e,t){return super._multiply(e,t,Float64Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float64Array)}static divide(e,t){return super._divide(e,t,Float64Array)}static divideVector(e,t){return super._divideVector(e,t,Float64Array)}static cross(e,t){return super._cross(e,t,Float64Array)}static multiplyQuaternion(e,t){return super._multiplyQuaternion(e,t,Float64Array)}static fromCopy3(e,t,n){return super._fromCopy3(e,t,n,Float64Array)}static fromCopy1(e){return super._fromCopy3(e,e,e,Float64Array)}static fromCopyArray3(e){return new s(new Float64Array(e))}static fromCopyArray(e){return new s(new Float64Array(e.slice(0,3)))}static rotateX(e,t,n){const o=Math.cos(t),a=Math.sin(t);n.y=e.y*o-e.z*a,n.z=e.y*a+e.z*o}static rotateY(e,t,n){const o=Math.cos(t),a=Math.sin(t);n.x=e.x*o+e.z*a,n.z=-e.x*a+e.z*o}static rotateZ(e,t,n){const o=Math.cos(t),a=Math.sin(t);n.x=e.x*o-e.y*a,n.y=e.x*a+e.y*o}clone(){return super.clone()}}},8924:(e,t,n)=>{n.d(t,{Am:()=>r,HO:()=>i,aJ:()=>s});var o=n(3414),a=n(3497);class i extends o.xn{constructor(e,{type:t}){super(e,{type:t}),this.__updateCount=0}set x(e){this._v[0]=e,this.__updateCount++}get x(){return this._v[0]}set y(e){this._v[1]=e,this.__updateCount++}get y(){return this._v[1]}set z(e){this._v[2]=e,this.__updateCount++}get z(){return this._v[2]}set w(e){this._v[3]=e,this.__updateCount++}get w(){return this._v[3]}raw(){return this._v}setAt(e,t){return this._v[e]=t,this.__updateCount++,this}setComponents(e,t,n,o){return this._v[0]=e,this._v[1]=t,this._v[2]=n,this._v[3]=o,this.__updateCount++,this}copyComponents(e){return this.setComponents(e._v[0],e._v[1],e._v[2],e._v[3])}zero(){return this.setComponents(0,0,0,0)}one(){return this.setComponents(1,1,1,1)}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}normalize(){const e=this.length();return this.divide(e),this}normalize3(){const e=Math.hypot(this._v[0],this._v[1],this._v[2]);return this.divide(e),this}add(e){return this._v[0]+=e._v[0],this._v[1]+=e._v[1],this._v[2]+=e._v[2],this._v[3]+=e._v[3],this}subtract(e){return this._v[0]-=e._v[0],this._v[1]-=e._v[1],this._v[2]-=e._v[2],this._v[3]-=e._v[3],this}multiply(e){return this._v[0]*=e,this._v[1]*=e,this._v[2]*=e,this._v[3]*=e,this}multiplyVector(e){return this._v[0]*=e._v[0],this._v[1]*=e._v[1],this._v[2]*=e._v[2],this._v[3]*=e._v[3],this}divide(e){return 0!==e?(this._v[0]/=e,this._v[1]/=e,this._v[2]/=e,this._v[3]/=e):(a.V.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0,this._v[2]=1/0,this._v[3]=1/0),this}divideVector(e){return 0!==e._v[0]&&0!==e._v[1]&&0!==e._v[2]&&0!==e._v[3]?(this._v[0]/=e._v[0],this._v[1]/=e._v[1],this._v[2]/=e._v[2],this._v[3]/=e._v[3]):(a.V.error("0 division occurred!"),this._v[0]=0===e._v[0]?1/0:this._v[0]/e._v[0],this._v[1]=0===e._v[1]?1/0:this._v[1]/e._v[1],this._v[2]=0===e._v[2]?1/0:this._v[2]/e._v[2],this._v[3]=0===e._v[3]?1/0:this._v[3]/e._v[3]),this}get _updateCount(){return this.__updateCount}}class r extends i{constructor(e){super(e,{type:Float32Array})}static fromCopyArray(e){return new r(new Float32Array(e).slice(0,4))}static fromCopyArray4(e){return new r(new Float32Array(e))}static fromCopy4(e,t,n,o){return new r(new Float32Array([e,t,n,o]))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}get className(){return"MutableVector4"}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1],this._v[2],this._v[3]]))}}class s extends i{constructor(e){super(e,{type:Float64Array})}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(e){return super._normalize(e,Float64Array)}static add(e,t){return super._add(e,t,Float64Array)}static subtract(e,t){return super._subtract(e,t,Float64Array)}static multiply(e,t){return super._multiply(e,t,Float64Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float64Array)}static divide(e,t){return super._divide(e,t,Float64Array)}static divideVector(e,t){return super._divideVector(e,t,Float64Array)}static fromCopyArray4(e){return new s(new Float64Array(e))}static fromCopyArray(e){return new s(new Float64Array(e.slice(0,4)))}static fromCopy4(e,t,n,o){return new s(new Float64Array([e,t,n,o]))}clone(){return super.clone()}}},6603:(e,t,n)=>{n.d(t,{P:()=>_});var o=n(6941),a=n(7751),i=n(1289),r=n(975),s=n(5697),l=n(7476),c=n(3497);class _ extends i.x{constructor(e){super(),this._v=e}get className(){return"Quaternion"}static get compositionType(){return a.h.Vec4}static identity(){return _.fromCopy4(0,0,0,1)}static dummy(){return new this(new Float32Array(0))}static invert(e){const t=e.length();if(0===t)return _.fromCopy4(0,0,0,0);const n=-e._v[0]/t,o=-e._v[1]/t,a=-e._v[2]/t,i=e._v[3]/t;return _.fromCopy4(n,o,a,i)}static invertTo(e,t){const n=e.length();return 0===n?t.setComponents(0,0,0,0):(t._v[0]=-e._v[0]/n,t._v[1]=-e._v[1]/n,t._v[2]=-e._v[2]/n,t._v[3]=e._v[3]/n,t)}static qlerp(e,t,n){let o=e._v[0]*t._v[0]+e._v[1]*t._v[1]+e._v[2]*t._v[2]+e._v[3]*t._v[3];if(0==1-o*o)return e.clone();{o>1?o=.999:o<-1&&(o=-.999);let a=Math.acos(o);const i=Math.sin(a);let r;o<0?(o*=-1,a=Math.acos(o),r=-1*Math.sin(a*n)/i):r=Math.sin(a*n)/i;const s=Math.sin(a*(1-n))/i;let l=e._v[0]*s+t._v[0]*r,c=e._v[1]*s+t._v[1]*r,u=e._v[2]*s+t._v[2]*r,f=e._v[3]*s+t._v[3]*r;const d=Math.hypot(l,c,u,f);return l/=d,c/=d,u/=d,f/=d,_.fromCopy4(l,c,u,f)}}static qlerpTo(e,t,n,o){let a=e._v[0]*t._v[0]+e._v[1]*t._v[1]+e._v[2]*t._v[2]+e._v[3]*t._v[3];if(0==1-a*a)return o.copyComponents(e);{a>1?a=.999:a<-1&&(a=-.999);let i=Math.acos(a);const r=Math.sin(i);let s;a<0?(a*=-1,i=Math.acos(a),s=-1*Math.sin(i*n)/r):s=Math.sin(i*n)/r;const l=Math.sin(i*(1-n))/r;o._v[0]=e._v[0]*l+t._v[0]*s,o._v[1]=e._v[1]*l+t._v[1]*s,o._v[2]=e._v[2]*l+t._v[2]*s,o._v[3]=e._v[3]*l+t._v[3]*s}return o.normalize()}static lerp(e,t,n){const o=e._v[0]*(1-n)+t._v[0]*n,a=e._v[1]*(1-n)+t._v[1]*n,i=e._v[2]*(1-n)+t._v[2]*n,r=e._v[3]*(1-n)+t._v[3]*n;return _.fromCopy4(o,a,i,r)}static lerpTo(e,t,n,o){return o._v[0]=e._v[0]*(1-n)+t._v[0]*n,o._v[1]=e._v[1]*(1-n)+t._v[1]*n,o._v[2]=e._v[2]*(1-n)+t._v[2]*n,o._v[3]=e._v[3]*(1-n)+t._v[3]*n,o}static axisAngle(e,t){const n=.5*t,o=Math.sin(n),a=e.length();return 0===a&&c.V.error("0 division occurred!"),_.fromCopy4(o*e._v[0]/a,o*e._v[1]/a,o*e._v[2]/a,Math.cos(n))}static fromMatrix(e){let t=Math.hypot(e.m00,e.m10,e.m20);const n=Math.hypot(e.m01,e.m11,e.m21),o=Math.hypot(e.m02,e.m12,e.m22);e.determinant()<0&&(t=-t);const a=l.g.fromCopyMatrix44(e),i=1/t,r=1/n,s=1/o;a.m00*=i,a.m10*=i,a.m20*=i,a.m01*=r,a.m11*=r,a.m21*=r,a.m02*=s,a.m12*=s,a.m22*=s;const c=a.m00+a.m11+a.m22;if(c>0){const e=.5/Math.sqrt(c+1),t=(a.m21-a.m12)*e,n=(a.m02-a.m20)*e,o=(a.m10-a.m01)*e,i=.25/e;return _.fromCopy4(t,n,o,i)}if(a.m00>a.m11&&a.m00>a.m22){const e=2*Math.sqrt(1+a.m00-a.m11-a.m22),t=.25*e,n=(a.m01+a.m10)/e,o=(a.m02+a.m20)/e,i=(a.m21-a.m12)/e;return _.fromCopy4(t,n,o,i)}if(a.m11>a.m22){const e=2*Math.sqrt(1+a.m11-a.m00-a.m22),t=(a.m01+a.m10)/e,n=.25*e,o=(a.m12+a.m21)/e,i=(a.m02-a.m20)/e;return _.fromCopy4(t,n,o,i)}{const e=2*Math.sqrt(1+a.m22-a.m00-a.m11),t=(a.m02+a.m20)/e,n=(a.m12+a.m21)/e,o=.25*e,i=(a.m10-a.m01)/e;return _.fromCopy4(t,n,o,i)}}static fromMatrixTo(e,t){let n=Math.hypot(e.m00,e.m10,e.m20);const o=Math.hypot(e.m01,e.m11,e.m21),a=Math.hypot(e.m02,e.m12,e.m22);e.determinant()<0&&(n=-n);const i=l.g.fromCopyMatrix44(e),r=1/n,s=1/o,c=1/a;i.m00*=r,i.m10*=r,i.m20*=r,i.m01*=s,i.m11*=s,i.m21*=s,i.m02*=c,i.m12*=c,i.m22*=c;const _=i.m00+i.m11+i.m22;if(_>0){const e=.5/Math.sqrt(_+1);t._v[0]=(i.m21-i.m12)*e,t._v[1]=(i.m02-i.m20)*e,t._v[2]=(i.m10-i.m01)*e,t._v[3]=.25/e}else if(i.m00>i.m11&&i.m00>i.m22){const e=2*Math.sqrt(1+i.m00-i.m11-i.m22);t._v[0]=.25*e,t._v[1]=(i.m01+i.m10)/e,t._v[2]=(i.m02+i.m20)/e,t._v[3]=(i.m21-i.m12)/e}else if(i.m11>i.m22){const e=2*Math.sqrt(1+i.m11-i.m00-i.m22);t._v[0]=(i.m01+i.m10)/e,t._v[1]=.25*e,t._v[2]=(i.m12+i.m21)/e,t._v[3]=(i.m02-i.m20)/e}else{const e=2*Math.sqrt(1+i.m22-i.m00-i.m11);t._v[0]=(i.m02+i.m20)/e,t._v[1]=(i.m12+i.m21)/e,t._v[2]=.25*e,t._v[3]=(i.m10-i.m01)/e}return t}static lookFromTo(e,t){return e.isEqual(t)?_.fromCopy4(0,0,0,1):this.qlerp(this.lookForward(e),this.lookForward(t),1)}static lookForward(e){return null==_.__tmp_upVec&&(_.__tmp_upVec=new e.constructor(0,1,0)),this.lookForwardAccordingToThisUp(e,_.__tmp_upVec)}static lookForwardAccordingToThisUp(e,t){const n=e.length();0===n&&c.V.error("0 division occurred!");const o=e._v[0]/n,a=e._v[1]/n,i=e._v[2]/n,r=t.length();0===r&&c.V.error("0 division occurred!");const s=t._v[0]/r,l=t._v[1]/r,u=t._v[2]/r;let f=t._v[1]*e._v[2]-t._v[2]*e._v[1],d=t._v[2]*e._v[0]-t._v[0]*e._v[2],h=t._v[0]*e._v[1]-t._v[1]*e._v[0];const m=Math.hypot(f,d,h);0===m&&c.V.error("0 division occurred!"),f/=m,d/=m,h/=m;const p=f,v=d,x=h,g=s,y=l,b=u,I=o,A=a,E=i,S=p+y+E;if(S>0){const e=Math.sqrt(S+1),t=.5/e;return _.fromCopy4((b-A)*t,(I-x)*t,(v-g)*t,.5*e)}if(p>=y&&p>=E){const e=Math.sqrt(1+p-y-E),t=.5/e;return _.fromCopy4(.5*e,(v+g)*t,(x+I)*t,(b-A)*t)}if(y>E){const e=Math.sqrt(1+y-p-E),t=.5/e;return _.fromCopy4((g+v)*t,.5*e,(A+b)*t,(I-x)*t)}{const e=Math.sqrt(1+E-p-y),t=.5/e;return _.fromCopy4((I+x)*t,(A+b)*t,.5*e,(v-g)*t)}}static fromPosition(e){return _.fromCopy4(e._v[0],e._v[1],e._v[2],0)}static add(e,t){const n=e._v[0]+t._v[0],o=e._v[1]+t._v[1],a=e._v[2]+t._v[2],i=e._v[3]+t._v[3];return _.fromCopy4(n,o,a,i)}static addTo(e,t,n){return n._v[0]=e._v[0]+t._v[0],n._v[1]=e._v[1]+t._v[1],n._v[2]=e._v[2]+t._v[2],n._v[3]=e._v[3]+t._v[3],n}static subtract(e,t){const n=e._v[0]-t._v[0],o=e._v[1]-t._v[1],a=e._v[2]-t._v[2],i=e._v[3]-t._v[3];return _.fromCopy4(n,o,a,i)}static subtractTo(e,t,n){return n._v[0]=e._v[0]-t._v[0],n._v[1]=e._v[1]-t._v[1],n._v[2]=e._v[2]-t._v[2],n._v[3]=e._v[3]-t._v[3],n}static multiply(e,t){const n=t._v[3]*e._v[0]+t._v[2]*e._v[1]-t._v[1]*e._v[2]+t._v[0]*e._v[3],o=-t._v[2]*e._v[0]+t._v[3]*e._v[1]+t._v[0]*e._v[2]+t._v[1]*e._v[3],a=t._v[1]*e._v[0]-t._v[0]*e._v[1]+t._v[3]*e._v[2]+t._v[2]*e._v[3],i=-t._v[0]*e._v[0]-t._v[1]*e._v[1]-t._v[2]*e._v[2]+t._v[3]*e._v[3];return _.fromCopy4(n,o,a,i)}static multiplyTo(e,t,n){const o=t._v[3]*e._v[0]+t._v[2]*e._v[1]-t._v[1]*e._v[2]+t._v[0]*e._v[3],a=-t._v[2]*e._v[0]+t._v[3]*e._v[1]+t._v[0]*e._v[2]+t._v[1]*e._v[3],i=t._v[1]*e._v[0]-t._v[0]*e._v[1]+t._v[3]*e._v[2]+t._v[2]*e._v[3],r=-t._v[0]*e._v[0]-t._v[1]*e._v[1]-t._v[2]*e._v[2]+t._v[3]*e._v[3];return n.setComponents(o,a,i,r)}static multiplyNumber(e,t){const n=e._v[0]*t,o=e._v[1]*t,a=e._v[2]*t,i=e._v[3]*t;return _.fromCopy4(n,o,a,i)}static multiplyNumberTo(e,t,n){return n._v[0]=e._v[0]*t,n._v[1]=e._v[1]*t,n._v[2]=e._v[2]*t,n._v[3]=e._v[3]*t,n}static divideNumber(e,t){0===t&&c.V.error("0 division occurred!");const n=e._v[0]/t,o=e._v[1]/t,a=e._v[2]/t,i=e._v[3]/t;return _.fromCopy4(n,o,a,i)}static divideNumberTo(e,t,n){return 0===t&&c.V.error("0 division occurred!"),n._v[0]=e._v[0]/t,n._v[1]=e._v[1]/t,n._v[2]=e._v[2]/t,n._v[3]=e._v[3]/t,n}toString(){return"("+this._v[0]+", "+this._v[1]+", "+this._v[2]+", "+this._v[3]+")"}toStringApproximately(){return o.z.financial(this._v[0])+" "+o.z.financial(this._v[1])+" "+o.z.financial(this._v[2])+" "+o.z.financial(this._v[3])+"\n"}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){return Math.abs(e._v[0]-this._v[0])<t&&Math.abs(e._v[1]-this._v[1])<t&&Math.abs(e._v[2]-this._v[2])<t&&Math.abs(e._v[3]-this._v[3])<t}isStrictEqual(e){return this._v[0]===e._v[0]&&this._v[1]===e._v[1]&&this._v[2]===e._v[2]&&this._v[3]===e._v[3]}toEulerAnglesTo(e){const t=2*(this._v[3]*this._v[0]+this._v[1]*this._v[2]),n=1-2*(this._v[0]*this._v[0]+this._v[1]*this._v[1]);e._v[0]=Math.atan2(t,n);let o=2*(this._v[3]*this._v[1]-this._v[2]*this._v[0]);o=o>1?1:o,o=o<-1?-1:o,e._v[1]=Math.asin(o);const a=2*(this._v[3]*this._v[2]+this._v[0]*this._v[1]),i=1-2*(this._v[1]*this._v[1]+this._v[2]*this._v[2]);return e._v[2]=Math.atan2(a,i),e}toEulerAngles(){const e=new r.Pq(new Float32Array(3)),t=2*(this._v[3]*this._v[0]+this._v[1]*this._v[2]),n=1-2*(this._v[0]*this._v[0]+this._v[1]*this._v[1]);e._v[0]=Math.atan2(t,n);let o=2*(this._v[3]*this._v[1]-this._v[2]*this._v[0]);o=o>1?1:o,o=o<-1?-1:o,e._v[1]=Math.asin(o);const a=2*(this._v[3]*this._v[2]+this._v[0]*this._v[1]),i=1-2*(this._v[1]*this._v[1]+this._v[2]*this._v[2]);return e._v[2]=Math.atan2(a,i),e}static _divide(e,t){let n,o,a,i;return 0!==t?(n=e._v[0]/t,o=e._v[1]/t,a=e._v[2]/t,i=e._v[3]/t):(c.V.error("0 division occurred!"),n=1/0,o=1/0,a=1/0,i=1/0),_.fromCopy4(n,o,a,i)}static _divideTo(e,t,n){let o,a,i,r;return 0!==t?(o=e._v[0]/t,a=e._v[1]/t,i=e._v[2]/t,r=e._v[3]/t):(c.V.error("0 division occurred!"),o=1/0,a=1/0,i=1/0,r=1/0),n._v[0]=o,n._v[1]=a,n._v[2]=i,n._v[3]=r,n}static normalize(e){const t=e.length();return this._divide(e,t)}static normalizeTo(e,t){const n=e.length();return this._divideTo(e,n,t)}fromToRotation(e,t){const n=s.tp.fromCopyVector3(e),o=s.tp.fromCopyVector3(t);n.normalize(),o.normalize();const a=n.dot(o);if(a>-1+Number.EPSILON){const e=Math.sqrt(2*(1+a)),t=1/e,i=r.Pq.multiply(n.cross(o),t);return this._v[0]=i.x,this._v[1]=i.y,this._v[2]=i.z,this._v[3]=.5*e,_.normalize(this)}{let e=r.Pq.fromCopy3(0,1,0),t=n.cross(e);return t.length()<Number.EPSILON&&(e=r.Pq.fromCopy3(1,0,0),t=n.cross(e)),t.normalize(),_.fromAxisAngle(t,Math.PI)}}static fromToRotation(e,t){let n=r.Pq.dot(e,t)+1;if(n<Number.EPSILON){if(n=0,Math.abs(e.x)>Math.abs(e.z)){const t=_.fromCopy4(-e.y,e.x,0,n);return _.normalize(t)}{const t=_.fromCopy4(0,-e.z,e.y,n);return _.normalize(t)}}{const o=_.fromCopy4(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x,n);return _.normalize(o)}}static fromToRotationTo(e,t,n){let o=r.Pq.dot(e,t)+1;return o<Number.EPSILON?(o=0,Math.abs(e.x)>Math.abs(e.z)?(n._v[0]=-e.y,n._v[1]=e.x,n._v[2]=0,n._v[3]=o,n.normalize(),n):(n._v[0]=0,n._v[1]=-e.z,n._v[2]=e.y,n._v[3]=o,n.normalize(),n)):(n._v[0]=e.y*t.z-e.z*t.y,n._v[1]=e.z*t.x-e.x*t.z,n._v[2]=e.x*t.y-e.y*t.x,n._v[3]=o,n.normalize(),n)}transformVector3(e){const t=_.__tmp_vec3_5;t.setComponents(this._v[0],this._v[1],this._v[2]);const n=r.Pq.cross(t,e),o=r.Pq.cross(t,n),a=r.Pq.multiply(n,this._v[3]),i=r.Pq.add(o,a),s=r.Pq.multiply(i,2);return r.Pq.add(e,s)}transformVector3To(e,t){const n=_.__tmp_vec3_5;n.setComponents(this._v[0],this._v[1],this._v[2]);const o=r.Pq.crossTo(n,e,_.__tmp_vec3_0),a=r.Pq.crossTo(n,o,_.__tmp_vec3_1),i=r.Pq.multiplyTo(o,this._v[3],_.__tmp_vec3_2),s=r.Pq.addTo(a,i,_.__tmp_vec3_3),l=r.Pq.multiplyTo(s,2,_.__tmp_vec3_4);return r.Pq.addTo(e,l,t)}transformVector3Inverse(e){return _.invert(this).transformVector3(e)}clone(){return _.fromCopy4(this._v[0],this._v[1],this._v[2],this._v[3])}static fromFloat32Array(e){return new _(e)}static fromCopyArray4(e){return new _(new Float32Array(e))}static fromCopyArray(e){return new _(new Float32Array(e.slice(0,4)))}static fromCopy4(e,t,n,o){return new _(new Float32Array([e,t,n,o]))}static fromCopyQuaternion(e){const t=new Float32Array(4);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],t[3]=e._v[3],new _(t)}static fromCopyVector4(e){const t=new Float32Array(4);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],t[3]=e._v[3],new _(t)}static fromCopyLogQuaternion(e){const t=e._v[0]*e._v[0]+e._v[1]*e._v[1]+e._v[2]*e._v[2],n=Math.sin(t),o=new Float32Array(4);return o[0]=e._v[0]*(n/t),o[1]=e._v[1]*(n/t),o[2]=e._v[2]*(n/t),o[3]=Math.cos(t),new _(o)}static fromAxisAngle(e,t){t*=.5;const n=Math.sin(t);return _.fromCopy4(n*e.x,n*e.y,n*e.z,Math.cos(t))}static fromAxisAngleTo(e,t,n){t*=.5;const o=Math.sin(t);return n._v[0]=o*e.x,n._v[1]=o*e.y,n._v[2]=o*e.z,n._v[3]=Math.cos(t),n}static getQuaternionAngle(e){const t=Math.max(-1,Math.min(1,e.w));return 2*Math.acos(t)}static clampRotation(e,t){const n=_.getQuaternionAngle(e);if(n<=t)return e;{const o=t/n,a=_.fromCopy4(0,0,0,1);return _.qlerp(a,e,o)}}}_.__tmp_upVec=void 0,_.__tmp_vec3_0=s.tp.zero(),_.__tmp_vec3_1=s.tp.zero(),_.__tmp_vec3_2=s.tp.zero(),_.__tmp_vec3_3=s.tp.zero(),_.__tmp_vec3_4=s.tp.zero(),_.__tmp_vec3_5=s.tp.zero()},9011:(e,t,n)=>{n.d(t,{Cj:()=>r,X5:()=>s,vQ:()=>l});var o=n(6941),a=n(8422),i=n(7751);class r extends a.c{constructor(e,{type:t}){super(),this._v=e}getValue(){return this._v[0]}getValueInArray(){return[this._v[0]]}get x(){return this._v[0]}get raw(){return this._v}isStrictEqual(e){return this.x===e.x}isEqual(e,t=Number.EPSILON){return Math.abs(e.x-this.x)<t}get glslStrAsFloat(){return`${o.z.convertToStringAsGLSLFloat(this.x)}`}get glslStrAsInt(){return`${Math.floor(this.x)}`}static _fromCopyNumber(e,t){return new this(new t([e]),{type:t})}static _dummy(e){return new this(new e,{type:e})}static get compositionType(){return i.h.Scalar}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}}class s extends r{constructor(e){super(e,{type:Float32Array})}static fromCopyNumber(e){return super._fromCopyNumber(e,Float32Array)}static zero(){return s.fromCopyNumber(0)}static one(){return s.fromCopyNumber(1)}static dummy(){return super._dummy(Float32Array)}get className(){return"Scalar"}toString(){return"("+this._v[0]+")"}clone(){return new s(this._v)}}class l extends r{constructor(e){super(e,{type:Float64Array})}static fromCopyNumber(e){return super._fromCopyNumber(e,Float64Array)}static zero(){return l.fromCopyNumber(0)}static one(){return l.fromCopyNumber(1)}static dummy(){return super._dummy(Float64Array)}clone(){return new l(this._v)}}},4956:(e,t,n)=>{n.d(t,{k:()=>c});var o=n(3870),a=n(7476),i=n(6253),r=n(5697),s=n(6603),l=n(975);class c{constructor(e){this.__updateCount=0,this.__position=r.tp.dummy(),this.__scale=r.tp.dummy(),this.__rotation=i.h.dummy(),void 0!==e?this.setTransform(e.positionInner,e.scaleInner,i.h.fromCopyQuaternion(e.rotationInner)):(this.__position=r.tp.zero(),this.__scale=r.tp.one(),this.__rotation=i.h.identity())}isEqual(e,t=Number.EPSILON){return this.positionInner.isEqual(e.positionInner,t)&&this.rotationInner.isEqual(e.rotationInner,t)&&this.scaleInner.isEqual(e.scaleInner,t)}clone(){return new c(this)}set position(e){this.__position.copyComponents(e),this.__updateTransform()}setPositionAsArray3(e){this.__position._v[0]=e[0],this.__position._v[1]=e[1],this.__position._v[2]=e[2],this.__updateTransform()}get position(){return this.positionInner.clone()}get positionInner(){return this.__position}set eulerAngles(e){const t=Math.sin(.5*e._v[0]),n=Math.cos(.5*e._v[0]),o=Math.sin(.5*e._v[1]),a=Math.cos(.5*e._v[1]),r=Math.sin(.5*e._v[2]),s=Math.cos(.5*e._v[2]);this.rotation=i.h.fromCopy4(t*a*s-n*o*r,n*o*s+t*a*r,n*a*r-t*o*s,n*a*s+t*o*r)}get eulerAngles(){return this.eulerAnglesInner.clone()}get eulerAnglesInner(){return this.__rotation.toEulerAngles()}set scale(e){this.__scale.copyComponents(e),this.__updateTransform()}setScaleAsArray3(e){this.__scale._v[0]=e[0],this.__scale._v[1]=e[1],this.__scale._v[2]=e[2],this.__updateTransform()}get scale(){return this.scaleInner.clone()}get scaleInner(){return this.__scale}set rotation(e){this.__rotation.copyComponents(e),this.__updateTransform()}setRotationAsArray4(e){this.__rotation._v[0]=e[0],this.__rotation._v[1]=e[1],this.__rotation._v[2]=e[2],this.__rotation._v[3]=e[3],this.__updateTransform()}get rotation(){return this.rotationInner.clone()}get rotationInner(){return this.__rotation}__updateTransform(){this.__updateCount++}set matrix(e){this.__rotation.fromMatrix(e),e.getTranslateTo(this.__position),e.getScaleTo(this.__scale),this.__updateTransform()}get matrix(){return this.matrixInner}get matrixInner(){const e=this.scaleInner,t=e._v[0],n=e._v[1],o=e._v[2],i=this.rotationInner,r=i._v[0]*i._v[0],s=i._v[1]*i._v[1],l=i._v[2]*i._v[2],c=i._v[1]*i._v[2],_=i._v[0]*i._v[2],u=i._v[0]*i._v[1],f=i._v[3]*i._v[0],d=i._v[3]*i._v[1],h=i._v[3]*i._v[2],m=1-2*(s+l),p=2*(u-h),v=2*(_+d),x=2*(u+h),g=1-2*(r+l),y=2*(c-f),b=2*(_-d),I=2*(c+f),A=1-2*(r+s),E=this.positionInner;return a.g.fromCopy16RowMajor(m*t,p*n,v*o,E.x,x*t,g*n,y*o,E.y,b*t,I*n,A*o,E.z,0,0,0,1)}getMatrixInnerTo(e){const t=this.scaleInner,n=t._v[0],o=t._v[1],a=t._v[2],i=this.rotationInner,r=i._v[0]*i._v[0],s=i._v[1]*i._v[1],l=i._v[2]*i._v[2],c=i._v[1]*i._v[2],_=i._v[0]*i._v[2],u=i._v[0]*i._v[1],f=i._v[3]*i._v[0],d=i._v[3]*i._v[1],h=i._v[3]*i._v[2],m=1-2*(s+l),p=2*(u-h),v=2*(_+d),x=2*(u+h),g=1-2*(r+l),y=2*(c-f),b=2*(_-d),I=2*(c+f),A=1-2*(r+s),E=this.positionInner;e.setComponents(m*n,p*o,v*a,E.x,x*n,g*o,y*a,E.y,b*n,I*o,A*a,E.z,0,0,0,1)}get updateCount(){return this.__updateCount}set rotateMatrix44(e){this.rotation=c.__tmpQuaternion_0.fromMatrix(e)}get rotateMatrix44(){return o._.fromCopyQuaternion(this.rotation)}setPropertiesFromJson(e){let t=e;"string"==typeof e&&(t=JSON.parse(e));for(const e in t)t.hasOwnProperty(e)&&e in this&&("quaternion"===e?this.rotation=s.P.fromCopyArray4(t[e]):this[e]="matrix"===e?o._.fromCopyArray16RowMajor(t[e]):l.Pq.fromCopyArray(t[e]))}setRotationFromNewUpAndFront(e,t){const n=e,o=r.tp.crossTo(n,t,c.__tmpVector3_0),a=r.tp.crossTo(o,n,c.__tmpVector3_1),i=c.__tmpMatrix44_0.setComponents(o.x,n.x,a.x,0,o.y,n.y,a.y,0,o.z,n.z,a.z,0,0,0,0,1);this.rotateMatrix44=i}headToDirection(e,t){const n=c.__tmpVector3_0.copyComponents(e).normalize(),o=c.__tmpVector3_1.copyComponents(t).normalize(),a=r.tp.crossTo(n,o,c.__tmpVector3_2),i=l.Pq.dot(n,o),s=Math.acos(i);this.rotation=c.__tmpQuaternion_0.axisAngle(a,s)}setTransform(e,t,n){this.__position=e.clone(),this.__rotation=n.clone(),this.__scale=t.clone(),this.__updateTransform()}}c.__tmpMatrix44_0=a.g.zero(),c.__tmpVector3_0=r.tp.zero(),c.__tmpVector3_1=r.tp.zero(),c.__tmpVector3_2=r.tp.zero(),c.__tmpQuaternion_0=i.h.identity()},9936:(e,t,n)=>{n.d(t,{I9:()=>l,VS:()=>s,Z5:()=>_,a2:()=>c,z8:()=>u});var o=n(6941),a=n(7751),i=n(8422),r=n(3497);class s extends i.c{constructor(e,{type:t}){super(),this._v=e}get x(){return this._v[0]}get y(){return this._v[1]}get glslStrAsFloat(){return`vec2(${o.z.convertToStringAsGLSLFloat(this._v[0])}, ${o.z.convertToStringAsGLSLFloat(this._v[1])})`}get glslStrAsInt(){return`ivec2(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])})`}static get compositionType(){return a.h.Vec2}static lengthSquared(e){return e.lengthSquared()}static lengthBtw(e,t){return e.lengthTo(t)}static angleOfVectors(e,t){const n=e.length()*t.length();0===n&&r.V.error("length of a vector is 0!");const o=e.dot(t)/n;return Math.acos(o)}static _zero(e){return this._fromCopyArray2([0,0],e)}static _one(e){return this._fromCopyArray2([1,1],e)}static _dummy(e){return new this(new e,{type:e})}static _normalize(e,t){const n=e.length();return this._divide(e,n,t)}static _add(e,t,n){const o=e._v[0]+t._v[0],a=e._v[1]+t._v[1];return this._fromCopyArray2([o,a],n)}static addTo(e,t,n){return n._v[0]=e._v[0]+t._v[0],n._v[1]=e._v[1]+t._v[1],n}static _subtract(e,t,n){const o=e._v[0]-t._v[0],a=e._v[1]-t._v[1];return this._fromCopyArray2([o,a],n)}static subtractTo(e,t,n){return n._v[0]=e._v[0]-t._v[0],n._v[1]=e._v[1]-t._v[1],n}static _multiply(e,t,n){const o=e._v[0]*t,a=e._v[1]*t;return this._fromCopyArray2([o,a],n)}static multiplyTo(e,t,n){return n._v[0]=e._v[0]*t,n._v[1]=e._v[1]*t,n}static _multiplyVector(e,t,n){const o=e._v[0]*t._v[0],a=e._v[1]*t._v[1];return this._fromCopyArray2([o,a],n)}static multiplyVectorTo(e,t,n){return n._v[0]=e._v[0]*t._v[0],n._v[1]=e._v[1]*t._v[1],n}static _divide(e,t,n){let o,a;return 0!==t?(o=e._v[0]/t,a=e._v[1]/t):(r.V.error("0 division occurred!"),o=1/0,a=1/0),this._fromCopyArray2([o,a],n)}static divideTo(e,t,n){return 0!==t?(n._v[0]=e._v[0]/t,n._v[1]=e._v[1]/t):(r.V.error("0 division occurred!"),n._v[0]=1/0,n._v[1]=1/0),n}static _divideVector(e,t,n){let o,a;return 0!==t._v[0]&&0!==t._v[1]?(o=e._v[0]/t._v[0],a=e._v[1]/t._v[1]):(r.V.error("0 division occurred!"),o=0===t._v[0]?1/0:e._v[0]/t._v[0],a=0===t._v[1]?1/0:e._v[1]/t._v[1]),this._fromCopyArray2([o,a],n)}static divideVectorTo(e,t,n){return 0!==t._v[0]&&0!==t._v[1]?(n._v[0]=e._v[0]/t._v[0],n._v[1]=e._v[1]/t._v[1]):(r.V.error("0 division occurred!"),n._v[0]=0===t._v[0]?1/0:e._v[0]/t._v[0],n._v[1]=0===t._v[1]?1/0:e._v[1]/t._v[1]),n}static dot(e,t){return e.dot(t)}toString(){return"("+this._v[0]+", "+this._v[1]+")"}toStringApproximately(){return o.z.financial(this._v[0])+" "+o.z.financial(this._v[1])+"\n"}flattenAsArray(){return[this._v[0],this._v[1]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){return Math.abs(e._v[0]-this._v[0])<t&&Math.abs(e._v[1]-this._v[1])<t}isStrictEqual(e){return this._v[0]===e._v[0]&&this._v[1]===e._v[1]}at(e){return this._v[e]}length(){return Math.hypot(this._v[0],this._v[1])}lengthSquared(){return this._v[0]**2+this._v[1]**2}lengthTo(e){const t=this._v[0]-e._v[0],n=this._v[1]-e._v[1];return Math.hypot(t,n)}dot(e){return this._v[0]*e._v[0]+this._v[1]*e._v[1]}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1]]))}static _fromCopyArray2(e,t){return new this(new t(e),{type:t})}static _fromCopy2(e,t,n){return new this(new n([e,t]),{type:n})}static _fromCopyArray(e,t){return new this(new t(e.slice(0,2)),{type:t})}static _fromVector2(e,t){return new this(new t(e._v),{type:t})}static _fromCopyVector2(e,t){return new this(new t([e._v[0],e._v[1]]),{type:t})}static _fromCopyVector3(e,t){return new this(new t([e._v[0],e._v[1],e._v[2]]),{type:t})}static _fromCopyVector4(e,t){return new this(new t([e._v[0],e._v[1],e._v[2]]),{type:t})}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}}class l extends s{constructor(e){super(e,{type:Float32Array})}static fromCopyArray2(e){return super._fromCopyArray2(e,Float32Array)}static fromCopy2(e,t){return super._fromCopy2(e,t,Float32Array)}static fromCopyArray(e){return super._fromCopyArray(e,Float32Array)}static fromCopyVector2(e){return super._fromCopyVector2(e,Float32Array)}static fromCopyVector4(e){return super._fromCopyVector4(e,Float32Array)}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}get className(){return"Vector2"}clone(){return super.clone()}}class c extends s{constructor(e){super(e,{type:Float64Array})}static fromCopyArray2(e){return super._fromCopyArray2(e,Float64Array)}static fromCopy2(e,t){return super._fromCopy2(e,t,Float64Array)}static fromCopyArray(e){return super._fromCopyArray(e,Float64Array)}static fromArrayBuffer(e){return new c(new Float64Array(e))}static fromFloat64Array(e){return new c(e)}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(e){return super._normalize(e,Float64Array)}static add(e,t){return super._add(e,t,Float64Array)}static subtract(e,t){return super._subtract(e,t,Float64Array)}static multiply(e,t){return super._multiply(e,t,Float64Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float64Array)}static divide(e,t){return super._divide(e,t,Float64Array)}static divideVector(e,t){return super._divideVector(e,t,Float64Array)}clone(){return super.clone()}}const _=l.fromCopy2(1,1),u=l.fromCopy2(0,0)},975:(e,t,n)=>{n.d(t,{HQ:()=>u,Pq:()=>l,oD:()=>_,pG:()=>c,wr:()=>s});var o=n(6941),a=n(7751),i=n(8422),r=n(3497);class s extends i.c{constructor(e,{type:t}){super(),this._v=e}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return 1}get glslStrAsFloat(){return`vec3(${o.z.convertToStringAsGLSLFloat(this._v[0])}, ${o.z.convertToStringAsGLSLFloat(this._v[1])}, ${o.z.convertToStringAsGLSLFloat(this._v[2])})`}get glslStrAsInt(){return`ivec3(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])}, ${Math.floor(this._v[2])})`}static get compositionType(){return a.h.Vec3}static lengthSquared(e){return e.lengthSquared()}static lengthBtw(e,t){return e.lengthTo(t)}static angleOfVectors(e,t){const n=e.length()*t.length();0===n&&r.V.error("length of a vector is 0!");const o=e.dot(t)/n;return Math.acos(o)}static _zero(e){return this._fromCopyArray([0,0,0],e)}static _one(e){return this._fromCopyArray([1,1,1],e)}static _dummy(e){return new this(new e([]),{type:e})}static _normalize(e,t){const n=e.length();return this._divide(e,n,t)}static normalizeTo(e,t){const n=e.length();return this.divideTo(e,n,t),t}static _add(e,t,n){const o=e._v[0]+t._v[0],a=e._v[1]+t._v[1],i=e._v[2]+t._v[2];return this._fromCopyArray([o,a,i],n)}static addTo(e,t,n){return n._v[0]=e._v[0]+t._v[0],n._v[1]=e._v[1]+t._v[1],n._v[2]=e._v[2]+t._v[2],n}static _subtract(e,t,n){const o=e._v[0]-t._v[0],a=e._v[1]-t._v[1],i=e._v[2]-t._v[2];return this._fromCopyArray([o,a,i],n)}static subtractTo(e,t,n){return n._v[0]=e._v[0]-t._v[0],n._v[1]=e._v[1]-t._v[1],n._v[2]=e._v[2]-t._v[2],n}static _multiply(e,t,n){const o=e._v[0]*t,a=e._v[1]*t,i=e._v[2]*t;return this._fromCopyArray([o,a,i],n)}static multiplyTo(e,t,n){return n._v[0]=e._v[0]*t,n._v[1]=e._v[1]*t,n._v[2]=e._v[2]*t,n}static _multiplyVector(e,t,n){const o=e._v[0]*t._v[0],a=e._v[1]*t._v[1],i=e._v[2]*t._v[2];return this._fromCopyArray([o,a,i],n)}static multiplyVectorTo(e,t,n){return n._v[0]=e._v[0]*t._v[0],n._v[1]=e._v[1]*t._v[1],n._v[2]=e._v[2]*t._v[2],n}static _multiplyMatrix4(e,t,n){const o=e._v[0],a=e._v[1],i=e._v[2],r=1/(t._v[3]*o+t._v[7]*a+t._v[11]*i+t._v[15]),s=(t._v[0]*o+t._v[4]*a+t._v[8]*i+t._v[12])*r,l=(t._v[1]*o+t._v[5]*a+t._v[9]*i+t._v[13])*r,c=(t._v[2]*o+t._v[6]*a+t._v[10]*i+t._v[14])*r;return this._fromCopyArray([s,l,c],n)}static _divide(e,t,n){let o,a,i;return 0!==t?(o=e._v[0]/t,a=e._v[1]/t,i=e._v[2]/t):(r.V.error("0 division occurred!"),o=1/0,a=1/0,i=1/0),this._fromCopyArray([o,a,i],n)}static divideTo(e,t,n){return 0!==t?(n._v[0]=e._v[0]/t,n._v[1]=e._v[1]/t,n._v[2]=e._v[2]/t):(r.V.error("0 division occurred!"),n._v[0]=1/0,n._v[1]=1/0,n._v[2]=1/0),n}static _divideVector(e,t,n){let o,a,i;return 0!==t._v[0]&&0!==t._v[1]&&0!==t._v[2]?(o=e._v[0]/t._v[0],a=e._v[1]/t._v[1],i=e._v[2]/t._v[2]):(r.V.error("0 division occurred!"),o=0===t._v[0]?1/0:e._v[0]/t._v[0],a=0===t._v[1]?1/0:e._v[1]/t._v[1],i=0===t._v[2]?1/0:e._v[2]/t._v[2]),this._fromCopyArray([o,a,i],n)}static divideVectorTo(e,t,n){return 0!==t._v[0]&&0!==t._v[1]&&0!==t._v[2]?(n._v[0]=e._v[0]/t._v[0],n._v[1]=e._v[1]/t._v[1],n._v[2]=e._v[2]/t._v[2]):(r.V.error("0 division occurred!"),n._v[0]=0===t._v[0]?1/0:e._v[0]/t._v[0],n._v[1]=0===t._v[1]?1/0:e._v[1]/t._v[1],n._v[2]=0===t._v[2]?1/0:e._v[2]/t._v[2]),n}static dot(e,t){return e.dot(t)}static _cross(e,t,n){const o=e._v[1]*t._v[2]-e._v[2]*t._v[1],a=e._v[2]*t._v[0]-e._v[0]*t._v[2],i=e._v[0]*t._v[1]-e._v[1]*t._v[0];return this._fromCopyArray([o,a,i],n)}static crossTo(e,t,n){const o=e._v[1]*t._v[2]-e._v[2]*t._v[1],a=e._v[2]*t._v[0]-e._v[0]*t._v[2],i=e._v[0]*t._v[1]-e._v[1]*t._v[0];return n.setComponents(o,a,i)}static _multiplyQuaternion(e,t,n){const o=2*e._v[0],a=2*e._v[1],i=2*e._v[2],r=e._v[0]*o,s=e._v[1]*a,l=e._v[2]*i,c=e._v[0]*a,_=e._v[0]*i,u=e._v[1]*i,f=e._v[3]*o,d=e._v[3]*a,h=e._v[3]*i,m=(1-(s+l))*t._v[0]+(c-h)*t._v[1]+(_+d)*t._v[2],p=(c+h)*t._v[0]+(1-(r+l))*t._v[1]+(u-f)*t._v[2],v=(_-d)*t._v[0]+(u+f)*t._v[1]+(1-(r+s))*t._v[2];return this._fromCopyArray([m,p,v],n)}static multiplyQuaternionTo(e,t,n){const o=2*e._v[0],a=2*e._v[1],i=2*e._v[2],r=e._v[0]*o,s=e._v[1]*a,l=e._v[2]*i,c=e._v[0]*a,_=e._v[0]*i,u=e._v[1]*i,f=e._v[3]*o,d=e._v[3]*a,h=e._v[3]*i,m=(1-(s+l))*t._v[0]+(c-h)*t._v[1]+(_+d)*t._v[2],p=(c+h)*t._v[0]+(1-(r+l))*t._v[1]+(u-f)*t._v[2],v=(_-d)*t._v[0]+(u+f)*t._v[1]+(1-(r+s))*t._v[2];return n.setComponents(m,p,v)}toString(){return"("+this._v[0]+", "+this._v[1]+", "+this._v[2]+")"}toStringApproximately(){return o.z.financial(this._v[0])+" "+o.z.financial(this._v[1])+" "+o.z.financial(this._v[2])+"\n"}flattenAsArray(){return[this._v[0],this._v[1],this._v[2]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){return Math.abs(e._v[0]-this._v[0])<t&&Math.abs(e._v[1]-this._v[1])<t&&Math.abs(e._v[2]-this._v[2])<t}isStrictEqual(e){return this._v[0]===e._v[0]&&this._v[1]===e._v[1]&&this._v[2]===e._v[2]}at(e){return this._v[e]}length(){return Math.hypot(this._v[0],this._v[1],this._v[2])}lengthSquared(){return this._v[0]**2+this._v[1]**2+this._v[2]**2}lengthTo(e){const t=this._v[0]-e._v[0],n=this._v[1]-e._v[1],o=this._v[2]-e._v[2];return Math.hypot(t,n,o)}dot(e){return this._v[0]*e._v[0]+this._v[1]*e._v[1]+this._v[2]*e._v[2]}get className(){return"Vector3"}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1],this._v[2]],0,0))}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}static _lerp(e,t,n,o){return new this(new o([e._v[0]*(1-n)+t._v[0]*n,e._v[1]*(1-n)+t._v[1]*n,e._v[2]*(1-n)+t._v[2]*n]),{type:o})}static _fromCopyArray3(e,t){return new this(new t(e),{type:t})}static _fromCopy3(e,t,n,o){return new this(new o([e,t,n]),{type:o})}static _fromCopyArray(e,t){return new this(new t(e.slice(0,3)),{type:t})}static _fromCopyVector3(e,t){return new this(new t([e._v[0],e._v[1],e._v[2]]),{type:t})}static _fromCopyVector4(e,t){return new this(new t([e._v[0],e._v[1],e._v[2]]),{type:t})}static _fromVector2(e,t){return new this(new t([e._v[0],e._v[1],0]),{type:t})}}class l extends s{constructor(e){super(e,{type:Float32Array})}static fromCopyArray3(e){return super._fromCopyArray3(e,Float32Array)}static fromCopy3(e,t,n){return super._fromCopy3(e,t,n,Float32Array)}static fromCopy1(e){return super._fromCopy3(e,e,e,Float32Array)}static fromCopyArray(e){return super._fromCopyArray(e,Float32Array)}static fromCopyVector3(e){return super._fromCopyVector3(e,Float32Array)}static fromCopyVector4(e){return super._fromCopyVector4(e,Float32Array)}static fromArrayBuffer(e){return new l(new Float32Array(e))}static fromFloat32Array(e){return new l(e)}static fromCopyFloat32Array(e){return new l(e.slice(0))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static multiplyMatrix4(e,t){return super._multiplyMatrix4(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}static cross(e,t){return super._cross(e,t,Float32Array)}static multiplyQuaternion(e,t){return super._multiplyQuaternion(e,t,Float32Array)}static lerp(e,t,n){return super._lerp(e,t,n,Float32Array)}}class c extends s{constructor(e){super(e,{type:Float64Array})}static fromCopyArray3(e){return super._fromCopyArray3(e,Float64Array)}static fromCopy3(e,t,n){return super._fromCopy3(e,t,n,Float64Array)}static fromCopy1(e){return super._fromCopy3(e,e,e,Float64Array)}static fromCopyArray(e){return super._fromCopyArray(e,Float64Array)}static fromArrayBuffer(e){return new c(new Float64Array(e))}static fromFloat64Array(e){return new c(e)}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(e){return super._normalize(e,Float64Array)}static add(e,t){return super._add(e,t,Float64Array)}static subtract(e,t){return super._subtract(e,t,Float64Array)}static multiply(e,t){return super._multiply(e,t,Float64Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float64Array)}static multiplyMatrix4(e,t){return super._multiplyMatrix4(e,t,Float64Array)}static divide(e,t){return super._divide(e,t,Float64Array)}static divideVector(e,t){return super._divideVector(e,t,Float64Array)}static cross(e,t){return super._cross(e,t,Float64Array)}static multiplyQuaternion(e,t){return super._multiplyQuaternion(e,t,Float64Array)}static lerp(e,t,n){return super._lerp(e,t,n,Float64Array)}}const _=l.fromCopy3(1,1,1),u=l.fromCopy3(0,0,0)},3414:(e,t,n)=>{n.d(t,{Em:()=>c,IU:()=>l,TB:()=>f,X9:()=>_,_d:()=>u,xn:()=>s});var o=n(6941),a=n(7751),i=n(8422),r=n(3497);class s extends i.c{constructor(e,{type:t}){super(),this._v=e}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return this._v[3]}get glslStrAsFloat(){return`vec4(${o.z.convertToStringAsGLSLFloat(this._v[0])}, ${o.z.convertToStringAsGLSLFloat(this._v[1])}, ${o.z.convertToStringAsGLSLFloat(this._v[2])}, ${o.z.convertToStringAsGLSLFloat(this._v[3])})`}get glslStrAsInt(){return`ivec4(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])}, ${Math.floor(this._v[2])}, ${Math.floor(this._v[3])})`}static _fromCopyArray4(e,t){return new this(new t(e),{type:t})}static _fromCopy4(e,t,n,o,a){return new this(new a([e,t,n,o]),{type:a})}static _fromCopyArray(e,t){return new this(new t(e.slice(0,4)),{type:t})}static _fromCopyVector4(e,t){return new this(new t([e._v[0],e._v[1],e._v[2],e._v[3]]),{type:t})}static _fromCopyVector3(e,t){return new this(new t([e._v[0],e._v[1],e._v[2],1]),{type:t})}static _fromVector2(e,t){return new this(new t([e._v[0],e._v[1],0,1]),{type:t})}static get compositionType(){return a.h.Vec4}static lengthSquared(e){return e.lengthSquared()}static lengthBtw(e,t){return e.lengthTo(t)}static _zero(e){return new this(new e([0,0,0,0]),{type:e})}static _one(e){return new this(new e([1,1,1,1]),{type:e})}static _dummy(e){return new this(new e([]),{type:e})}static _normalize(e,t){const n=e.length();return this._divide(e,n,t)}static _add(e,t,n){return new this(new n([e._v[0]+t._v[0],e._v[1]+t._v[1],e._v[2]+t._v[2],e._v[3]+t._v[3]]),{type:n})}static addTo(e,t,n){return n._v[0]=e._v[0]+t._v[0],n._v[1]=e._v[1]+t._v[1],n._v[2]=e._v[2]+t._v[2],n._v[3]=e._v[3]+t._v[3],n}static _subtract(e,t,n){return new this(new n([e._v[0]-t._v[0],e._v[1]-t._v[1],e._v[2]-t._v[2],e._v[3]-t._v[3]]),{type:n})}static subtractTo(e,t,n){return n._v[0]=e._v[0]-t._v[0],n._v[1]=e._v[1]-t._v[1],n._v[2]=e._v[2]-t._v[2],n._v[3]=e._v[3]-t._v[3],n}static _multiply(e,t,n){return new this(new n([e._v[0]*t,e._v[1]*t,e._v[2]*t,e._v[3]*t]),{type:n})}static multiplyTo(e,t,n){return n._v[0]=e._v[0]*t,n._v[1]=e._v[1]*t,n._v[2]=e._v[2]*t,n._v[3]=e._v[3]*t,n}static _multiplyVector(e,t,n){return new this(new n([e._v[0]*t._v[0],e._v[1]*t._v[1],e._v[2]*t._v[2],e._v[3]*t._v[3]]),{type:n})}static multiplyVectorTo(e,t,n){return n._v[0]=e._v[0]*t._v[0],n._v[1]=e._v[1]*t._v[1],n._v[2]=e._v[2]*t._v[2],n._v[3]=e._v[3]*t._v[3],n}static _divide(e,t,n){let o,a,i,s;return 0!==t?(o=e._v[0]/t,a=e._v[1]/t,i=e._v[2]/t,s=e._v[3]/t):(r.V.error("0 division occurred!"),o=1/0,a=1/0,i=1/0,s=1/0),new this(new n([o,a,i,s]),{type:n})}static divideTo(e,t,n){return 0!==t?(n._v[0]=e._v[0]/t,n._v[1]=e._v[1]/t,n._v[2]=e._v[2]/t,n._v[3]=e._v[3]/t):(r.V.error("0 division occurred!"),n._v[0]=1/0,n._v[1]=1/0,n._v[2]=1/0,n._v[3]=1/0),n}static _divideVector(e,t,n){let o,a,i,s;return 0!==t._v[0]&&0!==t._v[1]&&0!==t._v[2]&&0!==t._v[3]?(o=e._v[0]/t._v[0],a=e._v[1]/t._v[1],i=e._v[2]/t._v[2],s=e._v[3]/t._v[3]):(r.V.error("0 division occurred!"),o=0===t._v[0]?1/0:e._v[0]/t._v[0],a=0===t._v[1]?1/0:e._v[1]/t._v[1],i=0===t._v[2]?1/0:e._v[2]/t._v[2],s=0===t._v[3]?1/0:e._v[3]/t._v[3]),new this(new n([o,a,i,s]),{type:n})}static divideVectorTo(e,t,n){return 0!==t._v[0]&&0!==t._v[1]&&0!==t._v[2]&&0!==t._v[3]?(n._v[0]=e._v[0]/t._v[0],n._v[1]=e._v[1]/t._v[1],n._v[2]=e._v[2]/t._v[2],n._v[3]=e._v[3]/t._v[3]):(r.V.error("0 division occurred!"),n._v[0]=0===t._v[0]?1/0:e._v[0]/t._v[0],n._v[1]=0===t._v[1]?1/0:e._v[1]/t._v[1],n._v[2]=0===t._v[2]?1/0:e._v[2]/t._v[2],n._v[3]=0===t._v[3]?1/0:e._v[3]/t._v[3]),n}static dot(e,t){return e.dot(t)}toString(){return"("+this._v[0]+", "+this._v[1]+", "+this._v[2]+", "+this._v[3]+")"}toStringApproximately(){return o.z.financial(this._v[0])+" "+o.z.financial(this._v[1])+" "+o.z.financial(this._v[2])+" "+o.z.financial(this._v[3])+"\n"}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3]]}isDummy(){return 0===this._v.length}isEqual(e,t=Number.EPSILON){return Math.abs(e._v[0]-this._v[0])<t&&Math.abs(e._v[1]-this._v[1])<t&&Math.abs(e._v[2]-this._v[2])<t&&Math.abs(e._v[3]-this._v[3])<t}isStrictEqual(e){return this._v[0]===e._v[0]&&this._v[1]===e._v[1]&&this._v[2]===e._v[2]&&this._v[3]===e._v[3]}at(e){return this._v[e]}length(){return Math.hypot(this._v[0],this._v[1],this._v[2],this._v[3])}lengthSquared(){return this._v[0]**2+this._v[1]**2+this._v[2]**2+this._v[3]**2}lengthTo(e){const t=this._v[0]-e._v[0],n=this._v[1]-e._v[1],o=this._v[2]-e._v[2],a=this._v[3]-e._v[3];return Math.hypot(t,n,o,a)}dot(e){return this._v[0]*e._v[0]+this._v[1]*e._v[1]+this._v[2]*e._v[2]+this._v[3]*e._v[3]}get className(){return"Vector4"}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1],this._v[2],this._v[3]]))}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}}class l extends s{constructor(e){super(e,{type:Float32Array})}static fromCopyArray(e){return super._fromCopyArray(e,Float32Array)}static fromCopyArray4(e){return super._fromCopyArray4(e,Float32Array)}static fromCopy4(e,t,n,o){return super._fromCopy4(e,t,n,o,Float32Array)}static fromCopyVector3(e){return super._fromCopyVector3(e,Float32Array)}static fromCopyVector4(e){return super._fromCopyVector4(e,Float32Array)}static fromArrayBuffer(e){return new l(new Float32Array(e))}static fromFloat32Array(e){return new l(e)}static fromCopyFloat32Array(e){return new l(e.slice(0))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}clone(){return super.clone()}}class c extends s{constructor(e){super(e,{type:Float64Array})}static fromCopyArray4(e){return super._fromCopyArray4(e,Float64Array)}static fromCopy4(e,t,n,o){return super._fromCopy4(e,t,n,o,Float64Array)}static fromCopyArray(e){return super._fromCopyArray(e,Float64Array)}static fromArrayBuffer(e){return new c(new Float64Array(e))}static fromFloat64Array(e){return new c(e)}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(e){return super._normalize(e,Float64Array)}static add(e,t){return super._add(e,t,Float64Array)}static subtract(e,t){return super._subtract(e,t,Float64Array)}static multiply(e,t){return super._multiply(e,t,Float64Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float64Array)}static divide(e,t){return super._divide(e,t,Float64Array)}static divideVector(e,t){return super._divideVector(e,t,Float64Array)}clone(){return super.clone()}}const _=l.fromCopy4(1,1,1,1),u=l.fromCopy4(0,0,0,1),f=l.fromCopy4(0,0,0,0)},1124:(e,t,n)=>{n.d(t,{u:()=>o});class o{constructor(e){this._v=e}}},6227:(e,t,n)=>{n.d(t,{F5:()=>a.F,Q$:()=>i,y3:()=>r.y,xR:()=>s.x,cD:()=>l.c,xx:()=>c.x,q$:()=>u,Hj:()=>d,Rd:()=>f,z8:()=>B.z8,Z5:()=>B.Z5,HQ:()=>L.HQ,oD:()=>L.oD,TB:()=>_.TB,_d:()=>_._d,X9:()=>_.X9,q_:()=>h.q,qp:()=>m.q,jZ:()=>v,nx:()=>x.n,St:()=>g.z,qS:()=>y.q,kU:()=>b.k,_0:()=>I._,$C:()=>E,OX:()=>T,Qx:()=>w.Q,_b:()=>C._,gJ:()=>R.g,hY:()=>P.h,n9:()=>N.n9,eZ:()=>N.eZ,Zt:()=>N.Zt,A3:()=>M.A3,ly:()=>M.ly,eE:()=>M.eE,tp:()=>A.tp,Qj:()=>A.Qj,vv:()=>A.vv,Am:()=>S.Am,HO:()=>S.HO,aJ:()=>S.aJ,PT:()=>p.P,X5:()=>D.X5,Cj:()=>D.Cj,vQ:()=>D.vQ,kJ:()=>F.k,I9:()=>B.I9,VS:()=>B.VS,a2:()=>B.a2,Pq:()=>L.Pq,wr:()=>L.wr,pG:()=>L.pG,IU:()=>_.IU,xn:()=>_.xn,Em:()=>_.Em,uS:()=>V.u,QA:()=>o.QA,oz:()=>o.oz,XT:()=>o.XT,VQ:()=>o.VQ,cL:()=>o.cL,e7:()=>o.e7,z$:()=>o.z$,UL:()=>o.UL,et:()=>o.et,uq:()=>o.uq,k0:()=>o.k0,Lu:()=>o.Lu,Nd:()=>o.Nd,BN:()=>o.BN,S8:()=>o.S8,wQ:()=>o.wQ,sb:()=>o.sb,ZK:()=>o.ZK,J6:()=>o.J6,R8:()=>o.R8,VH:()=>o.VH,xZ:()=>o.xZ,P4:()=>o.P4,gp:()=>o.gp,G9:()=>o.G9,cS:()=>o.cS,Nj:()=>o.Nj,z9:()=>o.z9,db:()=>o.db});var o=n(8454),a=n(3629);class i{constructor(){this._v=new Float32Array}isTheSourceSame(e){return this._v.buffer===e}}var r=n(640),s=n(1289),l=n(8422),c=n(1525),_=n(3414);class u extends _.IU{constructor(e){super(e)}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return this._v[3]}get r(){return this._v[0]}get g(){return this._v[1]}get b(){return this._v[2]}get a(){return this._v[3]}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}clone(){return super.clone()}static fromCopyArray(e){return this._fromCopyArray(e,Float32Array)}static fromCopyArray4(e){return this._fromCopyArray4(e,Float32Array)}static fromCopy4(e,t,n,o){return this._fromCopy4(e,t,n,o,Float32Array)}static fromCopyVector4(e){return this._fromCopyVector4(e,Float32Array)}}const f=new u(new Float32Array([1,1,1,1])),d=new u(new Float32Array([0,0,0,1]));var h=n(6222),m=n(4992),p=n(6603);class v{constructor(e){this._v=e}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return 1}static fromFloat32Array(e){return new v(e)}static fromCopyArray3(e){return new p.P(new Float32Array(e))}static fromCopyArray(e){return new p.P(new Float32Array(e.slice(0,3)))}static fromCopy3(e,t,n){return new p.P(new Float32Array([e,t,n]))}static fromCopyLogQuaternion(e){const t=new Float32Array(3);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],new p.P(t)}static fromCopyVector4(e){const t=new Float32Array(3);return t[0]=e._v[0],t[1]=e._v[1],t[2]=e._v[2],new p.P(t)}static fromCopyQuaternion(e){const t=Math.acos(e.w),n=Math.sin(t),o=new Float32Array(3);return o[0]=e.x*(t/n),o[1]=e.y*(t/n),o[2]=e.z*(t/n),new v(o)}get className(){return"LogQuaternion"}}var x=n(8805),g=n(6941),y=n(8718),b=n(8068),I=n(3870),A=n(5697);class E extends A.tp{constructor(e){super(e)}get x(){return this._v[0]}set x(e){this._v[0]=e}get y(){return this._v[1]}set y(e){this._v[1]=e}get z(){return this._v[2]}set z(e){this._v[2]=e}get w(){return 1}get r(){return this._v[0]}set r(e){this._v[0]=e}get g(){return this._v[1]}set g(e){this._v[1]=e}get b(){return this._v[2]}set b(e){this._v[2]=e}get a(){return 1}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}static cross(e,t){return super._cross(e,t,Float32Array)}clone(){return super.clone()}}var S=n(8924);class T extends S.Am{constructor(e){super(e)}get x(){return this._v[0]}set x(e){this._v[0]=e}get y(){return this._v[1]}set y(e){this._v[1]=e}get z(){return this._v[2]}set z(e){this._v[2]=e}get w(){return this._v[3]}set w(e){this._v[3]=e}get r(){return this._v[0]}set r(e){this._v[0]=e}get g(){return this._v[1]}set g(e){this._v[1]=e}get b(){return this._v[2]}set b(e){this._v[2]=e}get a(){return this._v[3]}set a(e){this._v[3]=e}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(e){return super._normalize(e,Float32Array)}static add(e,t){return super._add(e,t,Float32Array)}static subtract(e,t){return super._subtract(e,t,Float32Array)}static multiply(e,t){return super._multiply(e,t,Float32Array)}static multiplyVector(e,t){return super._multiplyVector(e,t,Float32Array)}static divide(e,t){return super._divide(e,t,Float32Array)}static divideVector(e,t){return super._divideVector(e,t,Float32Array)}clone(){return super.clone()}}var w=n(5572),C=n(2162),R=n(7476),P=n(6253),N=n(1881),M=n(5882),D=n(9011),F=n(4956),B=n(9936),L=n(975),V=n(1124)},8454:(e,t,n)=>{n.d(t,{BN:()=>l,G9:()=>E,J6:()=>d,Lu:()=>r,Nd:()=>s,Nj:()=>N,P4:()=>I,QA:()=>v,R8:()=>h,S8:()=>c,UL:()=>P,VH:()=>m,VQ:()=>y,XT:()=>g,ZK:()=>f,cL:()=>b,cS:()=>S,db:()=>C,e7:()=>T,et:()=>o,gp:()=>A,k0:()=>i,oz:()=>x,sb:()=>u,uq:()=>a,wQ:()=>_,xZ:()=>p,z$:()=>R,z9:()=>w});const o=Symbol("get1"),a=Symbol("get1_offset"),i=Symbol("get1_offsetAsComposition"),r=Symbol("get2"),s=Symbol("get2_offset"),l=Symbol("get2_offsetAsComposition"),c=Symbol("get3"),_=Symbol("get3_offset"),u=Symbol("get3_offsetAsComposition"),f=Symbol("get4"),d=Symbol("get4_offset"),h=Symbol("get4_offsetAsComposition"),m=Symbol("getN_offset"),p=Symbol("getN_offsetAsComposition"),v=Symbol("add2"),x=Symbol("add2_offset"),g=Symbol("add3"),y=Symbol("add3_offset"),b=Symbol("add4"),I=Symbol("mulArray3WithScalar_offset"),A=Symbol("mulArray4WithScalar_offset"),E=Symbol("mulArrayNWithScalar_offset"),S=Symbol("mulThatAndThisToOutAsMat44_offsetAsComposition"),T=Symbol("add4_offset"),w=Symbol("qlerp_offsetAsComposition"),C=Symbol("scalar_lerp_offsetAsComposition"),R=Symbol("array3_lerp_offsetAsComposition"),P=Symbol("arrayN_lerp_offsetAsComposition"),N=Symbol("normalizeArray4"),M=[Array,Float32Array,Float64Array,Int8Array,Int16Array,Int32Array,Uint8Array,Uint16Array,Uint32Array],D=[i,l,o,a,r,s,c,_,u,f,d,h,m,p,v,x,g,y,b,T,I,A,E,S,w,C,R,P,N],F=[function(e){return[this[e]]},function(e){return[this[2*e],this[2*e+1]]},function(){return[this[0]]},function(e){return[this[e]]},function(){return[this[0],this[1]]},function(e){return[this[e],this[e+1]]},function(){return[this[0],this[1],this[2]]},function(e){return[this[e],this[e+1],this[e+2]]},function(e){return[this[3*e],this[3*e+1],this[3*e+2]]},function(){return[this[0],this[1],this[2],this[3]]},function(e){return[this[e],this[e+1],this[e+2],this[e+3]]},function(e){return[this[4*e],this[4*e+1],this[4*e+2],this[4*e+3]]},function(e,t){const n=new Array(t);for(let o=0;o<t;o++)n[o]=this[e+o];return n},function(e,t){const n=new Array(t);for(let o=0;o<t;o++)n[o]=this[e*t+o];return n},function(e){return this[0]+=e[0],this[1]+=e[1],this},function(e,t,n){return this[t]+=e[n],this[t+1]+=e[n+1],this},function(e){return this[0]+=e[0],this[1]+=e[1],this[2]+=e[2],this},function(e,t,n){return this[t]+=e[n],this[t+1]+=e[n+1],this[t+2]+=e[n+2],this},function(e){return this[0]+=e[0],this[1]+=e[1],this[2]+=e[2],this[3]+=e[3],this},function(e,t,n){return this[t]+=e[n],this[t+1]+=e[n+1],this[t+2]+=e[n+2],this[t+3]+=e[n+3],this},function(e,t){return this[e]*=t,this[e+1]*=t,this[e+2]*=t,this},function(e,t){return this[e]*=t,this[e+1]*=t,this[e+2]*=t,this[e+3]*=t,this},function(e,t,n){for(let o=0;o<t;o++)this[e+o]*=n;return this},function(e,t,n,o){const a=t,i=this,r=16*n,s=16*e;o[0]=a[r]*i[s]+a[r+4]*i[s+1]+a[r+8]*i[s+2]+a[r+12]*i[s+3],o[1]=a[r+1]*i[s]+a[r+5]*i[s+1]+a[r+9]*i[s+2]+a[r+13]*i[s+3],o[2]=a[r+2]*i[s]+a[r+6]*i[s+1]+a[r+10]*i[s+2]+a[r+14]*i[s+3],o[3]=a[r+3]*i[s]+a[r+7]*i[s+1]+a[r+11]*i[s+2]+a[r+15]*i[s+3],o[4]=a[r]*i[s+4]+a[r+4]*i[s+5]+a[r+8]*i[s+6]+a[r+12]*i[s+7],o[5]=a[r+1]*i[s+4]+a[r+5]*i[s+5]+a[r+9]*i[s+6]+a[r+13]*i[s+7],o[6]=a[r+2]*i[s+4]+a[r+6]*i[s+5]+a[r+10]*i[s+6]+a[r+14]*i[s+7],o[7]=a[r+3]*i[s+4]+a[r+7]*i[s+5]+a[r+11]*i[s+6]+a[r+15]*i[s+7],o[8]=a[r]*i[s+8]+a[r+4]*i[s+9]+a[r+8]*i[s+10]+a[r+12]*i[s+11],o[9]=a[r+1]*i[s+8]+a[r+5]*i[s+9]+a[r+9]*i[s+10]+a[r+13]*i[s+11],o[10]=a[r+2]*i[s+8]+a[r+6]*i[s+9]+a[r+10]*i[s+10]+a[r+14]*i[s+11],o[11]=a[r+3]*i[s+8]+a[r+7]*i[s+9]+a[r+11]*i[s+10]+a[r+15]*i[s+11],o[12]=a[r]*i[s+12]+a[r+4]*i[s+13]+a[r+8]*i[s+14]+a[r+12]*i[s+15],o[13]=a[r+1]*i[s+12]+a[r+5]*i[s+13]+a[r+9]*i[s+14]+a[r+13]*i[s+15],o[14]=a[r+2]*i[s+12]+a[r+6]*i[s+13]+a[r+10]*i[s+14]+a[r+14]*i[s+15],o[15]=a[r+3]*i[s+12]+a[r+7]*i[s+13]+a[r+11]*i[s+14]+a[r+15]*i[s+15]},function(e,t,n,o){const a=new Array(4);let i=this[0+4*n]*e[0+4*o]+this[1+4*n]*e[1+4*o]+this[2+4*n]*e[2+4*o]+this[3+4*n]*e[3+4*o];if(0==1-i*i)a[0]=this[0+4*n],a[1]=this[1+4*n],a[2]=this[2+4*n],a[3]=this[3+4*n];else{i>1?i=.999:i<-1&&(i=-.999);let r=Math.acos(i);const s=Math.sin(r);let l;i<0?(i*=-1,r=Math.acos(i),l=-1*Math.sin(r*t)/s):l=Math.sin(r*t)/s;const c=Math.sin(r*(1-t))/s;a[0]=this[0+4*n]*c+e[0+4*o]*l,a[1]=this[1+4*n]*c+e[1+4*o]*l,a[2]=this[2+4*n]*c+e[2+4*o]*l,a[3]=this[3+4*n]*c+e[3+4*o]*l}return a},function(e,t,n,o){return this[n]*(1-t)+e[o]*t},function(e,t,n,o){const a=new Array(3);for(let i=0;i<3;i++)a[i]=this[3*n+i]*(1-t)+e[3*o+i]*t;return a},function(e,t,n,o,a){const i=new Array(t);for(let r=0;r<t;r++)i[r]=this[o*t+r]*(1-n)+e[a*t+r]*n;return i},function(){const e=Math.hypot(this[0],this[1],this[2],this[3]);return this[0]/=e,this[1]/=e,this[2]/=e,this[3]/=e,this}];for(let e=0;e<M.length;e++)for(let t=0;t<D.length;t++)M[e].prototype[D[t]]=F[t]},3795:(e,t,n)=>{n.d(t,{C:()=>m});var o=n(4114),a=n(7751),i=n(9936),r=n(975),s=n(3414),l=n(5882),c=n(5697),_=n(8924),u=n(8068),f=n(7476),d=n(2229),h=n(3497);class m{constructor({bufferView:e,byteOffsetInBufferView:t,compositionType:n,componentType:i,byteStride:r,count:s,raw:l,max:c,min:u,arrayLength:f,normalized:m}){var p,v,x,g,y,b,I,A;this.__compositionType=a.h.Unknown,this.__componentType=o.I.Unknown,this.__count=0,this.__takenCount=0,this.__byteStride=0,this.__max=_.Am.fromCopyArray([-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]),this.__min=_.Am.fromCopyArray([Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE]),this.__arrayLength=1,this.__normalized=!1,this.__isMinMixDirty=!0,this.__version=0,this.__bufferView=e,this.__byteOffsetInRawArrayBufferOfBuffer=e.byteOffsetInRawArrayBufferOfBuffer+t,this.__compositionType=n,this.__componentType=i,this.__count=s,this.__arrayLength=f,d.Is.exist(c)&&this.__max.setComponents(null!==(p=c[0])&&void 0!==p?p:-Number.MAX_VALUE,null!==(v=c[1])&&void 0!==v?v:-Number.MAX_VALUE,null!==(x=c[2])&&void 0!==x?x:-Number.MAX_VALUE,null!==(g=c[3])&&void 0!==g?g:-Number.MAX_VALUE),d.Is.exist(u)&&this.__min.setComponents(null!==(y=u[0])&&void 0!==y?y:Number.MAX_VALUE,null!==(b=u[1])&&void 0!==b?b:Number.MAX_VALUE,null!==(I=u[2])&&void 0!==I?I:Number.MAX_VALUE,null!==(A=u[3])&&void 0!==A?A:Number.MAX_VALUE),d.Is.exist(c)&&d.Is.exist(u)&&(this.__isMinMixDirty=!1),this.__raw=l,this.__normalized=m,this.__byteStride=r,0===this.__byteStride&&(this.__byteStride=this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes()*this.__arrayLength);const E=this.getTypedArrayClass(this.__componentType);this.__typedArrayClass=E;const S=this.__byteStride-this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes(),T=this.__raw.byteLength-this.__byteOffsetInRawArrayBufferOfBuffer,w=this.byteStride*this.__count-S;T<w&&h.V.error(`Requesting a data size that exceeds the remaining capacity of the buffer: ${this.bufferView.buffer.name}.\n        Exceeded Size: ${w-T}\n        this.__raw.byteLength: ${this.__raw.byteLength}\n        this.__byteOffsetInRawArrayBufferOfBuffer: ${this.byteOffsetInRawArrayBufferOfBuffer}\n        this.byteStride: ${this.byteStride}\n        this.__count: ${this.__count}\n        this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer: ${this.__raw.byteLength-this.__byteOffsetInRawArrayBufferOfBuffer}\n        this.byteStride * this.__count: ${this.byteStride*this.__count}\n        maxExceededSizeOnAoS: ${S}\n        `),this.__dataView=new DataView(this.__raw,this.__byteOffsetInRawArrayBufferOfBuffer,Math.min(this.__byteStride*this.__count,this.__raw.byteLength-this.__byteOffsetInRawArrayBufferOfBuffer)),this.__typedArray=new E(this.__raw,this.__byteOffsetInRawArrayBufferOfBuffer,this.__compositionType.getNumberOfComponents()*this.__count),this.__dataViewGetter=this.__dataView[this.getDataViewGetter(this.__componentType)].bind(this.__dataView),this.__dataViewSetter=this.__dataView[this.getDataViewSetter(this.__componentType)].bind(this.__dataView)}__onUpdated(){var e;this.__version++,null!=this._primitive&&(null===(e=this._primitive.deref())||void 0===e||e.onAccessorUpdated(this.__version))}getTypedArrayClass(e){switch(e){case o.I.Byte:return Int8Array;case o.I.UnsignedByte:return Uint8Array;case o.I.Short:return Int16Array;case o.I.UnsignedShort:return Uint16Array;case o.I.Int:return Int32Array;case o.I.UnsignedInt:return Uint32Array;case o.I.Float:return Float32Array;case o.I.Double:return Float64Array;default:return void h.V.error("Unexpected ComponentType!")}}getDataViewGetter(e){switch(e){case o.I.Byte:return"getInt8";case o.I.UnsignedByte:return"getUint8";case o.I.Short:return"getInt16";case o.I.UnsignedShort:return"getUint16";case o.I.Int:return"getInt32";case o.I.UnsignedInt:return"getUint32";case o.I.Float:return"getFloat32";case o.I.Double:return"getFloat64";default:return h.V.error("Unexpected ComponentType!"),"unknown"}}getDataViewSetter(e){switch(e){case o.I.Byte:return"setInt8";case o.I.UnsignedByte:return"setUint8";case o.I.Short:return"setInt16";case o.I.UnsignedShort:return"setUint16";case o.I.Int:return"setInt32";case o.I.UnsignedInt:return"setUint32";case o.I.Float:return"setFloat32";case o.I.Double:return"setFloat64";default:h.V.error("Unexpected ComponentType!")}}takeOne(){const e=this.__raw;this.__takenCount>=this.__count&&h.V.error("You are trying to allocate more than you have secured.");const t=new this.__typedArrayClass(e,this.__byteOffsetInRawArrayBufferOfBuffer+this.__byteStride*this.__takenCount,this.__compositionType.getNumberOfComponents()*this.__arrayLength);return t._accessor=this,t._idx_of_accessor=this.__takenCount,this.__takenCount+=1,t}_takeExistedOne(e){const t=this.__raw;e>=this.__count&&h.V.error("You are trying to allocate more than you have secured.");const n=new this.__typedArrayClass(t,this.__byteOffsetInRawArrayBufferOfBuffer+this.__byteStride*e,this.__compositionType.getNumberOfComponents()*this.__arrayLength);return n._accessor=this,n._idx_of_accessor=e,n}get takenCount(){return this.takenCount}get numberOfComponents(){return this.__compositionType.getNumberOfComponents()}get componentSizeInBytes(){return this.__componentType.getSizeInBytes()}get elementSizeInBytes(){return this.numberOfComponents*this.componentSizeInBytes}get elementCount(){return this.__count}get byteLength(){return this.__byteStride*this.__count}get componentType(){return this.__componentType}get compositionType(){return this.__compositionType}getTypedArray(){return this.__typedArray}getUint8Array(){return new Uint8Array(this.bufferView.buffer.getArrayBuffer(),this.byteOffsetInRawArrayBufferOfBuffer,this.byteLength)}get isAoS(){return!this.isSoA}get isSoA(){return this.byteStride===this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes()}get byteStride(){return this.__byteStride}getScalar(e,{indicesAccessor:t,endian:n=!0}){let o=e;return t&&(o=t.getScalar(e,{})),this.__dataViewGetter(this.__byteStride*o,n)}getScalarAt(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;return n&&(a=n.getScalar(e,{})),this.__dataViewGetter(this.__byteStride*a+t,o)}getVec2AsArray(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n)]}getVec3AsArray(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n)]}getVec4AsArray(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n),this.__dataViewGetter(this.__byteStride*o+3*a,n)]}getMat3AsArray(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n),this.__dataViewGetter(this.__byteStride*o+3*a,n),this.__dataViewGetter(this.__byteStride*o+4*a,n),this.__dataViewGetter(this.__byteStride*o+5*a,n),this.__dataViewGetter(this.__byteStride*o+6*a,n),this.__dataViewGetter(this.__byteStride*o+7*a,n),this.__dataViewGetter(this.__byteStride*o+8*a,n)]}getMat4AsArray(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n),this.__dataViewGetter(this.__byteStride*o+3*a,n),this.__dataViewGetter(this.__byteStride*o+4*a,n),this.__dataViewGetter(this.__byteStride*o+5*a,n),this.__dataViewGetter(this.__byteStride*o+6*a,n),this.__dataViewGetter(this.__byteStride*o+7*a,n),this.__dataViewGetter(this.__byteStride*o+8*a,n),this.__dataViewGetter(this.__byteStride*o+9*a,n),this.__dataViewGetter(this.__byteStride*o+10*a,n),this.__dataViewGetter(this.__byteStride*o+11*a,n),this.__dataViewGetter(this.__byteStride*o+12*a,n),this.__dataViewGetter(this.__byteStride*o+13*a,n),this.__dataViewGetter(this.__byteStride*o+14*a,n),this.__dataViewGetter(this.__byteStride*o+15*a,n)]}getVec2(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return i.I9.fromCopyArray2([this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n)])}getVec3(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return r.Pq.fromCopyArray([this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n)])}getVec4(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return s.IU.fromCopyArray([this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n),this.__dataViewGetter(this.__byteStride*o+3*a,n)])}getMat3(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return u.k.fromCopy9RowMajor(this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n),this.__dataViewGetter(this.__byteStride*o+3*a,n),this.__dataViewGetter(this.__byteStride*o+4*a,n),this.__dataViewGetter(this.__byteStride*o+5*a,n),this.__dataViewGetter(this.__byteStride*o+6*a,n),this.__dataViewGetter(this.__byteStride*o+7*a,n),this.__dataViewGetter(this.__byteStride*o+8*a,n))}getMat4(e,{indicesAccessor:t,endian:n=!0}){let o=e;t&&(o=t.getScalar(e,{}));const a=this.componentSizeInBytes;return f.g.fromCopy16RowMajor(this.__dataViewGetter(this.__byteStride*o,n),this.__dataViewGetter(this.__byteStride*o+1*a,n),this.__dataViewGetter(this.__byteStride*o+2*a,n),this.__dataViewGetter(this.__byteStride*o+3*a,n),this.__dataViewGetter(this.__byteStride*o+4*a,n),this.__dataViewGetter(this.__byteStride*o+5*a,n),this.__dataViewGetter(this.__byteStride*o+6*a,n),this.__dataViewGetter(this.__byteStride*o+7*a,n),this.__dataViewGetter(this.__byteStride*o+8*a,n),this.__dataViewGetter(this.__byteStride*o+9*a,n),this.__dataViewGetter(this.__byteStride*o+10*a,n),this.__dataViewGetter(this.__byteStride*o+11*a,n),this.__dataViewGetter(this.__byteStride*o+12*a,n),this.__dataViewGetter(this.__byteStride*o+13*a,n),this.__dataViewGetter(this.__byteStride*o+14*a,n),this.__dataViewGetter(this.__byteStride*o+15*a,n))}getVec2To(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*a,o),this.__dataViewGetter(this.__byteStride*a+1*i,o))}getVec3To(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*a,o),this.__dataViewGetter(this.__byteStride*a+1*i,o),this.__dataViewGetter(this.__byteStride*a+2*i,o))}getVec4To(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*a,o),this.__dataViewGetter(this.__byteStride*a+1*i,o),this.__dataViewGetter(this.__byteStride*a+2*i,o),this.__dataViewGetter(this.__byteStride*a+3*i,o))}getMat3To(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*a,o),this.__dataViewGetter(this.__byteStride*a+1*i,o),this.__dataViewGetter(this.__byteStride*a+2*i,o),this.__dataViewGetter(this.__byteStride*a+3*i,o),this.__dataViewGetter(this.__byteStride*a+4*i,o),this.__dataViewGetter(this.__byteStride*a+5*i,o),this.__dataViewGetter(this.__byteStride*a+6*i,o),this.__dataViewGetter(this.__byteStride*a+7*i,o),this.__dataViewGetter(this.__byteStride*a+8*i,o))}getMat4To(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*a,o),this.__dataViewGetter(this.__byteStride*a+1*i,o),this.__dataViewGetter(this.__byteStride*a+2*i,o),this.__dataViewGetter(this.__byteStride*a+3*i,o),this.__dataViewGetter(this.__byteStride*a+4*i,o),this.__dataViewGetter(this.__byteStride*a+5*i,o),this.__dataViewGetter(this.__byteStride*a+6*i,o),this.__dataViewGetter(this.__byteStride*a+7*i,o),this.__dataViewGetter(this.__byteStride*a+8*i,o),this.__dataViewGetter(this.__byteStride*a+9*i,o),this.__dataViewGetter(this.__byteStride*a+10*i,o),this.__dataViewGetter(this.__byteStride*a+11*i,o),this.__dataViewGetter(this.__byteStride*a+12*i,o),this.__dataViewGetter(this.__byteStride*a+13*i,o),this.__dataViewGetter(this.__byteStride*a+14*i,o),this.__dataViewGetter(this.__byteStride*a+15*i,o))}setScalar(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{})),this.__dataViewSetter(this.__byteStride*a,t,o),this.__isMinMixDirty=!0,this.__onUpdated()}setVec2(e,t,n,{indicesAccessor:o,endian:a=!0}){let i=e;o&&(i=o.getScalar(e,{}));const r=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*i,t,a),this.__dataViewSetter(this.__byteStride*i+1*r,n,a),this.__isMinMixDirty=!0,this.__onUpdated()}setVec3(e,t,n,o,{indicesAccessor:a,endian:i=!0}){let r=e;a&&(r=a.getScalar(e,{}));const s=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*r,t,i),this.__dataViewSetter(this.__byteStride*r+1*s,n,i),this.__dataViewSetter(this.__byteStride*r+2*s,o,i),this.__isMinMixDirty=!0,this.__onUpdated()}setVec4(e,t,n,o,a,{indicesAccessor:i,endian:r=!0}){let s=e;i&&(s=i.getScalar(e,{}));const l=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*s,t,r),this.__dataViewSetter(this.__byteStride*s+1*l,n,r),this.__dataViewSetter(this.__byteStride*s+2*l,o,r),this.__dataViewSetter(this.__byteStride*s+3*l,a,r),this.__isMinMixDirty=!0,this.__onUpdated()}setMat4(e,t,n,o,a,i,r,s,l,c,_,u,f,d,h,m,p,{indicesAccessor:v,endian:x=!0}){let g=e;v&&(g=v.getScalar(e,{}));const y=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*g,t,x),this.__dataViewSetter(this.__byteStride*g+1*y,n,x),this.__dataViewSetter(this.__byteStride*g+2*y,o,x),this.__dataViewSetter(this.__byteStride*g+3*y,a,x),this.__dataViewSetter(this.__byteStride*g+4*y,i,x),this.__dataViewSetter(this.__byteStride*g+5*y,r,x),this.__dataViewSetter(this.__byteStride*g+6*y,s,x),this.__dataViewSetter(this.__byteStride*g+7*y,l,x),this.__dataViewSetter(this.__byteStride*g+8*y,c,x),this.__dataViewSetter(this.__byteStride*g+9*y,_,x),this.__dataViewSetter(this.__byteStride*g+10*y,u,x),this.__dataViewSetter(this.__byteStride*g+11*y,f,x),this.__dataViewSetter(this.__byteStride*g+12*y,d,x),this.__dataViewSetter(this.__byteStride*g+13*y,h,x),this.__dataViewSetter(this.__byteStride*g+14*y,m,x),this.__dataViewSetter(this.__byteStride*g+15*y,p,x),this.__isMinMixDirty=!0,this.__onUpdated()}setVec2AsVector(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*a,t.x,o),this.__dataViewSetter(this.__byteStride*a+1*i,t.y,o),this.__isMinMixDirty=!0,this.__onUpdated()}setVec3AsVector(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*a,t.x,o),this.__dataViewSetter(this.__byteStride*a+1*i,t.y,o),this.__dataViewSetter(this.__byteStride*a+2*i,t.z,o),this.__isMinMixDirty=!0,this.__onUpdated()}setVec4AsVector(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*a,t.x,o),this.__dataViewSetter(this.__byteStride*a+1*i,t.y,o),this.__dataViewSetter(this.__byteStride*a+2*i,t.z,o),this.__dataViewSetter(this.__byteStride*a+3*i,t.w,o),this.__isMinMixDirty=!0,this.__onUpdated()}setMat4AsMatrix44(e,t,{indicesAccessor:n,endian:o=!0}){let a=e;n&&(a=n.getScalar(e,{}));const i=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*a,t._v[0],o),this.__dataViewSetter(this.__byteStride*a+1*i,t._v[1],o),this.__dataViewSetter(this.__byteStride*a+2*i,t._v[2],o),this.__dataViewSetter(this.__byteStride*a+3*i,t._v[3],o),this.__dataViewSetter(this.__byteStride*a+4*i,t._v[4],o),this.__dataViewSetter(this.__byteStride*a+5*i,t._v[5],o),this.__dataViewSetter(this.__byteStride*a+6*i,t._v[6],o),this.__dataViewSetter(this.__byteStride*a+7*i,t._v[7],o),this.__dataViewSetter(this.__byteStride*a+8*i,t._v[8],o),this.__dataViewSetter(this.__byteStride*a+9*i,t._v[9],o),this.__dataViewSetter(this.__byteStride*a+10*i,t._v[10],o),this.__dataViewSetter(this.__byteStride*a+11*i,t._v[11],o),this.__dataViewSetter(this.__byteStride*a+12*i,t._v[12],o),this.__dataViewSetter(this.__byteStride*a+13*i,t._v[13],o),this.__dataViewSetter(this.__byteStride*a+14*i,t._v[14],o),this.__dataViewSetter(this.__byteStride*a+15*i,t._v[15],o),this.__isMinMixDirty=!0,this.__onUpdated()}copyFromTypedArray(e){const t=this.numberOfComponents;for(let n=0;n<e.byteLength/this.componentSizeInBytes;n++){const o=Math.floor(n/t),a=o*t;switch(t){case 1:this.setScalar(o,e[a+0],{});break;case 2:this.setVec2(o,e[a+0],e[a+1],{});break;case 3:this.setVec3(o,e[a+0],e[a+1],e[a+2],{});break;case 4:this.setVec4(o,e[a+0],e[a+1],e[a+2],e[a+3],{});break;default:throw new Error("Other than vectors are currently not supported.")}}this.__isMinMixDirty=!0,this.__onUpdated()}setScalarAt(e,t,n,{indicesAccessor:o,endian:a=!0}){let i=e;o&&(i=o.getScalar(e,{})),this.__dataViewSetter(this.__byteStride*i+t,n,a),this.__isMinMixDirty=!0,this.__onUpdated()}setElementFromSameCompositionAccessor(e,t,n){const o=null!=n?n:e;1===this.compositionType.getNumberOfComponents()?this.setScalar(e,t.getScalar(o,{}),{}):2===this.compositionType.getNumberOfComponents()?this.setVec2AsVector(e,t.getVec2(o,{}),{}):3===this.compositionType.getNumberOfComponents()?this.setVec3AsVector(e,t.getVec3(o,{}),{}):4===this.compositionType.getNumberOfComponents()&&this.setVec4AsVector(e,t.getVec4(o,{}),{}),this.__isMinMixDirty=!0,this.__onUpdated()}copyBuffer(e){new Uint8Array(this.__raw).set(new Uint8Array(e.__raw,e.__byteOffsetInRawArrayBufferOfBuffer,e.byteLength),this.__byteOffsetInRawArrayBufferOfBuffer),this.__isMinMixDirty=!0,this.__onUpdated()}setElementFromAccessor(e,t,n){const o=null!=n?n:e;if(1===this.compositionType.getNumberOfComponents())1===t.compositionType.getNumberOfComponents()?this.setScalar(e,t.getScalar(o,{}),{}):2===t.compositionType.getNumberOfComponents()?this.setScalar(e,t.getVec2(o,{}).x,{}):3===t.compositionType.getNumberOfComponents()?this.setScalar(e,t.getVec3(o,{}).x,{}):4===t.compositionType.getNumberOfComponents()&&this.setScalar(e,t.getVec4(o,{}).x,{});else if(2===this.compositionType.getNumberOfComponents()){if(1===t.compositionType.getNumberOfComponents()){const n=t.getScalar(o,{});this.setVec2(e,n,0,{})}else if(2===t.compositionType.getNumberOfComponents())this.setVec2AsVector(e,t.getVec2(o,{}),{});else if(3===t.compositionType.getNumberOfComponents()){const n=t.getVec3(o,{});this.setVec2(e,n.x,n.y,{})}else if(4===t.compositionType.getNumberOfComponents()){const n=t.getVec4(o,{});this.setVec2(e,n.x,n.y,{})}}else if(3===this.compositionType.getNumberOfComponents()){if(1===t.compositionType.getNumberOfComponents()){const n=t.getScalar(o,{});this.setVec3(e,n,0,0,{})}else if(2===t.compositionType.getNumberOfComponents()){const n=t.getVec2(o,{});this.setVec3(e,n.x,n.y,0,{})}else if(3===t.compositionType.getNumberOfComponents()){const n=t.getVec3(o,{});this.setVec3AsVector(e,n,{})}else if(4===t.compositionType.getNumberOfComponents()){const n=t.getVec4(o,{});this.setVec3(e,n.x,n.y,n.z,{})}}else if(4===this.compositionType.getNumberOfComponents())if(1===t.compositionType.getNumberOfComponents()){const n=t.getScalar(o,{});this.setVec4(e,n,0,0,0,{})}else if(2===t.compositionType.getNumberOfComponents()){const n=t.getVec2(o,{});this.setVec4(e,n.x,n.y,0,0,{})}else if(3===t.compositionType.getNumberOfComponents()){const n=t.getVec3(o,{});this.setVec4(e,n.x,n.y,n.z,0,{})}else if(4===t.compositionType.getNumberOfComponents()){const n=t.getVec4(o,{});this.setVec4AsVector(e,n,{})}this.__isMinMixDirty=!0,this.__onUpdated()}addElementFromSameCompositionAccessor(e,t,n,o){const a=null!=o?o:e;1===this.compositionType.getNumberOfComponents()?this.setScalar(e,this.getScalar(e,{})+n*t.getScalar(a,{}),{}):2===this.compositionType.getNumberOfComponents()?this.setVec2AsVector(e,i.I9.add(this.getVec2(e,{}),i.I9.multiply(t.getVec2(a,{}),n)),{}):3===this.compositionType.getNumberOfComponents()?this.setVec3AsVector(e,r.Pq.add(this.getVec3(e,{}),r.Pq.multiply(t.getVec3(a,{}),n)),{}):4===this.compositionType.getNumberOfComponents()&&this.setVec4AsVector(e,s.IU.add(this.getVec4(e,{}),s.IU.multiply(t.getVec4(a,{}),n)),{}),this.__isMinMixDirty=!0,this.__onUpdated()}get arrayBufferOfBufferView(){return this.__raw}get dataViewOfBufferView(){return this.__dataView}get byteOffsetInBufferView(){return this.__byteOffsetInRawArrayBufferOfBuffer-this.__bufferView.byteOffsetInRawArrayBufferOfBuffer}get byteOffsetInBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer-this.__bufferView.buffer.byteOffsetInRawArrayBuffer}get byteOffsetInRawArrayBufferOfBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer}get bufferView(){return this.__bufferView}setMinMax(e,t){const n=this.compositionType.getNumberOfComponents();1===n?(this.__min._v[0]=e[0],this.__max._v[0]=t[0]):2===n?(this.__min._v[0]=e[0],this.__min._v[1]=e[1],this.__max._v[0]=t[0],this.__max._v[1]=t[1]):3===n?(this.__min._v[0]=e[0],this.__min._v[1]=e[1],this.__min._v[2]=e[2],this.__max._v[0]=t[0],this.__max._v[1]=t[1],this.__max._v[2]=t[2]):4===n&&(this.__min._v[0]=e[0],this.__min._v[1]=e[1],this.__min._v[2]=e[2],this.__min._v[3]=e[3],this.__max._v[0]=t[0],this.__max._v[1]=t[1],this.__max._v[2]=t[2],this.__max._v[3]=t[3]),this.__isMinMixDirty=!1}get min(){this.__isMinMixDirty&&this.__calcMinMax();const e=this.compositionType.getNumberOfComponents();return 4===e?[this.__min._v[0],this.__min._v[1],this.__min._v[2],this.__min._v[3]]:3===e?[this.__min._v[0],this.__min._v[1],this.__min._v[2]]:2===e?[this.__min._v[0],this.__min._v[1]]:[this.__min._v[0]]}get max(){this.__isMinMixDirty&&this.__calcMinMax();const e=this.compositionType.getNumberOfComponents();return 4===e?[this.__max._v[0],this.__max._v[1],this.__max._v[2],this.__max._v[3]]:3===e?[this.__max._v[0],this.__max._v[1],this.__max._v[2]]:2===e?[this.__max._v[0],this.__max._v[1]]:[this.__max._v[0]]}get normalized(){return this.__normalized}__calcMinMax(){const e=this.compositionType.getNumberOfComponents();if(4===e){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);const e=m.__tmpVector4_0;for(let t=0;t<this.elementCount;t++){this.getVec4To(t,e,{});for(let t=0;t<4;t++)this.__max._v[t]<e._v[t]&&(this.__max._v[t]=e._v[t]),e._v[t]<this.__min._v[t]&&(this.__min._v[t]=e._v[t])}}else if(3===e){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);const e=m.__tmpVector3_0;for(let t=0;t<this.elementCount;t++){this.getVec3To(t,e,{});for(let t=0;t<3;t++)this.__max._v[t]<e._v[t]&&(this.__max._v[t]=e._v[t]),e._v[t]<this.__min._v[t]&&(this.__min._v[t]=e._v[t])}}else if(2===e){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);const e=m.__tmpVector2_0;for(let t=0;t<this.elementCount;t++){this.getVec2To(t,e,{});for(let t=0;t<2;t++)this.__max._v[t]<e._v[t]&&(this.__max._v[t]=e._v[t]),e._v[t]<this.__min._v[t]&&(this.__min._v[t]=e._v[t])}}else if(1===e){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let e=0;e<this.elementCount;e++){const t=this.getScalar(e,{});this.__max._v[0]<t&&(this.__max._v[0]=t),t<this.__min._v[0]&&(this.__min._v[0]=t)}}this.__isMinMixDirty=!1}get isMinMaxDirty(){return this.__isMinMixDirty}get version(){return this.__version}get actualByteStride(){return 0===this.__byteStride?this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes()*this.__arrayLength:this.__byteStride}isSame(e){return this.byteLength===e.byteLength&&this.byteOffsetInRawArrayBufferOfBuffer===e.byteOffsetInRawArrayBufferOfBuffer&&this.bufferView.buffer.getArrayBuffer()===e.bufferView.buffer.getArrayBuffer()}}m.__tmpVector4_0=_.Am.zero(),m.__tmpVector3_0=c.tp.zero(),m.__tmpVector2_0=l.A3.zero()},4066:(e,t,n)=>{n.d(t,{h:()=>c});var o=n(3735),a=n(7751),i=n(4114),r=n(5065),s=n(8556),l=n(3497);class c{constructor({byteLength:e,buffer:t,name:n,byteAlign:o}){this.__byteLength=0,this.__byteOffset=0,this.__takenBytesIndex=0,this.__name="",this.__bufferViews=[],this.__name=n,this.__byteLength=e,this.__byteAlign=o,t instanceof Uint8Array?(this.__raw=t.buffer,this.__byteOffset=t.byteOffset):this.__raw=t}set name(e){this.__name=e}get name(){return this.__name}getArrayBuffer(){return this.__raw}__padding(e,t){const n=r.$.calcPaddingBytes(e,t);return n>0&&l.V.info("Padding bytes added to takenBytesIndex."),n}takeBufferView({byteLengthToNeed:e,byteStride:t}){const n=e;if(n+this.__takenBytesIndex>this.byteLength){const e=`The size of the BufferView you are trying to take exceeds the byte length left in the Buffer.\nBuffer.byteLength: ${this.byteLength}, Buffer.takenSizeInByte: ${this.takenSizeInByte},\nbyteSizeToTake: ${n}, the byte length left in the Buffer: ${this.__byteLength-this.__takenBytesIndex}`;return new s._({message:e,error:{"Buffer.byteLength":this.takenSizeInByte,"Buffer.takenSizeInByte":this.takenSizeInByte}})}const a=new o.E({buffer:this,byteOffsetInBuffer:this.__takenBytesIndex,defaultByteStride:t,byteLength:n,raw:this.__raw});return this.__takenBytesIndex+=n,this.__takenBytesIndex=r.$.addPaddingBytes(this.__takenBytesIndex,this.__byteAlign),this.__bufferViews.push(a),new s.Ok(a)}takeBufferViewWithByteOffset({byteLengthToNeed:e,byteStride:t,byteOffset:n}){if(e+n>this.byteLength){const t=`The size of the BufferView you are trying to take exceeds the byte length left in the Buffer.\nBuffer.byteLength: ${this.byteLength}, Buffer.takenSizeInByte: ${this.takenSizeInByte},\nbyteSizeToTake: ${e}, the byte length left in the Buffer: ${this.__byteLength-this.__takenBytesIndex}`;return new s._({message:t,error:void 0})}const a=new o.E({buffer:this,byteOffsetInBuffer:n,defaultByteStride:t,byteLength:e,raw:this.__raw}),i=Uint8Array.BYTES_PER_ELEMENT*e+n;return this.__takenBytesIndex<i&&(this.__takenBytesIndex=i),this.__bufferViews.push(a),new s.Ok(a)}_addTakenByteIndex(e){this.__takenBytesIndex+=e}get byteLength(){return this.__byteLength}get takenSizeInByte(){return this.__takenBytesIndex}get byteOffsetInRawArrayBuffer(){return this.__byteOffset}getTypedArray(e,t,n,o=100){let r;const s=i.I.toTypedArray(n);return void 0===s&&l.V.warn("componentType is Invalid"),r=a.h.isArray(t)?new s(this.__raw,this.__byteOffset+4*e,o):new s(this.__raw,this.__byteOffset+4*e,1),r}isSame(e){return this.__raw===e.__raw}}},3735:(e,t,n)=>{n.d(t,{E:()=>i});var o=n(3795),a=n(6301);class i{constructor({buffer:e,byteOffsetInBuffer:t,defaultByteStride:n,byteLength:o,raw:a}){this.__defaultByteStride=0,this.__takenByte=0,this.__takenAccessorCount=0,this.__accessors=[],this.__buffer=e,this.__byteOffsetInBuffer=t,this.__byteOffsetInRawArrayBufferOfBuffer=e.byteOffsetInRawArrayBuffer+t,this.__byteLength=o,this.__defaultByteStride=n,this.__raw=a}get defaultByteStride(){return this.__defaultByteStride}get byteLength(){return this.__byteLength}get byteOffsetInBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer-this.__buffer.byteOffsetInRawArrayBuffer}get byteOffsetInRawArrayBufferOfBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer}get buffer(){return this.__buffer}get isSoA(){return!this.isAoS}get isAoS(){for(const e of this.__accessors)if(e.isAoS)return!0;return!1}getUint8Array(){return new Uint8Array(this.__raw,this.__byteOffsetInRawArrayBufferOfBuffer,this.__byteLength)}takeAccessor({compositionType:e,componentType:t,count:n,byteStride:o=this.defaultByteStride,max:a,min:i,arrayLength:r=1,normalized:s=!1}){return this.__takeAccessorInner({compositionType:e,componentType:t,count:n,byteStride:o,max:a,min:i,normalized:s,arrayLength:r})}takeAccessorWithByteOffset({compositionType:e,componentType:t,count:n,byteOffsetInBufferView:o,byteStride:a=this.defaultByteStride,max:i,min:r,normalized:s=!1}){return this.__takeAccessorInnerWithByteOffset({compositionType:e,componentType:t,count:n,byteStride:a,byteOffsetInBufferView:o,max:i,min:r,normalized:s})}__takeAccessorInner({compositionType:e,componentType:t,count:n,byteStride:i,max:r,min:s,arrayLength:l,normalized:c}){const _=this.__takenByte;let u=i;if(0===u&&(u=e.getNumberOfComponents()*t.getSizeInBytes()*l),this.__takenByte+u*(n-1)+t.getSizeInBytes()*e.getNumberOfComponents()>this.byteLength){const e=`The size of the Accessor you are trying to take exceeds the byte length left in the BufferView.\nBufferView.byteLength: ${this.byteLength}, BufferView.takenSizeInByte: ${this.__takenByte}, Accessor.byteStride: ${i}, Accessor.count: ${n};\nbyteSizeToTake: ${u*n}, the byte length left in the Buffer: ${this.byteLength-this.__takenByte}`;return new a._({message:e,error:void 0})}const f=new o.C({bufferView:this,byteOffsetInBufferView:_,compositionType:e,componentType:t,byteStride:i,count:n,raw:this.__raw,max:r,min:s,arrayLength:l,normalized:c});return this.__accessors.push(f),this.__takenByte+=u*n,new a.Ok(f)}__takeAccessorInnerWithByteOffset({compositionType:e,componentType:t,count:n,byteStride:i,byteOffsetInBufferView:r,max:s,min:l,normalized:c}){if(this.__takenByte+i*(n-1)+t.getSizeInBytes()*e.getNumberOfComponents()>this.byteLength){const e=`The size of the Accessor you are trying to take exceeds the byte length left in the BufferView.\nBufferView.byteLength: ${this.byteLength}, BufferView.takenSizeInByte: ${this.__takenByte}, Accessor.byteStride: ${i}, Accessor.count: ${n};\nbyteSizeToTake: ${i*n}, the byte length left in the Buffer: ${this.byteLength-this.__takenByte}`;return new a._({message:e,error:void 0})}const _=new o.C({bufferView:this,byteOffsetInBufferView:r,compositionType:e,componentType:t,byteStride:i,count:n,raw:this.__raw,max:s,min:l,arrayLength:1,normalized:c});return this.__accessors.push(_),new a.Ok(_)}isSame(e){return this.byteLength===e.byteLength&&this.byteOffsetInRawArrayBufferOfBuffer===e.byteOffsetInRawArrayBufferOfBuffer&&this.defaultByteStride===e.defaultByteStride&&this.buffer.getArrayBuffer()===e.buffer.getArrayBuffer()}}},5065:(e,t,n)=>{n.d(t,{$:()=>i});var o=n(8556),a=n(1692);class i{static isNode(){return void 0===window&&"undefined"!=typeof process&&!0}static btoa(e){if(i.isNode()){let t;return t=Buffer.isBuffer(e)?e:Buffer.from(e.toString(),"binary"),t.toString("base64")}return btoa(e)}static atob(e){return i.isNode()?Buffer.from(e,"base64").toString("binary"):atob(e)}static dataUriToArrayBuffer(e){const t=e.split(","),n=i.atob(t[1]),o=n.length,a=new ArrayBuffer(o),r=new Uint8Array(a);for(let e=0;e<o;e++)r[e]=n.charCodeAt(e);return a}static arrayBufferToString(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);{const t=new Uint8Array(e);return this.uint8ArrayToStringInner(t)}}static uint8ArrayToString(e){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(e):this.uint8ArrayToStringInner(e)}static stringToBase64(e){let t=null;return t=i.btoa(e),t}static base64ToArrayBuffer(e){const t=window.atob(e),n=t.length,o=new Uint8Array(n);for(let e=0;e<n;e++)o[e]=t.charCodeAt(e);return o.buffer}static UInt8ArrayToDataURL(e,t,n){const o=document.createElement("canvas");o.width=t,o.height=n;const a=o.getContext("2d"),i=a.createImageData(t,n);for(let o=0;o<i.data.length;o+=4)i.data[o+0]=e[(n-Math.floor(o/(4*t)))*(4*t)+o%(4*t)+0],i.data[o+1]=e[(n-Math.floor(o/(4*t)))*(4*t)+o%(4*t)+1],i.data[o+2]=e[(n-Math.floor(o/(4*t)))*(4*t)+o%(4*t)+2],i.data[o+3]=e[(n-Math.floor(o/(4*t)))*(4*t)+o%(4*t)+3];return a.putImageData(i,0,0),o.remove(),o.toDataURL("image/png")}static loadResourceAsync(e,t,n,o){return new Promise(((a,r)=>{if(i.isNode());else{const i=new XMLHttpRequest;t?(i.onload=e=>{let o=null;o=t?i.response:i.responseText,n(a,o)},i.open("GET",e,!0),i.responseType="arraybuffer"):(i.onreadystatechange=()=>{if(4!==i.readyState||2!==Math.floor(i.status/100)&&0!==i.status)o&&o(r,i.status);else{let e=null;e=t?i.response:i.responseText,n(a,e)}},i.open("GET",e,!0)),i.send(null)}}))}static toCRC32(e){let t=0,n=0,o=0;const a=i.crc32table;t=~t;for(let i=0,r=e.length;i<r;++i)o=255&(t^e.charCodeAt(i)),n="0x"+a[o],t=t>>>8^n;return~t>>>0}static accessBinaryAsImage(e,t,n,o){const a=this.takeBufferViewAsUint8Array(t,e,n);return this.accessArrayBufferAsImage(a,o)}static createBlobImageUriFromUint8Array(e,t){const n=new Blob([e],{type:t});return URL.createObjectURL(n)}static takeBufferViewAsUint8Array(e,t,n){var o;const a=e.bufferViews[t];let i=null!==(o=a.byteOffset)&&void 0!==o?o:0;const r=a.byteLength;let s=n;return n instanceof Uint8Array&&(s=n.buffer,i+=n.byteOffset),new Uint8Array(s,i,r)}static accessArrayBufferAsImage(e,t){const n=this.uint8ArrayToStringInner(new Uint8Array(e));return this.getImageType(t)+i.btoa(n)}static uint8ArrayToStringInner(e){const t=new Array(e.byteLength);for(let n=0;n<e.byteLength;n++)t[n]=e[n];const n=1024,o=Math.ceil(t.length/n);let a="";for(let e=0;e<o;e++)a+=String.fromCharCode.apply(this,t.slice(e*n,(e+1)*n));return a}static getImageType(e){let t=null;return t="image/jpeg"===e||"jpg"===e.toLowerCase()||"jpeg"===e.toLowerCase()?"data:image/jpeg;base64,":"image/png"===e||"png"===e.toLowerCase()?"data:image/png;base64,":"image/gif"===e||"gif"===e.toLowerCase()?"data:image/gif;base64,":"image/bmp"===e||"bmp"===e.toLowerCase()?"data:image/bmp;base64,":"data:image/unknown;base64,",t}static getMimeTypeFromExtension(e){let t=null;return t="jpg"===e.toLowerCase()||"jpeg"===e.toLowerCase()?"image/jpeg":"png"===e.toLowerCase()?"image/png":"gif"===e.toLowerCase()?"image/gif":"bmp"===e.toLowerCase()?"image/bmp":"image/unknown",t}static getExtension(e){const t=e.split(".");return t[t.length-1]}static createUint8ArrayFromBufferViewInfo(e,t,n){var o;const a=e.bufferViews[t];let i=null!==(o=a.byteOffset)&&void 0!==o?o:0;const r=a.byteLength;let s=n;return n instanceof Uint8Array&&(s=n.buffer,i+=n.byteOffset),new Uint8Array(s,i,r)}static createImageFromUri(e,t){return new a.m((n=>{const o=new Image;if(o.crossOrigin="Anonymous",e.match(/^blob:/)||e.match(/^data:/))o.onload=()=>{n(o)},o.src=e;else{const a=(e,o)=>{const a=new Uint8Array(o),r=i.createBlobImageUriFromUint8Array(a,t);e.onload=()=>{n(e),URL.revokeObjectURL(r)},e.src=r};(()=>{const t=new XMLHttpRequest;var n;t.onreadystatechange=(n=o,function(){4===t.readyState&&200===t.status&&a(n,t.response)}),t.open("GET",e),t.responseType="arraybuffer",t.send()})()}}))}static createDefaultGltfOptions(){return{files:{},loaderExtension:void 0,defaultMaterialHelperName:void 0,defaultMaterialHelperArgumentArray:[],statesOfElements:[{targets:[],states:{enable:[],functions:{}},isTransparent:!0,opacity:1,isTextureImageToLoadPreMultipliedAlpha:!1}],tangentCalculationMode:1,extendedJson:void 0,__importedType:"undefined"}}static async fetchArrayBuffer(e){const t=await fetch(e,{mode:"cors"});if(!t.ok)return new o._({message:`fetchArrayBuffer failed. uri: ${e}`,error:t.statusText});const n=await t.arrayBuffer();return new o.Ok(n)}static getResizedCanvas(e,t){const n=document.createElement("canvas"),o=this.getNearestPowerOfTwo(e.width),a=this.getNearestPowerOfTwo(e.height),i=a/o;let r=0,s=0;return o>a?(r=Math.min(o,t),s=r*i):(s=Math.min(a,t),r=s/i),n.width=r,n.height=s,n.getContext("2d").drawImage(e,0,0,e.width,e.height,0,0,r,s),[n,r,s]}static detectTransparentPixelExistence(e,t=1){const n=e.width,o=e.height;let a,i;e instanceof ImageData?i=e:e instanceof HTMLImageElement?(a=document.createElement("canvas").getContext("2d"),a.drawImage(e,0,0),i=a.getImageData(0,0,n,o)):(a=e.getContext("2d"),a.drawImage(e,0,0),i=a.getImageData(0,0,n,o));for(let e=0;e<o;e++)for(let o=0;o<n;o++)if(i.data[4*(o+e*n)+3]<t)return!0;return!1}static getNearestPowerOfTwo(e){return Math.pow(2,Math.round(Math.log(e)/Math.LN2))}static calcPaddingBytes(e,t){return e%t!=0?t-e%t:0}static addPaddingBytes(e,t){return e+this.calcPaddingBytes(e,t)}static normalizedInt8ArrayToFloat32Array(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;n++)t[n]=Math.max(e[n]/127,-1);return t}static normalizedUint8ArrayToFloat32Array(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;n++)t[n]=e[n]/255;return t}static normalizedInt16ArrayToFloat32Array(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;n++)t[n]=Math.max(e[n]/32767,-1);return t}static normalizedUint16ArrayToFloat32Array(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;n++)t[n]=e[n]/65535;return t}static getCopy({src:e,srcByteOffset:t,copyByteLength:n,distByteOffset:o}){const a=new ArrayBuffer(e.byteLength),i=new Uint8Array(a,o,n);return i.set(new Uint8Array(e,t,n)),i.buffer}static getCopyAs4Bytes({src:e,srcByteOffset:t,copyByteLength:n,distByteOffset:o}){if(t%4!=0||n%4!=0||o%4!=0)throw new Error("Invalid byte align for 4bytes unit copy operation.");const a=new ArrayBuffer(e.byteLength),i=new Int32Array(a,o,n/4);return i.set(new Int32Array(e,t,n/4)),i.buffer}static copyArrayBuffer({src:e,dist:t,srcByteOffset:n,copyByteLength:o,distByteOffset:a=0}){const i=new Uint8Array(t,a,o);return i.set(new Uint8Array(e,n,o)),i.buffer}static copyArrayBufferWithPadding({src:e,dist:t,srcByteOffset:n,copyByteLength:o,distByteOffset:a}){const i=new Uint8Array(t,a,o),r=e.byteLength-n-o;if(r<0){i.set(new Uint8Array(e,n,e.byteLength-n));const t=new Uint8Array(-r);i.set(t)}else i.set(new Uint8Array(e,n,o));return i.buffer}static copyArrayBufferAs4Bytes({src:e,dist:t,srcByteOffset:n,copyByteLength:o,distByteOffset:a}){if(n%4!=0||o%4!=0||a%4!=0)throw new Error("Invalid byte align for 4bytes unit copy operation.");const i=new Int32Array(t,a,o/4);return i.set(new Int32Array(e,n,o/4)),i.buffer}static copyArrayBufferAs4BytesWithPadding({src:e,dist:t,srcByteOffset:n,copyByteLength:o,distByteOffset:a}){const i=new Int32Array(t,a,o/4),r=e.byteLength-n-o;if(r<0){i.set(new Int32Array(e,n,(e.byteLength-n)/4));const t=new Uint8Array(-r);i.set(t)}else i.set(new Int32Array(e,n,o/4));return i.buffer}static stringToBuffer(e){return(new TextEncoder).encode(e).buffer}}i.crc32table="00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".split(" ")},4324:(e,t,n)=>{n.d(t,{Ol:()=>r,Pq:()=>i,wJ:()=>o,yH:()=>a});class o{constructor({index:e,str:t,noCheckStrUnique:n}){if(null==o.__indices.get(this.constructor)&&o.__indices.set(this.constructor,[]),null==o.__strings.get(this.constructor)&&o.__strings.set(this.constructor,[]),-1!==o.__indices.get(this.constructor).indexOf(e))throw new Error("Dont use duplicate index.");if(!0!==n&&-1!==o.__strings.get(this.constructor).indexOf(t))throw new Error("Dont use duplicate str.");this.index=e,this.str=t,this.symbol=Symbol(t),o.__indices.get(this.constructor).push(e),o.__strings.get(this.constructor).push(t)}toString(){return this.str}toJSON(){return this.index}}function a({typeList:e,index:t}){const n=e.find((e=>e.index===t));if(n)return n}function i({typeList:e,str:t}){const n=e.find((e=>e.str.toLowerCase()===t.toLowerCase()));if(n)return n}function r({typeList:e,str:t}){const n=e.find((e=>e.str===t));if(n)return n}o.__indices=new Map,o.__strings=new Map},2229:(e,t,n)=>{n.d(t,{Is:()=>r,Q:()=>o});const o={defined:(e,...t)=>void 0!==e,undefined:(e,...t)=>void 0===e,null:(e,...t)=>null===e,exist:(e,...t)=>null!=e,function:(e,...t)=>"function"==typeof e,true:(e,...t)=>!0===e,truly:(e,...t)=>!!e,false:(e,...t)=>!1===e,falsy:(e,...t)=>!e,stringContaining:(e,t)=>-1!==e.indexOf(t)},a={not:e=>function(){return e.apply(null,[...arguments])},all:e=>function(){return Array.isArray(arguments[0])?arguments[0].every(e):[...arguments].every(e)},any:e=>function(){return Array.isArray(arguments[0])?arguments[0].some(e):[...arguments].some(e)}},i={defined:(e,...t)=>void 0===e,undefined:(e,...t)=>void 0!==e,null:(e,...t)=>null!==e,exist:(e,...t)=>null==e,function:(e,...t)=>"function"!=typeof e,true:(e,...t)=>!0!==e,truly:(e,...t)=>!e,false:(e,...t)=>!1!==e,falsy:(e,...t)=>!!e};for(const e in a)if(Object.prototype.hasOwnProperty.call(a,e)){o[e]={};for(const t in o)Object.prototype.hasOwnProperty.call(o,t)&&(o[e][t]="not"===e?a[e](i[t]):a[e](o[t]))}const r=o},3497:(e,t,n)=>{var o;n.d(t,{$:()=>o,V:()=>i}),function(e){e[e.Debug=0]="Debug",e[e.Info=1]="Info",e[e.Warn=2]="Warn",e[e.Error=3]="Error",e[e.Assert=4]="Assert"}(o||(o={}));class a{constructor(){this.message="",this.timestamp=0,this.logLevel=o.Info}}class i{static __common(e,t){if(!this.isAccumulateLog&&!this.isRichLog)return e;const n=new a;return n.message=e,n.timestamp=Date.now(),n.logLevel=t,this.isAccumulateLog&&this.__messages.push(n),this.__formatLogs(n)}static __clearAccumulatedLog(){this.__messages=[]}static __formatLogs(e){if(!this.isRichLog)return e.message;const t=new Intl.DateTimeFormat(void 0,{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"}).format(e.timestamp);return`Rn[${this.__getLogLevelText(e.logLevel)}][${t}]: ${e.message}`}static __getLogLevelText(e){return o[e]}static error(e){if(this.logLevel<=o.Error){const t=this.__common(e,o.Error);return console.error(t),t}}static warn(e){if(this.logLevel<=o.Warn){const t=this.__common(e,o.Warn);return console.warn(t),t}}static info(e){if(this.logLevel<=o.Info){const t=this.__common(e,o.Info);return console.info(t),t}}static debug(e){if(this.logLevel<=o.Debug){const t=this.__common(e,o.Debug);return console.debug(t),t}}static assert(e,t){if(this.logLevel<=o.Assert){const n=this.__common(t,o.Assert);return console.assert(e,n),n}}static getAccumulatedLog(){return this.__messages.map((e=>this.__formatLogs(e)))}}i.__messages=[],i.logLevel=o.Warn,i.isRichLog=!1,i.isAccumulateLog=!1},7681:(e,t,n)=>{n.d(t,{Bv:()=>b,CW:()=>c,Cw:()=>p,H2:()=>v,Jh:()=>m,K_:()=>d,MM:()=>g,Mf:()=>E,Sm:()=>S,TF:()=>u,VT:()=>l,XW:()=>f,Xe:()=>y,bX:()=>A,m6:()=>x,pJ:()=>r,qL:()=>I,sM:()=>_,t4:()=>s,uD:()=>h,zH:()=>T});var o=n(2229);const a=function(){const e=["iPod","iPad","iPhone","Android"];for(let t=0;t<e.length;t++)if(navigator.userAgent.indexOf(e[t])>0)return!0;return i()},i=function(){return navigator.userAgent.indexOf("Macintosh")>-1&&"ontouchend"in document},r=({value:e,defaultValue:t})=>null==e?t:e,s=(e,t)=>!!o.Is.exist(t)&&(e(t),!0),l=(e,t)=>o.Is.exist(t)?e(t):t,c=(e,t)=>!!o.Is.exist(t)&&(e(t),!0),_=(e,t)=>o.Is.exist(t)?e(t):t,u=(e,t)=>!o.Is.undefined(t)||(e(),!1),f=(e,t)=>o.Is.undefined(t)?e():t,d=(e,t)=>{o.Is.undefined(t)&&e()},h=(e,t)=>o.Is.undefined(t)?e():t,m=(e,t)=>null==t?e:t,p=({value:e,compensation:t})=>null==e?t():e,v=e=>null==e?[]:e,x=e=>null==e?new Map:e,g=(e,t)=>e>t?{result:!0,greater:e,less:t}:{result:!1,greater:t,less:e},y=(e,t)=>e<t?{result:!0,greater:t,less:e}:{result:!1,greater:e,less:t},b=e=>{const t=e.split(/\r\n|\r|\n/);let n="";for(let e=0;e<t.length;e++){const o=e+1;let a=" : ";o<10?a="  : ":o>=100&&(a=": "),n+=o+a+t[e]+"\n"}return n};function I(e){if(null==e)throw new Error(`Expected 'val' to be existed, but received ${e}`)}function A(e){return JSON.parse(JSON.stringify(e))}function E(e,t){const n=document.createElement("a");n.download=e;const o=new Blob([t],{type:"octet/stream"}),a=URL.createObjectURL(o);n.href=a;const i=new MouseEvent("click");n.dispatchEvent(i),URL.revokeObjectURL(a)}function S(e,t){const n=document.createElement("a");n.download=e;const o=new Blob([t],{type:"octet/stream"}),a=URL.createObjectURL(o);n.href=a;const i=new MouseEvent("click");n.dispatchEvent(i),URL.revokeObjectURL(a)}const T=Object.freeze({isMobileVr:function(){return/(Pacific Build.+OculusBrowser.+SamsungBrowser.+)|(SamsungBrowser)|(Mobile VR)/i.test(window.navigator.userAgent)},isMobile:a,isIOS:function(){const e=["iPod","iPad","iPhone"];for(let t=0;t<e.length;t++)if(navigator.userAgent.indexOf(e[t])>0)return!0;return i()},isSafari:function(){return navigator.userAgent.indexOf("Safari")>0&&-1===navigator.userAgent.indexOf("Chrome")},preventDefaultForDesktopOnly:function(e){a()||e.preventDefault()},isObject:function(e){return e instanceof Object&&!(e instanceof Array)},fillTemplate:function(e,t){return new Function("return `"+e+"`;").call(t)},isNode:function(){return"undefined"!=typeof process&&!0},concatArrayBuffers:function(e,t,n,o){let a,i=0;for(let e=0;e<t.length;++e)i+=t[e];a=null!=o?new Uint8Array(o):new Uint8Array(i);const r=e=>null!=o&&s+e>o?s+e-o:0;let s=0;const l=(t,o)=>{const i=r(t);return i?(a.set(new Uint8Array(e[o],n[o],i),s),s+=i,!0):(a.set(new Uint8Array(e[o],n[o],t),s),s+=t,!1)},c=e=>{const t=r(e);return t?(a.set(new Uint8Array(t),s),s+=t,!0):(a.set(new Uint8Array(e),s),s+=e,!1)};for(let o=0;o<e.length;++o){const i=t[o]+n[o]-e[o].byteLength,r=i>0?i:0;if(l(t[o]-r,o))return a.buffer;if(r>0&&c(r))return a.buffer}return null!=o&&s<o&&a.set(new Uint8Array(o-s),s),a.buffer},concatArrayBuffers2:({finalSize:e,srcs:t,srcsOffset:n,srcsCopySize:o})=>{const a=new Uint8Array(new ArrayBuffer(e));let i=0;for(const e in t){const r=t[e],s=new Uint8Array(r,n[e],o[e]);a.set(s,i),i+=o[e]}return a.buffer},addLineNumberToCode:b,downloadArrayBuffer:E,downloadTypedArray:S})},1276:(e,t,n)=>{n.d(t,{BA:()=>s,NV:()=>i,Xt:()=>r,p2:()=>a});const o="The value does not exist!";class a{constructor(e){this.value=e}andThen(e){return e(this.value)}orElse(e){return this}match(e){return e.Some(this.value)}unwrapOrDefault(e){return this.value}unwrapOrElse(e){return this.value}unwrapForce(){return this.value}unwrapOrUndefined(){return this.value}get(){return this.value}has(){return!0}doesNotHave(){return!1}}class i{andThen(e){return this}orElse(e){return e()}match(e){return e.None()}unwrapOrDefault(e){return e}unwrapOrElse(e){return e()}unwrapForce(){throw new ReferenceError(o)}unwrapOrUndefined(){}has(){return!1}doesNotHave(){return!0}}function r(e){if(!e.has())throw new ReferenceError(o)}function s(e){if(e.has())throw new ReferenceError(o)}},8556:(e,t,n)=>{n.d(t,{Ok:()=>i,_:()=>r,j3:()=>s,ou:()=>l});var o=n(9908);class a{constructor(e){this.val=e}match(e){if(this instanceof i)return new i(e.Ok(this.val));if(this instanceof r)return new r(e.Err(this.val));throw new Error("This is neither Ok nor Err.")}name(){return this.constructor.name}}class i extends a{constructor(e){super(e)}andThen(e){return e(this.val)}orElse(e){return this}unwrapWithCompensation(e){return this.val}unwrapForce(){return this.val}true(){return!0}isOk(){return!0}isErr(){return!1}get(){return this.val}}class r extends a{constructor(e){super(e),this._rnException=new o.O(this.val)}andThen(e){return this}orElse(e){return e()}unwrapWithCompensation(e){return e(this.val)}unwrapForce(){throw this._rnException}false(){return!1}isOk(){return!1}isErr(){return!0}getRnError(){return this.val}toString(){return this._rnException.stack}}function s(e){if(e.isErr())throw new Error("This is Err. No Ok.")}function l(e){if(e.isOk())throw new Error("This is Ok. No Err.")}},9908:(e,t,n)=>{n.d(t,{O:()=>o});class o extends Error{constructor(e){super(`\n  message: ${e.message}\n  error: ${void 0!==e.error._rnException?"see below Exception ↓"+e.error.toString():e.error}\n`),this.err=e,this.name=o._prefix}getRnError(){return this.err}}o._prefix="\nRhodonite Exception"},1692:(e,t,n)=>{n.d(t,{m:()=>o});class o extends Promise{constructor(e){super(((e,t)=>{})),this.name="",this.__callbackObj={promiseAllNum:0,resolvedNum:0,rejectedNum:0,pendingNum:0,processedPromises:[]},this.__promise=e instanceof Promise?e:new Promise(e)}static resolve(e){if(e instanceof Promise)return new o(e);if(e instanceof o)return e;if(null!=e.then){const t=new o(((t,n)=>{t(e)}));return t.then=e.then,t}return new o(((t,n)=>{t(e)}))}static all(e,t){if(t){const n=[],a={promiseAllNum:e.length,resolvedNum:0,rejectedNum:0,pendingNum:e.length,processedPromises:[]};for(const i of e){const e=o.resolve(i);e.__callback=t,e.__callbackObj=a,n.push(e)}return new o(Promise.all(n))}return new o(Promise.all(e))}static race(e){return new o(Promise.race(e))}then(e,t){let n;return e&&(n=t=>(0!==this.__callbackObj.promiseAllNum&&-1===this.__callbackObj.processedPromises.indexOf(this)&&(this.__callbackObj.pendingNum--,this.__callbackObj.resolvedNum++,this.__callbackObj.processedPromises.push(this)),this.__callback&&this.__callback(this.__callbackObj),e(t))),this.__promise.then(n,t)}catch(e){return new o(this.__promise.catch(e))}finally(e){return this.__promise.finally(e)}static reject(e){return new o(Promise.reject(e))}}},6612:(e,t,n)=>{n.d(t,{g:()=>o});class o{static _processBegin(){o.__currentProcessBeginTime=performance.now(),o.__intervalProcessBegin=o.__currentProcessBeginTime-o.__lastProcessBeginTime,0===o.__systemStartTime&&(o.__systemStartTime=o.__currentProcessBeginTime),o.__lastProcessBeginTime=o.__currentProcessBeginTime}static _processEnd(){o.__lastProcessEndTime=performance.now(),o.__lastTickTimeInterval=o.__lastProcessEndTime-o.__currentProcessBeginTime}static get timeAtProcessBeginMilliseconds(){return o.__currentProcessBeginTime}static get timeAtProcessEndMilliseconds(){return o.__lastProcessEndTime}static get timeFromSystemStart(){return(performance.now()-o.__systemStartTime)/1e3}static get lastTickTimeInterval(){return o.__lastTickTimeInterval/1e3}static get intervalProcessBegin(){return o.__intervalProcessBegin/1e3}static get lastTimeTimeIntervalInMilliseconds(){return o.__lastTickTimeInterval}}o.__currentProcessBeginTime=0,o.__lastProcessBeginTime=0,o.__lastProcessEndTime=0,o.__lastTickTimeInterval=0,o.__systemStartTime=0,o.__intervalProcessBegin=0},6301:(e,t,n)=>{n.d(t,{l2:()=>i,$j:()=>l.$,wJ:()=>c.wJ,_:()=>w._,aV:()=>E,Is:()=>o.Is,Qg:()=>o.Q,$b:()=>B.$,Vy:()=>B.V,zH:()=>S.zH,NV:()=>T.NV,Ok:()=>w.Ok,OD:()=>R.O,m9:()=>C.m,p2:()=>T.p2,DP:()=>a,gX:()=>P.g,vK:()=>F,Ko:()=>M,$l:()=>D,yH:()=>c.yH,Pq:()=>c.Pq,Ol:()=>c.Ol,Bv:()=>S.Bv,BA:()=>T.BA,qL:()=>S.qL,Xt:()=>T.Xt,ou:()=>w.ou,j3:()=>w.j3,gH:()=>A,PS:()=>I,bX:()=>S.bX,Jh:()=>S.Jh,Mf:()=>S.Mf,Sm:()=>S.Sm,MM:()=>S.MM,CW:()=>S.CW,sM:()=>S.sM,t4:()=>S.t4,VT:()=>S.VT,K_:()=>S.K_,uD:()=>S.uD,TF:()=>S.TF,XW:()=>S.XW,Xe:()=>S.Xe,H2:()=>S.H2,m6:()=>S.m6,Js:()=>r,yC:()=>s,Cw:()=>S.Cw,pJ:()=>S.pJ});var o=n(2229);class a{constructor(){this.__weakMap=new WeakMap}set(e,t){return!this.__weakMap.has(e)&&(this.__weakMap.set(e,t),!0)}has(e){return!!this.__weakMap.has(e)}get(e){const t=this.__weakMap.get(e);if(!o.Is.not.exist(t))return this.__weakMap.get(e)}delete(e){return!!this.__weakMap.has(e)&&(this.__weakMap.delete(e),!0)}}class i{constructor(){this.__symbolWeakMap=new a}register(e){this.__symbolWeakMap.set(Symbol(),e)}}const r=e=>{const t=new WeakMap;return n=>{if(t.has(n))return t.get(n);const o=e(n);return t.set(n,o),o}},s=e=>{const t=new Map;return n=>{if(t.has(n))return t.get(n);const o=e(n);return t.set(n,o),o}};var l=n(5065),c=n(4324),_=n(975),u=n(2162),f=n(6941),d=n(5697),h=n(1525),m=n(5882),p=n(1238);function v(e,t,n){const o=1<<t;let a=0;for(let t=0;t<e.height;t+=o)for(let i=0;i<e.width;i+=o){let r=0,s=0;for(let a=0;a<o;a++)for(let l=0;l<o;l++){const o=e.getPixel(i+l,t+a,n);r+=o,s+=o*o}r/=o*o,s/=o*o,a+=Math.max(0,s-r*r)/(e.width*e.height/o/o)}return a}function x(e,t,n,o,a=128){const i=2*a;let r=0;for(let s=0;s<i;s++){const l=(s+.5)/i,c=f.z.invGaussianCdf(l,t,n),_=Math.max(0,Math.min(a-1,Math.floor(c*a)));r+=e.getPixelAsArray(_,0)[o]}return r/=i,r}function g(e,t,n){for(let o=1;o<t.height;o++){const a=v(e,o,n),i=Math.sqrt(a);for(let e=0;e<t.width;e++){const a=x(t,(e+.5)/t.width,i,n);t.setPixelAtChannel(e,o,n,a)}}}function y(e,t,n,o=.5,a=.16666){const i=function(e){const t=[];for(let n=0;n<e;n++)t.push({});return t}(e.height*e.width);for(let t=0;t<e.height;t++)for(let o=0;o<e.width;o++)i[t*e.width+o].x=o,i[t*e.width+o].y=t,i[t*e.width+o].value=e.getPixel(o,t,n);i.sort(((e,t)=>e.value<t.value?-1:e.value>t.value?1:0));for(let e=0;e<i.length;e++){const r=i[e].x,s=i[e].y,l=(e+.5)/i.length,c=f.z.invGaussianCdf(l,o,a);t.setPixelAtChannel(r,s,n,c)}}function b(e,t,n,o=.5,a=.16666){const i=[];for(let t=0;t<e.height;t++)for(let o=0;o<e.width;o++)i[t*e.width+o]=e.getPixel(o,t,n);i.sort(((e,t)=>e<t?-1:e>t?1:0));for(let e=0;e<t.width;e++){const r=(e+.5)/t.width,s=f.z.gaussianCdf(r,o,a),l=i[Math.floor(s*i.length)];t.setPixelAtChannel(e,0,n,l)}}function I(e,t,n){const o=document.createElement("canvas");return o.width=t,o.height=n,o.getContext("2d").drawImage(e,0,0,e.width,e.height,0,0,t,n),o}function A(e){const t=e.width,n=e.height,a=document.createElement("canvas");a.width=t,a.height=n;const i=a.getContext("2d"),r=i.getImageData(0,0,t,n);if(o.Is.exist(e.r_image)){const o=e.r_image.getContext("2d").getImageData(0,0,e.r_image.width,e.r_image.height);for(let e=0;e<t*n;e++)r.data[4*e+0]=o.data[4*e+0]}else for(let e=0;e<t*n;e++)r.data[4*e+0]=0;if(o.Is.exist(e.g_image)){const o=e.g_image.getContext("2d").getImageData(0,0,e.g_image.width,e.g_image.height);for(let e=0;e<t*n;e++)r.data[4*e+1]=o.data[4*e+1]}else for(let e=0;e<t*n;e++)r.data[4*e+1]=0;if(o.Is.exist(e.b_image)){const o=e.b_image.getContext("2d").getImageData(0,0,e.b_image.width,e.b_image.height);for(let e=0;e<t*n;e++)r.data[4*e+2]=o.data[4*e+2]}else for(let e=0;e<t*n;e++)r.data[4*e+2]=0;if(o.Is.exist(e.a_image)){const o=e.a_image.getContext("2d").getImageData(0,0,e.a_image.width,e.a_image.height);for(let e=0;e<t*n;e++)r.data[4*e+3]=o.data[4*e+3]}else for(let e=0;e<t*n;e++)r.data[4*e+3]=0;return i.putImageData(r,0,0),a}const E=Object.freeze({precomputations:function(e,t=128){const n={};n.lutWidth=t,n.colorSpaceVector1=d.tp.zero(),n.colorSpaceVector2=d.tp.zero(),n.colorSpaceVector3=d.tp.zero(),n.colorSpaceOrigin=d.tp.zero();const o=new p.C(e.width,e.height,3);!function(e,t,n,o,a,i){const r=[d.tp.zero(),d.tp.zero(),d.tp.zero()];!function(e,t){let n=0,o=0,a=0,i=0,r=0,s=0,l=0,c=0,m=0;for(let t=0;t<e.height;t++)for(let _=0;_<e.width;_++){const u=e.getPixelAs(_,t,3,h.x);n+=u.x,o+=u.y,a+=u.z,i+=u.x*u.x,r+=u.y*u.y,s+=u.z*u.z,l+=u.x*u.y,c+=u.x*u.z,m+=u.y*u.z}const p=e.width*e.height;n/=p,o/=p,a/=p,i/=p,r/=p,s/=p,l/=p,c/=p,m/=p;const v=u._.zero();v.m00=i-n*n,v.m01=l-n*o,v.m02=c-n*a,v.m10=l-n*o,v.m11=r-o*o,v.m12=m-o*a,v.m20=c-n*a,v.m21=m-o*a,v.m22=s-a*a;const x=u._.zero(),g=d.tp.zero();f.z.computeEigenValuesAndVectors(v,x,g),t[0]=_.Pq.fromCopyArray([x.m00,x.m10,x.m20]),t[1]=_.Pq.fromCopyArray([x.m01,x.m11,x.m21]),t[2]=_.Pq.fromCopyArray([x.m02,x.m12,x.m22])}(e,r);for(let n=0;n<e.height;n++)for(let o=0;o<e.width;o++)for(let a=0;a<3;++a){const i=e.getPixelAs(o,n,3,h.x),s=_.Pq.dot(i,r[a]);t.setPixelAtChannel(o,n,a,s)}const s=[m.A3.fromCopyArray2([Number.MAX_VALUE,-Number.MAX_VALUE]),m.A3.fromCopyArray2([Number.MAX_VALUE,-Number.MAX_VALUE]),m.A3.fromCopyArray2([Number.MAX_VALUE,-Number.MAX_VALUE])];for(let n=0;n<e.height;n++)for(let o=0;o<e.width;o++)for(let e=0;e<3;++e)s[e].x=Math.min(s[e].x,t.getPixelAsArray(o,n)[e]),s[e].y=Math.max(s[e].y,t.getPixelAsArray(o,n)[e]);for(let n=0;n<e.height;n++)for(let o=0;o<e.width;o++)for(let e=0;e<3;++e){const a=(t.getPixelAsArray(o,n)[e]-s[e].x)/(s[e].y-s[e].x);t.setPixelAtChannel(o,n,e,a)}i.x=s[0].x*r[0].x+s[1].x*r[1].x+s[2].x*r[2].x,i.y=s[0].x*r[0].y+s[1].x*r[1].y+s[2].x*r[2].y,i.z=s[0].x*r[0].z+s[1].x*r[1].z+s[2].x*r[2].z,n.x=r[0].x*(s[0].y-s[0].x),n.y=r[0].y*(s[0].y-s[0].x),n.z=r[0].z*(s[0].y-s[0].x),o.x=r[1].x*(s[1].y-s[1].x),o.y=r[1].y*(s[1].y-s[1].x),o.z=r[1].z*(s[1].y-s[1].x),a.x=r[2].x*(s[2].y-s[2].x),a.y=r[2].y*(s[2].y-s[2].x),a.z=r[2].z*(s[2].y-s[2].x)}(e,o,n.colorSpaceVector1,n.colorSpaceVector2,n.colorSpaceVector3,n.colorSpaceOrigin);const a=new p.C(e.width,e.height,3);n.Tinput=a;for(let e=0;e<3;e++)y(o,a,e);const i=new p.C(t,1,3);n.Tinv=i;for(let e=0;e<3;e++)b(o,i,e);i.resize(i.width,Math.floor(Math.log(a.width)/Math.log(2)),3);for(let e=0;e<3;e++)g(a,i,e);return n}});var S=n(7681),T=n(1276),w=n(8556),C=n(1692),R=n(9908),P=n(6612);const N="The value does not exist!";class M{constructor(){this.__weakMap=new WeakMap}set(e,t){this.__weakMap.set(e,t)}unwrapOrDefault(e,t){const n=this.__weakMap.get(e);return o.Is.exist(n)?n:t}unwrapOrElse(e,t){const n=this.__weakMap.get(e);return o.Is.exist(n)?n:t()}unwrapForce(e){const t=this.__weakMap.get(e);if(o.Is.exist(t))return t;throw new ReferenceError(N)}unwrapOrUndefined(e){return this.__weakMap.get(e)}has(e){return this.__weakMap.has(e)}}class D{constructor(e,t){this.__weakMap=new WeakMap,this.__weakMap.set(e,t)}unwrapOrDefault(e,t){return this.__weakMap.get(e)}unwrapOrElse(e,t){return this.__weakMap.get(e)}unwrapForce(e){return this.__weakMap.get(e)}get(e){return this.__weakMap.get(e)}unwrapOrUndefined(e){return this.__weakMap.get(e)}has(e){return!0}}class F{then(){return this}unwrapOrDefault(e,t){return t}unwrapOrElse(e,t){return t(void 0)}unwrapForce(e){throw new ReferenceError(N)}unwrapOrUndefined(e){}has(){return!1}}var B=n(3497)},9179:(e,t,n)=>{n.d(t,{N:()=>r});var o=n(6227),a=n(975),i=n(2229);class r{constructor(){if(this.__localScale=a.Pq.one(),i.Is.not.exist(r.__world)){const e=new OIMO.World({timestep:1/60,iterations:8,broadphase:2,worldscale:1,random:r.__worldProperty.random,info:!1,gravity:[r.__worldProperty.gravity.x,r.__worldProperty.gravity.y,r.__worldProperty.gravity.z]});r.__world=e}}setShape(e,t){const n=r.__world;this.__localScale=e.size,this.__property={type:e.type.str.toLowerCase(),size:[e.size.x,e.size.y,e.size.z],pos:[e.position.x,e.position.y,e.position.z],rot:[e.rotation.x,e.rotation.y,e.rotation.z],move:e.move,density:e.density,friction:e.friction,restitution:e.restitution},this.__body=n.add(this.__property),this.__entity=t}update(){if(void 0===this.__entity)return;const e=this.__body.getPosition(),t=this.__body.getQuaternion();this.__entity.getSceneGraph().setPositionWithoutPhysics(a.Pq.fromCopy3(e.x,e.y,e.z)),this.__entity.getSceneGraph().setRotationWithoutPhysics(o.PT.fromCopy4(t.x,t.y,t.z,t.w))}setPosition(e){const t=r.__world;if(void 0===this.__entity)return;this.__body.remove();const n=this.__property;this.__property={type:n.type,size:[n.size[0],n.size[1],n.size[2]],pos:[e.x,e.y,e.z],rot:[this.__entity.eulerAngles.x,this.__entity.eulerAngles.y,this.__entity.eulerAngles.z],move:n.move,density:n.density,friction:n.friction,restitution:n.restitution},this.__body=t.add(this.__property)}setEulerAngle(e){const t=r.__world;if(void 0===this.__entity)return;const n=this.__body.getPosition();this.__body.remove();const a=this.__property;this.__property={type:a.type,size:[a.size[0],a.size[1],a.size[2]],pos:[n.x,n.y,n.z],rot:[o.St.radianToDegree(e.x),o.St.radianToDegree(e.y),o.St.radianToDegree(e.z)],move:a.move,density:a.density,friction:a.friction,restitution:a.restitution},this.__body=t.add(this.__property)}setScale(e){const t=r.__world;if(void 0===this.__entity)return;const n=this.__body.getPosition();this.__body.remove();const o=this.__property;this.__property={type:o.type,size:[this.__localScale.x*e.x,this.__localScale.y*e.y,this.__localScale.z*e.z],pos:[n.x,n.y,n.z],rot:[this.__entity.eulerAngles.x,this.__entity.eulerAngles.y,this.__entity.eulerAngles.z],move:o.move,density:o.density,friction:o.friction,restitution:o.restitution},this.__body=t.add(this.__property)}static update(){i.Is.exist(r.__world)&&r.__world.step()}}r.__worldProperty={gravity:a.Pq.fromCopy3(0,-9.8,0),random:!0}},4772:(e,t,n)=>{n.d(t,{f:()=>r});var o=n(3583),a=n(7670),i=n(2766);class r{static getCgApiResourceRepository(){const e=i.m7.isWebGL2Approach(a.l.currentProcessApproach)?"webgl":"webgpu",t=o.e.getInstance().getModule(e);return"webgl"===e?t.WebGLResourceRepository.getInstance():null==t?void 0:t.WebGpuResourceRepository.getInstance()}static getWebGLResourceRepository(){return o.e.getInstance().getModule("webgl").WebGLResourceRepository.getInstance()}static getWebGpuResourceRepository(){return o.e.getInstance().getModule("webgpu").WebGpuResourceRepository.getInstance()}}r.InvalidCGAPIResourceUid=-1},5738:(e,t,n)=>{n.d(t,{r:()=>a});var o=n(8819);class a extends o.E{constructor(){super(),this.__renderPasses=[]}clone(){const e=new a;e.tryToSetUniqueName(this.uniqueName+"_cloned",!0);const t=[];for(const e of this.__renderPasses)t.push(e.clone());return e.addRenderPasses(t),e}addRenderPasses(e){for(const t of e)this.__renderPasses.push(t)}clearRenderPasses(){this.__renderPasses.length=0}get renderPasses(){return this.__renderPasses}setViewport(e){for(const t of this.__renderPasses)t.setViewport(e)}}},6455:(e,t,n)=>{n.d(t,{w:()=>i});var o=n(8819),a=n(2229);class i extends o.E{constructor(){super(),this.__expressions=[],this.__expressionsCache=[],this.__expressionQueries=[]}addExpression(e,{inputRenderPasses:t,outputs:n}={inputRenderPasses:[],outputs:[]}){if(a.Is.exist(n))for(const t of n){let n=t.renderPass.instance;a.Is.exist(t.renderPass.instance)?n=t.renderPass.instance:a.Is.exist(t.renderPass.index)?n=e.renderPasses[t.renderPass.index]:a.Is.exist(t.renderPass.uniqueName)&&(n=o.E.getRnObjectByName(t.renderPass.uniqueName)),a.Is.exist(n)&&n.setFramebuffer(t.frameBuffer)}this.__expressions.push({expression:e,inputRenderPasses:a.Is.exist(t)?t:[]}),this.__expressionsCache.push(e)}getColorAttachmentFromInputOf(e,t={renderPass:{index:0},colorAttachmentIndex:0,framebufferType:i.FrameBuffer}){return new Promise((n=>{const o=function*(){const e=yield;return n(e),e}();this.__expressionQueries.push([e,t.renderPass,t.colorAttachmentIndex,o,t.framebufferType])}))}resolve(){for(const[e,t,n,i,r]of this.__expressionQueries)for(const s of this.__expressions)if(e===s.expression){let e,l=t.instance;if(a.Is.exist(t.instance)?l=t.instance:a.Is.exist(t.index)?l=s.inputRenderPasses[t.index]:a.Is.exist(t.uniqueName)&&(l=o.E.getRnObjectByName(t.uniqueName)),"ResolveFrameBuffer2"===r?e=l.getResolveFramebuffer2():"ResolveFrameBuffer"===r?e=l.getResolveFramebuffer():"FrameBuffer"===r&&(e=l.getFramebuffer()),a.Is.exist(e)){const t=e.getColorAttachedRenderTargetTexture(n);a.Is.exist(t)&&(i.next(t),i.next(t))}}}clearExpressions(){this.__expressions.length=0,this.__expressionsCache.length=0}get expressions(){return this.__expressionsCache}setViewport(e){for(const t of this.__expressions)t.expression.setViewport(e)}}i.FrameBuffer="FrameBuffer",i.ResolveFrameBuffer="ResolveFrameBuffer",i.ResolveFrameBuffer2="ResolveFrameBuffer2"},2889:(e,t,n)=>{n.d(t,{A:()=>f});var o=n(8819),a=n(3414),i=n(700),r=n(960),s=n(8924),l=n(4289),c=n(6947),_=n(4772),u=n(1614);class f extends o.E{constructor(){super(),this.__entities=[],this.__sceneGraphDirectlyAdded=[],this.__topLevelSceneGraphComponents=[],this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__primitiveMaterial=new Map,this.toClearColorBuffer=!1,this.toClearDepthBuffer=!0,this.toClearStencilBuffer=!1,this.isDepthTest=!0,this.depthWriteMask=!0,this.clearColor=a.IU.fromCopyArray([1,1,1,1]),this.clearDepth=1,this.clearStencil=0,this._drawVertexNumberForBufferLessRendering=0,this._primitiveModeForBufferLessRendering=c.R.Triangles,this._dummyPrimitiveForBufferLessRendering=new r.s,this.isVrRendering=!0,this.isOutputForVr=!1,this._lastOpaqueIndex=-1,this._lastTranslucentIndex=-1,this._lastBlendWithZWriteIndex=-1,this._lastBlendWithoutZWriteIndex=-1,this._lastPrimitiveUids=[],this._lastTransformComponentsUpdateCount=-1,this._lastCameraControllerComponentsUpdateCount=-1,this._lastSceneGraphComponentsUpdateCount=-1,this._renderedSomethingBefore=!0,this._isChangedSortRenderResult=!1,this._toRenderOpaquePrimitives=!0,this._toRenderTranslucentPrimitives=!0,this._toRenderBlendWithZWritePrimitives=!0,this._toRenderBlendWithoutZWritePrimitives=!0,this.toRenderEffekseerEffects=!1,this.__renderPassUID=++f.__mesh_uid_count}setToRenderOpaquePrimitives(e){this._toRenderOpaquePrimitives=e,this.__calcMeshComponents()}setToRenderBlendWithoutZWritePrimitives(e){this._toRenderBlendWithoutZWritePrimitives=e,this.__calcMeshComponents()}setToRenderBlendWithZWritePrimitives(e){this._toRenderBlendWithZWritePrimitives=e,this.__calcMeshComponents()}setToRenderTranslucentPrimitives(e){this._toRenderTranslucentPrimitives=e,this.__calcMeshComponents()}isBufferLessRenderingMode(){return this._drawVertexNumberForBufferLessRendering>0}setBufferLessRendering(e,t,n){this._primitiveModeForBufferLessRendering=e,this._drawVertexNumberForBufferLessRendering=t,this.__material=n}setBufferLessFullScreenRendering(e){this._primitiveModeForBufferLessRendering=c.R.Triangles,this._drawVertexNumberForBufferLessRendering=3,this.__material=e}clone(){var e,t;const n=new f;return n.tryToSetUniqueName(this.uniqueName+"_cloned",!0),n.__entities=this.__entities.concat(),n.__sceneGraphDirectlyAdded=this.__sceneGraphDirectlyAdded.concat(),n.__topLevelSceneGraphComponents=this.__topLevelSceneGraphComponents.concat(),n.__meshComponents=this.__meshComponents.concat(),n.__optimizedMeshComponents=this.__optimizedMeshComponents.concat(),n.__frameBuffer=this.__frameBuffer,n.__resolveFrameBuffer=this.__resolveFrameBuffer,n.__resolveFrameBuffer2=this.__resolveFrameBuffer2,n.__viewport=null===(e=this.__viewport)||void 0===e?void 0:e.clone(),n.toClearColorBuffer=this.toClearColorBuffer,n.toClearDepthBuffer=this.toClearDepthBuffer,n.toClearStencilBuffer=this.toClearStencilBuffer,n.isDepthTest=this.isDepthTest,n.clearColor=this.clearColor.clone(),n.clearDepth=this.clearDepth,n.clearStencil=this.clearStencil,n.cameraComponent=this.cameraComponent,n.__material=this.__material,n.__primitiveMaterial=new Map(this.__primitiveMaterial),n.isVrRendering=this.isVrRendering,n.isOutputForVr=this.isOutputForVr,n._toRenderOpaquePrimitives=this._toRenderOpaquePrimitives,n._toRenderTranslucentPrimitives=this._toRenderTranslucentPrimitives,n._toRenderBlendWithoutZWritePrimitives=this._toRenderBlendWithoutZWritePrimitives,n.__postEachRenderFunc=this.__postEachRenderFunc,n.__renderTargetColorAttachments=null===(t=this.__renderTargetColorAttachments)||void 0===t?void 0:t.concat(),n._lastOpaqueIndex=this._lastOpaqueIndex,n._lastTranslucentIndex=this._lastTranslucentIndex,n._lastBlendWithZWriteIndex=this._lastBlendWithZWriteIndex,n._lastBlendWithoutZWriteIndex=this._lastBlendWithoutZWriteIndex,n._lastPrimitiveUids=this._lastPrimitiveUids.concat(),n._lastTransformComponentsUpdateCount=this._lastTransformComponentsUpdateCount,n._lastCameraControllerComponentsUpdateCount=this._lastCameraControllerComponentsUpdateCount,n._lastSceneGraphComponentsUpdateCount=this._lastSceneGraphComponentsUpdateCount,n._renderedSomethingBefore=this._renderedSomethingBefore,n._isChangedSortRenderResult=this._isChangedSortRenderResult,n}setPostRenderFunction(e){this.__postEachRenderFunc=e}doPostRender(){null!=this.__postEachRenderFunc&&this.__postEachRenderFunc()}addEntities(e){for(const t of e){const e=t.getSceneGraph();this.__sceneGraphDirectlyAdded.push(e);const n=(0,u.g)(e,!1).map((e=>e.entity)),o=this.__entities.concat(n).reduce(((e,t)=>(e.set(t.entityUID,t),e)),new Map);this.__entities=Array.from(o.values())}this.__calcMeshComponents(),this.__topLevelSceneGraphComponents=[],this.__collectTopLevelSceneGraphComponents()}__calcMeshComponents(){this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__collectMeshComponents()}get entities(){return this.__entities}clearEntities(){this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__topLevelSceneGraphComponents=[],this.__entities=[]}__collectTopLevelSceneGraphComponents(){const e=t=>(t.parent&&e(t.parent),t);this.__topLevelSceneGraphComponents=this.__sceneGraphDirectlyAdded.map((t=>e(t)));const t=new Set(this.__topLevelSceneGraphComponents);this.__topLevelSceneGraphComponents=Array.from(t)}__collectMeshComponents(){this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__entities.filter((e=>{const t=e.getComponentByComponentTID(l.N.MeshComponentTID);if(null!=t&&null!=t.mesh){if(this.__meshComponents.push(t),!this._toRenderOpaquePrimitives&&t.mesh.isExistOpaque())return;if(!this._toRenderTranslucentPrimitives&&t.mesh.isExistTranslucent())return;if(!this._toRenderBlendWithZWritePrimitives&&t.mesh.isExistBlendWithZWrite())return;if(!this._toRenderBlendWithoutZWritePrimitives&&t.mesh.isExistBlendWithoutZWrite())return;this.__optimizedMeshComponents.push(t)}}))}get meshComponents(){return this.__meshComponents}get _optimizedMeshComponents(){return this.__optimizedMeshComponents}get sceneTopLevelGraphComponents(){return this.__topLevelSceneGraphComponents}setFramebuffer(e){this.__frameBuffer=e,null!=e?this.setViewport(a.IU.fromCopyArray([0,0,e.width,e.height])):this.__viewport=void 0}setRenderTargetColorAttachments(e){this.__renderTargetColorAttachments=e}getRenderTargetColorAttachments(){return this.__renderTargetColorAttachments}getFramebuffer(){return this.__frameBuffer}removeFramebuffer(){this.__frameBuffer=void 0}setViewport(e){null!=this.__viewport?this.__viewport.copyComponents(e):this.__viewport=s.Am.fromCopyArray([e.x,e.y,e.z,e.w])}getViewport(){let e=this.__viewport;return null!=e&&(e=f.__tmp_Vector4_0.copyComponents(e)),e}setResolveFramebuffer(e){this.__resolveFrameBuffer=e}getResolveFramebuffer(){return this.__resolveFrameBuffer}setResolveFramebuffer2(e){this.__resolveFrameBuffer2=e}getResolveFramebuffer2(){return this.__resolveFrameBuffer2}_copyFramebufferToResolveFramebuffersWebGL(){this.__copyFramebufferToResolveFramebufferInner(this.__resolveFrameBuffer),this.__copyFramebufferToResolveFramebufferInner(this.__resolveFrameBuffer2)}__copyFramebufferToResolveFramebufferInner(e){if(null==e)return;const t=i.u.getInstance(),n=t.getWebGLResource(this.__frameBuffer.cgApiResourceUid),o=t.getWebGLResource(e.cgApiResourceUid);if(null==n||null==o)return;const a=t.currentWebGLContextWrapper.getRawContextAsWebGL2();a.bindFramebuffer(a.READ_FRAMEBUFFER,n),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,o),a.blitFramebuffer(0,0,this.__frameBuffer.width,this.__frameBuffer.height,0,0,e.width,e.height,a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT,a.NEAREST),a.bindFramebuffer(a.READ_FRAMEBUFFER,null),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}_copyResolve1ToResolve2WebGpu(){if(null==this.__resolveFrameBuffer||null==this.__resolveFrameBuffer2)return;const e=_.f.getWebGpuResourceRepository();for(let t=0;t<this.__resolveFrameBuffer.colorAttachments.length;t++)null!=this.__resolveFrameBuffer.colorAttachments[t]&&null!=this.__resolveFrameBuffer2.colorAttachments[t]&&-1!==this.__resolveFrameBuffer.colorAttachments[t]._textureResourceUid&&-1!==this.__resolveFrameBuffer2.colorAttachments[t]._textureResourceUid&&e.copyTextureData(this.__resolveFrameBuffer.colorAttachments[t]._textureResourceUid,this.__resolveFrameBuffer2.colorAttachments[t]._textureResourceUid)}setMaterialForPrimitive(e,t){this.__primitiveMaterial.set(t.objectUID,new WeakRef(e))}setMaterial(e){this.__material=e}get material(){return this.__material}_getMaterialOf(e){var t;return null===(t=this.__primitiveMaterial.get(e.objectUID))||void 0===t?void 0:t.deref()}__hasMaterialOf(e){return this.__primitiveMaterial.has(e.objectUID)}getAppropriateMaterial(e){let t=this._getMaterialOf(e);return null!=t||(t=null!=this.__material?this.__material:e.material),t}get renderPassUID(){return this.__renderPassUID}}f.__tmp_Vector4_0=s.Am.zero(),f.__mesh_uid_count=-1},8909:(e,t,n)=>{n.d(t,{I:()=>s,M:()=>r});var o=n(3212),a=n(2229),i=n(7670);function r(e,t){return-1===e.getShaderProgramUid(t)}function s(e){const t=e.getPrimitiveNumber();for(let n=0;n<t;n++){const t=e.getPrimitiveAt(n);a.Is.exist(t.vertexHandles)?t.update3DAPIVertexData():t.create3DAPIVertexData()}e.updateVariationVBO(),i.l.currentProcessApproach!==o.m.WebGPU&&e.updateVAO()}},123:(e,t,n)=>{n.d(t,{s:()=>i});var o=n(2229),a=n(7681);class i{constructor(){this.__subscriberMap=new Map}subscribe(e,t){let n=this.__subscriberMap.get(e);return o.Is.not.exist(n)&&(this.__subscriberMap.set(e,[]),n=this.__subscriberMap.get(e)),n.push(t)-1}unsubscribe(e,t){const n=this.__subscriberMap.get(e);null!=n&&n.splice(t,1)}unsubscribeAll(e){this.__subscriberMap.delete(e)}publishAsync(e,t){let n=0;const o=(0,a.H2)(this.__subscriberMap.get(e));for(const e of o)setTimeout(e.bind(this,t),0),n++;return n}publishSync(e,t){let n=0;const o=(0,a.H2)(this.__subscriberMap.get(e));for(const e of o)e(t),n++;return n}}},4849:(e,t,n)=>{n.d(t,{B$:()=>H,BU:()=>N,Bn:()=>c,CD:()=>S,CO:()=>B,E0:()=>D,EA:()=>_,Go:()=>I,H9:()=>L,Hg:()=>g,IE:()=>U,IU:()=>z,J5:()=>s,Kq:()=>P,LZ:()=>C,O3:()=>p,Oi:()=>T,Ol:()=>G,P6:()=>v,QL:()=>a,S8:()=>f,WD:()=>l,Wt:()=>Q,X2:()=>O,XX:()=>d,XZ:()=>r,Zc:()=>W,_M:()=>E,bg:()=>h,cK:()=>X,dM:()=>V,eN:()=>j,g1:()=>k,kV:()=>F,lX:()=>w,o9:()=>q,oN:()=>b,oO:()=>M,pF:()=>y,qm:()=>u,rO:()=>x,uR:()=>m,vH:()=>i,x6:()=>A,zQ:()=>R});var o=n(2229);const a="mousedown",i="mousemove",r="mouseup",s="wheel",l="mouseenter",c="mouseleave",_="mouseover",u="click",f="keydown",d="keyup",h="keypress",m="pointerdown",p="MSPointerDown",v="pointermove",x="MSPointerMove",g="pointerup",y="MSPointerUp",b="pointercancel",I="pointerenter",A="pointerleave",E="pointerover",S="pointerout",T="resize",w="orientationchange",C="tap",R="doubletap",P="longtap",N="hold",M="drag",D="swipe",F="pinch",B="touchstart",L="touchmove",V="touchend",z="touchcancel",G="touchenter",O="touchleave",U="touchover",k="touchout";function W(e){const t=void 0!==document.ontouchstart,n=window.navigator.pointerEnabled,o=window.navigator.msPointerEnabled;return{start:n?m:o?p:t?B:a,move:n?v:o?x:t?L:i,end:n?g:o?y:t?V:r,click:u}[e]}const Q="None",q="CameraController",X="GizmoTranslation",H="GizmoScale";class j{static register(e,t){this.__inputHandlingStateMap.set(e,t),this.__activeMap.set(e,!0),this.__processEventListeners()}static unregister(e){this.__activeMap.set(e,!1),this.__inputHandlingStateMap.delete(e),this.__processEventListeners()}static setActive(e,t){this.__activeMap.set(e,t),e===X&&t?this.__activeMap.set(H,!1):e===H&&t&&this.__activeMap.set(X,!1),this.__processEventListeners()}static __addEventListeners(e){const t=j.__inputHandlingStateMap.get(e);if(o.Is.exist(t))for(const e of t)e.eventTargetDom.addEventListener(e.eventName,e.handler,e.options)}static __removeEventListeners(e){const t=j.__inputHandlingStateMap.get(e);if(o.Is.exist(t))for(const e of t)e.eventTargetDom.removeEventListener(e.eventName,e.handler,e.options)}static __processEventListeners(){const e=j.__inputHandlingStateMap.get(X),t=j.__inputHandlingStateMap.get(H);j.__inputHandlingStateMap.get(q)&&(this.__addEventListeners(q),this.__currentState=q),e&&(this.__addEventListeners(X),this.__removeEventListeners(H),this.__currentState=X),t&&(this.__addEventListeners(H),this.__removeEventListeners(X),this.__currentState=H)}static enableCameraController(){this.__addEventListeners(q),this.__activeMap.set(q,!0),this.__processEventListeners()}static disableCameraController(){this.__removeEventListeners(q),this.__activeMap.set(q,!1),this.__processEventListeners()}static getCurrentState(){return this.__currentState}}j.__inputHandlingStateMap=new Map,j.__activeMap=new Map,j.__currentState=Q},3583:(e,t,n)=>{n.d(t,{e:()=>o});class o{constructor(){this.__modules=new Map}async loadModule(e,t){let o;return"webgl"===e.toLowerCase()?o=await(await Promise.resolve().then(n.bind(n,5581))).default:"webgpu"===e.toLowerCase()?o=await(await Promise.resolve().then(n.bind(n,8044))).default:"effekseer"===e.toLowerCase()?(o=await(await Promise.resolve().then(n.bind(n,494))).Effekseer,o.EffekseerComponent.wasmModuleUri=null==t?void 0:t.wasm):"pbr"===e.toLowerCase()?o=await(await Promise.resolve().then(n.bind(n,8918))).default:"xr"===e.toLowerCase()&&(o=await(await Promise.resolve().then(n.bind(n,352))).default),this.__modules.set(e,o),o}getModule(e){return this.__modules.get(e)}static getInstance(){return this.__instance||(this.__instance=new o),this.__instance}}},9827:(e,t,n)=>{n.d(t,{i:()=>L});var o=n(5368),a=n(6737),i=n(3212),r=n(3583),s=n(4772),l=n(8621),c=n(5738),_=n(7503),u=n(7496),f=n(3107),d=n(975),h=n(5250),m=n(6612),p=n(7670),v=n(7681),x=n(2229),g=n(5338),y=n(6455),b=n(3414),I=n(2889),A=n(4289),E=n(589),S=n(69),T=n(3336),w=n(7295),C=n(7566),R=n(4415),P=n(2805),N=n(1823),M=n(960),D=n(5672),F=n(8321),B=n(3497);class L{constructor(){}static startRenderLoop(e,...t){this.__renderLoopFunc=e,this.__args=t;const n=this.__getAnimationFrameObject();void 0===this.__rnXRModule&&(this.__rnXRModule=r.e.getInstance().getModule("xr")),this.__animationFrameId=n.requestAnimationFrame(((n,o)=>{if(void 0!==this.__rnXRModule){const a=this.__rnXRModule.WebXRSystem.getInstance(),i=this.__rnXRModule.WebARSystem.getInstance();a.isReadyForWebXR?(a._preRender(n,o),e.apply(e,[n,...t]),a._postRender()):i.isReadyForWebAR?(i._preRender(n,o),e.apply(e,[n,...t]),i._preRender(n,o)):e.apply(e,[n,...t])}else e.apply(e,[n,...t]);this.startRenderLoop(e,...t)}))}static __getAnimationFrameObject(){let e=window;const t=r.e.getInstance().getModule("xr");if(x.Is.exist(t)){const n=t.WebXRSystem.getInstance(),o=t.WebARSystem.getInstance();if(n.requestedToEnterWebXR?e=n.xrSession:o.requestedToEnterWebAR&&(e=o.arSession),x.Is.not.exist(e))return window}return e}static stopRenderLoop(){this.__getAnimationFrameObject().cancelAnimationFrame(this.__animationFrameId),this.__animationFrameId=-1}static restartRenderLoop(){null!=this.__renderLoopFunc&&this.startRenderLoop(this.__renderLoopFunc,0,this.__args)}static processAuto(e=b.IU.fromCopy4(0,0,0,1)){if(x.Is.not.exist(L.__expressionForProcessAuto)){const t=new c.r,n=new I.A;n.toClearColorBuffer=!0,n.toClearDepthBuffer=!0,n.clearColor=e;const o=new I.A;t.addRenderPasses([n,o]),L.__expressionForProcessAuto=t,L.__renderPassForProcessAuto=o}L.__renderPassForProcessAuto.clearEntities();const t=_.YY._getEntities();L.__renderPassForProcessAuto.addEntities(t),this.process([L.__expressionForProcessAuto])}static process(e){m.g._processBegin();let t=e;if(e instanceof y.w&&(t=e.expressions),w.n.current===l.u.InvalidObjectUID&&L.createCamera(),f.q.getInstance().getValue("time",0)._v[0]=m.g.timeFromSystemStart,this.processApproach===i.m.WebGPU){const e=a.O.getComponentTIDs(),n=S.x.getInstance();for(const i of l.u._processStages){const r="common_"+i.methodName;if(i===o.O.Render){const e=T._.getInstance();P.e.common_$prerender();for(const o of t)for(const t of o.renderPasses){this.__cgApiResourceRepository.clearFrameBuffer(t),t._isChangedSortRenderResult=!1;const o=P.e.sort_$render(t);let a=t._renderedSomethingBefore;if(a&&(a=!e.renderWithRenderBundle(t),p.l.webgpuRenderBundleMode||(p.l.webgpuRenderBundleMode=a)),a){const e=P.e.common_$render({renderPass:t,processStage:i,renderPassTickCount:this.__renderPassTickCount,primitiveUids:o});t._renderedSomethingBefore=e,e&&n.finishRenderBundleEncoder(t)}t._copyResolve1ToResolve2WebGpu(),t.doPostRender(),this.__renderPassTickCount++}n.flush()}else if(!p.l.webgpuRenderBundleMode||C.C.isAnimating||N.W.updateCount!==this.__lastTransformComponentsUpdateCount||w.n.currentCameraUpdateCount!==this.__lastCameraComponentsUpdateCount||R.v.updateCount!==this.__lastCameraControllerComponentsUpdateCount||M.s.getPrimitiveCount()!==this.__lastPrimitiveCount)for(const t of e){const e=a.O.getComponentClass(t),n=e[r];n&&n({processApproach:this.__processApproach,renderPass:void 0,processStage:i,renderPassTickCount:this.__renderPassTickCount}),e.process(e,i)}}this.__lastCameraComponentsUpdateCount=w.n.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=R.v.updateCount,this.__lastTransformComponentsUpdateCount=N.W.updateCount,this.__lastPrimitiveCount=M.s.getPrimitiveCount()}else{const e=s.f.getWebGLResourceRepository(),n=r.e.getInstance().getModule("xr"),i=a.O.getComponentTIDs(),c=a.O.getRenderingComponentTIDs();for(const r of l.u._processStages){const s="common_"+r.methodName;if(r===o.O.Render){P.e.common_$prerender();for(const o of t)for(const t of c){const i=a.O.getComponentClass(t);for(const a of o.renderPasses){"undefined"!=typeof spector&&spector.setMarker(`| ${o.uniqueName}: ${a.uniqueName}#`),e.switchDepthTest(a.isDepthTest),t===A.N.MeshRendererComponentTID&&(L.bindFramebufferWebGL(a,n),L.setViewportForNormalRendering(a,n)),t===A.N.MeshRendererComponentTID&&this.__cgApiResourceRepository.clearFrameBuffer(a),a._isChangedSortRenderResult=!1;const l=P.e.sort_$render(a);if(a._renderedSomethingBefore){const e=i[s];if(e){const t=e({processApproach:this.__processApproach,renderPass:a,processStage:r,renderPassTickCount:this.__renderPassTickCount,primitiveUids:l});a._renderedSomethingBefore=t}t!==A.N.MeshRendererComponentTID&&i.process(i,r)}this.__renderPassTickCount++,a._copyFramebufferToResolveFramebuffersWebGL(),a.doPostRender()}}}else if(C.C.isAnimating||N.W.updateCount!==this.__lastTransformComponentsUpdateCount||w.n.currentCameraUpdateCount!==this.__lastCameraComponentsUpdateCount||R.v.updateCount!==this.__lastCameraControllerComponentsUpdateCount||M.s.getPrimitiveCount()!==this.__lastPrimitiveCount)for(const e of i){const t=a.O.getComponentClass(e),n=t[s];n&&n({processApproach:this.__processApproach,renderPass:void 0,processStage:r,renderPassTickCount:this.__renderPassTickCount}),t.process(t,r)}}this.__lastCameraComponentsUpdateCount=w.n.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=R.v.updateCount,this.__lastTransformComponentsUpdateCount=N.W.updateCount,this.__lastPrimitiveCount=M.s.getPrimitiveCount()}m.g._processEnd()}static get processTime(){return m.g.lastTimeTimeIntervalInMilliseconds}static get timeAtProcessBegin(){return m.g.timeAtProcessBeginMilliseconds}static get timeAtProcessEnd(){return m.g.timeAtProcessEndMilliseconds}static createCamera(){const e=(0,F.v)();e.getTransform().localPosition=d.Pq.fromCopyArray([0,0,1]),e.getCamera().type=h.A.Orthographic,e.getCamera().zNear=.1,e.getCamera().zFar=1e4;const t=s.f.getCgApiResourceRepository(),[n,o]=t.getCanvasSize();e.getCamera().xMag=n/o,e.getCamera().yMag=1}static setViewportForNormalRendering(e,t){const n=null==t?void 0:t.WebXRSystem.getInstance(),o=null==t?void 0:t.WebARSystem.getInstance();(null==n?void 0:n.isWebXRMode)&&e.isVrRendering||(null==o?void 0:o.isWebARMode)||this.__cgApiResourceRepository.setViewport(e.getViewport())}static bindFramebufferWebGL(e,t){const n=null==t?void 0:t.WebXRSystem.getInstance(),o=null==t?void 0:t.WebARSystem.getInstance();if((null==n?void 0:n.isWebXRMode)&&e.isOutputForVr){const e=this.__cgApiResourceRepository.currentWebGLContextWrapper.getRawContext();e.bindFramebuffer(e.FRAMEBUFFER,n.framebuffer)}else if(null==o?void 0:o.isWebARMode){const e=this.__cgApiResourceRepository.currentWebGLContextWrapper.getRawContext();e.bindFramebuffer(e.FRAMEBUFFER,o.framebuffer)}else this.__cgApiResourceRepository.bindFramebuffer(e.getFramebuffer()),this.__cgApiResourceRepository.setDrawTargets(e)}static __displayRnInfo(){console.log(`%cRhodonite%cWeb3D Library%c %cversion%c${D.x.version}%c %cbranch%c${D.x.branch}%c %cmode%c${this.__processApproach.str}`,"font-weight: bold; padding: 4px 8px; border-radius: 6px 0px 0px 6px; background: linear-gradient(to right, #ff0084 0%,#ff0022 100%);","padding: 4px; border-radius: 0px 6px 6px 0px; background: linear-gradient(to right, #8400ff 0%,#4400ff 100%);","","background: #666; padding: 4px; border-radius: 6px 0px 0px 6px","background: firebrick; padding: 4px; border-radius: 0px 6px 6px 0px","","background: #666; padding: 4px; border-radius: 6px 0px 0px 6px","background: green; padding: 4px; border-radius: 0px 6px 6px 0px","","background: #666; padding: 4px; border-radius: 6px 0px 0px 6px","background: blue; padding: 4px; border-radius: 0px 6px 6px 0px")}static async init(e){if(this.__processApproach=e.approach,p.l.currentProcessApproach=e.approach,!0!==e.notToDisplayRnInfoAtInit&&this.__displayRnInfo(),await r.e.getInstance().loadModule("webgl"),await r.e.getInstance().loadModule("webgpu"),await r.e.getInstance().loadModule("pbr"),await r.e.getInstance().loadModule("xr"),g.T.eventTargetDom=e.canvas,u.X.createInstanceIfNotCreated({cpuGeneric:x.Is.exist(e.memoryUsageOrder)?e.memoryUsageOrder.cpuGeneric:.1,gpuInstanceData:x.Is.exist(e.memoryUsageOrder)?e.memoryUsageOrder.gpuInstanceData:.5,gpuVertexData:x.Is.exist(e.memoryUsageOrder)?e.memoryUsageOrder.gpuVertexData:.5}),L.__cgApiResourceRepository=s.f.getCgApiResourceRepository(),e.approach===i.m.WebGPU){const t=u.X.getInstance().getMemorySize(),n=s.f.getCgApiResourceRepository(),o=r.e.getInstance().getModule("webgpu").WebGpuDeviceWrapper,a=await navigator.gpu.requestAdapter(),{maxBufferSize:l,maxStorageBufferBindingSize:c}=a.limits;if(l<t||c<t)throw new Error("The required buffer size is too large for this device.");const _=[];function d(e){a.features.has(e)&&_.push(e)}d("float32-filterable"),d("rg11b10ufloat-renderable"),d("texture-compression-bc"),d("texture-compression-etc2"),d("texture-compression-astc");const h=await a.requestDevice({requiredFeatures:_,requiredLimits:{maxStorageBufferBindingSize:c,maxBufferSize:l}}),m=new o(e.canvas,a,h);n.addWebGpuDeviceWrapper(m),n.recreateSystemDepthTexture(),n.createUniformMorphOffsetsBuffer(),n.createUniformMorphWeightsBuffer(),n.createBindGroupLayoutForDrawParameters()}else{const y=s.f.getWebGLResourceRepository();y.generateWebGLContext(e.canvas,!0,e.webglOption),y.switchDepthTest(!0)}f.q.getInstance().initialize(e.approach),v.zH.isMobile()&&i.m.isUniformApproach(e.approach)&&B.V.warn("The number of Uniform variables available on mobile devices is limited and may interfere with rendering. Use the DataTexture ProcessApproach for this device."),e.canvas.addEventListener("webglcontextlost",(e=>{e.preventDefault(),this.stopRenderLoop(),B.V.error("WebGL context lost occurred.")}).bind(this)),e.canvas.addEventListener("webglcontextrestored",(()=>{B.V.error("WebGL context restored."),this.restartRenderLoop()})),await(0,E.iE)(),p.l.viewportAspectRatio=e.canvas.width/e.canvas.height}static get processApproach(){return this.__processApproach}static resizeCanvas(e,t){s.f.getCgApiResourceRepository().resizeCanvas(e,t),p.l.viewportAspectRatio=e/t}static getCanvasSize(){return s.f.getCgApiResourceRepository().getCanvasSize()}static getCurrentWebGLContextWrapper(){return this.__cgApiResourceRepository.currentWebGLContextWrapper}}L.__processApproach=i.m.None,L.__renderPassTickCount=0,L.__animationFrameId=-1,L.__args=[],L.__lastCameraComponentsUpdateCount=-1,L.__lastCameraControllerComponentsUpdateCount=-1,L.__lastTransformComponentsUpdateCount=-1,L.__lastPrimitiveCount=-1},7670:(e,t,n)=>{n.d(t,{l:()=>o});const o={currentProcessApproach:n(3212).m.None,viewportAspectRatio:0,webgpuRenderBundleMode:!1}},8592:(e,t,n)=>{n.d(t,{B$:()=>a.B$,BU:()=>a.BU,Bn:()=>a.Bn,CD:()=>a.CD,CO:()=>a.CO,E0:()=>a.E0,EA:()=>a.EA,Go:()=>a.Go,H9:()=>a.H9,Hg:()=>a.Hg,IE:()=>a.IE,IU:()=>a.IU,J5:()=>a.J5,Kq:()=>a.Kq,LZ:()=>a.LZ,O3:()=>a.O3,Oi:()=>a.Oi,Ol:()=>a.Ol,P6:()=>a.P6,QL:()=>a.QL,S8:()=>a.S8,WD:()=>a.WD,Wt:()=>a.Wt,X2:()=>a.X2,XX:()=>a.XX,XZ:()=>a.XZ,Zc:()=>a.Zc,_M:()=>a._M,bg:()=>a.bg,cK:()=>a.cK,dM:()=>a.dM,eN:()=>a.eN,em:()=>i.e,g1:()=>a.g1,iQ:()=>r.i,kV:()=>a.kV,lK:()=>s.l,lX:()=>a.lX,o9:()=>a.o9,oN:()=>a.oN,oO:()=>a.oO,pF:()=>a.pF,qm:()=>a.qm,rO:()=>a.rO,sB:()=>o.s,uR:()=>a.uR,vH:()=>a.vH,x6:()=>a.x6,zQ:()=>a.zQ});var o=n(123),a=n(4849),i=n(3583),r=n(9827),s=n(7670)},2664:(e,t,n)=>{n.d(t,{E:()=>_});var o=n(8819),a=n(4958),i=n(4114),r=n(1238),s=n(7751),l=n(2229),c=n(8393);class _ extends o.E{constructor(){super(),this.__width=0,this.__height=0,this.__level=0,this.__mipLevelCount=1,this.__internalFormat=c.n.RGBA8,this.__format=a.A.RGBA,this.__type=i.I.UnsignedByte,this.__hasTransparentPixels=!1,this.__isTextureReady=!1,this.__startedToLoad=!1,this.__name="untitled",this._textureResourceUid=-1,this._samplerResourceUid=-1,this._textureViewResourceUid=-1,this._textureViewAsRenderTargetResourceUid=-1,this.__textureUid=++_.__textureUidCount}get textureUID(){return this.__textureUid}get width(){return this.__width}getWidthAtMipLevel(e){return Math.max(1,Math.floor(this.__width/Math.pow(2,e)))}getHeightAtMipLevel(e){return Math.max(1,Math.floor(this.__height/Math.pow(2,e)))}set width(e){this.__width=e}get height(){return this.__height}set height(e){this.__height=e}get isTextureReady(){return this.__isTextureReady}get startedToLoad(){return this.__startedToLoad}get htmlImageElement(){return this.__htmlImageElement}get htmlCanvasElement(){const e=document.createElement("canvas"),t=null==e?void 0:e.getContext("2d");return this.__htmlCanvasElement=e,l.Is.exist(t)&&l.Is.exist(this.__htmlImageElement)&&(e.width=this.__htmlImageElement.width,e.height=this.__htmlImageElement.height,t.drawImage(this.__htmlImageElement,0,0,this.__htmlImageElement.width,this.__htmlImageElement.height)),this.__htmlCanvasElement}get uri(){return this.__uri}set name(e){this.__name=e}get name(){return this.__name}getImageData(e,t,n,o){return void 0===this.__canvasContext&&this.createInternalCanvasContext(),this.__canvasContext.getImageData(e,t,n,o)}getPixelAs(e,t,n){const o=this.getImageData(e,t,1,1).data;return n.compositionType===s.h.Vec4?new n(new Float32Array([o[0],o[1],o[2],o[3]])):new n(new Float32Array([o[0],o[1],o[2]]))}getPixelAsArray(e,t){return this.getImageData(e,t,1,1).data}setPixel(e,t,n){const o=this.getImageData(e,t,1,1),a=o.data,i=n.constructor.compositionType.getNumberOfComponents();for(let e=0;e<i;e++)a[e]=n.at(e);this.__canvasContext.putImageData(o,e,t)}setPixelAtChannel(e,t,n,o){const a=this.getImageData(e,t,1,1);a.data[n]=o,this.__canvasContext.putImageData(a,e,t)}get isTransparent(){return this.__hasTransparentPixels}createInternalCanvasContext(){let e;null!=this.__htmlCanvasElement?e=this.__htmlCanvasElement:(e=document.createElement("canvas"),e.width=this.width,e.height=this.height),this.__htmlCanvasElement=e,this.__canvasContext=e.getContext("2d")}getTextureDataFloat(e){const t=this.getImageData(0,0,this.width,this.height),n=new r.C(this.width,this.height,e),o=t.data;for(let t=0;t<this.height;t++)for(let a=0;a<this.width;a++)for(let i=0;i<e;i++)n.setPixelAtChannel(a,t,i,o[t*this.width*4+4*a+i]/255);return n}}_.InvalidTextureUid=-1,_.__textureUidCount=_.InvalidTextureUid},8973:(e,t,n)=>{n.d(t,{b:()=>_});var o=n(2664),a=n(9747),i=n(4772),r=n(1383),s=n(7670),l=n(3212),c=n(3497);class _ extends o.E{constructor(){super(),this.mipmapLevelNumber=1,this.hdriFormat=a.P.LDR_SRGB,this.isNamePosNeg=!1,this.__onTextureLoadedArray=[]}__setTextureResourceUid(e,t){this._textureResourceUid=e,_.managedRegistry.register(this,{textureResourceUid:e,uniqueName:t},this)}registerOnTextureLoaded(e){this.__onTextureLoadedArray.push(e)}async loadTextureImages(){this.__startedToLoad=!0;const e=i.f.getCgApiResourceRepository(),[t,n]=await e.createCubeTextureFromFiles(this.baseUriToLoad,this.mipmapLevelNumber,this.isNamePosNeg,this.hdriFormat);this._recommendedTextureSampler=n,this.__setTextureResourceUid(t,this.uniqueName),this._samplerResourceUid=n._samplerResourceUid,s.l.currentProcessApproach===l.m.WebGPU&&(this._textureViewResourceUid=e.createTextureViewCube(this._textureResourceUid)),this.__isTextureReady=!0}loadTextureImagesAsync(){return new Promise((e=>{this.__startedToLoad=!0;const t=i.f.getCgApiResourceRepository();t.createCubeTextureFromFiles(this.baseUriToLoad,this.mipmapLevelNumber,this.isNamePosNeg,this.hdriFormat).then((([e,n])=>{this.__setTextureResourceUid(e,this.uniqueName),this._recommendedTextureSampler=n,this._samplerResourceUid=n._samplerResourceUid,s.l.currentProcessApproach===l.m.WebGPU&&(this._textureViewResourceUid=t.createTextureViewCube(this._textureResourceUid))})).then((()=>{this.__isTextureReady=!0,this.__onTextureLoadedArray.forEach((e=>{e()})),this.__onTextureLoadedArray=[],e()}))}))}loadTextureImagesFromBasis(e,{magFilter:t=r.P.Linear,minFilter:n=r.P.LinearMipmapLinear,wrapS:o=r.P.Repeat,wrapT:a=r.P.Repeat}={}){this.__startedToLoad=!0,"undefined"==typeof BASIS&&c.V.error("Failed to call BASIS() function. Please check to import basis_transcoder.js."),BASIS().then((r=>{const{initializeBasis:s}=r;s();const l=new(0,r.BasisFile)(e);if(!l.startTranscoding())return c.V.error("failed to start transcoding."),l.close(),void l.delete();const _=i.f.getWebGLResourceRepository().createCubeTextureFromBasis(l,{magFilter:t,minFilter:n,wrapS:o,wrapT:a});this.__setTextureResourceUid(_,this.uniqueName),this.__isTextureReady=!0,l.close(),l.delete()}))}load1x1Texture(e="rgba(0,0,0,1)"){const t=document.createElement("canvas");t.width=1,t.height=1;const n=t.getContext("2d");n.fillStyle=e,n.fillRect(0,0,1,1);const o=i.f.getCgApiResourceRepository(),[a,r]=o.createCubeTexture(1,[{posX:t,negX:t,posY:t,negY:t,posZ:t,negZ:t}],1,1);this.__setTextureResourceUid(a,this.uniqueName),this._recommendedTextureSampler=r,this._samplerResourceUid=r._samplerResourceUid,s.l.currentProcessApproach===l.m.WebGPU&&(this._textureViewResourceUid=o.createTextureViewCube(this._textureResourceUid)),this.__isTextureReady=!0}generateTextureFromTypedArrays(e,t,n){const o=i.f.getWebGLResourceRepository(),[a,r]=o.createCubeTexture(e.length,e,t,n);this._recommendedTextureSampler=r,this.__setTextureResourceUid(a,this.uniqueName),this.__isTextureReady=!0,this.__startedToLoad=!0}importWebGLTextureDirectly(e,t=0,n=0){this.__width=t,this.__height=n;const o=i.f.getWebGLResourceRepository().setWebGLTextureDirectly(e);this.__setTextureResourceUid(o,this.uniqueName),this.__startedToLoad=!0,this.__isTextureReady=!0}static __deleteInternalTexture(e){i.f.getCgApiResourceRepository().deleteTexture(e)}destroy3DAPIResources(){_.__deleteInternalTexture(this._textureResourceUid),this._textureResourceUid=i.f.InvalidCGAPIResourceUid,this.__isTextureReady=!1,this.__startedToLoad=!1}[Symbol.dispose](){c.V.debug("[Symbol.dispose] is called"),this.destroy()}destroy(){this.destroy3DAPIResources(),this.unregister(),_.managedRegistry.unregister(this)}}_.managedRegistry=new FinalizationRegistry((e=>{c.V.info(`WebGL/WebGPU cube texture "${e.uniqueName}" was automatically released along with GC. But explicit release is recommended.`),_.__deleteInternalTexture(e.textureResourceUid)}))},4513:(e,t,n)=>{n.d(t,{$:()=>u});var o=n(2664),a=n(4958),i=n(4114),r=n(4772),s=n(3414),l=n(7670),c=n(2766),_=n(8393);class u extends o.E{constructor(){super(),this.__arrayLength=0}create({width:e,height:t,mipLevelCount:n,format:o}){this.__width=e,this.__height=t,this.__mipLevelCount=null!=n?n:Math.floor(Math.log2(Math.max(e,t)))+1;const{format:a,type:i}=_.n.getPixelFormatAndComponentTypeFromTextureFormat(o);this.__internalFormat=o,this.__format=a,this.__type=i,this.__createRenderTargetTexture()}createTextureArray({width:e,height:t,level:n=0,internalFormat:o=_.n.RGB8,format:r=a.A.RGBA,type:s=i.I.UnsignedByte,arrayLength:l}){this.__width=e,this.__height=t,this.__level=n,this.__internalFormat=o,this.__format=r,this.__type=s,this.__arrayLength=l,this.__createRenderTargetTextureArray()}set _fbo(e){this.__fbo=e}get fbo(){return this.__fbo}get arrayLength(){return this.__arrayLength}__createRenderTargetTexture(){const e=r.f.getCgApiResourceRepository(),t=e.createRenderTargetTexture({width:this.__width,height:this.__height,mipLevelCount:this.__mipLevelCount,format:this.__internalFormat});this._textureResourceUid=t,l.l.currentProcessApproach===c.m7.WebGPU&&(this._textureViewResourceUid=e.createTextureView2d(this._textureResourceUid),this._textureViewAsRenderTargetResourceUid=e.createTextureViewAsRenderTarget(this._textureResourceUid))}__createRenderTargetTextureArray(){const e=r.f.getCgApiResourceRepository().createRenderTargetTextureArray({width:this.__width,height:this.__height,level:this.__level,internalFormat:this.__internalFormat,format:this.__format,type:this.__type,arrayLength:this.__arrayLength});this._textureResourceUid=e}resize(e,t){this.destroy3DAPIResources(),this.__width=e,this.__height=t,this.__arrayLength>0?this.__createRenderTargetTextureArray():this.__createRenderTargetTexture()}destroy3DAPIResources(){return r.f.getCgApiResourceRepository().deleteTexture(this._textureResourceUid),this._textureResourceUid=r.f.InvalidCGAPIResourceUid,!0}async getTexturePixelData(){return r.f.getCgApiResourceRepository().getTexturePixelData(this._textureResourceUid,this.__width,this.__height,this.__fbo.framebufferUID,this.__fbo.whichColorAttachment(this))}async downloadTexturePixelData(){const e=await this.getTexturePixelData(),t=document.createElement("canvas");t.width=this.__width,t.height=this.__height;const n=t.getContext("2d"),o=new ImageData(new Uint8ClampedArray(e.buffer),this.__width,this.__height);n.putImageData(o,this.__width,this.__height);const a=t.toDataURL("image/png"),i=document.createElement("a"),r=document.createEvent("MouseEvent");i.href=a,i.download="texture.png",r.initEvent("click",!0,!0),i.dispatchEvent(r)}async getPixelValueAt(e,t,n){let o=n;return o||(o=await this.getTexturePixelData()),s.IU.fromCopyArray([o[4*(t*this.width+e)+0],o[4*(t*this.width+e)+1],o[4*(t*this.width+e)+2],o[4*(t*this.width+e)+3]])}generateMipmaps(){r.f.getCgApiResourceRepository().generateMipmaps2d(this._textureResourceUid,this.width,this.height)}blitToTexture2dFromTexture2dArray(e){0!==this.__arrayLength&&r.f.getWebGLResourceRepository().blitToTexture2dFromTexture2dArray(this._textureResourceUid,e.__fbo.cgApiResourceUid,e.width,e.height)}blitToTexture2dFromTexture2dArrayFake(e){0!==this.__arrayLength&&r.f.getWebGLResourceRepository().blitToTexture2dFromTexture2dArrayFake(this._textureResourceUid,e.__fbo.cgApiResourceUid,e.width,e.height)}blitToTexture2dFromTexture2dArray2(e){0!==this.__arrayLength&&r.f.getWebGLResourceRepository().blitToTexture2dFromTexture2dArray2(this._textureResourceUid,e._textureResourceUid,e.width/2,e.height)}createCubeTextureViewAsRenderTarget(e,t){}}},108:(e,t,n)=>{n.d(t,{_:()=>c});var o=n(9747),a=n(3212),i=n(8393),r=n(4772),s=n(7670),l=n(2664);class c extends l.E{constructor(){super(),this.hdriFormat=o.P.HDR_LINEAR,this._textureViewAsRenderTargetResourceUid=-1}create({width:e,height:t,mipLevelCount:n,format:o}){this.__width=e,this.__height=t,this.__mipLevelCount=null!=n?n:Math.floor(Math.log2(Math.max(e,t)))+1;const{format:a,type:r}=i.n.getPixelFormatAndComponentTypeFromTextureFormat(o);this.__internalFormat=o,this.__format=a,this.__type=r,this.__createRenderTargetTexture()}__createRenderTargetTexture(){const e=r.f.getCgApiResourceRepository(),t=e.createRenderTargetTextureCube({width:this.__width,height:this.__height,mipLevelCount:this.__mipLevelCount,format:this.__internalFormat});this._textureResourceUid=t,s.l.currentProcessApproach===a.m.WebGPU&&(this._textureViewResourceUid=e.createTextureViewCube(this._textureResourceUid),this._textureViewAsRenderTargetResourceUid=e.createCubeTextureViewAsRenderTarget(this._textureResourceUid,0,0))}generateMipmaps(){r.f.getCgApiResourceRepository().generateMipmapsCube(this._textureResourceUid,this.width,this.height)}resize(e,t){this.destroy3DAPIResources(),this.__width=e,this.__height=t,this.__createRenderTargetTexture()}destroy3DAPIResources(){return r.f.getCgApiResourceRepository().deleteTexture(this._textureResourceUid),this._textureResourceUid=r.f.InvalidCGAPIResourceUid,!0}createCubeTextureViewAsRenderTarget(e,t){if(s.l.currentProcessApproach===a.m.WebGPU){const n=r.f.getWebGpuResourceRepository();this._textureViewAsRenderTargetResourceUid=n.createCubeTextureViewAsRenderTarget(this._textureResourceUid,e,t)}}set _fbo(e){this.__fbo=e}get fbo(){return this.__fbo}get mipmapLevelNumber(){return this.__mipLevelCount}setIsTextureReady(){this.__isTextureReady=!0}}},9993:(e,t,n)=>{n.d(t,{L:()=>i});var o=n(2766),a=n(4772);class i{constructor(e){var t,n,a;this.__samplerResourceUid=-1,this.__minFilter=e.minFilter,this.__magFilter=e.magFilter,this.__wrapS=e.wrapS,this.__wrapT=e.wrapT,this.__wrapR=null!==(t=e.wrapR)&&void 0!==t?t:o.gu.Repeat,this.__anisotropy=null===(n=e.anisotropy)||void 0===n||n,this.__shadowCompareMode=null!==(a=e.shadowCompareMode)&&void 0!==a&&a}create(){const e=a.f.getCgApiResourceRepository();this.__samplerResourceUid=null==e?void 0:e.createTextureSampler({minFilter:this.__minFilter,magFilter:this.__magFilter,wrapS:this.__wrapS,wrapT:this.__wrapT,wrapR:this.__wrapR,anisotropy:this.__anisotropy,shadowCompareMode:this.__shadowCompareMode})}get created(){return-1!==this.__samplerResourceUid}get minFilter(){return this.__minFilter}get magFilter(){return this.__magFilter}get wrapS(){return this.__wrapS}get wrapT(){return this.__wrapT}get wrapR(){return this.__wrapR}get _samplerResourceUid(){return this.__samplerResourceUid}}},1018:(e,t,n)=>{n.d(t,{g:()=>m});var o=n(4958),a=n(4114),i=n(2664),r=n(4772),s=n(5338),l=n(5065),c=n(4169),_=n(3583),u=n(3212),f=n(7670),d=n(8393),h=n(3497);class m extends i.E{constructor(){super(),this.autoResize=!0,this.autoDetectTransparency=!1}__setTextureResourceUid(e,t){this._textureResourceUid=e,m.managedRegistry.register(this,{textureResourceUid:e,uniqueName:t},this)}get hasDataToLoadLazy(){return null!=this.__uriToLoadLazy||null!=this.__imgToLoadLazy}generateTextureFromBasis(e,t){var n;this.__startedToLoad=!0,"undefined"==typeof BASIS&&h.V.error("Failed to call BASIS() function. Please check to import basis_transcoder.js."),m.__loadedBasisFunc?m.__BasisFile?this.__setBasisTexture(e,t):null===(n=m.__basisLoadPromise)||void 0===n||n.then((()=>{this.__setBasisTexture(e,t)})):(m.__loadedBasisFunc=!0,m.__basisLoadPromise=new Promise((n=>{BASIS().then((o=>{const{initializeBasis:a}=o;a(),m.__BasisFile=o.BasisFile,this.__setBasisTexture(e,t),n()}))})))}__setBasisTexture(e,{level:t=0,internalFormat:n=d.n.RGBA8,format:i=o.A.RGBA,type:s=a.I.UnsignedByte,generateMipmap:l=!0}={}){this.__startedToLoad=!0;const c=new m.__BasisFile(e);if(!c.startTranscoding())return h.V.error("failed to start transcoding."),c.close(),void c.delete();const _=r.f.getCgApiResourceRepository().createCompressedTextureFromBasis(c,{border:0,format:i,type:s});this.__setTextureResourceUid(_,this.uniqueName),this.__isTextureReady=!0,c.close(),c.delete()}async generateTextureFromKTX2(e){this.__startedToLoad=!0;const t=await c.w.getInstance().transcode(e);this.__width=t.width,this.__height=t.height,this.generateCompressedTextureWithMipmapFromTypedArray(t.mipmapData,t.compressionTextureType)}generateTextureFromImage(e,{level:t=0,internalFormat:n=d.n.RGBA8,format:i=o.A.RGBA,type:r=a.I.UnsignedByte,generateMipmap:s=!0}={}){this.__imgToLoadLazy=e,this.__optionsToLoadLazy={level:t,internalFormat:n,format:i,type:r,generateMipmap:s}}async loadFromImgLazy(){var e,t,n,i,c,_,h,m,p,v;if(null==this.__imgToLoadLazy)return;const x=this.__imgToLoadLazy,g=null!==(t=null===(e=this.__optionsToLoadLazy)||void 0===e?void 0:e.level)&&void 0!==t?t:0,y=null!==(i=null===(n=this.__optionsToLoadLazy)||void 0===n?void 0:n.internalFormat)&&void 0!==i?i:d.n.RGBA8,b=null!==(_=null===(c=this.__optionsToLoadLazy)||void 0===c?void 0:c.format)&&void 0!==_?_:o.A.RGBA,I=null!==(m=null===(h=this.__optionsToLoadLazy)||void 0===h?void 0:h.type)&&void 0!==m?m:a.I.UnsignedByte,A=null===(v=null===(p=this.__optionsToLoadLazy)||void 0===p?void 0:p.generateMipmap)||void 0===v||v;this.__startedToLoad=!0,this.__htmlImageElement=x;let E=x;if(this.autoResize){const[e,t,n]=l.$.getResizedCanvas(E,s.T.maxSizeLimitOfNonCompressedTexture);E=e,this.__width=t,this.__height=n,this.__htmlCanvasElement=e}this.autoDetectTransparency&&(this.__hasTransparentPixels=l.$.detectTransparentPixelExistence(E)),this.__width=E.width,this.__height=E.height;const S=r.f.getCgApiResourceRepository();let T;if(E instanceof HTMLImageElement)T=await S.createTextureFromHTMLImageElement(E,{level:g,internalFormat:y,width:this.__width,height:this.__height,border:0,format:b,type:I,generateMipmap:A});else{if(!(E instanceof HTMLCanvasElement))throw new Error("Unsupported image type.");T=S.createTextureFromImageBitmapData(E,{level:g,internalFormat:y,width:this.__width,height:this.__height,border:0,format:b,type:I,generateMipmap:A})}this.__setTextureResourceUid(T,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=S.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0,this.__uri=x.src,this.__imgToLoadLazy=void 0}generateTextureFromUri(e,{level:t=0,internalFormat:n=d.n.RGBA8,format:i=o.A.RGBA,type:r=a.I.UnsignedByte,generateMipmap:s=!0}={}){this.__uriToLoadLazy=e,this.__optionsToLoadLazy={level:t,internalFormat:n,format:i,type:r,generateMipmap:s}}async loadFromUrlLazy(){var e,t,n,i,c,_,h,m,p,v;if(null==this.__uriToLoadLazy)return;const x=this.__uriToLoadLazy,g=null!==(t=null===(e=this.__optionsToLoadLazy)||void 0===e?void 0:e.level)&&void 0!==t?t:0,y=null!==(i=null===(n=this.__optionsToLoadLazy)||void 0===n?void 0:n.internalFormat)&&void 0!==i?i:d.n.RGBA8,b=null!==(_=null===(c=this.__optionsToLoadLazy)||void 0===c?void 0:c.format)&&void 0!==_?_:o.A.RGBA,I=null!==(m=null===(h=this.__optionsToLoadLazy)||void 0===h?void 0:h.type)&&void 0!==m?m:a.I.UnsignedByte,A=null===(v=null===(p=this.__optionsToLoadLazy)||void 0===p?void 0:p.generateMipmap)||void 0===v||v;return this.__uri=x,this.__startedToLoad=!0,new Promise(((e,t)=>{this.__img=new Image,x.match(/^data:/)||(this.__img.crossOrigin="Anonymous"),this.__img.onload=()=>{this.__htmlImageElement=this.__img;let t=this.__img;if(this.autoResize){const[e,n,o]=l.$.getResizedCanvas(t,s.T.maxSizeLimitOfNonCompressedTexture);t=e,this.__width=n,this.__height=o,this.__htmlCanvasElement=e}this.autoDetectTransparency&&(this.__hasTransparentPixels=l.$.detectTransparentPixelExistence(t)),this.__width=t.width,this.__height=t.height;const n=r.f.getCgApiResourceRepository();let o=r.f.InvalidCGAPIResourceUid;(async()=>{if(t instanceof HTMLImageElement)o=await n.createTextureFromHTMLImageElement(t,{level:g,internalFormat:y,width:this.__width,height:this.__height,border:0,format:b,type:I,generateMipmap:A});else{if(!(t instanceof HTMLCanvasElement))throw new Error("Unsupported image type");{const e=n.createTextureFromImageBitmapData(t,{level:g,internalFormat:y,width:this.__width,height:this.__height,border:0,format:b,type:I,generateMipmap:A});o=e}}this.__setTextureResourceUid(o,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=n.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0,this.__uriToLoadLazy=void 0,e()})()},this.__img.src=x}))}generate1x1TextureFrom(e="rgba(255,255,255,1)"){const t=document.createElement("canvas");t.width=1,t.height=1,this.__width=1,this.__height=1;const n=t.getContext("2d");n.fillStyle=e,n.fillRect(0,0,1,1);const i=r.f.getCgApiResourceRepository(),s=i.createTextureFromImageBitmapData(t,{level:0,internalFormat:d.n.RGBA8,width:1,height:1,border:0,format:o.A.RGBA,type:a.I.UnsignedByte,generateMipmap:!1});this.__setTextureResourceUid(s,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=i.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}async generateSheenLutTextureFromDataUri(){const e=_.e.getInstance().getModule("pbr"),t=r.f.getCgApiResourceRepository(),n=await t.createTextureFromDataUri(e.sheen_E_and_DGTerm,{level:0,internalFormat:d.n.RGBA8,border:0,format:o.A.RGBA,type:a.I.UnsignedByte,generateMipmap:!1});this.__setTextureResourceUid(n,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=t.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}allocate(e){var t;const n=r.f.getCgApiResourceRepository();e.mipLevelCount=null!==(t=e.mipLevelCount)&&void 0!==t?t:Math.floor(Math.log2(Math.max(e.width,e.height)))+1;const o=n.allocateTexture({mipLevelCount:e.mipLevelCount,width:e.width,height:e.height,format:e.format});this.__setTextureResourceUid(o,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=n.createTextureView2d(this._textureResourceUid)),this.__width=e.width,this.__height=e.height,this.__mipLevelCount=e.mipLevelCount,this.__internalFormat=e.format}async loadImageToMipLevel(e){const t=r.f.getCgApiResourceRepository();await t.loadImageToMipLevelOfTexture2D({mipLevel:e.mipLevel,textureUid:this._textureResourceUid,format:this.__internalFormat,type:e.type,xOffset:e.xOffset,yOffset:e.yOffset,width:e.width,height:e.height,rowSizeByPixel:e.rowSizeByPixel,data:e.data}),0===e.mipLevel&&(this.__isTextureReady=!0)}generateCompressedTextureFromTypedArray(e,t,n,o){this.__width=t,this.__height=n;const a={level:0,width:t,height:n,buffer:e},i=r.f.getCgApiResourceRepository(),s=i.createCompressedTexture([a],o);this.__setTextureResourceUid(s,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=i.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}generateCompressedTextureWithMipmapFromTypedArray(e,t){const n=e.find((e=>0===e.level));if(null==n)throw new Error("texture data with level 0 is not found");this.__width=n.width,this.__height=n.height;const o=r.f.getCgApiResourceRepository(),a=o.createCompressedTexture(e,t);this.__setTextureResourceUid(a,this.uniqueName),f.l.currentProcessApproach===u.m.WebGPU&&(this._textureViewResourceUid=o.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}generateMipmaps(){r.f.getCgApiResourceRepository().generateMipmaps2d(this._textureResourceUid,this.__width,this.__height)}importWebGLTextureDirectly(e,t=0,n=0){this.__width=t,this.__height=n;const o=r.f.getWebGLResourceRepository().setWebGLTextureDirectly(e);this.__setTextureResourceUid(o,this.uniqueName),this.__startedToLoad=!0,this.__isTextureReady=!0}destroy3DAPIResources(){return m.__deleteInternalTexture(this._textureResourceUid),this._textureResourceUid=r.f.InvalidCGAPIResourceUid,this.__isTextureReady=!1,this.__startedToLoad=!1,!0}static __deleteInternalTexture(e){r.f.getCgApiResourceRepository().deleteTexture(e)}[Symbol.dispose](){h.V.debug("[Symbol.dispose] is called"),this.destroy()}destroy(){this.destroy3DAPIResources(),this.unregister(),m.managedRegistry.unregister(this)}}m.__loadedBasisFunc=!1,m.managedRegistry=new FinalizationRegistry((e=>{h.V.info(`WebGL/WebGPU 2D texture "${e.uniqueName}" was automatically released along with GC. But explicit release is recommended.`),m.__deleteInternalTexture(e.textureResourceUid)}))},1238:(e,t,n)=>{n.d(t,{C:()=>o});class o{constructor(e,t,n){this.__channels=n,this.__width=e,this.__height=t,this.__data=new Float32Array(e*t*n)}resize(e,t,n){this.__width=e,this.__height=t,this.__channels=n,this.__data=new Float32Array(o.transfer(this.__data.buffer,e*t*n*4))}setPixelAtChannel(e,t,n,o){this.__data[t*this.__width*this.__channels+e*this.__channels+n]=o}get width(){return this.__width}get height(){return this.__height}get data(){return this.__data}getPixel(e,t,n){return this.__data[t*this.__width*this.__channels+e*this.__channels+n]}getPixelAs(e,t,n,o){return 3===n?new o(new Float32Array([this.__data[t*this.__width*this.__channels+e*this.__channels+0],this.__data[t*this.__width*this.__channels+e*this.__channels+1],this.__data[t*this.__width*this.__channels+e*this.__channels+2]])):4===n?new o(new Float32Array([this.__data[t*this.__width*this.__channels+e*this.__channels+0],this.__data[t*this.__width*this.__channels+e*this.__channels+1],this.__data[t*this.__width*this.__channels+e*this.__channels+2],this.__data[t*this.__width*this.__channels+e*this.__channels+3]])):void 0}getPixelAsArray(e,t){const n=[];for(let o=0;o<this.__channels;o++)n.push(this.__data[t*this.__width*this.__channels+e*this.__channels+o]);return n}initialize(e,t,n){this.__width=e,this.__height=t,this.__channels=n,this.__data=new Float32Array(e*t*n)}static transfer(e,t){e=Object(e);const n=new ArrayBuffer(t);if(!(e instanceof ArrayBuffer&&n instanceof ArrayBuffer))throw new TypeError("Source and destination must be ArrayBuffer instances");if(n.byteLength>=e.byteLength){let t=0,o=e.byteLength;[8,4,2,1].forEach((a=>{if(o>=a){const i=function(e,t,n,o,a){let i=Uint8Array;switch(e){case 8:i=Float64Array;break;case 4:i=Float32Array;break;case 2:i=Uint16Array;break;default:i=Uint8Array}const r=new i(t,o,Math.trunc(a/e)),s=new i(n,o,Math.trunc(a/e));for(let e=0;e<s.length;e++)s[e]=r[e];return{nextOffset:r.byteOffset+r.byteLength,leftBytes:t.byteLength-(r.byteOffset+r.byteLength)}}(a,e,n,t,o);t=i.nextOffset,o=i.leftBytes}}))}return n}}},8918:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});const o=Object.freeze({sheen_E_and_DGTerm:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGkmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4yLWMwMDAgNzkuNTY2ZWJjNWI0LCAyMDIyLzA1LzA5LTA4OjI1OjU1ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjMuNCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjItMDctMTFUMDA6MDg6NDArMDk6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTA3LTExVDEyOjU4OjE0KzA5OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIyLTA3LTExVDEyOjU4OjE0KzA5OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkZjBkNDUyYS00ZTNjLTRlMDQtOGUwOC0zZTA4YzBhZmY5NWYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6YjMzNWYzNGYtOWZlNy00MWU3LWEyZWEtNWZlYzVmZmY3NDlmIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YjMzNWYzNGYtOWZlNy00MWU3LWEyZWEtNWZlYzVmZmY3NDlmIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiMzM1ZjM0Zi05ZmU3LTQxZTctYTJlYS01ZmVjNWZmZjc0OWYiIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMDA6MDg6NDArMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYzQyMmE0NC1mM2QxLTRhZTEtYWMyNS02NGE3NGZkZGI0MTciIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMTA6NTY6MjArMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpkZjBkNDUyYS00ZTNjLTRlMDQtOGUwOC0zZTA4YzBhZmY5NWYiIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMTI6NTg6MTQrMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pi6E66IAAKbnSURBVHiclf1Lr3XLtiUGtR5z7X3OzXuvMm2wxSNBcgHJYFdApkqJX+CKK1iU+WdI1Ki4BAYkpEQpJJBlOS2nLTtJnHnT13lf556zz/6+OTqF6K311mOMtfZh7rXnN+YY8Y7Wn9EjRvxX//N/iN//R/j5H1y//7/nz/8xfo/rZ+TvkW9cwBtI4G0XF/AdeAPfgQuV5j0vdpq0+5f9TKY5rjFTJp/qO+f1m7mu2yNPDCs8n8pRsuT3Y2m4FQ7Li1lOst6Y6T2xWn5U7Re4te34PhLn52n0NH6pEDU7Pqk3vizqXi9uiXFLnLebccu+f8ZsyRe1xK3wuBUV/+T/kPgXyD9D/hnwL/5R/tl/mH/2H1x/9n/J3/zNZYC+DMrvp79HSnjPvCAK/abQfIAbkwwE5csw4QkwqcXhi1sCzAQOXKcZx/c1i8rbn8+l37zfeUyPL4vCjZZwu9b39XTzMeUjUnURt/bgy/Se6+tkuzsX8Xp9Qh4HUX1GEsfnkcaOxKpu5etv8AJewAeu17+Zr/8dXv9HfPwX+Pjf4/W/xfofxdqUMoq7bJQfKw672H/r1iDMm/fmHlN+QME/d64Q9odZ1GN2WOFH+3/xE9Zgz3XPG3Ms77MSn6fP2cJHSsinZuCTqcFTSn/6ddswG+A3vx60uCWL2R0v8xeL+oJmMIv1SdHNj/gr5G8QPyG/IRJYuH4Efv3fzfe/h+vfw/WXuP7PeP8Hmf834B8jr517ifvmwOtjV9UOb8r7qblHyus2BC687hR4jMhBNirqmnNw3ebvnst51Rcfz7XYxyOB6r0ze9wG5D5u958gOj9jSXdF5dAE7ln8c1ck7g3wxJ8V8vjJW4IvOvtYkWd0ZvdY7L3BH/g91XlgvTb6gT9GBPI78P3v4f3v4vu/u/Kfvq//EPl/yvyHyH+G/O3CtyuvCETO0cyuz+dPLP87f15PDd2y4rL+fCHm7qPgCQ5i+IxlHrU86prK8hlo7rz5s8Sffe713h/d6z0uvkh8CNWjui+yfMZi7yzc7/8hpHVv7dfD9XV/74SKyRcOkOxkH3gjEhnAB/IH4FfAHwE/IwP4BnwDvgPfke+/j+vfx/W/wfX/jPy/XvkPMv8x8l9m/g3y94lvme+w4QoA2YN+qChi7ZIkR3OPQfkME59Jg6PGOy9/pK6Dc3xW4xcIO34efbmLr5gD8vj5mh4eCzza8Mh9057+IqEecgN24aU9yrQv+qW2fUH8RxuUF1/OxT1XPMEAwMcFrCgbAD8gf4X4NfIbAOAb8HORQZZtG3H9O5n/zrr+aV7/D+Q/iOsfIf8M+ZfAb5C/Q/6M+I4sH08idyMyu2JvnM+f4HVoDo+ze2T8rNsiv+uG/kMm4P8fEBwfZ/ye/tA07ljP2ap7+Z/x6Tv+/MJ/rskCD0B8jbz85OkX4ugPF3pOmXfWfnTw3n4lcMaEz7WGo+NLEiACWIgX8gP4AfEjrl8B34AEXsBCvoAX1hvvN/BGvhEXcP19XH8/rv91Xv/vzH+I/EfIf4b8c+RfI3+D/An5c8S3yO+JKzIRmaSH7k+ezfrs87Us/gNvPnKpOybu7NbzflEL/gCgPN45aOCxnXhK8FjUF7B+vD6kxNcU+NiF4/NYez4h9Q7iz4p6rOX+81HWHTN49OIjArmAF+KF/AH5A+JXyO+IxLUQC/ECXkg5/+XafCOuv4vrfxXX/xL5n+D6fyH/U+R/nfnnyL/A9ZvE30b+hPwZ8Q35PXAFLuBKZGQmgMhqXP7CsD4OzaPm8AjTA2G4jcLjlH9d+53ZY7bnM8Tc2d5x89BMHPT3NuSXc/+LPAWfNNIbcwAoPmnS0Z6jli8kJz5P87VAeGz2I+3BRulgHx/VxYX8AD4QP+D6sXSeCFxRY5Av4DuwEG/gQr4pXN/A9UfI/0Vc/zbyP4vrP0L+Y1z/DPHnyL+4SiD8LuKnxM/brA68r14HS2RGUUJ6kx9Bee/Vff4Owe36zxeYy0+Y0NcfV35Uixd7PU3eoZffefwjsz9kxTGvjzLkszbfxSBuI/mFfnIf9kcB8kgMd73lLoRxG7Ff7M5R432i740BcAEfGcDi3wfwA/AD8OPUHBfWd7wXYiG3FrSAF7AvLuBCXj/i+rdy/U/i+s+x/hNc/yXyn6/rz6/8i8RfZf4G+C3yJ+D3tBO+A++0ReEry2hcUWZAbNvhJh/uHY7bZPgcPzKYiyR8wPQgg0chfn96pFFL7vPxi8zsC9rGzJs3xBx57wzvgNofrth4Lm/JF+Tx+PSxzY808Iufz0TKUdTXYvADgLQgvJC0huNtOUkkuUoOlChY5ceJaxsGiPwR1/8U17+B+C+Q/xni/5P5L5B/DvwF8q8zfwP8LfJ3yN8jfs78WXEVmdeK612cNJEZyHIjxdnfbTzo9zXHN29oOBjzMYJ3tnHMQdym7TBkcZtFbwyeJvjrWfki42ddeGz5ZyR0dByzd1+0LWeux5T3ocMN9J74s349solfbN5dtMYnPd2fjwwEJUC8gA/ERxnEACJxAQgkdaFYiO9FDPnGtqFz60VbFAQQv0b8zyL/xxn/JfI/j/znkf9N5n8b+EvkXyP/Bvlb4HeRP2X+HvEz8hvie2bFVSRNhcI5iSHZqYz6yjkY97kXWMMUj69Z+NcFPg5iPMH6oJPPqriXKZA9Lmw5Vu7dOWo5VCPcru99ufPs+8/PupA3leYXO3tXRDHv4/M79wY/8qD4kgY+VgwGX+6gD+RmxFfhLkgDuS82wSxci4rQG3EhKQrywnX9yRX/NvJ/gPyvkP8k819k/nnkX2T+JfKvA79B/hb5W+RPGT9H/j7jG/Ib8M4ytxN4Z14ZmxJKQSr7eXcpcNkgHG4l3ODyGV+/s+ecP+/Zj899IeIuJY4En4Eyn74fC/lCbYjbBW4AvV/chedjy++N8YxfK3iPeVXsLzL4oyXHhN4/n/EIzexH/SKmWwu6pm4hjXanlEDYVHHV9/7DGxGIwFq4rn8181/J/O9F/pMoV+l/i/zLzL9C/jXyb5G/jfzdFT9F/rSlQeAb4tvK9xvfgcvshGtbzBcS2ISQMbsVW2TYgMUnUQlKskv4bCnqF6U8noD4COhj6B+z3NnYZyrEPf2d+A/ueGhxd3Ac/Pho4WP3j9rV3z/QKP8iwWe0h6fR82Y/VnQIgYso/thMtMwA0oDC41bizYFMIKOQvZnwFZQMFxA0A951vQUCAshA/vcz/1Xkv35d/xT53yD/JfJfZv5V5F8hf4P8DfA75O+QP2X8FPnzhZ9zr0LH98h34h14R14ZF3AFtu/oItYd89bN2D9x8QE+Ga+8zRZI/muGLeUno3yA6QtdK2/3/xB2+5kQe5QkdwI7mP3XUHscDTyN1WdyTC2/0/999A5hlU/Xnv2zpuKXsjzK1Y9EcfEWAvT948JFOeAsJIOiIIok8EYG8GaiC9e79aVIIBH5q7z+DcS/gvz/Iv858u8i/+K6/hL5V8i/CfzmvaUBfsr8KfL3Gb/P/AaUyyjxHXEh34k38rriym0nZJUO7LW2QKbJgUgJLqSYE/Jh7I6J/II27rnuE3Ont3uWQw27a1x/SEWfPfKbzvjxBDVYGx5LCPv+Qzp1NOkLED9mv/frs6G401Lebj7KmaTj0/SZVXIg97qYO+utsmDBEgUQ+q8mgzQnaWyTNoD8e5l/guvvIf/ryD+N+NPMP900gPwb5N8Cf3vl75A/BX6K/H3mz4mfI74hv134DrwD72S0ReQbkWplZAKZkQASGUja0S0ZdrevSoNNN59NzxeM/BjfLySvVrWOOfhM6H9BlvfsX/Dgg+kePXqE2l1cPJZzr/SzTt1J2i++4D45Bw3WBWccnxXyxf2jzR/FFQJYtG4VAbHVmAR2/PNmtdiqRX0WkG+yWEmAN8nDljT3dSTi+kD8D5F/ktc/Q/4J8o+Rf4z868g/zvwb5G8Qv838bebvED9p6SDjmxYQEt+j/EXvKCMhkW9E7oC8CxmZ72rusd5ckoFjnbSkOTrTkr4H6jyiVt9fjPt9NfoPAboSezPuYXZHwM/ByD8jDNwq8oY9NiAnFv/wz0FyX4iaL8B95+J3crr36JFN7LwfkCErFUj2wKt8QbiAV1GCD0Gzk0MLQus/JVuyEJdceYr8uxF/lPnHuP4I+Xcy/w7yj+oPf4v828jfIn+b8VPkT1f8HnSYJn6uCFW8s5ynW+6sRGa5YxORa0udLNVoSwaNXALyrnJiEhhmNS2Mhxn6xbF+5Nme5i6vvVhMWPtk3znuga2jQJ9vPBV4/zz26w/8xFONd1GQtybdBQ7m9Z0qjuz3PqoZjz2KrQKl34jyb+bqi3ghgUhEWgVajQrgjdhMFYBZCG1dJK4wrO013utH5N9H/BrXryN/nflr5K+BXyN/Df5c+dt3/C7yp4zfI38Cfo74cccXZRYZBL4nGK2KzPquBbWMJJFmZi+u9Ygk2I8wJp1A6XgSII9s6VAqrtv0HxC/c69HleNxyj37Z/rJHdaOyEf0HEg9isW8fqSEx/SPWUTb3v3HvJ8B2guPp6o/m6CDMvf9WgmGa/Or//JVpmUm8BLjBBJ43SZMvJ9FaengSkTgsqDkvLZ9HLj+NcSPyB8zf4X81ZW/Qv4q8ldX/oj9h19l/i7zd4gfkb/P/H3ED1d+i/iW+Q3xDfkBfM/eh1yWxxYIu6qSX3Et4CKvL4QHrj04yX9Qo2Lrx4mwnvIf52q/KLsxnzoU7il9YB+J5ED8UekviqZ7S47a/fog1OP+Y5rj8xlYD3rA50N3J4aDgF3I3Kv2ipYN4EclkkNztRDQalcZBol8lUvH0b/5fbBFW4WIKQFWrRAjrnab4pJf5u9mfiB/QH6s/OEt6OePyB8jf7zix8gfM3+H+AH5A/LniN9f+XPiA/jIrRHF9+0j2pSwnUUZZSGEbd7MEgvN60OGkOE7ScgX+8f+cilOM8GFurtE/uwnnvjxsT3lkaMfgHtke5+hELeiPkv2KGc+g+YXJTy2/J7ygPKdW3/dgEN84Wk04vZzp/nQ3ctpYEc6KP5n1XbhTQOqI22/RQ+ZyCDYJlsrSFrGcVEm5P75x5Erc2W+kB+o74/MHzI/gI/ID+QH8oeIHzN/Qn4EfmAYRcWZ5taI4nvmO/ECTeQoSkggMhF13S7U3QRfY5b7NIFacxtD2uO8gHeMuxqLO0DvoM85u9cNDcf0Hz9zTrBHpD4KlgP9nzH1Ozs/qjgac8fr16LgfvPxexdy8AX/HDe/YP+PJA0RgHPr/Rdr6kJZQgDUJpCUBt4g54so3gtj/1XRRQ0jEBeuzVevP0L+a8hAriu3+vVCFvSvHaK0qSJemR+5f8bPyA/EN+S3iG/I94VX4h34jnhtE5lryW/k2iSw0R/cphOZF3LMTJIQOGZbWMytC6QQQEoVLH2go5UcK3ePzYG/x8+aNjEmmDTTR7GPyAZGX/3p3b90IOyLFuLWF+X64vOo+dyb+hm4P6v9KPyRLKPXAXzy+JeBFbgkASgEaFVaqMRGR8yBc6K6KsG+kD2wLryDbpuigf8OEivjnYFckevKFflKbLHwyqxojYyijYyfka+IV+YL8T1yId7IV5ZZ/AbeF67AyiKGiNKCapEv49qKTTZxg/rSZNLRvZmkMJUqS9+8/0YMjjncEBMmEO7IPmDxGdo+Y5x3WjpKu8PlCyo98PpFG77g2Z8B/Xj6GQ0fzP6RFI9acq8E9xM5LrkmcC3EZVaDLlRrjnn1eUoX6HtJ2MlgSwaUZ+mSSL7+TuS1XZeZsXfLZL6Q2yf1gXxFfa+MVfSw0Y+PxDdgb975fuGN+J75ynjvgNXAW7vSgCuxkFfEbsV2EW2gZuPbZRrRXaHaxTg6LtWpBw1+4tVPDZhy5KCEY7aU44Dp46TePzHz3kXBZ7jPT1Iq/WONn+Fbd/4QenCyP6pTq47yP5MYeSvNR/VDkr54NqiuLPrsF5B04GwzgA25q0AJ44yBFXhH+1PKKXQZO4xeGUj2LK8/QV7E4WbKq8NQd9xSrsxX5ivwyljIFXhl/By5Ml7Ibxkv5PfE3l2zEivxvkoI7IjrIE1XmF1G2cp76YAKTkZGmuGbhfnqcdF1bKrAXGw4AFy/ZXAH4zI0MY6w+/dn6scjSfyBUDtu3pWEI2XM68+o6Kjia7adT4X7I2esnuwLafNZy48GfDSV8/neCSlRsPX1WHQksrFSFnYNwXqOAe2+UQKUckFnqPKEfJWB9/WnyO+ReWXGdt8XPUSyZRHbaF7IlbFthr1m8a1+xivyVYtlpRpdke/kbs4oV2n1sxh0ZkZ786MIo9Sh6lf09CkMLwVqsYhJDByqPNEZStODeWfYuK2LfcZrD0wcgL5/HDGf0ZInuBPPnXofS7jX+4V4eYQ75rVfHHTySJAHQ4qhAqEUFenuuRAXakE1u/cV3LZqHTUwtmgd4maR4V2XzbfhfmtEQUsgxWzzT5HfFWMdRQXkxlpnjvJYZbyw/UhRPyNXctNaYGWdWbqCEUtXmQQLuMoyLrs9siRdraNVzbErHsQQOza19J3J5sJIQOlNSIgYBiyUG+OZLaKMibfZexYUj/i78+xHjHZLZj8+q+KAZn5yfZT2+LmLpqM9MVMe5HEnzoNm9vfHax9NFQC3wGvvC+xCT3MHSiTRTWkQnLD0RolpGVdrasn+2eW0VPkh848j35nfk1ZB5KWFuUzRK7atDKzYCtKmASzEylyI78iVeC98v2oTZ2SuwDuRRhUXiPIOAzRv6V7GqObS6G2Mh01TlmuVI54ZPPFOYoTEkDckdJEedmV6G26QPQCtBA4dB3resnyBRf8cGssj17/z8vvTO0bv5evnXX97YBw3kvASjp9K+fGG9lXNuj3cn+pQsfw0d9AqSth8Uqfdyl2YMBsAJQoAsnw2tpapJGqwy/+jzJ+R35DvLQeybIMr8gqXSyLcjA36KPRHYCXWhe8RKzOaNsj7UcKhdb7S8uXtojs3FdC3B4jrB1SIojtNf3Bt2+nYO8RNLETxB5Yyp7DBdOOcj1j8TAFQvgMBx0dCxmvHLOSzjI9c9k4Md1mx5k/Ma9zyftaAz9p5f6RaPjDvOu+P7QOlF2hl2QZbApRqhJ6MvkBPaZDnpd3flt/lT/VtBHDlQv4d5LfIN/Kd+T3yyktuHFJMIjNWxhXYNBBYGdWHLShWrHd+SyxgW8Yb9CviO3KhNj/vv+j9+HWqVwB55ZXx2lFGteOg2X0AeQ0M1/qHUwL5sVQgC0nqwvrpnVMeU5rMIE5/0EPc7uN2cdd/nJYOeOB254B4kpHcaUwV3Vv1iNovxMhBXd6YR4lxNMPL//AHQS+QB3ImyTOJ/kje1AoxkIlYNp2rK8urHu2Y6jRqSc2z5IDtZFmJK3+F/KO4vl/4Htuzud6RVwW25aXWXyYKLooCtCj4HgjEd96PiJX5JvSDQURvG0Np3UlJtsOKIkKu0gQiolxZqPAJuXx36bs/tUSe0vo4DGegUd5nfNjNB0D7TKXbnN9h/RkvVIJHqviCKz8y6TsE70R1kPdnBPOLutmdDPAHdFCfJgB5gdxJB/Ri1kZOJN6b91MOFFtb7EaaIqTCpRxciIU3gAuxbNoSAFeqLq495xYWv7rW7yO/Xfk98zvyuzQiUsy1fUMXuxjAFYGMpGqUCLMHAoisrY7bEkA7vGofUHMTLhFcyZiiRn+ZyDvYWppOmI28WT536aDs6EJs0UGYFDQjuJfa2oN053k9u5w1uVbxORBxA98XKPca72Uen9GkWVrYyOLWsMd6XVY8qm2HiPiibY8d/xiFBi6U5xy0enU4XIGS10EJkM74t8S4130hVus8ceP9sBkuvSiR5YP6AfmrzG+R31eRwXsf0BW0Cmgi03+fiNKIULcithAoLT5W5FaTrjIeYp93F8CbJn01dntLt3S88tJyAeclow5ATYoAM1456jv87iosl8+UHqQjvM6Jp70IvCHZ+ZWOAQZy9zjf0HBHqj+9p79fO9n8IuvF7fter9+5X9w/j1rQZ8nuj+J0g9IbEh7FgK1W1N+17QGZyAuRdBCtT6sJqu0JwhrFqnENf6tMDrRZHMgfkT9c+cOVP+LaulAfLBe955LcuWgAAMoYyI37iIwrvknemfn7TjY2oLWCFgUpU3iyf15gbUEXRb+HyI+sQFi7k70uUgF5expPM0Bg72Jv1HLHYo+/uZKuHDk9y6NAwK00/9wfHRIGT1U4HB8VmHtRj9XdwXbH3j3NUUhvidwP9iRfthoQ0yQAV8rKKRTAKu+eyOaylFtcVNGLNGXQB3j8VlIvSkTibdfID1w/1Jl16wfkj5nvzHfkmxfcGKn1go2WgLz3m1lHRGQkvmdEnezFyNWohmh3s/W59vPsfQ2ZbRjU30JeO3Rjj3m1W+sJ21kUAB2kKPuYtwh+uDl8+Juwe9T4aDFAI+SXmPchmpTlkYV/hubj0We5cpZ/VOT38fT0/nkkiXt1n+V9LMSMYBOa/QakCX3BupGdFTOXq90oHreYKJ0e4DMUv99iQfflCNpyYC3atReAF9YPkT9Efsv8Afk98nuWSfCDmQRX5ub2e/14K+M7nKjwn9KUM4C147K3syhpHtTBRrlff7O3c8ZVw3O1bCr2f2UjPgN55XbvBNG+sRpIQywieXoFPUVpek1RLwcxKHnm9Pc2hd7irGE/pv/Ed4zUXyD7EZR/iFhwoeR3/PtRBHk5d1kU05A4+viZTDjK1/XHmZwsv9g/AJrFyadlBEex/73+M7Qm2wtWriGFEu0IiNWaz7UIp4smtV9AGhHDoa+9CeYj8MPeEnnhh9oOFlfkdaXiilI+wg1IKkVXgTvq0VUOsEh8L88ptoOoBqU2tGVE7PVjUkJTRXF15BVBuxngVmhSnK0ZR5SnyCMsKsyoYy3KpbrH+KoG3bT6k1QqjePvroH0spp4AhvzyFPvoI9bFV8TzP0bM72X81hXHN39ZBjutd9r2Z+PvAWad/tICTumDbwjOrm0gUZjt279v+g8Res8pQ659n+Vi+mi5lNpFCB0vRIv4CNXb5dB/kBF6AfkPjXoAnbUwv4ACq3YnvjYnPiiDhHpOjJwHm7BnwR9+YqdBiKJ3byukFc4Gc1n7HYuICClowGISEdkNQ4iA0rpTUIC6kB2u1Nb10n258DBwsBEGjoCJ5E9IjtvF5/dfCwnnpIdFYmoPqvoUW48NhIT+vvnR9z6Cc5BKMfk68CpF2mJoBi82Q+b8ScNAJg6lLwvrG/N552tFCUjiHJVuFvk68qPdb3efoTd3gkZe4ngjfy4zCSIWrsq8Cd+QHzbe9syvnMgIzOo+bxz9Pxd4f4RV17NImu1eLt2Ng9ZdBD1gG6BAOyYui3t9n/UyBkQxI2aAi24whBkzCw5+I8h/fxYmju1eCoHWZOEaCk7GSY0j9rcDjkKjCe8HhLGxqyb/1maI/FR4B/Swf3pUyFa7kSf71DcKOy+qUmwnzBPUUb7hQDgwmvhfXEN6qrQiTJ5N++XtlNA2lzfFgQycL2AV2IFXrlemxKQH5HftX0s8a6TTeMDeUV+ZPlmKooocGVBMnTha7/Anvw3tZYdyVGLYps/Zv+8gFXmQZ0k3A4ibrspMaQgh0SpRiVKgvSUJSa5albSIiE3UQefFkRit0fwfvqQEuiBpdJmgHjUW3owRDke0zXxdPDpA+hHc7yEL5r8WUb/+YsSwB+Jq+1k1+EGlQx13k/+SAmAJgNBXxr/vqh9ZCBP4NaCWLiuEhThxDB9oKEV3m1ka67WilzIV+bKS+y/VKPAO+Md+ZH5ztzHW7+ShgEDETaIvsveVDAHwxKk/KAuCnqB4v3q1XZcbScwUc71AcqBS4GlUbQRGdRnDAWlpTHaNJMNa/u4dKFaj0DsNeYGU51tgUNOOES2F5Y4PkMtPqOBcXPqIp+lP3DmaL5zdBcd90/cMoqjPzTvS7K8dzBKAnDh54q+6MIUJUrCkDXsZOA+0L2PLKn/rItuU6r+8Cijiycoon6WKEhuGdMunFx5rcAC1taIojbRv6K3Sr4SH4HrwgvxEZnIHYidgeuKjOSO+OBJ6+GYebsg0HfQF5RtDEDrVLvAHe9XwUKolTjqOsB2+5hj05w8WxTt673ywYkjSredIJNg10SNKptDg+0CvFf6WM+qfGU8wOqC4kBVMQorMebTPwTQsBpnYX19R7+37Z7l/jNujT+uP+6t96ZvTNcJyZPrw3i/s39BXGVl4JIQQClC62oayMsQv2rvFtDSoDnaWrmtjUux/n6eNTfB5CvyI3MfoPsBZMa1Mb83v3PxCheN42jfitixvEBgkEPYcO1lgW1x2xpZKiDiCi6O8XuPPvWtPR7JKLrScfr+bkbuL1JAjQMVngAy6AM915NJL+ioCkdD7IARdvpRAhzYSMsuTaHF3w1CX5f5GZFgVqQs8ZTmKPn+6LrdTIMnF8KsyvSQOBb8CPrj59Z89hFAJSWWcYNoezcP3r8YO7aa6yeVn9D2g2uLmZVYsVZk1H75fCU3SVIIvBJX4hWh9YHrwhV4rch35g5r286ijcnLtKLQmfDGVC8gQT/kYI4XV9BQ0XIlFhbpITG0IHmBtoVeF8UsQJdPxc753JrUoIhoNxdcX3KExYVS/w/ICFKUgzOz8dpHleOgDai9eaaElXM04Hh60MZn6b+gnHsufVTmeTDWIVxgjSjlfg4BBA4Pwo9SnK6oP+F++zqD0qDYLa8HVaAMg2oAr2tcFivbGtXWhaDrV+BVYiFekW/kK3PHTl/AFXHRM7rjgxiGE738ylCe2Vvzk1IOhNhfVrdAe+DKfahqb6x5no4QnssOLhGyB+oCpBqlMB6si0tjO2NRR1MrGyb9a7d2OITOXrKGkhvReUfiQ4bACpFMoEQaHXa58cjR9fRg/2rAUcjRhccCcavr6PWHDYjVQ2quqZ4SoHuw6YkLAoyvIVCn2iOWH1R+pPrHDkAyX9BhB0cDKYDItU+L4PFd+z2rtT94mwRXYh+LsoBXxBv5ulLr1C/EFbnp5wWRdyTP/Tro3aVBOKazqN6Xj8JXw5PnCFQEtd5wU5rSBen/cyG4Bg2g+4fgqGR0ThJoZP8yCQT7nO2L7EKfuWUAFx4MiV9k4Xe+weqfie2x6vujIans+qzul4qNp58f51QD4C7aCHxnJrH8468ciAR9xcrQkco4tKYN/070kvC68AY9QjDJAGD/W0ZC0SON0f23gFfiO6/bNsjY4aKvxBV4AVdGrswrX4oTRWbghchro3/6R5zzNRkEtOa6bWIjAPsW7qkvcUHgIrg3srlasRlwSYbcOA29B20vYxBWUYQFUoNwWrco5UsFUpIokbPFDbMZCCa2GMEEGiCW9uDKx6cxZzrGnXP7z8ebWrDjgH+qAh0SyVtyNonpPx7zyCp4Ad8ny+8uedBEC4t6WowxgG0JakkByG1VC/SBAN7mCKr7YDDcRStcg8GFhkAkFqXUurD3di3Eitw+U9nKG/2vWgamprTRn5FpvH/EGiiOyCagBimWPPBXc+PkEC6ZBNH2wB6eRct4ocRIQV6WMDed5fZ4brZ9oVa+xO+N+7co2uRZv00W3CAcnifIrTXD/muh3ioC0rGX5GwCGMM1K+TPSW/z4bhzMGjdeSSDz2jjaImn+XhIzbGQsDftg9Yt3d3CffkFw+7bnZov34g7na0t8UEvqhpEBxE7EECE7AH726eLRh2dsvc9lp4TFXGx77w2243MUlHwKijsk+BBbWNE1HCTV7Orvc/mfeXamh1HuFpaClKudHugfPp74Sx6aQDYawABXLVmXGSxvaKl2FuIA/X1Ru5UpyD+zYHjYoQpVDeod+sbEhQm1XEuZShTjmEZo3QUctRyZ9c5r+N25yjg8XNH/J0a95TQDcq1zcpv/BvB6H8b1Wb8tHpX4nu0A6O8ikFVp4tGGPQDc/WXAfK5HPEAOkBov5WY0mi3YlH5CbOJ6y9iIePKtV1DgYV4vfPaxJBYtUiMBF45BqeFVhmeWBMVteUmuM6bAMVLjV+qqLwiln62KzQRseAhQ702vBcTSIigMBCrAP1HI/AH7QB1xtuOIHMJDYcqrNkK07ijq0tI8cobtWBizvE6nn6mtXyC/jtdPdZ4CI3nPmwVCCP4oLi+ghv1b1VAUgoVsMV54Ht0WGgy5U4m+dzN2TOy6oQIyOJa4pLDBmixRaWInQwP2gmSwW5HUibsXfCbHq5YmVf5Ukv5ca/oK4GszZoA3fHQbKWm4eIIibtrL1xWVgBcEnZBVqw3lnMGk4JmMRR0ZwxEywKFccCpoqqd7F9kQOYtoXOsasW4ejISmMLAG0UGOWHqiHQI5CjPoi1utfjnUap40z4TPrBWHcV+ZNaBM0rnVNs/yd3rgcgjuuDND0L80LD+SAD7IsBlMksQpIG4jvHKoo0cmhml86a/hdzH/iwayuUwTb76Jsj7V8mB3DrSnsGF11UIVqeT3Jl8u+GOLQqucumsLGZfoI99COk2lFPnDJdYQGn1Fseww4R4oUmjJaCp3gLBQyq6vSsisUMAKyxp5wpxD+I/m1YPMVD9HVIEw+EFQmAXAsXRPAmEZ1ly4DK6ivsnbz8PrAsqBwXmDXe6Y69IslL8Zjn4hYKOqu+2XwZ9GO8Hpg1gNwFLY02r8Dg11ORA9JJxbr9QJrb2X8vDGSvjDSRWtDoUIgyeFfdKXBHryosWQjlAL2h94MrgJp2yFgSFzHwFLh+3RAYWoyGQ2/oMGdyFgR0ogdZiZBwvB72WuYqpoJYYWNk2giMzV+mTCpXgYFeUR82cfPsFDrH/aAZuWpxA4J7MOYN54o9qgUkXg/JMeX5Onm049UdDUH2Wd36cDO7oh68EK3zBG1o6/S7FoJ9UeHYG5/o7ZP4SYwlmAVb2vgKwTEHjof/7o8hQats7yQxTUbkRbQwUDQSPyuoTgfrO1n/Ku7RwZYX9vECSEySyNYKL96V3wdcEstbEueOhurH1n1orRw2SFIebwpcbubGdy5uuzGJmMCsZb/acy1tq4gPAWD6rQS/py8gixUSETDVzsx5koKHPcyLIK6YhoZSfMe/z58GM56+nhw9C4EjsIM9HL5Dyy8xNcXfWENab4njbJRnI5InQKB+21FHxMA+yUAO7xRQC3o0sJSK9/2mUACKevL8Yf2yNqOmhtBRayZlxRa5aftAhwBt9RRg7pGcFcPUwyIkJGb5ZHGBF32RId8gmlhmw39ZBwNFZ1Gy4MN87dkIiIVv/MaCQoBBcIeAPGhM1+kyxa7FTXCidLUiO94Jmxw1xaoZNJoGDgMTds0B4/DwIhLzd/7youN25f3aacTCWk86ehwV8BxBj2js12f8mlSuap5FfAbjpPwl4gB2GCqSUDvRq0kpcJQQSPUO9StADVYsUQeiLKnLrQljAdYEb0gqXQrwUIfBiRWyVetVExJpi66LwgRnEioe7NuIjrqs3zUiKGBk3y57vdUWrQ9Amm7qX4JKZSCIaNAkEF8JMoINLCkCpSlpD0B0GRFQGhl1knmyo5DxHn/eD7W5+d5ABmtqP+W8mDaOivmW/vhYmR0qvOrYRfM+pi8vkQNB117p+s68+TQhqaxTX9YiXrlxjgyr8GAAfArYxY2VeqRquwSxBubW9JuL6KEWIf3vfpdhz6GfwZKHxtwicBN2gHIBtQrgOsO1doGVChnmYE4vLWTBbPrLtntgrTqXN1xAl5YMIIbloQP2kGH5e3N7DxduNWOM9Fc8tpV14pNHdCuVwp7qU2FJIaGl4PThPmxbjvPEAXweIfh7lfS1MHss8UqoJvSEmyWvlA3USPIUA59yZ/cbC9+w0aehXnWJkLQceO20tXsCbiKz9NACMtcitXtECZUYGlWce+B/Y6tB+tGJdeW3FDbXVPUhFyxz8C8gLi2xu63ons+Bnw31bpyuq2MWVw6u8bmT8fFQdishUYsNtCuulAkU7dkz7p4KEyqaZaF4MbS4rPYdrZ73Oa+iulGUkTyRRymSes9fT57RkaKo5q/yDhB6J4QaiQUXHLHw2NUch+84HKDRxC1w0iUgmFjXiwj1M7Umjjbg1XLJyX1wS2SC13PtNPHLsKuSYZ/YDtCZSUjLPIpoMIpDbrRp8X1igYvAiXPuvxQEZNZlY3JZTZDCpZdPYljN7rMoA2AJBJq+JnUykHF5BabBdiR0Q2jNWNL4VeqMHWgMwl2a5kkIDXk4pOnui/GeNdA8CxZ7ALWU49Em2vzVFG+IRPepzDtDB3xTiRNkT5WXCsj/euZPB3SX1SAPePN2hG/SJChdPRNgguh6oGAmswLfbi+B3s0QGwVogLuqID30Vg9VTRRfQnM4oIdDQF6EephjcGbpP/iFkk/QQdej1sJLJwneJFcokNQkZMnm9BwvYRLVKU9oOJaAWWhY9p6GRuHoDxO7m6k5p9GpyyOUZAJFMUaxnD2rtOqNTYk+dynIruX7e1JmSFewWgclFbFZp/RcZbJlyx+4wTliIEorAg1zt+OTgg09Af8r7uYgeaWolWODLeeHX4qiYzH73UBKgohdpHgTaO5hEv1MCyP67uUak1g3tNcnos8hdSjUhiKHQpwnpQs71MXGf1HzYaaIaa7PTC6kwB2CtcgSV0qJv04I2t6sXVIr9awUcPXg8Sn3wRrKKWiIA5CETebTaE4CrTLxo0GZq978JmuP8ohrsWlbgFxmk1CS4sGi+6U3hlNynteoJwUQpte7gTH1ZOcdHcA1M0WPgeSBIu/mB7AqcaIC9XbBn5EKbvGGzRe0bW5v+hmKqLQrk8Sb7hfXzMvYfRifeVsKoLdSKqvcZsCyoTZc84aec7SH37L6WOhSRmZc1MKT/oNJIw9mtXlrf9RC/GGrPxZHYbH5rLQtxZa6IvKrrsgGCdkjHS5csNEAjesh5X/y+BUK5Phu1hX6jE26rL3dqCr4AtCBXeJB2JV4GDWqDUejYpQvHNi+Q8I8uBL6GIT67waC5FT3E/GkgYeE3UYABkNGkXgnWsam+wBSz+EamUQLEOzgzopMegqjpbYFl6Pd2ne6gLj6DNLAPPeREIJA0pnNmbA8WphwAgidxyVBeVWAdHqrYqOLxqDUtx2v7WNGiYEM/LomCBCLkD5UutImBFtQmCXmcVrCbSbivxFtOSGkmZrnVaIcNPeRO3c7+6KfFr4MnAwSFQQBYdJsW7ZYqTyz1DJoyNIGWJhLunsYWCBQt7j36hFSGdDxgEn7TWnIQyf3z4Y0W9K9Hg9h7YD9d4CqwPcnc3vL59HKmLSaoYy4WAJze/b29PTNz0QgW6LOcJNXl2bqkLh98JJkwTQI6THUz4GQQFi64SJPLg/dQm6LL6lh1lGIpP9pPPDlJn4CqQTi5Wq5VO5eLhkA2HMNVih2EhBYCZTAXsw8AbTrLfzqgX2k21hk1zQXjJBm0FVtQ25fbp8S21YTDFp4HoizrfhTJ6BZPu0nloCIQpQ7GOe8HgfWQHp/zeHQVdMN5dXHPhFylpZInd70wM/0SNRwLeJvbS9Dvjs2J7+sauasO6dcx/Ng0kO9d7eZum3vNoAKnNaIThvuC9lVaUwbiTRpwMijPKdZVlk69tK4S7IOmERIC11wP3uKIYkGOVygWsXnVzk9+cd0GjT0rVhJiOc19ssUxuOcAQUHdq2eUAPKtNucGuPRbk0hQqcwSv26EED5kiC4apN87sJwMIscN5/oiLZMwg+unR1w5gMmrjsT6fOB2605V4q5VNCdWpYPQF6370rs7qvdPcXcN/iHdQipZDe3FpVOtfe3ZT7pRYAX01UVizPnNSlTb0ipfGiWgz81dXAi7RBjR5RQRcet/UP8O6E5BP80dtMDXLdRRQnP+fJ7Dhqu7KYmRW+eWD1Te0dB7jukLKmGZlYo2QNkM9Fy4pZzY6UMkAQpRaI2tyaDtWnMpuQexPVLHp8mm+K2PQRpfV1kHsn32ezzdtLml/Ig6TraZcc6C/I6EAD0X1bNAHY92ig/qPzXhwVPXWaI7Q08p2Y+urOO28l3SIIHkuWhcdy6N+fJSFqvrZfzd9tQUlhwgr6q/1SaybOIgqOP6xG26xcJCvGvHvwRFrTcHVrI1CESujCsTiFWGb55jIv4u3reP3HKJkYXUCwqQ1tIVVZxo92gVHdMCJgkB4GETLQEqloLDSNcRih1mNw6tXJEHR8vi6Mk/BYZx2yYDX+scOGQX+nMQ1Mnso9OrqPRYIHnc9Se3T5ir1Ll+UVV7JfqFW6JyCY00iEsIuGRQq5OYKs6EK+p9YMMRtOlBbICMMJigxyUoIhWabMZreXhWnUS6cQ87MH2Rr2481HnwXLpaNgbaOdcKUnU3N9YqMvSqF/E4HpFgaDMpFmTwIgOQg9vPYpcrMyumOhGMnd0CrxxARV1NDkTqXvWqCFKpTzUd5PjR/D57TQ3+U+bXphMmJmoKEuLLxUkbFbfEu0geJDtYu4J0Dn7tZJDH/RvJBfDhDPMwfL0UodypR+QRWqYSiI0MAJd/1foKEc6KIHIqn0R/Bd7i+ncayIrQJNlmV3ovU65Pjl4td62MHWEPIDKuINxls24mXYxsxT4oNBbjfErv31wVe49j2QO1HEbQRrDSqAG4jL+Et3ngvqcp/CYZUmp25TnBXC1WlbYsJiOhGtjrxGYabxlyte9URwZFSs6UQMVNONDNBG+9OZQG3BuannjjbN0mtFMTXfFEBufPIUroBXJaOUQB7J1BaUUQL0OfubS5zCz3ZA9NFFprANiq80B/5vadZlzZBoCIYf9d0dtmsk6MjfSqNmIyuvwgj29Do3/G1mEOFT/rkHQtEbxLfcqIIh5pRP1S98jY2pCWDvRW8gJ9RoZWTngcgORCDwV1jbDxK5QD9PWv2O/hM9VdZ0LL6UnfDIky3aadilAzM8WflqFA9r8JgTXggiJPiUXpYIYrR7b3kwVPlBbOcAM2B8eZh32cZnAUyB8fuj5en3bWgUfBWI/FgIT7QB95ojvh5D6ZnOSaNy/iAt6BC3ktvmVviwWIjY9TaYsf0g/Y8ZY1eqY6L1nqTQbB5pQGv9n5po11GgPbs7V3uwQQ0ZSAQFyEfqO3Vmm2uhCrGlng56pB0XIqNcUjiTxWXn0sCihNyBW7X1uXkc5U7L3GSZZxND0cDlDzbGAczqsFBmKFsqFQ2BnoD4UiTef8osUTvLCmnyEp2KQD0E1NvHuXA6YFVOLd/I93dilpPPu65S86MTkweL/XbesXongJFnXvJV+Qs7tR47VwvaleMdhCpWbkBa4K52wXfX89HEFNg/Bo9/+e+JLxVNx5yG+AyDv+gv5NsMBoHyjJs8TFVSioTTBXAx0I84SKWsbMcfZC/ksm5NpLht8EXKUXBZQbh1Qx0NZqUmpqWQLFB6VEryWAjFc2q8kMEpIhRtzugQycoz5z/GDqsXVBowS1rnnrZ99ieB8H7rtZvEiSbrD0hhQTZTfwRpgbeTn6svWAw+SIWfu2FHj6/kUrYx/CkhcLKEEPMlYfNNK7q0RXdMuom5cE4H71oJkJW9XKpDSQWNh3fEGgKtnvotxbIssZyfcTq0Vk3KU0R1BMrIzMjhK9CfHczqYyedNWxzxN44SVFJUTXPO06aCE3E2R65Daj0F/j7fWxfiGcFB6wMiAdTdVICg6pE0QPNVkeJfZJcfuBdfHHj6HRnTgUd/7foVCKNE1bYDLMotby9eYJA+y1Yfq1RM5Yd7Wrpgr+fPzDrzp/t/ILHcQyvydMoGubbYkK7aBaA9Ws8mPo9wrA5mcOrMHmvThj0AfEYBYGVfIAGiK0gXqiOtmQJHIWDwF0fa7dxiqsG7qnbNscK0ixS+T7hxQVEQil5ygZTwVfSxKiaQjNlvTkXYExlCwQTBxURjs37sVTCeq2HRE4oQK6Vm3ROmj0ZPEO+KrcsceEG92fPOTNltnko/yxgGYWHQ5cKhDYvyV2OjbErGQyfuvmUtVNL6qAVvpv2hXX9sSoAV8JfakXCLDnY9A6TojOeTYPrXitQHEfu9i6BT3vW8matqMGJxxZNkDmyXulxkEYb2BtxMA9VbJTPlDtQ4whkE6jnh1a/UanO1V5YPUAnN2N6vY1dGH2kRPdZ7jE1KMhhmAoKszinj2OwSKz7dpDS2NJVl177tcMHTbygB/guzbnFc9Ig94atdWJWdcipkWN81jWAWwKVQhuRfCOuSGYHVauYxPt6xgvV3F7EmK2d8dGkx2Y/n+uRC1+hu4qPAk7+x5So2Y7GOUI7z6U0pRnck8+q9ONb+quGcXacROzWK0S6O0oGKii6tj0VrQLjv0ihxkXK04S3buqCGBvd4/LiNYRBDeZgJ3k1NHAZAK2Axkx/5sbBeNakuNsJVEvxbHtl0sk6EIB7kCF+HeFgexq4Orl7lAqXoRKYUS3r2vBhxOfhYyGL5uW+Sp8/gwzN3Btp9+iCUrtMjrGJYrxs0tmE6fqdnzvnLhVbLjvLanvH4H3shm/4vO0B0TkTyPvSCeGcC7Aif3hGUrphQJK4oTZwGl1BJzPclXsyd1K79BbcddQH0RiKtws+87Y6a+lIFQuBEX0JudMz601ZmWsj0s5aopwtASWiAvMvF2YnbPuZuhVSN3ko5MSLlBJRZQnk/iP+aywob44tsOxJUpImOhd8kED4mfU05HF1k/u1zE5ay2gIeDhxYzGQYqMRnMciopALQS7IqQ7qRYDmlIEkA04IUK7nsCtTFkSACj8jBZVsdB1/xcsoDlBQLqkMw9+/utRGlksHJ7haxFZJyQ2AlrJ5kfj0ZBJSm7u9KuXjuj7I7yil5GEuTrcRFVoCgAX49K7WtXoXVf8zVykBz9nI4C/HhUxBCrjlcJdXMrBeY02mKqjSLpQnu2mGr/2FGliX53QXt+aHvaCnEvFGAfOFPckQsFA8clJGQv1z9i7hpKgq0XHmxW290RPs9mXiex1xzW/PgawzKCnZf7t//BpqRlcdfbH+M+JzmKK/tnQBZX4C3G/8bm2gqGy+0F2sNFX0QZxCjehUCWwuBxvjb9BTLyWwAr4x1cGN4Eh3L47JQr5DmtAeY6UcD0oqAQoGc9arm3de32JSVJDtR2tmEq4ZBRNuvKsjsyOg9ncVNaMfrKnVTUBdYaGoKJThd5RaWXZcTq/TEkZNaZiEUnaTmTqvsbl8HV4YN/S4j08HMgEW1RFxmQp9dkcWobUcKekgnb4QtTkwbuUuIjb6LBXZZOCSdY3Y/pTJ60e91yiTBi3gdXlTa+gQt4Q8pP7nerXnVu4eGIyiuQK/rFGtRNhfY03KdUk516G3miAdqFAcb6MHlsi3YhkrESwo8IowRCZkTtINvQL8zvBiD6X9oKHEWfOKWrVQLzyEVFzreRkIu9EEppNg8nKZoLUIuqpmdTrBxACpLLhmhb2zSDUQIA7VxtH+u4xp6e7H6Ql6nDgValRA18ZgxemzPkgxkiwWhCwFMNYcu+HzvxHlx3zOdxzYjknE/zllhjHUfFM5lrQVQXALwvvFGn5eYV6RZwIJE0hUMO0D2Xe+Sy2ygZBER5M6wlm93upa4EQn2XqhPcXFJ83QenLNIMRGyOuJcXrgpGKGKgTRoS/uKjNkgaoiEjrhICax9cl3FtDs8lgiowegpoqKZ0mxhV7iEuO6CMpyqzrf8et+CeyiNyTt7HxfBSEo2zeTOHSTyEXb/DACVH+yez9mIZBVwNfJ6La5zkaBpoWSbyNASKuvaDekVSKODHHEFpefzziOOY9COdx6v3Yj0Zy3wjyudTrs+8Ovot2hGUbg/ExVHalJ/bQ75Qb8cuL4fRQLVE2jAgtWePzcYezx+iCC+FPlAKBuhmDGz/Jl+iwJSQtUaMSGxXeFDEQl7atOgjvHrgxR8S+/VmBPf2QcmdP9icbwGDZJXpW0XpshOKGbuhTBmXRQ7k0KbABGKvt5i10BilNURS4JEyIW9/mxQWNNc0qgFpbacZfdyEx05DgScaopQ7QBtA4iOHZ20AV4+SprDMC5+qYIJTaEz1a8T5mERmmgQu5Juu/Qt4R+j6isyUUygyuSJGd4aRW24aQDW5jcLSonfdOrJQnFGDQM4Tm51Hb4vZWB/GQK0WS8+hsZpTCHCsIoDttAmOX8fCodg/9kJvXs1U22VEUjMKKXXFovuz3rpRciG9ujo9rrIQvMUtArA7wymUvXYmJ5Tio8s+dm0+HdhMsJvbpRRJADdRINPCIZ4sAJAWCf+4/IjCWkP3CI+L0JZIblk9YN0S1QpyWLuUuBOZqpqNVBOtb1vpDzk9rwt55RYI2yzcUZ/5Rnk5F/IqFXf7P9MkZT3d7K5MfFtHScFhB2MWKLWo1IMbk0LEXhRBzYWtCBqomwctBx4itx+2qqMPhq6XrUHXsYmj8iGBxZ46/IH6OU1yzQUBnVUJtmEg45ZuXdkDhJUt3fZyBb2cEaq4+HEVDgwPKdQEMDyUtFHXANA11b8iCUl0i7GD5HkvIGD4dsBSq0/9sK4EaX0+9oiKLC48GK/7W67PA9AHuDVJ/ljkERb5TMMXwHvhfeGdeSXN38C1TduF65LqT/ZfrvCtCIn9N+41ftn9MygtsTDCo7hNQbl1Gzp52hhAGcFJNYG8u7K0NVmWg6Lr27VDz02GAuV2uxaupEsGZPySYrrvy8lNy0SmZDzD8opOpMcsko2dMFcMvVVG64hrQuAeYzN4pdO0muTQl9G8OFvCbHRi1CC7qijwU91Rn10UcDgn/w1Z3mSLNB5EKtCm+AHxCeuB5k8+Dvq0O/enwFgFW7kP/ex4h4jM2it2cS0sI64+FSuvIoBa+UofQfQSDFkbOLtoGriQsNh83t+7CqswLYFvBX1nAbfAZClFWV2KQMGiyYr4ljrUdmc3inoGzPuicjnpJbpNIKzg+1+ydaQmEZa3IngkEUXA1Wr+7rLp9NogjJQEE7HJey9lC0O8YECfBWbz16ol7HqnZTZQa0LjPflF4iB1lyjgDEsstcIi7UyKkg/uvuwXZNzRrL/7Uwc6bhdp6pNArzC47Sd/k2kH3tv8pa5fWN+unpJJuV9dIe5+xY7xKk8RgB0ZsUd3W8AQrsjq9r9NgXtmZf4mrcS0mXVigBQHshc6gjZUNP7luwm97ZJuRTDEmoyuWrwPHpVqtI8NaqesXsAssG2OG8rUYp9qkfrgxxMBWhFPgMsOAisVpBYOlFs1WLuHq1cZQLW/SWhf0H9a1AC6icSoVZxkAQ3j7UygXC3JcFCDuLrJEBbTFNfjMhQf/9VbIocQ2FgiBQSxe9eO/DO2+e47ccZ+el0IyOW/cq/4XsB7xXXtMDhqPhnbAi5dn84fsf9L/m4wCAJKzCER2wg7sVbsLbk9ka7uogqe1slIh9ahK9AtMlZrOO0kiTY/xXdiEbu0uckkA3TsAMHzD23E7oyGT7e00+Z6hbsxYxvH1bg9SiENH3T9kKc7GbAFsocDZhwz7CpkQTOCKIN5yLYZuGQrA9kpQf2pZi80ES77SPi7ex0BFZbSR81UplaueKeRMMY3W+6KkY+3YdmUKCh6fzraLIBov8psUj2N2NrEm3bHFXFVRJnu4Iq4Fh2gRZSR0YsAGaV0ZNT19rXlimQtyRrJa1pPUfsiKjEWb271PoCI2g5c5SB2vH8lim3/xqosEby/KuGmEMSueOdHFwXdDOyUiFgok8NyPHwrDSIi1goWxKaxgO7Pbk81yKoAGx9RCdRKRLEMVDb7YoP1rxAQdhGdkSWy35wUdH8aSLFFdFjt4MDnTMlyOS3OKtgQGA53YWszyn1E0wH0mLB2KO+Ei/cVOMSu1SMXL8F+GofaTs8r40qqQBUIVLGVWxnJtV9wF9cySlhRBlUI7iVoUiJzRYrXCuIacYybDewlYDb09rHo8er5sUSIRYT5J5lqj/4i1PaGmdW4IBywNg2sSlCwLoO64FqFZliTDcNqBtT+aqTmwBrfDUYUDUdPFTYZk26spw5w7IxdSYM7DLXRXyyzGQjHSkTU8G1kh2ZpDxYx2iwrlIdTZND1FLq/XPOJGfZ8GABHyrttIFwL9Muakta4RALvjPfm+gH7KyGQ+2fGlQXo0oXCfm6sU6HYaE7QSUYbACu4NBNAcWFRoziP2qlpRuyyOLp7HWcVa98vH66L1KwTCE5AgXqzfdjjfh42qwcv3dzEMLwoapaxeqOAWGzDatmwFkmTQkntQlePvmuE1lQtzC8hqUmSeG4eLy4vhoIuo4GNM4sRjCU1Eva8zE5cicM1wTT8SQN+Yx34FrgPAsg8bWXPtapNs8SdIGCtYsvijXgvXBdVoMS1t1VFnYF1Rf3MCoomYZQviIrQ1nwQ7QwlU8+yS6PpIUgbJS6KFWmywdlCOaQdylSzAnTvR1+QTRo3N4ASHDVRVFSIfhRHFDEILy/j4feLmDkkuKjhEFDRLZwNs6Z1W7q1ejr71hJgU35ELW5Yw2FVBJEgeaCGIGizhKU0pi+x0CXtB2m0FIPZh5RYJUY/LRoYBBAGepjHA55nXktQiCLxuHmgSdM1uXe0lp9rR0CUUfsGEtsYKKK7InJFKUJS9NHQl1KEWp9FMhYhjUMkqN+TyxtYm5+AJKSJ5NAHAnhxYWAnWJpCput/m7XqbuXaPrFuhFBM0hLfte8GoW4tdMVinpvoVdkaCTZeibaRq1mxoMyfIPLVlqaKRca9RzDVJAcaaSl5QaqD9U0d39QC4ySwgnTdRNW2r5JB17BbgqTxO2RtvA3Dru9lcb+NfqrwvNV0oB+wwmOX/c7a5H4hriTXB94RGXF18HPIE5okDHmmtisv2ZmWBlHQT6E2KRacr+9RPoYDlaxHc9NMFjxCo8vCIwtkYlCiAUNbceUiC+kh4rWJVl1yMHZYMqjtzN74WV183140ktBVlzFjhFqt3OS0MKpZZbGIQXTvF6liGZs4GX9Jnm5/j5NBfxVx1k1Cky03Lq55aI5sRCXccwyaBbNKwL6Sx3gQVzd87+vDVerwbh2Jyo+xUsDMgI1+LfQmtX85gqL9Pxlb9efOry0Eot0+pRqV+atFg+qUdJsmCQ15tWX7i6w0kEXu+V49i8HSaBjQGAiKfpSJXZSQhGpjoSZtC40Al5U1dUopzV5lIOLV0sRpo0sWqW9aUgkAPVFiqOT6TpxRvRDhlJYfRHCysaK9puCmCmA0p9M4hFWjkAqNgUik2IdYUnNvYxsN5CY3TjIdmUbL9lQ0sGQEC8UWL3Ni/RH3/eZEfP6p0W/0I97RIQ+l84ShP5AL10JGO0a354dx0Uhya+o5NAAKx8T0zugiYoXkRjUvyVs29O2CZpWLCJQ5G0YDwZnMYqXNnAw0la41fqJjGTGskuyNtN1cmp4sxbKj77fOIwJjXYKjKGiToidiNwTyRrCaX9RJEmpZJON4kHZsqLFsdBGiwNSAoyWGUUQTVRNN09S8S5SLVDBAr5ykgZjunVpOSFsEEI5tBU5wd69R3bmRxBYtPOH5vT2em4UrAG5bt1sFCgjxvRFMuv5eR0KbvOUtLby6PVBPixAoqcVIGtYrUEs2hKxUqEfutcTCyYqqEKpMq9j55qBFGD1xzYgLQlmGwWDzjcgmIPFcEhih5Ombx7bvFejuRNTShCFcMDaki2yaFuc4EKvBjs/COHQmf/rCstcF/YTiEQPgTg8iLArqusdVRyMD3pAzJidJrLzBOkUGN1/n4RUVyqeeMz+bWeAdKKfnwrt0obgi9sG3mxLK6q2V3bgYnWDoJy+n9sJzQkUSgx56IMTj1cIV6W3eyRZHJ9pi1oxSt9G8cDqdKYtBuu8vTH3aRbVtSma8VanVLiabQiZexKQx+KYOt4nZ/cHLQ4yxxE73Tvhmeb0kJ66+f/K+cNxdJkpZQ3NhtgUSj+ORlVNPtSxAi3zQSv0J7D3X/Y80KE278ZAGw4JtghEeDtzfge1kpJ/tEmV9m7Cxo32oArWBa3t8o1YDdig79Xs0xMu3wwXglNVCxIfh03rZLiMwjHQP6F6VF85cC6o7NmTgYGmqlr6J2qJ1Mn5jeroUg6QK3rCD/2jO70x7QK4pzunPiDMinOpYABB0W4mrOxdtmoeXfsqLZY1TJ4PIitnWRqtdZNdcKAkOg9PMvk6HOCeXbTEaCPW+O3SjFTGxZnOl+ivgZ4M4jTDc/3MZwAZ58JbFV2QHO3B3S8CjG+jj56Og7Su1J4zxUyCYL6jkYO+JMUUoReuC9UYpoR/SkZaEJfkyFwSKuUYYbw4ATTP0XVYuhUU04gaDJCMOPS+QWfhDp7FlYLZN4iVgN+sjqzeVxKre/9C15QmY33DO3jK7kZoI2ogC3TXikHThdNLYnoSvqRIuRVBYKtWuheemgSYRq58lh8BJEQEebF86jyijNSKTBUFKOEgCnn5Ig+TR/u8VV1AOIOq8k70CgNrscgF18k/FulHtSdP+bQUAThJGGzCC6Wb5kJGJbPqJ1Y9KhtjqL0zi474CCoJeyYBekBJJHFkG/w2CWkxO6RER8UKQTAezJ8uvkprWh4hAUwJJRZgZEUFss7d2dSFRAGn00wPdXRPzBdTEqugQKSU52cs7l0CPkybRr1kTX2SrvGRzzfp500sDUO5gLHH0hu3k7gPu+fBIFYgMEmBY/xV4b8RXGDNPPE/4CsBWimgZG+J1M8wq2DqSa/wgwwpropbMtGiwRBhBMijR0UKT5FFz7MTQF0QRo0qdkSJIkWEDr2CEls5NJIjGS+Mm+Q3EmvKBjK4h4/5Tw2QgJMoquxatmxCtU9UxEpUjWUFBi00SnZlUACQAWUUatbREUt8bvvOCBNUgdplQNFk4Vhb+GIlZUdNbgT2wLoLebV9fDBbE74aBaMNxw3vvOuDNQzt7w1lDn4EPe6HXA4EK/a7VSJUvfFdoQ8IU/RYRbNi20SuiE5CVjB5ZYVpwrMFdHG6fDLJJIKSeFuPHdpJy9pmFSFMp4uANm+ZepAV9g5ivNjcWWQGXr/UBsVhXjFxq5U/Y9aqsEUXJS5Rq+Alb/345FSidUOkQ1yiQhMUj/I6NVN22uWs23pekcI1Pj7RujPsdx7kE4Q5cM3tgP00JkfnxO7ZYlhHvwDt2LEO8ecbtW0tdQUXIN77kRH9EC41t+C6uXi0CHY140Jcs12e5hopmyisKrmFVP6X6O8HUGHFJOEh8RU4RSf0hqtIiGJHK4gLZ4kRlA5s0RrwI88bgi4/KnEgSkRFP43azZxoe6AeQqAhVv5rtW2+FXParm4s2cgy2LYnkABCV7NZSxzA5AkpLWAMa7bC2EomxQWUyoelLbSgGB0j4yAuk/RFNTl4tBcjxdsWp6sTcCmOpWpqQfi7gu/t8QH9/xJV4S8nhvqt9X55+3wFTC7RawOLiRKs9CCyuANAfum/LaIbmek9lzjt09TQxOBcxTo9FT39K9eQEZ4kLjiwrkA69qIcYHBszBmUH0nAo7YdZpbEYa4OQk124KApF+c3aRSSWqInT2nUrSsShMDL9t4j+KJoPjrBIxgIxWJhYhuQF7NEqpnMAl4zDfNOklhDcezaYoHGjoWuN/xP93j/x9NNu1pkOW6dfuOBu/qKE2v0YlAN70Vfn3e698AS9VCCMPTFGBkmX6Gb5kg+u7cgwCLr/o1w3yQtyWaUMZ5A9iGE0sJ/mNOk0l6iSQ4gBqXlCVqCHkYNoopjzqm+V09D1gB/pOfs5WxKByDM7xY9hUXKjhURjFYZajYWExBQcqMaI/ESvXZFx8n1Bardb44LzMAgc0VFJCG8kobmncEntiW5ADZEzfl/3bSePqGYivi0HgBr/xvfb1P2LBm4FeNY+d6J/J1sd1KmFAr4KIDJ3WMRQ8XNNeohAvTXDhMBCB/koKCgjNUAa3NVDY98MClJEJMpPUkNofhKgxIKDaa/vlojZ6Fwmto0T99Q2pdGUCZrUxVkFHyEwAtxAA00wSS6KYTe97esUoxeJ01Z2QSTQ5/zZcoHAZKNK7RGnV6UN8RjlNGthCVBKUqPXYm0sziVKg+WN7hb5nz5FOVhJI/j4vn8ORxAnEYvuzovMPvm3aAGb6p+FfgyVRuiHfD58uvg+mLEUUB4A6TnVujAzgP1MDdNu/bZ7CG7tj2G/Y9CGaACm679ocmVRVE1ARUZJgmsfzAaQZj9ClNCMyvWCnrcA49s4r/EyBEp8KXZSwXZsfOWlph7BtQX3cjbv5COjLQmLSplNIV2mEwxYuEArPPZPeP5iCE04qq7pghg2mSAaYAX1tbyWJofe/qG7ZQTLgzng/4lHaO4au7TQu+xUZ3o83fnTjxZDgOj0lIJEiPMiuPnL9wBIU+K0FuXWXmFKAHBH2GZ2tBGTrLDOvtx3yt4diAQlBjkNeTxoMCyGDJAhOl+nnLDptEmrWU3bGylUhRUY7YxqKeEcVt/7d5LAdrWkBDbDhEPzUsFY2DPubtQ3iMHYfuMyvN0mR0jT7dvtMg3UYta67MKMBlRajwhHLGrumcEYGWRVM+YFsmSWyYHwayA24slS0/Z8NbJrnevyTe76035fHvxWBu4yoJtpOy4E+jwfFdkmdSG6/EHKKXDX8i3lhmSCCwdByvGnYTWHac191ncVbTZxBE3nIMk6JxNzVfXmlSJIOXXCMcq0FcrFLptihV1jlQ78TjBh6URqYyH0eYpGP6nJaEfNGJTMArOZhBfCMQ7Eua9APRQ5ishIfmT2q2dLY9lYNbLR0DdTX7CzTPZNmQGb98aUAFGJM3Z8Wzl8aqkr5n6Xfr2XGccWAdoXXNu65BI9QL/M6t3gWWYJhIGbJq/IQFsFfIboIDKmC/N1Om3gZiFoOV1sXjQg3MseKPqLAHUPgWEZlNVCNxLQiRkgaW0wIHUhYR9h3TYQkyyMoNmjIWFoppeJSWJqvEYRv9NOrRt0XLTotQmJA2xYF6g1MvaLqeej6NvVDKF8V8KNkc0OmIJI3qMKHY0ylZ8YiY9PCtyb65ejs0Kda5FLbzid6E9/AQyhkvbiyYvC4Tr8/eL99HjSAmfsvrEfOUDl2yIxGNcseg5sdWjZfY70YLHN9A1AOmJIvHw5hTBujMY0dR6WrAKltLQ4EBONiLlTbDWTJBkXdTUf75yNuMAIdpAMkfM0lE0lFKN1cBlJGNmMjCO3ySxx+qYCyYYuCAqVEwPnuDh5KBdV0+ZKoiCERbtYr4yX6XNNbw8oDcKoI1FRPWE04PxeAT9c/OqQHu7h0onndd5bVLxDPSLckcilkAczAJQAgIwEo5Pd86YWysFk+o3FfSHTGTpRa/KfGsQmKScJujUFJlKY8/4edNJqu0FzUoIXbqzTWaSmcUPKqcWx2Oy894YSpAgjg2bGxbkVCG2oJuqU2uA+03m+xngXwBw9IDaqKu6ltPo3OHk9NGyPxlBDp/JtJn0YRA8L9HJCQaDof8Iu9lkmim7IEenwjrZ3qcMcak//bd/ORTYvObBfFCeuv81ogKZCIbjIALINAuJf03ggy89I+YATwJAVtqmNP/cILhKD8RubDF7Kl9JMi/PqPxl6KVDWfPReYQRsV8DBTwk5fdU9Sh6x14n1hnUlYR/3LmSjCVYhA8bgWv9SYfP9ontIJ+XNfC3DOG5oBh+B1hXVvKh9drw/LwqsvOhuNzHyiRHDfqLFcpu+IgKCwIzdLNwXJ1753vp95rvPtJr+/u2fkT6TVIfM2FXoGzUiwr0DIgzEMEU/fTEYHRREtp0c4RZXwZWvthyMMbiF1Iu+hfTsQeJI1ZCJ99ck1zTYPtoqRmf4oL93eMbebA5BM5XLuCa9q8G72GhWU6Psb7FKpRGAxScP3l3AHavXzUIbRtGaUkc9kZaN9yPCwksbfayyR9M4vUDPkemxE3mzK2IDKrmJYUqV7jSjnjilTTwDA8Xy02ZfnwQI9Hcf4Hwu7l459Z813EGbfzMgtML9bZsLcvHnMmc/lQsS0p5vsn9mhDbLb0xmC4eGXUuDgBQhI5Vyg5L9+H6Gvgkv0CIjdFdLvGOfntkAbSRwhrX319AiHCNGG5y2xOkbD5IhBHRjF5Ygas+x2POAeFj5YYsYsAQSTGGXO0daSnQV3S49lQIGQ3JYwOmu9ThRwh52Fk1QetsHyYjrD+jv/5dr9/UvuWpkQiHNHdvzJpO+Ii+Zv7a2Vb5O1A6v8vasUuj1qrGLi7UXLQQq+mT/FcBM0aElMNR9wOzg6fFEnYBys3odxM3ygEUGBKpD95S6GbfB7WkActIAaPtq/gRxYnEvneq4lAiqKJIA4qqTtzb/FZVmODR1HdadAje4CkhwC8kdvG3rD8b90YY++ljIqjIdlE0QeLER0yjyE7ugUDntKAoHPmyoJ1UkOk1TGuA5lXhJF9ozJZIQT0bFLLzrHXU5lrTk/s9TBXq7GbCQioCQ86fIIKQO7Rdft+7eu+CRyzyhpNGktsPr1pFAlyi24etWbx0eYaLAzQNjtG0TO/p7BD3ziBiN0E3ZnaIoYr15VkTwPlhRtSGOkgc1tuJA1s0sAVN+SByFe2kv0SiMUJBZV1CN0zAFg9uo7zE7dwvsTHYeRPWDewasXFRKP0Sjya69Q5ud1/igk7CbJHUxtUC8Tllx0oAnTmYPrQS7J3Rhv5nizXCGt8Cd048pZSZbq5ERnDBiEP/O1ogEYtFDUULucAbZvmbyRgG6qIJLftJq2vBFJwbq9WyO/sLc8OiLE1CfMdGZPg3Rj4pfigaO2RKnN/ppTry4wmV8msVQILj3k0/G9Dd6iqJUgj+NvtuAV0GEJnl2sEwQ/VWCk6AVJvmgJ8Op4KykSWvgEhyuCg5lk27yi7TklfagN12RJ9SwaMQ0NCV7d1l0d158SXWhH+mq/BXZEkBrXsB7cRUsJnnAjGD0ShmN42gy2M7QRZNA+FbUNIzrbyVHfswUQIFA/QS/gy8nNIybEAjmclgbSRw3UbFGgg3Hl+Bz8iBcxCg7mkhNctrArIva0bjPa7J9gjgJvaC9caOE5nvRBmsVJakVbKzwEn1CRPP5yVnlzNVqrsmKcxTECEIFshs2CsC8YJmkohs18MvwrdlVLKPPmsIcAWC/nOvClXlxI287MSemzdlP0MMCgcjRdaRPu4Cmq7RuLiFeLN8uFO6GEfcPoHG/ID/PDvcviSGgp1Qdjslwt/NnhQwFqsahnziv0uDXk95nbTPgeDX8nbOcNxrQtZTsVnt68bjJzE/4UV3cvytQtHQxlhoNC0Kc/F6otVZZu5XXKCTmFx85+o1qLcSfTxzcodq7kCZYklYPj0iaiZYVie4cDspZyAt4v3hqVbv26311jPBJ13koECze083f6HOvpMH3oi9k+FLDScYFbeJpk6BKAKICQmUDVERnl19mcdAYoKTdPc+9zsUx3dmF59RqrjgdzEI9mHrYUBLEQaarQQ9Mz0/Tm+kx+5p72Aqa+5vrBjq9p1tsXLAgZGvY4tmFCZ2rg35PB0SKxcWrkCA0twkunERwdcxPQW2C48+FmWe2VQZxDnozcWFEKyo32mg4k4X3WPtefjERZdX0NVWjzIy1UXtR27Fzm9/T6n37heghGcUg1Jq4EO77zlD9O8F2XxaCLQIClBtSbMT+Ff+zF7nK0kUAFRDK1S66g9jzJAvoiQA9A2gWAm6n1BSfTFqPJCjSdl2A8QVOP1LUVOYyOtF9sxNqFIQwkwZqhiDknLeSZBAEg32rSZZFGKo2ROfpYlUTMI8QBQOBNOJqpdC/C1rePoOq7XSTsiSOXa5blxoxEgjZwaE2Yuj5gxYHdjEL2K+nttCG0oKI5mxDVqtUc4k3kdeae95hcoC+Qe1ruRTc74qQuXcA0382plkmbKGgWTsCFiS30yOpr9MKqjS1DYBrvUIvp7ntXXDcRBiOftHDnpvsqWzEhw4eIpkV9+K3p59Yh6SBvr1S/g4nxcGeC4ItRihkhsEQxE6Yrr8eTnMR8Fqm5Li5OwuJEcNlf/eBc3zWsVLVESdrgKcNHCqNX0QMzqLH3UH0OBmlI4A1AphTzs3UT0bwp9Jkq/tpq1pXgic7DH//JphtJ6Ted10R0TRtTe2pteHa3kU0L+P0u4+N+zIk2iyO4qySIXtocpk9IFiHjZ0ArSdBON6WsdpTtEtbnLOcpSlUYXENuAq27yyYNta1q4YE5oQnHakZOTovfPLlfkXbKucbNJyWbD9NiL03xNVrICJeLhAoieA8frbcOcjqepudWHesUB9Nb1QTyYhmdcmmfclCfNPyJvUg1l3hiXb+1Msb8wzvafcOYz9TflIF+lPtUWSouH45fMzr3wsCq87GglvG9SqzKLKhENg/Ic8PJQNkPBDctTb8KosZaTcx9FItlKRDMO16z4xTEedI/PROA8AndoWvBrj7HyOl04zLgYc7++YR7tYUzUpJNLCbQZLe3HpTC5Y1ILqXjbmmSz4pInR1yFojUEK2QQsFlFiwnxqE3Y9l9x3QfG5CMlRpdxOWcpk230IAyO3iXLb+tTKbQvA25T6J/uRNoZ8rAMK6xfNwIzygsH5ZvdKO4lrg2VV7uJhgu2s0jPvplsw5Ih0oBIojgEPRJrLxpvKHpi0M4y4BTtw3/kBuuub9I5ofI/0hhWrW3DL2WgiFvi+ATkE/rF4dvrAz8kUYDsqWACh9poEm3cbRL0hHpR/ctdmEaMBArQ60lT/74KAXR9+/uyL/hxfUpkQNsAJF85zWQ/8xN38uoZyPZL/Ko2+LxLk6TePeT3xo81fhzSYWVjvvdUIEYntvihjKH5p0jG6cdNQDYb4NAzFyYitbGmL7T40MOA3HqpbkZvpWuIBNZTHUA6MtUICwhaEn+dCBDzmiD4Y04OyLrYmi+g4aSWGiJmZi2gD24srBSod2EaH0BSOH6R5WJ4YmCWfi6NxNcsDI6N3E/FeCYhIDxYxd2DB5saLKps5gPOK18jLFvQCd+43t2aBXglqvJcrd3++GslZq6eIcPv5JEuP+JgOqPSMlXZkdLCQi2SiNQrn8/ZVA5BSKDw2QcsQSmutHB4lDN9GQEqnw4BpDOZoear5g5/Gj5IPfHzwJVr5ZyX4ueeN+GdCTgkHJ0pA2qaKOi0reJGyg0qUj2aOQo3O2tvrWwcbGzo142Gh1wFQmRhBVa/1cCdSsqfMi6W6naCA6CVs+iMr4Uo0qrstwv26iYKox5vvPgv7L7N0wA8DiJlLLApbgWNwFtSY0ndRbjCDCYF6Q/YMRpujz/tsgTkpDqfjbGVVTDI0FKQQkkgPrMEntNq7wur9/cX0X89upBW2wttlqNNMyBA6Vpr3GigSFAL0smFlIVbyNb5ikkkAujoapeLhSNpEcX8b8W/FpBNPjaYUvGqxhHYGVbxTUYw5KqmqMEYkFuUiYB6eSSNkSgEpOIgvKFsc/LYTN780Y2HfWpBOu+Dbzvrn/y70z4z03tIYZ0InpEo1SirDK6QTa07uTxd2b1nkkBIulq54XMBv0EAVOAypWKN+NI4Nt4gnWkrzwBGsm9pvUSQI9Z+05HTgqOgkwmqhN1RAmmsmx2SGSi042RATRLwAO9EJRcfzP0jds/Zg3w2SzA7bB+cLUjliCXHguOVSKt5YUxYfdi67FYhxrhNf2/yzGPN82sBcEt5r0amUpTekvz4/rQrr24Gfc/vpgCIb0ELJNEkkvJ2rcZOnCsoDKGCh/kPaGgxze/RT737w13QvEIVsQxAGi2SEbPZqgIjAISU+ZhtMQR96Cvuri+UKiuoDeScGMy7QvkxjGGicXF1E1u2+YFIwMbR3X5Ce/86ejG6qgGbbgedAKE2bECzUT3QYjSFHesqAJk0JaJ4EK4CmfjXyn27AuhKRIYB3ruKXlZyk520JYzbYL2TnA3ULjrtDv4x5WCQp3XzZJZMsc2gBQsFpBn3WBhUOGMq0L2MkofQQiDQbNV2kclAMpQIOCwphOwUuRDmk4VhpKYPGvEP5MgMMmUeisbzd22bzgi8aMbZNzCTKLxNNeJsO98K5rEDQuAQQUe++Layh211SRzttCUrlgHR/FjUJHOaKNIvtB7mIvJAE5o9MYvJQc9h/qr+RJokd7T+sOgKvvsAWBNZSfvikcC+hT/9Gd5v11ZNWDHLjk8/EQaOIbpUFFR8JV0EQ8E4O0fxDfKb9+Sw8heBsPaPJoTB/8W5ZD0cPBy01ut9KCZlSnZrJLVpm6PxlnN2AVkYm7it32HUKx2++UsK+r5QP9TlcszB6Jm4uQinc2zIb2MshNWwK60vpOK8v484ZpFTw2KE+J5C1Pb60GLuzioHl7scMi5+4ot2XwjVInTtVFNq42ecUkhmXoT5VAm9UK3ChO87qc1fkiMSCBgOBSQA50Jo3F1JJwmgokwhCRpFRwWhf6bObBFWVAZgMf5UwMWFKjorQdNjkpxNAfwQXgYUyztpiJbaahuJ3aFQBJoSYMr4W8M5R3EIzA29Bt2vTtLOCCLrqopsSD75vDYIjIlIuT95c9Fco1o4QzzDEKq92C0g9epp8tTrEseGEo8av1HPcF9YXoJMoAKJ/PF75OqT2L2A0denUzDMTdV1MFvGSUXsSuGqYnMncVBlPT+E3PxrE7TN+ctgcVKGb6ZttGEnCPxDS4xYc8u6rWQpg2H28kZWvGBU2zyyP6ZAccIgJ93eLIBN0GmQGosa2yqs/0XA3TqosyKdFjZWQT0bUvfUs9ndXCuq9iV7G2liASNSYQIqwwL231RV7km1ekDIDMvAIZmYFcmUBm+iKu+H1a+IOWBaTeEO5GLfILNW14gEMgywGKihQqRq6nNVM2+ONkODOLMVz7Ozpo2rtkxlWjGIMj447+GMHPZ0yb8WkDtBEGyVTTVDNntFFcL4sSKr1x1Uo2IEUEk/l7YvF9jIetkKgZwWY/MHM1dSd4sQ/H28S6Y0WfEcD0cnZDjpp68I20wCg6Q7NGxFurforqghN9vLlQLW+u35oMj2k4968s5MryhJrCk8obE/3uA91M+rCbpfFnsXOnq1aKpCCZuKgs2tXPBiiw2S2B/nlgkaSIKLXq/lFd/TQknnabJs04+oXO7PuxQD0EmwmxiZPvkskNejCv/zh7VOpBbWtsEMREpxSSJj3QxmiYcwFLoOc4mj6+lXUBlDelFMXoe1Cm9X+OfnSppdPb7fp/LBoa4SQ6tWRLCySnHNEAfy1B33bx9mruRfJYPO3QDz2/8pJ8iCae+na4p32Lcg4diRho29fvH2lYxQa13EEFJFeNNkQFWeMgW/mUHvK4eUWuJFc5iE7C1wkjeNUDHkJ1ZAMGMMOAeUsdNzv7XCreCctnxdVoXZuPsgMkxdHZfgFbEqCS7mQM1W64LKoN4tVNqCSbJPoNdcYSnB3XMRkT/QZbpxCaBBwib6sN7kkxzkqckvs5p2Dh2gtbK68ga0dqn3uv5rrSYvGeee0LU5CWCRM3BsIO+5dff2r/uiNs6Sdjp5vX1v4BAtd8XI2/0o5SstLcRCSY4qw5F61g6ybuKYo4adGqQzMXZ/OGeKE/mJ1IFB3VoxbX/R12DRq7o4RoKIQvEbDSxoqndGQbsCaUjXgMic1uG88TncKobTOQBDC2MkgxEHQHRWyCzLCam/A2TsbIxGw27H53f4Nhrl61vbuV/o1s82AOjcjwLRf+WB8I8/2LbMxldKFVF5EBcbWdRQSx0OEpOdQtASBom5KSpCWtGRsVIYjLm3kqvatx2YRxw70hNQhzm1rCGqY7LehoRMDIbOcTjfpJicUMEGDYoxhqdo/61XpCRpPdQHX4OKAYuThH08ruUnYHjZIn+sPeBOMKk4NPI8LmVffUGI21aIBV3dHcJ10eRIkSXKMtywchaiW4tPZl6HwZ1lF6jjxFyW0ovnS1lxGGln+4gJJwFzq1xFt6P3f3oonkUIEIbytHtyqNBU2ggLULN4gMfl0XDvc05UdQdmbvsKYWVKwHQJjXFc3mD61JiYt40ughZGc3bppgfKmYj3WoidApDb3YvejT4CEGXp3UQgE6dtrAJYB1gU09wXFPipUkNbKvzc5XN8Ex3q2RMtauISamMIJHs8ZoSI9qU48Ros6c26ffdSzQLWahGP+1Xf6UBiYKRqS0+zRvqwebSGBQtmSBaMuhEq1O1kgFIyOyh2UvGGvXr0O8rWQ9uvNvA7c8s6Mo6dzE1vCHpjEYlIrlbGiENoAwDVYhUeWcdYOJ63ZM2Qeg1sEnOwsNmMFwWeYAOrqKeqDnrluoAWyMCDaiufKgs33Llr0QwKs77khvPdXsCgF3yA6Yi0m8fFKv91HQ94rgvfZZ22WO/SsLtcE3zc8TptZvqzemRXsYuyuTkWoHMSBwhQVIQ9ilner6UtYdxEgs1bnJA6351K9QmT1G0kC6SWH2jMSL6CFtsO5UBJsS3++SPdxNQuCWSPFvyfqwtINvje32Ica2M/vqwSI5d4QMxYXipWcj2wBwsXBAjwy4Ikm557O3VjqkdplanNqaRhLBSVGi0nem7EEu9jPIgSsJLQQH5xquKvVI89T9Ouvd01GjtF3+Y7NLUiMiCFsg3HUbGNc/7gth0U+R9R4CaFvMlBV7+LQ9siN5ZBPTmAYTN0XFXC5YrW8AbZAQzcYJTIBu4SPa499NYqAoJhg2R4NzgnszxTUrDbOkHbLY0pDzJZ27l9KIj9V9DCuzfaPi6Es8u4qyLb8GDkGv2bDgHRHM5Xg1RnzoJ/WPvKurM0JKy8Ao+bGgzs5qJIuK1LUIvGZr/Z8YjfJJMUpSoECi1rxgZzV3FBDJwC1mpb9DP28ywc3cBXBJGFLxY5JKssVZgBzMHtJ/aC6DbkoSP6QjdQN69DnKTAwrWgnEfff3WEu2MBXOWYrZ7M/y1JT5a5YQjjRV1ATa2KUEiyC99VR2IxkUzWd0JRkieGFoONEP6jmwoMvsULkuUdRiBAevpk9DKWbkGUOcmIA2saJf8EPsutvVwYlydTKYlIPz0OCqPRm3wy2OMnCbu9umlhYFR+ynePmh/IRt7OqUgWjt/DLckBrt0BSCacoWvgJjYNcL2WdpuVfUPi0WOF6HS14XdubUSTyKSgJ6RUhlSvFIwx5GCYU+VZE9UZuGQ0taSRxkKEvYjNbsJrk1adjrZR6CxTUiZ97ONRWbpC5Mrd34ajWsH3a0nFLe/lMVORBcxOPNUYCQWs6fHSDkNQR/Fqs6+EWvG2Zm+38Y1JC2s9FEhLv/i7PmSLZutoFYOzom4pASGAoSjzNRMpbJkew5rV01vugmTi9eK+qqGT3QPOnHZqoThLP/G46XBWhhhkhERKu1o/1if05sxyFw0aUBThjGKpVSeTnbDaVSe0qcsjHNzNkRp1IlPHAT5Lth1aUOyBj74ttn2t+1DbdqNZWmiW1jd8me5pfieJeD3siqeM2g6h737VDXvko2GDQpGfQ/1rDyitbFL5im5KqL8/uhyqdQeKoutmTWIkJKP9We0uCTJej9i2pAK/Q2c2ksfD6ihTC1qRiwc75e+WRG6w4p5+BwnTEmZExoa4Ko4BWim0iOpOZPFfpbDiyKEQnEwchZVHotBo4gG7XkEVJRjFm6az8GTQ7PKQzuPWr8TkBGeUghNOm0OYMzKZWtLDKsg4zEGJYJp35qZGwToGOoDbXc5iuQpRkAtptRMKqVLGSzdjLZ4R51ESFwt9dlo7mmJa12SoZgGkOJCQWAjktX1XSQ+vDw9GS1A0qCgaOk1WUk9aVjVrIV+ggrdpfgO3QHpCctGQK68OBzIw8rFqRSMkIUPYy3Jx1An3F7py5k9HbYuA33gewY/TFZMahd4soxmmZXSAyJ3lrCeek9CLXxtwHthLgt2tnOoyT0WkoN79qcXsgGUotZjaQnXd+C/gc7D4CbZhrcrkqhPY/wODnqRQQTQFYndjzqWjEqTdN/OPNwEh/cmoKisU+CicqdmLl8ZQDtrxiHh7qmlOhj2QPFqic6C2bJxgQx3Si32AFYXPT2FFlK04cIBZQuYQKh8EZOWH1vBhkxFr8aPhNVa6z1ariNGGKUKw6/AZkHKo8spKVdha+X6cqK7Vr3tyK7pK0RCt357JLpBSKqbBuXrQOYj6j3xZORd3aGoO00yGlJF1/XG+9mTDVuxJY0ANijobQYlojIGpP+AyEu+CpLdvTYSBlEVyB4zLqVIzR7xZO0yMJTjr9gB2At5JSI0fYtedlbjwBirB5Q46+JpFIb3p5W+qvLVKjM6wIec+Iiq3W36NyNOXVJmFQ3DrDiiEA2GhjyZA5CkG3LmTvymmLjUHATKPqhS5gxyEyH1Sd75kkDrpcTxzhUmpzRPqQQxE1uWJaOCFhUcdP2LnqXTOna0zTcSiWLYpANGKstp/LhwSRz7Zs3j2dyznMiuz6O7LByjEio6faNmoPJK/smOVY30mZfUwdMmRCN7FZ5jgzsVOyepqOOupDOUdzJ3TY1zUTY6oyjnGhiCB8+ZlzoIhAtYHs8TPtp4FoobiW0xOFtraeNcrF9X6LuyQOWVnzlBvXdvSsb1vtpWESnL5MFctXLKOBuIoHeRERz+n0/eJKPI1vqCWqBUzy02bmDzKHsRFsVldtUChhLaHw0CSTA1TdHtTMj/Q1k12GaJRsFYqKqkT0sBOOIVf7iwhmRDTKDsDZ7Ib2uaXjQG9LDzvUfXNmKEZ6MDgy7IhrPwBZWvSymny61kfLHszqRGdUNGlAzYW8rmxgeDdtmkgWGVCUpAjZCCsSqvVppDJVAt/fb4c7ObT0r6ZGsY61iSAZQBSrD14t6lBIlASfWhXIYmxQQx6oT06TdVDnU/BKQEVwfF6pRTd1wHEpXgMqDgRijEMbhWHqjnI7idKyhUzYzc6vXVPBiaVThQiPm3J1oa+4u9gM7VYG4NLCwDDXGVSnXLuz8H6P1CWVy6E4ZbD/oFY1uXnj+QYRNouHNcykBFctBdZWpGYe1el0H+MaWXCi2566jkxOJ2V8GPPe6jAA4XyQ250y1TZ4cuJyZbwcrv03kZ7Qk/5KUFv9uvOsOeLSoEQnnovQLDPWGLTYnrMGoSB02lcHsxhBhSSC2BPL4oOAW6Qn9SSdGGrEJJeBN46bwKLrCroPAiY4Zs0HWwmGU2vQZPdph1XCAorMYtRiC9+fVHekLptUs+orYpBPjKTfQAwBfciO/diSwFoPbgIyp0uCG+yA9uM4dKVAN2nDlR+iPjvH06YZUJiZj4SOYp5Yt/LOlgXShop9iW01jrupItoCQknD24xgaozvjtBxs2AvfM0SssyezG8J7OufNAo3a1oI7KPfMtglEAi8hkDdBzAUaoWuKkZwsf+C6uHuTnvNNlxX7mxLSjycZhVMtmXRi+I4iaWfqxDKrWcdCocFdxxlZa6v8Xpk20IvqImK5K6Z2vWT6xoAmCYsI2svG5i21IOracPIgKwqdhb8qaln0hBhGp5uiSRZCWynmJRUuo6rQSPVSdDpTGSiXIte1SggEwReaQmbcP19WGjigDe/of5qjmXKv2ZZnswiSsCB0IiZ3X6R4xsbVzZ1EiFzWDue7Qhpp75l4HI0uK0DKFOmrcCkklGPj3XsO7VA4kD01raw1FpGTsXx1w4d0K5mja05T/nNp0+O6BbdtzM1IOD3dpbimLfsY4wS4FDEIGIegaAQfQUQrlAvk641vB9v0pZJZgvxSHyq0XmlzlBvK45YGrZ/cbwpzvWggs2+Xz+22o0ib+PKDOS6XaUScboDbHYMaEdA+TZUuTSylFWgcnVdaCEN3nL7RaJY5UOkKktqcGkADa9gUJgkDaGR7EAQmUx8kY/8VnWCmYX9FA6aYnUl3Z5f8/WfY5hkI3QefACm7eU21/olUxPg9QX0UXJRjl7B1xCIjDvrh4XBTNwB2U+u9Acwpti26DfCkdVUXsGb0GEmBqiGbxCOaYY8EwQhyCkFSqiFICbXaNScvZ+FqUnbhlTwtOj9n4JAfD2Eh0xGWhlIFy9DPBpC7k06mXTH4K6xYp24VCGDFNtx7pw7TmGQElh0U2WM7fzadRC/JOVlWAy1/ROfizwgq1QbNw+9Z0NSBVnujbGv24Lqvfhr6d6IOegPhJYXE0S8X/iEHmtSFAwb6m2o0cCksEuvjI05MhtWTUQsdm31Gp2/kWQmckTElnsZ5qhR3IUJ0LAbp2O3OmiZjGIYDjXwRowLqRS5PIE4KiEMPHkDOG9VNK83A6uBXsVsE6bWEWjAWgYH6WFPN7MAuYXkPqVZBQsxlA8nSBkcF9wAZLxDxUlmS+Xt432NEgAJFGSSDYSQAVHXSAGehoAUsfleaZEqhn08PtJXpbARZPzStXrWjMAup2czYqEGcBiZGwinNmdCAYzVb2MWkBG//npCUc8nWdNfkauGNKya1iw2l6TWQ8RawKqfj4ydIhdMwWSEEimeOn4ah/g+wH+H9zeHThHaEGYfmrA2dZSg2Ga2PLZJfK/2n36mj6w4y9wZHG0shkk46FdZ954r0H+Prez+AlgWuQBOGFDzCFDBaOk6CMP3HVaP6Gf1oHIAV0mTEpCe7D/5j3qo9DSwRoOe0GV4heMuxSXI8karLT+PlabxHsB7oFVpsVlRg8E9Gp2UDQS/YqhWDEoTZYOHg4gDCctdVLwscHlLqJ+ymuZ4c8q26GEv2nyKt6O5vJarKD8Srt4Y1NJucBoLlrOSA8Jut3sW6V6eZvvsSNM4a6GXUtRzu2aHOHRY6ICSdhBZCDGSXRkToM1tbAhs6R/QEGDfWhTibXhPT1QcyHREV0axU5dXJJhv1nwhrWFml0YWQmRXrVRqnFsFaCQ5FqF0rPVWmdPHnQifDyOIzqwtSQkM22P0Ki2fYsMpvtcE0GSuU2BXo1fjkOIAsmYpH8161M6YuHsXn+qwOSYk7tWMU2N2eLqIuOUkhINHutTkXOypmqZOasq0CeciamPcqzph8UUAG9muR2pFP56nsYPQ7jhJmMcPUp0a58OaxCS8gLBKujrUqEDvJ1U0iMimC0AyAYJ5KUUuhyovxIezOFyjpSnTS5FElN1XVHRKGJtelGQjZrY2IaRkJYOKzvWl6ynFs0IqP+oavTSFpHlLHmHJ5nKZAY5Dtt4D5Ohqb4JRdlSzD7dyeVl2GVg8ARTKrddp9ljjqG2LHaq+23ItqGkOpUhscC4mr1R5QI0iBOzaHJg6i4dvceiFfZQ3rvjQcSKUxeQKXEjDyGNy34FIUMpWeliqG4JtqRKUIxIR1pIzprEKyRfBsA24ywdPAxMdkXxZDEYX7TQMMGSJ3JBeUL2jiBFZMa0Rij3ZqSJiiVU/lykzago6D5pQoFGqxiWf7CLiBmtQBu7Sf0sc4+H1qA4WW0oQRXv3n/hyQkXESvXyTgMwbRmyapgCPDmjZUUMt+lmmnzT7l9ve3TVCs/7usdD0jULuF9epON1Sn+BFGVMbbJ6wUBZHZ2+YFNONSWkcjuELioCcpNEOn4Of1uYEK8SfN+jLtXUjjGChmqmwdqaXYdl2YlvudSqSgnvM5dAlmue1HtK9F1aAUiJXeKbCiqCj4RONqXQ1d2oyEXaGim52O0QYje/CindHWcAB6Wke7Mb5S0sS70hYUzXI1IKa/UvbuQKZedX2lKQo6MgIgoyen0xQF5pIMu4bZPOYMT+Gq6EaJXn/cNMNy6E73w7NG+IN914Oc3HsgIfUazJyB7enzd7H3DOqj0yOR7IBTzjci76208Dk94CPWSO7n1V4nxBIsRvsZoDsf9FyCu67HXlNPYLg243oDf4b3GsmBosK5zckV4edOjIJ9ND0RT+9VBx21ArsRAk+Fe+YZjHpuoMpmGlxBmXvtupim83rfloUtOBox/7gEBQ5+L18kZIGwMiyh6sRLzPa8u6ZA07CgDt5yLnL7pK1wLg3D/UhQYZqH1avmihr0itlaT6qXaYYpWkOGGBhWb1kW/RzAKgTK+fGYnC+yQ6Ot8p5NZCC5Au3iy5ask9V1LnDFgTItBy4Q9uxFY9KpJBV5QmSYg+Grd12fnussZiWdHhFGikNbHA8x3oZuvgVKA7u/hzhVar51jRety3wCvGP9l0Ch+tG6k1NcdGSaV8QLVExyBUKOhIKJ6nEeafKIXhsYbh5Q3AZQYQBtpLLqC6/2hR2kn0UAmAhWy2m/hBk/wWbsFzBjXlCsz7LZ45lalbJ0RwnDfqccj/IH4VjTcwWOMeacdo5Vlavi6TBy7l6pUm5Q1NYrDXm7JKDGG18CLg+1JMFtOE0uLyaZzqg5ulGTsULrsb6tIOl/xhgBHdMPacv6MNRPMzQ9SUffNOws/ODtS8NlylOMSgK06e0f6Qgyyx6BK0ru0EcPabUyoydo+Rh19o43hiqNEhG7xjn7XkroPNpkt6IjI4hk/69i6L86Vep2jw2FFiFnhbce7BEKg7MVr3GjmQFUCzD/rLEMe0NK8r5uIasEOit5fh2JKmMBzSRt9CYpsURsw3MkmMm1lOjzFhgsBrnXnBMcmVI7dl0kUzJ06EhZEtixFDoVdr4SHFanWyYB5o41SjtakiPwKE4CfQNEFq0TQYaiyJa6waHUmqPwKrhBYWDWribuJw5le7TSIiaNeqp6AJZS9zrMpD1iXQGwp52V5D8mM7meKTAMFPYKcbKZJufgMs9Cadmdup2xo8PaC6GPHBBylW9UqgavmjlR7BGd2GL3LvixNkZCpsdpMVlTZhmf7B8zuLUjgC9mnGYBC4NxNpltKU5iGB+oWbN4xpKo/FcJxXRMKhhYF7y8gIN+aLUm2bzNUDwctzKDDTT7b4YOukpr/sujnzSNY6Gj04VDz8P7tsAHfNs6lOxtChwNzQAhyCl01FIXWk3Jhsc7Fd5n9DQbDteiOz235yVMAoJQ3meVGwDQi5C3tE3MRP7XgLXwaQMLTnWWgBGBpbp4kP/EbLRlgBEAJzkhvhOH3tlIYlaWzC+E0lwOhJYbT+MNGbvJtS+2/symkgIM2k7hAjawIW4pOiB1F6jWW+uDxVo9VldwnTvZFiGpJiu/eamGKXdDrjsFDElUgw4gRTC/jYZdxs4RsSBovMrV1AHE0R3ya5SY4f0mOLU5wthHpHi/XBYN7VRR1IvjpWH6c6f/3nJXUigTnOh0hujRhjcYcsvtRrD7e2Ns8N+3fO7in+X/coF3UpxBMlpOUy6jSKXt8fUtgsDN+gTYVKrOOiTKjT3BdlGjsi1Zj8oAy8qQnrabkcTAvIR9RhyvRZ2fwGvztqOatm1y342ajknQUVIAmcJDdRSTHNt/sgqjWMy16hjZGC6mo9y++y2rUmX4fsnQauGI7vMkA2OD0moG+WHuAi5SuxwlurSAbbUWNI7ylkUbURTcsfPuTJ241zUo5qQsIB8IfvFR9l+T9h2rYogmKFvZr+6Ct0rU9MMEMI6vRLkhH7xhkK2SgPkwwF8CSyiHtmUt5KjzwKCdj2qJY17Z6vZyOejiSr1dv9UyEDXxTcs1dvjcGYPuaFoPYel92TWPPelOliYCwDd/E44c0Nm6zzSatDJLLs9LUbbT43FGreWMGknj3Vkljmf0y8k9WBPaxiZ+do5G1BJKXhdGTvlELqoDsjTOkDNaQLlzUypOrJ6beppMBw6PXqqGuWM15euxUKG5V345iyWGU2ONgwD114UJXGCfrMMjA+zAOS1Gwmu0bG0hGn2KtapRdDsunsu0QZiC4cxMypT05k0o+OwkqdJByn0Vju974WvZoFtOpz7bJQDIxmspFPDTq4hPGk3CMkHe3/Z+Mf0mZ15WSOIdVLaTe2JVhcfXKiqKrzPTOzuI5u47bKzzV9+Nm2Q62tB4NgDkPXVBzFolWCZzSD0EyCmi7dWI8do9pFsBeJ+gZLmqH2XDaEqx7Flc+MvUCqUJ6EsNlDKTGXunWsDOpr6utwTI49tF6g+nk5rkZMtYDGjYjl7RambWkLDZlvzbF3uoAwD6qLi3tVJtvSrSAslrK4oSCu+ymsHRI8mGA2wlTeu7Llyqvjkyk0D1q5qyUkX9hRsmG3mFI1yhCS1YlNsJlULowSqCTSOM4BIMWxos4vxTqx6ZSopxzAtxUms2sSF+9cdch4qR6ybnycnPaA/abmGUFJFWvOC6Wm+9LvmUu5BEiyw/lkwW4LMvq6NvTF5z0q2IOKn75Nh27ELn5Qj9hml1CI0IkJY7mGz7DidCXQmOql0zU0Sx3no5M09DSIYUpSD3iAISJVXR3wNZDXNE99D6rocqMtjOZmihkMUNZsaJcYCNUbBg82k2MA8LVoz1vySVNJ3Nro+IzjWfnnXuDi2ojcR2NCIPF56+vvTSILShtO9bum9RmEoAIT8m641hV2LWQ7m6zTTQw5oIveYb5ZJqmtlY7YBMdV3EB+SBt6qw3Xord4FLnnurV5DLcIUrbSXb0fzUTVS7sTWvZwPd7+n8z78rniz3dCUGFNoO4ev52hN6tCgxiQ1V7DxFOXRdtczSemCdZYy3LjfYF6N45YP060JcXQ5lNgoeYQGoI15D9VI8mG1sSu3ZhqbL+Gj9I6kVMlzaGw6z+8QGak0Mh6Rk+6ollpe0H2xSavWAZqDK9vcmbhY0qYai90ZZ37Mp/stSpxp+/0Ug0eBo9bddkWG6WUVSH1JAnRz2TRBGgUpgzVZtQ7s3s+knkksnDQyUR4VHhzi2bAtBNPONR8pb2mO0ByhaSB4uMbYuLhVe/PwAOXHbCkXhn6p41wn4mpAAaV+ml+1j07JamWX4PIhTrZ9igJjwC5MhMIhajjxwresC+gCzSK2l0nkZN+G4+NjjKpmV4TuJNqlTXkSIunqSU2WH62ukuElt4HbKb0vJhZ2yyNMc1vUnUCSk/Ktk8IEuOWtdVVj6icisMUB6W5Okggr3FrtdN7vCDS0940u5en+rJOzMDRGILX5nY6aRK5WRtKwnuT3EgWdy9WeZYYEZ7cdneLThtGB17RkopY0e1rVye9OhFV2Wwrom2k3BSQWux/oojmxZakLN3PXmJsuN5kgmOWAwpyaAFdn7sJKs6pluWa2PqNoFpdd0dCWrMAeg4SkQRhfr5tBtYRMkSdeeTuHyUDHy2i9KPHo9E2NYQKqkU1VY8CJ5glr/9kmimq2KFSoisKubYNsHDv0o5SiZmNUbI6UwLCPU4zfFR42tZn6oTvpqYoS0BdTi0+/0A7N4ALwfONJdXhWLeIcGjNutXshmrCkghQkwugCXHEvEuTRCVWGHiYGCMrVCHamWj64e7cz5m9e9K4XFTShKvdrdIib1rxOfp/stnY2kvmZv7Jy9bAK7CShRp7ECG6Uo3zJbxiLz9t5WFJ+cJR+/9UOonqw8SBbtjm6n4640jFN9o9ELaK13q8tlOgCOcp1H9S13Df6oPkYsEQVkK6SfWFwt7gjy9J5XSag5LUGwxagWq61+cWi3OVKZGjwrb4YnCbmOJxZjDg7ZXYHmcv25lPtVgmjBab72quTDKOiBZFldjdpAe83eBpuV1vkBT8DtwmNM15/dFkFGrs2hX5WZ2XIcakQDw5t+I9RGsjyNYNqag1UTtUlpMzQ6Rk1za7MtA6cxu9Xo7/xgXaMwiqCiwiTFbuVbTQ3VfT+3U4WT1hfwDWeuoQRk9anpUraXRmjMVUpY6NMQBVCoXjuGmKTioHGRLwYF2+Mf8R9q74iHtsGBeRxXr4Ey9QxLNyIhGLLuhyo8IqauRpuYNHOfrhDklnY6aI9vuLQOVEuTM/KK3vCgGssyZHk6dGNJGUOZ1Q7eUMrFWGWnjFyuwP4z+zVKIUPgTw7L2AxHm5rO0USXGowXWtA02I801EetwtXqdm2PQSna9XRbOQ3yNK59eOi732nwTISWhwax1qQc2MuSPFiFzKUXicJ2FLXFv0HObmYUpuj8d7/S4EOmrzDBQlIGdv/9dZNedBC3RGQAO3PmCqQOu4hPUGV6VCBRmenc6Z584TvsRlg0S8UtJqKE3ERuuejx20kDg5vIx5y85Mq5Nas3fE0foPdt8AhuWh25iKmuEkAornH0MpUApFf3zFwO7xP3Wk/7dUAx1pNmSsS3YFwv1ObE+L0TGwFCr5SOVhCU1FX3r8a8Q7oUz8hOS36UuS1ZIetQMcOtbu5yhZr1qWhaH5hqvOaabVYDiOqbSSYX6g1dTVJLMq61tg8/JhWoXsCyqEkzpKkDPlzj40yqsXNg1DxHN9SDguRpvNk4a9gTcju7w58ILNu4lFwtdrJotqDGQ3xRrxVAfhBudwBDEvjFCVeAooY3TTe3OR0U4Fa/ggHuwSKqSKqCWXMLhSRqA9Tsjd3xBALo/H6cNAGoJ0aGzbVAAecvuBfwfEJqkxcc9hcoQ1p0SGK0aqR0Y9H51RFww4GfWtN6Uj64SOZowGDVNwrJbVLfnrcsvcIkaIkfFqviy681wFMpSkEe2iQ8ewKEKI7H9FRdEKx5MPQpvQ06mfTmON7rpSNC9GVywoidSQ+1hC8CpGlJl4Kg5icz/P9AkwcjQF4gWLPYU3XNOXw3raeDc0SuyokoDTv0Z1o2ohZRyHbZ15e3SxvT8FAS9QgOLLLCC9jWWfvNmt2E/ZpK0OH2U/kGdvmk+wZf/E16P/RipsaAHq3FC8UQX+Xtf8+WbvoZgZs/sJm/ilwJOV/LuDy+OdCDg5wU/do/X4rS6QQTw+3TTXLUNVPgiJnyjB9KTtyYRgPEL5vSstQEPs2WCmUK+ajz1LizKJzShriMRYBDnargsJLDDtP16sWlaRJA6OfYQwcBMVzDrXneGccLH2SU9cV7dUN0WoTXWG6tY41u0Myqct48mb2DxaYByOXb9eY1P5fbwGMFmguMgZNeLMX9ZmkKpLGrccRV0rgs+KHppDBt8qUk+WvLtlvNqBdswpLoA+J1+FrQDdo2jB1hAVvp0ccnIXfbxFtyzQZn4OcMArVO6BZ5cgy0ZaDx2ZARnaB71nPiZkpGqIHDcCBBUBnl+fIYq+uKBZTP5MO0wZxS5gDVo11kBiEcpczZEaNaU18lztVxzye3XQnWMB2DIqaNMYiFll+QZ/Y3K8CgEDPTX8F6173dbHQpmNTheswmZjh1v3USGWnHr8OkgggW7wc/lbEiHEcFwfEs7Wg5Fj3xVGj+39GS2czVrcwRJY2O12/pp8aP5MNtapVaLlc0XecCaoSldawS5j9YCUESRHOVoiUJJJUC0e4tfmDvD0cSAq3dBj3b8SpJQ4VSN0JA6sLigPcnl7lR4zmsf39HxQLJM3Yz8fdoLxMRSlAUF8K83gyDdw7JH+RHCNZlKZkUo00PnKSAl0yFhTc1umTxKD5cwtEIF4uBEjHfpKhf6TA2KD5fTtCdCYy7nVjS8B9TVpSRZXd7Ydj0V3k1AY3ZxF2dIpISTXW0T0E+nCHCygC3EatOdAURuZdZoPtBAcdAS2+QCzC5FhoccpaOzShWy9sPuq+Ly8Yo6DaYw1LKy1ne0JH+tX61zh2BOiozFaKQO1fEHSsSwtaBPoWHTkZ/xAR6ffHUy0XCBjO7NXWI+M5YjWF4/6xb+b+KG8rA1PvOmsBkSoyJc0Hrw+qiRjKT3ghy24bzytIxbkvsXSw7FlXiTGaytJkA/gWmTGelvKoTnr2soYZxE9bcxkqpSve/E421HrSJTt1nB2b8UKaKVNy9AY0i/hQfdoPALL85vdk7b7mBd0/1oaF1OXgNmkQz8pPa/92k+m2uqxfTG+f4WmF2dCoyWg5M0mluK9pQSpdkFX/x2dAvyeDnqgBR2xuLkbb/a/srf8MhofmZt23CDjCjI+qLTS7iT6H0jQb1mC94Cy4phag7lRlaoFs12IAVXu51bi/Z6U98pgZnUhOdk51y1WgZem5HNF+Y/VAdG7z1YIuow9j9Sg3IXvjr09xWx0iigUwnDkBuPTo7eD2jekz7facAKuoil4K4MWaucIgjhZBILt6DmZWgcGWRet+vYaVLVuSylJvMGAUsRfbH4LJGX+3YePM9SjnoIBPoyGRrToKxMySo7TozJ7vvAPBOGnow1ipGqkLvdQRpsnsLH2ccC+QVUC/am9nkSBtnSbGuyPoHqn553tUiYOmJdT7EDYZdxTtoHH215i9IXjzYNOqnZ0Dn2r//TGNqukq7VsJJyW0NylGjVWOQ1ns5MVbazJ7W3dLH1O0Tz2HgauQnjh9UN6MlgwaVfUhSI1MHWTeo89GD16yinRtidIcXmIab5My43xXSWOy//3vcQpdWkCo6yHZOTqXOht2wQCKQvzOmGft3Ok7iQqC/kB6M/4Y/1XbpKYmZa/K6RGci19NLVtulKaRrorMBSZDtTk9B4/f1+SaDnu5Vn2Ch9ZEVQSwnxphZ+FoHt/7V7Yao0UAFcXucCwwWhBNhFhtn3ZdgZEhoNltwMUUAjH/jpbDxLG3R5xDUxsTE+E9fzYGCsd5621Yl9V2oYsXo1+aWhWwpKexSco3AhD8YB8z7qMvwutNy+js3Bp1+nmcNoqGyeARyGGx9K6GY9Zq0lm2JN4GRAbAN6WeywKwtbDk3CkZodAkcVBCohVxsV601p4cOM+rET8qNWBZURrxAsTOZVgOT3yjCiOwUbR8LE5RefvuKeupFZca1ZB0AyT+g5Bypo2z6jiK2pdllVpPp1ZVDzwkTixcDFKNF52wkc2SuUjHeARrh1vAC35QbpnOLY5qtrje19jt9nd/lPyGaSlLJYJutLFM6YKW0pixjkdHaybjTLVm/fWP3DtnNCiezN/j+8VrXz4IEsZ4xwQrdZVB3N1jHFzjMjT0pJCMrRs2fGqMwUXc/cyVM6+YcasBRy3UMRhBMPQKNjHEEUFsHbW41sEMmtAGsT/Kh0cFaYeUAuuV2IIdBkxd2TgavNiYBJcOWgUi/Ku6npiJ7A1ZqGf5JBa0Kie9P3ocusWYgjRN6VLdui9JRU5PqK92ccrf/7ClK5mrnUK35bD9vUs7kL1MJhxZHL6YelGP2/5J6y1YkcGlKTiAuKn14nA91yzEP+Z7cbrtkt1xaf7TBEHDvpAPGZOrKh5wyRuBa/87XX7oVrVn0zhlCAeYF2L/jpVSBUejLNSEnFtvJtVrOGDABZEklmy1mCFhq8J3mzgoKAzZldJs2aYszJS6XwefdGO8v1VR7wfglEuZbCZVbNtSRfkfWzLA8N0o5ogGfKst5D5yVUpPhXKXCdlMRzpDEYbmSFhMQ6Q7NK2ovme7pVqLllkc5FvKNZxR5KdcNxhe2lKRLdfjGvWeT2sVciYK62av/lIzCTXPTG3hW828i0oe5FjfztoJQZhBXOSXlJDiUgpUrhgElFgg5gvxbGSnTOMOrakaud6Fm3MiwX6d96u9uw0uN9iP6gWM96VBvw6RXXUmilooll9svioebNuGpSF1XxMYkxE3+eBgTS1O9XAcDHqEJ+0yGWcquh9SRcOX6B6OAoxE9lNfYbDnUyAOVqhhba3DgiZMWTdV3fixEgkao/Wbv66mPTWD2vZtTJrxedEchzAt2bSXBhls9UA8G1KBeH8TUhJeiwA9mDQR31bBk0u0m9p45wOJiDzvU/m5HeS4Jm3AuBsHD4npg5eKs+84u9UdhYJevLkatfWdnf2kip5Wy06OLhv9aAA8OygitugT303L24CzcqSKDPWUjzDh+Hg8hIwwo4rwQoLtVhXe57SiOBM0T8EfzkuNKXZrm8nVE50ybUhlppmLpVcjrYqGoBuXcdO1RC0EXw3GsebqyNaJV9a1uu8LzBBTGAZMfWWnHLQBG7AjJqXZM0enFYTj+E7GxWW0a3IyO6ZXAF08CQRXdoN/PusT2Q1oy1LyYWo1R0otGpjyE4NIOMelKQ2Si1b6aeWPZqi3nWuS7NlmdUYKMXVAEwLN9CaU68mXNVghxdv2VWcTmvsfp5X56GDDMTmN9Lds2XIYFEJbo5MSe9BYH4zFwjU9MS/6ZVPo+qSliPUoy/nz+I8NndSC1bjPDaD0iHzwme1c8Y0BQHNouVBxMGYwrz06rzUoxwa0g0F6q2Lie9ZYfUHn6nKULOyC6pyxAXcAq8wW9t1msITGnH3cPj56HvYgrCW6TS5Y5RwcOi2NStC9TXJusVjbopNNItTDDZAsXBR5+EZ4mFu9e/RJC2mPNsGkMXXXprpdTCrVCOLZnyhF0pnAEXOq72ZZpQsbKLXxRXpNRistGVkKBsfnWItNPJmzftOxng8Q75RUoupDfjnMa3D9S8l289RI21BGYO0xt8ZRKy3BIkSGQWpZypgFwpmZ9ac/9g5aZQyaxU05XUg9GoNrqZItmSoHX1QBcTixQMhOcOUYR7280Q3Xnh4arDAbUQjjMboNKS4pss0HjjH/Z7FhpXkoh7dTKd2GCYOyuhCDBrwJo2SOki2E8dNLAQ70KQ0AglJBE25l1vSlbg4lRHPpOPM1BFef5v73ypI3sHls88ERRTmHX8jNcWKFdfdwjp9C3uFZkpAZ3HG2uZLxNKpDv2nyMxa7MDvDxq5JbGOhjcmuacgCHZvhDFVwEGZrdj5nmXlHs1WxmH2nsZMpupE7zzZPDyayRqsCW+PyVltrHVgxVb5ge8IoUDSj3pX/wI9A3HWKqQf2CYcgLh+PjhsXAaTxdQPlUH6SyeZxnzaP/WnaCAxHvkDrGkXGjgtyU7tLWcA+C3pWUY/y5lBylX1nueza1ZWcZbp+EvKNMMnmlHpq0OgrV94EkT13Ftk/Mo70KuerBQFUM7sNfsL4nWUO2LfyNKHWmxLbpyQS8xLrjvYnqDRtrJGrd9/3ZezB/p+UJVFFNBqaqEoFyvvq79CB5dQ/FGNIdKy2dF3DkYOlsW5bH+sjd5OpWL3cJhtaM2qc7wj7yfs1jDn5Z7DtmSAmcEeXDWRdTvEt4buBwoo0J/w+C2+S8Amb8LzrV/VPR0QTCO5Qn1XXApZ3JmD9iVsPCRe3bgU3aUNVONt5p+c4Om7QL6go5WnIMpeJFIyJa+INxf3D7umL1YXGs8Qs90hta/iy3fG799J/9jRJqdCdvuDiAHqJt8lnydU4H6W0W4MRbqXbrwLewXHlOfVBVjJp/DYvo67Nhow+WQtTtwDhINo49DGxMRatOsGkCrbwNvFO1UoYYz5PjiBfUIZluJXv2gKLcqr0h4Ny1vyZY42ioM+nZP/Gtjco86be7DT7ToqyLI0HuoXdjxH5PMgjrAYfxLNwjmU5msied29zGpel8WySUOxo3WwHaEMz509rSfv1FQcB3vHtNQJ6zpS3jxdSH2ksNgiDbDBxE67GPH3GYJr3Jm8phMjL9FH60TvBmKFuc4g8ZFJTLe68ju1jmv0XW1JagTJOnm3lO5+E/hGkITs1+Czte6FzBW1u6VH7qRsDIqSYDCnGm99n4+0+puXNJp4Qj3Ff9UpaYLMtrQSjVff6UAhw3rNgmuyzYsV6YyR0P09Pkbj7jcNpdntZStet/hdq95bcQ/WF/RxGCG5ShbjsR8blmQeawr5zprHj5brsIUP6s4gxFdV5R2daX4r5tANsutImJS27CiLurvW+C5fy4Qhz1olRx2E5OGS5w6spy50YxHevWKHaNl5kJKDvKg41MuzFBWO47/R/GAZGG0afVjhDyBIGaxRPbf2nIUENXi8JvppIZGu69Kj7x7lXfsAEzFyGoTaMqOQgcjWJfe6G9buSjM3oE4Y0b15TeQ9p283VZdNPwr4bWGY5BTHXGvUgEQRcVZ2NHHjiDlrrlEbHuh8API6NpHL3GA5d1p2/LJadNgYM5beinIT0LMzluqwc0YBUmWU0cOwYVnkaooQrPGPDZJhNbIOhTgza8Lve7tUDkXkZ3C0OFNi7IvVkT3CO0QMDQnVnDdtacye5UdOw7Pr4HDjTzawmAW2jd8X6K9Te8A3C9K4vQWcmw44Hte8RJ2j8Nbr9G5HdAK99K0TqVJrx8JSyLsL06YO0DztShDq7PHygVZQh7+jj+EyOHrNh2U3tUP5RUFR7joP3wAITp9AIiq+DzaX9uFOmltXSemM0bObTJGZf5WiICO4XcM03EYk1JhUheXKURnOf477zyFNRub2eta6vuWpm1yc6fcx9+CSIvIeY1bCJZxR03K7CRZBhLqyJTn6Y7d7MTKLKhZJa+IBC8YjJ0o6Uhq0QtqQ45b2KAdNTW5j0Nr9Jk2uy9gDyExEhsHotIkKddtjuJmJ012faP5nLzaz3EAl14bEBTqi1ELbsbCwYIMSuMg0nyKw9uJV4mawACQPCWCKpCyn7Mf6OPFdyjtUrcDrvjvzoQTgD74RI19qdSJbOdKjujLrOWgz3HMz2IDFZaHxxiJrwBngQcniTYMtJbk5NvticDNwRJqtuEaMgRpVGrWijaxBDdSzswtPch0UfLaymlSA61NCFEaHIMr0GoxaNr2uPMPUpeSqE6LCm42zJoIo9/osKQzr/C778674kXK1l+IQAJ8wFWjERIUVV0VjXmVnojIPN+xAfFIJBSDV6nsAV3DRqOQgvifjLMBHRtH7E9ngzxH6UcTBzw7ff1HAEObSo6T73I+zsfkC5l3rjgj5SzvDyvKDm7d+Gkpx3XERoC/z+bXr4LG3jrNtFQBsriMZm3dMquKjFM8C0r3iKDgp2zSMjRGksJLB1MwtngNQhFwJT6YCGmgSG6KgHeHaRB+ynsmPcH1p1jqLSnqenca/RWVSc7C1nRXiwAarweCw29otnxqPBCOlVWDZkqj5vWbxtHvXgCWyYbAHreOXt0aNBE6GO+QoGJnf0igddmQWFmxzoYwGMiA+1RNrMIQS8v91xa7nOFypGIMq42cphjNO7Hkpkaw7Lit2ktWyuakGgFNV+GQz1GOgXt813gpMzigzCfKZKRsyl7TJz66iNyAOIsDR+LX6gOwfWlcyMxSx/LZqdqenxdC2KSqMu1e5GPF3a7VCigB4QOUbtbkQ6Nbozqp/WZNvbI0kSAndwwXhB/YxqUjWWVU5HkBqVFhYq0kqcpufBcXO+E+k4he44WHf3Ihq7bKUd6M0ux9Hl1nqsQPiHvzw6aD9YFMXHO3dd5U+iBPTx96wdtGFZdr3DbL0lA8zPk7QlKkGc7F+hFpv25AW6vG3mUXUvKoOIxvoAiO+c8B3405TY6Ljz2NWkFUcZoY4wb4t74bUjz5ywOXCu1YQxcjUGRiHKKyayZoGb9coaOQoBn3pTkqW10PAib8XKh+PnOZ99Id2CiIxx+vSGKGnPHFbOKQ41CUZUQTbfQG9laQ6I9wdIc27Cdj8egQa5vF+MnjjQvwxnIHzRLPNENggpjbLP7uN6bZRbID3vYenmU67PvsViDyGQnnOT3JN/5KjG1aC64hFEi2IkR3SdmXE3Z8gG0HXfuv5Qd3O5NC3/zsLFnqPrtSm72Y4wneQ+hDoVQumPLZRS1sWrN3bTquuqWB3szF0/0dEjvfc/h5kEmsJHL0bUHbFb9Emeke6wTx4ZFF3+nsVeDCabbLWoemUGcfCnsDGWk9Ap1/DkDBZ1WLTixE4haWkOeDjW7+V4sutkFn0dR8mzjphNFX8yWNfP7pczIbu5RhvKhWdCoOF1ApotDNP6xjZwNZVPqYMO/UdNs+COjm5QimRR6nuzj/CCegycTiIG5URjtMuUPInhtm+yHOxDIXEtVdS5yrETLJNRO236RirwVUgcULfuBssXU99kcCwOkKNbXf20Q0T332uOIG5nMO545qYxr4l3JA0O5s3xP6/Drncr1+1+M5XPl7oaDQTNqf/NPAdczgTqjqXUnqEDcGqAnh5UfbF56qCenqMUD92ZfSzklXgRNZK5uk0iEtCIxWykX5gtyzoDMdeGd03L1K3DfCqUEOjiEcE2C4jLZsjvD1cGwZ1Hyn0tizaI8otZhKg5p3ncdI0o+UYCh9dlnF53SDC+d95XFXMA1yu+UcuBwgO1dyUKxoqOOuJWnWvt8VSdWhyW3os95JvJk+cGWMrh2ZQRXKyRu1L0FG6iEH+uTVkzq66HxYqbC6jppn+QN6sCV8PMSxPGd9Q9GU5bBUqy+XDQz2bwIoB+xSoCfPEp0R4NR7+TarIzdVh8hKNHf04GMdCpz2A94uj5lD7MwT91J2W5Y73lhsPuDkHMEtSeZzbPGte8qbHIWyPHp7nUQLM6iHlz/0oxQoeyzXULCXE7I+apipya5OjYvPQsnmxS3NDvjzgL/Rs3qvAZ58/2OOnQzx4pFlVMzshjmNTG7EHS8mbTj3eaxal4T2uh829HUt5vclM8cIZ/SjvaPw7O1Rr/IzSPNTKM8fJkw2eSBqmY2W3VYk65z6pYGlrzPtIfK2WukqnwO5PWr7CzBMMm2zWjfo+QSXxOuXXmKH8i1WVIMEt2hwthJQROZ+IkUlGXDZZPx6HSuA3qxYYt5c47RSetL221R7C+DdGynvucxkmB9sUCVmx3zXk+3MbySQl65tfGI9sUTrtjn9bapdYrOx8NbDtjUq3K+xBLM6MnDm2n+U30DZckx4WampZXOddRqZ8h19hoDDmfdjfK2efZiJjX3cjoO/ebkl13dzsMTGmWsfo4ZHR0yT4IPj1hPpmIM9pC/y675cUS8SPqU2Ok1ufMVVMTwIiubSaiY+KnCmTDgNhTNk502Fi3k1H2JwPI6e5MyKWzfzboienjOC3pTiOuaIroAUdGW3zK4Pjduy7RzTiVIgE0us0APU5xtuqs8bjv0P+c8/bVQx+eilWCw5mrSq1c4XVP5Ei7Jo01K53tc2CF3QTZ6uGrWbwzn46Wuw2QXVWl8Def8uTQE6luTjhV7DYYKQdzdwPUrGjh2eZBtkSoxIdgZzAcNSEPjxOI1TzjW8k5O3l/3oRAGAs3obHb8LhwBtXjKwaOqoMRQo6jOIsQd7Re98djAQfzQPc/vB23a+yoxk/6cFSG28IWzM7pGW2Q9Hd2oBvTz6IOTMCkloxg6FqFNwcd9XmbgTka3UA2luDWWeRprWp6Nma/697Gg7z7JDYl9jbU4kDO7D5UdhGX1ZVsJOxw3HPKog+IJk08e4HQ+rQxX6aYpyyaguXTdmxFs+E9179Eh/f7d8AR6wc+xeG6AYdj9FGzitmYmI/uVXuZDRNMfmhFdV98nk1HzzPBLPvwzrB3TURjUYm8QER4A+jZxNNcP5jxmf1QPLQhODvHQzfEXILJBOvsQlunOuKR/D0A7R5g4psuxOPRj7bETRcYJqPYbvHKodgosT4XEDwzlBFBTVSDH0yNnNlbd3DcXI3sblvcCMayjK0zmvuYyb5g2+qqq1iffb4gGy/QBst0X9AJOBO398ORyQg8lgEhNVWoZUlCQdpgotX3oEL14FAygHrt1TxmyWlmjGbx0i5K4IzEKCbtNoOxf4d11Wh31JjNg0bibGLtoKNj/bTYfBw3E4tQTg5iwk/XOZz60GTtCpY9XSe/T/sfN5jx5mCC96ZXsN2dUidtjO0BZyMmcEE66cabihx23UzL2KFAA6bvDgyWSWPUn4Q1wyqSDpMTo+MIBpWL8xNljRgXp+MFHJP4PLs/OxQntXMIk2kDaJP+1kAOUyGt0sGa5oFzYYMDkxUqE9xyicnmrLpB2x7WVcNAEOwdkiDHTckBGc5XIcbBavwxb3f4WeyFU9pdnfAQPSc8T/YUIzSEhvE5gSnvzN4TH5Of3eaHLHgip4fWWC7mnZx1CqVmIV6dHTL1pEYYp2RnlRzN3auuw2dl2BUTLwq51+ZLsNbIxpgfnKjGuMIpjT+A+zHRrlY1ZTKZWcChZqAvuv0OdA+vUEu616pxhFpgG8Q5k6XiZC7xfvJwTdycwSba8N9OVPZzKmF1M0Z8TqfEs+YzuO0BlLSWPICPLGA03aqDZcFkMGdlwhZnZCP4sm4c5ceYC8CUYM20t+rQ4K0jJz91clWbgwtPh8rkY+UNErjkY5EtS6fNAw7kOzrJ9kxWSQvdJFoRsRGD8jTQoyure6bin4lThwc3Foelq7Ydqo6L2ZP3O27QWD/JwCmK0sZHJddZOGArayprvnNpMOlU+1mQE8k6Jmk0pn+CmAuGY7gmc+hqhxxIm7Cr74Qa0BXFuJasa2NtUoXujPZHQGrGKHF0R3gKslLxiR7bGOVPHnKWndbs3Yxd8gismCi3BhXEY1rJrreYC6hkxeYgh8YIVpTTXDYDeoz2fqv2elCBBm+uUGeOPjUHbiBO49wcnns5bGUHXajMYW/EdOHfhyuclh6U1GFaOKnAfPwHVT3cGI2GoaLLDGJUffE3Fx1t9llyi+KQ8rotJQc98mNkp1oBWRHd8clhiw6NnEZpgrJ5nIA+y03E0NOhBpg/J87IylNYreGJN2NprgMuipfNLxRU16xB/ZDHlm4DzBhVkMhVJowg94/VlGRbw3zWs0SD682doLwxefB+2N6ygWrxAoP40DRycvrjIOg1S7BkZ2kq86CTmL/jNNDvdNUp0dwIwV0BzyUbXDQ9d9dtt0GsC2NXzdhtYw0JPwVpNiCtqaKR4OjfTKaOhHN240WZxHeibir0lhi461KEJGbBTpWpEJ2hoelk7Bo/KMTS5kIhcZN9mH9WvrKbE4kKZO7R7rh/I4nGuvcXM2J04viO9WTHNFyt9uQOx3BuNJ3ddkKj48a0tTOaYJQWs2p0CZ1+qzfXI83MbquiZYXkGKKZd8LoKRw6jvS6Dn9hgjwbwOUEFqOnQp5KO8ybGA7BupVGIcfqUrNTJ3JrcjRyBxNIyzKOdVBpGOcFOcXuqzAKlq6lZEGRUmqFiKcb7KPiB3AIoLEuC4Bz+U74DgUA0PuQNoLbkW99bkrwVuzP1ckeXDp5FjjYXNw8RbtJDjLS/qjxAH7aHVGO0Hy02S/uaoN306SzTSKqiffw1ZPMfMSNnm06+76ojkz6xvMsMXpmm3cm+65HGybHAvCEnZo5aMxHhrjxLWatR0mn12LfRYKkDYB0ig0rlMnUQpWGoVa1T9b6eKpqehHtAiokepJM+pu/OBSOTl/VdTo55QCmlFiWzHB5O2XOZvc2vA2CmFliFAJpU1M3GDSWRiHehrRc989Y2Oe1Q9xFgUPkaCE9MP1odb8CVIjvS2mB2hwohthdOAgLjQr9FtkYmo34J9gd7qMPdh3G3Y+WGAeplqRo4kZdMBeQ7sCYi/LO0szeEN3o3QJ2lhbT9Jlfa1EmUQ/JA3DpCM7xj4X0jPsAVh8A2KFN6atp7Z4Z4+mkeEylGhHWynO6p4Pl4E93oGPAK8MXVo+GTdZ4L/Ca6TF1j4M37//3rDTlMPbLmX76CGIzrSKb53AdQo3+cq8QMCVEuIlRix0zOkswGupugacqCcf9gsru9nBZLN1q/+koOzliRipxQTZ3fxLwMNLjqEkPhlufEMwC0rWgKrd/pwB39ZN6MFUUowouk42Wqj4bzclkJz2YjBHnNt7fUuKoJn2qmHHAL86baowD+qCWg3lblbWuXh0cYBhZHtB4pml/jocqedu9g07bKwY7x5yb/aVmLCo/tOMHHQVsn1d1ZloF3sPhHRpw9wSsZA+9ua1aDrQONs9rqXw1IKOKUMnJ9EmKCnakhtcctSqh3LWPrg/FgQqyrxnBUOp7rRz3o4tIXTRtRSpuNLtdG+O7R2YLn3jAgTdyuHGSEgaW61FWGC2NO1Z4j7sVfnL04NP96NhKn3ZnbCw6IdJzuT/X0eIIPIWONqosfc42NNncXJlxUBQp52oMjQQIL3xo3nPwWhWRfZLN1EfAn6JcZM1fvShRi3Ri3t6l0HozR2FWUYVLo/KV4Ko3sO5MdB8DqnlFQeoM4Fm9VXdoQcZHz/C4A4giDOlF6ga4sdjmtBj/nNrRgONR2EXONQeraCgSnmD0aksMsxqPQnSxgAx33bSGExO6tyrqW+xjkthIyWTh5Ac2ABNhBz+GbUPDLZV7RV0Ep66iMxwyWvkxhIWove5V7UZGXngymOfgCNmlh3oBRbZGUwI7WAmz2H/gFCAAuCk+kWL5cdpzydp0s4Z3GcqPTwxK0Ke12Yd1WQD9rvmKF9LUOjtXiOi96mjVq9O4GpNjah8a3960eT9vNx36h59n3TKCRNzRgU8AAgkyyaL6+bjuG9Hpmyn6HHvnvD0gvxd3HD3qGk8z2qve/6YVjseErKupwmhJIT0ti4C0wH29imaO2IjwETFgbg9yR6rCRsbREn6Q/0aEMHSPR3AHzpUjWA1c/dJGAvWaeTuM2Tm32xXnisxNbnRT5n15VIVIPEx2HqN8UJd+HdB8wJJBYv/rHl7PHbbIlTPZwZqzuU/4BHpx3DTcgiu7tDhqf2iruVPoIem2GcNujfzozmxWwc/jkSRGBHebkRYzPvi7wuwlsx7Z6DZH19dMoJNpZ1xg6AnRNNAOKMUILY2gQ1a0lIwWcgHA4db78HYd/dScgC09urRjuG+C5Vj9dS9qqxmssdHs/KyNyKaKUaZxze4YRgmzDZ3xiDjy9DG//KMpH5oHr41iW7I7rar4EUSkhjmkJsH0b6tLOBoj4CdFswHDIfZkBHNkPAJnVNinnnibx8oZycqCNI8yUhTpLbAbvnRwvJfAQ/Ro0rTwKdIt/j2D4Xq8TDvi97GRzHMlbjqAsdVKuMxCmBF5M999Qi1WwgmPeR4ignIUe8d39imWrDhv9cZMcNzPYxVsfmQ8eEZYmSLaSUvKflABMx6zqOdxL6Ofx3HHFnvdyGG/YpRoRbZ1G4C4ksDMtjVuMLYxXDPqWBIp7dhdDZ3cUGlwH72aYsf7GhbRfTimww/HbVoe3314OrstzHfLmw3z3Xhv4HraI+ZCxOfHkHF6LW9Jxq14csDfhdXx9CCJHE9bmByFPrRmsvu8PRIIJiRbV3HnZX5mFdzqvZoFjxFI2X+ipbnM5M1rjmj3FcXpx7EY1Q0j2GsZXTm7YL3XGi1/77rWbHYAvkNtFtE0K6qwkW/279QlDynoHdr3V+JXuCGArLqBEnV/TK7vmOGQ1s9tV7gzO4FlRrAii8hub0TCX8f0N8Rjt6HM5XhKJm8G26+mjv4eT/3RvUn5lCBmbNw9/RApN5DcZQ7vxJFlT2EPbMv3Z4sZMLYMt+riWJOpKCBa8/f9MU7eYSU7QvOWy9tftCoI2vKz/DNmgYy4aG/GqRuYdyiIusvMGLeDVWwiMtZH4K+BX0WqYw8qRAAepSMRsEzd51nk5dOEqSgiCfQ0V2kXCyHxVIj1ZYDWijKoOMXYK9yHaiUTGGWmqjY2J5mWcmQFky0r+ZpZ9s1dpTqyy7mAV+tmu/yEeXgjkrn8+JbMMeYZgb1VOoGMZG2jzfY9NuWlHaK66HKgJ60SvKozCSAjX8mfgSvzxUev6pFGsrLXyAeQGqihke7ar8jMKkS6rrqjohJAZM6iXuyz4LoLuTjLiJ2ph8Jxlcz7smRgr3vSIyMReP//AMbcfwmNPZQ4AAAAAElFTkSuQmCC"})},5886:(e,t,n)=>{n.d(t,{$1S:()=>no,$20:()=>uo,$5m:()=>Tc,$9U:()=>Ho,$GU:()=>qt,$NS:()=>xo,$S4:()=>Lt,$VS:()=>f,$_W:()=>lo,$kA:()=>dc,$s3:()=>le,$yO:()=>yu,ABF:()=>j_,ABd:()=>Ke,ADN:()=>Ht,AP$:()=>fu,ASL:()=>No,ATe:()=>za,Ajb:()=>ji,AuF:()=>jt,B9H:()=>te,BFJ:()=>Fa,BJP:()=>Eu,Bbv:()=>o,Bby:()=>Al,BhK:()=>vl,Bm9:()=>Sn,Bu$:()=>en,C$$:()=>jo,C0M:()=>Us,C3$:()=>ie,CQ$:()=>ql,Cmt:()=>i_,Cqp:()=>Qi,Crs:()=>Va,Ct4:()=>de,CvS:()=>yi,D$P:()=>qo,D0Q:()=>ii,D0T:()=>Sc,DCt:()=>Te,DId:()=>Y,DJB:()=>bl,DZo:()=>ma,Dd_:()=>ol,Dgu:()=>We,DiI:()=>B,DlF:()=>xu,DmK:()=>Dc,DvS:()=>Ar,E2B:()=>ja,EFD:()=>J_,EJp:()=>Xn,EKx:()=>it,EPb:()=>Oe,ERv:()=>mc,EXU:()=>on,EgH:()=>X,Ej$:()=>_c,Ekz:()=>Rl,EoG:()=>$e,Eod:()=>Qn,EpB:()=>bt,Esg:()=>I,Euh:()=>jn,Ezs:()=>Ha,F28:()=>kl,F2H:()=>d_,FFn:()=>ys,FQ_:()=>ti,FVz:()=>rl,FZT:()=>W_,Fpk:()=>me,G3$:()=>oo,G6D:()=>yc,G9S:()=>sc,G9d:()=>so,GBD:()=>ar,GKA:()=>r,GN:()=>D,GRZ:()=>K_,GUp:()=>Be,GZ4:()=>St,GbE:()=>Hi,GbL:()=>er,GcC:()=>Vt,GgK:()=>mt,GiW:()=>t_,GrH:()=>w_,GuE:()=>wn,GwV:()=>$s,H0Y:()=>f_,H0Z:()=>we,H5b:()=>Hc,HAV:()=>Kc,HAd:()=>Vs,HBF:()=>gs,HCV:()=>Wl,HX7:()=>P,HXT:()=>ai,H_C:()=>Su,Hd_:()=>nn,HgV:()=>pr,Hmk:()=>se,I7V:()=>vu,IBr:()=>$c,ICk:()=>In,ICq:()=>q,IFQ:()=>oi,ILo:()=>Gl,IRf:()=>xr,IUR:()=>Se,IWn:()=>Tt,IZB:()=>mn,Iro:()=>Ya,J6D:()=>Ja,JAL:()=>Rt,JE7:()=>Cn,JHM:()=>xi,JKl:()=>bo,JMu:()=>Ac,JRB:()=>ra,JR_:()=>m,JU7:()=>cs,JaO:()=>et,Jh8:()=>G_,JoP:()=>Kl,JqV:()=>ue,K07:()=>dl,KLy:()=>mi,KW4:()=>Oc,KW8:()=>Zo,Kbv:()=>bn,Kff:()=>p_,Krh:()=>Cs,L2q:()=>Hn,LBe:()=>At,LBv:()=>fe,LKE:()=>du,LLr:()=>Fe,LLx:()=>E_,LS0:()=>E,LT:()=>_a,LTm:()=>$n,LWw:()=>gr,La2:()=>dn,Lmi:()=>wu,LnC:()=>Bt,Lp7:()=>gt,Luz:()=>xc,LvL:()=>y,MEG:()=>ht,MLb:()=>Ps,MUv:()=>U_,MXJ:()=>wl,Mtk:()=>Nu,N21:()=>Me,N65:()=>hr,NFn:()=>eo,NHQ:()=>na,NI$:()=>Ea,NLr:()=>ao,NMz:()=>ho,NOS:()=>Qa,NPM:()=>Ko,NTE:()=>ka,NVQ:()=>li,Na_:()=>K,Nb9:()=>p,Nqf:()=>ro,Nrn:()=>po,Nsx:()=>Ci,NtV:()=>lr,Nxr:()=>yo,O$t:()=>Oi,O25:()=>Mt,O5B:()=>at,O6V:()=>$r,OQr:()=>Pc,ORN:()=>ts,ORZ:()=>ir,OX6:()=>tu,OdY:()=>Ii,P5b:()=>gc,P72:()=>uu,P8g:()=>Di,P9j:()=>V_,PE4:()=>rc,PGi:()=>Rc,PMe:()=>js,PSb:()=>$i,PZV:()=>Si,P_R:()=>Bn,Pa4:()=>B_,PtF:()=>un,PxH:()=>r_,Q6N:()=>oc,QIY:()=>X_,QOu:()=>D_,QYl:()=>Da,Qcv:()=>Oa,Qmb:()=>Vi,R0s:()=>Ze,R89:()=>M_,R9X:()=>sa,RBY:()=>Et,RCl:()=>h,RD:()=>C_,RF4:()=>Uo,RF7:()=>ss,RHW:()=>Ti,RM:()=>Jc,RMO:()=>G,RUH:()=>R_,RUg:()=>_s,Rmj:()=>kc,Rpj:()=>Ec,RyF:()=>g_,Ryb:()=>fi,S1f:()=>yr,SI2:()=>$l,SIq:()=>lc,SO0:()=>__,SRI:()=>Lo,SSH:()=>Ys,SS_:()=>c,SWC:()=>O_,SX:()=>Vl,S_d:()=>Q_,Sei:()=>jc,T41:()=>di,T57:()=>v_,T5b:()=>Mc,T5f:()=>Wo,T6I:()=>Wc,T7M:()=>To,T9W:()=>ps,TLR:()=>oe,TS8:()=>hl,TWN:()=>Pl,TYA:()=>Ce,TZR:()=>fc,TjR:()=>_e,Tj_:()=>gi,Ts0:()=>Hl,U$E:()=>go,U5A:()=>mo,U82:()=>cl,U8R:()=>ta,URV:()=>co,UY2:()=>ea,UZ0:()=>A,UbO:()=>Ei,UeU:()=>re,UhB:()=>to,Uhp:()=>xs,UjW:()=>Jo,UnF:()=>io,UoN:()=>fo,UuR:()=>vo,VB6:()=>qe,VEW:()=>vi,VFj:()=>ye,VI9:()=>jr,VOb:()=>Jr,VYc:()=>fa,VbN:()=>An,Vds:()=>fl,Vex:()=>Re,VgI:()=>dt,VgQ:()=>pc,Vn9:()=>Yi,VnX:()=>es,VvC:()=>$t,VwS:()=>Dn,VyP:()=>Pt,W1C:()=>us,W5v:()=>hs,W8X:()=>zn,WAf:()=>s_,WKI:()=>Qc,WY$:()=>y_,WaA:()=>Bi,WcB:()=>ae,Wh$:()=>Sa,Ws5:()=>Gi,X34:()=>Ni,X3l:()=>ct,X6K:()=>It,XF9:()=>C,XGp:()=>Ve,XPd:()=>dr,XR4:()=>qr,XTL:()=>Ul,XUN:()=>wr,XWT:()=>Cu,XXU:()=>$a,X_L:()=>ua,Xhg:()=>ve,XsZ:()=>ac,Xw_:()=>Ai,Y1B:()=>ut,Y3K:()=>al,Y3t:()=>Pn,Y6T:()=>c_,YDq:()=>Ua,YF_:()=>w,YKR:()=>s,YRY:()=>m_,YVc:()=>Rr,YbW:()=>Ks,Ybf:()=>as,YhR:()=>ba,Yhj:()=>ls,Yjk:()=>il,YrJ:()=>Zi,Yt2:()=>Ga,Z2n:()=>Ui,Z4f:()=>De,ZB:()=>Ss,ZR9:()=>zl,ZRC:()=>pl,ZSk:()=>Ao,ZTl:()=>Za,ZUo:()=>Ur,ZZz:()=>Xc,ZnS:()=>Bo,Zp7:()=>Ji,Zwe:()=>Rn,ZyF:()=>uc,Zzs:()=>Ba,_4j:()=>Je,_SQ:()=>Eo,_Vk:()=>J,_dw:()=>je,_j2:()=>Pe,_pd:()=>F,_sq:()=>l,_wJ:()=>Js,_wv:()=>H,_zN:()=>rs,a21:()=>pe,a2U:()=>Nr,a3f:()=>hu,aEz:()=>Mn,aGx:()=>Yr,aHb:()=>k_,aNE:()=>U,aT3:()=>ft,aT8:()=>Qo,aXg:()=>Vc,a_J:()=>T_,ahp:()=>Ae,aiV:()=>Ri,al5:()=>x_,all:()=>pa,apK:()=>Pr,aqx:()=>Bl,ark:()=>Xl,arp:()=>Zr,at_:()=>wc,b2G:()=>Tl,b4e:()=>ha,b6I:()=>q_,b74:()=>Gc,bAr:()=>or,bB_:()=>Pu,bD6:()=>Ee,bFC:()=>Fi,bWC:()=>xl,bXV:()=>Rs,c6j:()=>yt,cAE:()=>u_,cB$:()=>ze,cHm:()=>Ye,c_q:()=>ca,cbo:()=>Ta,cjV:()=>Ra,cu3:()=>Ue,d5W:()=>Kt,d7Z:()=>S,d9j:()=>an,dEP:()=>aa,dHy:()=>Xs,dLg:()=>Zs,dNB:()=>Is,dPv:()=>Jl,dTz:()=>Hs,dWw:()=>is,d_T:()=>R,dg0:()=>N,doc:()=>Ru,dz0:()=>xt,dzD:()=>A_,e25:()=>Fo,eCD:()=>pi,eRy:()=>he,eSO:()=>Qr,eSj:()=>Oo,eVh:()=>Yc,ec4:()=>V,eeI:()=>Wn,eit:()=>Ts,elk:()=>Fn,enB:()=>ge,ep0:()=>I_,ery:()=>Xr,esd:()=>j,evL:()=>Ct,exC:()=>kr,fAZ:()=>pu,fCO:()=>st,fFt:()=>d,fHf:()=>Ut,fO4:()=>Qt,fb5:()=>Ws,fc1:()=>os,fr7:()=>H_,ft:()=>su,ftY:()=>Le,g05:()=>h_,g3j:()=>nr,g5j:()=>o_,gAe:()=>si,gFc:()=>_o,gIl:()=>u,gQC:()=>vr,gRO:()=>Au,gSE:()=>ec,gb6:()=>ne,gbn:()=>Mi,gcL:()=>Tn,gdC:()=>_i,gfP:()=>Cl,gok:()=>Es,gxY:()=>He,h6k:()=>rr,h79:()=>vt,hBn:()=>cu,hE8:()=>zr,hFl:()=>La,hK:()=>Fr,hLS:()=>z_,hOm:()=>Xe,hQu:()=>ns,hUo:()=>Ln,hWT:()=>vn,hZy:()=>Kr,haZ:()=>k,hal:()=>ul,hcD:()=>nc,hgN:()=>Nn,hjW:()=>Mr,hv4:()=>Or,hx4:()=>$o,i6v:()=>va,i9e:()=>hc,iFy:()=>z,iQI:()=>T,iaA:()=>bu,ieh:()=>xe,igB:()=>lu,ij8:()=>Ca,iq4:()=>tl,ixJ:()=>Hr,j$I:()=>Ll,j0H:()=>wa,j0Z:()=>Co,j1H:()=>Os,j4O:()=>Tu,j4m:()=>ke,j5p:()=>mu,jNC:()=>gn,jQ:()=>$_,jRf:()=>Wa,jec:()=>F_,jo5:()=>Li,jpq:()=>xn,k5Z:()=>Iu,kAS:()=>Zl,kEk:()=>Xt,kF4:()=>x,kJW:()=>pt,kNd:()=>sr,kSd:()=>Pi,kVg:()=>ce,keo:()=>ko,kiM:()=>Nl,kqJ:()=>kn,krh:()=>Zt,kvl:()=>Ot,l$P:()=>Wr,lFD:()=>Do,lHw:()=>ei,lN4:()=>Gn,lS4:()=>b_,lTC:()=>l_,lX_:()=>Pa,l_1:()=>kt,lc5:()=>ks,ld1:()=>Sr,lj5:()=>ee,lyI:()=>bc,mBK:()=>Ic,mPm:()=>Io,mr6:()=>_n,mwi:()=>L_,n82:()=>fs,n9r:()=>S_,nAp:()=>Tr,nHc:()=>Q,nPH:()=>Qs,nXm:()=>zi,nfE:()=>M,o0M:()=>ri,o0W:()=>nl,o5C:()=>a,o9E:()=>Gt,o9f:()=>Gr,o9k:()=>Aa,oBw:()=>Br,oHg:()=>tn,oTQ:()=>_,oU0:()=>ui,ogd:()=>ur,ogh:()=>wt,ogk:()=>Vr,ok8:()=>Yl,om_:()=>Ne,omo:()=>Dr,ovX:()=>v,ovc:()=>el,owV:()=>ru,p23:()=>rt,pDF:()=>Wi,pDg:()=>sn,pGt:()=>au,pIg:()=>Ms,pWd:()=>ya,pgB:()=>qi,pjY:()=>Wt,pwz:()=>lt,q5F:()=>oa,qBr:()=>b,qCb:()=>wo,qHe:()=>cn,qLf:()=>Xo,qMS:()=>Fl,qQO:()=>Il,qS3:()=>Gs,qVF:()=>Jn,q_N:()=>Kn,qbL:()=>Nc,qn5:()=>Ro,qu3:()=>zt,quc:()=>N_,qxn:()=>Jt,r2d:()=>As,r2o:()=>fr,r4W:()=>On,r5i:()=>Ge,r7:()=>eu,r7E:()=>Fs,r96:()=>yl,rBz:()=>Ki,rJm:()=>Ia,rKV:()=>Cc,rMs:()=>Bs,rNS:()=>mr,rOH:()=>zo,rWx:()=>P_,rlz:()=>gl,s4R:()=>Na,s65:()=>Un,s6M:()=>Uc,sCC:()=>gu,sDH:()=>Ie,sHs:()=>Zc,sIe:()=>da,sIk:()=>sl,sUR:()=>_l,sWE:()=>Dl,sXl:()=>Cr,s_L:()=>Qe,spg:()=>Vn,t2z:()=>Ql,t39:()=>br,t3t:()=>ia,tB6:()=>ki,tPK:()=>Yt,tUw:()=>tr,tVl:()=>Mo,tey:()=>Po,thb:()=>a_,tnf:()=>Ns,ts6:()=>Dt,u6J:()=>ml,uB_:()=>pn,uGn:()=>Ma,uIG:()=>bi,uJz:()=>la,uPu:()=>En,uSd:()=>zc,uZd:()=>W,upx:()=>vc,uq5:()=>ds,uqn:()=>jl,uxs:()=>$,vFW:()=>L,vMg:()=>qa,vUx:()=>Lr,vjF:()=>n_,vt6:()=>rn,vuU:()=>hi,w16:()=>ot,w2T:()=>Nt,w5x:()=>vs,w6b:()=>qc,w9:()=>Xi,wJN:()=>ic,wJx:()=>O,wKb:()=>Ml,wQM:()=>bs,wV$:()=>_t,wV_:()=>_r,wWS:()=>qs,wez:()=>tc,wfs:()=>Ir,wg3:()=>iu,wil:()=>So,wmj:()=>Ft,x$4:()=>zs,x75:()=>ni,xD:()=>xa,xG3:()=>Ka,xI7:()=>tt,xJL:()=>yn,xM1:()=>qn,xME:()=>ws,xNp:()=>Bc,xOe:()=>Z_,xS5:()=>Yn,xTJ:()=>ln,xZA:()=>ms,xag:()=>ga,xe8:()=>Fc,xfA:()=>nu,xrP:()=>Zn,xs6:()=>i,y4x:()=>ou,y6O:()=>Z,yAt:()=>Ls,yI2:()=>Ds,yKc:()=>El,ybN:()=>Go,ynL:()=>nt,ynU:()=>_u,yoA:()=>hn,yqV:()=>Vo,yvk:()=>cc,yyQ:()=>Lc,yzJ:()=>Sl,z3$:()=>Ol,zJ6:()=>e_,zLE:()=>Yo,zT4:()=>Xa,zVs:()=>cr,zWr:()=>Y_,zc7:()=>ci,zcS:()=>fn,zdb:()=>g,zfP:()=>Er,zgu:()=>ll,zlu:()=>wi,zqI:()=>be});const o=256,a=1024,i=16384,r=0,s=1,l=2,c=3,_=4,u=5,f=6,d=0,h=1,m=768,p=769,v=770,x=771,g=772,y=773,b=774,I=775,A=776,E=32769,S=32770,T=32771,w=32772,C=32774,R=32778,P=32779,N=32777,M=32777,D=34877,F=32968,B=32969,L=32970,V=32971,z=32773,G=34964,O=34965,U=2849,k=33901,W=33902,Q=2885,q=2886,X=2928,H=2930,j=2931,Y=2932,K=2961,Z=2962,J=2964,$=2965,ee=2966,te=2967,ne=2963,oe=2968,ae=34816,ie=34817,re=34818,se=34819,le=36003,ce=36004,_e=36005,ue=2978,fe=3088,de=3106,he=3107,me=3317,pe=3333,ve=3379,xe=3386,ge=3408,ye=3410,be=3411,Ie=3412,Ae=3413,Ee=3414,Se=3415,Te=10752,we=32824,Ce=32873,Re=32936,Pe=32937,Ne=32938,Me=32939,De=34467,Fe=7936,Be=7937,Le=7938,Ve=35738,ze=35739,Ge=37444,Oe=35044,Ue=35040,ke=35048,We=34962,Qe=34963,qe=34660,Xe=34661,He=34342,je=34338,Ye=34339,Ke=34340,Ze=34341,Je=34922,$e=34373,et=34975,tt=2884,nt=1028,ot=1029,at=1032,it=3042,rt=2929,st=3024,lt=32823,ct=32926,_t=32928,ut=3089,ft=2960,dt=0,ht=1280,mt=1281,pt=1282,vt=1285,xt=37442,gt=2304,yt=2305,bt=4352,It=4353,At=4354,Et=33170,St=5120,Tt=5121,wt=5122,Ct=5123,Rt=5124,Pt=5125,Nt=5126,Mt=6402,Dt=6406,Ft=6407,Bt=6408,Lt=6409,Vt=6410,zt=5121,Gt=32819,Ot=32820,Ut=33635,kt=35632,Wt=35633,Qt=35713,qt=35712,Xt=35714,Ht=35715,jt=35717,Yt=35721,Kt=35718,Zt=34921,Jt=36347,$t=36348,en=35661,tn=35660,nn=34930,on=36349,an=35663,rn=35724,sn=35725,ln=512,cn=519,_n=513,un=514,fn=515,dn=516,hn=518,mn=517,pn=7680,vn=7681,xn=7682,gn=7683,yn=5386,bn=34055,In=34056,An=9728,En=9729,Sn=9984,Tn=9985,wn=9986,Cn=9987,Rn=10240,Pn=10241,Nn=10242,Mn=10243,Dn=3553,Fn=5890,Bn=34067,Ln=34068,Vn=34069,zn=34070,Gn=34071,On=34072,Un=34073,kn=34074,Wn=34076,Qn=33984,qn=33985,Xn=33986,Hn=33987,jn=33988,Yn=33989,Kn=33990,Zn=33991,Jn=33992,$n=33993,eo=33994,to=33995,no=33996,oo=33997,ao=33998,io=33999,ro=34e3,so=34001,lo=34002,co=34003,_o=34004,uo=34005,fo=34006,ho=34007,mo=34008,po=34009,vo=34010,xo=34011,go=34012,yo=34013,bo=34014,Io=34015,Ao=34016,Eo=10497,So=33071,To=33648,wo=35664,Co=35665,Ro=35666,Po=35667,No=35668,Mo=35669,Do=35670,Fo=35671,Bo=35672,Lo=35673,Vo=35674,zo=35675,Go=35676,Oo=35678,Uo=35680,ko=36336,Wo=36337,Qo=36338,qo=36339,Xo=36340,Ho=36341,jo=36160,Yo=36161,Ko=32854,Zo=32855,Jo=36194,$o=33189,ea=6401,ta=36168,na=34041,oa=36162,aa=36163,ia=36164,ra=36176,sa=36177,la=36178,ca=36179,_a=36180,ua=36181,fa=36048,da=36049,ha=36050,ma=36051,pa=36064,va=36096,xa=36128,ga=33306,ya=0,ba=36053,Ia=36054,Aa=36055,Ea=36057,Sa=36061,Ta=36006,wa=36007,Ca=34024,Ra=1286,Pa=37440,Na=37441,Ma=37443,Da=3074,Fa=3314,Ba=3315,La=3316,Va=3330,za=3331,Ga=3332,Oa=32874,Ua=32877,ka=32878,Wa=32883,Qa=33e3,qa=33001,Xa=34045,Ha=35657,ja=35658,Ya=35071,Ka=35076,Za=35077,Ja=35659,$a=35723,ei=35977,ti=34229,ni=37154,oi=37157,ai=37137,ii=36203,ri=6403,si=32849,li=32856,ci=32857,_i=32879,ui=32882,fi=33082,di=33083,hi=33084,mi=33085,pi=34892,vi=34893,xi=35904,gi=35905,yi=35907,bi=34894,Ii=34836,Ai=34837,Ei=34842,Si=34843,Ti=35866,wi=35869,Ci=35898,Ri=35901,Pi=36208,Ni=36209,Mi=36214,Di=36215,Fi=36220,Bi=36221,Li=36226,Vi=36227,zi=36232,Gi=36233,Oi=36238,Ui=36239,ki=36244,Wi=36248,Qi=36249,qi=33321,Xi=33323,Hi=33325,ji=33326,Yi=33327,Ki=33328,Zi=33329,Ji=33330,$i=33331,er=33332,tr=33333,nr=33334,or=33335,ar=33336,ir=33337,rr=33338,sr=33339,lr=33340,cr=36756,_r=36757,ur=36758,fr=36759,dr=36975,hr=37167,mr=33503,pr=33640,vr=35899,xr=35902,gr=36269,yr=34042,br=5131,Ir=33319,Ar=33320,Er=36255,Sr=34917,Tr=34918,wr=34919,Cr=35887,Rr=36202,Pr=34852,Nr=34853,Mr=34854,Dr=34855,Fr=34856,Br=34857,Lr=34858,Vr=34859,zr=34860,Gr=34861,Or=34862,Ur=34863,kr=34864,Wr=34865,Qr=34866,qr=34867,Xr=34868,Hr=36063,jr=36065,Yr=36066,Kr=36067,Zr=36068,Jr=36069,$r=36070,es=36071,ts=36072,ns=36073,os=36074,as=36075,is=36076,rs=36077,ss=36078,ls=36079,cs=35679,_s=35682,us=36289,fs=36292,ds=36293,hs=36298,ms=36299,ps=36300,vs=36303,xs=36306,gs=36307,ys=36308,bs=36311,Is=36183,As=35097,Es=35051,Ss=35052,Ts=35053,ws=35055,Cs=36662,Rs=36663,Ps=36662,Ns=36663,Ms=35685,Ds=35686,Fs=35687,Bs=35688,Ls=35689,Vs=35690,zs=36294,Gs=36295,Os=36296,Us=35863,ks=36764,Ws=35069,Qs=35070,qs=35967,Xs=35968,Hs=35971,js=35972,Ys=35973,Ks=35976,Zs=35978,Js=35979,$s=35980,el=35981,tl=35982,nl=35983,ol=36386,al=36387,il=36388,rl=36389,sl=33296,ll=33297,cl=33298,_l=33299,ul=33300,fl=33301,dl=33302,hl=33303,ml=33304,pl=35056,vl=36006,xl=36008,gl=36009,yl=36010,bl=36011,Il=36052,Al=36182,El=35345,Sl=35368,Tl=35369,wl=35370,Cl=35371,Rl=35373,Pl=35374,Nl=35375,Ml=35376,Dl=35377,Fl=35379,Bl=35380,Ll=35382,Vl=35383,zl=35384,Gl=35386,Ol=35387,Ul=35388,kl=35389,Wl=35390,Ql=35391,ql=35392,Xl=35394,Hl=35395,jl=35396,Yl=35398,Kl=37138,Zl=37139,Jl=37140,$l=37141,ec=37142,tc=37143,nc=37144,oc=37145,ac=37146,ic=37147,rc=37148,sc=37149,lc=1,cc=6144,_c=6145,uc=6146,fc=32775,dc=32776,hc=33190,mc=35041,pc=35042,vc=35045,xc=35046,gc=35049,yc=35050,bc=36012,Ic=36013,Ac=4294967295,Ec=-1,Sc=37447,Tc=35070,wc=37445,Cc=37446,Rc=34047,Pc=34046,Nc=33776,Mc=33777,Dc=33778,Fc=33779,Bc=35916,Lc=35917,Vc=35918,zc=35919,Gc=37488,Oc=37489,Uc=37490,kc=37491,Wc=37492,Qc=37493,qc=37494,Xc=37495,Hc=37496,jc=37497,Yc=35840,Kc=35842,Zc=35841,Jc=35843,$c=36196,e_=35986,t_=35986,n_=34798,o_=37808,a_=37809,i_=37810,r_=37811,s_=37812,l_=37813,c_=37814,__=37815,u_=37816,f_=37817,d_=37818,h_=37819,m_=37820,p_=37821,v_=37840,x_=37841,g_=37842,y_=37843,b_=37844,I_=37845,A_=37846,E_=37847,S_=37848,T_=37849,w_=37850,C_=37851,R_=37852,P_=37853,N_=34042,M_=36193,D_=34836,F_=34837,B_=33297,L_=35863,V_=32775,z_=32776,G_=35904,O_=35906,U_=35907,k_=33296,W_=35723,Q_=36064,q_=36065,X_=36066,H_=36067,j_=36068,Y_=36069,K_=36070,Z_=36071,J_=36072,$_=36073,eu=36074,tu=36075,nu=36076,ou=36077,au=36078,iu=36079,ru=34853,su=34854,lu=34855,cu=34856,_u=34857,uu=34858,fu=34859,du=34860,hu=34861,mu=34862,pu=34863,vu=34864,xu=34865,gu=34866,yu=34867,bu=34868,Iu=36063,Au=34852,Eu=34229,Su=34916,Tu=34917,wu=34918,Cu=34919,Ru=35007,Pu=36392,Nu=36795},3923:(e,t,n)=>{n.d(t,{V:()=>a,q:()=>o});const o="gltf_node_index";function a(e,t){return e.magFilter===t.magFilter&&e.minFilter===t.minFilter&&e.wrapS===t.wrapS&&e.wrapT===t.wrapT}},2238:(e,t,n)=>{n.d(t,{tPK:()=>r.tPK,ZSk:()=>r.ZSk,d5W:()=>r.d5W,j$I:()=>r.j$I,uZd:()=>r.uZd,haZ:()=>r.haZ,ts6:()=>r.ts6,ahp:()=>r.ahp,XsZ:()=>r.XsZ,qHe:()=>r.qHe,sXl:()=>r.sXl,YVc:()=>r.YVc,Dgu:()=>r.Dgu,RMO:()=>r.RMO,AuF:()=>r.AuF,w16:()=>r.w16,EKx:()=>r.EKx,iFy:()=>r.iFy,vFW:()=>r.vFW,_pd:()=>r._pd,dg0:()=>r.dg0,GN:()=>r.GN,nfE:()=>r.nfE,ec4:()=>r.ec4,DiI:()=>r.DiI,sDH:()=>r.sDH,lFD:()=>r.lFD,e25:()=>r.e25,ZnS:()=>r.ZnS,SRI:()=>r.SRI,r5i:()=>r.r5i,VB6:()=>r.VB6,hOm:()=>r.hOm,c6j:()=>r.c6j,wil:()=>r.wil,yvk:()=>r.yvk,all:()=>r.all,S_d:()=>r.S_d,VI9:()=>r.VI9,fc1:()=>r.fc1,r7:()=>r.r7,Ybf:()=>r.Ybf,OX6:()=>r.OX6,dWw:()=>r.dWw,xfA:()=>r.xfA,_zN:()=>r._zN,y4x:()=>r.y4x,RF7:()=>r.RF7,pGt:()=>r.pGt,Yhj:()=>r.Yhj,wg3:()=>r.wg3,b6I:()=>r.b6I,aGx:()=>r.aGx,QIY:()=>r.QIY,hZy:()=>r.hZy,fr7:()=>r.fr7,arp:()=>r.arp,ABF:()=>r.ABF,VOb:()=>r.VOb,zWr:()=>r.zWr,O6V:()=>r.O6V,GRZ:()=>r.GRZ,VnX:()=>r.VnX,xOe:()=>r.xOe,ORN:()=>r.ORN,EFD:()=>r.EFD,hQu:()=>r.hQu,jQ:()=>r.jQ,xs6:()=>r.xs6,Ct4:()=>r.Ct4,eRy:()=>r.eRy,uIG:()=>r.uIG,fO4:()=>r.fO4,b74:()=>r.b74,s6M:()=>r.s6M,T6I:()=>r.T6I,H5b:()=>r.H5b,WKI:()=>r.WKI,g05:()=>r.g05,cAE:()=>r.cAE,H0Y:()=>r.H0Y,F2H:()=>r.F2H,YRY:()=>r.YRY,Kff:()=>r.Kff,g5j:()=>r.g5j,thb:()=>r.thb,Cmt:()=>r.Cmt,PxH:()=>r.PxH,WAf:()=>r.WAf,lTC:()=>r.lTC,Y6T:()=>r.Y6T,SO0:()=>r.SO0,GiW:()=>r.GiW,vjF:()=>r.vjF,RM:()=>r.RM,HAV:()=>r.HAV,T5b:()=>r.T5b,DmK:()=>r.DmK,xe8:()=>r.xe8,zJ6:()=>r.zJ6,IBr:()=>r.IBr,sHs:()=>r.sHs,eVh:()=>r.eVh,qbL:()=>r.qbL,KW4:()=>r.KW4,Rmj:()=>r.Rmj,RD:()=>r.RD,n9r:()=>r.n9r,a_J:()=>r.a_J,GrH:()=>r.GrH,RUH:()=>r.RUH,rWx:()=>r.rWx,T57:()=>r.T57,al5:()=>r.al5,RyF:()=>r.RyF,WY$:()=>r.WY$,lS4:()=>r.lS4,ep0:()=>r.ep0,dzD:()=>r.dzD,LLx:()=>r.LLx,ZZz:()=>r.ZZz,w6b:()=>r.w6b,Sei:()=>r.Sei,yyQ:()=>r.yyQ,aXg:()=>r.aXg,uSd:()=>r.uSd,xNp:()=>r.xNp,Z4f:()=>r.Z4f,PE4:()=>r.PE4,iQI:()=>r.iQI,LS0:()=>r.LS0,dz0:()=>r.dz0,Krh:()=>r.Krh,MLb:()=>r.MLb,bXV:()=>r.bXV,tnf:()=>r.tnf,xI7:()=>r.xI7,nHc:()=>r.nHc,pDg:()=>r.pDg,ld1:()=>r.ld1,j4O:()=>r.j4O,gxY:()=>r.gxY,Lp7:()=>r.Lp7,GZ4:()=>r.GZ4,w2T:()=>r.w2T,JAL:()=>r.JAL,ogh:()=>r.ogh,IWn:()=>r.IWn,VyP:()=>r.VyP,evL:()=>r.evL,jNC:()=>r.jNC,ICk:()=>r.ICk,$GU:()=>r.$GU,Ej$:()=>r.Ej$,ZRC:()=>r.ZRC,mBK:()=>r.mBK,i6v:()=>r.i6v,bD6:()=>r.bD6,Bbv:()=>r.Bbv,esd:()=>r.esd,O25:()=>r.O25,hx4:()=>r.hx4,i9e:()=>r.i9e,lyI:()=>r.lyI,DId:()=>r.DId,EgH:()=>r.EgH,NHQ:()=>r.NHQ,xag:()=>r.xag,p23:()=>r.p23,_wv:()=>r._wv,fCO:()=>r.fCO,EpB:()=>r.EpB,a2U:()=>r.a2U,owV:()=>r.owV,hjW:()=>r.hjW,ZUo:()=>r.ZUo,fAZ:()=>r.fAZ,exC:()=>r.exC,I7V:()=>r.I7V,l$P:()=>r.l$P,DlF:()=>r.DlF,eSO:()=>r.eSO,sCC:()=>r.sCC,XR4:()=>r.XR4,$yO:()=>r.$yO,ery:()=>r.ery,iaA:()=>r.iaA,ft:()=>r.ft,omo:()=>r.omo,igB:()=>r.igB,hK:()=>r.hK,hBn:()=>r.hBn,oBw:()=>r.oBw,ynU:()=>r.ynU,vUx:()=>r.vUx,P72:()=>r.P72,ogk:()=>r.ogk,AP$:()=>r.AP$,hE8:()=>r.hE8,LKE:()=>r.LKE,o9f:()=>r.o9f,a3f:()=>r.a3f,hv4:()=>r.hv4,j5p:()=>r.j5p,rlz:()=>r.rlz,BhK:()=>r.BhK,zdb:()=>r.zdb,qBr:()=>r.qBr,G6D:()=>r.G6D,j4m:()=>r.j4m,P5b:()=>r.P5b,s_L:()=>r.s_L,wJx:()=>r.wJx,PtF:()=>r.PtF,X6K:()=>r.X6K,LWw:()=>r.LWw,yqV:()=>r.yqV,pIg:()=>r.pIg,yI2:()=>r.yI2,rOH:()=>r.rOH,r7E:()=>r.r7E,rMs:()=>r.rMs,ybN:()=>r.ybN,yAt:()=>r.yAt,HAd:()=>r.HAd,qCb:()=>r.qCb,j0Z:()=>r.j0Z,qn5:()=>r.qn5,l_1:()=>r.l_1,XXU:()=>r.XXU,FZT:()=>r.FZT,C$$:()=>r.C$$,Vds:()=>r.Vds,hal:()=>r.hal,sIk:()=>r.sIk,aHb:()=>r.aHb,zgu:()=>r.zgu,Pa4:()=>r.Pa4,K07:()=>r.K07,sUR:()=>r.sUR,sIe:()=>r.sIe,VYc:()=>r.VYc,U82:()=>r.U82,TS8:()=>r.TS8,DZo:()=>r.DZo,qQO:()=>r.qQO,b4e:()=>r.b4e,cbo:()=>r.cbo,YhR:()=>r.YhR,u6J:()=>r.u6J,rJm:()=>r.rJm,NI$:()=>r.NI$,o9k:()=>r.o9k,Bby:()=>r.Bby,Wh$:()=>r.Wh$,ynL:()=>r.ynL,O5B:()=>r.O5B,ICq:()=>r.ICq,XF9:()=>r.XF9,HX7:()=>r.HX7,d_T:()=>r.d_T,RBY:()=>r.RBY,yoA:()=>r.yoA,Mtk:()=>r.Mtk,La2:()=>r.La2,zqI:()=>r.zqI,t39:()=>r.t39,R89:()=>r.R89,aT8:()=>r.aT8,$9U:()=>r.$9U,cB$:()=>r.cB$,XGp:()=>r.XGp,jpq:()=>r.jpq,Kbv:()=>r.Kbv,GwV:()=>r.GwV,zfP:()=>r.zfP,W5v:()=>r.W5v,w5x:()=>r.w5x,xZA:()=>r.xZA,T9W:()=>r.T9W,tey:()=>r.tey,ASL:()=>r.ASL,tVl:()=>r.tVl,MEG:()=>r.MEG,cjV:()=>r.cjV,JMu:()=>r.JMu,kJW:()=>r.kJW,GgK:()=>r.GgK,xJL:()=>r.xJL,uB_:()=>r.uB_,zcS:()=>r.zcS,mr6:()=>r.mr6,uPu:()=>r.uPu,JE7:()=>r.JE7,gcL:()=>r.gcL,YKR:()=>r.YKR,_sq:()=>r._sq,SS_:()=>r.SS_,aNE:()=>r.aNE,kEk:()=>r.kEk,keo:()=>r.keo,D$P:()=>r.D$P,$S4:()=>r.$S4,GcC:()=>r.GcC,$kA:()=>r.$kA,jRf:()=>r.jRf,Iro:()=>r.Iro,D0T:()=>r.D0T,ixJ:()=>r.ixJ,k5Z:()=>r.k5Z,qMS:()=>r.qMS,Bu$:()=>r.Bu$,TWN:()=>r.TWN,sWE:()=>r.sWE,eeI:()=>r.eeI,apK:()=>r.apK,gRO:()=>r.gRO,vMg:()=>r.vMg,NOS:()=>r.NOS,D0Q:()=>r.D0Q,hLS:()=>r.hLS,IFQ:()=>r.IFQ,Ekz:()=>r.Ekz,Ezs:()=>r.Ezs,EXU:()=>r.EXU,ZTl:()=>r.ZTl,ij8:()=>r.ij8,dNB:()=>r.dNB,HXT:()=>r.HXT,Hd_:()=>r.Hd_,zT4:()=>r.zT4,PGi:()=>r.PGi,Xhg:()=>r.Xhg,dLg:()=>r.dLg,_wJ:()=>r._wJ,dHy:()=>r.dHy,wKb:()=>r.wKb,kiM:()=>r.kiM,J6D:()=>r.J6D,VvC:()=>r.VvC,krh:()=>r.krh,x75:()=>r.x75,oHg:()=>r.oHg,gfP:()=>r.gfP,E2B:()=>r.E2B,qxn:()=>r.qxn,ieh:()=>r.ieh,T5f:()=>r.T5f,qLf:()=>r.qLf,TZR:()=>r.TZR,P9j:()=>r.P9j,xG3:()=>r.xG3,T7M:()=>r.T7M,VbN:()=>r.VbN,GuE:()=>r.GuE,Bm9:()=>r.Bm9,xTJ:()=>r.xTJ,LBe:()=>r.LBe,pWd:()=>r.pWd,IZB:()=>r.IZB,VgI:()=>r.VgI,JoP:()=>r.JoP,RCl:()=>r.RCl,YF_:()=>r.YF_,d7Z:()=>r.d7Z,LvL:()=>r.LvL,Esg:()=>r.Esg,kF4:()=>r.kF4,Nb9:()=>r.Nb9,h79:()=>r.h79,a21:()=>r.a21,Crs:()=>r.Crs,Yt2:()=>r.Yt2,ATe:()=>r.ATe,gok:()=>r.gok,eit:()=>r.eit,ZB:()=>r.ZB,xME:()=>r.xME,qu3:()=>r.qu3,o9E:()=>r.o9E,kvl:()=>r.kvl,fHf:()=>r.fHf,GKA:()=>r.GKA,H0Z:()=>r.H0Z,pwz:()=>r.pwz,DCt:()=>r.DCt,H_C:()=>r.H_C,nAp:()=>r.nAp,XUN:()=>r.XUN,XWT:()=>r.XWT,Lmi:()=>r.Lmi,Nsx:()=>r.Nsx,GbE:()=>r.GbE,PSb:()=>r.PSb,GbL:()=>r.GbL,Ajb:()=>r.Ajb,tUw:()=>r.tUw,g3j:()=>r.g3j,pgB:()=>r.pgB,YrJ:()=>r.YrJ,Zp7:()=>r.Zp7,zVs:()=>r.zVs,lHw:()=>r.lHw,QYl:()=>r.QYl,bWC:()=>r.bWC,r96:()=>r.r96,o0M:()=>r.o0M,VFj:()=>r.VFj,tB6:()=>r.tB6,zLE:()=>r.zLE,c_q:()=>r.c_q,j0H:()=>r.j0H,uJz:()=>r.uJz,LT:()=>r.LT,R9X:()=>r.R9X,dEP:()=>r.dEP,t3t:()=>r.t3t,JRB:()=>r.JRB,DJB:()=>r.DJB,X_L:()=>r.X_L,q5F:()=>r.q5F,GUp:()=>r.GUp,_SQ:()=>r._SQ,hWT:()=>r.hWT,wfs:()=>r.wfs,Vn9:()=>r.Vn9,ORZ:()=>r.ORZ,h6k:()=>r.h6k,rBz:()=>r.rBz,kNd:()=>r.kNd,NtV:()=>r.NtV,w9:()=>r.w9,bAr:()=>r.bAr,GBD:()=>r.GBD,wV_:()=>r.wV_,wmj:()=>r.wmj,zc7:()=>r.zc7,XPd:()=>r.XPd,PZV:()=>r.PZV,Ws5:()=>r.Ws5,P8g:()=>r.P8g,Xw_:()=>r.Xw_,jec:()=>r.jec,Qmb:()=>r.Qmb,X34:()=>r.X34,UjW:()=>r.UjW,KW8:()=>r.KW8,gAe:()=>r.gAe,Z2n:()=>r.Z2n,WaA:()=>r.WaA,ogd:()=>r.ogd,aiV:()=>r.aiV,LnC:()=>r.LnC,UbO:()=>r.UbO,nXm:()=>r.nXm,gbn:()=>r.gbn,OdY:()=>r.OdY,QOu:()=>r.QOu,jo5:()=>r.jo5,kSd:()=>r.kSd,NPM:()=>r.NPM,NVQ:()=>r.NVQ,O$t:()=>r.O$t,bFC:()=>r.bFC,r2o:()=>r.r2o,Cqp:()=>r.Cqp,pDF:()=>r.pDF,DvS:()=>r.DvS,eSj:()=>r.eSj,W1C:()=>r.W1C,n82:()=>r.n82,RUg:()=>r.RUg,JU7:()=>r.JU7,r2d:()=>r.r2d,RF4:()=>r.RF4,uq5:()=>r.uq5,_j2:()=>r._j2,X3l:()=>r.X3l,Vex:()=>r.Vex,wV$:()=>r.wV$,N21:()=>r.N21,om_:()=>r.om_,LBv:()=>r.LBv,Y1B:()=>r.Y1B,ovc:()=>r.ovc,d9j:()=>r.d9j,vt6:()=>r.vt6,Q6N:()=>r.Q6N,lc5:()=>r.lc5,ovX:()=>r.ovX,UZ0:()=>r.UZ0,JR_:()=>r.JR_,JHM:()=>r.JHM,Tj_:()=>r.Tj_,CvS:()=>r.CvS,MUv:()=>r.MUv,SWC:()=>r.SWC,Jh8:()=>r.Jh8,Luz:()=>r.Luz,EPb:()=>r.EPb,upx:()=>r.upx,ZyF:()=>r.ZyF,xD:()=>r.xD,C3$:()=>r.C3$,WcB:()=>r.WcB,UeU:()=>r.UeU,Hmk:()=>r.Hmk,$s3:()=>r.$s3,kVg:()=>r.kVg,TjR:()=>r.TjR,IUR:()=>r.IUR,o5C:()=>r.o5C,Na_:()=>r.Na_,_Vk:()=>r._Vk,y6O:()=>r.y6O,UY2:()=>r.UY2,U8R:()=>r.U8R,uxs:()=>r.uxs,lj5:()=>r.lj5,B9H:()=>r.B9H,aT3:()=>r.aT3,gb6:()=>r.gb6,TLR:()=>r.TLR,VgQ:()=>r.VgQ,cu3:()=>r.cu3,ERv:()=>r.ERv,enB:()=>r.enB,kAS:()=>r.kAS,gSE:()=>r.gSE,SI2:()=>r.SI2,SIq:()=>r.SIq,wez:()=>r.wez,dPv:()=>r.dPv,elk:()=>r.elk,Eod:()=>r.Eod,xM1:()=>r.xM1,NFn:()=>r.NFn,UhB:()=>r.UhB,$1S:()=>r.$1S,G3$:()=>r.G3$,NLr:()=>r.NLr,UnF:()=>r.UnF,Nqf:()=>r.Nqf,G9d:()=>r.G9d,$_W:()=>r.$_W,URV:()=>r.URV,EJp:()=>r.EJp,gFc:()=>r.gFc,$20:()=>r.$20,UoN:()=>r.UoN,NMz:()=>r.NMz,U5A:()=>r.U5A,Nrn:()=>r.Nrn,UuR:()=>r.UuR,$NS:()=>r.$NS,U$E:()=>r.U$E,Nxr:()=>r.Nxr,L2q:()=>r.L2q,JKl:()=>r.JKl,mPm:()=>r.mPm,Euh:()=>r.Euh,xS5:()=>r.xS5,q_N:()=>r.q_N,xrP:()=>r.xrP,qVF:()=>r.qVF,LTm:()=>r.LTm,VwS:()=>r.VwS,RHW:()=>r.RHW,gdC:()=>r.gdC,vuU:()=>r.vuU,TYA:()=>r.TYA,zlu:()=>r.zlu,Qcv:()=>r.Qcv,hUo:()=>r.hUo,VEW:()=>r.VEW,eCD:()=>r.eCD,P_R:()=>r.P_R,W8X:()=>r.W8X,r4W:()=>r.r4W,kqJ:()=>r.kqJ,spg:()=>r.spg,lN4:()=>r.lN4,s65:()=>r.s65,N65:()=>r.N65,rNS:()=>r.rNS,Zwe:()=>r.Zwe,OQr:()=>r.OQr,KLy:()=>r.KLy,T41:()=>r.T41,Y3t:()=>r.Y3t,Ryb:()=>r.Ryb,oU0:()=>r.oU0,hgN:()=>r.hgN,aEz:()=>r.aEz,wJN:()=>r.wJN,Rpj:()=>r.Rpj,bB_:()=>r.bB_,doc:()=>r.doc,Dd_:()=>r.Dd_,Yjk:()=>r.Yjk,FVz:()=>r.FVz,iq4:()=>r.iq4,o0W:()=>r.o0W,wWS:()=>r.wWS,SSH:()=>r.SSH,PMe:()=>r.PMe,Y3K:()=>r.Y3K,YbW:()=>r.YbW,dTz:()=>r.dTz,oTQ:()=>r.oTQ,$VS:()=>r.$VS,gIl:()=>r.gIl,XTL:()=>r.XTL,ark:()=>r.ark,Ts0:()=>r.Ts0,t2z:()=>r.t2z,CQ$:()=>r.CQ$,ILo:()=>r.ILo,ok8:()=>r.ok8,uqn:()=>r.uqn,yKc:()=>r.yKc,yzJ:()=>r.yzJ,aqx:()=>r.aqx,MXJ:()=>r.MXJ,b2G:()=>r.b2G,HCV:()=>r.HCV,F28:()=>r.F28,z3$:()=>r.z3$,ZR9:()=>r.ZR9,SX:()=>r.SX,rKV:()=>r.rKV,at_:()=>r.at_,Fpk:()=>r.Fpk,uGn:()=>r.uGn,lX_:()=>r.lX_,NTE:()=>r.NTE,s4R:()=>r.s4R,BFJ:()=>r.BFJ,YDq:()=>r.YDq,hFl:()=>r.hFl,Zzs:()=>r.Zzs,hcD:()=>r.hcD,gQC:()=>r.gQC,S1f:()=>r.S1f,quc:()=>r.quc,HgV:()=>r.HgV,IRf:()=>r.IRf,Uhp:()=>r.Uhp,wQM:()=>r.wQM,HBF:()=>r.HBF,FFn:()=>r.FFn,x$4:()=>r.x$4,qS3:()=>r.qS3,j1H:()=>r.j1H,C0M:()=>r.C0M,mwi:()=>r.mwi,ADN:()=>r.ADN,LLr:()=>r.LLr,ftY:()=>r.ftY,FQ_:()=>r.FQ_,BJP:()=>r.BJP,JaO:()=>r.JaO,nPH:()=>r.nPH,$5m:()=>r.$5m,_dw:()=>r._dw,fb5:()=>r.fb5,_4j:()=>r._4j,EoG:()=>r.EoG,cHm:()=>r.cHm,ABd:()=>r.ABd,R0s:()=>r.R0s,pjY:()=>r.pjY,JqV:()=>r.JqV,G9S:()=>r.G9S,fFt:()=>r.fFt,q_f:()=>s.q,teG:()=>i,Vi7:()=>s.V});var o=n(7751),a=n(3497);function i(e){switch(e.className){case"Scalar":return o.h.Scalar;case"Vector2":return o.h.Vec2;case"Vector3":return o.h.Vec3;case"Vector4":return o.h.Vec4;case"Matrix22":return o.h.Mat2;case"Matrix33":return o.h.Mat3;case"Matrix44":return o.h.Mat4;default:return a.V.error("CompositionType.Unknown"),o.h.Unknown}}var r=n(5886),s=n(3923)},5672:(e,t,n)=>{n.d(t,{x:()=>o});const o=n(3600).A},7529:(e,t,n)=>{n.d(t,{u:()=>p});var o,a,i,r,s,l,c=n(3430),_=n(3414),u=n(5338),f=n(3497),d=function(e,t,n,o,a){if("m"===o)throw new TypeError("Private method is not writable");if("a"===o&&!a)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!a:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===o?a.call(e,n):a?a.value=n:t.set(e,n),n},h=function(e,t,n,o){if("a"===n&&!o)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!o:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?o:"a"===n?o.call(e):o?o.value:t.get(e)};const m=-1;class p{constructor(e,t){this.__webglVersion=1,this.width=0,this.height=0,this.__activeTextureBackup=-1,this.__activeTextures2D=[],this.__activeTextures2DArray=[],this.__activeTexturesCube=[],this.__boundTextures=new Map,this.__boundSamplers=new Map,this.__viewport_left=0,this.__viewport_top=0,this.__viewport_width=0,this.__viewport_height=0,this.__default_viewport_left=0,this.__default_viewport_top=0,this.__default_viewport_width=0,this.__default_viewport_height=0,o.set(this,m),a.set(this,m),i.set(this,m),r.set(this,m),s.set(this,m),l.set(this,m),this.__maxVertexUniformVectors=m,this.__maxFragmentUniformVectors=m,this._isWebXRMode=!1,this.__extensions=new Map,this.__gl=e,this.width=t.width,this.height=t.height,this.canvas=t,this.__viewport_width=this.__default_viewport_width=this.width,this.__viewport_height=this.__default_viewport_height=this.height,this.__is_multiview=!0,"WebGL2RenderingContext"===this.__gl.constructor.name&&(this.__webglVersion=2,this.webgl2ExtTFL=this.__getExtension(c.z.TextureFloatLinear),this.webgl2ExtTHFL=this.__getExtension(c.z.TextureHalfFloatLinear),this.webgl2ExtTFA=this.__getExtension(c.z.TextureFilterAnisotropic),this.webgl2ExtCBF=this.__getExtension(c.z.ColorBufferFloatWebGL2),this.webgl2ExtCBHF=this.__getExtension(c.z.ColorBufferHalfFloatWebGL2),this.webgl2ExtCTAstc=this.__getCompressedTextureExtension(c.z.CompressedTextureAstc),this.webgl2ExtCTS3tc=this.__getCompressedTextureExtension(c.z.CompressedTextureS3tc),this.webgl2ExtCTPvrtc=this.__getCompressedTextureExtension(c.z.CompressedTexturePvrtc),this.webgl2ExtCTAtc=this.__getCompressedTextureExtension(c.z.CompressedTextureAtc),this.webgl2ExtCTEtc=this.__getCompressedTextureExtension(c.z.CompressedTextureEtc),this.webgl2ExtCTEtc1=this.__getCompressedTextureExtension(c.z.CompressedTextureEtc1),this.webgl2ExtCTBptc=this.__getCompressedTextureExtension(c.z.CompressedTextureBptc),this.webgl2ExtMLTVIEW=this.__getExtension(c.z.OculusMultiview),this.webgl2ExtMLTVIEW?this.webgl2ExtMLTVIEW.is_multisample=!0:(this.webgl2ExtMLTVIEW=this.__getExtension(c.z.OvrMultiview2),this.webgl2ExtMLTVIEW?this.webgl2ExtMLTVIEW.is_multisample=!1:(u.T.cgApiDebugConsoleOutput&&f.V.info("OCULUS_multiview and OVR_multiview2 extensions are not supported"),this.__is_multiview=!1)),this.webgl2ExtClipCtrl=this.__getExtension(c.z.ClipControl),this.webgl2ExtGmanWM=this.__getExtension(c.z.GMAN_WEBGL_MEMORY)),this.__getUniformBufferInfo(),this.__getMaxUniformVectors()}getRawContext(){return this.__gl}getRawContextAsWebGL1(){return this.__gl}getRawContextAsWebGL2(){return this.__gl}get viewport(){return _.IU.fromCopyArray([this.__viewport_left,this.__viewport_top,this.__viewport_width,this.__viewport_height])}get defaultViewport(){return _.IU.fromCopyArray([this.__default_viewport_left,this.__default_viewport_top,this.__default_viewport_width,this.__default_viewport_height])}isSupportWebGL1Extension(e){return!!this.__getExtension(e)}isNotSupportWebGL1Extension(e){return!this.isSupportWebGL1Extension(e)}getIsWebGL2(e){return this.isWebGL2}get isWebGL2(){return 2===this.__webglVersion}createVertexArray(){return this.getIsWebGL2(this.__gl)?this.__gl.createVertexArray():null!=this.webgl1ExtVAO?this.webgl1ExtVAO.createVertexArrayOES():void 0}deleteVertexArray(e){this.getIsWebGL2(this.__gl)?this.__gl.deleteVertexArray(e):null!=this.webgl1ExtVAO&&this.webgl1ExtVAO.deleteVertexArrayOES(e)}bindVertexArray(e){this.getIsWebGL2(this.__gl)?this.__gl.bindVertexArray(e):null!=this.webgl1ExtVAO&&this.webgl1ExtVAO.bindVertexArrayOES(e)}vertexAttribDivisor(e,t){this.getIsWebGL2(this.__gl)?this.__gl.vertexAttribDivisor(e,t):this.webgl1ExtIA.vertexAttribDivisorANGLE(e,t)}drawElementsInstanced(e,t,n,o,a){this.__gl.drawElementsInstanced(e,t,n,o,a)}drawArraysInstanced(e,t,n,o){this.__gl.drawArraysInstanced(e,t,n,o)}colorAttachment(e){return 36064+e}drawBuffers(e){const t=this.__gl;if(0===e.length)return void t.drawBuffers([t.NONE]);const n=e[0].webGLConstantValue();t.drawBuffers(e.map((e=>e.webGLConstantValue()))),n===t.NONE||0===e.length?t.colorMask(!1,!1,!1,!1):t.colorMask(!0,!0,!0,!0)}__activeTexture(e){this.__activeTextureBackup!==e&&(this.__gl.activeTexture(this.__gl.TEXTURE0+e),this.__activeTextureBackup=e)}bindTexture2D(e,t){this.__boundTextures.get(e)!==t&&(this.__activeTexture(e),this.__gl.bindTexture(this.__gl.TEXTURE_2D,t),this.__boundTextures.set(e,t)),this.__activeTextures2D[e]=t}bindTexture2DArray(e,t){this.__boundTextures.get(e)!==t&&(this.__activeTexture(e),this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY,t),this.__boundTextures.set(e,t)),this.__activeTextures2DArray[e]=t}bindTextureSampler(e,t){this.__gl.bindSampler(e,t),this.__boundSamplers.set(e,t)}bindTextureCube(e,t){this.__boundTextures.get(e)!==t&&(this.__activeTexture(e),this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP,t),this.__boundTextures.set(e,t)),this.__activeTexturesCube[e]=t}unbindTexture2D(e){this.__activeTexture(e),this.__gl.bindTexture(this.__gl.TEXTURE_2D,null),this.__boundTextures.delete(e),delete this.__activeTextures2D[e]}unbindTextureCube(e){this.__activeTexture(e),this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP,null),this.__boundTextures.delete(e),delete this.__activeTexturesCube[e]}unbindTextures(){for(let e=0;e<this.__activeTextures2D.length;e++)null!=this.__activeTextures2D[e]&&(this.__activeTexture(15),this.__gl.bindTexture(this.__gl.TEXTURE_2D,null),delete this.__activeTextures2D[e]);for(let e=0;e<this.__activeTextures2DArray.length;e++)null!=this.__activeTextures2DArray[e]&&(this.__activeTexture(15),this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY,null),delete this.__activeTextures2DArray[e]);for(let e=0;e<this.__activeTexturesCube.length;e++)null!=this.__activeTexturesCube[e]&&(this.__activeTexture(15),this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP,null),delete this.__activeTexturesCube[e])}__getExtension(e){const t=this.__gl;if(!this.__extensions.has(e)){const n=t.getExtension(e.toString());if(null==n&&u.T.cgApiDebugConsoleOutput){const t=`${e.toString()} Not Available in this environment`;f.V.info(t)}return this.__extensions.set(e,n),n}return this.__extensions.get(e)}__getCompressedTextureExtension(e){var t,n;const o=this.__gl;if(!this.__extensions.has(e)){const a=e.toString(),i=null!==(n=null!==(t=o.getExtension(a))&&void 0!==t?t:o.getExtension("MOZ_"+a))&&void 0!==n?n:o.getExtension("WEBKIT_"+a);if(null==i&&u.T.cgApiDebugConsoleOutput){const t=`${e.toString()} Not Available in this environment`;f.V.info(t)}else this.__extensions.set(e,i);return i}return this.__extensions.get(e)}setViewport(e,t,n,o){const a=this.__gl;this.__viewport_width===n&&this.__viewport_height===o&&this.__viewport_left===e&&this.__viewport_top===t||(a.viewport(e,t,n,o),this.__viewport_left=e,this.__viewport_top=t,this.__viewport_width=n,this.__viewport_height=o)}setViewportAsVector4(e){const t=this.__gl;this.__viewport_width===e.z&&this.__viewport_height===e.w&&this.__viewport_left===e.x&&this.__viewport_top===e.y||(t.viewport(e.x,e.y,e.z,e.w),this.__viewport_left=e.x,this.__viewport_top=e.y,this.__viewport_width=e.z,this.__viewport_height=e.w)}__getUniformBufferInfo(){if(!this.isWebGL2)return;const e=this.__gl,t=e.getParameter(e.UNIFORM_BUFFER_OFFSET_ALIGNMENT),n=e.getParameter(e.MAX_UNIFORM_BLOCK_SIZE);d(this,r,e.getParameter(e.MAX_VERTEX_UNIFORM_BLOCKS),"f"),d(this,s,e.getParameter(e.MAX_FRAGMENT_UNIFORM_BLOCKS),"f"),d(this,l,Math.min(h(this,r,"f"),h(this,s,"f")),"f"),d(this,o,n-n%t,"f"),d(this,i,t,"f"),d(this,a,n,"f")}__getMaxUniformVectors(){const e=this.getRawContext();this.__maxVertexUniformVectors=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),this.__maxVertexUniformVectors=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)}getMaxConventionUniformBlocks(){return h(this,l,"f")}getAlignedMaxUniformBlockSize(){return h(this,o,"f")}getMaxVertexUniformVectors(){return this.__maxVertexUniformVectors}getMaxFragmentUniformVectors(){return this.__maxFragmentUniformVectors}getWebGLMemoryInfo(){if(this.webgl2ExtGmanWM)return this.webgl2ExtGmanWM.getMemoryInfo()}isMultiview(){return this.__is_multiview&&u.T.multiViewForWebVR}}o=new WeakMap,a=new WeakMap,i=new WeakMap,r=new WeakMap,s=new WeakMap,l=new WeakMap},3430:(e,t,n)=>{n.d(t,{z:()=>N});var o=n(4324);class a extends o.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const i=new a({index:1,str:"OES_vertex_array_object"}),r=new a({index:2,str:"OES_texture_float"}),s=new a({index:3,str:"OES_texture_half_float"}),l=new a({index:4,str:"OES_texture_float_linear"}),c=new a({index:5,str:"OES_texture_half_float_linear"}),_=new a({index:6,str:"ANGLE_instanced_arrays"}),u=new a({index:7,str:"EXT_texture_filter_anisotropic"}),f=new a({index:8,str:"OES_element_index_uint"}),d=new a({index:9,str:"EXT_shader_texture_lod"}),h=new a({index:10,str:"OES_standard_derivatives"}),m=new a({index:11,str:"WEBGL_draw_buffers"}),p=new a({index:12,str:"EXT_blend_minmax"}),v=new a({index:13,str:"WEBGL_color_buffer_float"}),x=new a({index:14,str:"WEBGL_compressed_texture_astc"}),g=new a({index:15,str:"WEBGL_compressed_texture_s3tc"}),y=new a({index:16,str:"WEBGL_compressed_texture_pvrtc"}),b=new a({index:17,str:"WEBGL_compressed_texture_atc"}),I=new a({index:18,str:"WEBGL_compressed_texture_etc"}),A=new a({index:19,str:"WEBGL_compressed_texture_etc1"}),E=new a({index:20,str:"EXT_texture_compression_bptc"}),S=new a({index:21,str:"GMAN_webgl_memory"}),T=new a({index:22,str:"EXT_color_buffer_float"}),w=new a({index:23,str:"EXT_color_buffer_half_float"}),C=new a({index:24,str:"OCULUS_multiview"}),R=new a({index:25,str:"OVR_multiview2"}),P=new a({index:26,str:"EXT_clip_control"}),N=Object.freeze({VertexArrayObject:i,TextureFloat:r,TextureHalfFloat:s,TextureFloatLinear:l,TextureHalfFloatLinear:c,InstancedArrays:_,TextureFilterAnisotropic:u,ElementIndexUint:f,ShaderTextureLod:d,ShaderDerivatives:h,DrawBuffers:m,BlendMinmax:p,ColorBufferFloatWebGL1:v,CompressedTextureAstc:x,CompressedTextureS3tc:g,CompressedTexturePvrtc:y,CompressedTextureAtc:b,CompressedTextureEtc:I,CompressedTextureEtc1:A,CompressedTextureBptc:E,ColorBufferFloatWebGL2:T,ColorBufferHalfFloatWebGL2:w,OculusMultiview:C,OvrMultiview2:R,GMAN_WEBGL_MEMORY:S,ClipControl:P})},700:(e,t,n)=>{n.d(t,{u:()=>N});var o=n(4772),a=n(3639),i=n(1383),r=n(4958),s=n(7751),l=n(4114),c=n(7529),_=n(4513),u=n(9747),f=n(3414),d=n(3686),h=n(7681),m=n(5065),p=n(7925),v=n(3430),x=n(2229),g=n(7865),y=n(5338),b=n(5886),I=n(9993),A=n(7670),E=n(3497);const S=["#version 300 es","uniform vec2 u_offset;","uniform vec2 u_scale;","out mediump vec3 v_texcoord;","void main() {","    const float eye_offset_x[12] = float[12] (","        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,","        1.0, 1.0, 1.0, 1.0, 1.0, 1.0","    );","    const vec3 quad_positions[12] = vec3[12]","    (","        vec3(0.0, 0.0, 0.0),","        vec3(1.0, 0.0, 0.0),","        vec3(0.0, 1.0, 0.0),","        vec3(0.0, 1.0, 0.0),","        vec3(1.0, 0.0, 0.0),","        vec3(1.0, 1.0, 0.0),","        vec3(0.0, 0.0, 1.0),","        vec3(1.0, 0.0, 1.0),","        vec3(0.0, 1.0, 1.0),","        vec3(0.0, 1.0, 1.0),","        vec3(1.0, 0.0, 1.0),","        vec3(1.0, 1.0, 1.0)","    );","    const vec2 pos_scale = vec2(0.5, 1.0);","    vec2 eye_offset = vec2(eye_offset_x[gl_VertexID], 0.0);","    gl_Position = vec4(((quad_positions[gl_VertexID].xy * u_scale + u_offset) * pos_scale * 2.0) - 1.0 + eye_offset, 0.0, 1.0);","    v_texcoord = vec3(quad_positions[gl_VertexID].xy * u_scale + u_offset, quad_positions[gl_VertexID].z);","}"].join("\n"),T=["#version 300 es","uniform mediump sampler2DArray u_source_texture;","in mediump vec3 v_texcoord;","out mediump vec4 output_color;","void main()","{","    output_color = texture(u_source_texture, v_texcoord);","}"].join("\n");class w{constructor(e){this.__gl=e,this.__program=e.createProgram(),this.__attachShaderSource(S,e.VERTEX_SHADER),this.__attachShaderSource(T,e.FRAGMENT_SHADER),this.__gl.linkProgram(this.__program),this.__bindAttribLocation({v_texcoord:0}),this.__getUniformLocations()}static getInstance(e){return this.__instance||(this.__instance=new w(e)),this.__instance}__attachShaderSource(e,t){const n=this.__gl;let o;switch(t){case n.VERTEX_SHADER:this.__vertexShader=n.createShader(t),o=this.__vertexShader;break;case n.FRAGMENT_SHADER:this.__fragmentShader=n.createShader(t),o=this.__fragmentShader;break;default:return void E.V.error("Invalid Shader Type: "+t)}n.attachShader(this.__program,o),n.shaderSource(o,e),n.compileShader(o)}__bindAttribLocation(e){const t=this.__gl;if(e){this.__attrib={};for(const n in e)t.bindAttribLocation(this.__program,e[n],n),this.__attrib[n]=e[n]}}__getUniformLocations(){const e=this.__gl;if(null==this.__uniform){this.__uniform={};const t=e.getProgramParameter(this.__program,e.ACTIVE_UNIFORMS);let n="";for(let o=0;o<t;o++)n=e.getActiveUniform(this.__program,o).name.replace("[0]",""),this.__uniform[n]=e.getUniformLocation(this.__program,n)}}blit(e,t,n,o,a,i,r){const s=this.__gl,l=this.__program;s.activeTexture(s.TEXTURE15),s.bindTexture(s.TEXTURE_2D_ARRAY,e),s.useProgram(l);const c=s.getParameter(s.DEPTH_TEST),_=s.getParameter(s.DEPTH_WRITEMASK);s.disable(s.SCISSOR_TEST),c&&s.disable(s.DEPTH_TEST),s.disable(s.STENCIL_TEST),s.colorMask(!0,!0,!0,!0),_&&s.depthMask(!1);const u=s.getParameter(s.VIEWPORT);s.viewport(0,0,i,r),s.uniform2f(this.__uniform.u_scale,o,a),s.uniform2f(this.__uniform.u_offset,t,n),s.uniform1i(this.__uniform.u_source_texture,15),s.drawArrays(s.TRIANGLES,0,12),s.__changedProgram=!0,s.viewport(u[0],u[1],u[2],u[3]),c&&s.enable(s.DEPTH_TEST),s.depthMask(_),s.flush()}blitFake(e,t,n,o,a,i,r){const s=this.__gl,l=this.__program;s.activeTexture(s.TEXTURE15),s.bindTexture(s.TEXTURE_2D_ARRAY,e),s.useProgram(l);const c=s.getParameter(s.VIEWPORT);s.viewport(0,0,i,r),s.uniform2f(this.__uniform.u_scale,o,a),s.uniform2f(this.__uniform.u_offset,t,n),s.uniform1i(this.__uniform.u_source_texture,15),s.drawArrays(s.TRIANGLES,0,12),s.__changedProgram=!0,s.viewport(c[0],c[1],c[2],c[3])}blit2(e,t,n,o){const a=this.__gl,i=a.createFramebuffer(),r=a.createFramebuffer();function s(s,l){const c=a.createTexture();a.bindTexture(a.TEXTURE_2D,c),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,n,o,0,a.RGBA,a.UNSIGNED_BYTE,null),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.bindFramebuffer(a.READ_FRAMEBUFFER,i),a.framebufferTextureLayer(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,e,0,s),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,r),a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,c,0),a.blitFramebuffer(0,0,n,o,0,0,n,o,a.COLOR_BUFFER_BIT,a.NEAREST),a.framebufferTexture2D(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,c,0),a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,t,0),a.blitFramebuffer(0,0,n,o,l,0,l+n,o,a.COLOR_BUFFER_BIT,a.NEAREST)}s(0,0),s(1,n),a.bindFramebuffer(a.FRAMEBUFFER,null)}}var C=n(3212),R=n(8393);const P=n(3101);class N extends o.f{constructor(){super(),this.__webglContexts=new Map,this.__resourceCounter=o.f.InvalidCGAPIResourceUid,this.__webglResources=new Map,this.__samplerClampToEdgeLinearUid=o.f.InvalidCGAPIResourceUid,this.__samplerClampToEdgeNearestUid=o.f.InvalidCGAPIResourceUid,this.__samplerRepeatNearestUid=o.f.InvalidCGAPIResourceUid,this.__samplerRepeatLinearUid=o.f.InvalidCGAPIResourceUid,this.__samplerShadowUid=o.f.InvalidCGAPIResourceUid,this.__samplerRepeatTriLinearUid=o.f.InvalidCGAPIResourceUid,this.__samplerRepeatAnisotropyLinearUid=o.f.InvalidCGAPIResourceUid}static getInstance(){return this.__instance||(this.__instance=new N),this.__instance}addWebGLContext(e,t,n){const o=new c.u(e,t);this.__webglContexts.set("default",o),n&&(this.__glw=o)}generateWebGLContext(e,t,n){const o=e.getContext("webgl2",n);return this.addWebGLContext(o,e,t),h.zH.isSafari()&&(y.T.isUboEnabled=!1),o}get currentWebGLContextWrapper(){return this.__glw}getResourceNumber(){return++this.__resourceCounter}__registerResource(e){const t=this.getResourceNumber();return e._resourceUid=t,this.__webglResources.set(t,e),t}getWebGLResource(e){const t=this.__webglResources.get(e);return null!=t?t:null}createIndexBuffer(e){const t=this.__glw.getRawContext();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");this.__glw.bindVertexArray(null);const n=t.createBuffer(),o=this.__registerResource(n);return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n),t.bufferData(t.ELEMENT_ARRAY_BUFFER,e.getTypedArray(),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),o}updateIndexBuffer(e,t){const n=this.__glw,o=null==n?void 0:n.getRawContext();if(x.Is.not.exist(o))throw new Error("No WebGLRenderingContext set as Default.");const a=this.__webglResources.get(t);if(x.Is.not.exist(a))throw new Error("Not found IBO.");n.bindVertexArray(null),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,a),o.bufferSubData(o.ELEMENT_ARRAY_BUFFER,0,e.getTypedArray()),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null)}createVertexBuffer(e){const t=this.__glw.getRawContext();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");this.__glw.bindVertexArray(null);const n=t.createBuffer(),o=this.__registerResource(n);return t.bindBuffer(t.ARRAY_BUFFER,n),t.bufferData(t.ARRAY_BUFFER,e.getUint8Array(),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),o}createVertexBufferFromTypedArray(e){const t=this.__glw.getRawContext();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");this.__glw.bindVertexArray(null);const n=t.createBuffer(),o=this.__registerResource(n);return t.bindBuffer(t.ARRAY_BUFFER,n),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),o}updateVertexBuffer(e,t){const n=this.__glw,o=null==n?void 0:n.getRawContext();if(!x.Is.exist(o))throw new Error("No WebGLRenderingContext set as Default.");const a=this.__webglResources.get(t);if(!x.Is.exist(a))throw new Error("Not found VBO.");n.bindVertexArray(null),o.bindBuffer(o.ARRAY_BUFFER,a),o.bufferSubData(o.ARRAY_BUFFER,0,e.bufferView.getUint8Array()),o.bindBuffer(o.ARRAY_BUFFER,null)}createVertexArray(){if(null==this.__glw)throw new Error("No WebGLRenderingContext set as Default.");const e=this.__glw.createVertexArray();if(!x.Is.not.exist(e))return this.__registerResource(e)}bindTexture2D(e,t){const n=this.getWebGLResource(t);this.__glw.bindTexture2D(e,n)}bindTextureSampler(e,t){if(-1===t)this.__glw.bindTextureSampler(e,null);else{const n=this.getWebGLResource(t);this.__glw.bindTextureSampler(e,n)}}bindTextureCube(e,t){const n=this.getWebGLResource(t);this.__glw.bindTextureCube(e,n)}createVertexBufferAndIndexBuffer(e){let t;e.hasIndices()&&(t=this.createIndexBuffer(e.indicesAccessor));const n=[];for(let e=0;e<a.r.AttributeTypeNumber;e++)n[e]=!1;const o=[];return e.attributeAccessors.forEach(((t,i)=>{const r=this.createVertexBuffer(t),s=a.r.toAttributeSlotFromJoinedString(e.attributeSemantics[i]);n[s]=!0,o.push(r)})),{vaoHandle:-1,iboHandle:t,vboHandles:o,attributesFlags:n,setComplete:!1}}updateVertexBufferAndIndexBuffer(e,t){t.iboHandle&&this.updateIndexBuffer(e.indicesAccessor,t.iboHandle);const n=e.attributeAccessors;for(let e=0;e<n.length;e++)this.updateVertexBuffer(n[e],t.vboHandles[e])}createShaderProgram({material:e,primitive:t,vertexShaderStr:n,fragmentShaderStr:a,attributeNames:i,attributeSemantics:r,onError:s}){const l=this.__glw.getRawContext();if(null==l)throw new Error("No WebGLRenderingContext set as Default.");const c=y.T.cgApiDebugConsoleOutput,_=l.createShader(l.VERTEX_SHADER);if(l.shaderSource(_,n),l.compileShader(_),c&&!this.__checkShaderCompileStatus(e.materialTypeName,_,n,s))return o.f.InvalidCGAPIResourceUid;const u=l.createShader(l.FRAGMENT_SHADER);l.shaderSource(u,a),l.compileShader(u),c&&this.__checkShaderCompileStatus(e.materialTypeName,u,a,s);const f=l.createProgram();if(f._gl=l,f._materialTypeName=e.materialTypeName,f._vertexShaderStr=n,f._fragmentShaderStr=a,f._shaderSemanticsInfoMap=new Map,f._material=new WeakRef(e),f._primitive=new WeakRef(t),l.attachShader(f,_),l.attachShader(f,u),i.forEach(((e,t)=>{l.bindAttribLocation(f,r[t].getAttributeSlot(),e)})),l.linkProgram(f),c&&!this.__checkShaderProgramLinkStatus(e.materialTypeName,f,n,a))return o.f.InvalidCGAPIResourceUid;f.__SPECTOR_rebuildProgram=this.rebuildProgramBySpector.bind(f);const d=this.__registerResource(f);return l.deleteShader(_),l.deleteShader(u),d}__checkShaderCompileStatus(e,t,n,o){const a=this.__glw.getRawContext();if(x.Is.false(a.getShaderParameter(t,a.COMPILE_STATUS))&&x.Is.false(a.isContextLost())){E.V.info("MaterialTypeName: "+e);const i=h.zH.addLineNumberToCode(n);E.V.info(i);const r=a.getShaderInfoLog(t);return void 0===o?(E.V.error("An error occurred compiling the shaders:"+r),!1):(o(r),!1)}return!0}__checkShaderProgramLinkStatus(e,t,n,o){const a=this.__glw.getRawContext();if(x.Is.false(a.getProgramParameter(t,a.LINK_STATUS))&&x.Is.false(a.isContextLost())){E.V.info("MaterialTypeName: "+e),E.V.info(h.zH.addLineNumberToCode("Vertex Shader:")),E.V.info(h.zH.addLineNumberToCode(n)),E.V.info(h.zH.addLineNumberToCode("Fragment Shader:")),E.V.info(h.zH.addLineNumberToCode(o));const i=a.getProgramInfoLog(t);return E.V.error("Unable to initialize the shader program: "+i),!1}return!0}setupUniformLocations(e,t,n){const o=this.__glw.getRawContext(),a=this.getWebGLResource(e),i=t.length;for(let e=0;e<i;e++){const n=t[e];a._shaderSemanticsInfoMap.set(n.semantic,n)}for(let e=0;e<i;e++){const i=t[e];if(n||i.needUniformInDataTextureMode||s.h.isTexture(i.compositionType)){const e=i.semantic,t="u_"+i.semantic,n=o.getUniformLocation(a,t);a[e]=n,null==n&&y.T.cgApiDebugConsoleOutput&&E.V.info(`Can not get the uniform location: ${t}. The uniform may be unused by other code so implicitly removed.`)}}return a}setupBasicUniformLocations(e){const t=this.getWebGLResource(e),n=this.currentWebGLContextWrapper.getRawContext();t.dataTexture=n.getUniformLocation(t,"u_dataTexture"),t.isMainVr=n.getUniformLocation(t,"u_isMainVr"),t.currentComponentSIDs=n.getUniformLocation(t,"u_currentComponentSIDs")}setUniform1iForTexture(e,t,n){const o=e,a=o._shaderSemanticsInfoMap.get(t);if(null==a)return;const i=this.__glw.getRawContext(),r=o[t];i.uniform1i(r,n[0]),this.bindTexture(a,n)}setUniformValue(e,t,n,o){const a=e._shaderSemanticsInfoMap.get(t);if(null==a)return!1;let i=!1,r=0;a.compositionType===s.h.Mat3?(i=!0,r=3):a.compositionType===s.h.Mat4?(i=!0,r=4):r=a.compositionType.getNumberOfComponents();const l=a.compositionType===s.h.ScalarArray||a.compositionType===s.h.Vec4Array||a.compositionType===s.h.Vec3Array||a.compositionType===s.h.Vec2Array,c=t;let _=!1;return s.h.isTexture(a.compositionType)?(_=this.setUniformValueInner(e,c,a,i,r,!1,{x:o[0]}),this.bindTexture(a,o)):_=l?null==o._v?this.setUniformValueInner(e,c,a,i,r,!0,{x:o}):this.setUniformValueInner(e,c,a,i,r,!0,{x:o._v}):a.compositionType===s.h.Scalar?null==o._v?this.setUniformValueInner(e,c,a,i,r,!1,{x:o}):this.setUniformValueInner(e,c,a,i,r,!0,{x:o._v}):null==o._v?this.setUniformValueInner(e,c,a,i,r,!1,o):this.setUniformValueInner(e,c,a,i,r,!0,{x:o._v}),_}bindTexture(e,t){var n,o;if(e.compositionType===s.h.Texture2D||e.compositionType===s.h.Texture2DShadow){if(this.bindTexture2D(t[0],t[1]._textureResourceUid),null!=t[2])this.bindTextureSampler(t[0],t[2]._samplerResourceUid);else if(e.compositionType===s.h.Texture2D){const e=this.createOrGetTextureSamplerClampToEdgeLinear();this.bindTextureSampler(t[0],e)}else if(e.compositionType===s.h.Texture2DShadow){const e=this.createOrGetTextureSamplerShadow();this.bindTextureSampler(t[0],e)}}else if(e.compositionType===s.h.TextureCube)if(this.bindTextureCube(t[0],t[1]._textureResourceUid),null!=t[2])this.bindTextureSampler(t[0],t[2]._samplerResourceUid);else{const e=t[1];this.bindTextureSampler(t[0],null!==(o=null===(n=e._recommendedTextureSampler)||void 0===n?void 0:n._samplerResourceUid)&&void 0!==o?o:-1)}}setUniformValueInner(e,t,n,o,a,i,{x:r,y:s,z:c,w:_}){const u=e[t];if(null==u)return!1;const f=u,d=this.__glw.getRawContext();if(o)4===a?d.uniformMatrix4fv(f,!1,r):d.uniformMatrix3fv(f,!1,r);else if(i){const e=n.componentType===l.I.Int||n.componentType===l.I.Short||n.componentType===l.I.Byte;1===a?e?d.uniform1iv(f,r):d.uniform1fv(f,r):2===a?e?d.uniform2iv(f,r):d.uniform2fv(f,r):3===a?e?d.uniform3iv(f,r):d.uniform3fv(f,r):4===a&&(e?d.uniform4iv(f,r):d.uniform4fv(f,r))}else{const e=n.componentType===l.I.Int||n.componentType===l.I.Short||n.componentType===l.I.Byte;1===a?e?d.uniform1i(f,r):d.uniform1f(f,r):2===a?e?d.uniform2i(f,r,s):d.uniform2f(f,r,s):3===a?e?d.uniform3i(f,r,s,c):d.uniform3f(f,r,s,c):4===a&&(e?d.uniform4i(f,r,s,c,_):d.uniform4f(f,r,s,c,_))}return!0}setVertexDataToPipeline({vaoHandle:e,iboHandle:t,vboHandles:n},i,r=o.f.InvalidCGAPIResourceUid){const c=this.__glw.getRawContext(),_=this.getWebGLResource(e);if(this.__glw.bindVertexArray(_),null!=t){const e=this.getWebGLResource(t);if(null==e)throw new Error("Nothing Element Array Buffer!");c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,e)}if(n.forEach(((e,t)=>{const n=this.getWebGLResource(e);if(null==n)throw new Error("Nothing Element Array Buffer at index "+t);c.bindBuffer(c.ARRAY_BUFFER,n),c.enableVertexAttribArray(a.r.toAttributeSlotFromJoinedString(i.attributeSemantics[t])),c.vertexAttribPointer(a.r.toAttributeSlotFromJoinedString(i.attributeSemantics[t]),i.attributeCompositionTypes[t].getNumberOfComponents(),i.attributeComponentTypes[t].index,i.attributeAccessors[t].normalized,i.attributeAccessors[t].byteStride,0)})),r!==o.f.InvalidCGAPIResourceUid){const e=this.getWebGLResource(r);if(null==e)throw new Error("Nothing Element Array Buffer at index");c.bindBuffer(c.ARRAY_BUFFER,e),c.enableVertexAttribArray(a.r.Instance.getAttributeSlot()),c.vertexAttribPointer(a.r.Instance.getAttributeSlot(),s.h.Vec4.getNumberOfComponents(),l.I.Float.index,!1,0,0),this.__glw.vertexAttribDivisor(a.r.Instance.getAttributeSlot(),1)}c.bindBuffer(c.ARRAY_BUFFER,null),this.__glw.bindVertexArray(null),c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,null)}createTexStorage2D({levels:e,internalFormat:t,width:n,height:o}){const a=this.__glw.getRawContextAsWebGL2(),i=a.createTexture();this.__glw.bindTexture2D(15,i),a.texStorage2D(b.VwS,e,t.index,n,o);const r=this.__registerResource(i);return this.__glw.unbindTexture2D(15),r}createTextureSampler({magFilter:e,minFilter:t,wrapS:n,wrapT:o,wrapR:a,anisotropy:i,isPremultipliedAlpha:r,shadowCompareMode:s}){const l=this.__glw.getRawContextAsWebGL2(),c=l.createSampler(),_=this.__registerResource(c);return l.samplerParameteri(c,l.TEXTURE_MIN_FILTER,t.index),l.samplerParameteri(c,l.TEXTURE_MAG_FILTER,e.index),l.samplerParameteri(c,l.TEXTURE_WRAP_S,n.index),l.samplerParameteri(c,l.TEXTURE_WRAP_T,o.index),l.samplerParameteri(c,l.TEXTURE_WRAP_R,a.index),s&&(l.samplerParameteri(c,l.TEXTURE_COMPARE_MODE,l.COMPARE_REF_TO_TEXTURE),l.samplerParameteri(c,l.TEXTURE_COMPARE_FUNC,l.LESS)),i&&this.__glw.webgl2ExtTFA&&l.samplerParameteri(c,this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT,4),_}createOrGetTextureSamplerClampToEdgeLinear(){if(this.__samplerClampToEdgeLinearUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerClampToEdgeLinearUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.LINEAR),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.LINEAR),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.samplerParameteri(t,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE)}return this.__samplerClampToEdgeLinearUid}createOrGetTextureSamplerClampToEdgeNearest(){if(this.__samplerClampToEdgeNearestUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerClampToEdgeNearestUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.samplerParameteri(t,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE)}return this.__samplerClampToEdgeNearestUid}createOrGetTextureSamplerRepeatNearest(){if(this.__samplerRepeatNearestUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerRepeatNearestUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_R,e.REPEAT)}return this.__samplerRepeatNearestUid}createOrGetTextureSamplerRepeatLinear(){if(this.__samplerRepeatLinearUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerRepeatLinearUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.LINEAR),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.LINEAR),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_R,e.REPEAT)}return this.__samplerRepeatLinearUid}createOrGetTextureSamplerRepeatTriLinear(){if(this.__samplerRepeatTriLinearUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerRepeatTriLinearUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.LINEAR),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_R,e.REPEAT)}return this.__samplerRepeatTriLinearUid}createOrGetTextureSamplerShadow(){if(this.__samplerShadowUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerShadowUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.samplerParameteri(t,e.TEXTURE_COMPARE_MODE,e.COMPARE_REF_TO_TEXTURE),e.samplerParameteri(t,e.TEXTURE_COMPARE_FUNC,e.LESS)}return this.__samplerShadowUid}createOrGetTextureSamplerRepeatAnisotropyLinear(){if(this.__samplerRepeatAnisotropyLinearUid===o.f.InvalidCGAPIResourceUid){const e=this.__glw.getRawContextAsWebGL2(),t=e.createSampler(),n=this.__registerResource(t);this.__samplerRepeatAnisotropyLinearUid=n,e.samplerParameteri(t,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.samplerParameteri(t,e.TEXTURE_MAG_FILTER,e.LINEAR),e.samplerParameteri(t,e.TEXTURE_WRAP_S,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_T,e.REPEAT),e.samplerParameteri(t,e.TEXTURE_WRAP_R,e.REPEAT),e.samplerParameteri(t,this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT,4)}return this.__samplerRepeatAnisotropyLinearUid}createTextureFromImageBitmapData(e,{level:t,internalFormat:n,width:o,height:a,border:i,format:r,type:s,generateMipmap:l}){const c=this.__glw.getRawContextAsWebGL2(),_=c.createTexture(),u=this.__registerResource(_);this.__glw.bindTexture2D(15,_);const f=Math.floor(Math.log2(Math.max(o,a)))+1;return c.texStorage2D(b.VwS,f,n.index,o,a),c.texSubImage2D(c.TEXTURE_2D,0,0,0,r.index,s.index,e),this.__createTextureInner(c,o,a,l),u}__createTextureInner(e,t,n,o){e.generateMipmap(e.TEXTURE_2D),this.__glw.unbindTexture2D(15)}async createTextureFromHTMLImageElement(e,{level:t,internalFormat:n,width:o,height:a,border:i,format:r,type:s,generateMipmap:l}){const c=this.__glw.getRawContextAsWebGL2(),_=c.createTexture(),u=this.__registerResource(_);this.__glw.bindTexture2D(15,_);const f=l?Math.max(Math.log2(o),Math.log2(a)):1;return c.texStorage2D(b.VwS,f,n.index,o,a),c.texSubImage2D(c.TEXTURE_2D,0,0,0,r.index,s.index,e),this.__createTextureInner(c,o,a,l),u}allocateTexture({format:e,width:t,height:n,mipLevelCount:o}){const a=this.__glw.getRawContextAsWebGL2(),i=a.createTexture(),r=this.__registerResource(i);return this.__glw.bindTexture2D(15,i),a.texStorage2D(b.VwS,o,e.index,t,n),this.__glw.unbindTexture2D(15),r}loadImageToMipLevelOfTexture2D({mipLevel:e,textureUid:t,format:n,type:o,xOffset:a,yOffset:i,width:s,height:l,rowSizeByPixel:c,data:_}){const u=this.__glw.getRawContextAsWebGL2(),f=this.getWebGLResource(t),d=R.n.getPixelFormatFromTextureFormat(n),h=r.A.getCompositionNumFromPixelFormat(d),m=new _.constructor(s*l*h);for(let e=0;e<l;e++){const t=e*c*h,n=e*s*h;for(let e=0;e<s;e++)m.set(_.subarray(t+e*h,t+(e+1)*h),n+e*h)}this.__glw.bindTexture2D(15,f),u.texSubImage2D(u.TEXTURE_2D,e,a,i,s,l,d.index,o.index,m),this.__glw.unbindTexture2D(15)}createTextureFromTypedArray(e,{level:t,internalFormat:n,width:o,height:a,border:i,format:r,type:s,generateMipmap:l}){const c=this.__glw.getRawContextAsWebGL2(),_=c.createTexture(),u=this.__registerResource(_);this.__glw.bindTexture2D(15,_);const f=l?Math.max(Math.log2(o),Math.log2(a)):1;return c.texStorage2D(b.VwS,f,n.index,o,a),c.texSubImage2D(c.TEXTURE_2D,0,0,0,o,a,r.index,s.index,e),this.__createTextureInner(c,o,a,l),u}createCompressedTexture(e,t){const n=this.__glw.getRawContext(),o=n.createTexture(),a=this.__registerResource(o);this.__glw.bindTexture2D(15,o);const i=t.index;for(const t of e)n.compressedTexImage2D(n.TEXTURE_2D,t.level,i,t.width,t.height,0,t.buffer);return this.__glw.unbindTexture2D(15),a}createCompressedTextureFromBasis(e,{border:t,format:n,type:o}){let a,i;const r=this.__glw.getRawContext(),s=r.createTexture(),l=this.__registerResource(s);this.__glw.bindTexture2D(15,s);const c=r.getExtension("WEBGL_compressed_texture_s3tc");c&&(a=p.F.BC3,i=c.COMPRESSED_RGBA_S3TC_DXT5_EXT);const _=r.getExtension("WEBGL_compressed_texture_etc1");_&&(a=p.F.ETC1,i=_.COMPRESSED_RGB_ETC1_WEBGL);const u=r.getExtension("WEBGL_compressed_texture_atc");u&&(a=p.F.ATC_RGBA,i=u.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL);const f=r.getExtension("WEBGL_compressed_texture_etc");f&&(a=p.F.ETC2,i=f.COMPRESSED_RGBA8_ETC2_EAC);const d=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");d&&(a=p.F.PVRTC1_RGBA,i=d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG);const h=r.getExtension("WEBGL_compressed_texture_astc");h&&(a=p.F.ASTC,i=h.COMPRESSED_RGBA_ASTC_4x4_KHR);const m=e.getNumLevels(0);for(let n=0;n<m;n++){const o=e.getImageWidth(0,n),s=e.getImageHeight(0,n),l=this.decodeBasisImage(e,a,0,n);r.compressedTexImage2D(r.TEXTURE_2D,n,i,o,s,t,l)}return this.__glw.unbindTexture2D(15),l}decodeBasisImage(e,t,n,o){const a=e.getImageTranscodedSizeInBytes(n,o,t.index),i=new Uint8Array(a);return e.transcodeImage(i,n,o,t.index,0,0)||E.V.error("failed to transcode the image."),i}createFrameBufferObject(){const e=this.__glw.getRawContext().createFramebuffer();return this.__registerResource(e)}attachColorBufferToFrameBufferObject(e,t,n){const o=this.__glw.getRawContextAsWebGL2(),a=this.getWebGLResource(e.framebufferUID);o.bindFramebuffer(o.FRAMEBUFFER,a);const i=this.getWebGLResource(n._textureResourceUid),r=this.__glw.colorAttachment(t);n instanceof _.$&&n.arrayLength>0?(n._fbo=e,this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(o.DRAW_FRAMEBUFFER,r,i,0,4,0,n.arrayLength):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(o.DRAW_FRAMEBUFFER,r,i,0,0,n.arrayLength)):n instanceof _.$&&0===n.arrayLength?(n._fbo=e,o.framebufferTexture2D(o.FRAMEBUFFER,r,o.TEXTURE_2D,i,0)):(n._fbo=e,o.framebufferRenderbuffer(o.FRAMEBUFFER,r,o.RENDERBUFFER,i)),o.bindFramebuffer(o.FRAMEBUFFER,null)}attachColorBufferCubeToFrameBufferObject(e,t,n,o,a){const i=this.__glw.getRawContextAsWebGL2(),r=this.getWebGLResource(e.framebufferUID);i.bindFramebuffer(i.FRAMEBUFFER,r);const s=this.getWebGLResource(a._textureResourceUid),l=this.__glw.colorAttachment(t);a._fbo=e,i.framebufferTexture2D(i.FRAMEBUFFER,l,i.TEXTURE_CUBE_MAP_POSITIVE_X+n,s,o),i.bindFramebuffer(i.FRAMEBUFFER,null)}attachDepthBufferToFrameBufferObject(e,t){this.__attachDepthOrStencilBufferToFrameBufferObject(e,t,36096)}attachStencilBufferToFrameBufferObject(e,t){this.__attachDepthOrStencilBufferToFrameBufferObject(e,t,36128)}attachDepthStencilBufferToFrameBufferObject(e,t){this.__attachDepthOrStencilBufferToFrameBufferObject(e,t,33306)}__attachDepthOrStencilBufferToFrameBufferObject(e,t,n){const o=this.__glw.getRawContextAsWebGL2(),a=this.getWebGLResource(e.framebufferUID);o.bindFramebuffer(o.FRAMEBUFFER,a);const i=this.getWebGLResource(t._textureResourceUid);t instanceof _.$&&t.arrayLength>0?(t._fbo=e,this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(o.DRAW_FRAMEBUFFER,n,i,0,4,0,t.arrayLength):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(o.DRAW_FRAMEBUFFER,n,i,0,0,t.arrayLength)):t instanceof _.$&&0===t.arrayLength?(t._fbo=e,o.framebufferTexture2D(o.FRAMEBUFFER,n,o.TEXTURE_2D,i,0)):(t._fbo=e,o.framebufferRenderbuffer(o.FRAMEBUFFER,n,o.RENDERBUFFER,i)),o.bindFramebuffer(o.FRAMEBUFFER,null)}createRenderBuffer(e,t,n,o,a){const i=this.__glw.getRawContext(),r=i.createRenderbuffer(),s=this.__registerResource(r);return i.bindRenderbuffer(i.RENDERBUFFER,r),o?i.renderbufferStorageMultisample(i.RENDERBUFFER,a,i[n.str],e,t):i.renderbufferStorage(i.RENDERBUFFER,i[n.str],e,t),i.bindRenderbuffer(i.RENDERBUFFER,null),s}setDrawTargets(e){const t=e.getFramebuffer();if(t){const n=e.getRenderTargetColorAttachments();x.Is.exist(n)?this.__glw.drawBuffers(n):this.__glw.drawBuffers(t.colorAttachmentsRenderBufferTargets)}else this.__glw.drawBuffers([d.q.Back])}bindFramebuffer(e){const t=this.__glw.getRawContext();if(e){const n=e.cgApiResourceUid,o=this.getWebGLResource(n);t.bindFramebuffer(t.FRAMEBUFFER,o)}else t.bindFramebuffer(t.FRAMEBUFFER,null)}unbindFramebuffer(){const e=this.__glw.getRawContext();e.bindFramebuffer(e.FRAMEBUFFER,null)}createRenderTargetTexture({width:e,height:t,mipLevelCount:n,format:o}){const a=this.__glw.getRawContextAsWebGL2(),i=a.createTexture(),r=this.__registerResource(i);return this.__glw.bindTexture2D(15,i),a.texStorage2D(a.TEXTURE_2D,n,o.index,e,t),this.__glw.unbindTexture2D(15),r}createRenderTargetTextureArray({width:e,height:t,level:n,internalFormat:o,format:a,type:i,arrayLength:r}){const s=this.__glw.getRawContextAsWebGL2(),l=s.createTexture(),c=this.__registerResource(l);return this.__glw.bindTexture2DArray(15,l),s.texStorage3D(s.TEXTURE_2D_ARRAY,1,o.index,e,t,r),c}createRenderTargetTextureCube({width:e,height:t,mipLevelCount:n,format:o}){const a=this.__glw.getRawContextAsWebGL2(),i=a.createTexture(),r=this.__registerResource(i);return this.__glw.bindTextureCube(15,i),a.texStorage2D(a.TEXTURE_CUBE_MAP,n,o.index,e,t),this.__glw.unbindTextureCube(15),r}createCubeTexture(e,t,n,o){const a=this.__glw.getRawContext(),r=a.createTexture(),s=this.__registerResource(r);this.__glw.bindTextureCube(15,r);const l=i.P.ClampToEdge,c=i.P.ClampToEdge;let _=i.P.Linear,f=i.P.Linear;t[0].posX.hdriFormat===u.P.HDR_LINEAR&&this.__glw.isNotSupportWebGL1Extension(v.z.TextureFloatLinear)?(_=e>=2?i.P.NearestMipmapNearest:i.P.Nearest,f=i.P.Nearest):(_=e>=2?i.P.LinearMipmapLinear:i.P.Linear,f=i.P.Linear);const d=new I.L({wrapS:l,wrapT:c,minFilter:_,magFilter:f});d.create();const h=(e,t,i)=>{if(e.hdriFormat===u.P.HDR_LINEAR){const n=this.__glw.getRawContextAsWebGL2();n.texImage2D(t,i,y.T.isMobile?n.RGB16F:n.RGB32F,e.width,e.height,0,n.RGB,n.FLOAT,e.dataFloat)}else e instanceof HTMLImageElement||e instanceof HTMLCanvasElement?a.texImage2D(t,i,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,e):a.texImage2D(t,i,a.RGBA,n/2**i,o/2**i,0,a.RGBA,a.UNSIGNED_BYTE,e)};for(let e=0;e<t.length;e++){const n=t[e];h(n.posX,a.TEXTURE_CUBE_MAP_POSITIVE_X,e),h(n.negX,a.TEXTURE_CUBE_MAP_NEGATIVE_X,e),h(n.posY,a.TEXTURE_CUBE_MAP_POSITIVE_Y,e),h(n.negY,a.TEXTURE_CUBE_MAP_NEGATIVE_Y,e),h(n.posZ,a.TEXTURE_CUBE_MAP_POSITIVE_Z,e),h(n.negZ,a.TEXTURE_CUBE_MAP_NEGATIVE_Z,e)}return this.__glw.unbindTextureCube(15),[s,d]}async createCubeTextureFromFiles(e,t,n,o){const a=this.__glw.getRawContext(),i=[];let r=0,s=0;for(let l=0;l<t;l++){const t=()=>new Promise(((t,i)=>{let r=0;const s=[];let c=".jpg";o===u.P.HDR_LINEAR?c=".hdr":o===u.P.RGBE_PNG&&(c=".RGBE.PNG");let _="_right_",f="_left_",d="_top_",h="_bottom_",m="_front_",p="_back_";n&&(_="_posx_",f="_negx_",d="_posy_",h="_negy_",m="_posz_",p="_negz_");const v=[[e+_+l+c,a.TEXTURE_CUBE_MAP_POSITIVE_X],[e+f+l+c,a.TEXTURE_CUBE_MAP_NEGATIVE_X],[e+d+l+c,a.TEXTURE_CUBE_MAP_POSITIVE_Y],[e+h+l+c,a.TEXTURE_CUBE_MAP_NEGATIVE_Y],[e+m+l+c,a.TEXTURE_CUBE_MAP_POSITIVE_Z],[e+p+l+c,a.TEXTURE_CUBE_MAP_NEGATIVE_Z]];for(let e=0;e<v.length;e++){const n=v[e][1];let a;a=o===u.P.HDR_LINEAR||o===u.P.RGB9_E5_PNG?new P:new Image,a.hdriFormat=o,a.side=n,a.uri=v[e][0],a.crossOrigin="Anonymous",a.onload=()=>{r++,s.push(a),6===r&&t(s)},a.onerror=()=>{i(a.uri)},a.src=v[e][0]}}));let c;try{c=await t()}catch(e){try{c=await t()}catch(e){E.V.error(`failed to load ${e}`)}}const _={};for(const e of c){switch(e.side){case a.TEXTURE_CUBE_MAP_POSITIVE_X:_.posX=e;break;case a.TEXTURE_CUBE_MAP_POSITIVE_Y:_.posY=e;break;case a.TEXTURE_CUBE_MAP_POSITIVE_Z:_.posZ=e;break;case a.TEXTURE_CUBE_MAP_NEGATIVE_X:_.negX=e;break;case a.TEXTURE_CUBE_MAP_NEGATIVE_Y:_.negY=e;break;case a.TEXTURE_CUBE_MAP_NEGATIVE_Z:_.negZ=e}0===l&&(r=e.width,s=e.height)}i.push(_)}return this.createCubeTexture(t,i,r,s)}createCubeTextureFromBasis(e,{magFilter:t=i.P.Linear,minFilter:n=i.P.LinearMipmapLinear,wrapS:o=i.P.Repeat,wrapT:a=i.P.Repeat,border:r=0}){const s=this.__glw.getRawContext();let l,c;const _=s.createTexture(),u=this.__registerResource(_);this.__glw.bindTextureCube(15,_);const f=s.getExtension("WEBGL_compressed_texture_s3tc");f&&(l=p.F.BC3,c=f.COMPRESSED_RGBA_S3TC_DXT5_EXT);const d=s.getExtension("WEBGL_compressed_texture_etc1");d&&(l=p.F.ETC1,c=d.COMPRESSED_RGB_ETC1_WEBGL);const h=s.getExtension("WEBGL_compressed_texture_atc");h&&(l=p.F.ATC_RGBA,c=h.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL);const m=s.getExtension("WEBGL_compressed_texture_etc");m&&(l=p.F.ETC2,c=m.COMPRESSED_RGBA8_ETC2_EAC);const v=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");v&&(l=p.F.PVRTC1_RGBA,c=v.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG);const x=s.getExtension("WEBGL_compressed_texture_astc");x&&(l=p.F.ASTC,c=x.COMPRESSED_RGBA_ASTC_4x4_KHR);const g=e.getNumImages(),y=e.getNumLevels(0);if(s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_WRAP_S,o.index),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_WRAP_T,a.index),y>=2)s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MIN_FILTER,n.index),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MAG_FILTER,t.index);else{let e=n;n===i.P.LinearMipmapLinear&&(e=i.P.Linear),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MIN_FILTER,e.index),s.texParameteri(s.TEXTURE_CUBE_MAP,s.TEXTURE_MAG_FILTER,t.index)}for(let t=0;t<y;t++)for(let n=0;n<g;n++){const o=e.getImageWidth(n,t),a=e.getImageHeight(n,t),i=this.decodeBasisImage(e,l,n,t);s.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+n,t,c,o,a,r,i)}return this.__glw.unbindTextureCube(15),u}createDummyBlackCubeTexture(){const e=this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg=="),t=new Uint8Array(e);return this.createCubeTexture(1,[{posX:t,negX:t,posY:t,negY:t,posZ:t,negZ:t}],1,1)}createDummyCubeTexture(e="rgba(0,0,0,1)"){const t=document.createElement("canvas");t.width=1,t.height=1;const n=t.getContext("2d");return n.fillStyle=e,n.fillRect(0,0,1,1),this.createCubeTexture(1,[{posX:t,negX:t,posY:t,negY:t,posZ:t,negZ:t}],1,1)}setWebGLTextureDirectly(e){const t=e;return this.__registerResource(t)}async createTextureFromDataUri(e,{level:t,internalFormat:n,border:o,format:a,type:i,generateMipmap:r}){return new Promise((s=>{const l=new Image;e.match(/^data:/)||(l.crossOrigin="Anonymous"),l.onload=()=>{const e=l.width,c=l.height,_=this.createTextureFromHTMLImageElement(l,{level:t,internalFormat:n,width:e,height:c,border:o,format:a,type:i,generateMipmap:r});s(_)},l.src=e}))}updateLevel0TextureAndGenerateMipmap(e,t,{width:n,height:o,format:a,type:i}){const r=this.getWebGLResource(e);this.__glw.bindTexture2D(15,r);const s=this.__glw.getRawContextAsWebGL2();s.texSubImage2D(s.TEXTURE_2D,0,0,0,n,o,a.index,i.index,t),s.generateMipmap(s.TEXTURE_2D),this.__glw.unbindTexture2D(15)}updateTexture(e,t,{level:n,xoffset:o,yoffset:a,width:i,height:r,format:s,type:l}){const c=this.getWebGLResource(e);this.__glw.bindTexture2D(15,c);const _=this.__glw.getRawContextAsWebGL2();_.texSubImage2D(_.TEXTURE_2D,n,0,0,i,r,s.index,l.index,t),this.__glw.unbindTexture2D(15)}deleteFrameBufferObject(e){const t=this.getWebGLResource(e),n=this.__glw.getRawContext();null!=t&&(n.deleteFramebuffer(t),this.__webglResources.delete(e))}deleteRenderBuffer(e){const t=this.__glw.getRawContext(),n=this.getWebGLResource(e);t.deleteRenderbuffer(n),this.__webglResources.delete(e)}deleteTexture(e){const t=this.getWebGLResource(e),n=this.__glw.getRawContext();null!=t&&(n.deleteTexture(t),this.__webglResources.delete(e),E.V.debug("gl.deleteTexture called: "+e))}createDummyTexture(e="rgba(255,255,255,1)"){const t=document.createElement("canvas");t.width=1,t.height=1;const n=t.getContext("2d");return n.fillStyle=e,n.fillRect(0,0,1,1),this.createTextureFromImageBitmapData(t,{level:0,internalFormat:R.n.RGBA8,width:1,height:1,border:0,format:r.A.RGBA,type:l.I.UnsignedByte,generateMipmap:!1})}createDummyBlackTexture(){return this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg==")}createDummyWhiteTexture(){return this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5/hPwAIAgL/4d1j8wAAAABJRU5ErkJggg==")}createDummyNormalTexture(){return this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mOsr///HwAGgAL+v1RumAAAAABJRU5ErkJggg==")}__createDummyTextureInner(e){const t=m.$.base64ToArrayBuffer(e);return this.createTextureFromTypedArray(new Uint8Array(t),{level:0,internalFormat:R.n.RGBA8,width:1,height:1,border:0,format:r.A.RGBA,type:l.I.UnsignedByte,generateMipmap:!1})}generateMipmaps2d(e,t,n){const o=this.__glw.getRawContext(),a=this.getWebGLResource(e);this.__glw.bindTexture2D(15,a),o.generateMipmap(o.TEXTURE_2D),this.__glw.unbindTexture2D(15)}generateMipmapsCube(e,t,n){const o=this.__glw.getRawContext(),a=this.getWebGLResource(e);this.__glw.bindTextureCube(15,a),o.generateMipmap(o.TEXTURE_CUBE_MAP),this.__glw.unbindTextureCube(15)}async getTexturePixelData(e,t,n,o,a){const i=this.__glw.getRawContext(),r=this.getWebGLResource(o);i.bindFramebuffer(i.FRAMEBUFFER,r);const s=new Uint8Array(t*n*4);return null!=i.readBuffer&&i.readBuffer(36064+a),i.readPixels(0,0,t,n,i.RGBA,i.UNSIGNED_BYTE,s),i.bindFramebuffer(i.FRAMEBUFFER,null),s}createUniformBuffer(e){const t=this.__glw.getRawContextAsWebGL2();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");const n=t.createBuffer(),o=this.__registerResource(n);return t.bindBuffer(t.UNIFORM_BUFFER,n),t.bufferData(t.UNIFORM_BUFFER,e,t.DYNAMIC_DRAW),t.bindBuffer(t.UNIFORM_BUFFER,null),o}updateUniformBuffer(e,t,n,o){const a=this.__glw.getRawContextAsWebGL2(),i=this.getWebGLResource(e);a.bindBuffer(a.UNIFORM_BUFFER,i),a.bufferSubData(a.UNIFORM_BUFFER,0,t,n,o),a.bindBuffer(a.UNIFORM_BUFFER,null)}bindUniformBlock(e,t,n){const o=this.__glw.getRawContextAsWebGL2();if(null==o)throw new Error("No WebGLRenderingContext set as Default.");const a=this.getWebGLResource(e),i=o.getUniformBlockIndex(a,t);o.uniformBlockBinding(a,i,n)}bindUniformBufferBase(e,t){const n=this.__glw.getRawContextAsWebGL2();if(null==n)throw new Error("No WebGLRenderingContext set as Default.");const o=this.getWebGLResource(t);n.bindBufferBase(n.UNIFORM_BUFFER,e,o)}deleteUniformBuffer(e){const t=this.__glw.getRawContext();null==t&&new Error("No WebGLRenderingContext set as Default.");const n=this.getWebGLResource(e);this.__webglResources.delete(e),t.deleteBuffer(n)}setupUniformBufferDataArea(e){const t=this.__glw.getRawContextAsWebGL2();null==t&&new Error("No WebGLRenderingContext set as Default.");const n=t.createBuffer(),o=this.__registerResource(n),a=this.__glw.getMaxConventionUniformBlocks(),i=this.__glw.getAlignedMaxUniformBlockSize(),r=new Float32Array(i*a/4);x.Is.exist(e)&&r.set(e.subarray(0,r.length)),t.bindBuffer(t.UNIFORM_BUFFER,n),t.bufferData(t.UNIFORM_BUFFER,r,t.DYNAMIC_DRAW,0,0);for(let e=0;e<a;e++)t.bindBufferRange(t.UNIFORM_BUFFER,e,n,i*e,i);return t.bindBuffer(t.UNIFORM_BUFFER,null),o}getGlslRenderTargetBeginString(e){let t="";for(let n=0;n<e;n++)t+=`layout(location = ${n}) out vec4 rt${n};`;return t}getGlslRenderTargetEndString(e){return""}getGlslDataUBODefinitionString(){let e="";const t=this.__glw.getMaxConventionUniformBlocks(),n=this.__glw.getAlignedMaxUniformBlockSize();for(let o=0;o<t;o++)e+=`\nlayout (std140) uniform Vec4Block${o} {\n  vec4 vec4Block${o}[${n/4/4}];\n};\n`;e+="\nvec4 fetchVec4FromVec4Block(int vec4Idx) {\n  int vec4IdxForEachBlock = vec4Idx % dataUBOVec4Size;\n  if (vec4Idx < dataUBOVec4Size) {\n    return vec4Block0[vec4IdxForEachBlock];\n  }";for(let n=1;n<t;n++)e+=`\n else if (vec4Idx < dataUBOVec4Size * ${n+1}) {\n    return vec4Block${n}[vec4IdxForEachBlock];\n}`;return e+="}\n",e}getGlslDataUBOVec4SizeString(){return`const int dataUBOVec4Size = ${this.__glw.getAlignedMaxUniformBlockSize()/4/4};`}createMultiviewFramebuffer(e,t,n){if(x.Is.not.exist(this.__glw.webgl2ExtMLTVIEW))return[-1,-1];const o=this.__glw.getRawContextAsWebGL2(),a=o.createFramebuffer(),i=this.__registerResource(a);o.bindFramebuffer(o.DRAW_FRAMEBUFFER,a);const r=o.createTexture(),s=this.__registerResource(r);o.bindTexture(o.TEXTURE_2D_ARRAY,r),o.texStorage3D(o.TEXTURE_2D_ARRAY,1,o.RGBA8,e,t,2),this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(o.DRAW_FRAMEBUFFER,o.COLOR_ATTACHMENT0,r,0,n,0,2):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(o.DRAW_FRAMEBUFFER,o.COLOR_ATTACHMENT0,r,0,0,2);const l=o.createTexture();return o.bindTexture(o.TEXTURE_2D_ARRAY,l),o.texStorage3D(o.TEXTURE_2D_ARRAY,1,o.DEPTH32F_STENCIL8,e,t,2),this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(o.DRAW_FRAMEBUFFER,o.DEPTH_STENCIL_ATTACHMENT,l,0,n,0,2):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(o.DRAW_FRAMEBUFFER,o.DEPTH_STENCIL_ATTACHMENT,l,0,0,2),[i,s]}createTransformFeedback(){const e=this.__glw.getRawContextAsWebGL2(),t=e.createTransformFeedback(),n=this.__registerResource(t);return e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,t),n}deleteTransformFeedback(e){const t=this.__glw.getRawContextAsWebGL2(),n=this.getWebGLResource(e);t.deleteTransformFeedback(n),this.__webglResources.delete(e)}setViewport(e){var t,n;e?(null===(t=this.__glw)||void 0===t||t.setViewportAsVector4(e),A.l.viewportAspectRatio=(e.z-e.x)/(e.w-e.y)):(null===(n=this.__glw)||void 0===n||n.setViewport(0,0,this.__glw.width,this.__glw.height),A.l.viewportAspectRatio=this.__glw.width/this.__glw.height)}clearFrameBuffer(e){const t=this.__glw.getRawContext();let n=0;e.toClearColorBuffer&&(t.clearColor(e.clearColor.x,e.clearColor.y,e.clearColor.z,e.clearColor.w),n|=t.COLOR_BUFFER_BIT),e.toClearDepthBuffer&&(t.clearDepth(e.clearDepth),n|=t.DEPTH_BUFFER_BIT),e.toClearStencilBuffer&&(t.clearStencil(e.clearStencil),n|=t.STENCIL_BUFFER_BIT),0!==n&&t.clear(n)}deleteVertexDataResources(e){const t=this.__glw.getRawContext(),n=e.iboHandle;if(n){const e=this.getWebGLResource(n);t.deleteBuffer(e),this.__webglResources.delete(n)}const o=e.vboHandles;for(const e of o){const n=this.getWebGLResource(e);t.deleteBuffer(n),this.__webglResources.delete(e)}const a=e.vaoHandle,i=this.getWebGLResource(a);this.__glw.deleteVertexArray(i),this.__webglResources.delete(a)}deleteVertexArray(e){const t=this.getWebGLResource(e);this.__glw.deleteVertexArray(t),this.__webglResources.delete(e)}deleteVertexBuffer(e){const t=this.__glw.getRawContext(),n=this.getWebGLResource(e);t.deleteBuffer(n),this.__webglResources.delete(e)}resizeCanvas(e,t){this.__glw.width=e,this.__glw.height=t,this.__glw.canvas.width=e,this.__glw.canvas.height=t,this.__glw.setViewportAsVector4(f.IU.fromCopyArray([0,0,e,t]))}getCanvasSize(){return[this.__glw.canvas.width,this.__glw.canvas.height]}switchDepthTest(e){const t=this.__glw.getRawContext();e?t.enable(t.DEPTH_TEST):t.disable(t.DEPTH_TEST)}rebuildProgramBySpector(e,t,n,o){const a=this._material.deref();if(x.Is.not.exist(a)){const e="Material Not found";return E.V.warn(e),o(e),!1}const i=A.l.currentProcessApproach,r=(0,g.A)(i),s=e.replace(/! =/g,"!="),l=t.replace(/! =/g,"!="),c=r._reSetupShaderForMaterialBySpector(a,this._primitive.deref(),{vertex:s,pixel:l},o);if(c<0)return!1;const _=N.getInstance().getWebGLResource(c);return c>0&&n(_),!0}getPixelDataFromTexture(e,t,n,o,a){const i=this.__glw.getRawContext(),r=new Uint8Array((o-t)*(a-n)*4),s=this.getWebGLResource(e),l=i.createFramebuffer();return i.bindFramebuffer(i.FRAMEBUFFER,l),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,s,0),i.readPixels(t,n,o,a,i.RGBA,i.UNSIGNED_BYTE,r),i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteFramebuffer(l),r}setWebGLStateToDefault(){const e=this.__glw.getRawContextAsWebGL2();e.bindBuffer(e.ARRAY_BUFFER,null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindVertexArray(null),e.clearColor(0,0,0,0),e.clearDepth(1),e.clearStencil(0),e.depthFunc(e.LESS),e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.SCISSOR_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.disable(e.CULL_FACE),e.frontFace(e.CCW),e.cullFace(e.BACK),e.blendColor(0,0,0,0),e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.stencilOpSeparate(e.FRONT,e.KEEP,e.KEEP,e.KEEP),e.stencilOpSeparate(e.BACK,e.KEEP,e.KEEP,e.KEEP),e.stencilFuncSeparate(e.FRONT,e.ALWAYS,0,4294967295),e.stencilFuncSeparate(e.BACK,e.ALWAYS,0,4294967295),e.stencilMaskSeparate(e.FRONT,4294967295),e.stencilMaskSeparate(e.BACK,4294967295),e.colorMask(!0,!0,!0,!0),e.depthMask(!0),e.sampleCoverage(1,!1);for(let t=0;t<16;t++)e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null),e.bindTexture(e.TEXTURE_CUBE_MAP,null),e.bindSampler(t,null)}unbindTextureSamplers(){const e=this.__glw.getRawContextAsWebGL2();for(let t=0;t<16;t++)e.bindSampler(t,null)}isSupportMultiViewVRRendering(){return A.l.currentProcessApproach===C.m.DataTexture&&this.__glw.isMultiview()}blitToTexture2dFromTexture2dArray(e,t,n,o){const a=this.__glw.getRawContextAsWebGL2(),i=this.getWebGLResource(e),r=this.getWebGLResource(t);a.bindFramebuffer(a.DRAW_FRAMEBUFFER,r),w.getInstance(a).blit(i,0,0,1,1,n,o),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}blitToTexture2dFromTexture2dArrayFake(e,t,n,o){const a=this.__glw.getRawContextAsWebGL2(),i=this.getWebGLResource(e),r=this.getWebGLResource(t);a.bindFramebuffer(a.DRAW_FRAMEBUFFER,r),w.getInstance(a).blitFake(i,0,0,1,1,n,o),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}blitToTexture2dFromTexture2dArray2(e,t,n,o){const a=this.__glw.getRawContextAsWebGL2(),i=this.getWebGLResource(e),r=this.getWebGLResource(t);w.getInstance(a).blit2(i,r,n,o)}}},4034:(e,t,n)=>{n.d(t,{A:()=>E,H:()=>A});var o=n(6338),a=n(3583),i=n(700),r=n(7751),s=n(4114),l=n(4132),c=n(9011),_=n(975);let u,f,d,h,m,p,v,x=!1,g=!0,y=!0,b=!1,I=[!0,!0,!0,!0];function A(e,t,n){if(null!=e&&!e.isShaderProgramReady(t))try{null==t||t._backupMaterial(),n.setupShaderForMaterial(e,t)}catch(o){console.log(o),null==t||t._restoreMaterial(),n.setupShaderForMaterial(e,t)}}const E=Object.freeze({setWebGLParameters:function(e,t){!function(e,t){const n=e.cullFace,o=e.cullFrontFaceCCW,a=e.cullFaceBack;x!==n&&(n?t.enable(t.CULL_FACE):t.disable(t.CULL_FACE),x=n),!0===n&&g!==o&&(o?t.frontFace(t.CCW):t.frontFace(t.CW),g=o),a!==y&&(a?t.cullFace(t.BACK):t.cullFace(t.FRONT),y=a)}(e,t),function(e,t){const n=e.isBlend();u!==n&&(n?t.enable(t.BLEND):t.disable(t.BLEND),u=n),e.alphaMode===o.K.Blend&&(function(e,t,n){(f!==e||d!==t)&&(n.blendEquationSeparate(e,t),f=e,d=t)}(e.blendEquationMode.index,e.blendEquationModeAlpha.index,t),function(e,t,n,o,a){(h!==e||m!==t||p!==n||v!==o)&&(a.blendFuncSeparate(e,t,n,o),h=e,m=t,p=n,v=o)}(e.blendFuncSrcFactor.index,e.blendFuncDstFactor.index,e.blendFuncAlphaSrcFactor.index,e.blendFuncAlphaDstFactor.index,t))}(e,t),function(e,t){const n=e.alphaToCoverage;n!==b&&(n?t.enable(t.SAMPLE_ALPHA_TO_COVERAGE):t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),b=n)}(e,t),function(e,t){const n=e.colorWriteMask;n[0]===I[0]&&n[1]===I[1]&&n[2]===I[2]&&n[3]===I[3]||(t.colorMask(n[0],n[1],n[2],n[3]),I=n)}(e,t)},setVRViewport:function(e,t){const n=i.u.getInstance(),o=a.e.getInstance().getModule("xr").WebXRSystem.getInstance();o.isWebXRMode&&n.setViewport(o._getViewportAt(t))},getDisplayCount:function(e,t){return t.isWebXRMode?t.isMultiView()?1:e?2:1:1},isVrMainPass:function(e){const t=a.e.getInstance().getModule("xr");return(null==t?void 0:t.WebXRSystem.getInstance().isWebXRMode)&&e.isVrRendering},getPointSpriteShaderSemanticsInfoArray:function(){return[{semantic:"pointSize",compositionType:r.h.Scalar,componentType:s.I.Float,stage:l.C.PixelShader,initialValue:c.X5.fromCopyNumber(30),min:0,max:Number.MAX_VALUE,isInternalSetting:!1},{semantic:"pointDistanceAttenuation",compositionType:r.h.Vec3,componentType:s.I.Float,stage:l.C.PixelShader,initialValue:_.Pq.fromCopyArray([0,.1,.01]),min:0,max:1,isInternalSetting:!1}]}})},8767:(e,t,n)=>{n.d(t,{_:()=>D});var o=n(700),a=n(7496),i=n(4958),r=n(4114),s=n(7616),l=n(9447),c=n(960),_=n(4772),u=n(8374),f=n(7751),d=n(8621),h=n(4317),m=n(2805),p=n(6737),v=n(5338),x=n(7295),g=n(3107),y=n(4289),b=n(7681),I=n(4034),A=n(3583),E=n(2229),S=n(6235),T=n(7488),w=n(8909),C=n(4415),R=n(1823),P=n(7566),N=n(8393),M=n(3497);class D{constructor(){this.__webglResourceRepository=o.u.getInstance(),this.__dataTextureUid=_.f.InvalidCGAPIResourceUid,this.__dataUBOUid=_.f.InvalidCGAPIResourceUid,this.__lastShader=_.f.InvalidCGAPIResourceUid,this.__lastMaterialStateVersion=-1,this.__lastRenderPassTickCount=-1,this._totalSizeOfGPUShaderDataStorageExceptMorphData=0,this.__lastMaterialsUpdateCount=-1,this.__lastTransformComponentsUpdateCount=-1,this.__lastSceneGraphComponentsUpdateCount=-1,this.__lastCameraComponentsUpdateCount=-1,this.__lastCameraControllerComponentsUpdateCount=-1}static dumpDataTextureBuffer(){this.__isDebugOperationToDataTextureBufferDone=!1}static getVertexShaderMethodDefinitions_dataTexture(){return`\n\n  mat4 get_worldMatrix(float instanceId)\n  {\n    int index = ${d.u.getLocationOffsetOfMemberOfComponent(h.K,"worldMatrix")} + 4 * int(instanceId);\n    mat4 matrix = fetchMat4(index);\n\n    return matrix;\n  }\n\n\n  mat3 get_normalMatrix(float instanceId) {\n    int index = ${d.u.getLocationOffsetOfMemberOfComponent(h.K,"normalMatrix")} * 4 + 9 * int(instanceId);\n    mat3 matrix = fetchMat3No16BytesAligned(index);\n    return matrix;\n  }\n\n  bool get_isVisible(float instanceId) {\n    int index = ${d.u.getLocationOffsetOfMemberOfComponent(h.K,"isVisible")} * 4 + int(instanceId);\n    float visibility = fetchScalarNo16BytesAligned(index);\n    return (visibility > 0.5) ? true : false;\n  }\n\n  bool get_isBillboard(float instanceId) {\n    int index = ${d.u.getLocationOffsetOfMemberOfComponent(h.K,"isBillboard")} * 4 + int(instanceId);\n    float isBillboard = fetchScalarNo16BytesAligned(index);\n    return (isBillboard > 0.5) ? true : false;\n  }\n\n#ifdef RN_IS_VERTEX_SHADER\n  #ifdef RN_IS_MORPHING\n  vec3 get_position(float vertexId, vec3 basePosition) {\n    vec3 position = basePosition;\n    int scalar_idx = 3 * int(vertexId);\n    for (int i=0; i<${v.T.maxVertexMorphNumberInShader}; i++) {\n\n      int basePosIn4bytes = u_dataTextureMorphOffsetPosition[i] * 4 + scalar_idx;\n      vec3 addPos = fetchVec3No16BytesAligned(basePosIn4bytes);\n\n      position += addPos * u_morphWeights[i];\n      if (i == u_morphTargetNumber-1) {\n        break;\n      }\n    }\n\n    return position;\n  }\n  #endif\n#endif\n`}setupShaderForMaterial(e,t){const n=o.u.getInstance().currentWebGLContextWrapper,[a,i]=e._createProgramWebGL(D.getVertexShaderMethodDefinitions_dataTexture(),D.__getShaderProperty,t,n.isWebGL2);return i&&(e._setupBasicUniformsLocations(t),e._setUniformLocationsOfMaterialNodes(!1,t),e._setupAdditionalUniformLocations(I.A.getPointSpriteShaderSemanticsInfoArray(),!1,t),D.__globalDataRepository._setUniformLocationsForDataTextureModeOnly(e.getShaderProgramUid(t))),a}_reSetupShaderForMaterialBySpector(e,t,n,o){const[a,i]=e._createProgramByUpdatedSources(n,t,o);return a===_.f.InvalidCGAPIResourceUid||(i&&(e._setupBasicUniformsLocations(t),e._setUniformLocationsOfMaterialNodes(!1,t),e._setupAdditionalUniformLocations(I.A.getPointSpriteShaderSemanticsInfoArray(),!1,t)),D.__globalDataRepository._setUniformLocationsForDataTextureModeOnly(e.getShaderProgramUid(t))),a}static __getShaderProperty(e,t,n,o){var a,i;const s=t.compositionType.getGlslStr(t.componentType);let l;const c=f.h.isTexture(t.compositionType),_=t.semantic.replace(".","_");let u="";const d=t.compositionType.getGlslStr(t.componentType);let h="";t.arrayLength&&(h=`[${t.arrayLength}]`),(t.needUniformInDataTextureMode||c)&&(u=`  uniform ${d} u_${_}${h};\n`);const m=t.compositionType.getVec4SizeOfProperty(),p=t.compositionType.getNumberOfComponents(),v=D.getOffsetOfPropertyInShader(n,t.semantic,e);-1===v&&M.V.error("Could not get the location offset of the property.");let x=m;l=`int vec4_idx = ${v} + ${x} * instanceId;\n`,f.h.isArray(t.compositionType)&&(x=m*(null!==(a=t.arrayLength)&&void 0!==a?a:1),l=`int vec4_idx = ${v} + ${x} * instanceId + ${m} * idxOfArray;\n`,l+=`int scalar_idx = ${4*v} + ${4*Math.ceil(p/4)*(null!==(i=t.arrayLength)&&void 0!==i?i:1)} * instanceId + ${p} * idxOfArray;\n`);let g="";t.componentType===r.I.Int&&t.compositionType!==f.h.Scalar&&(g="i");let y="";if(c||t.needUniformInDataTextureMode){if(!c&&t.needUniformInDataTextureMode){if(!o&&t.arrayLength)return`\n${u}\n`;{let e="";return t.arrayLength&&(e="[idxOfArray]"),`${u}\n${s} get_${_}(highp float _instanceId, const int idxOfArray) {\n  return u_${_}${e};\n}\n`}}return u}{y+=`\n${s} get_${_}(highp float _instanceId, const int idxOfArray) {\n  int instanceId = int(_instanceId);\n  ${l}\n  `;let e=`${u}\n${y}`;switch(t.compositionType){case f.h.Vec4:case f.h.Vec4Array:e+="        highp vec4 val = fetchElement(vec4_idx);\n";break;case f.h.Vec3:e+="        vec4 col0 = fetchElement(vec4_idx);\n",e+=`        highp ${g}vec3 val = ${g}vec3(col0.xyz);`;break;case f.h.Vec3Array:e+="        vec3 val = fetchVec3No16BytesAligned(scalar_idx);\n";break;case f.h.Vec2:e+="        highp vec4 col0 = fetchElement(vec4_idx);\n",e+=`        highp ${g}vec2 val = ${g}vec2(col0.xy);`;break;case f.h.Vec2Array:e+="        highp vec2 val = fetchVec2No16BytesAligned(scalar_idx);\n";break;case f.h.Scalar:e+="        vec4 col0 = fetchElement(vec4_idx);\n",t.componentType===r.I.Int?e+="        int val = int(col0.x);":t.componentType===r.I.Bool?e+="        bool val = bool(col0.x);":e+="       float val = col0.x;";break;case f.h.ScalarArray:e+="        float col0 = fetchScalarNo16BytesAligned(scalar_idx);\n",t.componentType===r.I.Int?e+="        int val = int(col0);":t.componentType===r.I.Bool?e+="        bool val = bool(col0);":e+="       float val = col0;";break;case f.h.Mat4:case f.h.Mat4Array:e+="        mat4 val = fetchMat4(vec4_idx);\n";break;case f.h.Mat3:e+="        mat3 val = fetchMat3(vec4_idx);\n";break;case f.h.Mat3Array:e+="        mat3 val = fetchMat3No16BytesAligned(scalar_idx);\n";break;case f.h.Mat2:e+="        mat2 val = fetchMat2(vec4_idx);\n";break;case f.h.Mat2Array:e+="        mat2 val = fetchMat2No16BytesAligned(scalar_idx);\n";break;case f.h.Mat4x3Array:e+="        mat4x3 val = fetchMat4x3(vec4_idx);\n";break;default:e+=""}return e+="\n  return val;\n}\n",e}}static getOffsetOfPropertyInShader(e,t,n){return e?g.q.getInstance().getLocationOffsetOfProperty(t):T.s.getLocationOffsetOfMemberOfMaterial(n,t)}$load(e){const t=e.mesh;return null==t?(l.F.alertNoMeshSet(e),!1):(D.__currentComponentSIDs=D.__globalDataRepository.getValue("currentComponentSIDs",0),t.isSetUpDone()||(this.deleteDataTexture(),(0,w.I)(t)),!0)}__createAndUpdateDataTexture(){this.__createAndUpdateDataTextureInner()}__createAndUpdateDataTextureForCameraOnly(){const e=16*g.q.getInstance().getLocationOffsetOfProperty("boneMatrix");this.__createAndUpdateDataTextureInner(e)}__createAndUpdateDataTextureInner(e){const t=a.X.getInstance(),n=t.getBuffer(s.a.GPUInstanceData),o=this.__webglResourceRepository.currentWebGLContextWrapper.getAlignedMaxUniformBlockSize(),l=this.__isUboUse()?o:0;if(null==n)return;const c=a.X.bufferWidthLength*a.X.bufferHeightLength*4*4;if(this.__dataTextureUid!==_.f.InvalidCGAPIResourceUid){const t=(null!=e?e:n.takenSizeInByte)-l,o=Math.min(Math.ceil(t/a.X.bufferWidthLength/4/4),a.X.bufferHeightLength),s=a.X.bufferWidthLength*o*4*4;t>c&&M.V.warn("The buffer size exceeds the size of the data texture.");const _=new Float32Array(n.getArrayBuffer(),l,s/4);this.__webglResourceRepository.updateTexture(this.__dataTextureUid,_,{level:0,xoffset:0,yoffset:0,width:a.X.bufferWidthLength,height:o,format:i.A.RGBA,type:r.I.Float}),D.__isDebugOperationToDataTextureBufferDone||(b.zH.downloadTypedArray("Rhodonite_dataTextureBuffer.bin",_),D.__isDebugOperationToDataTextureBufferDone=!0)}else{const e=t.getBuffer(s.a.GPUVertexData);let o,_=0,u=new ArrayBuffer(0);E.Is.exist(e)&&(_=e.takenSizeInByte,u=e.getArrayBuffer());{const e=t.getBuffer(s.a.GPUVertexData);let i=0;E.Is.exist(e)&&(i=e.takenSizeInByte);let r=new ArrayBuffer(0);E.Is.exist(e)&&(r=e.getArrayBuffer());const _=n.takenSizeInByte-l,u=4*(a.X.bufferWidthLength-_/4/4%a.X.bufferWidthLength)*4,f=b.zH.concatArrayBuffers2({finalSize:c,srcs:[n.getArrayBuffer(),r],srcsCopySize:[_+u,i],srcsOffset:[l,0]});_+u+i>c&&M.V.warn("The buffer size exceeds the size of the data texture."),o=new Float32Array(f),v.T.totalSizeOfGPUShaderDataStorageExceptMorphData=n.takenSizeInByte+u}this.__dataTextureUid=this.__webglResourceRepository.createTextureFromTypedArray(o,{level:0,internalFormat:N.n.RGBA32F,width:a.X.bufferWidthLength,height:a.X.bufferHeightLength,border:0,format:i.A.RGBA,type:r.I.Float,generateMipmap:!1})}}deleteDataTexture(){null!=this.__dataTextureUid&&(this.__webglResourceRepository.deleteTexture(this.__dataTextureUid),this.__dataTextureUid=_.f.InvalidCGAPIResourceUid)}prerender(){P.C.isAnimating||R.W.updateCount!==this.__lastTransformComponentsUpdateCount||h.K.updateCount!==this.__lastSceneGraphComponentsUpdateCount||u.i.stateVersion!==this.__lastMaterialsUpdateCount?(this.__createAndUpdateDataTexture(),this.__createAndUpdateUBO(),this.__lastTransformComponentsUpdateCount=R.W.updateCount,this.__lastSceneGraphComponentsUpdateCount=h.K.updateCount,this.__lastMaterialsUpdateCount=u.i.stateVersion):x.n.currentCameraUpdateCount===this.__lastCameraComponentsUpdateCount&&C.v.updateCount===this.__lastCameraControllerComponentsUpdateCount||(this.__createAndUpdateDataTextureForCameraOnly(),this.__lastCameraComponentsUpdateCount=x.n.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=C.v.updateCount),this.__lightComponents=p.O.getComponentsWithType(S.M)}__isUboUse(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2&&v.T.isUboEnabled}__createAndUpdateUBO(){if(this.__isUboUse()){const e=this.__webglResourceRepository.currentWebGLContextWrapper,t=e.getAlignedMaxUniformBlockSize(),n=e.getMaxConventionUniformBlocks(),o=a.X.getInstance().getBuffer(s.a.GPUInstanceData);if(this.__dataUBOUid===_.f.InvalidCGAPIResourceUid)this.__dataUBOUid=this.__webglResourceRepository.setupUniformBufferDataArea(new Float32Array(o.getArrayBuffer()));else{const e=new Float32Array(o.getArrayBuffer());this.__webglResourceRepository.updateUniformBuffer(this.__dataUBOUid,e,0,t*n/4)}}}attachGPUData(e){}attachGPUDataInner(e,t){}attachVertexData(e,t,n,o){}attachVertexDataInner(e,t,n,o,a){const i=t.vertexHandles,r=o.getRawContext(),s=this.__webglResourceRepository.getWebGLResource(e.getVaoUids(n));if(null!=s)o.bindVertexArray(s);else{this.__webglResourceRepository.setVertexDataToPipeline(i,t,e._variationVBOUid);const n=this.__webglResourceRepository.getWebGLResource(i.iboHandle);r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,n)}}static getInstance(){if(!this.__instance){this.__instance=new D;const e=A.e.getInstance().getModule("xr").WebXRSystem.getInstance();D.__webxrSystem=e}return this.__instance}__setCurrentComponentSIDsForEachDisplayIdx(e,t,n){if(n){let e=-1;const n=D.__webxrSystem;n.isWebXRMode&&(e=n.isMultiView()?n._getCameraComponentSIDAt(0):n._getCameraComponentSIDAt(t)),D.__currentComponentSIDs._v[y.N.CameraComponentTID]=e}else{let t=e.cameraComponent;null==t&&(t=p.O.getComponent(x.n,x.n.current)),D.__currentComponentSIDs._v[y.N.CameraComponentTID]=t?t.componentSID:-1}}__setCurrentComponentSIDsForEachPrimitive(e,t,n){null==D.__currentComponentSIDs&&(D.__currentComponentSIDs=D.__globalDataRepository.getValue("currentComponentSIDs",0)),D.__currentComponentSIDs._v[0]=t.materialSID}common_$render(e,t,n){"undefined"!=typeof spector&&spector.setMarker("|  |  DataTexture:common_$render#");const o=this.__webglResourceRepository.currentWebGLContextWrapper,a=o.getRawContextAsWebGL2();if(t.isBufferLessRenderingMode())return this.__renderWithoutBuffers(a,t),!0;let i=!1;if(t._toRenderOpaquePrimitives){t.depthWriteMask||a.depthMask(!1);for(let n=0;n<=t._lastOpaqueIndex;n++){const a=e[n],r=this.__renderInner(a,o,t);i||(i=r)}}if(t._toRenderTranslucentPrimitives)for(let n=t._lastOpaqueIndex+1;n<=t._lastTranslucentIndex;n++){const a=e[n],r=this.__renderInner(a,o,t);i||(i=r)}if(t._toRenderBlendWithZWritePrimitives)for(let n=t._lastTranslucentIndex+1;n<=t._lastBlendWithZWriteIndex;n++){const a=e[n],r=this.__renderInner(a,o,t);i||(i=r)}if(t._toRenderBlendWithoutZWritePrimitives){m.e.isDepthMaskTrueForBlendPrimitives||a.depthMask(!1);for(let n=t._lastBlendWithZWriteIndex+1;n<=t._lastBlendWithoutZWriteIndex;n++){const a=e[n],r=this.__renderInner(a,o,t);i||(i=r)}}return a.depthMask(!0),this.__lastRenderPassTickCount=n,i}__renderWithoutBuffers(e,t){const n=t.material,o=t._dummyPrimitiveForBufferLessRendering;(0,I.H)(n,o,this);const a=n.getShaderProgramUid(o),i=this.__webglResourceRepository.getWebGLResource(a);e.useProgram(i),this.__lastShader=a,this.bindDataTexture(e,i),this.__setCurrentComponentSIDsForEachPrimitive(e,n,i),e.uniform1fv(i.currentComponentSIDs,D.__currentComponentSIDs._v);const r=I.A.isVrMainPass(t);if(null!=i.vrState&&r){const e=g.q.getInstance().getValue("vrState",0);e._v[0]=r?1:0,e._v[1]=0,i._gl.uniform2iv(i.vrState,e._v)}I.A.setWebGLParameters(n,e),n._setParametersToGpuWebGLWithOutInternalSetting({shaderProgram:i,firstTime:!0,isUniformMode:!1}),t.depthWriteMask?e.depthMask(!0):e.depthMask(!1),this.__webglResourceRepository.setViewport(t.getViewport()),e.drawArrays(t._primitiveModeForBufferLessRendering.index,0,t._drawVertexNumberForBufferLessRendering)}__renderInner(e,t,n){var o;const a=t.getRawContextAsWebGL2(),i=c.s.getPrimitive(e);if(null==i)return!1;const r=i.mesh,s=r.meshEntitiesInner[0],l=n.getAppropriateMaterial(i);(0,I.H)(l,i,this);const _=s.getMeshRenderer(),u=r.getPrimitiveIndexInMesh(i);this.attachVertexDataInner(r,i,u,t,r._variationVBOUid);let f=!1;const d=l.getShaderProgramUid(i);if(d!==this.__lastShader||a.__changedProgram){if((0,w.M)(l,i))return!1;const e=this.__webglResourceRepository.getWebGLResource(d);a.useProgram(e),a.__changedProgram=!1,this.bindDataTexture(a,e),D.__shaderProgram=e,f=!0}(null===(o=this.__lastMaterial)||void 0===o?void 0:o.deref())!==l&&(f=!0,this.__lastMaterial=new WeakRef(l)),this.__lastMaterialStateVersion!==l.stateVersion&&(f=!0,this.__lastMaterialStateVersion=l.stateVersion);const h=I.A.isVrMainPass(n),m={glw:t,entity:s,worldMatrix:s.getSceneGraph().matrixInner,normalMatrix:s.getSceneGraph().normalMatrixInner,isBillboard:s.getSceneGraph().isBillboard,lightComponents:this.__lightComponents,renderPass:n,primitive:i,diffuseCube:_.diffuseCubeMap,specularCube:_.specularCubeMap,setUniform:!1,isVr:h,displayIdx:-1};f&&(this.__setCurrentComponentSIDsForEachPrimitive(a,l,D.__shaderProgram),I.A.setWebGLParameters(l,a),l._setParametersToGpuWebGL({material:l,shaderProgram:D.__shaderProgram,firstTime:f,args:m})),l._setParametersToGpuWebGLPerPrimitive({material:l,shaderProgram:D.__shaderProgram,firstTime:f,args:m});const p=I.A.getDisplayCount(h,D.__webxrSystem);for(let e=0;e<p;e++){if(h&&I.A.setVRViewport(n,e),this.__setCurrentComponentSIDsForEachDisplayIdx(n,e,h),a.uniform1fv(D.__shaderProgram.currentComponentSIDs,D.__currentComponentSIDs._v),null!=D.__shaderProgram.vrState&&h&&p>1){const t=g.q.getInstance().getValue("vrState",0);t._v[0]=h?1:0,t._v[1]=e,D.__shaderProgram._gl.uniform2iv(D.__shaderProgram.vrState,t._v)}i.indicesAccessor?a.drawElementsInstanced(i.primitiveMode.index,i.indicesAccessor.elementCount,i.indicesAccessor.componentType.index,0,r.meshEntitiesInner.length):a.drawArraysInstanced(i.primitiveMode.index,0,i.getVertexCountAsVerticesBased(),r.meshEntitiesInner.length)}return this.__lastShader=d,!0}bindDataTexture(e,t){e.uniform1i(t.dataTexture,7),this.__webglResourceRepository.bindTexture2D(7,this.__dataTextureUid);const n=this.__webglResourceRepository.createOrGetTextureSamplerRepeatNearest();this.__webglResourceRepository.bindTextureSampler(7,n)}}D.__globalDataRepository=g.q.getInstance(),D.__isDebugOperationToDataTextureBufferDone=!0},3296:(e,t,n)=>{n.d(t,{n:()=>T});var o=n(700),a=n(960),i=n(4772),r=n(9871),s=n(6737),l=n(6235),c=n(5338),_=n(4958),u=n(4114),f=n(2805),d=n(7751),h=n(7496),m=n(4132),p=n(7616),v=n(3107),x=n(7681),g=n(4034),y=n(2229),b=n(8909),I=n(3583),A=n(7566),E=n(8393),S=n(3497);class T{constructor(){this.__webglResourceRepository=o.u.getInstance(),this.__dataTextureUid=i.f.InvalidCGAPIResourceUid,this.__lastShader=-1,this.__lastRenderPassTickCount=-1}setupShaderForMaterial(e,t){const n=o.u.getInstance().currentWebGLContextWrapper,[a,i]=e._createProgramWebGL(T.__vertexShaderMethodDefinitions_uniform,r.lk.getShaderProperty,t,n.isWebGL2);if(i){e._setupBasicUniformsLocations(t),e._setUniformLocationsOfMaterialNodes(!0,t);const n=T.componentMatrices,o=g.A.getPointSpriteShaderSemanticsInfoArray();e._setupAdditionalUniformLocations(n.concat(o),!0,t),T.__globalDataRepository._setUniformLocationsForUniformModeOnly(e.getShaderProgramUid(t))}return a}_reSetupShaderForMaterialBySpector(e,t,n,o){const[a,r]=e._createProgramByUpdatedSources(n,t,o);if(a===i.f.InvalidCGAPIResourceUid)return a;if(r){e._setupBasicUniformsLocations(t),e._setUniformLocationsOfMaterialNodes(!0,t);const n=T.componentMatrices,o=g.A.getPointSpriteShaderSemanticsInfoArray();e._setupAdditionalUniformLocations(n.concat(o),!0,t)}return T.__globalDataRepository._setUniformLocationsForUniformModeOnly(e.getShaderProgramUid(t)),a}$load(e){const t=e.mesh;return!!y.Is.exist(t)&&(t.isSetUpDone()||(0,b.I)(t),!0)}prerender(){if(this.__lightComponents=s.O.getComponentsWithType(l.M),this.__dataTextureUid===i.f.InvalidCGAPIResourceUid){const e=h.X.getInstance().getBuffer(p.a.GPUVertexData);if(null==e)return;e.takenSizeInByte/h.X.bufferWidthLength/4>h.X.bufferHeightLength&&S.V.warn("The buffer size exceeds the size of the data texture.");const t=h.X.bufferWidthLength*h.X.bufferHeightLength*4*4,n=x.zH.concatArrayBuffers2({finalSize:t,srcs:[e.getArrayBuffer()],srcsCopySize:[e.takenSizeInByte],srcsOffset:[0]}),o=new Float32Array(n);this.__dataTextureUid=this.__webglResourceRepository.createTextureFromTypedArray(o,{level:0,internalFormat:E.n.RGBA32F,width:h.X.bufferWidthLength,height:h.X.bufferHeightLength,border:0,format:_.A.RGBA,type:u.I.Float,generateMipmap:!1})}}attachGPUData(e){}attachVertexData(e,t,n,o){}attachVertexDataInner(e,t,n,o,a){const i=t.vertexHandles,r=this.__webglResourceRepository.getWebGLResource(e.getVaoUidsByPrimitiveUid(n)),s=o.getRawContext();if(null!=r)o.bindVertexArray(r);else{this.__webglResourceRepository.setVertexDataToPipeline(i,t,a);const e=this.__webglResourceRepository.getWebGLResource(i.iboHandle);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,e)}}dettachVertexData(e){const t=e.getRawContext();e.bindVertexArray&&e.bindVertexArray(null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.bindBuffer(t.ARRAY_BUFFER,null)}static getInstance(){if(!this.__instance){this.__instance=new T;const e=I.e.getInstance().getModule("xr").WebXRSystem.getInstance();T.__webxrSystem=e}return this.__instance}common_$render(e,t,n){"undefined"!=typeof spector&&spector.setMarker("|  |  Uniform:$render#");const o=this.__webglResourceRepository.currentWebGLContextWrapper,a=o.getRawContextAsWebGL2();if(t.isBufferLessRenderingMode())return this.__renderWithoutBuffers(a,t),!0;let i=!1;if(t._toRenderOpaquePrimitives){t.depthWriteMask||a.depthMask(!1);for(let a=0;a<=t._lastOpaqueIndex;a++){const r=e[a],s=this.renderInner(r,o,t,n);i||(i=s)}}if(t._toRenderTranslucentPrimitives)for(let a=t._lastOpaqueIndex+1;a<=t._lastTranslucentIndex;a++){const r=e[a],s=this.renderInner(r,o,t,n);i||(i=s)}if(t._toRenderBlendWithZWritePrimitives)for(let a=t._lastTranslucentIndex+1;a<=t._lastBlendWithZWriteIndex;a++){const r=e[a],s=this.renderInner(r,o,t,n);i||(i=s)}if(t._toRenderBlendWithoutZWritePrimitives){f.e.isDepthMaskTrueForBlendPrimitives||a.depthMask(!1);for(let a=t._lastBlendWithZWriteIndex+1;a<=t._lastBlendWithoutZWriteIndex;a++){const r=e[a],s=this.renderInner(r,o,t,n);i||(i=s)}}return a.depthMask(!0),this.__webglResourceRepository.unbindTextureSamplers(),i}__renderWithoutBuffers(e,t){const n=t.material,o=t._dummyPrimitiveForBufferLessRendering;(0,g.H)(n,o,this);const a=n.getShaderProgramUid(o),i=this.__webglResourceRepository.getWebGLResource(a);e.useProgram(i),this.__lastShader=a,this.bindDataTexture(e,i),g.A.setWebGLParameters(n,e),n._setParametersToGpuWebGLWithOutInternalSetting({shaderProgram:i,firstTime:!0,isUniformMode:!0});const r=g.A.isVrMainPass(t);if(null!=i.vrState&&r){const e=v.q.getInstance().getValue("vrState",0);e._v[0]=r?1:0,e._v[1]=0,i._gl.uniform2iv(i.vrState,e._v)}t.depthWriteMask?e.depthMask(!0):e.depthMask(!1),this.__webglResourceRepository.setViewport(t.getViewport()),e.drawArrays(t._primitiveModeForBufferLessRendering.index,0,t._drawVertexNumberForBufferLessRendering)}renderInner(e,t,n,o){var r,s,l;const c=t.getRawContext(),_=a.s.getPrimitive(e);if(null==_)return!1;const u=n.getAppropriateMaterial(_);(0,g.H)(u,_,this);const f=_.mesh.meshEntitiesInner;let d=!1;const h=g.A.isVrMainPass(n),m=g.A.getDisplayCount(h,T.__webxrSystem);for(const o of f){if(o.getSceneGraph()._isCulled)continue;const a=o.getMesh();this.attachVertexDataInner(a.mesh,_,e,t,i.f.InvalidCGAPIResourceUid);const f=u.getShaderProgramUid(_),p=this.__webglResourceRepository.getWebGLResource(f);let x=!0;if(f!==this.__lastShader||c.__changedProgram){if((0,b.M)(u,_))return!1;if(x=!0,c.__changedProgram=!1,c.useProgram(p),this.bindDataTexture(c,p),A.C.isAnimating){const e=v.q.getInstance().getValue("time",0);p._gl.uniform1f(p.time,e._v[0])}this.__lastShader=f}(null===(r=this.__lastMaterial)||void 0===r?void 0:r.deref())!==u&&(x=!0,this.__lastMaterial=new WeakRef(u));for(let e=0;e<m;e++){h&&g.A.setVRViewport(n,e);const a={setUniform:!0,glw:t,entity:o,primitive:_,worldMatrix:o.getSceneGraph().matrix,normalMatrix:o.getSceneGraph().normalMatrix,isBillboard:o.getSceneGraph().isBillboard,lightComponents:this.__lightComponents,renderPass:n,diffuseCube:null===(s=o.tryToGetMeshRenderer())||void 0===s?void 0:s.diffuseCubeMap,specularCube:null===(l=o.tryToGetMeshRenderer())||void 0===l?void 0:l.specularCubeMap,isVr:h,displayIdx:e};if(x&&(g.A.setWebGLParameters(u,c),u._setParametersToGpuWebGL({material:u,shaderProgram:p,firstTime:x,args:a})),u._setParametersToGpuWebGLPerPrimitive({material:u,shaderProgram:p,firstTime:x,args:a}),null!=p.vrState&&h){const t=v.q.getInstance().getValue("vrState",0);t._v[0]=h?1:0,t._v[1]=e,p._gl.uniform2iv(p.vrState,t._v)}_.indicesAccessor?c.drawElements(_.primitiveMode.index,_.indicesAccessor.elementCount,_.indicesAccessor.componentType.index,0):c.drawArrays(_.primitiveMode.index,0,_.getVertexCountAsVerticesBased())}d=!0}return d}bindDataTexture(e,t){e.uniform1i(t.dataTexture,7),this.__webglResourceRepository.bindTexture2D(7,this.__dataTextureUid);const n=this.__webglResourceRepository.createOrGetTextureSamplerRepeatNearest();this.__webglResourceRepository.bindTextureSampler(7,n)}}T.__globalDataRepository=v.q.getInstance(),T.componentMatrices=[{semantic:"vertexAttributesExistenceArray",compositionType:d.h.ScalarArray,componentType:u.I.Int,stage:m.C.VertexShader,min:0,max:1,isInternalSetting:!0},{semantic:"worldMatrix",compositionType:d.h.Mat4,componentType:u.I.Float,stage:m.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0},{semantic:"normalMatrix",compositionType:d.h.Mat3,componentType:u.I.Float,stage:m.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0},{semantic:"isBillboard",compositionType:d.h.Scalar,componentType:u.I.Bool,stage:m.C.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0}],T.__vertexShaderMethodDefinitions_uniform=`uniform mat4 u_worldMatrix;\nuniform mat3 u_normalMatrix;\nuniform bool u_isBillboard;\n\nmat4 get_worldMatrix(float instanceId) {\n  return u_worldMatrix;\n}\n\nmat3 get_normalMatrix(float instanceId) {\n  return u_normalMatrix;\n}\n\nbool get_isVisible(float instanceId) {\n  return true; // visibility is handled in CPU side in WebGLStrategyUniform, so this is dummy value.\n}\n\nbool get_isBillboard(float instanceId) {\n  return u_isBillboard;\n}\n\n#ifdef RN_IS_VERTEX_SHADER\n# ifdef RN_IS_MORPHING\n  vec3 get_position(float vertexId, vec3 basePosition) {\n    vec3 position = basePosition;\n    int scalar_idx = 3 * int(vertexId);\n    #ifdef GLSL_ES3\n      int posIn4bytes = scalar_idx % 4;\n    #else\n      int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n    #endif\n    for (int i=0; i<${c.T.maxVertexMorphNumberInShader}; i++) {\n\n      int basePosIn16bytes = u_dataTextureMorphOffsetPosition[i] + (scalar_idx - posIn4bytes)/4;\n\n      vec3 addPos = vec3(0.0);\n      if (posIn4bytes == 0) {\n        vec4 val = fetchElement(basePosIn16bytes);\n        addPos = val.xyz;\n      } else if (posIn4bytes == 1) {\n        vec4 val0 = fetchElement(basePosIn16bytes);\n        addPos = vec3(val0.yzw);\n      } else if (posIn4bytes == 2) {\n        vec4 val0 = fetchElement(basePosIn16bytes);\n        vec4 val1 = fetchElement(basePosIn16bytes+1);\n        addPos = vec3(val0.zw, val1.x);\n      } else if (posIn4bytes == 3) {\n        vec4 val0 = fetchElement(basePosIn16bytes);\n        vec4 val1 = fetchElement(basePosIn16bytes+1);\n        addPos = vec3(val0.w, val1.xy);\n      }\n\n      // int index = u_dataTextureMorphOffsetPosition[i] + 1 * int(vertexId);\n      // vec3 addPos = fetchElement(u_dataTexture, index, widthOfDataTexture, heightOfDataTexture).xyz;\n\n      position += addPos * u_morphWeights[i];\n      if (i == u_morphTargetNumber-1) {\n        break;\n      }\n    }\n\n    return position;\n  }\n# endif\n#endif\n  `},7865:(e,t,n)=>{n.d(t,{A:()=>i});var o=n(3212),a=n(3583);const i=function(e){const t=a.e.getInstance().getModule("webgl");return o.m.isDataTextureApproach(e)?t.WebGLStrategyDataTexture.getInstance():(o.m.isUniformApproach(e),t.WebGLStrategyUniform.getInstance())}},5581:(e,t,n)=>{n.r(t),n.d(t,{default:()=>_});var o=n(7865),a=n(4876),i=n(7529),r=n(700),s=n(3296),l=n(8767);const c=Object.freeze({getRenderingStrategy:o.A,CommonShaderPart:a.q,WebGLContextWrapper:i.u,WebGLResourceRepository:r.u,WebGLStrategyUniform:s.n,WebGLStrategyDataTexture:l._}),_=c;("undefined"!=typeof global?global:"undefined"!=typeof window?window:void 0).RnWebGL=c},4876:(e,t,n)=>{n.d(t,{q:()=>_});var o=n(3212),a=n(3639),i=n(700),r=n(7670);const s="const float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n",l="struct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n";var c=n(7014);class _{constructor(){this.__webglResourceRepository=i.u.getInstance()}static getMainBegin(e){return r.l.currentProcessApproach===o.m.WebGPU?e?"\nvar<private> output : VertexOutput;\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n#ifdef RN_USE_INSTANCE\na_instanceIds = instance_ids;\n#endif\n\n#ifdef RN_USE_POSITION\na_position = vec3<f32>(position);\n#else\na_position = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_NORMAL\na_normal = normal;\n#endif\n\n#ifdef RN_USE_TEXCOORD_0\na_texcoord_0 = texcoord_0;\n#endif\n\n#ifdef RN_USE_COLOR_0\na_color_0 = vec4<f32>(color_0);\n#else\na_color_0 = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n#endif\n":"\nvar<private> rt0: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n@fragment\nfn main(\n  input: VertexOutput,\n  @builtin(front_facing) isFront: bool,\n) -> @location(0) vec4<f32> {\n":"\nvoid main() {\n"}static getMainEnd(e){return r.l.currentProcessApproach===o.m.WebGPU?e?"\n  return output;\n}\n":"\n  return rt0;\n}\n":"\n}\n    "}static getVertexPrerequisites(e){if(r.l.currentProcessApproach===o.m.WebGPU){let t="";return t+=`\n/* shaderity: @{definitions} */\n#define RN_IS_NODE_SHADER\n\n#ifdef RN_USE_INSTANCE\nvar<private> a_instanceIds: vec4<f32>;\n#endif\n\nvar<private> a_position: vec3<f32>;\n\nvar<private> a_normal: vec3<f32>;\n\nvar<private> a_texcoord_0: vec2<f32>;\n\nvar<private> a_color_0: vec4<f32>;\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  ${_.__makeVaryingVariablesWGSL(e)}\n}\n\n${l}\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n`,t}{let e="";return e+=`\n#version 300 es\nprecision highp float;\nprecision highp int;\n${s}\n\nin vec4 a_instanceInfo;\n`,e+=`\nuniform bool u_vertexAttributesExistenceArray[${a.r.AttributeTypeNumber}];\n`,e+="/* shaderity: @{matricesGetters} */",e+="/* shaderity: @{getters} */",e}}static __makeVaryingVariablesWGSL(e){const t=[];for(let n=0;n<e.length;n++){const o=e[n];for(let e=0;e<o.inputConnections.length;e++){const n=o.inputConnections[e];if(null==n)continue;const a=o.getInputs()[e],i=c.Q.getShaderNodeByUid(n.shaderNodeUid);if("Vertex"===i.getShaderStage()&&"Fragment"===o.getShaderStage()){const e=a.compositionType.toWGSLType(a.componentType);t.push({type:e,name:`${i.shaderFunctionName}_${i.shaderNodeUid}`})}}}t.sort(((e,t)=>e.name<t.name?-1:1));let n="";for(let e=0;e<t.length;e++)n+=`@location(${e}) ${t[e].name}: ${t[e].type},\n`;return n}static getPixelPrerequisites(e){if(r.l.currentProcessApproach===o.m.WebGPU){let t="";return t+=`\n/* shaderity: @{definitions} */\n#define RN_IS_NODE_SHADER\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  ${_.__makeVaryingVariablesWGSL(e)}\n}\n\n${l}\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n`,t}{let e="";return e+=`\n      #version 300 es\n      precision highp float;\n      precision highp int;\n      ${s}\n      `,e+="/* shaderity: @{getters} */",e+="layout(location = 0) out vec4 rt0;",e}}static getMainPrerequisites(){return r.l.currentProcessApproach===o.m.WebGPU?"let materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n":"#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n"}static getAssignmentStatement(e,t){return r.l.currentProcessApproach===o.m.WebGPU?`var ${e}: ${t.compositionType.toWGSLType(t.componentType)} = ${t.compositionType.getWgslInitialValue(t.componentType)};\n`:`${t.compositionType.getGlslStr(t.componentType)} ${e} = ${t.compositionType.getGlslInitialValue(t.componentType)};\n`}static getAssignmentVaryingStatementInPixelShader(e,t,n){return r.l.currentProcessApproach===o.m.WebGPU?`var ${e}: ${t.compositionType.toWGSLType(t.componentType)} = input.${n.shaderFunctionName}_${n.shaderNodeUid};\n`:`${t.compositionType.getGlslStr(t.componentType)} ${e} = v_${n.shaderFunctionName}_${n.shaderNodeUid};\n`}static getAssignmentVaryingStatementInVertexShader(e,t,n){return r.l.currentProcessApproach===o.m.WebGPU?`output.${e.shaderFunctionName}_${e.shaderNodeUid} = ${t[n]};\n`:`v_${e.shaderFunctionName}_${e.shaderNodeUid} = ${t[n]};\n`}}},4169:(e,t,n)=>{n.d(t,{w:()=>D}),new Uint8Array([0]);const o=[171,75,84,88,32,50,48,187,13,10,26,10];var a,i,r,s,l,c,_,u,f;(f=a||(a={}))[f.NONE=0]="NONE",f[f.BASISLZ=1]="BASISLZ",f[f.ZSTD=2]="ZSTD",f[f.ZLIB=3]="ZLIB",function(e){e[e.BASICFORMAT=0]="BASICFORMAT"}(i||(i={})),function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.ETC1S=163]="ETC1S",e[e.UASTC=166]="UASTC"}(r||(r={})),function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.SRGB=1]="SRGB"}(s||(s={})),function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.LINEAR=1]="LINEAR",e[e.SRGB=2]="SRGB",e[e.ITU=3]="ITU",e[e.NTSC=4]="NTSC",e[e.SLOG=5]="SLOG",e[e.SLOG2=6]="SLOG2"}(l||(l={})),function(e){e[e.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",e[e.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED"}(c||(c={})),function(e){e[e.RGB=0]="RGB",e[e.RRR=3]="RRR",e[e.GGG=4]="GGG",e[e.AAA=15]="AAA"}(_||(_={})),function(e){e[e.RGB=0]="RGB",e[e.RGBA=3]="RGBA",e[e.RRR=4]="RRR",e[e.RRRG=5]="RRRG"}(u||(u={}));class d{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=a.NONE,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:i.BASICFORMAT,versionNumber:2,descriptorBlockSize:40,colorModel:r.UNSPECIFIED,colorPrimaries:s.SRGB,transferFunction:s.SRGB,flags:c.ALPHA_STRAIGHT,texelBlockDimension:{x:4,y:4,z:1,w:1},bytesPlane:[],samples:[]}],this.keyValue={},this.globalData=null}}class h{constructor(e,t,n,o){this._dataView=new DataView(e.buffer,e.byteOffset+t,n),this._littleEndian=o,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_skip(e){return this._offset+=e,this}_scan(e,t=0){const n=this._offset;let o=0;for(;this._dataView.getUint8(this._offset)!==t&&o<e;)o++,this._offset++;return o<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,o)}}function m(e){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(e):Buffer.from(e).toString("utf8")}var p=n(4772),v=n(5216);let x,g,y;const b={env:{emscripten_notify_memory_growth:function(e){y=new Uint8Array(g.exports.memory.buffer)}}};class I{init(){return x||(x="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+A).then((e=>e.arrayBuffer())).then((e=>WebAssembly.instantiate(e,b))).then(this._init):WebAssembly.instantiate(Buffer.from(A,"base64"),b).then(this._init),x)}_init(e){g=e.instance,b.env.emscripten_notify_memory_growth(0)}decode(e,t=0){if(!g)throw new Error("ZSTDDecoder: Await .init() before decoding.");const n=e.byteLength,o=g.exports.malloc(n);y.set(e,o),t=t||Number(g.exports.ZSTD_findDecompressedSize(o,n));const a=g.exports.malloc(t),i=g.exports.ZSTD_decompress(a,t,o,n),r=y.slice(a,a+i);return g.exports.free(o),g.exports.free(a),r}}const A="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";var E=n(3212),S=n(7670),T=n(3497);const w="ETC1_RGB",C="BC1_RGB",R="BC3_RGBA",P="ETC2_RGBA",N="ASTC_4x4_RGBA",M="RGBA32";class D{constructor(){"undefined"==typeof MSC_TRANSCODER&&T.V.error("Failed to call MSC_TRANSCODER() function. Please check to import msc_basis_transcoder.js."),this.__mscTranscoderPromise=this.__loadMSCTranscoder()}static getInstance(){return this.__instance||(this.__instance=new D),this.__instance}transcode(e){const t=this.__parse(e);if(t.pixelDepth>0)throw new Error("Only 2D textures are currently supported");if(t.layerCount>1)throw new Error("Array textures are not currently supported");if(t.faceCount>1)throw new Error("Cube textures are not currently supported");return t.supercompressionScheme===a.ZSTD?(null==D.__zstdDecoder&&(D.__zstdDecoder=new I),D.__zstdDecoder.init().then((()=>this.__mscTranscoderPromise.then((()=>this.__transcodeData(t)))))):this.__mscTranscoderPromise.then((()=>this.__transcodeData(t)))}__loadMSCTranscoder(){return new Promise((e=>{D.__mscTranscoderModule&&e(),MSC_TRANSCODER().then((t=>{t.initTranscoders(),D.__mscTranscoderModule=t,e()}))}))}__getDeviceDependentParametersWebGL(e){const t=p.f.getWebGLResourceRepository().currentWebGLContextWrapper,n=t.webgl2ExtCTAstc||t.webgl1ExtCTAstc,o=t.webgl2ExtCTBptc||t.webgl1ExtCTBptc,a=t.webgl2ExtCTS3tc||t.webgl1ExtCTS3tc,i=t.webgl2ExtCTPvrtc||t.webgl1ExtCTPvrtc,r=t.webgl2ExtCTEtc||t.webgl1ExtCTEtc,s=t.webgl2ExtCTEtc1||t.webgl1ExtCTEtc1;let l,c;return n?(l=N,c=v.s.ASTC_RGBA_4x4):o?(l="BC7_RGBA",c=v.s.BPTC_RGBA):a?e?(l=R,c=v.s.S3TC_RGBA_DXT5):(l=C,c=v.s.S3TC_RGB_DXT1):i?e?(l="PVRTC1_4_RGBA",c=v.s.PVRTC_RGBA_4BPPV1):(l="PVRTC1_4_RGB",c=v.s.PVRTC_RGB_4BPPV1):r?e?(l=P,c=v.s.ETC2_RGBA8_EAC):(l=w,c=v.s.ETC2_RGB8):s?(l=w,c=v.s.ETC1_RGB):(l=M,c=v.s.RGBA8_EXT),{transcodeTargetStr:l,compressionTextureType:c}}__getDeviceDependentParametersWebGPU(e){const t=p.f.getWebGpuResourceRepository().getWebGpuDeviceWrapper().gpuAdapter,n=t.features.has("texture-compression-astc"),o=t.features.has("texture-compression-bc"),a=t.features.has("texture-compression-etc2");let i,r;return n?(i=N,r=v.s.ASTC_RGBA_4x4):o?e?(i=R,r=v.s.S3TC_RGBA_DXT5):(i=C,r=v.s.S3TC_RGB_DXT1):a?e?(i=P,r=v.s.ETC2_RGBA8_EAC):(i=w,r=v.s.ETC2_RGB8):(i=M,r=v.s.RGBA8_EXT),{transcodeTargetStr:i,compressionTextureType:r}}__parse(e){return function(e){const t=new Uint8Array(e.buffer,e.byteOffset,o.length);if(t[0]!==o[0]||t[1]!==o[1]||t[2]!==o[2]||t[3]!==o[3]||t[4]!==o[4]||t[5]!==o[5]||t[6]!==o[6]||t[7]!==o[7]||t[8]!==o[8]||t[9]!==o[9]||t[10]!==o[10]||t[11]!==o[11])throw new Error("Missing KTX 2.0 identifier.");const n=new d,a=17*Uint32Array.BYTES_PER_ELEMENT,i=new h(e,o.length,a,!0);n.vkFormat=i._nextUint32(),n.typeSize=i._nextUint32(),n.pixelWidth=i._nextUint32(),n.pixelHeight=i._nextUint32(),n.pixelDepth=i._nextUint32(),n.layerCount=i._nextUint32(),n.faceCount=i._nextUint32();const r=i._nextUint32();n.supercompressionScheme=i._nextUint32();const s=i._nextUint32(),l=i._nextUint32(),c=i._nextUint32(),_=i._nextUint32(),u=i._nextUint64(),f=i._nextUint64(),p=new h(e,o.length+a,3*r*8,!0);for(let t=0;t<r;t++)n.levels.push({levelData:new Uint8Array(e.buffer,e.byteOffset+p._nextUint64(),p._nextUint64()),uncompressedByteLength:p._nextUint64()});const v=new h(e,s,l,!0),x={vendorId:v._skip(4)._nextUint16(),descriptorType:v._nextUint16(),versionNumber:v._nextUint16(),descriptorBlockSize:v._nextUint16(),colorModel:v._nextUint8(),colorPrimaries:v._nextUint8(),transferFunction:v._nextUint8(),flags:v._nextUint8(),texelBlockDimension:{x:v._nextUint8()+1,y:v._nextUint8()+1,z:v._nextUint8()+1,w:v._nextUint8()+1},bytesPlane:[v._nextUint8(),v._nextUint8(),v._nextUint8(),v._nextUint8(),v._nextUint8(),v._nextUint8(),v._nextUint8(),v._nextUint8()],samples:[]},g=(x.descriptorBlockSize/4-6)/4;for(let e=0;e<g;e++)x.samples[e]={bitOffset:v._nextUint16(),bitLength:v._nextUint8(),channelID:v._nextUint8(),samplePosition:[v._nextUint8(),v._nextUint8(),v._nextUint8(),v._nextUint8()],sampleLower:v._nextUint32(),sampleUpper:v._nextUint32()};n.dataFormatDescriptor.length=0,n.dataFormatDescriptor.push(x);const y=new h(e,c,_,!0);for(;y._offset<_;){const e=y._nextUint32(),t=y._scan(e),o=m(t),a=y._scan(e-t.byteLength);n.keyValue[o]=o.match(/^ktx/i)?m(a):a,y._offset%4&&y._skip(4-y._offset%4)}if(f<=0)return n;const b=new h(e,u,f,!0),I=b._nextUint16(),A=b._nextUint16(),E=b._nextUint32(),S=b._nextUint32(),T=b._nextUint32(),w=b._nextUint32(),C=[];for(let e=0;e<r;e++)C.push({imageFlags:b._nextUint32(),rgbSliceByteOffset:b._nextUint32(),rgbSliceByteLength:b._nextUint32(),alphaSliceByteOffset:b._nextUint32(),alphaSliceByteLength:b._nextUint32()});const R=u+b._offset,P=R+E,N=P+S,M=N+T,D=new Uint8Array(e.buffer,e.byteOffset+R,E),F=new Uint8Array(e.buffer,e.byteOffset+P,S),B=new Uint8Array(e.buffer,e.byteOffset+N,T),L=new Uint8Array(e.buffer,e.byteOffset+M,w);return n.globalData={endpointCount:I,selectorCount:A,imageDescs:C,endpointsData:D,selectorsData:F,tablesData:B,extendedData:L},n}(e)}__transcodeData(e){var t;const n=e.pixelWidth,o=e.pixelHeight,i=e.faceCount,s=null===(t=e.globalData)||void 0===t?void 0:t.imageDescs,c=e.dataFormatDescriptor[0],_=c.colorModel===r.UASTC?1:0,u=this.__hasAlpha(c,_),f=!1,d=D.__mscTranscoderModule,h=1===_?new d.UastcImageTranscoder:new d.BasisLzEtc1sImageTranscoder,m=1===_?d.TextureFormat.UASTC4x4:d.TextureFormat.ETC1S,{transcodeTargetStr:p,compressionTextureType:v}=S.l.currentProcessApproach===E.m.WebGPU?this.__getDeviceDependentParametersWebGPU(u):this.__getDeviceDependentParametersWebGL(u),x=d.TranscodeTarget[p],g=[],y={width:n,height:o,compressionTextureType:v,mipmapData:g,needGammaCorrection:c.transferFunction!==l.SRGB};for(let t=0;t<e.levels.length;t++){const r=Math.max(1,n>>t),l=Math.max(1,o>>t),p=new d.ImageInfo(m,r,l,t);let v=e.levels[t].levelData;const y=e.levels[t].uncompressedByteLength,b=p.numBlocksX*p.numBlocksY*c.bytesPlane[0];e.supercompressionScheme===a.ZSTD&&(v=D.__zstdDecoder.decode(v,y));let I=0;const A=t*Math.max(e.layerCount,1)*i*Math.max(e.pixelDepth,1);for(let n=0;n<i;n++){let o,i,c=null;if(e.supercompressionScheme===a.BASISLZ?(c=null==s?void 0:s[A+n],o=new Uint8Array(v,c.rgbSliceByteOffset,c.rgbSliceByteLength+c.alphaSliceByteLength)):(o=new Uint8Array(v,I,b),I+=b),1===_)p.flags=0,p.rgbByteOffset=0,p.rgbByteLength=y,p.alphaByteOffset=0,p.alphaByteLength=0,i=h.transcodeImage(x,o,p,0,u,f);else{const t=e.globalData,n=h;n.decodePalettes(t.endpointCount,t.endpointsData,t.selectorCount,t.selectorsData),n.decodeTables(t.tablesData),p.flags=c.imageFlags,p.rgbByteOffset=0,p.rgbByteLength=c.rgbSliceByteLength,p.alphaByteOffset=c.alphaSliceByteOffset>0?c.rgbSliceByteLength:0,p.alphaByteLength=c.alphaSliceByteLength,i=n.transcodeImage(x,o,p,0,f)}if(null!=(null==i?void 0:i.transcodedImage)){const e=i.transcodedImage.get_typed_memory_view().slice();i.transcodedImage.delete();const n={level:t,width:r,height:l,buffer:e};g.push(n)}}}return y}__hasAlpha(e,t){return 1===t?e.samples[0].channelID===u.RGBA:2===e.samples.length&&(e.samples[0].channelID===_.AAA||e.samples[1].channelID===_.AAA)}}},7976:(e,t,n)=>{n.d(t,{y:()=>o});class o{constructor(e,t,n){this.__canvas=e,this.__context=e.getContext("webgpu"),this.__gpuAdapter=t,this.__gpuDevice=n;const o=navigator.gpu.getPreferredCanvasFormat();this.__context.configure({device:this.__gpuDevice,format:o,alphaMode:"premultiplied"})}get canvas(){return this.__canvas}get gpuAdapter(){return this.__gpuAdapter}get gpuDevice(){return this.__gpuDevice}get context(){return this.__context}}},69:(e,t,n)=>{n.d(t,{x:()=>N});var o=n(5065),a=n(7751),i=n(4114),r=n(4958),s=n(1383),l=n(3639),c=n(960),_=n(8374),u=n(2229),f=n(4772),d=n(9993),h=n(5338),m=n(9747),p=n(589),v=n(2805),x=n(6338),g=n(7681),y=n(8973),b=n(7295),I=n(7503),A=n(7670),E=n(7925),S=n(8393),T=n(108),w=n(3497);const C=n(3101),R=16,P=17;class N extends f.f{constructor(){super(),this.__webGpuResources=new Map,this.__resourceCounter=f.f.InvalidCGAPIResourceUid,this.__webGpuRenderPipelineMap=new Map,this.__materialStateVersionMap=new Map,this.__bindGroupTextureMap=new Map,this.__bindGroupLayoutTextureMap=new Map,this.__bindGroupSamplerMap=new Map,this.__bindGroupLayoutSamplerMap=new Map,this.__bindGroupsUniformDrawParameters=new Map,this.__uniformDrawParametersBuffers=new Map,this.__renderBundles=new Map,this.__lastMaterialsUpdateCount=-1,this.__lastCurrentCameraComponentSid=-1,this.__lastEntityRepositoryUpdateCount=-1,this.__lastPrimitivesMaterialVariantUpdateCount=-1,this.__lastMeshRendererComponentsUpdateCount=-1,this.__srcTextureViewsForGeneratingMipmaps=new Map,this.__dstTextureViewsForGeneratingMipmaps=new Map,this.__bindGroupsForGeneratingMipmaps=new Map}clearCache(){this.__webGpuRenderPipelineMap.clear(),this.__materialStateVersionMap.clear(),this.__bindGroupTextureMap.clear(),this.__bindGroupLayoutTextureMap.clear(),this.__bindGroupSamplerMap.clear(),this.__bindGroupLayoutSamplerMap.clear(),this.__renderBundles.clear()}addWebGpuDeviceWrapper(e){this.__webGpuDeviceWrapper=e,this.__commandEncoder=this.__webGpuDeviceWrapper.gpuDevice.createCommandEncoder()}getWebGpuDeviceWrapper(){return this.__webGpuDeviceWrapper}static getInstance(){return this.__instance||(this.__instance=new N),this.__instance}getResourceNumber(){return++this.__resourceCounter}__registerResource(e){const t=this.getResourceNumber();return e._resourceUid=t,this.__webGpuResources.set(t,e),t}getCanvasSize(){const e=this.__webGpuDeviceWrapper.canvas;return[e.width,e.height]}createTextureFromImageBitmapData(e,{level:t,internalFormat:n,width:o,height:a,border:i,format:r,type:s,generateMipmap:l}){return this.__createTextureInner(o,a,n,l,e)}async createTextureFromDataUri(e,{level:t,internalFormat:n,border:o,format:a,type:i,generateMipmap:r}){return new Promise((s=>{const l=new Image;e.match(/^data:/)||(l.crossOrigin="Anonymous"),l.onload=async()=>{const e=l.width,c=l.height,_=await this.createTextureFromHTMLImageElement(l,{level:t,internalFormat:n,width:e,height:c,border:o,format:a,type:i,generateMipmap:r});s(_)},l.src=e}))}generateMipmaps2d(e,t,n){const o=this.__webGpuResources.get(e),a={size:[t,n,1],format:o.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:Math.floor(Math.log2(Math.max(t,n)))+1};this.generateMipmaps(o,a)}generateMipmapsCube(e,t,n){const o=this.__webGpuResources.get(e),a={size:[t,n,6],format:o.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:Math.floor(Math.log2(Math.max(t,n)))+1};this.generateMipmaps(o,a)}async getTexturePixelData(e,t,n,o,a){const i=this.__webGpuResources.get(e),r=new Uint8Array(t*n*4),s=this.__webGpuDeviceWrapper.gpuDevice,l=s.createCommandEncoder(),c=s.createBuffer({size:t*n*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});l.copyTextureToBuffer({texture:i},{buffer:c,bytesPerRow:4*t},{width:t,height:n,depthOrArrayLayers:1}),s.queue.submit([l.finish()]),await c.mapAsync(GPUMapMode.READ);const _=c.getMappedRange();return r.set(new Uint8Array(_)),c.unmap(),r}generateMipmaps(e,t){const n=this.__webGpuDeviceWrapper.gpuDevice;if(null==this.__generateMipmapsShaderModule&&(this.__generateMipmapsShaderModule=n.createShaderModule({code:"\n          var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n            vec2f(-1, 1), vec2f(1, 1),\n            vec2f(-1, -1), vec2f(1, -1));\n\n          struct VertexOutput {\n            @builtin(position) position : vec4f,\n            @location(0) texCoord : vec2f,\n          };\n\n          @vertex\n          fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n            var output : VertexOutput;\n            output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\n            output.position = vec4f(pos[vertexIndex], 0, 1);\n            return output;\n          }\n\n          @group(0) @binding(0) var imgSampler : sampler;\n          @group(0) @binding(1) var img : texture_2d<f32>;\n\n          @fragment\n          fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\n            return textureSample(img, imgSampler, texCoord);\n          }\n        "})),null!=this.__generateMipmapsPipeline&&t.format!=this.__generateMipmapsFormat&&(this.__generateMipmapsPipeline=void 0),null==this.__generateMipmapsPipeline){this.__generateMipmapsBindGroupLayout=n.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}}]});const e=n.createPipelineLayout({bindGroupLayouts:[this.__generateMipmapsBindGroupLayout]});this.__generateMipmapsPipeline=n.createRenderPipeline({layout:e,vertex:{module:this.__generateMipmapsShaderModule,entryPoint:"vertexMain"},fragment:{module:this.__generateMipmapsShaderModule,entryPoint:"fragmentMain",targets:[{format:t.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}}),this.__generateMipmapsFormat=t.format}null==this.__generateMipmapsSampler&&(this.__generateMipmapsSampler=n.createSampler({minFilter:"linear"})),null!=this.__renderPassEncoder&&(null!=this.__renderBundleEncoder&&this.__renderPassEncoder.executeBundles([this.__renderBundleEncoder.finish()]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0);const o="2d"===e.dimension&&6===e.depthOrArrayLayers?6:1;for(let a=0;a<o;++a){const o=this.__srcTextureViewsForGeneratingMipmaps.get(e);if(null==o||null==o[a]){const t=e.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1});null==o&&this.__srcTextureViewsForGeneratingMipmaps.set(e,[]),this.__srcTextureViewsForGeneratingMipmaps.get(e)[a]=t}let i=this.__srcTextureViewsForGeneratingMipmaps.get(e)[a];for(let o=1;o<t.mipLevelCount;++o){const t=this.__dstTextureViewsForGeneratingMipmaps.get(e);if(null==t||null==t[a]||null==t[a][o]){const n=e.createView({dimension:"2d",baseMipLevel:o,mipLevelCount:1,baseArrayLayer:a,arrayLayerCount:1});null==t&&this.__dstTextureViewsForGeneratingMipmaps.set(e,[]),null==this.__dstTextureViewsForGeneratingMipmaps.get(e)[a]&&(this.__dstTextureViewsForGeneratingMipmaps.get(e)[a]=[]),this.__dstTextureViewsForGeneratingMipmaps.get(e)[a][o]=n}const r=this.__dstTextureViewsForGeneratingMipmaps.get(e)[a][o],s=this.__commandEncoder.beginRenderPass({colorAttachments:[{view:r,loadOp:"load",storeOp:"store"}]}),l=this.__bindGroupsForGeneratingMipmaps.get(e);if(null==l||null==l[a]||null==l[a][o]){const t=n.createBindGroup({layout:this.__generateMipmapsBindGroupLayout,entries:[{binding:0,resource:this.__generateMipmapsSampler},{binding:1,resource:i}]});null==l&&this.__bindGroupsForGeneratingMipmaps.set(e,[]),null==this.__bindGroupsForGeneratingMipmaps.get(e)[a]&&(this.__bindGroupsForGeneratingMipmaps.get(e)[a]=[]),this.__bindGroupsForGeneratingMipmaps.get(e)[a][o]=t}const c=this.__bindGroupsForGeneratingMipmaps.get(e)[a][o];s.setPipeline(this.__generateMipmapsPipeline),s.setBindGroup(0,c),s.draw(4),s.end(),i=r}}}createTextureSampler({magFilter:e,minFilter:t,wrapS:n,wrapT:o,wrapR:a,anisotropy:i,isPremultipliedAlpha:r,shadowCompareMode:l}){const c=this.__webGpuDeviceWrapper.gpuDevice,_=i?4:1,u={magFilter:e.webgpu,minFilter:t.webgpu,mipmapFilter:t===s.P.LinearMipmapLinear||t===s.P.NearestMipmapLinear?"linear":"nearest",addressModeU:n.webgpu,addressModeV:o.webgpu,addressModeW:a.webgpu,maxAnisotropy:_};"nearest"!==u.magFilter&&"nearest"!==u.minFilter&&"nearest"!==u.mipmapFilter||(u.maxAnisotropy=1);const f=c.createSampler(u);return this.__registerResource(f)}createVertexBuffer(e){const t=this.__webGpuDeviceWrapper.gpuDevice.createBuffer({size:e.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Uint8Array(t.getMappedRange()).set(e.getUint8Array()),t.unmap(),this.__registerResource(t)}createVertexBufferFromTypedArray(e){const t=this.__webGpuDeviceWrapper.gpuDevice.createBuffer({size:e.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Uint8Array(t.getMappedRange()).set(new Uint8Array(e.buffer)),t.unmap(),this.__registerResource(t)}createIndexBuffer(e){const t=this.__webGpuDeviceWrapper.gpuDevice;let n=e.getUint8Array();if(e.componentType===i.I.UnsignedByte){const t=new Uint16Array(e.byteLength),o=e.getTypedArray();for(let e=0;e<o.length;e++)t[e]=o[e];n=new Uint8Array(t.buffer)}const a=o.$.addPaddingBytes(n.byteLength,4),r=t.createBuffer({size:a,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});return new Uint8Array(r.getMappedRange()).set(n),r.unmap(),this.__registerResource(r)}updateVertexBuffer(e,t){const n=this.__webGpuResources.get(t);if(u.Is.not.exist(n))throw new Error("Not found VBO.");n.mapAsync(GPUMapMode.WRITE).then((()=>{new Uint8Array(n.getMappedRange()).set(e.bufferView.getUint8Array()),n.unmap()}))}updateIndexBuffer(e,t){const n=this.__webGpuResources.get(t);if(u.Is.not.exist(n))throw new Error("Not found IBO.");n.mapAsync(GPUMapMode.WRITE).then((()=>{let t=e.getUint8Array();if(e.componentType===i.I.UnsignedByte){const n=new Uint16Array(e.byteLength),o=e.getTypedArray();for(let e=0;e<o.length;e++)n[e]=o[e];t=new Uint8Array(n.buffer)}new Uint8Array(n.getMappedRange()).set(t),n.unmap()}))}deleteVertexBuffer(e){const t=this.__webGpuResources.get(e);if(u.Is.not.exist(t))throw new Error("Not found VBO.");t.destroy(),this.__webGpuResources.delete(e)}createVertexBufferAndIndexBuffer(e){let t;e.hasIndices()&&(t=this.createIndexBuffer(e.indicesAccessor));const n=[];for(let e=0;e<l.r.AttributeTypeNumber;e++)n[e]=!1;const o=[];return e.attributeAccessors.forEach(((t,a)=>{const i=this.createVertexBuffer(t),r=l.r.toAttributeSlotFromJoinedString(e.attributeSemantics[a]);n[r]=!0,o.push(i)})),{vaoHandle:-1,iboHandle:t,vboHandles:o,attributesFlags:n,setComplete:!1}}updateVertexBufferAndIndexBuffer(e,t){t.iboHandle&&this.updateIndexBuffer(e.indicesAccessor,t.iboHandle);const n=e.attributeAccessors;for(let e=0;e<n.length;e++)this.updateVertexBuffer(n[e],t.vboHandles[e])}deleteVertexDataResources(e){if(u.Is.exist(e.iboHandle)){const t=this.__webGpuResources.get(e.iboHandle);u.Is.exist(t)&&t.destroy()}for(const t of e.vboHandles){const e=this.__webGpuResources.get(t);u.Is.exist(e)&&e.destroy()}}setVertexDataToPipeline({vaoHandle:e,iboHandle:t,vboHandles:n},o,a=f.f.InvalidCGAPIResourceUid){const i=[],r=[];for(let e=0;e<n.length;e++){const t=l.r.toAttributeSlotFromJoinedString(o.attributeSemantics[e]),n=o.attributeAccessors[e].componentType.webgpu+o.attributeAccessors[e].compositionType.webgpu;r.push({shaderLocation:t,offset:o.attributeAccessors[e].byteOffsetInBufferView,format:n})}i[0]={stepMode:"vertex",attributes:r,arrayStride:o.attributeAccessors[0].byteStride},this.__webGpuResources.get(a),i[1]={stepMode:"instance",attributes:[{shaderLocation:l.r.Instance.getAttributeSlot(),offset:0,format:"float32x4"}],arrayStride:16}}__checkShaderCompileStatus(e,t,n){w.V.info("MaterialTypeName: "+e);const o=g.zH.addLineNumberToCode(t);w.V.info(o);for(let e=0;e<n.messages.length;e++)return w.V.info(n.messages[e].message),!1;return!0}createShaderProgram({material:e,primitive:t,vertexShaderStr:n,fragmentShaderStr:o,attributeNames:a,attributeSemantics:i,onError:r}){const s=this.__webGpuDeviceWrapper.gpuDevice,l=s.createShaderModule({code:n});h.T.cgApiDebugConsoleOutput&&l.getCompilationInfo().then((t=>{t.messages.length>0&&this.__checkShaderCompileStatus(e.materialTypeName,n,t)}));const c=s.createShaderModule({code:o});h.T.cgApiDebugConsoleOutput&&c.getCompilationInfo().then((t=>{t.messages.length>0&&this.__checkShaderCompileStatus(e.materialTypeName,o,t)}));const _={vsModule:l,fsModule:c};return this.__registerResource(_)}clearFrameBuffer(e){if(e.entities.length>0)return;if(!e.toClearColorBuffer&&!e.toClearDepthBuffer)return;this.__webGpuDeviceWrapper.gpuDevice;const t=this.__webGpuDeviceWrapper.context,n=[];let o;if(e.toClearColorBuffer){const o=e.getFramebuffer();if(null!=o)for(let t of o.colorAttachments){const o=this.__webGpuResources.get(t._textureViewAsRenderTargetResourceUid);n.push({view:o,clearValue:{r:e.clearColor.x,g:e.clearColor.y,b:e.clearColor.z,a:e.clearColor.w},loadOp:"clear",storeOp:"store"})}else null==this.__contextCurrentTextureView&&(this.__contextCurrentTextureView=t.getCurrentTexture().createView()),n.push({view:this.__contextCurrentTextureView,clearValue:{r:e.clearColor.x,g:e.clearColor.y,b:e.clearColor.z,a:e.clearColor.w},loadOp:"clear",storeOp:"store"})}if(e.toClearDepthBuffer){const t=e.getFramebuffer();o=null!=t&&null!=t.depthAttachment?{view:this.__webGpuResources.get(t.depthAttachment._textureViewAsRenderTargetResourceUid),depthClearValue:e.clearDepth,depthLoadOp:"clear",depthStoreOp:"store"}:{view:this.__systemDepthTextureView,depthClearValue:e.clearDepth,depthLoadOp:"clear",depthStoreOp:"store"}}const a={colorAttachments:n,depthStencilAttachment:o,label:e.uniqueName};this.__commandEncoder.beginRenderPass(a).end()}draw(e,t,n,o,a){const i=n.isBufferLessRenderingMode(),r=e._vertexHandles;if(!i&&null==r)return;let s,l,c=-1,_=-1;if(!i){const n=e.mesh.meshEntitiesInner[0],a=n.getMeshRenderer();t._setInternalSettingParametersToGpuWebGpu({material:t,args:{cameraComponentSid:o,entity:n,specularCube:a.specularCubeMap}}),c=a.componentSID,_=a.updateCount,s=a.diffuseCubeMap,l=a.specularCubeMap}const u=`${e._getFingerPrint()} ${t.materialUID} ${n.renderPassUID} ${c} ${_} ${a} `,[f,d]=this.getOrCreateRenderPipeline(u,e,t,n,a,s,l);this.createRenderBundleEncoder(n);const h=this.__renderBundleEncoder;if(h.setBindGroup(0,this.__bindGroupStorageBuffer),h.setPipeline(f),h.setBindGroup(1,this.__bindGroupTextureMap.get(u)),h.setBindGroup(2,this.__bindGroupSamplerMap.get(u)),h.setBindGroup(3,this.__bindGroupsUniformDrawParameters.get(`${n.renderPassUID}-${e.primitiveUid}`)),i)h.draw(n._drawVertexNumberForBufferLessRendering);else{const t=e.mesh,n=this.__webGpuResources.get(t._variationVBOUid);if(h.setVertexBuffer(0,n),r.vboHandles.forEach(((e,t)=>{const n=this.__webGpuResources.get(e);h.setVertexBuffer(t+1,n)})),e.hasIndices()){const n=this.__webGpuResources.get(r.iboHandle),o=e.getIndexBitSize();h.setIndexBuffer(n,o);const a=e.indicesAccessor;h.drawIndexed(a.elementCount,t.meshEntitiesInner.length)}else{const n=e.attributeAccessors[0].elementCount;h.draw(n,t.meshEntitiesInner.length)}}this.createRenderPassEncoder(n)}createRenderBundleEncoder(e){if(null==this.__renderBundleEncoder){const t=this.__webGpuDeviceWrapper.gpuDevice,n=e.getFramebuffer();let o=[navigator.gpu.getPreferredCanvasFormat()],a=this.__systemDepthTexture.format;if(null!=n){o=[];for(let e of n.colorAttachments){const t=this.__webGpuResources.get(e._textureResourceUid);o.push(t.format)}a=null!=n.depthAttachment?this.__webGpuResources.get(n.depthAttachment._textureResourceUid).format:void 0}const i={colorFormats:o,depthStencilFormat:a,sampleCount:null!=e.getResolveFramebuffer()?e.getFramebuffer().colorAttachments[0].sampleCount:1},r=t.createRenderBundleEncoder(i);this.__renderBundleEncoder=r}}createRenderPassEncoder(e){if(null==this.__renderPassEncoder){const t=e.getFramebuffer(),n=e.getResolveFramebuffer(),o=e.toClearColorBuffer?{r:e.clearColor.x,g:e.clearColor.y,b:e.clearColor.z,a:e.clearColor.w}:void 0,a=e.toClearDepthBuffer?e.clearDepth:void 0;if(null!=n&&null!=t){let i=this.__systemDepthTextureView;null!=t.depthAttachment&&null!=this.__webGpuResources.get(t.depthAttachment._textureResourceUid)&&(i=this.__webGpuResources.get(t.depthAttachment._textureViewResourceUid));const r={colorAttachments:[],depthStencilAttachment:{view:i,depthClearValue:a,depthLoadOp:e.toClearDepthBuffer?"clear":"load",depthStoreOp:"store"},label:e.uniqueName},s=[];for(let a=0;a<n.colorAttachments.length;a++){const i=t.colorAttachments[a],r=n.colorAttachments[a],l=this.__webGpuResources.get(i._textureViewAsRenderTargetResourceUid);let c=this.__webGpuResources.get(r._textureViewAsRenderTargetResourceUid);s.push({view:l,resolveTarget:c,clearValue:o,loadOp:e.toClearColorBuffer?"clear":"load",storeOp:"store"})}r.colorAttachments=s,this.__renderPassEncoder=this.__commandEncoder.beginRenderPass(r)}else if(null!=t){let n,i;null!=t.depthAttachment&&null!=this.__webGpuResources.get(t.depthAttachment._textureResourceUid)&&(n=this.__webGpuResources.get(t.depthAttachment._textureViewAsRenderTargetResourceUid)),null!=n&&(i={view:n,depthClearValue:a,depthLoadOp:e.toClearDepthBuffer?"clear":"load",depthStoreOp:"store"});const r={colorAttachments:[],depthStencilAttachment:i,label:e.uniqueName},s=[];for(let n of t.colorAttachments){const t=this.__webGpuResources.get(n._textureViewAsRenderTargetResourceUid);s.push({view:t,clearValue:o,loadOp:e.toClearColorBuffer?"clear":"load",storeOp:"store"})}r.colorAttachments=s,this.__renderPassEncoder=this.__commandEncoder.beginRenderPass(r)}else{if(null==this.__contextCurrentTextureView){const e=this.__webGpuDeviceWrapper.context;this.__contextCurrentTextureView=e.getCurrentTexture().createView()}const t={colorAttachments:[{view:this.__contextCurrentTextureView,clearValue:o,loadOp:e.toClearColorBuffer?"clear":"load",storeOp:"store"}],depthStencilAttachment:{view:this.__systemDepthTextureView,depthClearValue:a,depthLoadOp:e.toClearDepthBuffer?"clear":"load",depthStoreOp:"store"},label:e.uniqueName};this.__renderPassEncoder=this.__commandEncoder.beginRenderPass(t)}}}__toClearRenderBundles(){_.i.stateVersion===this.__lastMaterialsUpdateCount&&b.n.current===this.__lastCurrentCameraComponentSid&&I.YY.updateCount===this.__lastEntityRepositoryUpdateCount&&c.s.variantUpdateCount===this.__lastPrimitivesMaterialVariantUpdateCount&&v.e.updateCount===this.__lastMeshRendererComponentsUpdateCount||(this.__renderBundles.clear(),A.l.webgpuRenderBundleMode=!1,this.__lastCurrentCameraComponentSid=b.n.current,this.__lastMaterialsUpdateCount=_.i.stateVersion,this.__lastEntityRepositoryUpdateCount=I.YY.updateCount,this.__lastPrimitivesMaterialVariantUpdateCount=c.s.variantUpdateCount,this.__lastMeshRendererComponentsUpdateCount=v.e.updateCount)}executeRenderBundle(e){this.__toClearRenderBundles(),!e._isChangedSortRenderResult&&h.T.cacheWebGpuRenderBundles||this.__renderBundles.clear();let t=this.__renderBundles.get(e.renderPassUID);return null!=t&&(this.createRenderPassEncoder(e),null!=this.__renderPassEncoder)&&(this.__renderPassEncoder.executeBundles([t]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0,!0)}finishRenderBundleEncoder(e){if(null!=this.__renderPassEncoder&&null!=this.__renderBundleEncoder){const t=this.__renderBundleEncoder.finish();h.T.cacheWebGpuRenderBundles?this.__renderBundles.set(e.renderPassUID,t):this.__renderBundles.clear(),this.__renderPassEncoder.executeBundles([t]),this.__renderPassEncoder.end(),this.__renderBundleEncoder=void 0,this.__renderPassEncoder=void 0}}getOrCreateRenderPipeline(e,t,n,o,a,i,r){if(this.__webGpuRenderPipelineMap.has(e)&&this.__materialStateVersionMap.get(e)===n.stateVersion)return[this.__webGpuRenderPipelineMap.get(e),!1];this.__webGpuRenderPipelineMap.delete(e),this.__materialStateVersionMap.delete(e),this.__bindGroupTextureMap.delete(e),this.__bindGroupLayoutTextureMap.delete(e),this.__bindGroupSamplerMap.delete(e),this.__bindGroupLayoutSamplerMap.delete(e),this.__createBindGroup(e,n,i,r);const s=this.__webGpuDeviceWrapper.gpuDevice,_=navigator.gpu.getPreferredCanvasFormat(),u=this.__webGpuResources.get(n.getShaderProgramUid(t));null!=u&&new Error("Shader Modules is not found");const f=[];o.isBufferLessRenderingMode()||f.push({stepMode:"instance",attributes:[{shaderLocation:l.r.Instance.getAttributeSlot(),offset:0,format:"float32x4"}],arrayStride:16}),t.attributeAccessors.forEach(((e,n)=>{const o={shaderLocation:l.r.toAttributeSlotFromJoinedString(t.attributeSemantics[n]),offset:0,format:e.componentType.webgpu+e.compositionType.webgpu};f.push({stepMode:"vertex",arrayStride:t.attributeAccessors[n].actualByteStride,attributes:[o]})}));const d=s.createPipelineLayout({bindGroupLayouts:[this.__bindGroupLayoutStorageBuffer,this.__bindGroupLayoutTextureMap.get(e),this.__bindGroupLayoutSamplerMap.get(e),this.__bindGroupLayoutUniformDrawParameters]});let h;n.isBlend()&&n.alphaMode===x.K.Blend&&(h={color:{srcFactor:n.blendFuncSrcFactor.webgpu,dstFactor:n.blendFuncDstFactor.webgpu,operation:n.blendEquationMode.webgpu},alpha:{srcFactor:n.blendFuncAlphaSrcFactor.webgpu,dstFactor:n.blendFuncAlphaDstFactor.webgpu,operation:n.blendEquationModeAlpha.webgpu}});const m=(o.isBufferLessRenderingMode()?o._primitiveModeForBufferLessRendering:t.primitiveMode).getWebGPUTypeStr();let p;"triangle-strip"!==m&&"line-strip"!==m||(p=t.getIndexBitSize()),c.s.getPrimitiveIdxHasMorph(t.primitiveUid);const v=o.getFramebuffer();let g=[{format:_,blend:h}],y="depth24plus";if(null!=v){g=[];for(let e of v.colorAttachments){const t=this.__webGpuResources.get(e._textureResourceUid);g.push({format:t.format,blend:h,writeMask:this.setColorWriteMask(n)})}y=null!=v.depthAttachment?this.__webGpuResources.get(v.depthAttachment._textureResourceUid).format:void 0}const b=s.createRenderPipeline({layout:d,vertex:{module:u.vsModule,entryPoint:"main",buffers:f},fragment:{module:u.fsModule,entryPoint:"main",targets:g},primitive:{topology:m,stripIndexFormat:p,frontFace:n.cullFrontFaceCCW?"ccw":"cw",cullMode:n.cullFace?n.cullFaceBack?"back":"front":"none"},depthStencil:null==y?void 0:{depthWriteEnabled:a,depthCompare:o.isDepthTest?"less":"always",format:y},multisample:{count:null!=o.getResolveFramebuffer()?o.getFramebuffer().colorAttachments[0].sampleCount:1}});return this.__webGpuRenderPipelineMap.set(e,b),this.__materialStateVersionMap.set(e,n.stateVersion),[b,!0]}flush(){const e=this.__webGpuDeviceWrapper.gpuDevice;e.queue.submit([this.__commandEncoder.finish()]),this.__commandEncoder=e.createCommandEncoder(),null!=this.__contextCurrentTextureView&&(this.__contextCurrentTextureView=void 0)}setColorWriteMask(e){let t=0;return e.colorWriteMask[0]&&(t|=1),e.colorWriteMask[1]&&(t|=2),e.colorWriteMask[2]&&(t|=4),e.colorWriteMask[3]&&(t|=8),t}async createCubeTextureFromFiles(e,t,n,o){const a=[];let i=0,r=0;for(let s=0;s<t;s++){const t=()=>new Promise(((t,a)=>{let i=0;const r=[];let l=".jpg";o===m.P.HDR_LINEAR?l=".hdr":o===m.P.RGBE_PNG&&(l=".RGBE.PNG");let c="_right_",_="_left_",u="_top_",f="_bottom_",d="_front_",h="_back_";n&&(c="_posx_",_="_negx_",u="_posy_",f="_negy_",d="_posz_",h="_negz_");const p=[[e+c+s+l,"posX"],[e+_+s+l,"negX"],[e+u+s+l,"posY"],[e+f+s+l,"negY"],[e+d+s+l,"posZ"],[e+h+s+l,"negZ"]];for(let e=0;e<p.length;e++){const n=p[e][1];let s;s=o===m.P.HDR_LINEAR||o===m.P.RGB9_E5_PNG?new C:new Image,s.hdriFormat=o,s.side=n,s.uri=p[e][0],s.crossOrigin="Anonymous",s.onload=()=>{i++,r.push(s),6===i&&t(r)},s.onerror=()=>{a(s.uri)},s.src=p[e][0]}}));let l;try{l=await t()}catch(e){try{l=await t()}catch(e){w.V.error(`failed to load ${e}`)}}const c=[];for(const e of l)if(e.hdriFormat===m.P.HDR_LINEAR)c.push(e);else{await e.decode();const t=await createImageBitmap(e);c.push(t),t.side=e.side}const _={};for(const e of c){switch(e.side){case"posX":_.posX=e;break;case"posY":_.posY=e;break;case"posZ":_.posZ=e;break;case"negX":_.negX=e;break;case"negY":_.negY=e;break;case"negZ":_.negZ=e}0===s&&(i=e.width,r=e.height)}a.push(_)}return this.createCubeTexture(t,a,i,r)}createCubeTexture(e,t,n,o){const a=[];for(let n=0;n<e;n++){const e=[];(t[n].posX instanceof ImageBitmap||t[0].posX instanceof HTMLCanvasElement)&&(e.push(t[n].posX),e.push(t[n].negX),e.push(t[n].posY),e.push(t[n].negY),e.push(t[n].posZ),e.push(t[n].negZ)),a.push(e)}const i=this.__webGpuDeviceWrapper.gpuDevice,r=i.createTexture({dimension:"2d",size:[n,o,6],format:a[0][0].hdriFormat===m.P.HDR_LINEAR?"rgba32float":"rgba8unorm",mipLevelCount:e,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let t=0;t<e;t++)for(let e=0;e<a[t].length;e++){const n=a[t][e];if(n.hdriFormat===m.P.HDR_LINEAR){const o=new Float32Array(n.width*n.height*4),a=n.dataFloat,s=n.width*n.height;for(let e=0;e<s;e++)o[4*e]=a[3*e],o[4*e+1]=a[3*e+1],o[4*e+2]=a[3*e+2],o[4*e+3]=1;const l=4*n.width*Float32Array.BYTES_PER_ELEMENT,c=256*Math.ceil(l/256),_=c/Float32Array.BYTES_PER_ELEMENT,u=new Float32Array(_*n.height);for(let e=0;e<n.height;e++){const t=e*n.width*4,a=t+4*n.width,i=e*_;u.set(o.subarray(t,a),i)}const f=i.createBuffer({size:u.byteLength,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Float32Array(f.getMappedRange()).set(u),f.unmap();const d=i.createCommandEncoder();d.copyBufferToTexture({buffer:f,bytesPerRow:c,rowsPerImage:n.height},{texture:r,origin:[0,0,e],mipLevel:t},[n.width,n.height,1]);const h=d.finish();i.queue.submit([h])}else i.queue.copyExternalImageToTexture({source:n},{texture:r,origin:[0,0,e],mipLevel:t},[n.width,n.height,1])}const l=this.__registerResource(r),c=s.P.Repeat,_=s.P.Repeat,u=1===e?s.P.Linear:s.P.LinearMipmapLinear,f=s.P.Linear,h=new d.L({wrapS:c,wrapT:_,minFilter:u,magFilter:f,anisotropy:!1});return h.create(),[l,h]}createStorageBuffer(e){const t=this.__webGpuDeviceWrapper.gpuDevice,n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE});return t.queue.writeBuffer(n,0,e),this.__storageBuffer=n,this.__registerResource(n)}updateStorageBuffer(e,t,n){const o=this.__webGpuDeviceWrapper.gpuDevice,a=this.__webGpuResources.get(e);o.queue.writeBuffer(a,0,t,0,n)}updateStorageBufferPartially(e,t,n,o,a){const i=this.__webGpuDeviceWrapper.gpuDevice,r=this.__webGpuResources.get(e);i.queue.writeBuffer(r,n,t,o,a)}createStorageBlendShapeBuffer(e){const t=this.__webGpuDeviceWrapper.gpuDevice,n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE});return t.queue.writeBuffer(n,0,e),this.__storageBlendShapeBuffer=n,this.__registerResource(n)}updateStorageBlendShapeBuffer(e,t,n){const o=this.__webGpuDeviceWrapper.gpuDevice,a=this.__webGpuResources.get(e);o.queue.writeBuffer(a,0,t,0,n)}createBindGroupLayoutForDrawParameters(){const e=this.__webGpuDeviceWrapper.gpuDevice;{const t={entries:[{binding:0,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]},n=e.createBindGroupLayout(t);this.__bindGroupLayoutUniformDrawParameters=n}}updateUniformBufferForDrawParameters(e,t,n,o,a){const i=this.__webGpuDeviceWrapper.gpuDevice;let r=this.__uniformDrawParametersBuffers.get(e);if(null==r){r=i.createBuffer({size:16,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.__uniformDrawParametersBuffers.set(e,r);const t=i.createBindGroup({layout:this.__bindGroupLayoutUniformDrawParameters,entries:[{binding:0,resource:{buffer:r}}]});this.__bindGroupsUniformDrawParameters.set(e,t)}N.__drawParametersUint32Array[0]=t,N.__drawParametersUint32Array[1]=n,N.__drawParametersUint32Array[2]=o,N.__drawParametersUint32Array[3]=a,i.queue.writeBuffer(r,0,N.__drawParametersUint32Array)}createUniformMorphOffsetsBuffer(){const e=this.__webGpuDeviceWrapper.gpuDevice,t=new Uint32Array(4*Math.ceil(h.T.maxVertexPrimitiveNumberInShader*h.T.maxVertexMorphNumberInShader/4)),n=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM});return e.queue.writeBuffer(n,0,t),this.__uniformMorphOffsetsBuffer=n,this.__registerResource(n)}updateUniformMorphOffsetsBuffer(e,t){const n=this.__webGpuDeviceWrapper.gpuDevice;if(null==this.__uniformMorphOffsetsBuffer)throw new Error("Not found uniform morph buffer.");n.queue.writeBuffer(this.__uniformMorphOffsetsBuffer,0,e,0,t)}createUniformMorphWeightsBuffer(){const e=this.__webGpuDeviceWrapper.gpuDevice,t=new Float32Array(4*Math.ceil(h.T.maxVertexPrimitiveNumberInShader*h.T.maxVertexMorphNumberInShader/4)),n=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM});return e.queue.writeBuffer(n,0,t),this.__uniformMorphWeightsBuffer=n,this.__registerResource(n)}updateUniformMorphWeightsBuffer(e,t){const n=this.__webGpuDeviceWrapper.gpuDevice;if(null==this.__uniformMorphWeightsBuffer)throw new Error("Not found uniform morph buffer.");n.queue.writeBuffer(this.__uniformMorphWeightsBuffer,0,e,0,t)}__createBindGroup(e,t,n,o){const i=this.__webGpuDeviceWrapper.gpuDevice;{const e=[],t=[];if(null!=this.__storageBuffer&&(e.push({binding:0,resource:{buffer:this.__storageBuffer}}),t.push({binding:0,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})),null!=this.__storageBlendShapeBuffer)e.push({binding:1,resource:{buffer:this.__storageBlendShapeBuffer}}),t.push({binding:1,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT});else{const n=i.createBuffer({size:16,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE});e.push({binding:1,resource:{buffer:n}}),t.push({binding:1,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})}null!=this.__uniformMorphOffsetsBuffer&&(e.push({binding:2,resource:{buffer:this.__uniformMorphOffsetsBuffer}}),t.push({binding:2,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})),null!=this.__uniformMorphWeightsBuffer&&(e.push({binding:3,resource:{buffer:this.__uniformMorphWeightsBuffer}}),t.push({binding:3,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}));const n={entries:t},o=i.createBindGroupLayout(n),a=i.createBindGroup({layout:o,entries:e});this.__bindGroupStorageBuffer=a,this.__bindGroupLayoutStorageBuffer=o}{const r=[],s=[],l=[],c=[];t._autoFieldVariablesOnly.forEach((e=>{const t=e.info;if("diffuseEnvTexture"!==t.semantic&&"specularEnvTexture"!==t.semantic&&a.h.isTexture(t.compositionType)){const t=e.value[0],n=e.value[1],o=e.value[2],a=n instanceof y.b||n instanceof T._?"cube":"2d";let i=this.__webGpuResources.get(n._textureViewResourceUid);null==i&&(i=n instanceof y.b||n instanceof T._?this.__webGpuResources.get(p.cC._textureResourceUid).createView({dimension:"cube"}):this.__webGpuResources.get(p.vK._textureResourceUid).createView()),r.push({binding:t,resource:i}),s.push({binding:t,texture:{viewDimension:a},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}),o.created||o.create();const _=this.__webGpuResources.get(o._samplerResourceUid);l.push({binding:t,resource:_}),c.push({binding:t,sampler:{type:"filtering"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})}}));const _=this.__webGpuResources.get(u.Is.exist(n)?n._textureViewResourceUid:-1);if(u.Is.exist(_))r.push({binding:R,resource:_});else{const e=this.__webGpuResources.get(p.cC._textureViewResourceUid);r.push({binding:R,resource:e})}s.push({binding:R,texture:{viewDimension:"cube"},visibility:GPUShaderStage.FRAGMENT});const f=this.__webGpuResources.get(u.Is.exist(n)?n._samplerResourceUid:-1);if(u.Is.exist(f))l.push({binding:R,resource:f});else{const e=this.__webGpuResources.get(p.cC._samplerResourceUid);l.push({binding:R,resource:e})}c.push({binding:R,sampler:{type:"filtering"},visibility:GPUShaderStage.FRAGMENT});const d=this.__webGpuResources.get(u.Is.exist(o)?o._textureViewResourceUid:-1);if(u.Is.exist(d))r.push({binding:P,resource:d});else{const e=this.__webGpuResources.get(p.cC._textureViewResourceUid);r.push({binding:P,resource:e})}s.push({binding:P,texture:{viewDimension:"cube"},visibility:GPUShaderStage.FRAGMENT});const h=this.__webGpuResources.get(u.Is.exist(o)?o._samplerResourceUid:-1);if(u.Is.exist(h))l.push({binding:P,resource:h});else{const e=this.__webGpuResources.get(p.cC._samplerResourceUid);l.push({binding:P,resource:e})}c.push({binding:P,sampler:{type:"filtering"},visibility:GPUShaderStage.FRAGMENT});const m={entries:s},v=i.createBindGroupLayout(m),x=i.createBindGroup({layout:v,entries:r});this.__bindGroupTextureMap.set(e,x),this.__bindGroupLayoutTextureMap.set(e,v);const g={entries:c},b=i.createBindGroupLayout(g),I=i.createBindGroup({layout:b,entries:l});this.__bindGroupSamplerMap.set(e,I),this.__bindGroupLayoutSamplerMap.set(e,b)}}async createTextureFromHTMLImageElement(e,{level:t,internalFormat:n,width:o,height:a,border:i,format:r,type:s,generateMipmap:l}){return e.crossOrigin="Anonymous",this.__createTextureInner(o,a,n,l,e)}createCompressedTextureFromBasis(e,{border:t,format:n,type:o}){let a,i;const r=e.getNumLevels(0),s=e.getImageWidth(0,0),l=e.getImageHeight(0,0),c=this.__webGpuDeviceWrapper.gpuDevice,_=this.__webGpuDeviceWrapper.gpuAdapter;_.features.has("texture-compression-bc")&&(a=E.F.BC3,i="bc3-rgba-unorm"),_.features.has("texture-compression-etc2")&&(a=E.F.ETC2,i="etc2-rgba8unorm"),_.features.has("texture-compression-astc")&&(a=E.F.ASTC,i="astc-4x4-unorm");const u={size:[s,l,1],format:i,mipLevelCount:r,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},f=c.createTexture(u);for(let t=0;t<r;t++){const n=e.getImageWidth(0,t),o=e.getImageHeight(0,t),i=this.decodeBasisImage(e,a,0,t),r=new ImageData(new Uint8ClampedArray(i),n,o);c.queue.copyExternalImageToTexture({source:r},{texture:f,mipLevel:t},[n,o,1])}return this.__registerResource(f)}decodeBasisImage(e,t,n,o){const a=e.getImageTranscodedSizeInBytes(n,o,t.index),i=new Uint8Array(a);return e.transcodeImage(i,n,o,t.index,0,0)||w.V.error("failed to transcode the image."),i}createCompressedTexture(e,t){const n=this.__webGpuDeviceWrapper.gpuDevice,o=t.blockInfo||{byteSize:4,width:1,height:1},a=e[0],i={size:[Math.ceil(a.width/o.width)*o.width,Math.ceil(a.height/o.height)*o.height,1],format:t.webgpu,mipLevelCount:e.length,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},r=n.createTexture(i);for(let t=0;t<e.length;t++){const a=e[t],i=a.width,s=a.height,l=Math.ceil(i/o.width)*o.byteSize,c=new Uint8Array(a.buffer.buffer);n.queue.writeTexture({texture:r,mipLevel:t},c,{offset:0,bytesPerRow:l},{width:Math.ceil(i/o.width)*o.width,height:Math.ceil(s/o.height)*o.height})}return this.__registerResource(r)}allocateTexture({format:e,width:t,height:n,mipLevelCount:o}){const a=this.__webGpuDeviceWrapper.gpuDevice,i={size:[t,n,1],mipLevelCount:o,format:e.webgpu,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},r=a.createTexture(i);return this.__registerResource(r)}async loadImageToMipLevelOfTexture2D({mipLevel:e,textureUid:t,format:n,type:o,xOffset:a,yOffset:i,width:s,height:l,rowSizeByPixel:c,data:_}){const u=this.__webGpuDeviceWrapper.gpuDevice,f=this.__webGpuResources.get(t),d=S.n.getPixelFormatFromTextureFormat(n),h=c*r.A.getCompositionNumFromPixelFormat(d)*o.getSizeInBytes(),m=256*Math.ceil(h/256),p=new Uint8Array(m*l);for(let e=0;e<l;e++){const t=e*h,n=e*m;p.set(new Uint8Array(_.buffer,t,h),n)}const v=u.createBuffer({size:p.byteLength,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(v.getMappedRange()).set(p),v.unmap();const x=u.createCommandEncoder();x.copyBufferToTexture({buffer:v,offset:0,bytesPerRow:m,rowsPerImage:l},{texture:f,mipLevel:e,origin:{x:a,y:i,z:0}},{width:s,height:l,depthOrArrayLayers:1});const g=x.finish();u.queue.submit([g]);try{await u.queue.onSubmittedWorkDone()}catch(e){w.V.error(e)}}__createTextureInner(e,t,n,o,a){const i=this.__webGpuDeviceWrapper.gpuDevice,r={size:[e,t,1],format:n.webgpu,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};o&&(r.mipLevelCount=Math.floor(Math.log2(Math.max(e,t)))+1);const s=i.createTexture(r);return i.queue.copyExternalImageToTexture({source:a},{texture:s},[e,t]),o&&this.generateMipmaps(s,r),this.__registerResource(s)}createRenderTargetTexture({width:e,height:t,mipLevelCount:n,format:o}){const a=this.__webGpuDeviceWrapper.gpuDevice,i={size:[e,t,1],format:o.webgpu,mipLevelCount:n,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},r=a.createTexture(i);return this.__registerResource(r)}createRenderTargetTextureArray({width:e,height:t,level:n,internalFormat:o,format:a,type:i,arrayLength:r}){return-1}createRenderTargetTextureCube({width:e,height:t,mipLevelCount:n,format:o}){const a=this.__webGpuDeviceWrapper.gpuDevice,i={dimension:"2d",size:[e,t,6],format:o.webgpu,mipLevelCount:n,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},r=a.createTexture(i);return this.__registerResource(r)}createRenderBuffer(e,t,n,o,a){const i=this.__webGpuDeviceWrapper.gpuDevice,r={size:[e,t,1],format:n.webgpu,sampleCount:o?a:1,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT},s=i.createTexture(r);return this.__registerResource(s)}deleteRenderBuffer(e){this.flush(),this.clearCache();const t=this.__webGpuResources.get(e);null!=t&&(t.destroy(),this.__webGpuResources.delete(e))}copyTextureData(e,t){this.__webGpuDeviceWrapper.gpuDevice;const n=this.__webGpuResources.get(e),o=this.__webGpuResources.get(t);null!=this.__renderPassEncoder&&(null!=this.__renderBundleEncoder&&this.__renderPassEncoder.executeBundles([this.__renderBundleEncoder.finish()]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0),this.__commandEncoder.copyTextureToTexture({texture:n},{texture:o},[o.width,o.height,1])}isMippmappedTexture(e){return this.__webGpuDeviceWrapper.gpuDevice,this.__webGpuResources.get(e).mipLevelCount>1}duplicateTextureAsMipmapped(e){const t=this.__webGpuDeviceWrapper.gpuDevice,n=this.__webGpuResources.get(e),o={size:{width:n.width,height:n.height,depthOrArrayLayers:n.depthOrArrayLayers},mipLevelCount:Math.floor(Math.log2(Math.max(n.width,n.height)))+1,format:n.format,usage:n.usage},a=t.createTexture(o);return null!=this.__renderPassEncoder&&(null!=this.__renderBundleEncoder&&this.__renderPassEncoder.executeBundles([this.__renderBundleEncoder.finish()]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0),this.__commandEncoder.copyTextureToTexture({texture:n},{texture:a},{width:n.width,height:n.height,depthOrArrayLayers:1}),[this.__registerResource(a),this.__registerResource(a.createView())]}attachDepthBufferToFrameBufferObject(e,t){}attachStencilBufferToFrameBufferObject(e,t){}attachDepthStencilBufferToFrameBufferObject(e,t){}createFrameBufferObject(){return-1}deleteFrameBufferObject(e){}attachColorBufferToFrameBufferObject(e,t,n){}attachColorBufferCubeToFrameBufferObject(e,t,n,o,a){}createTextureView2d(e){const t=this.__webGpuResources.get(e).createView();return this.__registerResource(t)}createTextureViewAsRenderTarget(e){const t=this.__webGpuResources.get(e).createView({baseMipLevel:0,mipLevelCount:1});return this.__registerResource(t)}createTextureViewCube(e){const t=this.__webGpuResources.get(e).createView({dimension:"cube"});return this.__registerResource(t)}createCubeTextureViewAsRenderTarget(e,t,n){const o=this.__webGpuResources.get(e).createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:t,baseMipLevel:n,mipLevelCount:1,aspect:"all"});return this.__registerResource(o)}deleteTexture(e){this.flush(),this.clearCache();const t=this.__webGpuResources.get(e);null!=t&&(this.__srcTextureViewsForGeneratingMipmaps.delete(t),this.__dstTextureViewsForGeneratingMipmaps.delete(t),this.__bindGroupsForGeneratingMipmaps.delete(t),t.destroy(),this.__webGpuResources.delete(e))}recreateSystemDepthTexture(){const e=this.__webGpuDeviceWrapper.gpuDevice,t=this.__webGpuDeviceWrapper.canvas;null!=this.__systemDepthTexture&&this.__systemDepthTexture.destroy(),this.__systemDepthTexture=e.createTexture({size:[t.width,t.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.__systemDepthTextureView=this.__systemDepthTexture.createView()}resizeCanvas(e,t){const n=this.__webGpuDeviceWrapper.canvas;n.width=e,n.height=t,this.recreateSystemDepthTexture()}setViewport(e){}isSupportMultiViewVRRendering(){return!1}}N.__drawParametersUint32Array=new Uint32Array(4)},3336:(e,t,n)=>{n.d(t,{_:()=>C});var o=n(9447),a=n(2805),i=n(7496),r=n(7616),s=n(960),l=n(8374),c=n(4772),_=n(8909),u=n(69),f=n(8621),d=n(4317),h=n(3107),m=n(7488),p=n(7751),v=n(4114),x=n(3583),g=n(6737),y=n(7295),b=n(5338),I=n(3639),A=n(7193),E=n(4415),S=n(1823),T=n(7566),w=n(3497);class C{constructor(){this.__storageBufferUid=c.f.InvalidCGAPIResourceUid,this.__storageBlendShapeBufferUid=c.f.InvalidCGAPIResourceUid,this.__lastMaterialsUpdateCount=-1,this.__lastTransformComponentsUpdateCount=-1,this.__lastSceneGraphComponentsUpdateCount=-1,this.__lastCameraComponentsUpdateCount=-1,this.__lastCameraControllerComponentsUpdateCount=-1,this.__lastBlendShapeComponentsUpdateCountForWeights=-1,this.__lastBlendShapeComponentsUpdateCountForBlendData=-1}static getInstance(){return this.__instance||(this.__instance=new C),this.__instance}static getVertexShaderMethodDefinitions_storageBuffer(){return`\nfn get_worldMatrix(instanceId: u32) -> mat4x4<f32>\n{\n  let index: u32 = ${f.u.getLocationOffsetOfMemberOfComponent(d.K,"worldMatrix")}u + 4u * instanceId;\n  let matrix = fetchMat4(index);\n\n  return matrix;\n}\n\nfn get_normalMatrix(instanceId: u32) -> mat3x3<f32> {\n  let index: u32 = ${f.u.getLocationOffsetOfMemberOfComponent(d.K,"normalMatrix")}u * 4 + 9 * instanceId;\n  let matrix = fetchMat3No16BytesAligned(index);\n\n  return matrix;\n}\n\nfn get_isVisible(instanceId: u32) -> bool {\n  let index: u32 = ${f.u.getLocationOffsetOfMemberOfComponent(d.K,"isVisible")}u * 4u + instanceId;\n  let visibility = fetchScalarNo16BytesAligned(index);\n  if (visibility > 0.5) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n#ifdef RN_IS_VERTEX_SHADER\n  #ifdef RN_IS_MORPHING\n  fn get_position(vertexId: u32, basePosition: vec3<f32>, blendShapeComponentSID: u32) -> vec3<f32> {\n    var position = basePosition;\n    let scalar_idx = 3u * vertexId;\n    for (var i=0u; i<uniformDrawParameters.morphTargetNumber; i++) {\n      let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\n      let idx = ${b.T.maxVertexMorphNumberInShader}u * currentPrimitiveIdx + i;\n      let offsets = uniformMorphOffsets.data[ idx / 4u];\n      let offsetPosition = offsets[idx % 4u];\n\n      let basePosIn4bytes = offsetPosition * 4u + scalar_idx;\n      let addPos = fetchVec3No16BytesAlignedFromBlendShapeBuffer(basePosIn4bytes);\n\n      let idx2 = ${b.T.maxVertexMorphNumberInShader}u * blendShapeComponentSID + i;\n      let morphWeights: vec4f = uniformMorphWeights.data[ idx2 / 4u];\n      let morphWeight: f32 = morphWeights[idx2 % 4u];\n      position += addPos * morphWeight;\n    }\n\n    return position;\n  }\n  #endif\n#endif\n\n`}static __getShaderProperty(e,t,n){var o,a;const i=t.compositionType.toWGSLType(t.componentType),r=t.semantic.replace(".","_");if(p.h.isTexture(t.compositionType)){const e=t.compositionType===p.h.TextureCube?"texture_cube<f32>":"texture_2d<f32>",n=r.replace("Texture","Sampler");return`\n@group(1) @binding(${t.initialValue[0]}) var ${r}: ${e};\n@group(2) @binding(${t.initialValue[0]}) var ${n}: sampler;\n`}const s=t.compositionType.getVec4SizeOfProperty(),l=t.compositionType.getNumberOfComponents(),c=C.getOffsetOfPropertyInShader(n,t.semantic,e);let _;-1===c&&w.V.error("Could not get the location offset of the property.");let u=s;_=`  let vec4_idx: u32 = ${c}u + ${u}u * instanceId;\n`,p.h.isArray(t.compositionType)&&(u=s*(null!==(o=t.arrayLength)&&void 0!==o?o:1),_=`  let vec4_idx: u32 = ${c}u + ${u} * instanceId + ${s}u * idxOfArray;\n`,_+=`  let scalar_idx: u32 = ${4*c} + ${4*Math.ceil(l/4)*(null!==(a=t.arrayLength)&&void 0!==a?a:1)} * instanceId + ${l}u * idxOfArray;\n`);let f=`\nfn get_${r}(instanceId: u32, idxOfArray: u32) -> ${i} {\n${_}\n`;switch(t.compositionType){case p.h.Vec4:case p.h.Vec4Array:f+="  let val = fetchElement(vec4_idx);\n";break;case p.h.Vec3:f+="  let col0 = fetchElement(vec4_idx);\n",f+=`  let val = ${i}(col0.xyz);`;break;case p.h.Vec3Array:f+="  let val = fetchVec3No16BytesAligned(scalar_idx);\n";break;case p.h.Vec2:f+="  let col0 = fetchElement(vec4_idx);\n",f+=`  let val = ${i}(col0.xy);`;break;case p.h.Vec2Array:f+="  let val = fetchVec2No16BytesAligned(scalar_idx);\n";break;case p.h.Scalar:f+="  let col0 = fetchElement(vec4_idx);\n",t.componentType===v.I.Int?f+="  let val = i32(col0.x);":t.componentType===v.I.UnsignedInt?f+="  let val = u32(col0.x);":t.componentType===v.I.Bool?f+="  let val = col0.x >= 0.5;":f+="  let val = col0.x;";break;case p.h.ScalarArray:f+="  let col0 = fetchScalarNo16BytesAligned(scalar_idx);\n",t.componentType===v.I.Int?f+="  let val = i32(col0);":t.componentType===v.I.UnsignedInt?f+="  let val = u32(col0);":t.componentType===v.I.Bool?f+="  let val = col0 >= 0.5;":f+="  let val = col0;";break;case p.h.Mat4:case p.h.Mat4Array:f+="  let val = fetchMat4(vec4_idx);\n";break;case p.h.Mat3:f+="  let val = fetchMat3(vec4_idx);\n";break;case p.h.Mat3Array:f+="  let val = fetchMat3No16BytesAligned(scalar_idx);\n";break;case p.h.Mat2:f+="  let val = fetchMat2(vec4_idx);\n";break;case p.h.Mat2Array:f+="  let val = fetchMat2No16BytesAligned(scalar_idx);\n";break;case p.h.Mat4x3Array:f+="  let val = fetchMat4x3(vec4_idx);\n";break;default:f+=""}return f+="\n  return val;\n}\n",f}static getOffsetOfPropertyInShader(e,t,n){return e?h.q.getInstance().getLocationOffsetOfProperty(t):m.s.getLocationOffsetOfMemberOfMaterial(n,t)}$load(e){const t=e.mesh;return null!=t&&(t.isSetUpDone()||(0,_.I)(t),!0)}common_$load(){null==this.__uniformMorphOffsetsTypedArray&&(this.__uniformMorphOffsetsTypedArray=new Uint32Array(4*Math.ceil(b.T.maxVertexPrimitiveNumberInShader*b.T.maxVertexMorphNumberInShader/4))),null==this.__uniformMorphWeightsTypedArray&&(this.__uniformMorphWeightsTypedArray=new Float32Array(4*Math.ceil(b.T.maxVertexPrimitiveNumberInShader*b.T.maxVertexMorphNumberInShader/4))),A.W.updateCount!==this.__lastBlendShapeComponentsUpdateCountForBlendData&&(this.__createOrUpdateStorageBlendShapeBuffer(),this.__lastBlendShapeComponentsUpdateCountForBlendData=A.W.updateCount)}__setupShaderProgramForMeshComponent(e){if(null==e.mesh)return void o.F.alertNoMeshSet(e);const t=e.mesh.getPrimitiveNumber();for(let n=0;n<t;n++){const t=e.mesh.getPrimitiveAt(n),o=t.material;this._setupShaderProgram(o,t)}}_setupShaderProgram(e,t){if(null!=e&&!e.isShaderProgramReady(t))try{this.setupShaderForMaterial(e,t,C.getVertexShaderMethodDefinitions_storageBuffer(),C.__getShaderProperty),t._backupMaterial()}catch(e){w.V.error(e),t._restoreMaterial(),this.setupShaderForMaterial(t.material,t,C.getVertexShaderMethodDefinitions_storageBuffer(),C.__getShaderProperty)}}setupShaderForMaterial(e,t,n,o){e._createProgramWebGpu(t,n,o)}renderWithRenderBundle(e){return u.x.getInstance().executeRenderBundle(e)}prerender(){T.C.isAnimating||S.W.updateCount!==this.__lastTransformComponentsUpdateCount||d.K.updateCount!==this.__lastSceneGraphComponentsUpdateCount||l.i.stateVersion!==this.__lastMaterialsUpdateCount?(this.__createAndUpdateStorageBuffer(),this.__lastTransformComponentsUpdateCount=S.W.updateCount,this.__lastSceneGraphComponentsUpdateCount=d.K.updateCount,this.__lastMaterialsUpdateCount=l.i.stateVersion):y.n.currentCameraUpdateCount===this.__lastCameraComponentsUpdateCount&&E.v.updateCount===this.__lastCameraControllerComponentsUpdateCount||(this.__createAndUpdateStorageBufferForCameraOnly(),this.__lastCameraComponentsUpdateCount=y.n.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=E.v.updateCount),A.W.updateCount!==this.__lastBlendShapeComponentsUpdateCountForWeights&&(this.__updateUniformMorph(),this.__lastBlendShapeComponentsUpdateCountForWeights=A.W.updateCount)}common_$render(e,t,n){if(t.isBufferLessRenderingMode())return this.__renderWithoutBuffers(t),!0;let o=!1;const i=t.isDepthTest&&t.depthWriteMask,r=t.isDepthTest&&t.depthWriteMask&&a.e.isDepthMaskTrueForBlendPrimitives;if(t._toRenderOpaquePrimitives)for(let n=0;n<=t._lastOpaqueIndex;n++){const a=e[n],r=this.renderInner(a,t,i);o||(o=r)}if(t._toRenderTranslucentPrimitives)for(let n=t._lastOpaqueIndex+1;n<=t._lastTranslucentIndex;n++){const a=e[n],r=this.renderInner(a,t,i);o||(o=r)}if(t._toRenderBlendWithZWritePrimitives)for(let n=t._lastTranslucentIndex+1;n<=t._lastBlendWithZWriteIndex;n++){const a=e[n],r=this.renderInner(a,t,i);o||(o=r)}if(t._toRenderBlendWithoutZWritePrimitives)for(let n=t._lastBlendWithZWriteIndex+1;n<=t._lastBlendWithoutZWriteIndex;n++){const a=e[n],i=this.renderInner(a,t,r);o||(o=i)}return o}__renderWithoutBuffers(e){const t=e.material,n=e._dummyPrimitiveForBufferLessRendering;this._setupShaderProgram(t,n);const o=u.x.getInstance();o.updateUniformBufferForDrawParameters(`${e.renderPassUID}-${n.primitiveUid}`,t.materialSID,0,0,0),o.draw(n,t,e,0,!0)}renderInner(e,t,n){var o;if(-1===e)return!1;const a=s.s.getPrimitive(e);if(null==a)return!1;const i=t.getAppropriateMaterial(a);if(this._setupShaderProgram(i,a),(0,_.M)(i,a))return!1;const r=u.x.getInstance(),l=this.__getAppropriateCameraComponentSID(t,0,!1),c=null!==(o=s.s.getPrimitiveIdxHasMorph(a.primitiveUid))&&void 0!==o?o:0;return r.updateUniformBufferForDrawParameters(`${t.renderPassUID}-${a.primitiveUid}`,i.materialSID,l,c,a.targets.length),r.draw(a,i,t,l,n),!0}__createAndUpdateStorageBuffer(){const e=i.X.getInstance().getBuffer(r.a.GPUInstanceData),t=u.x.getInstance(),n=new Float32Array(e.getArrayBuffer());if(this.__storageBufferUid!==c.f.InvalidCGAPIResourceUid){const o=e.takenSizeInByte/4;t.updateStorageBuffer(this.__storageBufferUid,n,o)}else this.__storageBufferUid=t.createStorageBuffer(n)}__createAndUpdateStorageBufferForCameraOnly(){const e=i.X.getInstance().getBuffer(r.a.GPUInstanceData),t=u.x.getInstance(),n=h.q.getInstance(),o=new Float32Array(e.getArrayBuffer());if(this.__storageBufferUid!==c.f.InvalidCGAPIResourceUid){const e=16*n.getLocationOffsetOfProperty("viewMatrix"),a=e/4,i=16*n.getLocationOffsetOfProperty("boneMatrix")/4;t.updateStorageBufferPartially(this.__storageBufferUid,o,e,a,i-a)}else this.__storageBufferUid=t.createStorageBuffer(o)}__createOrUpdateStorageBlendShapeBuffer(){const e=i.X.getInstance().getBuffer(r.a.GPUVertexData);if(null==e)return;const t=u.x.getInstance(),n=new Float32Array(e.getArrayBuffer());if(this.__storageBlendShapeBufferUid!==c.f.InvalidCGAPIResourceUid){const o=e.takenSizeInByte/4;t.updateStorageBlendShapeBuffer(this.__storageBlendShapeBufferUid,n,o)}else this.__storageBlendShapeBufferUid=t.createStorageBlendShapeBuffer(n);let o=0;for(;o<b.T.maxVertexPrimitiveNumberInShader;o++){const e=s.s.getPrimitiveHasMorph(o);if(null==e)break;for(let t=0;t<e.targets.length;t++){const n=e.targets[t].get(I.r.Position.XYZ);this.__uniformMorphOffsetsTypedArray[b.T.maxVertexMorphNumberInShader*o+t]=n.byteOffsetInBuffer/4/4}}const a=b.T.maxVertexMorphNumberInShader*o;t.updateUniformMorphOffsetsBuffer(this.__uniformMorphOffsetsTypedArray,a)}__updateUniformMorph(){if(null==i.X.getInstance().getBuffer(r.a.GPUVertexData))return;const e=u.x.getInstance(),t=g.O.getComponentsWithType(A.W);for(let e=0;e<t.length;e++){const n=t[e],o=n.weights;for(let e=0;e<o.length;e++)this.__uniformMorphWeightsTypedArray[b.T.maxVertexMorphNumberInShader*n.componentSID+e]=o[e]}if(t.length>0){const n=b.T.maxVertexMorphNumberInShader*t.length;e.updateUniformMorphWeightsBuffer(this.__uniformMorphWeightsTypedArray,n)}}__getAppropriateCameraComponentSID(e,t,n){if(n){const e=x.e.getInstance().getModule("xr").WebXRSystem.getInstance();let n=-1;return e.isWebXRMode&&(n=e.isMultiView()?e._getCameraComponentSIDAt(0):e._getCameraComponentSIDAt(t)),n}{let t=e.cameraComponent;return null==t&&(t=g.O.getComponent(y.n,y.n.current)),t?t.componentSID:-1}}}},8044:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var o=n(7976),a=n(69),i=n(3336);const r=Object.freeze({WebGpuDeviceWrapper:o.y,WebGpuResourceRepository:a.x,WebGpuStrategyBasic:i._}),s=r;("undefined"!=typeof global?global:"undefined"!=typeof window?window:void 0).RnWebGpu=r},6727:(e,t,n)=>{n.d(t,{BT:()=>b,Bi:()=>T,jw:()=>I,LQ:()=>S});const o={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})},a={xAxis:0,yAxis:0,button:0,state:o.ComponentState.DEFAULT};class i{constructor(e){this.componentProperty=e.componentProperty,this.states=e.states,this.valueNodeName=e.valueNodeName,this.valueNodeProperty=e.valueNodeProperty,this.valueNodeProperty===o.VisualResponseProperty.TRANSFORM&&(this.minNodeName=e.minNodeName,this.maxNodeName=e.maxNodeName),this.value=0,this.updateFromComponent(a)}updateFromComponent({xAxis:e,yAxis:t,button:n,state:a}){const{normalizedXAxis:i,normalizedYAxis:r}=function(e=0,t=0){let n=e,o=t;if(Math.sqrt(e*e+t*t)>1){const a=Math.atan2(t,e);n=Math.cos(a),o=Math.sin(a)}return{normalizedXAxis:.5*n+.5,normalizedYAxis:.5*o+.5}}(e,t);switch(this.componentProperty){case o.ComponentProperty.X_AXIS:this.value=this.states.includes(a)?i:.5;break;case o.ComponentProperty.Y_AXIS:this.value=this.states.includes(a)?r:.5;break;case o.ComponentProperty.BUTTON:this.value=this.states.includes(a)?n:0;break;case o.ComponentProperty.STATE:this.valueNodeProperty===o.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(a):this.value=this.states.includes(a)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class r{constructor(e,t){if(!(e&&t&&t.visualResponses&&t.gamepadIndices&&0!==Object.keys(t.gamepadIndices).length))throw new Error("Invalid arguments supplied");this.id=e,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach((e=>{const n=new i(t.visualResponses[e]);this.visualResponses[e]=n})),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:o.ComponentState.DEFAULT,button:void 0!==this.gamepadIndices.button?0:void 0,xAxis:void 0!==this.gamepadIndices.xAxis?0:void 0,yAxis:void 0!==this.gamepadIndices.yAxis?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(e){if(this.values.state=o.ComponentState.DEFAULT,void 0!==this.gamepadIndices.button&&e.buttons.length>this.gamepadIndices.button){const t=e.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||1===this.values.button?this.values.state=o.ComponentState.PRESSED:(t.touched||this.values.button>o.ButtonTouchThreshold)&&(this.values.state=o.ComponentState.TOUCHED)}void 0!==this.gamepadIndices.xAxis&&e.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=e.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===o.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>o.AxisTouchThreshold&&(this.values.state=o.ComponentState.TOUCHED)),void 0!==this.gamepadIndices.yAxis&&e.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=e.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===o.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>o.AxisTouchThreshold&&(this.values.state=o.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach((e=>{e.updateFromComponent(this.values)}))}}class s{constructor(e,t,n){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=n,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach((e=>{const t=this.layoutDescription.components[e];this.components[e]=new r(e,t)})),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach((t=>{e.push(t.data)})),e}updateFromGamepad(){Object.values(this.components).forEach((e=>{e.updateFromGamepad(this.xrInputSource.gamepad)}))}}async function l(e){const t=await fetch(e);if(t.ok)return t.json();throw new Error(t.statusText)}var c=n(148),_=n(3508),u=n(2229),f=n(6603),d=n(975),h=n(7681),m=n(5697),p=n(2162),v=n(3497);const x=new Map,g=Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON_1:"button_1",BUTTON_2:"button_2",BUTTON_3:"button_3",BUTTON_SPECIAL:"button_special"}),y=new Map;async function b(e,t,n){const{profile:o,assetPath:a}=await async function(e,t,n=null,o=!0){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No basePath supplied");const a=await async function(e){if(!e)throw new Error("No basePath supplied");return await l(`${e}/profilesList.json`)}(t);let i;if(e.profiles.some((e=>{const n=a[e];return n&&(i={profileId:e,profilePath:`${t}/${n.path}`,deprecated:!!n.deprecated}),!!i})),!i){if(!n)throw new Error("No matching profile name found");const e=a[n];if(!e)throw new Error(`No matching profile name found and default profile "${n}" missing.`);i={profileId:n,profilePath:`${t}/${e.path}`,deprecated:!!e.deprecated}}const r=await l(i.profilePath);let s;if(o){let t;if(t="any"===e.handedness?r.layouts[Object.keys(r.layouts)[0]]:r.layouts[e.handedness],!t)throw new Error(`No matching handedness, ${e.handedness}, in profile ${i.profileId}`);t.assetPath&&(s=i.profilePath.replace("profile.json",t.assetPath))}return{profile:r,assetPath:s}}(e,t),i=new s(e,o,a);x.set(e,i);const r=await async function(e){const t=await c.a.importFromUri(e.assetUrl);return function(e,t){Object.values(e.components).forEach((e=>{e.touchPointNodeName&&t.getChildByName(e.touchPointNodeName,!0)}))}(e,t),t}(i);if(r.isOk())return _.w.convertToRhodoniteObject(r.get())}function I(e,t,n){Array.from(x.values()).forEach((t=>{t.updateFromGamepad(),Object.keys(t.components).forEach((o=>{!function(e,t,n,o){const a=y.get(e.rootNodeName);if(u.Is.not.exist(a))return;if(0===A)return void(A=o);const i=1e-6*(o-A);switch(a){case g.TRIGGER:!function(e,t,n,o){let a=0;const i=y.get(e.rootNodeName);("pressed"===e.values.state||"touched"===e.values.state)&&(v.V.info(i+", "+e.values.button+", "+t),a=(0,h.pJ)({value:e.values.button,defaultValue:0})*o),"right"===t&&(a*=-1),E.x-=.1*a,E.y-=.1*a,E.z-=.1*a,E.x=Math.max(E.x,.05),E.y=Math.max(E.y,.05),E.z=Math.max(E.z,.05),E.x=Math.min(E.x,3),E.y=Math.min(E.y,3),E.z=Math.min(E.z,3),n.viewerScale.copyComponents(E)}(e,t,n,i);break;case g.THUMBSTICK:!function(e,t,n,o){const a=y.get(e.rootNodeName);let i=0,r=0;"pressed"===e.values.state?(v.V.info(a+", "+e.values.button+", "+e.values.state+", "+t),i=(0,h.pJ)({value:e.values.xAxis,defaultValue:0})*o,r=(0,h.pJ)({value:e.values.yAxis,defaultValue:0})*o):"touched"===e.values.state&&(i=(0,h.pJ)({value:e.values.xAxis,defaultValue:0})*o,r=(0,h.pJ)({value:e.values.yAxis,defaultValue:0})*o),i=Math.min(i,1),r=Math.min(r,1);const s=m.tp.zero();"right"===t?(n.viewerAzimuthAngle.x-=.15*i,s.y-=.1*r*n.viewerScale.x):(s.x+=.25*i*n.viewerScale.x,s.z+=.25*r*n.viewerScale.x);p._.fromCopyQuaternion(n.viewerOrientation).multiply(p._.rotateY(n.viewerAzimuthAngle.x)).multiplyVectorTo(s,s),n.viewerTranslate.add(s)}(e,t,n,i);break;case g.SQUEEZE:!function(e,t,n,o){const a=y.get(e.rootNodeName);("pressed"===e.values.state||"touched"===e.values.state)&&v.V.info(a+", "+e.values.button+", "+t)}(e,t);break;case g.BUTTON_1:case g.BUTTON_2:case g.BUTTON_3:case g.BUTTON_SPECIAL:!function(e,t,n,o){const a=y.get(e.rootNodeName);("pressed"===e.values.state||"touched"===e.values.state)&&v.V.info(a+", "+e.values.button+", "+e.values.state+", "+t)}(e,t);break;case g.TOUCHPAD:"pressed"===(r=e).values.state||"touched"===r.values.state&&0!==r.values.yAxis&&r.values.yAxis}var r}(t.components[o],t.xrInputSource.handedness,n,e)}))}))}y.set("a_button",g.BUTTON_1),y.set("b_button",g.BUTTON_2),y.set("x_button",g.BUTTON_1),y.set("y_button",g.BUTTON_2),y.set("thumbrest",g.BUTTON_3),y.set("menu",g.BUTTON_SPECIAL),y.set("xr_standard_trigger",g.TRIGGER),y.set("xr_standard_squeeze",g.SQUEEZE),y.set("xr_standard_thumbstick",g.THUMBSTICK),y.set("xr_standard_touchpad",g.TOUCHPAD),y.set("trigger",g.TRIGGER),y.set("squeeze",g.SQUEEZE),y.set("thumbstick",g.THUMBSTICK),y.set("touchpad",g.TOUCHPAD);let A=0;const E=m.tp.one();function S(e,t){const n=e.getTagValue("rnEntitiesByNames");Object.values(t.components).forEach((e=>{for(const t in e.visualResponses){const o=e.visualResponses[t],a=n.get(o.valueNodeName);if(u.Is.not.exist(a))v.V.warn("The entity of the controller doesn't exist");else if("visibility"===o.valueNodeProperty)a.getSceneGraph().isVisible=!!o.value;else if("transform"===o.valueNodeProperty){const e=n.get(o.minNodeName),t=n.get(o.maxNodeName);if(u.Is.not.exist(e)||u.Is.not.exist(t)){v.V.warn("The min/max Node of the component of the controller doesn't exist");continue}const i=e.getTransform(),r=t.getTransform();a.getTransform().quaternion=f.P.qlerp(i.localRotationInner,r.localRotationInner,o.value),a.getTransform().localPosition=d.Pq.lerp(i.localPositionInner,r.localPositionInner,o.value)}}}))}function T(e){return x.get(e)}},5966:(e,t,n)=>{n.d(t,{q:()=>g});var o=n(4772),a=n(975),i=n(7476),r=n(3414),s=n(9827),l=n(3583),c=n(6727),_=n(2229),u=n(5697),f=n(6253),d=n(1881),h=n(7488),m=n(8806),p=n(8321),v=n(3497);const x=a.Pq.fromCopyArray([0,1.1,0]);class g{constructor(){this.__isWebXRMode=!1,this.__spaceType="local",this.__requestedToEnterWebXR=!1,this.__isReadyForWebXR=!1,this.__defaultPositionInLocalSpaceMode=x,this.__canvasWidthForVR=0,this.__canvasHeightForVR=0,this.__controllerEntities=[],this.__xrInputSources=[],this.__viewerTranslate=u.tp.zero(),this.__viewerAzimuthAngle=d.n9.zero(),this.__viewerOrientation=f.h.identity(),this.__viewerScale=u.tp.one(),this.__multiviewFramebufferHandle=-1,this.__multiviewColorTextureHandle=-1,this.__viewerEntity=(0,m.P)(),this.__viewerEntity.tryToSetUniqueName("WebXR Viewer",!0),this.__viewerEntity.tryToSetTag({tag:"type",value:"background-assets"}),this.__leftCameraEntity=(0,p.v)(),this.__leftCameraEntity.tryToSetUniqueName("WebXR Left Camera",!0),this.__leftCameraEntity.tryToSetTag({tag:"type",value:"background-assets"}),this.__leftCameraEntity.getCamera()._xrLeft=!0,this.__rightCameraEntity=(0,p.v)(),this.__rightCameraEntity.tryToSetUniqueName("WebXR Right Camera",!0),this.__rightCameraEntity.tryToSetTag({tag:"type",value:"background-assets"}),this.__rightCameraEntity.getCamera()._xrRight=!0,this.__viewerEntity.getSceneGraph().addChild(this.__leftCameraEntity.getSceneGraph()),this.__viewerEntity.getSceneGraph().addChild(this.__rightCameraEntity.getSceneGraph())}async readyForWebXR(e,t){this.__basePath=t,await l.e.getInstance().loadModule("xr");const n=o.f.getWebGLResourceRepository().currentWebGLContextWrapper;if(null==n)return v.V.error("WebGL Context is not ready yet."),[];if(this.__glw=n,!await navigator.xr.isSessionSupported("immersive-vr"))throw new Error("WebXR is not supported in this environment.");if(e)e.style.display="block";else{const e=document.createElement("p"),t=document.createElement("a");t.setAttribute("id","enter-vr");const o=document.createTextNode("Enter VR");t.appendChild(o),e.appendChild(t);const a=n.canvas;a.parentNode.insertBefore(e,a),window.addEventListener("click",this.enterWebXR.bind(this))}return this.__isReadyForWebXR=!0,[]}async enterWebXR({initialUserPosition:e,callbackOnXrSessionStart:t=(()=>{}),callbackOnXrSessionEnd:n=(()=>{}),profilePriorities:a=[]}){const i=o.f.getWebGLResourceRepository().currentWebGLContextWrapper;if(null!=i&&this.__isReadyForWebXR){let o;const r=await navigator.xr.requestSession("immersive-vr");this.__xrSession=r,r.addEventListener("end",(()=>{i.__gl.bindFramebuffer(i.__gl.FRAMEBUFFER,null),this.__xrSession=void 0,this.__webglLayer=void 0,this.__xrViewerPose=void 0,this.__xrReferenceSpace=void 0,this.__spaceType="local",this.__isReadyForWebXR=!1,this.__requestedToEnterWebXR=!1,this.__xrInputSources.length=0,this.__setWebXRMode(!1),h.s._makeShaderInvalidateToAllMaterials(),this.__defaultPositionInLocalSpaceMode=x,v.V.info("XRSession ends."),s.i.stopRenderLoop(),s.i.restartRenderLoop(),n()}));const l=new Promise((e=>{r.addEventListener("inputsourceschange",(t=>{this.__onInputSourcesChange(t,e,a)}))}));return o=await r.requestReferenceSpace("local"),this.__spaceType="local",this.__defaultPositionInLocalSpaceMode=null!=e?e:x,this.__xrReferenceSpace=o,s.i.stopRenderLoop(),await this.__setupWebGLLayer(r,t),this.__requestedToEnterWebXR=!0,s.i.restartRenderLoop(),v.V.warn("End of enterWebXR."),l}v.V.error("WebGL context or WebXRSession is not ready yet.")}async exitWebXR(){null!=this.__xrSession&&await this.__xrSession.end()}getCanvasWidthForVr(){return this.__canvasWidthForVR}getCanvasHeightForVr(){return this.__canvasHeightForVR}getControllerEntities(){return this.__controllerEntities}get leftViewMatrix(){return this.__leftCameraEntity.getCamera().viewMatrix}get rightViewMatrix(){return this.__rightCameraEntity.getCamera().viewMatrix}get leftProjectionMatrix(){var e;const t=null===(e=this.__xrViewerPose)||void 0===e?void 0:e.views[0];return i.g.fromCopyFloat32ArrayColumnMajor(_.Is.exist(t)?t.projectionMatrix:i.g.identity()._v)}get rightProjectionMatrix(){var e;const t=null===(e=this.__xrViewerPose)||void 0===e?void 0:e.views[1];return i.g.fromCopyFloat32ArrayColumnMajor(_.Is.exist(t)?t.projectionMatrix:i.g.identity()._v)}get framebuffer(){var e,t;return null===(t=null===(e=this.__xrSession)||void 0===e?void 0:e.renderState.baseLayer)||void 0===t?void 0:t.framebuffer}isMultiView(){return o.f.getWebGLResourceRepository().isSupportMultiViewVRRendering()}get requestedToEnterWebXR(){return this.__requestedToEnterWebXR}get xrSession(){return this.__xrSession}get requestedToEnterWebVR(){return this.__requestedToEnterWebXR}get isWebXRMode(){return this.__isWebXRMode}__setWebXRMode(e){this.__isWebXRMode=e,this.__glw._isWebXRMode=e}get isReadyForWebXR(){return this.__isReadyForWebXR}static getInstance(){return this.__instance||(this.__instance=new g),this.__instance}_getViewMatrixAt(e){return 0===e?this.leftViewMatrix:this.rightViewMatrix}_getProjectMatrixAt(e){return 0===e?this.leftProjectionMatrix:this.rightProjectionMatrix}_getViewportAt(e){return 0===e?this._getLeftViewport():this._getRightViewport()}_getLeftViewport(){return r.IU.fromCopyArray([0,0,this.__canvasWidthForVR/2,this.__canvasHeightForVR])}_getRightViewport(){return this.isMultiView()?r.IU.fromCopyArray([0,0,this.__canvasWidthForVR/2,this.__canvasHeightForVR]):r.IU.fromCopyArray([this.__canvasWidthForVR/2,0,this.__canvasWidthForVR/2,this.__canvasHeightForVR])}_setValuesToGlobalDataRepository(){this.__leftCameraEntity.getCamera().projectionMatrix=this.leftProjectionMatrix,this.__rightCameraEntity.getCamera().projectionMatrix=this.rightProjectionMatrix,this.__leftCameraEntity.getCamera().setValuesToGlobalDataRepository(),this.__rightCameraEntity.getCamera().setValuesToGlobalDataRepository()}_getCameraWorldPositionAt(e){var t;const n=null===(t=this.__xrViewerPose)||void 0===t?void 0:t.views[e];if(_.Is.exist(n)){const e=n.transform.position,t=this.__defaultPositionInLocalSpaceMode,o=this.__viewerTranslate,i=a.Pq.add(a.Pq.fromCopyArray([e.x,e.y,e.z]),t);return a.Pq.fromCopyArray([(i.x+o.x)*this.__viewerScale.x,(i.y+o.y)*this.__viewerScale.y,(i.z+o.z)*this.__viewerScale.z])}return this.__defaultPositionInLocalSpaceMode}_getCameraComponentSIDAt(e){return 0===e?this.__leftCameraEntity.getCamera().componentSID:this.__rightCameraEntity.getCamera().componentSID}_getCameraComponentAt(e){return 0===e?this.__leftCameraEntity.getCamera():this.__rightCameraEntity.getCamera()}_preRender(e,t){this.isWebXRMode&&this.__requestedToEnterWebXR&&null!=t&&(this.__updateView(t),this.__updateInputSources(t),(0,c.jw)(e,t,{viewerTranslate:this.__viewerTranslate,viewerScale:this.__viewerScale,viewerOrientation:this.__viewerOrientation,viewerAzimuthAngle:this.__viewerAzimuthAngle}))}resetViewerTransform(){this.__viewerTranslate=u.tp.zero(),this.__viewerAzimuthAngle=d.n9.zero(),this.__viewerOrientation=f.h.identity(),this.__viewerScale=u.tp.one()}_postRender(){this.__isWebXRMode}async __onInputSourcesChange(e,t,n){this.__xrInputSources.length=0;for(const t of e.added){this.__xrInputSources.push(t);const e=await(0,c.BT)(t,this.__basePath,n);_.Is.exist(e)&&(this.__controllerEntities.push(e),this.__viewerEntity.getSceneGraph().addChild(e.getSceneGraph()))}t(this.__controllerEntities)}__setCameraInfoFromXRViews(e){if(_.Is.not.exist(e))return void v.V.warn("xrViewerPose not exist");const t=e.views[0],n=e.views[1];if(_.Is.not.exist(t)||_.Is.not.exist(n))return;const o=e.transform.orientation;this.__viewerOrientation.x=o.x,this.__viewerOrientation.y=o.y,this.__viewerOrientation.z=o.z,this.__viewerOrientation.w=o.w;const r=i.g.fromCopyFloat32ArrayColumnMajor(null==t?void 0:t.transform.matrix),s=i.g.fromCopyFloat32ArrayColumnMajor(null==n?void 0:n.transform.matrix),l=this.__viewerScale.x,c=t.transform.position,f=u.tp.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate),d=u.tp.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate),h=a.Pq.fromCopyArray([c.x,c.y,c.z]),m=a.Pq.fromCopyArray([c.x,c.y,c.z]),p=u.tp.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate).add(h),x=u.tp.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate).add(m),g=(f.x+d.x)/2,y=(f.z+d.z)/2,b=(p.x+x.x)/2,I=(p.z+x.z)/2,A=this.__viewerEntity.getTransform();A.localPosition=a.Pq.fromCopyArray([g,0,y]),A.localScale=a.Pq.fromCopyArray([l,l,l]),A.localEulerAngles=a.Pq.fromCopyArray([0,this.__viewerAzimuthAngle.x,0]),r.translateY=p.y,r.translateX=p.x-b,r.translateZ=p.z-I,r.translateY+=h.y,r.translateX+=h.x,r.translateZ+=h.z,s.translateY=x.y,s.translateX=x.x-b,s.translateZ=x.z-I,s.translateY+=m.y,s.translateX+=m.x,s.translateZ+=m.z,this.__leftCameraEntity.getTransform().localMatrix=r,this.__rightCameraEntity.getTransform().localMatrix=s}async __setupWebGLLayer(e,t){var n;const a=null===(n=this.__glw)||void 0===n?void 0:n.getRawContextAsWebGL2();if(null!=a){await a.makeXRCompatible(),this.__webglLayer=new window.XRWebGLLayer(e,a);const n=this.__webglLayer;e.updateRenderState({baseLayer:n,depthNear:.01,depthFar:1e3});const i=o.f.getWebGLResourceRepository();this.__canvasWidthForVR=n.framebufferWidth,this.__canvasHeightForVR=n.framebufferHeight,v.V.info(this.__canvasWidthForVR.toString()),v.V.info(this.__canvasHeightForVR.toString()),h.s._makeShaderInvalidateToAllMaterials(),i.resizeCanvas(this.__canvasWidthForVR,this.__canvasHeightForVR),this.__setWebXRMode(!0),t()}else v.V.error("WebGL context is not ready for WebXR.")}__updateView(e){this.__xrViewerPose=e.getViewerPose(this.__xrReferenceSpace),this.__setCameraInfoFromXRViews(this.__xrViewerPose)}__updateInputSources(e){this.__xrInputSources.forEach(((t,n)=>{if(_.Is.exist(t.gripSpace)){const o=e.getPose(t.gripSpace,this.__xrReferenceSpace);if(_.Is.exist(o)){const e=this.__controllerEntities[n];if(_.Is.exist(e)){const n=i.g.fromCopyFloat32ArrayColumnMajor(o.transform.matrix),a=i.g.fromCopyMatrix44(n);a.translateY+=this.__defaultPositionInLocalSpaceMode.y,a.translateY+=this.__viewerTranslate.y,e.getTransform().localMatrix=a;const r=(0,c.Bi)(t);_.Is.exist(r)?(0,c.LQ)(e,r):v.V.warn("motionController not found")}}}}))}}},352:(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var o=n(5966),a=n(8321),i=n(7476),r=n(6253),s=n(1881),l=n(5697),c=n(975),_=n(2229),u=n(3497),f=n(1276),d=n(4772),h=n(3583),m=n(9827);const p=c.Pq.fromCopyArray([0,1.1,0]);class v{constructor(){this.__oGlw=new f.NV,this.__isReadyForWebAR=!1,this.__oArSession=new f.NV,this.__oWebglLayer=new f.NV,this.__spaceType="local",this.__isWebARMode=!1,this.__requestedToEnterWebAR=!1,this.__oArViewerPose=new f.NV,this.__oArReferenceSpace=new f.NV,this.__defaultPositionInLocalSpaceMode=p,this.__canvasWidthForAR=0,this.__canvasHeightForAR=0,this._cameraEntity=(0,a.v)(),this.__viewerTranslate=l.tp.zero(),this.__viewerAzimuthAngle=s.n9.zero(),this.__viewerOrientation=r.h.identity(),this.__viewerScale=l.tp.one(),this._cameraEntity.tryToSetUniqueName("WebAR Viewer",!0),this._cameraEntity.tryToSetTag({tag:"type",value:"background-assets"})}static getInstance(){return this.__instance||(this.__instance=new v),this.__instance}async readyForWebAR(e){await h.e.getInstance().loadModule("xr");const t=d.f.getWebGLResourceRepository().currentWebGLContextWrapper;if(null==t)throw new Error("WebGL Context is not ready yet.");if(this.__oGlw=new f.p2(t),!await navigator.xr.isSessionSupported("immersive-ar"))throw new Error("WebAR is not supported in this environment.");if(u.V.info("WebAR is supported."),e)e.style.display="block";else{const e=document.createElement("p"),n=document.createElement("a");n.setAttribute("id","enter-ar");const o=document.createTextNode("Enter AR");n.appendChild(o),e.appendChild(n);const a=t.canvas;a.parentNode.insertBefore(e,a),window.addEventListener("click",this.enterWebAR.bind(this))}return this.__isReadyForWebAR=!0,[]}async enterWebAR({initialUserPosition:e,callbackOnXrSessionStart:t=(()=>{}),callbackOnXrSessionEnd:n=(()=>{})}){const o=d.f.getWebGLResourceRepository().currentWebGLContextWrapper;if(null!=o&&this.__isReadyForWebAR){const a=await navigator.xr.requestSession("immersive-vr");this.__oArSession=new f.p2(a),a.addEventListener("end",(()=>{o.__gl.bindFramebuffer(o.__gl.FRAMEBUFFER,null),this.__oArSession=new f.NV,this.__oWebglLayer=new f.NV,this.__oArViewerPose=new f.NV,this.__oArReferenceSpace=new f.NV,this.__spaceType="local",this.__isReadyForWebAR=!1,this.__requestedToEnterWebAR=!1,this.__isWebARMode=!1,this.__defaultPositionInLocalSpaceMode=p,u.V.info("XRSession ends."),m.i.stopRenderLoop(),m.i.restartRenderLoop(),n()}));const i=await a.requestReferenceSpace("local");return this.__spaceType="local",this.__defaultPositionInLocalSpaceMode=null!=e?e:p,this.__oArReferenceSpace=new f.p2(i),m.i.stopRenderLoop(),await this.__setupWebGLLayer(a,t),this.__requestedToEnterWebAR=!0,m.i.restartRenderLoop(),void u.V.warn("End of enterWebXR.")}u.V.error("WebGL context or WebXRSession is not ready yet.")}async __setupWebGLLayer(e,t){const n=this.__oGlw.unwrapForce().getRawContext();if(null!=n){await n.makeXRCompatible(),this.__oWebglLayer=new f.p2(window.XRWebGLLayer(e,n));const o=this.__oWebglLayer.unwrapForce();e.updateRenderState({baseLayer:o,depthNear:.1,depthFar:1e4});const a=d.f.getWebGLResourceRepository();this.__canvasWidthForAR=o.framebufferWidth,this.__canvasHeightForAR=o.framebufferHeight,u.V.info(this.__canvasWidthForAR.toString()),u.V.info(this.__canvasHeightForAR.toString()),a.resizeCanvas(this.__canvasWidthForAR,this.__canvasHeightForAR),this.__isWebARMode=!0,t()}else u.V.error("WebGL context is not ready for WebXR.")}async exitWebAR(){this.__oArSession.has()&&await this.__oArSession.get().end()}getCanvasWidthForVr(){return this.__canvasWidthForAR}getCanvasHeightForVr(){return this.__canvasHeightForAR}get viewMatrix(){return this._cameraEntity.getCamera().viewMatrix}__updateView(e){this.__oArViewerPose=new f.p2(e.getViewerPose(this.__oArReferenceSpace.unwrapForce())),this.__setCameraInfoFromXRViews(this.__oArViewerPose.unwrapForce())}__setCameraInfoFromXRViews(e){if(_.Is.not.exist(e))return void u.V.warn("xrViewerPose not exist");const t=e.views[0];if(_.Is.not.exist(t))return;const n=e.transform.orientation;this.__viewerOrientation.x=n.x,this.__viewerOrientation.y=n.y,this.__viewerOrientation.z=n.z,this.__viewerOrientation.w=n.w;const o=i.g.fromCopyFloat32ArrayColumnMajor(null==t?void 0:t.transform.matrix),a=this.__viewerScale.x,r=t.transform.position,s=l.tp.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate),f=c.Pq.fromCopyArray([r.x,r.y,r.z]),d=l.tp.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate).add(f),h=s.x,m=s.z,p=d.x,v=d.z,x=this._cameraEntity.getTransform();x.localPosition=c.Pq.fromCopyArray([h,0,m]),x.localScale=c.Pq.fromCopyArray([a,a,a]),x.localEulerAngles=c.Pq.fromCopyArray([0,this.__viewerAzimuthAngle.x,0]),o.translateY=d.y,o.translateX=d.x-p,o.translateZ=d.z-v,o.translateY+=f.y,o.translateX+=f.x,o.translateZ+=f.z,this._cameraEntity.getTransform().localMatrix=o}get projectionMatrix(){const e=this.__oArViewerPose.unwrapForce().views[0];return i.g.fromCopyFloat32ArrayColumnMajor(_.Is.exist(e)?e.projectionMatrix:i.g.identity()._v)}_preRender(e,t){this.isWebARMode&&this.__requestedToEnterWebAR&&null!=t&&this.__updateView(t)}_postRender(){this.isWebARMode&&this.__oGlw.unwrapForce().getRawContext(),this.requestedToEnterWebAR}get isWebARMode(){return this.__isWebARMode}get isReadyForWebAR(){return this.__isReadyForWebAR}get requestedToEnterWebAR(){return this.__requestedToEnterWebAR}get arSession(){return this.__oArSession.unwrapOrUndefined()}get framebuffer(){var e,t;return null===(t=null===(e=this.__oArSession.unwrapOrUndefined())||void 0===e?void 0:e.renderState.baseLayer)||void 0===t?void 0:t.framebuffer}}const x=Object.freeze({WebXRSystem:o.q,WebARSystem:v}),g=x;("undefined"!=typeof global?global:"undefined"!=typeof window?window:void 0).RnXR=x},3600:(e,t,n)=>{n.d(t,{A:()=>o});const o={version:"v0.13.8-29-g31c3f162b-dirty",branch:"main"}},3101:function(t,n,o){var a;a=function(){function t(){var e,t,s=document.createElement("canvas"),l="t",c=1,_=2.2,u=null;return s.__defineGetter__("exposure",(function(){return c})),s.__defineSetter__("exposure",(function(n){c=n,u&&(r(u,c,_,t.data),e.putImageData(t,0,0))})),s.__defineGetter__("gamma",(function(){return _})),s.__defineSetter__("gamma",(function(n){_=n,u&&(r(u,c,_,t.data),e.putImageData(t,0,0))})),s.__defineGetter__("dataFloat",(function(){return i(u)})),s.__defineGetter__("dataRGBE",(function(){return u})),s.toHDRBlob=function(e,t,o){function a(e,t,n){var o=e.createShader(n);return e.shaderSource(o,t),e.compileShader(o),o}var r=t&&t.match(/rgb9_e5/i)?new Uint8Array(n(i(u)).buffer):new Uint8Array(u.buffer),s=this.width,l=this.height;if(s*l*4<r.byteLength)return console.error("not big enough.");var c=document.createElement("canvas");c.width=s,c.height=l;var _=c.getContext("webgl",{antialias:!1,alpha:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!0}),f=_.createTexture();_.activeTexture(_.TEXTURE0),_.bindTexture(_.TEXTURE_2D,f),_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,!0),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MAG_FILTER,_.NEAREST),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MIN_FILTER,_.NEAREST),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_WRAP_S,_.CLAMP_TO_EDGE),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_WRAP_T,_.CLAMP_TO_EDGE),_.texImage2D(_.TEXTURE_2D,0,_.RGBA,s,l,0,_.RGBA,_.UNSIGNED_BYTE,new Uint8Array(r.buffer));var d=function(e,t,n){var o,i,r=e.createProgram();return e.attachShader(r,o=a(e,"precision highp float;\nattribute vec3 position;\nvarying vec2 tex;\nvoid main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }",e.VERTEX_SHADER)),e.attachShader(r,i=a(e,"precision highp float;\nprecision highp sampler2D;\nuniform sampler2D tx;\nvarying vec2 tex;\nvoid main() { gl_FragColor = texture2D(tx,tex); }",e.FRAGMENT_SHADER)),e.linkProgram(r),e.deleteShader(o),e.deleteShader(i),r}(_),h=_.getUniformLocation(d,"tx"),m=new Float32Array([-1,-1,0,1,-1,0,1,1,0,1,1,0,-1,1,0,-1,-1,0]),p=_.createBuffer();return _.enableVertexAttribArray(0),_.bindBuffer(_.ARRAY_BUFFER,p),_.bufferData(_.ARRAY_BUFFER,m,_.STATIC_DRAW),_.vertexAttribPointer(0,3,_.FLOAT,!1,0,0),_.useProgram(d),_.uniform1i(h,0),_.drawArrays(_.TRIANGLES,0,6),_.deleteTexture(f),_.deleteProgram(d),e?c.toBlob(e):void 0},s.__defineGetter__("src",(function(){return l})),s.__defineSetter__("src",(function(n){if(l=n,e&&e.clearRect(0,0,this.width,this.height),n.match(/\.hdr$/i))f=n,d=function(n,o,a){u=n,this.width=this.style.width=o,this.height=this.style.height=a,e=this.getContext("2d"),t=e.getImageData(0,0,o,a),r(n,c,_,t.data),e.putImageData(t,0,0),this.onload&&this.onload()}.bind(s),h=function(e,t){for(var n in t)e[n]=t[n];return e}(new XMLHttpRequest,{responseType:"arraybuffer"}),h.onerror=d.bind(h,!1),h.onload=function(){if(this.status>=400)return this.onerror();for(var e,t="",n=0,o=new Uint8Array(this.response);!t.match(/\n\n[^\n]+\n/g);)t+=String.fromCharCode(o[n++]);if("32-bit_rle_rgbe"!=(e=t.match(/FORMAT=(.*)$/m)[1]))return console.warn("unknown format : "+e),this.onerror();for(var a=t.split(/\n/).reverse()[1].split(" "),i=1*a[3],r=1*a[1],s=new Uint8Array(i*r*4),l=0,c=0;c<r;c++){var _=o.slice(n,n+=4),u=[];if(2!=_[0]||2!=_[1]||128&_[2]){var f=i;for(n-=4;f>0;)if(s.set(o.slice(n,n+=4),l),1==s[l]&&1==s[l+1]&&1==s[l+2])for(s[l+3];h>0;h--)s.set(s.slice(l-4,l),l),l+=4,f--;else f--,l+=4}else{if((_[2]<<8)+_[3]!=i)return console.warn("HDR line mismatch .."),this.onerror();for(var h=0;h<4;h++)for(var m,p,v=h*i,x=(h+1)*i;v<x;)if((m=o.slice(n,n+=2))[0]>128)for(p=m[0]-128;p-- >0;)u[v++]=m[1];else for(p=m[0]-1,u[v++]=m[1];p-- >0;)u[v++]=o[n++];for(h=0;h<i;h++)s[l++]=u[h],s[l++]=u[h+i],s[l++]=u[h+2*i],s[l++]=u[h+3*i]}}d&&d(s,i,r)},h.open("GET",f,!0),h.send(null);else if(n.match(/\.rgb9_e5\.png$/i))(i=new Image).src=n,i.onload=function(){var n=document.createElement("canvas"),s=this.width=this.style.width=n.width=i.width,l=this.height=this.style.height=n.height=i.height,f=n.getContext("webgl"),d=f.createTexture();f.bindTexture(f.TEXTURE_2D,d),f.texImage2D(f.TEXTURE_2D,0,f.RGBA,f.RGBA,f.UNSIGNED_BYTE,i),fb=f.createFramebuffer(),f.bindFramebuffer(f.FRAMEBUFFER,fb),f.framebufferTexture2D(f.FRAMEBUFFER,f.COLOR_ATTACHMENT0,f.TEXTURE_2D,d,0);var h=new Uint8Array(s*l*4);f.readPixels(0,0,s,l,f.RGBA,f.UNSIGNED_BYTE,h),f.deleteTexture(d),f.deleteFramebuffer(fb),this.dataRAW=new Uint32Array(h.buffer),u=a(o(this.dataRAW)),e=this.getContext("2d"),t=e.getImageData(0,0,s,l),r(u,c,_,t.data),e.putImageData(t,0,0),this.onload&&this.onload()}.bind(s);else if(n.match(/\.hdr\.png$|\.rgbe\.png/i)){var i;(i=new Image).src=n,i.onload=function(){var n=document.createElement("canvas"),o=this.width=this.style.width=n.width=i.width,a=this.height=this.style.height=n.height=i.height,s=n.getContext("webgl"),l=s.createTexture();s.bindTexture(s.TEXTURE_2D,l),s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,i),fb=s.createFramebuffer(),s.bindFramebuffer(s.FRAMEBUFFER,fb),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,l,0);var f=new Uint8Array(o*a*4);s.readPixels(0,0,o,a,s.RGBA,s.UNSIGNED_BYTE,f),s.deleteTexture(l),s.deleteFramebuffer(fb),u=f,e=this.getContext("2d"),t=e.getImageData(0,0,o,a),r(u,c,_,t.data),e.putImageData(t,0,0),this.onload&&this.onload()}.bind(s)}var f,d,h})),s}function n(e,t){for(var n,o,a,i,r,s,l=e.byteLength/12|0,c=(t=t||new Uint32Array(l),0);c<l;c++)n=Math.min(32768,e[3*c]),o=Math.min(32768,e[3*c+1]),a=Math.min(32768,e[3*c+2]),i=Math.max(Math.max(n,o),a),r=Math.max(-16,Math.floor(Math.log2(i)))+16,s=Math.pow(2,r-24),511==Math.floor(i/s+.5)&&(s*=2,r+=1),t[c]=(Math.floor(n/s+.5)<<23)+(Math.floor(o/s+.5)<<14)+(Math.floor(a/s+.5)<<5)+(0|r);return t}function o(e,t){for(var n,o,a=e.byteLength>>2,i=(t=t||new Float32Array(3*a),0);i<a;i++)n=e[i],o=Math.pow(2,(31&n)-24),t[3*i]=(n>>>23)*o,t[3*i+1]=(n>>>14&511)*o,t[3*i+2]=(n>>>5&511)*o;return t}function a(t,n){for(var o,a,i,r,s,l=t.byteLength/12|0,c=(n=n||new Uint8Array(4*l),0);c<l;c++)o=t[3*c],a=t[3*c+1],i=t[3*c+2],r=Math.max(Math.max(o,a),i),e=Math.ceil(Math.log2(r)),s=Math.pow(2,e-8),n[4*c]=o/s|0,n[4*c+1]=a/s|0,n[4*c+2]=i/s|0,n[4*c+3]=e+128;return n}function i(e,t){for(var n,o=e.byteLength>>2,a=(t=t||new Float32Array(3*o),0);a<o;a++)n=Math.pow(2,e[4*a+3]-136),t[3*a]=e[4*a]*n,t[3*a+1]=e[4*a+1]*n,t[3*a+2]=e[4*a+2]*n;return t}function r(e,t,n,o){t=Math.pow(2,void 0===t?1:t)/2,void 0===n&&(n=2.2);for(var a,i=1/n,r=e.byteLength>>2,s=(o=o||new Uint8ClampedArray(4*r),0);s<r;s++)a=t*Math.pow(2,e[4*s+3]-136),o[4*s]=255*Math.pow(e[4*s]*a,i),o[4*s+1]=255*Math.pow(e[4*s+1]*a,i),o[4*s+2]=255*Math.pow(e[4*s+2]*a,i),o[4*s+3]=255;return o}return t.floatToRgbe=a,t.rgbeToFloat=i,t.floatToRgb9_e5=n,t.rgb9_e5ToFloat=o,t.rgbeToLDR=r,t.floatToLDR=function(e,t,n,o){t=Math.pow(2,void 0===t?1:t)/2,void 0===n&&(n=2.2);for(var a=1/n,i=e.byteLength/12|0,r=(o=o||new Uint8ClampedArray(4*i),0);r<i;r++)o[4*r]=255*Math.pow(e[3*r]*t,a),o[4*r+1]=255*Math.pow(e[3*r+1]*t,a),o[4*r+2]=255*Math.pow(e[3*r+2]*t,a),o[4*r+3]=255;return o},t},t.exports?t.exports=a():o.amdD("HDRImage",a)}},n={};function o(e){var a=n[e];if(void 0!==a)return a.exports;var i=n[e]={exports:{}};return t[e].call(i.exports,i,i.exports,o),i.exports}o.amdD=function(){throw new Error("define cannot be used indirect")},o.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return o.d(t,{a:t}),t},o.d=(e,t)=>{for(var n in t)o.o(t,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var a={};o.d(a,{A:()=>ko});var i={};o.r(i),o.d(i,{AABB:()=>kt.F5,AABBGizmo:()=>Ae.T,AbsoluteAnimation:()=>c.qf,AbstractArrayBufferBaseMathNumber:()=>kt.Q$,AbstractCameraController:()=>r.i,AbstractMaterialContent:()=>en.F,AbstractMatrix:()=>kt.y3,AbstractQuaternion:()=>kt.xR,AbstractShaderNode:()=>tn.Q,AbstractTexture:()=>He.E,AbstractVector:()=>kt.cD,Accessor:()=>ho.C,AddShaderNode:()=>vn,AlphaMode:()=>x.Km,AnimationAssigner:()=>Et,AnimationAttribute:()=>x.R$,AnimationComponent:()=>c.C6,AnimationInterpolation:()=>x.v$,AttributeColorShaderNode:()=>bn,AttributeNormalShaderNode:()=>In,AttributePositionShaderNode:()=>An,AttributeTexcoordShaderNode:()=>En,Axis:()=>ce,BasisCompressionType:()=>x.F,BlendShapeComponent:()=>c.Wu,BlockBeginShader:()=>Vn,BlockBeginShaderNode:()=>zn,BlockEndShader:()=>Gn,BlockEndShaderNode:()=>On,BoneDataType:()=>x.Nj,Buffer:()=>mo.h,BufferUse:()=>x.aT,BufferView:()=>po.E,CGAPIResourceRepository:()=>Ve.f,Cache:()=>st.l2,CameraComponent:()=>c.np,CameraControllerComponent:()=>c.vZ,CameraControllerType:()=>x.EA,CameraType:()=>x.Aq,CapsuleCollider:()=>qt,ClassicShadingShader:()=>Ro,ColorGradingUsingLUTsMaterialContent:()=>to.u,ColorRgb:()=>kt.xx,ColorRgba:()=>kt.q$,CommonShaderPart:()=>rn.q,ComplexVertexAttribute:()=>xe,Component:()=>_.u,ComponentRepository:()=>u.O,ComponentType:()=>x.I5,CompositionType:()=>x.hY,CompressionTextureType:()=>x.sJ,Config:()=>f.T,ConstRgbaBlack:()=>kt.Hj,ConstRgbaWhite:()=>kt.Rd,ConstVector2_0_0:()=>kt.z8,ConstVector2_1_1:()=>kt.Z5,ConstVector3_0_0_0:()=>kt.HQ,ConstVector3_1_1_1:()=>kt.oD,ConstVector4_0_0_0_0:()=>kt.TB,ConstVector4_0_0_0_1:()=>kt._d,ConstVector4_1_1_1_1:()=>kt.X9,ConstantScalarVariableShaderNode:()=>_n,ConstantVariableShader:()=>sn,ConstantVector2VariableShaderNode:()=>fn,ConstantVector3VariableShaderNode:()=>dn,ConstantVector4VariableShaderNode:()=>hn,Cube:()=>_e.I,CubeTexture:()=>je.b,CustomMaterialContent:()=>no.w,DataUtil:()=>st.$j,DefaultTextures:()=>eo.K1,DepthEncodeMaterialContent:()=>oo.g,DetectHighLuminanceMaterialContent:()=>ao.Q,DotProductShaderNode:()=>gn,DrcPointCloudImporter:()=>Ct,EVENT_CLICK:()=>Bn.qm,EVENT_KEY_DOWN:()=>Bn.S8,EVENT_KEY_PRESS:()=>Bn.bg,EVENT_KEY_UP:()=>Bn.XX,EVENT_MOUSE_DOWN:()=>Bn.QL,EVENT_MOUSE_ENTER:()=>Bn.WD,EVENT_MOUSE_LEAVE:()=>Bn.Bn,EVENT_MOUSE_MOVE:()=>Bn.vH,EVENT_MOUSE_OVER:()=>Bn.EA,EVENT_MOUSE_UP:()=>Bn.XZ,EVENT_MOUSE_WHEEL:()=>Bn.J5,EVENT_MSPOINTER_DOWN:()=>Bn.O3,EVENT_MSPOINTER_MOVE:()=>Bn.rO,EVENT_MSPOINTER_UP:()=>Bn.pF,EVENT_ORIENTATION_CHANGE:()=>Bn.lX,EVENT_POINTER_CANCEL:()=>Bn.oN,EVENT_POINTER_DOWN:()=>Bn.uR,EVENT_POINTER_ENTER:()=>Bn.Go,EVENT_POINTER_LEAVE:()=>Bn.x6,EVENT_POINTER_MOVE:()=>Bn.P6,EVENT_POINTER_OUT:()=>Bn.CD,EVENT_POINTER_OVER:()=>Bn._M,EVENT_POINTER_UP:()=>Bn.Hg,EVENT_RESIZE:()=>Bn.Oi,EVENT_TOUCH_CANCEL:()=>Bn.IU,EVENT_TOUCH_DOUBLE_TAP:()=>Bn.zQ,EVENT_TOUCH_DRAG:()=>Bn.oO,EVENT_TOUCH_END:()=>Bn.dM,EVENT_TOUCH_ENTER:()=>Bn.Ol,EVENT_TOUCH_HOLD:()=>Bn.BU,EVENT_TOUCH_LEAVE:()=>Bn.X2,EVENT_TOUCH_LONG_TAP:()=>Bn.Kq,EVENT_TOUCH_MOVE:()=>Bn.H9,EVENT_TOUCH_OUT:()=>Bn.g1,EVENT_TOUCH_OVER:()=>Bn.IE,EVENT_TOUCH_PINCH:()=>Bn.kV,EVENT_TOUCH_START:()=>Bn.CO,EVENT_TOUCH_SWIPE:()=>Bn.E0,EVENT_TOUCH_TAP:()=>Bn.LZ,Effekseer:()=>Vo.Effekseer,EffekseerComponent:()=>zo.a,EndShader:()=>Mn,Entity:()=>d.w,EntityRepository:()=>h.YY,EntityUIDOutputMaterialContent:()=>io.v,EnumClass:()=>st.wJ,Err:()=>st._,EventPubSub:()=>Bn.sB,Expression:()=>ot.r,ExpressionHelper:()=>rt,FileType:()=>x.pt,ForwardRenderPipeline:()=>bo,Frame:()=>xo.w,FrameBuffer:()=>Oe,Frustum:()=>ge.P,FurnaceTestMaterialContent:()=>ro.P,GLTF2_EXPORT_DRACO:()=>G,GLTF2_EXPORT_EMBEDDED:()=>O,GLTF2_EXPORT_GLB:()=>z,GLTF2_EXPORT_GLTF:()=>V,GLTF2_EXPORT_NO_DOWNLOAD:()=>U,GL_ACTIVE_ATTRIBUTES:()=>Lo.tPK,GL_ACTIVE_TEXTURE:()=>Lo.ZSk,GL_ACTIVE_UNIFORMS:()=>Lo.d5W,GL_ACTIVE_UNIFORM_BLOCKS:()=>Lo.j$I,GL_ALIASED_LINE_WIDTH_RANGE:()=>Lo.uZd,GL_ALIASED_POINT_SIZE_RANGE:()=>Lo.haZ,GL_ALPHA:()=>Lo.ts6,GL_ALPHA_BITS:()=>Lo.ahp,GL_ALREADY_SIGNALED:()=>Lo.XsZ,GL_ALWAYS:()=>Lo.qHe,GL_ANY_SAMPLES_PASSED:()=>Lo.sXl,GL_ANY_SAMPLES_PASSED_CONSERVATIVE:()=>Lo.YVc,GL_ARRAY_BUFFER:()=>Lo.Dgu,GL_ARRAY_BUFFER_BINDING:()=>Lo.RMO,GL_ATTACHED_SHADERS:()=>Lo.AuF,GL_BACK:()=>Lo.w16,GL_BLEND:()=>Lo.EKx,GL_BLEND_COLOR:()=>Lo.iFy,GL_BLEND_DST_ALPHA:()=>Lo.vFW,GL_BLEND_DST_RGB:()=>Lo._pd,GL_BLEND_EQUATION:()=>Lo.dg0,GL_BLEND_EQUATION_ALPHA:()=>Lo.GN,GL_BLEND_EQUATION_RGB:()=>Lo.nfE,GL_BLEND_SRC_ALPHA:()=>Lo.ec4,GL_BLEND_SRC_RGB:()=>Lo.DiI,GL_BLUE_BITS:()=>Lo.sDH,GL_BOOL:()=>Lo.lFD,GL_BOOL_VEC2:()=>Lo.e25,GL_BOOL_VEC3:()=>Lo.ZnS,GL_BOOL_VEC4:()=>Lo.SRI,GL_BROWSER_DEFAULT_WEBGL:()=>Lo.r5i,GL_BUFFER_SIZE:()=>Lo.VB6,GL_BUFFER_USAGE:()=>Lo.hOm,GL_CCW:()=>Lo.c6j,GL_CLAMP_TO_EDGE:()=>Lo.wil,GL_COLOR:()=>Lo.yvk,GL_COLOR_ATTACHMENT0:()=>Lo.all,GL_COLOR_ATTACHMENT0_WEBGL:()=>Lo.S_d,GL_COLOR_ATTACHMENT1:()=>Lo.VI9,GL_COLOR_ATTACHMENT10:()=>Lo.fc1,GL_COLOR_ATTACHMENT10_WEBGL:()=>Lo.r7,GL_COLOR_ATTACHMENT11:()=>Lo.Ybf,GL_COLOR_ATTACHMENT11_WEBGL:()=>Lo.OX6,GL_COLOR_ATTACHMENT12:()=>Lo.dWw,GL_COLOR_ATTACHMENT12_WEBGL:()=>Lo.xfA,GL_COLOR_ATTACHMENT13:()=>Lo._zN,GL_COLOR_ATTACHMENT13_WEBGL:()=>Lo.y4x,GL_COLOR_ATTACHMENT14:()=>Lo.RF7,GL_COLOR_ATTACHMENT14_WEBGL:()=>Lo.pGt,GL_COLOR_ATTACHMENT15:()=>Lo.Yhj,GL_COLOR_ATTACHMENT15_WEBGL:()=>Lo.wg3,GL_COLOR_ATTACHMENT1_WEBGL:()=>Lo.b6I,GL_COLOR_ATTACHMENT2:()=>Lo.aGx,GL_COLOR_ATTACHMENT2_WEBGL:()=>Lo.QIY,GL_COLOR_ATTACHMENT3:()=>Lo.hZy,GL_COLOR_ATTACHMENT3_WEBGL:()=>Lo.fr7,GL_COLOR_ATTACHMENT4:()=>Lo.arp,GL_COLOR_ATTACHMENT4_WEBGL:()=>Lo.ABF,GL_COLOR_ATTACHMENT5:()=>Lo.VOb,GL_COLOR_ATTACHMENT5_WEBGL:()=>Lo.zWr,GL_COLOR_ATTACHMENT6:()=>Lo.O6V,GL_COLOR_ATTACHMENT6_WEBGL:()=>Lo.GRZ,GL_COLOR_ATTACHMENT7:()=>Lo.VnX,GL_COLOR_ATTACHMENT7_WEBGL:()=>Lo.xOe,GL_COLOR_ATTACHMENT8:()=>Lo.ORN,GL_COLOR_ATTACHMENT8_WEBGL:()=>Lo.EFD,GL_COLOR_ATTACHMENT9:()=>Lo.hQu,GL_COLOR_ATTACHMENT9_WEBGL:()=>Lo.jQ,GL_COLOR_BUFFER_BIT:()=>Lo.xs6,GL_COLOR_CLEAR_VALUE:()=>Lo.Ct4,GL_COLOR_WRITEMASK:()=>Lo.eRy,GL_COMPARE_REF_TO_TEXTURE:()=>Lo.uIG,GL_COMPILE_STATUS:()=>Lo.fO4,GL_COMPRESSED_R11_EAC:()=>Lo.b74,GL_COMPRESSED_RG11_EAC:()=>Lo.s6M,GL_COMPRESSED_RGB8_ETC2:()=>Lo.T6I,GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:()=>Lo.H5b,GL_COMPRESSED_RGBA8_ETC2_EAC:()=>Lo.WKI,GL_COMPRESSED_RGBA_ASTC_10X10_KHR:()=>Lo.g05,GL_COMPRESSED_RGBA_ASTC_10X5_KHR:()=>Lo.cAE,GL_COMPRESSED_RGBA_ASTC_10X6_KHR:()=>Lo.H0Y,GL_COMPRESSED_RGBA_ASTC_10X8_KHR:()=>Lo.F2H,GL_COMPRESSED_RGBA_ASTC_12X10_KHR:()=>Lo.YRY,GL_COMPRESSED_RGBA_ASTC_12X12_KHR:()=>Lo.Kff,GL_COMPRESSED_RGBA_ASTC_4X4_KHR:()=>Lo.g5j,GL_COMPRESSED_RGBA_ASTC_5X4_KHR:()=>Lo.thb,GL_COMPRESSED_RGBA_ASTC_5X5_KHR:()=>Lo.Cmt,GL_COMPRESSED_RGBA_ASTC_6X5_KHR:()=>Lo.PxH,GL_COMPRESSED_RGBA_ASTC_6X6_KHR:()=>Lo.WAf,GL_COMPRESSED_RGBA_ASTC_8X5_KHR:()=>Lo.lTC,GL_COMPRESSED_RGBA_ASTC_8X6_KHR:()=>Lo.Y6T,GL_COMPRESSED_RGBA_ASTC_8X8_KHR:()=>Lo.SO0,GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:()=>Lo.GiW,GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:()=>Lo.vjF,GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:()=>Lo.RM,GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:()=>Lo.HAV,GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:()=>Lo.T5b,GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:()=>Lo.DmK,GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:()=>Lo.xe8,GL_COMPRESSED_RGB_ATC_WEBGL:()=>Lo.zJ6,GL_COMPRESSED_RGB_ETC1_WEBGL:()=>Lo.IBr,GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG:()=>Lo.sHs,GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG:()=>Lo.eVh,GL_COMPRESSED_RGB_S3TC_DXT1_EXT:()=>Lo.qbL,GL_COMPRESSED_SIGNED_R11_EAC:()=>Lo.KW4,GL_COMPRESSED_SIGNED_RG11_EAC:()=>Lo.Rmj,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR:()=>Lo.RD,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR:()=>Lo.n9r,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR:()=>Lo.a_J,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR:()=>Lo.GrH,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR:()=>Lo.RUH,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR:()=>Lo.rWx,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR:()=>Lo.T57,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR:()=>Lo.al5,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR:()=>Lo.RyF,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR:()=>Lo.WY$,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR:()=>Lo.lS4,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR:()=>Lo.ep0,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR:()=>Lo.dzD,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR:()=>Lo.LLx,GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:()=>Lo.ZZz,GL_COMPRESSED_SRGB8_ETC2:()=>Lo.w6b,GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:()=>Lo.Sei,GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:()=>Lo.yyQ,GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:()=>Lo.aXg,GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:()=>Lo.uSd,GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:()=>Lo.xNp,GL_COMPRESSED_TEXTURE_FORMATS:()=>Lo.Z4f,GL_CONDITION_SATISFIED:()=>Lo.PE4,GL_CONSTANT_ALPHA:()=>Lo.iQI,GL_CONSTANT_COLOR:()=>Lo.LS0,GL_CONTEXT_LOST_WEBGL:()=>Lo.dz0,GL_COPY_READ_BUFFER:()=>Lo.Krh,GL_COPY_READ_BUFFER_BINDING:()=>Lo.MLb,GL_COPY_WRITE_BUFFER:()=>Lo.bXV,GL_COPY_WRITE_BUFFER_BINDING:()=>Lo.tnf,GL_CULL_FACE:()=>Lo.xI7,GL_CULL_FACE_MODE:()=>Lo.nHc,GL_CURRENT_PROGRAM:()=>Lo.pDg,GL_CURRENT_QUERY:()=>Lo.ld1,GL_CURRENT_QUERY_EXT:()=>Lo.j4O,GL_CURRENT_VERTEX_ATTRIB:()=>Lo.gxY,GL_CW:()=>Lo.Lp7,GL_DATA_BYTE:()=>Lo.GZ4,GL_DATA_FLOAT:()=>Lo.w2T,GL_DATA_INT:()=>Lo.JAL,GL_DATA_SHORT:()=>Lo.ogh,GL_DATA_UNSIGNED_BYTE:()=>Lo.IWn,GL_DATA_UNSIGNED_INT:()=>Lo.VyP,GL_DATA_UNSIGNED_SHORT:()=>Lo.evL,GL_DECR:()=>Lo.jNC,GL_DECR_WRAP:()=>Lo.ICk,GL_DELETE_STATUS:()=>Lo.$GU,GL_DEPTH:()=>Lo.Ej$,GL_DEPTH24_STENCIL8:()=>Lo.ZRC,GL_DEPTH32F_STENCIL8:()=>Lo.mBK,GL_DEPTH_ATTACHMENT:()=>Lo.i6v,GL_DEPTH_BITS:()=>Lo.bD6,GL_DEPTH_BUFFER_BIT:()=>Lo.Bbv,GL_DEPTH_CLEAR_VALUE:()=>Lo.esd,GL_DEPTH_COMPONENT:()=>Lo.O25,GL_DEPTH_COMPONENT16:()=>Lo.hx4,GL_DEPTH_COMPONENT24:()=>Lo.i9e,GL_DEPTH_COMPONENT32F:()=>Lo.lyI,GL_DEPTH_FUNC:()=>Lo.DId,GL_DEPTH_RANGE:()=>Lo.EgH,GL_DEPTH_STENCIL:()=>Lo.NHQ,GL_DEPTH_STENCIL_ATTACHMENT:()=>Lo.xag,GL_DEPTH_TEST:()=>Lo.p23,GL_DEPTH_WRITEMASK:()=>Lo._wv,GL_DITHER:()=>Lo.fCO,GL_DONT_CARE:()=>Lo.EpB,GL_DRAW_BUFFER0:()=>Lo.a2U,GL_DRAW_BUFFER0_WEBGL:()=>Lo.owV,GL_DRAW_BUFFER1:()=>Lo.hjW,GL_DRAW_BUFFER10:()=>Lo.ZUo,GL_DRAW_BUFFER10_WEBGL:()=>Lo.fAZ,GL_DRAW_BUFFER11:()=>Lo.exC,GL_DRAW_BUFFER11_WEBGL:()=>Lo.I7V,GL_DRAW_BUFFER12:()=>Lo.l$P,GL_DRAW_BUFFER12_WEBGL:()=>Lo.DlF,GL_DRAW_BUFFER13:()=>Lo.eSO,GL_DRAW_BUFFER13_WEBGL:()=>Lo.sCC,GL_DRAW_BUFFER14:()=>Lo.XR4,GL_DRAW_BUFFER14_WEBGL:()=>Lo.$yO,GL_DRAW_BUFFER15:()=>Lo.ery,GL_DRAW_BUFFER15_WEBGL:()=>Lo.iaA,GL_DRAW_BUFFER1_WEBGL:()=>Lo.ft,GL_DRAW_BUFFER2:()=>Lo.omo,GL_DRAW_BUFFER2_WEBGL:()=>Lo.igB,GL_DRAW_BUFFER3:()=>Lo.hK,GL_DRAW_BUFFER3_WEBGL:()=>Lo.hBn,GL_DRAW_BUFFER4:()=>Lo.oBw,GL_DRAW_BUFFER4_WEBGL:()=>Lo.ynU,GL_DRAW_BUFFER5:()=>Lo.vUx,GL_DRAW_BUFFER5_WEBGL:()=>Lo.P72,GL_DRAW_BUFFER6:()=>Lo.ogk,GL_DRAW_BUFFER6_WEBGL:()=>Lo.AP$,GL_DRAW_BUFFER7:()=>Lo.hE8,GL_DRAW_BUFFER7_WEBGL:()=>Lo.LKE,GL_DRAW_BUFFER8:()=>Lo.o9f,GL_DRAW_BUFFER8_WEBGL:()=>Lo.a3f,GL_DRAW_BUFFER9:()=>Lo.hv4,GL_DRAW_BUFFER9_WEBGL:()=>Lo.j5p,GL_DRAW_FRAMEBUFFER:()=>Lo.rlz,GL_DRAW_FRAMEBUFFER_BINDING:()=>Lo.BhK,GL_DST_ALPHA:()=>Lo.zdb,GL_DST_COLOR:()=>Lo.qBr,GL_DYNAMIC_COPY:()=>Lo.G6D,GL_DYNAMIC_DRAW:()=>Lo.j4m,GL_DYNAMIC_READ:()=>Lo.P5b,GL_ELEMENT_ARRAY_BUFFER:()=>Lo.s_L,GL_ELEMENT_ARRAY_BUFFER_BINDING:()=>Lo.wJx,GL_EQUAL:()=>Lo.PtF,GL_FASTEST:()=>Lo.X6K,GL_FLOAT_32_UNSIGNED_INT_24_8_REV:()=>Lo.LWw,GL_FLOAT_MAT2:()=>Lo.yqV,GL_FLOAT_MAT2X3:()=>Lo.pIg,GL_FLOAT_MAT2X4:()=>Lo.yI2,GL_FLOAT_MAT3:()=>Lo.rOH,GL_FLOAT_MAT3X2:()=>Lo.r7E,GL_FLOAT_MAT3X4:()=>Lo.rMs,GL_FLOAT_MAT4:()=>Lo.ybN,GL_FLOAT_MAT4X2:()=>Lo.yAt,GL_FLOAT_MAT4X3:()=>Lo.HAd,GL_FLOAT_VEC2:()=>Lo.qCb,GL_FLOAT_VEC3:()=>Lo.j0Z,GL_FLOAT_VEC4:()=>Lo.qn5,GL_FRAGMENT_SHADER:()=>Lo.l_1,GL_FRAGMENT_SHADER_DERIVATIVE_HINT:()=>Lo.XXU,GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:()=>Lo.FZT,GL_FRAMEBUFFER:()=>Lo.C$$,GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:()=>Lo.Vds,GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:()=>Lo.hal,GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:()=>Lo.sIk,GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT:()=>Lo.aHb,GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:()=>Lo.zgu,GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT:()=>Lo.Pa4,GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:()=>Lo.K07,GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:()=>Lo.sUR,GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:()=>Lo.sIe,GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:()=>Lo.VYc,GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:()=>Lo.U82,GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:()=>Lo.TS8,GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:()=>Lo.DZo,GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:()=>Lo.qQO,GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:()=>Lo.b4e,GL_FRAMEBUFFER_BINDING:()=>Lo.cbo,GL_FRAMEBUFFER_COMPLETE:()=>Lo.YhR,GL_FRAMEBUFFER_DEFAULT:()=>Lo.u6J,GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:()=>Lo.rJm,GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:()=>Lo.NI$,GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:()=>Lo.o9k,GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:()=>Lo.Bby,GL_FRAMEBUFFER_UNSUPPORTED:()=>Lo.Wh$,GL_FRONT:()=>Lo.ynL,GL_FRONT_AND_BACK:()=>Lo.O5B,GL_FRONT_FACE:()=>Lo.ICq,GL_FUNC_ADD:()=>Lo.XF9,GL_FUNC_REVERSE_SUBTRACT:()=>Lo.HX7,GL_FUNC_SUBSTRACT:()=>Lo.d_T,GL_GENERATE_MIPMAP_HINT:()=>Lo.RBY,GL_GEQUAL:()=>Lo.yoA,GL_GPU_DISJOINT_EXT:()=>Lo.Mtk,GL_GREATER:()=>Lo.La2,GL_GREEN_BITS:()=>Lo.zqI,GL_HALF_FLOAT:()=>Lo.t39,GL_HALF_FLOAT_OES:()=>Lo.R89,GL_HIGH_FLOAT:()=>Lo.aT8,GL_HIGH_INT:()=>Lo.$9U,GL_IMPLEMENTATION_COLOR_READ_FORMAT:()=>Lo.cB$,GL_IMPLEMENTATION_COLOR_READ_TYPE:()=>Lo.XGp,GL_INCR:()=>Lo.jpq,GL_INCR_WRAP:()=>Lo.Kbv,GL_INTERLEAVED_ATTRIBS:()=>Lo.GwV,GL_INT_2_10_10_10_REV:()=>Lo.zfP,GL_INT_SAMPLER_2D:()=>Lo.W5v,GL_INT_SAMPLER_2D_ARRAY:()=>Lo.w5x,GL_INT_SAMPLER_3D:()=>Lo.xZA,GL_INT_SAMPLER_CUBE:()=>Lo.T9W,GL_INT_VEC2:()=>Lo.tey,GL_INT_VEC3:()=>Lo.ASL,GL_INT_VEC4:()=>Lo.tVl,GL_INVALID_ENUM:()=>Lo.MEG,GL_INVALID_FRAMEBUFFER_OPERATION:()=>Lo.cjV,GL_INVALID_INDEX:()=>Lo.JMu,GL_INVALID_OPERATION:()=>Lo.kJW,GL_INVALID_VALUE:()=>Lo.GgK,GL_INVERT:()=>Lo.xJL,GL_KEEP:()=>Lo.uB_,GL_LEQUAL:()=>Lo.zcS,GL_LESS:()=>Lo.mr6,GL_LINEAR:()=>Lo.uPu,GL_LINEAR_MIPMAP_LINEAR:()=>Lo.JE7,GL_LINEAR_MIPMAP_NEAREST:()=>Lo.gcL,GL_LINES:()=>Lo.YKR,GL_LINE_LOOP:()=>Lo._sq,GL_LINE_STRIP:()=>Lo.SS_,GL_LINE_WIDTH:()=>Lo.aNE,GL_LINK_STATUS:()=>Lo.kEk,GL_LOW_FLOAT:()=>Lo.keo,GL_LOW_INT:()=>Lo.D$P,GL_LUMINANCE:()=>Lo.$S4,GL_LUMINANCE_ALPHA:()=>Lo.GcC,GL_MAX:()=>Lo.$kA,GL_MAX_3D_TEXTURE_SIZE:()=>Lo.jRf,GL_MAX_ARRAY_TEXTURE_LAYERS:()=>Lo.Iro,GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL:()=>Lo.D0T,GL_MAX_COLOR_ATTACHMENTS:()=>Lo.ixJ,GL_MAX_COLOR_ATTACHMENTS_WEBGL:()=>Lo.k5Z,GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:()=>Lo.qMS,GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:()=>Lo.Bu$,GL_MAX_COMBINED_UNIFORM_BLOCKS:()=>Lo.TWN,GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:()=>Lo.sWE,GL_MAX_CUBE_MAP_TEXTURE_SIZE:()=>Lo.eeI,GL_MAX_DRAW_BUFFERS:()=>Lo.apK,GL_MAX_DRAW_BUFFERS_WEBGL:()=>Lo.gRO,GL_MAX_ELEMENTS_INDICES:()=>Lo.vMg,GL_MAX_ELEMENTS_VERTICES:()=>Lo.NOS,GL_MAX_ELEMENT_INDEX:()=>Lo.D0Q,GL_MAX_EXT:()=>Lo.hLS,GL_MAX_FRAGMENT_INPUT_COMPONENTS:()=>Lo.IFQ,GL_MAX_FRAGMENT_UNIFORM_BLOCKS:()=>Lo.Ekz,GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:()=>Lo.Ezs,GL_MAX_FRAGMENT_UNIFORM_VECTORS:()=>Lo.EXU,GL_MAX_PROGRAM_TEXEL_OFFSET:()=>Lo.ZTl,GL_MAX_RENDERBUFFER_SIZE:()=>Lo.ij8,GL_MAX_SAMPLES:()=>Lo.dNB,GL_MAX_SERVER_WAIT_TIMEOUT:()=>Lo.HXT,GL_MAX_TEXTURE_IMAGE_UNITS:()=>Lo.Hd_,GL_MAX_TEXTURE_LOD_BIAS:()=>Lo.zT4,GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:()=>Lo.PGi,GL_MAX_TEXTURE_SIZE:()=>Lo.Xhg,GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:()=>Lo.dLg,GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:()=>Lo._wJ,GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:()=>Lo.dHy,GL_MAX_UNIFORM_BLOCK_SIZE:()=>Lo.wKb,GL_MAX_UNIFORM_BUFFER_BINDINGS:()=>Lo.kiM,GL_MAX_VARYING_COMPONENTS:()=>Lo.J6D,GL_MAX_VARYING_VECTORS:()=>Lo.VvC,GL_MAX_VERTEX_ATTRIBS:()=>Lo.krh,GL_MAX_VERTEX_OUTPUT_COMPONENTS:()=>Lo.x75,GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:()=>Lo.oHg,GL_MAX_VERTEX_UNIFORM_BLOCKS:()=>Lo.gfP,GL_MAX_VERTEX_UNIFORM_COMPONENTS:()=>Lo.E2B,GL_MAX_VERTEX_UNIFORM_VECTORS:()=>Lo.qxn,GL_MAX_VIEWPORT_DIMS:()=>Lo.ieh,GL_MEDIUM_FLOAT:()=>Lo.T5f,GL_MEDIUM_INT:()=>Lo.qLf,GL_MIN:()=>Lo.TZR,GL_MIN_EXT:()=>Lo.P9j,GL_MIN_PROGRAM_TEXEL_OFFSET:()=>Lo.xG3,GL_MIRRORED_REPEAT:()=>Lo.T7M,GL_NEAREST:()=>Lo.VbN,GL_NEAREST_MIPMAP_LINEAR:()=>Lo.GuE,GL_NEAREST_MIPMAP_NEAREST:()=>Lo.Bm9,GL_NEVER:()=>Lo.xTJ,GL_NICEST:()=>Lo.LBe,GL_NONE:()=>Lo.pWd,GL_NOTEQUAL:()=>Lo.IZB,GL_NO_ERROR:()=>Lo.VgI,GL_OBJECT_TYPE:()=>Lo.JoP,GL_ONE:()=>Lo.RCl,GL_ONE_MINUS_CONSTANT_ALPHA:()=>Lo.YF_,GL_ONE_MINUS_CONSTANT_COLOR:()=>Lo.d7Z,GL_ONE_MINUS_DST_ALPHA:()=>Lo.LvL,GL_ONE_MINUS_DST_COLOR:()=>Lo.Esg,GL_ONE_MINUS_SRC_ALPHA:()=>Lo.kF4,GL_ONE_MINUS_SRC_COLOR:()=>Lo.Nb9,GL_OUT_OF_MEMORY:()=>Lo.h79,GL_PACK_ALIGNMENT:()=>Lo.a21,GL_PACK_ROW_LENGTH:()=>Lo.Crs,GL_PACK_SKIP_PIXELS:()=>Lo.Yt2,GL_PACK_SKIP_ROWS:()=>Lo.ATe,GL_PIXEL_PACK_BUFFER:()=>Lo.gok,GL_PIXEL_PACK_BUFFER_BINDING:()=>Lo.eit,GL_PIXEL_UNPACK_BUFFER:()=>Lo.ZB,GL_PIXEL_UNPACK_BUFFER_BINDING:()=>Lo.xME,GL_PIXEL_UNSIGNED_BYTE:()=>Lo.qu3,GL_PIXEL_UNSIGNED_SHORT_4_4_4_4:()=>Lo.o9E,GL_PIXEL_UNSIGNED_SHORT_5_5_5_1:()=>Lo.kvl,GL_PIXEL_UNSIGNED_SHORT_5_6_5:()=>Lo.fHf,GL_POINTS:()=>Lo.GKA,GL_POLYGON_OFFSET_FACTOR:()=>Lo.H0Z,GL_POLYGON_OFFSET_FILL:()=>Lo.pwz,GL_POLYGON_OFFSET_UNITS:()=>Lo.DCt,GL_QUERY_COUNTER_BITS_EXT:()=>Lo.H_C,GL_QUERY_RESULT:()=>Lo.nAp,GL_QUERY_RESULT_AVAILABLE:()=>Lo.XUN,GL_QUERY_RESULT_AVAILABLE_EXT:()=>Lo.XWT,GL_QUERY_RESULT_EXT:()=>Lo.Lmi,GL_R11F_G11F_B10F:()=>Lo.Nsx,GL_R16F:()=>Lo.GbE,GL_R16I:()=>Lo.PSb,GL_R16UI:()=>Lo.GbL,GL_R32F:()=>Lo.Ajb,GL_R32I:()=>Lo.tUw,GL_R32UI:()=>Lo.g3j,GL_R8:()=>Lo.pgB,GL_R8I:()=>Lo.YrJ,GL_R8UI:()=>Lo.Zp7,GL_R8_SNORM:()=>Lo.zVs,GL_RASTERIZER_DISCARD:()=>Lo.lHw,GL_READ_BUFFER:()=>Lo.QYl,GL_READ_FRAMEBUFFER:()=>Lo.bWC,GL_READ_FRAMEBUFFER_BINDING:()=>Lo.r96,GL_RED:()=>Lo.o0M,GL_RED_BITS:()=>Lo.VFj,GL_RED_INTEGER:()=>Lo.tB6,GL_RENDERBUFFER:()=>Lo.zLE,GL_RENDERBUFFER_ALPHA_SIZE:()=>Lo.c_q,GL_RENDERBUFFER_BINDING:()=>Lo.j0H,GL_RENDERBUFFER_BLUE_SIZE:()=>Lo.uJz,GL_RENDERBUFFER_DEPTH_SIZE:()=>Lo.LT,GL_RENDERBUFFER_GREEN_SIZE:()=>Lo.R9X,GL_RENDERBUFFER_HEIGHT:()=>Lo.dEP,GL_RENDERBUFFER_INTERNAL_FORMAT:()=>Lo.t3t,GL_RENDERBUFFER_RED_SIZE:()=>Lo.JRB,GL_RENDERBUFFER_SAMPLES:()=>Lo.DJB,GL_RENDERBUFFER_STENCIL_SIZE:()=>Lo.X_L,GL_RENDERBUFFER_WIDTH:()=>Lo.q5F,GL_RENDERER:()=>Lo.GUp,GL_REPEAT:()=>Lo._SQ,GL_REPLACE:()=>Lo.hWT,GL_RG:()=>Lo.wfs,GL_RG16F:()=>Lo.Vn9,GL_RG16I:()=>Lo.ORZ,GL_RG16UI:()=>Lo.h6k,GL_RG32F:()=>Lo.rBz,GL_RG32I:()=>Lo.kNd,GL_RG32UI:()=>Lo.NtV,GL_RG8:()=>Lo.w9,GL_RG8I:()=>Lo.bAr,GL_RG8UI:()=>Lo.GBD,GL_RG8_SNORM:()=>Lo.wV_,GL_RGB:()=>Lo.wmj,GL_RGB10_A2:()=>Lo.zc7,GL_RGB10_A2UI:()=>Lo.XPd,GL_RGB16F:()=>Lo.PZV,GL_RGB16I:()=>Lo.Ws5,GL_RGB16UI:()=>Lo.P8g,GL_RGB32F:()=>Lo.Xw_,GL_RGB32F_EXT:()=>Lo.jec,GL_RGB32I:()=>Lo.Qmb,GL_RGB32UI:()=>Lo.X34,GL_RGB565:()=>Lo.UjW,GL_RGB5_A1:()=>Lo.KW8,GL_RGB8:()=>Lo.gAe,GL_RGB8I:()=>Lo.Z2n,GL_RGB8UI:()=>Lo.WaA,GL_RGB8_SNORM:()=>Lo.ogd,GL_RGB9_E5:()=>Lo.aiV,GL_RGBA:()=>Lo.LnC,GL_RGBA16F:()=>Lo.UbO,GL_RGBA16I:()=>Lo.nXm,GL_RGBA16UI:()=>Lo.gbn,GL_RGBA32F:()=>Lo.OdY,GL_RGBA32F_EXT:()=>Lo.QOu,GL_RGBA32I:()=>Lo.jo5,GL_RGBA32UI:()=>Lo.kSd,GL_RGBA4:()=>Lo.NPM,GL_RGBA8:()=>Lo.NVQ,GL_RGBA8I:()=>Lo.O$t,GL_RGBA8UI:()=>Lo.bFC,GL_RGBA8_SNORM:()=>Lo.r2o,GL_RGBA_INTEGER:()=>Lo.Cqp,GL_RGB_INTEGER:()=>Lo.pDF,GL_RG_INTEGER:()=>Lo.DvS,GL_SAMPLER_2D:()=>Lo.eSj,GL_SAMPLER_2D_ARRAY:()=>Lo.W1C,GL_SAMPLER_2D_ARRAY_SHADOW:()=>Lo.n82,GL_SAMPLER_2D_SHADOW:()=>Lo.RUg,GL_SAMPLER_3D:()=>Lo.JU7,GL_SAMPLER_BINDING:()=>Lo.r2d,GL_SAMPLER_CUBE:()=>Lo.RF4,GL_SAMPLER_CUBE_SHADOW:()=>Lo.uq5,GL_SAMPLES:()=>Lo._j2,GL_SAMPLE_ALPHA_TO_COVERAGE:()=>Lo.X3l,GL_SAMPLE_BUFFERS:()=>Lo.Vex,GL_SAMPLE_COVERAGE:()=>Lo.wV$,GL_SAMPLE_COVERAGE_INVERT:()=>Lo.N21,GL_SAMPLE_COVERAGE_VALUE:()=>Lo.om_,GL_SCISSOR_BOX:()=>Lo.LBv,GL_SCISSOR_TEST:()=>Lo.Y1B,GL_SEPARATE_ATTRIBS:()=>Lo.ovc,GL_SHADER_TYPE:()=>Lo.d9j,GL_SHADING_LANGUAGE_VERSION:()=>Lo.vt6,GL_SIGNALED:()=>Lo.Q6N,GL_SIGNED_NORMALIZED:()=>Lo.lc5,GL_SRC_ALPHA:()=>Lo.ovX,GL_SRC_ALPHA_SATURATE:()=>Lo.UZ0,GL_SRC_COLOR:()=>Lo.JR_,GL_SRGB:()=>Lo.JHM,GL_SRGB8:()=>Lo.Tj_,GL_SRGB8_ALPHA8:()=>Lo.CvS,GL_SRGB8_ALPHA8_EXT:()=>Lo.MUv,GL_SRGB_ALPHA_EXT:()=>Lo.SWC,GL_SRGB_EXT:()=>Lo.Jh8,GL_STATIC_COPY:()=>Lo.Luz,GL_STATIC_DRAW:()=>Lo.EPb,GL_STATIC_READ:()=>Lo.upx,GL_STENCIL:()=>Lo.ZyF,GL_STENCIL_ATTACHMENT:()=>Lo.xD,GL_STENCIL_BACK_FAIL:()=>Lo.C3$,GL_STENCIL_BACK_FUNC:()=>Lo.WcB,GL_STENCIL_BACK_PASS_DEPTH_FAIL:()=>Lo.UeU,GL_STENCIL_BACK_PASS_DEPTH_PASS:()=>Lo.Hmk,GL_STENCIL_BACK_REF:()=>Lo.$s3,GL_STENCIL_BACK_VALUE_MASK:()=>Lo.kVg,GL_STENCIL_BACK_WRITEMASK:()=>Lo.TjR,GL_STENCIL_BITS:()=>Lo.IUR,GL_STENCIL_BUFFER_BIT:()=>Lo.o5C,GL_STENCIL_CLEAR_VALUE:()=>Lo.Na_,GL_STENCIL_FAIL:()=>Lo._Vk,GL_STENCIL_FUNC:()=>Lo.y6O,GL_STENCIL_INDEX:()=>Lo.UY2,GL_STENCIL_INDEX8:()=>Lo.U8R,GL_STENCIL_PASS_DEPTH_FAIL:()=>Lo.uxs,GL_STENCIL_PASS_DEPTH_PASS:()=>Lo.lj5,GL_STENCIL_REF:()=>Lo.B9H,GL_STENCIL_TEST:()=>Lo.aT3,GL_STENCIL_VALUE_MASK:()=>Lo.gb6,GL_STENCIL_WRITEMASK:()=>Lo.TLR,GL_STREAM_COPY:()=>Lo.VgQ,GL_STREAM_DRAW:()=>Lo.cu3,GL_STREAM_READ:()=>Lo.ERv,GL_SUBPIXEL_BITS:()=>Lo.enB,GL_SYNC_CONDITION:()=>Lo.kAS,GL_SYNC_FENCE:()=>Lo.gSE,GL_SYNC_FLAGS:()=>Lo.SI2,GL_SYNC_FLUSH_COMMANDS_BIT:()=>Lo.SIq,GL_SYNC_GPU_COMMANDS_COMPLETE:()=>Lo.wez,GL_SYNC_STATUS:()=>Lo.dPv,GL_TEXTURE:()=>Lo.elk,GL_TEXTURE0:()=>Lo.Eod,GL_TEXTURE1:()=>Lo.xM1,GL_TEXTURE10:()=>Lo.NFn,GL_TEXTURE11:()=>Lo.UhB,GL_TEXTURE12:()=>Lo.$1S,GL_TEXTURE13:()=>Lo.G3$,GL_TEXTURE14:()=>Lo.NLr,GL_TEXTURE15:()=>Lo.UnF,GL_TEXTURE16:()=>Lo.Nqf,GL_TEXTURE17:()=>Lo.G9d,GL_TEXTURE18:()=>Lo.$_W,GL_TEXTURE19:()=>Lo.URV,GL_TEXTURE2:()=>Lo.EJp,GL_TEXTURE20:()=>Lo.gFc,GL_TEXTURE21:()=>Lo.$20,GL_TEXTURE22:()=>Lo.UoN,GL_TEXTURE23:()=>Lo.NMz,GL_TEXTURE24:()=>Lo.U5A,GL_TEXTURE25:()=>Lo.Nrn,GL_TEXTURE26:()=>Lo.UuR,GL_TEXTURE27:()=>Lo.$NS,GL_TEXTURE28:()=>Lo.U$E,GL_TEXTURE29:()=>Lo.Nxr,GL_TEXTURE3:()=>Lo.L2q,GL_TEXTURE30:()=>Lo.JKl,GL_TEXTURE31:()=>Lo.mPm,GL_TEXTURE4:()=>Lo.Euh,GL_TEXTURE5:()=>Lo.xS5,GL_TEXTURE6:()=>Lo.q_N,GL_TEXTURE7:()=>Lo.xrP,GL_TEXTURE8:()=>Lo.qVF,GL_TEXTURE9:()=>Lo.LTm,GL_TEXTURE_2D:()=>Lo.VwS,GL_TEXTURE_2D_ARRAY:()=>Lo.RHW,GL_TEXTURE_3D:()=>Lo.gdC,GL_TEXTURE_BASE_LEVEL:()=>Lo.vuU,GL_TEXTURE_BINDING_2D:()=>Lo.TYA,GL_TEXTURE_BINDING_2D_ARRAY:()=>Lo.zlu,GL_TEXTURE_BINDING_3D:()=>Lo.Qcv,GL_TEXTURE_BINDING_CUBE_MAP:()=>Lo.hUo,GL_TEXTURE_COMPARE_FUNC:()=>Lo.VEW,GL_TEXTURE_COMPARE_MODE:()=>Lo.eCD,GL_TEXTURE_CUBE_MAP:()=>Lo.P_R,GL_TEXTURE_CUBE_MAP_NEGATIVE_X:()=>Lo.W8X,GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:()=>Lo.r4W,GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:()=>Lo.kqJ,GL_TEXTURE_CUBE_MAP_POSITIVE_X:()=>Lo.spg,GL_TEXTURE_CUBE_MAP_POSITIVE_Y:()=>Lo.lN4,GL_TEXTURE_CUBE_MAP_POSITIVE_Z:()=>Lo.s65,GL_TEXTURE_IMMUTABLE_FORMAT:()=>Lo.N65,GL_TEXTURE_IMMUTABLE_LEVELS:()=>Lo.rNS,GL_TEXTURE_MAG_FILTER:()=>Lo.Zwe,GL_TEXTURE_MAX_ANISOTROPY_EXT:()=>Lo.OQr,GL_TEXTURE_MAX_LEVEL:()=>Lo.KLy,GL_TEXTURE_MAX_LOD:()=>Lo.T41,GL_TEXTURE_MIN_FILTER:()=>Lo.Y3t,GL_TEXTURE_MIN_LOD:()=>Lo.Ryb,GL_TEXTURE_WRAP_R:()=>Lo.oU0,GL_TEXTURE_WRAP_S:()=>Lo.hgN,GL_TEXTURE_WRAP_T:()=>Lo.aEz,GL_TIMEOUT_EXPIRED:()=>Lo.wJN,GL_TIMEOUT_IGNORED:()=>Lo.Rpj,GL_TIMESTAMP_EXT:()=>Lo.bB_,GL_TIME_ELAPSED_EXT:()=>Lo.doc,GL_TRANSFORM_FEEDBACK:()=>Lo.Dd_,GL_TRANSFORM_FEEDBACK_ACTIVE:()=>Lo.Yjk,GL_TRANSFORM_FEEDBACK_BINDING:()=>Lo.FVz,GL_TRANSFORM_FEEDBACK_BUFFER:()=>Lo.iq4,GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:()=>Lo.o0W,GL_TRANSFORM_FEEDBACK_BUFFER_MODE:()=>Lo.wWS,GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:()=>Lo.SSH,GL_TRANSFORM_FEEDBACK_BUFFER_START:()=>Lo.PMe,GL_TRANSFORM_FEEDBACK_PAUSED:()=>Lo.Y3K,GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:()=>Lo.YbW,GL_TRANSFORM_FEEDBACK_VARYINGS:()=>Lo.dTz,GL_TRIANGLES:()=>Lo.oTQ,GL_TRIANGLE_FAN:()=>Lo.$VS,GL_TRIANGLE_STRIP:()=>Lo.gIl,GL_UNIFORM_ARRAY_STRIDE:()=>Lo.XTL,GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS:()=>Lo.ark,GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:()=>Lo.Ts0,GL_UNIFORM_BLOCK_BINDING:()=>Lo.t2z,GL_UNIFORM_BLOCK_DATA_SIZE:()=>Lo.CQ$,GL_UNIFORM_BLOCK_INDEX:()=>Lo.ILo,GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:()=>Lo.ok8,GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:()=>Lo.uqn,GL_UNIFORM_BUFFER:()=>Lo.yKc,GL_UNIFORM_BUFFER_BINDING:()=>Lo.yzJ,GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT:()=>Lo.aqx,GL_UNIFORM_BUFFER_SIZE:()=>Lo.MXJ,GL_UNIFORM_BUFFER_START:()=>Lo.b2G,GL_UNIFORM_IS_ROW_MAJOR:()=>Lo.HCV,GL_UNIFORM_MATRIX_STRIDE:()=>Lo.F28,GL_UNIFORM_OFFSET:()=>Lo.z3$,GL_UNIFORM_SIZE:()=>Lo.ZR9,GL_UNIFORM_TYPE:()=>Lo.SX,GL_UNMASKED_RENDERER_WEBGL:()=>Lo.rKV,GL_UNMASKED_VENDOR_WEBGL:()=>Lo.at_,GL_UNPACK_ALIGNMENT:()=>Lo.Fpk,GL_UNPACK_COLORSPACE_CONVERSION_WEBGL:()=>Lo.uGn,GL_UNPACK_FLIP_Y_WEBGL:()=>Lo.lX_,GL_UNPACK_IMAGE_HEIGHT:()=>Lo.NTE,GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL:()=>Lo.s4R,GL_UNPACK_ROW_LENGTH:()=>Lo.BFJ,GL_UNPACK_SKIP_IMAGES:()=>Lo.YDq,GL_UNPACK_SKIP_PIXELS:()=>Lo.hFl,GL_UNPACK_SKIP_ROWS:()=>Lo.Zzs,GL_UNSIGNALED:()=>Lo.hcD,GL_UNSIGNED_INT_10F_11F_11F_REV:()=>Lo.gQC,GL_UNSIGNED_INT_24_8:()=>Lo.S1f,GL_UNSIGNED_INT_24_8_WEBGL:()=>Lo.quc,GL_UNSIGNED_INT_2_10_10_10_REV:()=>Lo.HgV,GL_UNSIGNED_INT_5_9_9_9_REV:()=>Lo.IRf,GL_UNSIGNED_INT_SAMPLER_2D:()=>Lo.Uhp,GL_UNSIGNED_INT_SAMPLER_2D_ARRAY:()=>Lo.wQM,GL_UNSIGNED_INT_SAMPLER_3D:()=>Lo.HBF,GL_UNSIGNED_INT_SAMPLER_CUBE:()=>Lo.FFn,GL_UNSIGNED_INT_VEC2:()=>Lo.x$4,GL_UNSIGNED_INT_VEC3:()=>Lo.qS3,GL_UNSIGNED_INT_VEC4:()=>Lo.j1H,GL_UNSIGNED_NORMALIZED:()=>Lo.C0M,GL_UNSIGNED_NORMALIZED_EXT:()=>Lo.mwi,GL_VALIDATE_STATUS:()=>Lo.ADN,GL_VENDOR:()=>Lo.LLr,GL_VERSION:()=>Lo.ftY,GL_VERTEX_ARRAY_BINDING:()=>Lo.FQ_,GL_VERTEX_ARRAY_BINDING_OES:()=>Lo.BJP,GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:()=>Lo.JaO,GL_VERTEX_ATTRIB_ARRAY_DIVISOR:()=>Lo.nPH,GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:()=>Lo.$5m,GL_VERTEX_ATTRIB_ARRAY_ENABLED:()=>Lo._dw,GL_VERTEX_ATTRIB_ARRAY_INTEGER:()=>Lo.fb5,GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:()=>Lo._4j,GL_VERTEX_ATTRIB_ARRAY_POINTER:()=>Lo.EoG,GL_VERTEX_ATTRIB_ARRAY_SIZE:()=>Lo.cHm,GL_VERTEX_ATTRIB_ARRAY_STRIDE:()=>Lo.ABd,GL_VERTEX_ATTRIB_ARRAY_TYPE:()=>Lo.R0s,GL_VERTEX_SHADER:()=>Lo.pjY,GL_VIEWPORT:()=>Lo.JqV,GL_WAIT_FAILED:()=>Lo.G9S,GL_ZERO:()=>Lo.fFt,GetComponentFromEntities:()=>g,Gizmo:()=>Ee.F,GlobalDataRepository:()=>m.q,GlobalRetarget:()=>c.WB,GlobalRetargetReverse:()=>c.i4,Gltf2Exporter:()=>k,Gltf2Importer:()=>Mt.a,GltfImporter:()=>Zt,GreaterShaderNode:()=>Pn,Grid:()=>ue,HdriFormat:()=>x.P8,INPUT_HANDLING_STATE_CAMERA_CONTROLLER:()=>Bn.o9,INPUT_HANDLING_STATE_GIZMO_SCALE:()=>Bn.B$,INPUT_HANDLING_STATE_GIZMO_TRANSLATION:()=>Bn.cK,INPUT_HANDLING_STATE_NONE:()=>Bn.Wt,IShape:()=>le.d,IdentityMatrix33:()=>kt.q_,IdentityMatrix44:()=>kt.qp,IfStatementShader:()=>Un,IfStatementShaderNode:()=>kn,ImageUtil:()=>st.aV,InputManager:()=>Bn.eN,Is:()=>st.Is,IsObj:()=>st.Qg,Joint:()=>de,KTX2TextureLoader:()=>Mo.w,LightComponent:()=>c.Mm,LightGizmo:()=>Te.h,LightType:()=>x.zY,Line:()=>he,LocatorGizmo:()=>Se.r,LogLevel:()=>st.$b,LogQuaternion:()=>kt.jZ,Logger:()=>st.Vy,MToon0xMaterialContent:()=>so.E,MToon1MaterialContent:()=>lo.t,MatCapMaterialContent:()=>co.R,Material:()=>nn.i,MaterialHelper:()=>Ne.m,MaterialRepository:()=>on.s,MathClassUtil:()=>kt.nx,MathUtil:()=>kt.St,Matrix22:()=>kt.qS,Matrix33:()=>kt.kU,Matrix44:()=>kt._0,MemoryManager:()=>p.X,MergeVectorShaderNode:()=>qn,Mesh:()=>ye.e,MeshComponent:()=>c.Fl,MeshHelper:()=>xt,MeshRendererComponent:()=>c.ef,MiscUtil:()=>st.zH,ModelConverter:()=>gt.w,ModuleManager:()=>Bn.em,MultiplyShaderNode:()=>yn,MutableColorRgb:()=>kt.$C,MutableColorRgba:()=>kt.OX,MutableMatrix22:()=>kt.Qx,MutableMatrix33:()=>kt._b,MutableMatrix44:()=>kt.gJ,MutableQuaternion:()=>kt.hY,MutableScalar:()=>kt.n9,MutableScalar_:()=>kt.eZ,MutableScalard:()=>kt.Zt,MutableVector2:()=>kt.A3,MutableVector2_:()=>kt.ly,MutableVector2d:()=>kt.eE,MutableVector3:()=>kt.tp,MutableVector3_:()=>kt.Qj,MutableVector3d:()=>kt.vv,MutableVector4:()=>kt.Am,MutableVector4_:()=>kt.HO,MutableVector4d:()=>kt.aJ,None:()=>st.NV,NormalMatrixShaderNode:()=>Cn,NormalizeShaderNode:()=>xn,OimoPhysicsStrategy:()=>ct.N,Ok:()=>st.Ok,OrbitCameraController:()=>s.w,OutColorShaderNode:()=>Fn,OutPositionShaderNode:()=>Dn,PhysicsComponent:()=>c.le,PixelFormat:()=>x.Ab,Plane:()=>me.Z,Primitive:()=>be.s,PrimitiveMode:()=>x.Rs,PrimitiveSortKey_BitLength_Depth:()=>ve.hN,PrimitiveSortKey_BitLength_Material:()=>ve.l$,PrimitiveSortKey_BitLength_PrimitiveType:()=>ve.$y,PrimitiveSortKey_BitLength_TranslucencyType:()=>ve.nm,PrimitiveSortKey_BitOffset_Material:()=>ve.AE,PrimitiveSortKey_BitOffset_PrimitiveType:()=>ve.a8,PrimitiveSortKey_BitOffset_TranslucencyType:()=>ve.mP,PrimitiveSortKey_BitOffset_ViewportLayer:()=>ve.sY,ProcessApproach:()=>x.m7,ProcessApproachClass:()=>x.av,ProcessStage:()=>x.Ow,ProjectionMatrixShaderNode:()=>wn,Quaternion:()=>kt.PT,RenderBuffer:()=>qe,RenderBufferTarget:()=>x.qB,RenderPass:()=>De.A,RenderPassHelper:()=>Le,RenderTargetTexture:()=>Ge.$,RenderTargetTextureCube:()=>Ye._,RenderableHelper:()=>tt,RhodoniteImportExtension:()=>Jt.j,RnException:()=>st.OD,RnObject:()=>v.E,RnPromise:()=>st.m9,Sampler:()=>Fe.L,Scalar:()=>kt.X5,Scalar_:()=>kt.Cj,Scalard:()=>kt.vQ,ScaleGizmo:()=>we.t,SceneGraphComponent:()=>c.K,ShaderGraphResolver:()=>Kn,ShaderNode:()=>x.mq,ShaderSemantics:()=>x.lk,ShaderSemanticsClass:()=>x.jc,ShaderType:()=>x.Co,ShaderVariableType:()=>x.kj,ShaderityUtilityWebGL:()=>$n.r,ShadingModel:()=>x.yD,ShadowMap:()=>x.pC,ShadowMapDecodeClassicMaterialContent:()=>_o.X,SimpleVertexAttribute:()=>Ie,SkeletalComponent:()=>c.DN,Some:()=>st.p2,Sphere:()=>pe,SphereCollider:()=>zt,SplitVectorShaderNode:()=>Qn,SymbolWeakMap:()=>st.DP,SynthesizeHdrMaterialContent:()=>uo.$,System:()=>Bn.iQ,SystemState:()=>Bn.lK,TagGltf2NodeIndex:()=>Lo.q_f,Texture:()=>Ke.g,TextureDataFloat:()=>Ze.C,TextureFetchShader:()=>Po,TextureFormat:()=>x.nC,TextureParameter:()=>x.gu,Time:()=>st.gX,ToneMappingType:()=>x.JK,Transform3D:()=>kt.kJ,TransformComponent:()=>c.WZ,TranslationGizmo:()=>Ce.U,UniformDataShader:()=>mn,UniformDataShaderNode:()=>pn,VERSION:()=>L.x,VRMColliderGroup:()=>Gt,VRMSpring:()=>Ot,VRMSpringBone:()=>Wt,VRMSpringBonePhysicsStrategy:()=>Vt,VarianceShadowMapDecodeClassicMaterialContent:()=>fo.w,VaryingVariableShader:()=>No,Vector2:()=>kt.I9,Vector2_:()=>kt.VS,Vector2d:()=>kt.a2,Vector3:()=>kt.Pq,Vector3_:()=>kt.wr,Vector3d:()=>kt.pG,Vector4:()=>kt.IU,Vector4_:()=>kt.xn,Vector4d:()=>kt.Em,VectorN:()=>kt.uS,VertexAttribute:()=>x.rz,VertexAttributeClass:()=>x.zc,VideoTexture:()=>et,ViewMatrixShaderNode:()=>Tn,Visibility:()=>x.bv,Vrm0xImporter:()=>Qt,VrmComponent:()=>c.r0,VrmImporter:()=>Kt,VrmaImporter:()=>$t,WalkThroughCameraController:()=>l.k,WeakNone:()=>st.vK,WeakOption:()=>st.Ko,WeakSome:()=>st.$l,WebGLContextWrapper:()=>Ao.u,WebGLExtension:()=>Eo.z,WebGLResourceRepository:()=>So.u,WebGLStrategyDataTexture:()=>wo._,WebGLStrategyUniform:()=>Co.n,WebGpuDeviceWrapper:()=>Do.y,WebGpuResourceRepository:()=>Fo.x,WebGpuStrategyBasic:()=>Bo._,WebXRSystem:()=>Oo.q,WellKnownComponentTIDs:()=>c.Nq,WireframeMaterialNode:()=>Wn,WorldMatrixShaderNode:()=>Sn,_from:()=>st.yH,_fromString:()=>st.Pq,_fromStringCaseSensitively:()=>st.Ol,_getPropertyIndex2:()=>x.zb,add2:()=>kt.QA,add2_offset:()=>kt.oz,add3:()=>kt.XT,add3_offset:()=>kt.VQ,add4:()=>kt.cL,add4_offset:()=>kt.e7,addLineNumberToCode:()=>st.Bv,applyMixins:()=>h.XJ,array3_lerp_offsetAsComposition:()=>kt.z$,arrayN_lerp_offsetAsComposition:()=>kt.UL,assertDoesNotHave:()=>st.BA,assertExist:()=>st.qL,assertHas:()=>st.Xt,assertIsErr:()=>st.ou,assertIsOk:()=>st.j3,calcAlignedByteLength:()=>x.oM,combineImages:()=>st.gH,convertHTMLImageElementToCanvas:()=>st.PS,createCameraControllerEntity:()=>c.TB,createCameraEntity:()=>c.vN,createEffekseer:()=>M,createEntity:()=>h.S$,createGroupEntity:()=>c.PU,createLightEntity:()=>c.Gi,createLightWithCameraEntity:()=>Pe,createMeshEntity:()=>c.jw,createMotionController:()=>Go.BT,createPhysicsEntity:()=>c.F6,createSkeletalEntity:()=>c.Hf,createTransformEntity:()=>c.Yd,deepCopyUsingJsonStringify:()=>st.bX,defaultAnimationTrackName:()=>c.S6,defaultValue:()=>st.Jh,detectFormatByArrayBuffers:()=>Pt,detectFormatByUri:()=>Nt,downloadArrayBuffer:()=>st.Mf,downloadTypedArray:()=>st.Sm,dummyAnisotropyTexture:()=>eo.OZ,dummyBlackCubeTexture:()=>eo.cC,dummyBlackTexture:()=>eo.rT,dummyBlueTexture:()=>eo.Uk,dummySRGBGrayTexture:()=>eo.JD,dummyWhiteTexture:()=>eo.vK,enhanceArray:()=>b,flattenHierarchy:()=>c.gD,fromTensorToCompositionType:()=>Lo.teG,get1:()=>kt.et,get1_offset:()=>kt.uq,get1_offsetAsComposition:()=>kt.k0,get2:()=>kt.Lu,get2_offset:()=>kt.Nd,get2_offsetAsComposition:()=>kt.BN,get3:()=>kt.S8,get3_offset:()=>kt.wQ,get3_offsetAsComposition:()=>kt.sb,get4:()=>kt.ZK,get4_offset:()=>kt.J6,get4_offsetAsComposition:()=>kt.R8,getEvent:()=>Bn.Zc,getMotionController:()=>Go.Bi,getN_offset:()=>kt.VH,getN_offsetAsComposition:()=>kt.xZ,getWebXRSystem:()=>Uo,greaterThan:()=>st.MM,ifDefinedThen:()=>st.CW,ifDefinedThenWithReturn:()=>st.sM,ifExistsThen:()=>st.t4,ifExistsThenWithReturn:()=>st.VT,ifNotExistsThen:()=>st.K_,ifNotExistsThenWithReturn:()=>st.uD,ifUndefinedThen:()=>st.TF,ifUndefinedThenWithReturn:()=>st.XW,initDefaultTextures:()=>eo.iE,isBlend:()=>ve.SQ,isBlendWithZWrite:()=>ve.pc,isBlendWithoutZWrite:()=>ve.VG,isOpaque:()=>ve.qp,isSameGlTF2TextureSampler:()=>Lo.Vi7,isSkipDrawing:()=>Io.M,isTranslucent:()=>ve.eG,lessThan:()=>st.Xe,mulArray3WithScalar_offset:()=>kt.P4,mulArray4WithScalar_offset:()=>kt.gp,mulArrayNWithScalar_offset:()=>kt.G9,mulThatAndThisToOutAsMat44_offsetAsComposition:()=>kt.cS,normalizeArray4:()=>kt.Nj,nullishToEmptyArray:()=>st.H2,nullishToEmptyMap:()=>st.m6,objectCachify:()=>st.Js,primitiveCachify1:()=>st.yC,qlerp_offsetAsComposition:()=>kt.z9,scalar_lerp_offsetAsComposition:()=>kt.db,setupShaderProgram:()=>To.H,sheenLutTexture:()=>eo.EY,updateGamePad:()=>Go.jw,updateMotionControllerModel:()=>Go.LQ,updateVBOAndVAO:()=>Io.I,valueWithCompensation:()=>st.Cw,valueWithDefault:()=>st.pJ});var r=o(4930),s=o(2020),l=o(4578),c=o(3050),_=o(8621),u=o(6737),f=o(5338),d=o(8223),h=o(7503),m=o(3107),p=o(7496),v=o(8819),x=o(2766);const g=Symbol();class y{constructor(e){this.__raw=e}}Object.defineProperty(y.prototype,"getComponentFromEntities",{enumerable:!1,writable:!1,configurable:!0,value:function(e){const t=this.__raw,n=[];return t.forEach((t=>{const o=t.getComponentByComponentTID(e.componentTID);null!=o&&n.push(o)})),n}});const b=()=>{Object.defineProperty(Array.prototype,"Rn",{enumerable:!1,configurable:!1,get(){return new y(this)}})};var I=o(2229),A=o(3923),E=o(4114),S=o(5065),T=o(5886),w=o(7751),C=o(4317),R=o(4289),P=o(3497);function N(e,t,n){const o=e.extras.bufferViewByteLengthAccumulatedArray[t],a={buffer:t,byteLength:n.byteLength,byteOffset:o,extras:{uint8Array:n}},i=S.$.addPaddingBytes(a.byteLength,4)+o;return e.bufferViews.push(a),e.extras.bufferViewByteLengthAccumulatedArray[t]=i,a}function M(e,t){let n=!1;const o=e.extras.bufferViewByteLengthAccumulatedArray.length-1,a=[];for(let i=0;i<t.length;i++){const r=t[i].getComponentByComponentTID(R.N.EffekseerComponentTID);if(I.Is.exist(r)){n=!0;const t={node:i,name:r.uniqueName};if(I.Is.exist(r.arrayBuffer)){const n=N(e,o,new Uint8Array(r.arrayBuffer));t.bufferView=e.bufferViews.indexOf(n)}else I.Is.exist(r.uri)?t.uri=r.uri:P.V.error("no real effect data.");D(r.entity,t),a.push(t)}}n&&(e.extensions.RHODONITE_effekseer={version:"1.0",effects:a},e.extensionsUsed.push("RHODONITE_effekseer"))}function D(e,t){const n=e.tryToGetAnimation();if(I.Is.exist(n)){const e=n.getAnimationTrackNames(),o=[];for(const t of e)if(n.hasAnimation(t,"effekseer")){const e=n.getAnimationChannelsOfTrack(t);if(I.Is.exist(e)){const n=e.values();for(const e of n)if("effekseer"===e.target.pathName){const n=e.sampler.input,a=[];for(let t=0;t<n.length;t++){const o={input:n[t],event:e.sampler.output[t]>.5?"play":"pause"};a.push(o)}const i={name:t,values:a};o.push(i)}}}t.timelines=o}}var F=o(3414),B=o(6941),L=o(5672);const V="glTF",z="glTF-Binary",G="glTF-Draco",O="glTF-Embedded",U="No-Download";class k{constructor(){}static async export(e,t={entities:void 0,type:z}){const{collectedEntities:n,topLevelEntities:o}=this.__collectEntities(t),{json:a,fileName:i}=this.__createJsonBase(e);this.__createBufferViewsAndAccessors(a,n),this.__createNodes(a,n,o),await this.__createMaterials(a,n,t),M(a,n);const r=this.__createBinary(a);this.__deleteEmptyArrays(a);const s=function(e,t){delete e.buffers[0].uri;let n=JSON.stringify(e,null,2),o=S.$.stringToBuffer(n);const a=S.$.calcPaddingBytes(o.byteLength,4);if(a>0){for(let e=0;e<a;e++)n+=" ";o=S.$.stringToBuffer(n)}const i=o.byteLength,r=20+i,s=r+4+4+t.byteLength,l=new ArrayBuffer(s),c=new DataView(l);return c.setUint32(0,1179937895,!0),c.setUint32(4,2,!0),c.setUint32(8,s,!0),c.setUint32(12,o.byteLength,!0),c.setUint32(16,1313821514,!0),S.$.copyArrayBufferAs4Bytes({src:o,dist:l,srcByteOffset:0,copyByteLength:o.byteLength,distByteOffset:20}),S.$.copyArrayBufferAs4Bytes({src:t,dist:l,srcByteOffset:0,copyByteLength:t.byteLength,distByteOffset:20+i+8}),c.setUint32(r,t.byteLength,!0),c.setUint32(r+4,5130562,!0),l}(a,r);return t.type===z?this.__downloadGlb(a,i,s):t.type===V&&this.__downloadGltf(a,i,r),s}static __deleteEmptyArrays(e){0===e.accessors.length&&delete e.accessors,0===e.bufferViews.length&&delete e.bufferViews,0===e.materials.length&&delete e.materials,0===e.meshes.length&&delete e.meshes,0===e.skins.length&&delete e.skins,0===e.textures.length&&delete e.textures,0===e.images.length&&delete e.images,0===e.animations.length&&delete e.animations,I.Is.exist(e.extensionsUsed)&&0===e.extensionsUsed.length&&delete e.extensionsUsed,0===e.cameras.length&&delete e.cameras,delete e.extras}static __collectEntities(e){const t=t=>{if(I.Is.exist(e)&&I.Is.exist(e.excludeTags)){for(const n of e.excludeTags)if(t.matchTag(n.tag,n.value))return!1;if(t.matchTag("Being","gizmo"))return!0}return!0},n=t=>{if(I.Is.exist(e)&&I.Is.exist(e.excludeTags))for(const n of e.excludeTags)if(t.matchTag(n.tag,n.value))return[];return[t]},o=(e,t)=>{const a=e.getSceneGraph();if(a.children.length>0){const i=t?[]:n(e);for(let e=0;e<a.children.length;e++){const t=a.children[e];Array.prototype.push.apply(i,o(t.entity,!1))}return i}return t?[]:n(e)};if(I.Is.exist(e)&&I.Is.exist(e.entities)&&e.entities.length>0){const n=e.entities.flatMap((e=>o(e,!0)));let a=[];e.entities.forEach((e=>{-1===n.indexOf(e)&&t(e)&&a.push(e)}));let i=e.entities.concat();return Array.prototype.push.apply(i,n),i=[...new Set(i)],0===a.length&&(a=i),{collectedEntities:i,topLevelEntities:a}}let a=h.YY._getEntities();a=a.filter((e=>t(e)));let i=C.K.getTopLevelComponents().flatMap((e=>e.entity));return i=i.filter((e=>t(e))),a=a.flatMap((e=>o(e,!0))),Array.prototype.push.apply(a,i),a=[...new Set(a)],{collectedEntities:a,topLevelEntities:i}}static __createJsonBase(e){const t=e||"Rhodonite_"+(new Date).getTime();return{json:{asset:{version:"2.0",generator:`Rhodonite (${L.x.version})`},buffers:[{uri:t+".bin",byteLength:0}],bufferViews:[],accessors:[],animations:[],meshes:[],skins:[],materials:[{pbrMetallicRoughness:{baseColorFactor:[1,1,1,1]}}],textures:[],images:[],extensionsUsed:[],extensions:{},extras:{rnSkins:[],bufferViewByteLengthAccumulatedArray:[]},cameras:[],samplers:[]},fileName:t}}static __createBufferViewsAndAccessors(e,t){const n=[],o=[],a=[];!function(e,t,n,o,a){for(let i=0;i<t.length;i++){const r=t[i],s=r.tryToGetMesh();if(I.Is.exist(s)&&s.mesh){const t={primitives:[]},i=s.mesh.getPrimitiveNumber();for(let l=0;l<i;l++){const i=s.mesh.getPrimitiveAt(l),c={attributes:{},mode:i.primitiveMode.index},_=i.indicesAccessor;if(I.Is.exist(_)){const t=ae(e,n,o,_.bufferView,T.s_L),i=ie(e,e.bufferViews.indexOf(t),a,_),r=e.accessors.indexOf(i);c.indices=r}const u=i.attributeAccessors;for(let t=0;t<u.length;t++){const r=i.attributeSemantics[t].split(".")[0];if("BARY_CENTRIC_COORD"===r)continue;const s=u[t],l=Q(e,n,o,s.bufferView,s),_=ie(e,e.bufferViews.indexOf(l),a,s),f=e.accessors.indexOf(_);c.attributes[r]=f}W(r,i,c,e,n,o,a),t.primitives[l]=c}e.meshes.push(t)}}}(e,t,n,o,a),function(e,t){let n=0;const o=e.extras.bufferViewByteLengthAccumulatedArray.length;for(let a=0;a<t.length;a++){const i=t[a].tryToGetAnimation();if(I.Is.exist(i)){const t=i.getAnimationTrackNames();for(const r of t){const t={channels:[],samplers:[]};e.animations.push(t);let s=0;const l=i.getAnimationChannelsOfTrack(r);if(I.Is.exist(l)){const i=l.values();for(const r of i){if("effekseer"===r.target.pathName)continue;const{inputAccessorIdx:i,inputBufferViewByteLengthAccumulated:l}=Z(e,r,o,n);n+=l;const{outputAccessorIdx:c,outputBufferViewByteLengthAccumulated:_}=J(e,r,o,n);n+=_,s=Y(r,s,t,a),K(i,c,r,t)}}}}}e.extras.bufferViewByteLengthAccumulatedArray.push(n)}(e,t),function(e,t,n,o,a){for(let i=0;i<t.length;i++){const r=t[i].tryToGetSkeletal();if(I.Is.not.exist(r))continue;e.extras.rnSkins.push(r.entity);const s=r.getJoints(),l=[];for(const e of s)t.forEach(((t,n)=>{e.entity===t&&l.push(n)}));const c=r.getInverseBindMatricesAccessor();I.Is.exist(c)&&(ae(e,n,o,c.bufferView),ie(e,e.bufferViews.length-1,a,c));const _=r.topOfJointsHierarchy,u=r._bindShapeMatrix;let f=-1;if(I.Is.exist(_)){const e=_.entity;f=t.indexOf(e)}else f=l[0];const d={joints:l,inverseBindMatrices:e.accessors.length-1,skeleton:f>=0?f:void 0,bindShapeMatrix:null==u?void 0:u.flattenAsArray()};e.skins.push(d)}}(e,t,n,o,a)}static __createNodes(e,t,n){e.nodes=[],e.scenes=[{nodes:[]}];const o=e.scenes[0];for(let e=0;e<t.length;e++)t[e].gltfNodeIndex=e;let a=0;for(let n=0;n<t.length;n++){const o=t[n];e.nodes[n]={};const i=e.nodes[n];i.name=o.uniqueName;const r=o.getSceneGraph(),s=r.children;if(s.length>0){i.children=[];for(let e=0;e<s.length;e++){const t=s[e];I.Is.exist(t.entity.gltfNodeIndex)&&i.children.push(t.entity.gltfNodeIndex)}}r.isBillboard&&(i.extensions={RHODONITE_billboard:{isBillboard:!0}},-1===e.extensionsUsed.indexOf("RHODONITE_billboard")&&e.extensionsUsed.push("RHODONITE_billboard"));const l=o.getTransform();i.rotation=[l.localRotationInner.x,l.localRotationInner.y,l.localRotationInner.z,l.localRotationInner.w],i.scale=[l.localScaleInner.x,l.localScaleInner.y,l.localScaleInner.z],i.translation=[l.localPositionInner.x,l.localPositionInner.y,l.localPositionInner.z];const c=o.tryToGetMesh();I.Is.exist(c)&&I.Is.exist(c.mesh)&&(i.mesh=a++);const _=o.tryToGetBlendShape();if(I.Is.exist(_)){const e=_.weights;e.length>0&&(i.weights=e)}const u=o.tryToGetSkeletal();if(I.Is.exist(u)){const t=e.extras.rnSkins.indexOf(u.entity);t>=0&&(i.skin=t)}const f=o.tryToGetCamera();if(I.Is.exist(f)){let t;if(f.type===x.Aq.Perspective){const e=f.getTagValue("OriginalAspect"),n=f.getTagValue("OriginalFovY");t={name:f.entity.uniqueName,type:"perspective",perspective:{aspectRatio:I.Is.exist(e)?e:f.aspect,yfov:I.Is.exist(n)?B.z.degreeToRadian(n):B.z.degreeToRadian(f.fovy),znear:f.zNear,zfar:f.zFar}}}else if(f.type===x.Aq.Orthographic){const e=f.getTagValue("OriginalXMag"),n=f.getTagValue("OriginalYMag");t={name:f.entity.uniqueName,type:"orthographic",orthographic:{xmag:I.Is.exist(e)?e:f.xMag,ymag:I.Is.exist(n)?n:f.yMag,znear:f.zNear,zfar:f.zFar}}}e.cameras.push(t),i.camera=e.cameras.length-1}}n.forEach(((e,n)=>{const a=t.indexOf(e);a>=0&&o.nodes.push(a)}))}static async __createMaterials(e,t,n){let o=0;const a=[];e.extras.bufferViewByteLengthAccumulatedArray.push(0);const i=e.extras.bufferViewByteLengthAccumulatedArray.length-1;for(let r=0;r<t.length;r++){const s=t[r].tryToGetMesh();if(s&&s.mesh){const t=e.meshes[o++],r=s.mesh.getPrimitiveNumber();for(let o=0;o<r;o++){const r=s.mesh.getPrimitiveAt(o),l=t.primitives[o],c=r.material,_={pbrMetallicRoughness:{metallicFactor:1,roughnessFactor:1}};let u;if(I.Is.exist(c)){I.Is.false(c.isLighting)&&(I.Is.not.exist(_.extensions)&&(_.extensions={}),_.extensions.KHR_materials_unlit={},e.extensionsUsed.indexOf("KHR_materials_unlit")<0&&e.extensionsUsed.push("KHR_materials_unlit")),u=c.getParameter("baseColorFactor"),I.Is.not.exist(u)?(u=c.getParameter("diffuseColorFactor"),I.Is.not.exist(u)&&(u=F.IU.fromCopy4(1,1,1,1))):(_.pbrMetallicRoughness.metallicFactor=c.getParameter("metallicRoughnessFactor").x,_.pbrMetallicRoughness.roughnessFactor=c.getParameter("metallicRoughnessFactor").y),_.pbrMetallicRoughness.baseColorFactor=Array.prototype.slice.call(u._v),_.alphaMode=c.alphaMode.toGltfString();const t=[],o=(o,r)=>{if(o&&o.width>1&&o.height>1){let s=e.images.length,l=!1;for(let t=0;t<e.images.length;t++){const n=e.images[t];I.Is.exist(n.rnTextureUID)&&n.rnTextureUID===o.textureUID&&(s=t,l=!0)}let c=-1;{const t={magFilter:null!=r?r.magFilter.index:x.gu.Linear.index,minFilter:null!=r?r.minFilter.index:x.gu.Linear.index,wrapS:null!=r?r.wrapS.index:x.gu.TextureWrapS.index,wrapT:null!=r?r.wrapT.index:x.gu.TextureWrapT.index};c=e.samplers.findIndex((e=>(0,A.V)(t,e))),-1===c&&(e.samplers.push(t),c=e.samplers.length-1)}if(!l){const r={uri:o.name};r.rnTextureUID=o.textureUID,-1!==t.indexOf(o.name)&&(r.uri+="_"+o.textureUID),t.push(r.uri),I.Is.not.exist(r.uri.match(/\.(png)/))&&(r.uri+=".png");const s=o.htmlCanvasElement;if(s){const t=new Promise(((t,o)=>{s.toBlob((a=>{if(!I.Is.exist(a))throw Error("canvas to blob error!");te(e,i,a,n,r,t,o)}))}));a.push(t)}e.images.push(r)}const _={sampler:c,source:s};return-1===e.textures.indexOf(_)&&e.textures.push(_),e.textures.indexOf(_)}};let r,s=c.getParameter("baseColorTexture");if(null!=s)r=o(s[1],s[2]),null!=r&&(_.pbrMetallicRoughness.baseColorTexture={index:r});else if(s=c.getParameter("diffuseColorTexture"),null!=s){const e=o(s[1],s[2]);null!=e&&(_.pbrMetallicRoughness.diffuseColorTexture={index:e})}s=c.getParameter("metallicRoughnessTexture"),s&&(r=o(s[1],s[2]),null!=r&&(_.pbrMetallicRoughness.metallicRoughnessTexture={index:r})),s=c.getParameter("normalTexture"),s&&(r=o(s[1],s[2]),null!=r&&(_.normalTexture={index:r})),s=c.getParameter("occlusionTexture"),s&&(r=o(s[1],s[2]),null!=r&&(_.occlusionTexture={index:r})),s=c.getParameter("emissiveTexture"),s&&(r=o(s[1],s[2]),null!=r&&(_.emissiveTexture={index:r}))}-1===e.materials.indexOf(_)&&e.materials.push(_),l.material=e.materials.indexOf(_)}}}return Promise.all(a)}static __createBinary(e){if(I.Is.undefined(e.accessors)||I.Is.undefined(e.bufferViews))return new ArrayBuffer(0);const t=e.extras.bufferViewByteLengthAccumulatedArray.reduce(((e,t)=>e+t));t>0&&(e.buffers[0].byteLength=t+S.$.calcPaddingBytes(t,4));const n=new ArrayBuffer(e.buffers[0].byteLength);let o=0;for(let t=0;t<e.bufferViews.length;t++){const a=e.bufferViews[t],i=a.extras.uint8Array;delete a.extras;const r=o;S.$.copyArrayBufferWithPadding({src:i.buffer,dist:n,srcByteOffset:i.byteOffset,copyByteLength:i.byteLength,distByteOffset:r}),o+=S.$.addPaddingBytes(i.byteLength,4),a.byteOffset=r,a.buffer=0}return n}static __downloadGlb(e,t,n){{const e=document.createElement("a");e.download=t+".glb";const o=new Blob([n],{type:"octet/stream"}),a=URL.createObjectURL(o);e.href=a;const i=new MouseEvent("click");e.dispatchEvent(i)}}exportGlbAsArrayBuffer(){}static __downloadGltf(e,t,n){{const n=document.createElement("a");n.download=t+".gltf";const o=JSON.stringify(e,null,2);n.href="data:application/octet-stream,"+encodeURIComponent(o);const a=new MouseEvent("click");n.dispatchEvent(a)}{const e=document.createElement("a");e.download=t+".bin";const o=new Blob([n],{type:"octet/stream"}),a=URL.createObjectURL(o);e.href=a;const i=new MouseEvent("click");e.dispatchEvent(i)}}}function W(e,t,n,o,a,i,r){const s=e.tryToGetBlendShape();if(I.Is.exist(s)){const e=t.getBlendShapeTargets();I.Is.not.exist(n.targets)&&(n.targets=[]);for(const t of e){const e={};for(const[n,s]of t.entries()){const t=ae(o,a,i,s.bufferView,T.Dgu),l=ie(o,o.bufferViews.indexOf(t),r,s),c=o.accessors.indexOf(l);e[n.split(".")[0]]=c}n.targets.push(e)}}}function Q(e,t,n,o,a){const i=q(n,o);if(-1===i){const i=X(t,o.buffer),r={buffer:i,byteLength:o.byteLength,byteOffset:o.byteOffsetInBuffer,extras:{uint8Array:o.getUint8Array()}};return r.target=T.Dgu,e.extras.bufferViewByteLengthAccumulatedArray[i]=H(e.extras.bufferViewByteLengthAccumulatedArray,i,r),I.Is.exist(r.target)&&(r.byteStride=a.elementSizeInBytes),n.push(o),e.bufferViews.push(r),r}return e.bufferViews[i]}function q(e,t){return e.findIndex((e=>e.isSame(t)))}function X(e,t){0===e.length&&e.push(t);const n=e.findIndex((e=>e.isSame(t))),o=-1===n?e.length:n;return-1===n&&e.push(t),o}function H(e,t,n){return I.Is.exist(e[t])?e[t]+S.$.addPaddingBytes(n.byteLength,4):S.$.addPaddingBytes(n.byteLength,4)}function j(e){switch(e){case"translate":return"translation";case"quaternion":return"rotation";case"scale":return"scale";case"weights":return"weights";default:throw new Error("Invalid Path Name")}}function Y(e,t,n,o){const a={sampler:t++,target:{path:j(e.target.pathName),node:o}};return n.channels.push(a),t}function K(e,t,n,o){const a={input:e,output:t,interpolation:n.sampler.interpolationMethod.GltfString};o.samplers.push(a)}function Z(e,t,n,o){const a=E.I.fromTypedArray(ArrayBuffer.isView(t.sampler.input)?t.sampler.input:new Float32Array(t.sampler.input)),i=t.sampler.input.length,r=ne({bufferIdx:n,bufferViewByteOffset:o,accessorByteOffset:0,accessorCount:i,bufferViewByteStride:E.I.Float.getSizeInBytes(),componentType:a,compositionType:w.h.Scalar,uint8Array:new Uint8Array(ArrayBuffer.isView(t.sampler.input)?t.sampler.input.buffer:new Float32Array(t.sampler.input).buffer)});e.bufferViews.push(r);const s=oe({bufferViewIdx:e.bufferViews.indexOf(r),accessorByteOffset:0,componentType:a,count:i,compositionType:w.h.Scalar,min:[t.sampler.input[0]],max:[t.sampler.input[t.sampler.input.length-1]]});return e.accessors.push(s),o=$(0,r),{inputAccessorIdx:e.accessors.indexOf(s),inputBufferViewByteLengthAccumulated:o}}function J(e,t,n,o){const a=E.I.fromTypedArray(ArrayBuffer.isView(t.sampler.output)?t.sampler.output:new Float32Array(t.sampler.output)),i=t.target.pathName;let r=w.h.toGltf2AnimationAccessorCompositionType(t.sampler.outputComponentN),s=t.sampler.output.length/t.sampler.outputComponentN;"weights"===i&&(r=w.h.Scalar,s=t.sampler.output.length);const l=ne({bufferIdx:n,bufferViewByteOffset:o,accessorByteOffset:0,accessorCount:s,bufferViewByteStride:a.getSizeInBytes()*t.sampler.outputComponentN,componentType:a,compositionType:r,uint8Array:new Uint8Array(ArrayBuffer.isView(t.sampler.output)?t.sampler.output.buffer:new Float32Array(t.sampler.output).buffer)});e.bufferViews.push(l);const c=oe({bufferViewIdx:e.bufferViews.indexOf(l),accessorByteOffset:0,componentType:a,count:s,compositionType:r});return e.accessors.push(c),o=$(0,l),{outputAccessorIdx:e.accessors.indexOf(c),outputBufferViewByteLengthAccumulated:o}}function $(e,t){return t.byteLength+S.$.calcPaddingBytes(t.byteLength,4)}function ee(e){return e%4==0?e:e+(4-e%4)}async function te(e,t,n,o,a,i,r){if(o.type===V)setTimeout((()=>{const e=document.createElement("a"),t=new MouseEvent("click");e.href=URL.createObjectURL(n),e.download=a.uri,e.dispatchEvent(t),URL.revokeObjectURL(e.href)}),5e3*Math.random()),i();else{const o=new FileReader;o.addEventListener("load",(()=>{const n=o.result,r=N(e,t,new Uint8ClampedArray(n));a.bufferView=e.bufferViews.indexOf(r),a.mimeType="image/png",delete a.uri,i()})),o.addEventListener("error",(()=>{r(o.error)})),o.readAsArrayBuffer(n)}}function ne({bufferIdx:e,bufferViewByteOffset:t,accessorByteOffset:n,accessorCount:o,bufferViewByteStride:a,componentType:i,compositionType:r,uint8Array:s}){const l=ee(n),{fixedBufferViewByteLength:c,fixedBufferViewByteOffset:_}=function({accessorByteOffset:e,accessorCount:t,bufferViewByteStride:n,bufferViewByteOffset:o,sizeOfComponent:a,numberOfComponents:i}){const r=0===n?a*i:n;if(n%a!=0)throw Error("glTF2: When byteStride is defined, it MUST be a multiple of the size of the accessor’s component type.");const s=(_=r)%4==0?_:_+(4-_%4),l=ee(e),c=a*i;var _;return{fixedBufferViewByteLength:l+s*(t-1)+a*i,fixedBufferViewByteOffset:ee(o+(c-(l+o)%c))}}({accessorByteOffset:l,accessorCount:o,bufferViewByteStride:a,bufferViewByteOffset:t,sizeOfComponent:i.getSizeInBytes(),numberOfComponents:r.getNumberOfComponents()});return{buffer:e,byteLength:c,byteOffset:_,extras:{uint8Array:s}}}function oe({bufferViewIdx:e,accessorByteOffset:t,componentType:n,count:o,compositionType:a,min:i,max:r}){return{bufferView:e,byteOffset:ee(t),componentType:E.I.toGltf2AccessorComponentType(n),count:o,type:a.str,min:i,max:r,extras:{}}}function ae(e,t,n,o,a){const i=q(n,o);if(-1===i){const i=X(t,o.buffer),r={buffer:i,byteLength:o.byteLength,byteOffset:o.byteOffsetInBuffer,extras:{uint8Array:o.getUint8Array()}};return I.Is.exist(a)&&(r.target=a),e.extras.bufferViewByteLengthAccumulatedArray[i]=H(e.extras.bufferViewByteLengthAccumulatedArray,i,r),n.push(o),e.bufferViews.push(r),r}return e.bufferViews[i]}function ie(e,t,n,o){const a=function(e,t){return e.findIndex((e=>e.isSame(t)))}(n,o);if(-1===a){const a={bufferView:t,byteOffset:o.byteOffsetInBufferView,componentType:E.I.toGltf2AccessorComponentType(o.componentType),count:o.elementCount,type:w.h.toGltf2AccessorCompositionTypeString(o.compositionType.getNumberOfComponents()),extras:{uint8Array:void 0}};return o.compositionType.getNumberOfComponents()<=4&&(a.max=o.max,a.min=o.min),n.push(o),e.accessors.push(a),a}return e.accessors[a]}var re=o(3639),se=o(6947),le=o(4838);class ce extends le.d{generate(e){var t;const n={length:null!==(t=e.length)&&void 0!==t?t:1,material:e.material},o=[new Float32Array([0,0,0,n.length,0,0,0,0,0,0,n.length,0,0,0,0,0,0,n.length]),new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1])],a=[re.r.Position.XYZ,re.r.Color0.XYZ];this.copyVertexData({attributes:o,attributeSemantics:a,primitiveMode:se.R.Lines,material:n.material})}}var _e=o(6731);class ue extends le.d{generate(e){var t,n,o,a,i;const r={length:null!==(t=e.length)&&void 0!==t?t:1,division:null!==(n=e.division)&&void 0!==n?n:10,isXY:null===(o=e.isXY)||void 0===o||o,isXZ:null===(a=e.isXZ)||void 0===a||a,isYZ:null===(i=e.isYZ)||void 0===i||i,material:e.material},s=[];for(let e=0;e<2*r.division+3;e++){const t=-r.length,n=r.length/(r.division+1);r.isXZ&&(s.push(-r.length,0,t+n*e),s.push(r.length,0,t+n*e),s.push(t+n*e,0,-r.length),s.push(t+n*e,0,r.length)),r.isXY&&(s.push(-r.length,t+n*e,0),s.push(r.length,t+n*e,0),s.push(t+n*e,-r.length,0),s.push(t+n*e,r.length,0)),r.isYZ&&(s.push(0,-r.length,t+n*e),s.push(0,r.length,t+n*e),s.push(0,t+n*e,-r.length),s.push(0,t+n*e,r.length))}const l=[new Float32Array(s)],c=[re.r.Position.XYZ];this.copyVertexData({attributes:l,attributeSemantics:c,primitiveMode:se.R.Lines,material:null==r?void 0:r.material})}}var fe=o(975);class de extends le.d{constructor(){super(...arguments),this.__worldPositionOfThisJoint=fe.Pq.fromCopyArray3([0,0,1]),this.__worldPositionOfParentJoint=fe.Pq.fromCopyArray3([0,0,0]),this.__width=1}generate(e){const t=fe.Pq.lengthBtw(this.__worldPositionOfThisJoint,this.__worldPositionOfParentJoint),n=this.__width,o=t-t/7.5,a=fe.Pq.subtract(this.__worldPositionOfParentJoint,this.__worldPositionOfThisJoint);let i=fe.Pq.fromCopyArray3([0,1,0]);a.isEqual(fe.Pq.zero())||(i=fe.Pq.normalize(fe.Pq.subtract(this.__worldPositionOfParentJoint,this.__worldPositionOfThisJoint)));const r=fe.Pq.add(this.__worldPositionOfThisJoint,fe.Pq.multiply(i,o));let s=fe.Pq.fromCopyArray3([0,1,0]),l=fe.Pq.fromCopyArray3([0,-1,0]);Math.abs(fe.Pq.dot(i,s))>.4&&(s=fe.Pq.fromCopyArray3([1,0,0]),l=fe.Pq.fromCopyArray3([-1,0,0])),Math.abs(fe.Pq.dot(i,s))>.4&&(s=fe.Pq.fromCopyArray3([0,0,1]),l=fe.Pq.fromCopyArray3([0,0,-1]));const c=fe.Pq.multiply(fe.Pq.normalize(fe.Pq.cross(i,s)),n),_=fe.Pq.multiply(fe.Pq.normalize(fe.Pq.cross(i,c)),n),u=fe.Pq.multiply(fe.Pq.normalize(fe.Pq.cross(i,l)),n),f=fe.Pq.multiply(fe.Pq.normalize(fe.Pq.cross(i,u)),n),d=fe.Pq.add(r,c),h=fe.Pq.add(r,_),m=fe.Pq.add(r,u),p=fe.Pq.add(r,f),v=[];v.push(this.__worldPositionOfThisJoint),v.push(d),v.push(this.__worldPositionOfThisJoint),v.push(h),v.push(this.__worldPositionOfThisJoint),v.push(m),v.push(this.__worldPositionOfThisJoint),v.push(p),v.push(d),v.push(h),v.push(h),v.push(m),v.push(m),v.push(p),v.push(p),v.push(d),v.push(this.__worldPositionOfParentJoint),v.push(d),v.push(this.__worldPositionOfParentJoint),v.push(h),v.push(this.__worldPositionOfParentJoint),v.push(m),v.push(this.__worldPositionOfParentJoint),v.push(p);const x=[];v.map((e=>{Array.prototype.push.apply(x,e.flattenAsArray())}));const g=[new Float32Array(x)],y=[re.r.Position.XYZ];this.copyVertexData({attributes:g,attributeSemantics:y,primitiveMode:se.R.Lines,material:null==e?void 0:e.material})}}class he extends le.d{generate(e){var t,n,o;const a={startPos:null!==(t=e.startPos)&&void 0!==t?t:fe.Pq.fromCopy3(0,0,0),endPos:null!==(n=e.endPos)&&void 0!==n?n:fe.Pq.fromCopy3(1,0,0),hasTerminalMark:null===(o=e.hasTerminalMark)||void 0===o||o,material:e.material},i=[];if(i.push(...a.startPos.flattenAsArray()),i.push(...a.endPos.flattenAsArray()),a.hasTerminalMark){const e=.1*a.startPos.lengthTo(a.endPos);i.push(a.startPos.x-e,a.startPos.y,a.startPos.z),i.push(a.startPos.x+e,a.startPos.y,a.startPos.z),i.push(a.startPos.x,a.startPos.y,a.startPos.z-e),i.push(a.startPos.x,a.startPos.y,a.startPos.z+e),i.push(a.endPos.x-e,a.endPos.y,a.endPos.z),i.push(a.endPos.x+e,a.endPos.y,a.endPos.z),i.push(a.endPos.x,a.endPos.y,a.endPos.z-e),i.push(a.endPos.x,a.endPos.y,a.endPos.z+e)}const r=[new Float32Array(i)],s=[re.r.Position.XYZ];this.copyVertexData({attributes:r,attributeSemantics:s,primitiveMode:se.R.Lines,material:a.material})}}var me=o(1326);class pe extends le.d{constructor(){super()}generate(e){var t,n,o;const a={radius:null!==(t=e.radius)&&void 0!==t?t:1,widthSegments:null!==(n=e.widthSegments)&&void 0!==n?n:10,heightSegments:null!==(o=e.heightSegments)&&void 0!==o?o:10,material:e.material},i=[],r=[],s=[];Math.abs(a.radius)<Number.EPSILON&&(P.V.warn("The argument radius is zero / nearly zero. Rn will take the radius as 0.001 for safety. Check your code."),a.radius=.001);for(let e=0;e<=a.heightSegments;e++){const t=e*Math.PI/a.heightSegments+1e-5,n=Math.sin(t),o=Math.cos(t);for(let t=0;t<=a.widthSegments;t++){const l=2*t*Math.PI/a.widthSegments,c=Math.sin(l),_=Math.cos(l),u=a.radius*_*n,f=a.radius*o,d=a.radius*c*n,h=fe.Pq.fromCopyArray([u,f,d]);i.push(u),i.push(f),i.push(d);const m=1-t/a.widthSegments,p=e/a.heightSegments;r.push(m),r.push(p);const v=fe.Pq.normalize(h);s.push(v.x),s.push(v.y),s.push(v.z)}}const l=[];for(let e=0;e<a.heightSegments;e++)for(let t=0;t<a.widthSegments;t++){const n=e*(a.widthSegments+1)+t,o=n+a.widthSegments+1;l.push(n+1),l.push(o),l.push(n),l.push(n+1),l.push(o+1),l.push(o)}const c=[re.r.Position.XYZ,re.r.Normal.XYZ,re.r.Texcoord0.XY],_=se.R.Triangles,u=[new Float32Array(i),new Float32Array(s),new Float32Array(r)];this.copyVertexData({attributes:u,attributeSemantics:c,primitiveMode:_,indices:new Uint16Array(l),material:a.material})}}var ve=o(6054);class xe{constructor(e,t){this.__components=[],this.__offsets=[],this.__semantic=e,this.__offsets=[],this.__components=[];for(const[n,o]of t){const t=n.split(",");for(let n=0;n<t.length;n++){const a=t[n];a===e.X&&(this.__offsets[0]=n,this.__components[0]=o),a===e.Y&&(this.__offsets[1]=n,this.__components[1]=o),a===e.Z&&(this.__offsets[2]=n,this.__components[2]=o),a===e.W&&(this.__offsets[3]=n,this.__components[3]=o)}}}get semantic(){return this.__semantic}getScalarAsArray(e,t){return[this.__components[0].getScalarAt(e,this.__offsets[0],t)]}getVec2AsArray(e,t){return[this.__components[0].getScalarAt(e,this.__offsets[0],t),this.__components[1].getScalarAt(e,this.__offsets[1],t)]}getVec3AsArray(e,t){return[this.__components[0].getScalarAt(e,this.__offsets[0],t),this.__components[1].getScalarAt(e,this.__offsets[1],t),this.__components[2].getScalarAt(e,this.__offsets[2],t)]}getVec4AsArray(e,t){return[this.__components[0].getScalarAt(e,this.__offsets[0],t),this.__components[1].getScalarAt(e,this.__offsets[1],t),this.__components[2].getScalarAt(e,this.__offsets[2],t),this.__components[3].getScalarAt(e,this.__offsets[3],t)]}}var ge=o(4343),ye=o(2212),be=o(960);class Ie{constructor(e,t){this.__semantic=e,this.__accessor=t}get semantic(){return this.__semantic}getScalarAsArray(e,t){return[this.__accessor.getScalar(e,t)]}getVec2AsArray(e,t){return this.__accessor.getVec2AsArray(e,t)}getVec3AsArray(e,t){return this.__accessor.getVec3AsArray(e,t)}getVec4AsArray(e,t){return this.__accessor.getVec4AsArray(e,t)}}var Ae=o(3498),Ee=o(2384),Se=o(1392),Te=o(626),we=o(9588),Ce=o(2335),Re=o(8806);function Pe(){const e=(0,Re.P)(),t=h.YY.tryToAddComponentToEntityByTID(c.Nq.LightComponentTID,e),n=h.YY.tryToAddComponentToEntityByTID(c.Nq.CameraComponentTID,t);return n.getCamera().isSyncToLight=!0,n}var Ne=o(9620),Me=o(1383),De=o(2889),Fe=o(9993);let Be;const Le=Object.freeze({createScreenDrawRenderPass:function(e){const t=new De.A;return t.toClearColorBuffer=!1,t.toClearDepthBuffer=!1,t.isDepthTest=!1,t.setBufferLessFullScreenRendering(e),t},createScreenDrawRenderPassWithBaseColorTexture:function(e,t,n){void 0===Be&&(Be=new Fe.L({magFilter:Me.P.Linear,minFilter:Me.P.Linear,wrapS:Me.P.ClampToEdge,wrapT:Me.P.ClampToEdge}),Be.create()),e.setTextureParameter("baseColorTexture",t,null!=n?n:Be);const o=new De.A;return o.toClearColorBuffer=!1,o.toClearDepthBuffer=!1,o.isDepthTest=!1,o.setBufferLessFullScreenRendering(e),o}});var Ve=o(4772),ze=o(3686),Ge=o(4513);class Oe extends v.E{constructor(){super(),this.__colorAttachments=[],this.cgApiResourceUid=Ve.f.InvalidCGAPIResourceUid,this.width=0,this.height=0,this.__colorAttachmentMap=new Map}get colorAttachmentsRenderBufferTargets(){return Array.from(this.__colorAttachmentMap.keys())}get colorAttachments(){return this.__colorAttachments}get depthAttachment(){return this.__depthAttachment}get stencilAttachment(){return this.__stencilAttachment}get depthStencilAttachment(){return this.__depthStencilAttachment}getColorAttachedRenderTargetTexture(e){return null!=this.__colorAttachments[e]&&this.__colorAttachments[e]instanceof Ge.$?this.__colorAttachments[e]:void 0}getDepthAttachedRenderTargetTexture(){return this.__depthAttachment instanceof Ge.$?this.__depthAttachment:void 0}create(e,t){this.width=e,this.height=t;const n=Ve.f.getCgApiResourceRepository();return this.cgApiResourceUid=n.createFrameBufferObject(),this.cgApiResourceUid}get framebufferUID(){return this.cgApiResourceUid}setColorAttachmentAt(e,t){return t.width===this.width&&t.height===this.height&&(this.__colorAttachments[e]=t,Ve.f.getCgApiResourceRepository().attachColorBufferToFrameBufferObject(this,e,t),this.__colorAttachmentMap.set(ze.q.from(e),t),!0)}setColorAttachmentCubeAt(e,t,n,o){return o.width===this.width&&o.height===this.height&&(this.__colorAttachments[e]=o,Ve.f.getCgApiResourceRepository().attachColorBufferCubeToFrameBufferObject(this,e,t,n,o),o.createCubeTextureViewAsRenderTarget(t,n),this.__colorAttachmentMap.set(ze.q.from(e),o),!0)}setDepthAttachment(e){return e.width===this.width&&e.height===this.height&&(this.__depthAttachment=e,Ve.f.getCgApiResourceRepository().attachDepthBufferToFrameBufferObject(this,e),!0)}setStencilAttachment(e){return e.width===this.width&&e.height===this.height&&(this.__stencilAttachment=e,Ve.f.getCgApiResourceRepository().attachStencilBufferToFrameBufferObject(this,e),!0)}setDepthStencilAttachment(e){return e.width===this.width&&e.height===this.height&&(this.__depthStencilAttachment=e,Ve.f.getCgApiResourceRepository().attachDepthStencilBufferToFrameBufferObject(this,e),!0)}resize(e,t){Ve.f.getCgApiResourceRepository().deleteFrameBufferObject(this.cgApiResourceUid),this.cgApiResourceUid=Ve.f.InvalidCGAPIResourceUid,this.width=0,this.height=0,this.create(e,t),this.depthAttachment&&(this.depthAttachment.resize(e,t),this.setDepthAttachment(this.depthAttachment)),this.depthStencilAttachment&&(this.depthStencilAttachment.resize(e,t),this.setDepthStencilAttachment(this.depthStencilAttachment)),this.stencilAttachment&&(this.stencilAttachment.resize(e,t),this.setStencilAttachment(this.stencilAttachment));for(let n=0;n<this.colorAttachments.length;n++)this.colorAttachments[n].resize(e,t),this.setColorAttachmentAt(n,this.colorAttachments[n])}destroy3DAPIResources(){Ve.f.getCgApiResourceRepository().deleteFrameBufferObject(this.cgApiResourceUid),this.cgApiResourceUid=Ve.f.InvalidCGAPIResourceUid,this.width=0,this.height=0,this.depthAttachment&&(this.depthAttachment.destroy3DAPIResources(),this.__depthAttachment=void 0),this.depthStencilAttachment&&(this.depthStencilAttachment.destroy3DAPIResources(),this.__depthStencilAttachment=void 0),this.stencilAttachment&&(this.stencilAttachment.destroy3DAPIResources(),this.__stencilAttachment=void 0);for(const e of this.colorAttachments)e.destroy3DAPIResources();this.__colorAttachmentMap=new Map}whichColorAttachment(e){return this.__colorAttachments.indexOf(e)}}var Ue=o(4958),ke=o(7670),We=o(3212),Qe=o(8393);class qe extends v.E{constructor(){super(),this.width=0,this.height=0,this.__internalFormat=Qe.n.Depth24,this._textureResourceUid=-1,this._textureViewResourceUid=-1,this._textureViewAsRenderTargetResourceUid=-1,this.__isMSAA=!1,this.__sampleCountMSAA=4}set _fbo(e){this.__fbo=e}get fbo(){return this.__fbo}get sampleCount(){return this.__sampleCountMSAA}create(e,t,n,{isMSAA:o=!1,sampleCountMSAA:a=this.__sampleCountMSAA}={}){this.width=e,this.height=t,this.__isMSAA=o,this.__sampleCountMSAA=a,this.__internalFormat=n;const i=Ve.f.getCgApiResourceRepository();this._textureResourceUid=i.createRenderBuffer(e,t,n,o,a),ke.l.currentProcessApproach===We.m.WebGPU&&(this._textureViewResourceUid=i.createTextureView2d(this._textureResourceUid),this._textureViewAsRenderTargetResourceUid=i.createTextureViewAsRenderTarget(this._textureResourceUid))}createCubeTextureViewAsRenderTarget(e,t){}resize(e,t){this.destroy3DAPIResources(),this.create(e,t,this.__internalFormat,{isMSAA:this.__isMSAA})}destroy3DAPIResources(){return this.width=0,this.height=0,Ve.f.getCgApiResourceRepository().deleteRenderBuffer(this._textureResourceUid),this._textureResourceUid=Ve.f.InvalidCGAPIResourceUid,!0}}var Xe,He=o(2664),je=o(8973),Ye=o(108),Ke=o(1018),Ze=o(1238),Je=function(e,t,n,o,a){if("m"===o)throw new TypeError("Private method is not writable");if("a"===o&&!a)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!a:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===o?a.call(e,n):a?a.value=n:t.set(e,n),n},$e=function(e,t,n,o){if("a"===n&&!o)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!o:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?o:"a"===n?o.call(e):o?o.value:t.get(e)};class et extends He.E{constructor(){super(),this.autoResize=!0,this.autoDetectTransparency=!1,Xe.set(this,void 0)}__getResizedCanvas(e,t){const n=document.createElement("canvas"),o=S.$.getNearestPowerOfTwo(e.width),a=S.$.getNearestPowerOfTwo(e.height),i=a/o;let r=0,s=0;o>a?(r=Math.min(o,t),s=r*i):(s=Math.min(a,t),r=s/i),n.width=r,n.height=s;const l=n.getContext("2d");if(l.drawImage(e,0,0,e.width,e.height,0,0,r,s),this.autoDetectTransparency){this.__imageData=l.getImageData(0,0,r,s);for(let e=0;e<s;e++)for(let t=0;t<r;t++)if(this.__imageData.data[4*(t+e*r)+3]<1)return this.__hasTransparentPixels=!0,n;this.__hasTransparentPixels=!1}return n}generateTextureFromVideo(e,{level:t=0,internalFormat:n=Qe.n.RGBA8,format:o=Ue.A.RGBA,type:a=E.I.UnsignedByte,generateMipmap:i=!1,mutedAutoPlay:r=!0}={}){this.__startedToLoad=!0,Je(this,Xe,e,"f"),r&&(e.autoplay=!0,e.muted=!0);const s=e;this.__width=s.videoWidth,this.__height=s.videoHeight;const l=Ve.f.getCgApiResourceRepository().createTextureFromImageBitmapData(s,{level:t,internalFormat:n,width:this.__width,height:this.__height,border:0,format:o,type:a,generateMipmap:i});this._textureResourceUid=l,this.__isTextureReady=!0,this.__uri=e.src}generateTextureFromUri(e,{level:t=0,internalFormat:n=Qe.n.RGBA8,format:o=Ue.A.RGBA,type:a=E.I.UnsignedByte,generateMipmap:i=!1,mutedAutoPlay:r=!0,playButtonDomElement:s}={}){return this.__uri=e,this.__startedToLoad=!0,new Promise(((l,c)=>{const _=()=>{this.__width=u.videoWidth,this.__height=u.videoHeight;const e=Ve.f.getCgApiResourceRepository().createTextureFromImageBitmapData(u,{level:t,internalFormat:n,width:this.__width,height:this.__height,border:0,format:o,type:a,generateMipmap:i});this._textureResourceUid=e,this.__isTextureReady=!0,l()};null==s||s.addEventListener("click",(()=>{_(),u.play()}),!0);const u=document.createElement("video");u.crossOrigin="anonymous",u.setAttribute("playsinline","playsinline"),r&&(u.autoplay=!0,u.muted=!0),u.preload="auto",Je(this,Xe,u,"f"),u.addEventListener("canplaythrough",(()=>{_(),u.play()}),!0),u.addEventListener("ended",(()=>{u.play()}),!0),u.src=e}))}updateTexture(){const e=Ve.f.getWebGLResourceRepository();this.__isTextureReady&&$e(this,Xe,"f")&&e.updateTexture(this._textureResourceUid,$e(this,Xe,"f"),{level:0,xoffset:0,yoffset:0,width:this.__width,height:this.__height,format:Ue.A.RGBA,type:E.I.UnsignedByte})}getCurrentFramePixelData(){let e;const t=Ve.f.getWebGLResourceRepository();return this.__isTextureReady&&$e(this,Xe,"f")&&(e=t.getPixelDataFromTexture(this._textureResourceUid,0,0,this.width,this.height)),[e,this.width,this.height]}set playbackRate(e){$e(this,Xe,"f")&&($e(this,Xe,"f").playbackRate=e)}get playbackRate(){var e;const t=null===(e=$e(this,Xe,"f"))||void 0===e?void 0:e.playbackRate;return null!=t?t:1}play(){var e;null===(e=$e(this,Xe,"f"))||void 0===e||e.play()}pause(){$e(this,Xe,"f").pause()}}Xe=new WeakMap,et.__loadedBasisFunc=!1;const tt=Object.freeze({createFrameBuffer:function(e){var t;const n=new Oe;n.create(e.width,e.height);for(let t=0;t<e.textureNum;t++){const o=new Ge.$;o.create({width:e.width,height:e.height,mipLevelCount:e.mipLevelCount,format:e.textureFormats[t]}),n.setColorAttachmentAt(t,o)}if(e.createDepthBuffer){const o=new Ge.$,a=null!==(t=e.depthTextureFormat)&&void 0!==t?t:Qe.n.Depth32F;o.create({width:e.width,height:e.height,mipLevelCount:1,format:a}),n.setDepthAttachment(o)}return n},createFrameBufferMSAA:function(e){const t=new Oe;t.create(e.width,e.height);for(let n=0;n<e.colorBufferNum;n++){const o=new qe;o.create(e.width,e.height,e.colorFormats[n],{isMSAA:!0,sampleCountMSAA:e.sampleCountMSAA}),t.setColorAttachmentAt(n,o)}const n=new qe;return n.create(e.width,e.height,e.depthBufferFormat,{isMSAA:!0,sampleCountMSAA:e.sampleCountMSAA}),t.setDepthAttachment(n),t},createFrameBufferTextureArray:function(e){const t=new Oe;t.create(e.width,e.height);const n=new Ge.$;n.createTextureArray({width:e.width,height:e.height,level:e.level,internalFormat:e.internalFormat,format:e.format,type:e.type,arrayLength:e.arrayLength}),t.setColorAttachmentAt(0,n);const o=new Ge.$;return o.createTextureArray({width:e.width,height:e.height,level:e.level,internalFormat:Qe.n.Depth32FStencil8,format:Ue.A.DepthStencil,type:E.I.Float,arrayLength:e.arrayLength}),t.setDepthStencilAttachment(o),t},createFrameBufferCubeMap:function(e){const t=new Oe;t.create(e.width,e.height);const n=new Ye._;return n.create({width:e.width,height:e.height,mipLevelCount:e.mipLevelCount,format:e.textureFormat}),t.setColorAttachmentCubeAt(0,0,0,n),[t,n]},createDepthBuffer:function(e,t,{level:n=0,internalFormat:o=Qe.n.Depth32F}){const a=new Oe;a.create(e,t);const i=new Ge.$;return i.create({width:e,height:t,mipLevelCount:1,format:o}),a.setDepthAttachment(i),a}});var nt=o(9936),ot=o(5738),at=o(1124);function it(e,t,n,o,a,i){const r=Ne.m.createGaussianBlurMaterial(),s=B.z.computeGaussianDistributionRatioWhoseSumIsOne({kernelSize:t,variance:n});r.setParameter("gaussianKernelSize",t),r.setParameter("gaussianRatio",new at.u(new Float32Array(s))),r.setParameter("framebufferSize",nt.I9.fromCopy2(a,i)),!1===o&&r.setParameter("isHorizontal",!1);const l=e.getFramebuffer().colorAttachments[0],c=Le.createScreenDrawRenderPassWithBaseColorTexture(r,l),_=tt.createFrameBuffer({width:a,height:i,textureNum:1,textureFormats:[Qe.n.RGBA8],createDepthBuffer:!1});return c.setFramebuffer(_),c}const rt=Object.freeze({createBloomExpression:function({textureToBloom:e,parameters:{luminanceCriterion:t=1,gaussianBlurLevelHighLuminance:n=4,gaussianKernelSize:o=10,gaussianVariance:a=10,synthesizeCoefficient:i=[1,1,1,1,1,1]}}){const r=function(e,t){const n=Ne.m.createDetectHighLuminanceMaterial({maxInstancesNumber:1},e);n.setParameter("luminanceCriterion",t);const o=Le.createScreenDrawRenderPass(n);o.tryToSetUniqueName("renderPassDetectHighLuminance",!0);const a=tt.createFrameBuffer({width:e.width,height:e.height,textureNum:1,textureFormats:[Qe.n.RGBA8],createDepthBuffer:!1});return o.setFramebuffer(a),o}(e,t),s=function(e,t,n,o,a,i){const r=[];for(let s=0;s<t;s++){const t=Math.max(a>>s+1,1),l=Math.max(i>>s+1,1);let c;c=it(0===s?e:r[r.length-1],n,o,!0,t,l),c.tryToSetUniqueName("renderPassBlurH_"+s,!0);const _=it(c,n,o,!1,t,l);_.tryToSetUniqueName("renderPassBlurHV_"+s,!0),r.push(c,_)}return r}(r,n,o,a,e.width,e.height),l=function(e,t,n){const o=[e];for(let e=1;e<t.length;e+=2)o.push(t[e].getFramebuffer().colorAttachments[0]);const a=Ne.m.createSynthesizeHDRMaterial({maxInstancesNumber:1},o);a.setParameter("synthesizeCoefficient",n);const i=Le.createScreenDrawRenderPass(a);i.tryToSetUniqueName("renderPassSynthesizeGlare",!0);const r=tt.createFrameBuffer({width:e.width,height:e.height,textureNum:1,textureFormats:[Qe.n.R11F_G11F_B10F],createDepthBuffer:!1});return i.setFramebuffer(r),i}(e,s,i),c=new ot.r;return c.addRenderPasses([r,...s,l]),{bloomExpression:c,bloomedRenderTarget:l.getFramebuffer().colorAttachments[0]}}});var st=o(6301),lt=o(4155),ct=o(9179),_t=o(4324);class ut extends _t.wJ{constructor({index:e,str:t}){super({index:e,str:t})}}const ft=new ut({index:0,str:"Sphere"}),dt=new ut({index:1,str:"Box"}),ht=[ft,dt],mt=Object.freeze({Sphere:ft,Box:dt,from:function(e){return(0,_t.yH)({typeList:ht,index:e})},fromString:function(e){return(0,_t.Pq)({typeList:ht,str:e})}});var pt=o(2216);function vt(e){const t=(0,pt.j)(),n=t.getMesh(),o=new ye.e;return o.addPrimitive(e),n.setMesh(o),t}const xt=Object.freeze({createPlane:(e={})=>{const t=new me.Z;t.generate(e);const n=vt(t);return st.Is.not.exist(e.direction)&&(e.direction="xz"),"xy"===e.direction?n.localEulerAngles=fe.Pq.fromCopy3(Math.PI/2,0,0):"yz"===e.direction&&(n.localEulerAngles=fe.Pq.fromCopy3(0,0,Math.PI/2)),n},createLine:(e={})=>{const t=new he;return t.generate(e),vt(t)},createGrid:(e={})=>{const t=new ue;return t.generate(e),vt(t)},createCube:(e={})=>{var t;const n=new _e.I;n.generate(e);const o=vt(n);if(st.Is.exist(e.physics)&&e.physics.use){const n=h.YY.addComponentToEntity(lt.l,o),a=n.getPhysics(),i=new ct.N,r={type:mt.Box,size:null!==(t=e.widthVector)&&void 0!==t?t:fe.Pq.fromCopy3(1,1,1),position:fe.Pq.fromCopy3(0,0,0),rotation:fe.Pq.fromCopy3(0,0,0),move:e.physics.move,density:e.physics.density,friction:e.physics.friction,restitution:e.physics.restitution};i.setShape(r,n),a.setStrategy(i)}return o},createCubes:(e,t={})=>{var n;const o=new _e.I;o.generate(t);const a=new ye.e;a.addPrimitive(o);const i=[];for(let o=0;o<e;o++){const e=(0,pt.j)();if(e.getMesh().setMesh(a),st.Is.exist(t.physics)&&t.physics.use){const o=h.YY.addComponentToEntity(lt.l,e),a=o.getPhysics(),i=new ct.N,r={type:mt.Box,size:null!==(n=t.widthVector)&&void 0!==n?n:fe.Pq.fromCopy3(1,1,1),position:fe.Pq.fromCopy3(0,0,0),rotation:fe.Pq.fromCopy3(0,0,0),move:t.physics.move,density:t.physics.density,friction:t.physics.friction,restitution:t.physics.restitution};i.setShape(r,o),a.setStrategy(i)}i.push(e)}return i},createSphere:(e={})=>{const t=new pe;t.generate(e);const n=vt(t);if(st.Is.exist(e.physics)&&e.physics.use){const t=h.YY.addComponentToEntity(lt.l,n),o=t.getPhysics(),a=new ct.N,i={type:mt.Sphere,size:st.Is.exist(e.radius)?fe.Pq.fromCopy3(e.radius,e.radius,e.radius):fe.Pq.fromCopy3(1,1,1),position:fe.Pq.fromCopy3(0,0,0),rotation:fe.Pq.fromCopy3(0,0,0),move:e.physics.move,density:e.physics.density,friction:e.physics.friction,restitution:e.physics.restitution};a.setShape(i,t),o.setStrategy(a)}return n},createSpheres:(e,t={})=>{const n=new pe;n.generate(t);const o=new ye.e;o.addPrimitive(n);const a=[];for(let n=0;n<e;n++){const e=(0,pt.j)();if(e.getMesh().setMesh(o),st.Is.exist(t.physics)&&t.physics.use){const n=h.YY.addComponentToEntity(lt.l,e),o=n.getPhysics(),a=new ct.N,i={type:mt.Sphere,size:st.Is.exist(t.radius)?fe.Pq.fromCopy3(t.radius,t.radius,t.radius):fe.Pq.fromCopy3(1,1,1),position:fe.Pq.fromCopy3(0,0,0),rotation:fe.Pq.fromCopy3(0,0,0),move:t.physics.move,density:t.physics.density,friction:t.physics.friction,restitution:t.physics.restitution};a.setShape(i,n),o.setStrategy(a)}a.push(e)}return a},createJoint:(e={})=>{const t=new de;return t.generate(e),vt(t)},createAxis:(e={})=>{const t=new ce;return t.generate(e),vt(t)},createShape:vt});var gt=o(3508),yt=o(7566),bt=o(833),It=o(4507),At=o(103);class Et{assignAnimation(e,t,n,o,a){return this.__resetAnimationAndPose(e),this.__setupAnimationForSameSkeleton(e,t,n,o,a),e}assignAnimationWithVrma(e,t,n){this.__resetAnimationAndPose(e,n);let o=new Set;return(t=>{if(null!=t.animations&&0!==t.animations.length){h.YY.addComponentToEntity(At.v,e);for(const e of t.animations)for(const t of e.samplers)gt.w._readBinaryFromAccessorAndSetItToAccessorExtras(t.inputObject),gt.w._readBinaryFromAccessorAndSetItToAccessorExtras(t.outputObject);for(const a of t.animations)for(const i of a.channels){const a=this.__getCorrespondingEntityWithVrma(e,t,i.target.node);if(a){const r=h.YY.addComponentToEntity(yt.C,a).getAnimation(),s=t.extras.rnEntities[i.target.node],l=t.extensions.VRMC_vrm_animation.humanoidBoneNameMap.get(i.target.node);let _;s.tryToSetUniqueName(l,!0),"0.x"===e.tryToGetVrm()._version?_=new It.i(s):"1.0"===e.tryToGetVrm()._version&&(_=new c.WB(s)),r._setRetarget(_,n).forEach((e=>{o.add(e)}))}}}})(t),Array.from(o)}constructor(){}__resetAnimationAndPose(e,t){!function e(t,n){const o=t.tryToGetAnimation();null!=o&&(null!=n?o.resetAnimationTrackByPostfix(n):o.resetAnimationTracks()),t.getTransform()._restoreTransformFromRest();for(const o of t.children)e(o.entity,n)}(e,t)}static getInstance(){return this.__instance||(this.__instance=new Et),this.__instance}__getCorrespondingEntity(e,t,n,o,a,i){if(i){const n=e.getTagValue("rnEntitiesByNames"),a=t.nodes[o];return n.get(a.name)}if(I.Is.exist(n.extensions.VRM)){const t=n.extensions.VRM.humanoid.humanBones;let i;const r=new Map,s=new Map;for(const e of t)r.set(e.node,e.bone),s.set(e.name,e.bone);null!=a&&(i=s.get(a),null==i&&(i=r.get(o)));const l=e.getTagValue("humanoid_map_name_nodeId").get(i);if(null!=l)return e.getTagValue("rnEntities")[l];P.V.info(`humanoidBoneName: ${i}, nodeIndex: ${o}, nodeName: ${a}`)}else if(I.Is.exist(n.extensions.VRMC_vrm)){const t=n.extensions.VRMC_vrm.humanoid.humanBones;let i;const r=new Map;for(const e in t){const n=t[e];r.set(n.node,e)}null!=a&&(i=r.get(o));const s=e.getTagValue("humanoid_map_name_nodeId").get(i);if(null!=s)return e.getTagValue("rnEntities")[s];P.V.info(`humanoidBoneName: ${i}, nodeIndex: ${o}, nodeName: ${a}`)}}__getCorrespondingEntityWithVrma(e,t,n){const o=t.extensions.VRMC_vrm_animation.humanoidBoneNameMap.get(n),a=e.getTagValue("humanoid_map_name_nodeId").get(o);if(null!=a)return e.getTagValue("rnEntities")[a];P.V.info(`humanoidBoneName: ${o}, nodeIndex: ${n}`)}__isHips(e,t,n){const o=new Map;if(I.Is.exist(t.extensions.VRM)){const e=t.extensions.VRM.humanoid.humanBones;for(const t of e)o.set(t.node,t.bone)}else if(I.Is.exist(t.extensions.VRMC_vrm)){const e=t.extensions.VRMC_vrm.humanoid.humanBones;for(const t in e){const n=e[t];o.set(n.node,t)}}return e.getTagValue("humanoid_map_name_nodeId"),"hips"===o.get(n)}__setupAnimationForSameSkeleton(e,t,n,o,a){var i,r,s,l;if(null!=t.animations&&0!==t.animations.length){h.YY.addComponentToEntity(At.v,e);for(const e of t.animations)for(const t of e.samplers)gt.w._readBinaryFromAccessorAndSetItToAccessorExtras(t.inputObject),gt.w._readBinaryFromAccessorAndSetItToAccessorExtras(t.outputObject);for(const _ of t.animations)for(const u of _.channels){const f=null===(r=null===(i=u.samplerObject)||void 0===i?void 0:i.inputObject)||void 0===r?void 0:r.extras.typedDataArray,d=null===(l=null===(s=u.samplerObject)||void 0===s?void 0:s.outputObject)||void 0===l?void 0:l.extras.typedDataArray,m=null!=u.samplerObject.interpolation?u.samplerObject.interpolation:"LINEAR",p=t.nodes[u.target.node],v=this.__getCorrespondingEntity(e,t,n,u.target.node,p.name,o);if(v){const o=h.YY.addComponentToEntity(yt.C,v).getAnimation();if("none"===a){let t="translate";t="translation"===u.target.path?"translate":"rotation"===u.target.path?"quaternion":u.target.path,"quaternion"===t?o.setAnimation(I.Is.exist(_.name)?_.name:"Untitled",t,f,d,4,bt.v.fromString(m)):"translate"===t&&this.__isHips(e,n,u.target.node)&&o.setAnimation(I.Is.exist(_.name)?_.name:"Untitled",t,f,d,3,bt.v.fromString(m))}else{const e=t.extras.rnEntities[u.target.node];let n;if("global"===a)n=new c.WB(e);else{if("absolute"!==a)throw new Error("unknown retarget mode");n=new c.qf(e)}o._setRetarget(n)}}}}}}var St=o(1692),Tt=o(7681),wt=o(8556);class Ct{constructor(){}async importPointCloud(e,t){const n=e.substring(0,e.lastIndexOf("/"))+"/",o=S.$.createDefaultGltfOptions();if(t&&t.files)for(const e in t.files)if("drc"===S.$.getExtension(e)){const a=await this.__decodeDraco(t.files[e],o,n,t);return new wt.Ok(a)}const a=await S.$.fetchArrayBuffer(e);if(a.isErr())return new wt._({message:"fetchArrayBuffer failed",error:a});const i=await this.__decodeDraco(a.get(),o,n,t);return new wt.Ok(i)}importArrayBuffer(e,t,n){const o=e.substring(0,e.lastIndexOf("/"))+"/",a=S.$.createDefaultGltfOptions();return this.__decodeDraco(t,a,o,n).catch((e=>{P.V.error("__loadFromArrayBuffer error: "+e)}))}async __loadFromArrayBuffer(e,t,n,o){const a=new DataView(e,0,20),i=!0;let r;if(1179937895!==a.getUint32(0,i)){const a=S.$.arrayBufferToString(e),i=JSON.parse(a);r=await this._loadAsTextJson(i,o,t,n).catch((e=>{P.V.error("this.__loadAsTextJson error: "+e)}))}else r=await this._loadAsBinaryJson(a,i,e,o,t,n).catch((e=>{P.V.error("this.__loadAsBinaryJson error: "+e)}));return r}_getOptions(e,t,n){if(t.asset&&t.asset.extras&&t.asset.extras.rnLoaderOptions)for(const n in t.asset.extras.rnLoaderOptions)e[n]=t.asset.extras.rnLoaderOptions[n];for(const t in n)e[t]=n[t];return n&&n.loaderExtensionName&&"string"==typeof n.loaderExtensionName&&(null!=Rn[n.loaderExtensionName]?e.loaderExtension=Rn[n.loaderExtensionName].getInstance():(P.V.error(`${n.loaderExtensionName} not found!`),e.loaderExtension=void 0)),e}async _loadAsBinaryJson(e,t,n,o,a,i){const r=e.getUint32(12,t);if(1313821514!==e.getUint32(16,t))throw new Error("invalid chunkType of chunk0 in this binary glTF file.");const s=new Uint8Array(n,20,r),l=S.$.uint8ArrayToString(s),c=JSON.parse(l);o=this._getOptions(a,c,o);const _=new Uint8Array(n,20+r+8);void 0===c.asset.extras&&(c.asset.extras={fileType:"glTF",version:"2"}),this._mergeExtendedJson(c,o.extendedJson),c.asset.extras.rnLoaderOptions=o;try{await this._loadInner(_,i,c,o)}catch(e){P.V.error("this._loadInner error in _loadAsBinaryJson: "+e)}return c}async _loadAsTextJson(e,t,n,o){void 0===e.asset.extras&&(e.asset.extras={fileType:"glTF",version:"2"}),t=this._getOptions(n,e,t),this._mergeExtendedJson(e,t.extendedJson),e.asset.extras.rnLoaderOptions=t;try{await this._loadInner(void 0,o,e,t)}catch(e){P.V.error("this._loadInner error in _loadAsTextJson: "+e)}return e}_loadInner(e,t,n,o){const a=[];return a.push(this._loadResources(e,t,n,o,{shaders:[],buffers:[],images:[]})),a.push(new Promise(((e,t)=>{this._loadJsonContent(n,o),e()}))),Promise.all(a)}_loadJsonContent(e,t){this._loadDependenciesOfScenes(e),this._loadDependenciesOfNodes(e),this._loadDependenciesOfMeshes(e),this._loadDependenciesOfMaterials(e),this._loadDependenciesOfTextures(e),this._loadDependenciesOfJoints(e),this._loadDependenciesOfAnimations(e),this._loadDependenciesOfAccessors(e),this._loadDependenciesOfBufferViews(e),void 0===e.asset.extras&&(e.asset.extras={})}_loadDependenciesOfScenes(e){for(const t of e.scenes)for(const n in t.nodes)t.nodesObjects[n]=e.nodes[t.nodes[n]]}_loadDependenciesOfNodes(e){for(const t of e.nodes){if(t.children){I.Is.not.exist(t.childrenObjects)&&(t.childrenObjects=[]);for(const n in t.children)t.childrenObjects[n]=e.nodes[t.children[n]]}void 0!==t.mesh&&void 0!==e.meshes&&(t.meshObject=e.meshes[t.mesh]),void 0!==t.skin&&void 0!==e.skins&&(t.skinObject=e.skins[t.skin],void 0===t.meshObject.extras&&(t.meshObject.extras={}),t.meshObject.extras._skin=t.skin),void 0!==t.camera&&void 0!==e.cameras&&(t.cameraObject=e.cameras[t.camera]),void 0!==t.extensions&&void 0!==e.extensions&&void 0!==e.extensions.KHR_lights_punctual&&(t.extensions.KHR_lights_punctual.lightIndex=t.extensions.KHR_lights_punctual.light,t.extensions.KHR_lights_punctual.light=e.extensions.KHR_lights_punctual.lights[t.extensions.KHR_lights_punctual.lightIndex])}}_loadDependenciesOfMeshes(e){for(const t of e.meshes)for(const n of t.primitives){void 0!==n.material&&(n.materialObject=e.materials[n.material]);for(const t in n.attributes){const o=n.attributes[t],a=e.accessors[o];a.extras={toGetAsTypedArray:!0,attributeName:t},n.attributesObjects[t]=a}if(null!=n.indices&&(n.indicesObject=e.accessors[n.indices]),null!=n.targets){n.targetsObjects=[];for(const t of n.targets){const o={};for(const n in t){const a=t[n];if(a>=0){const t=e.accessors[a];t.extras={toGetAsTypedArray:!0,attributeName:n},o[n]=t}}n.targetsObjects.push(o)}}}}_checkRnGltfLoaderOptionsExist(e){return!(!e.asset.extras||!e.asset.extras.rnLoaderOptions)}_loadDependenciesOfMaterials(e){if(e.textures||(e.textures=[]),e.materials)for(const t of e.materials){if(t.pbrMetallicRoughness){const n=t.pbrMetallicRoughness.baseColorTexture;void 0!==n&&(n.texture=e.textures[n.index]);const o=t.pbrMetallicRoughness.metallicRoughnessTexture;void 0!==o&&(o.texture=e.textures[o.index])}const n=t.normalTexture;void 0!==n&&(n.texture=e.textures[n.index]);const o=t.occlusionTexture;void 0!==o&&(o.texture=e.textures[o.index]);const a=t.emissiveTexture;void 0!==a&&(a.texture=e.textures[a.index]),this._checkRnGltfLoaderOptionsExist(e)&&e.asset.extras.rnLoaderOptions.loaderExtension&&e.asset.extras.rnLoaderOptions.loaderExtension.setTextures&&e.asset.extras.rnLoaderOptions.loaderExtension.setTextures(e,t)}}_loadDependenciesOfTextures(e){if(e.textures)for(const t of e.textures)(0,Tt.CW)((n=>{t.samplerObject=e.samplers[n]}),t.sampler),void 0!==t.source&&(t.image=e.images[t.source])}_loadDependenciesOfJoints(e){if(e.skins)for(const t of e.skins)if(I.Is.exist(t.skeleton)){t.skeletonObject=e.nodes[t.skeleton],(0,Tt.CW)((n=>t.inverseBindMatricesObject=e.accessors[n]),t.inverseBindMatrices),(0,Tt.TF)((()=>t.skeletonObject=e.nodes[t.joints[0]]),t.skeleton),t.jointsObjects=[];for(const n of t.joints)t.jointsObjects.push(e.nodes[n])}}_loadDependenciesOfAnimations(e){if(e.animations)for(const t of e.animations){for(const n of t.channels)n.samplerObject=t.samplers[n.sampler],n.target.nodeObject=e.nodes[n.target.node];for(const n of t.channels)if(I.Is.exist(n.samplerObject)&&(n.samplerObject.inputObject=e.accessors[n.samplerObject.input],n.samplerObject.outputObject=e.accessors[n.samplerObject.output],void 0===n.samplerObject.outputObject.extras&&(n.samplerObject.outputObject.extras={}),"rotation"===n.target.path&&(n.samplerObject.outputObject.extras.quaternionIfVec4=!0),"weights"===n.target.path)){const e=n.samplerObject.outputObject.count/n.samplerObject.inputObject.count;n.samplerObject.outputObject.extras.weightsArrayLength=e}}}_loadDependenciesOfAccessors(e){for(const t of e.accessors)if(null==t.bufferView&&(t.bufferView=0),t.bufferViewObject=e.bufferViews[t.bufferView],null!=t.sparse){const n=t.sparse;n.indices.bufferViewObject=e.bufferViews[n.indices.bufferView],n.values.bufferViewObject=e.bufferViews[n.values.bufferView]}}_loadDependenciesOfBufferViews(e){for(const t of e.bufferViews)void 0!==t.buffer&&(t.bufferObject=e.buffers[t.buffer])}_mergeExtendedJson(e,t){let n=null;if(t instanceof ArrayBuffer){const e=S.$.arrayBufferToString(t);n=JSON.parse(e)}else"string"==typeof t?n=JSON.parse(t):"object"==typeof t&&(n=t);Object.assign(e,n)}_loadResources(e,t,n,o,a){const i=[];let r;for(const s in n.buffers){const l=n.buffers[s];let c,_;l.uri&&(c=l.uri.split("/"),_=c[c.length-1]),r=void 0===l.uri?new St.m(((t,n)=>{a.buffers[s]=e,l.buffer=e,t(e)})):l.uri.match(/^data:application\/(.*);base64,/)?new St.m(((e,t)=>{const n=S.$.dataUriToArrayBuffer(l.uri);a.buffers[s]=new Uint8Array(n),l.buffer=new Uint8Array(n),e(n)})):o.files&&o.files[_]?new St.m(((e,t)=>{const n=o.files[_];a.buffers[s]=new Uint8Array(n),l.buffer=new Uint8Array(n),e(n)})):new St.m(S.$.loadResourceAsync(t+l.uri,!0,((e,t)=>{a.buffers[s]=new Uint8Array(t),l.buffer=new Uint8Array(t),e(t)}),((e,t)=>{}))),l.bufferPromise=r,i.push(r)}for(const r in n.images){const s=r,l=n.images[s];let c;if(void 0===l.uri){let t=e;null==e&&(t=n.bufferViews[l.bufferView].bufferObject.buffer);const o=S.$.createUint8ArrayFromBufferViewInfo(n,l.bufferView,e);c=S.$.createBlobImageUriFromUint8Array(o,l.mimeType)}else{const e=l.uri,n=e.split("/"),a=n[n.length-1];if(o.files&&o.files[a]){const e=o.files[a];c=S.$.createBlobImageUriFromUint8Array(new Uint8Array(e),l.mimeType)}else c=e.match(/^data:/)?e:t+e}const _=S.$.createImageFromUri(c,l.mimeType).then((e=>{e.crossOrigin="Anonymous",a.images[s]=e,l.image=e}));i.push(_)}return Promise.all(i).catch((e=>{P.V.error("Promise.all error: "+e)}))}static getInstance(){return this.__instance||(this.__instance=new Ct),this.__instance}__decodeDraco(e,t,n,o){return this.__decodeBuffer(e).then((e=>{const a=JSON.stringify(e),i=JSON.parse(a);return this._loadAsTextJson(i,o,t,n).catch((e=>{P.V.error("this.__loadAsTextJson error: "+e)}))}))}__decodeBuffer(e){const t=new DracoDecoderModule,n=new t.Decoder,o=this.__getGeometryFromDracoBuffer(t,n,e);if(null==o)throw new Error("invalid dracoGeometry.");if(o.geometryType!==t.POINT_CLOUD)throw new Error("invalid geometryType of drc file.");if(-1===n.GetAttributeId(o,t.POSITION))throw t.destroy(n),t.destroy(o),new Error("Draco: No position attribute found.");const a=["POSITION","NORMAL","COLOR","TEX_COORD","GENERIC"],i=o.num_points(),r=[],s=[];let l=0;for(let e=0;e<a.length;e++){const c=n.GetAttributeId(o,t[a[e]]);if(-1===c){a.splice(e,1),e--;continue}const _=n.GetAttribute(o,c),u=new t.DracoFloat32Array;n.GetAttributeFloatForAllPoints(o,_,u),r[e]=u;const f=_.num_components();s[e]=f,"COLOR"===a[e]?l+=4*i:l+=i*f}const c=new Float32Array(l);for(let e=0,n=0;e<a.length;e++){if("COLOR"===a[e]&&3===s[e])for(let t=0;t<i;n+=4,t+=3)c[n]=r[e].GetValue(t),c[n+1]=r[e].GetValue(t+1),c[n+2]=r[e].GetValue(t+2),c[n+3]=1;else if("TEX_COORD"===a[e])for(let t=0;t<i;n+=2,t++)c[n]=r[e].GetValue(2*t),c[n+1]=1-r[e].GetValue(2*t+1);else for(let t=0;t<i*s[e];n++,t++)c[n]=r[e].GetValue(t);t.destroy(r[e])}return t.destroy(n),t.destroy(o),this.__decodedBufferToJSON(c,i,a,s)}async __decodedBufferToJSON(e,t,n,o){const a={asset:{version:"2.0"},extensionsUsed:["KHR_materials_unlit"],extensionsRequired:["KHR_materials_unlit"],nodes:[{name:"Node",mesh:0}],scenes:[{nodes:[0]}],materials:[{name:"point-cloud_material",pbrMetallicRoughness:{baseColorFactor:[1,1,1,1]},extensions:{KHR_materials_unlit:{}}}]};return await this.__setBuffersToJSON(e,a),this.__setAccessorsAndBufferViewsToJSON(t,n,o,a),this.__setMeshesToJSON(n,a),new Promise(((e,t)=>{e(a)}))}__setBuffersToJSON(e,t){return this.__convertBufferToURI(e.buffer).then((n=>{t.buffers=[{name:"input",byteLength:e.byteLength,uri:n}]})).catch((e=>{P.V.error("this.__convertBufferToURI error: "+e)}))}__convertBufferToURI(e){return new Promise(((t,n)=>{const o=new Blob([e],{type:"application/octet-stream"}),a=new FileReader;a.onload=()=>{t(a.result)},a.onerror=()=>{n(a.error)},a.readAsDataURL(o)}))}__setAccessorsAndBufferViewsToJSON(e,t,n,o){const a=[],i=[];let r=0;for(let o=0,s=0;o<t.length;s++){const l=n[o];let c;c=1===l?"SCALAR":"VEC"+l;let _=0;const u=t[o];for(;o<t.length&&(a.push({name:"point-cloud_"+u+"_"+o,componentType:5126,count:e,type:c,bufferView:s,byteOffset:_}),"COLOR"===t[o]?_+=4*e*4:_+=e*l*4,o++,u==t[o]););i[s]={name:"bufferView_"+u,buffer:0,byteLength:_,byteOffset:r,byteStride:4*l,target:34962},r+=_}o.accessors=a,o.bufferViews=i}__setMeshesToJSON(e,t){const n={};for(let t=0;t<e.length;t++)"TEX_COORD"===e[t]?n.TEXCOORD_0=t:"GENERIC"===e[t]?n.TANGENT=t:n[e[t]]=t;const o={name:"Node-Mesh",primitives:[{mode:0,material:0,attributes:n}]};t.meshes=[o]}async importPointCloudToPrimitive(e){const t=await S.$.fetchArrayBuffer(e);return this.__decodeDracoToPrimitive(t.unwrapForce())}__decodeDracoToPrimitive(e){const t=new DracoDecoderModule,n=new t.Decoder,o=this.__getGeometryFromDracoBuffer(t,n,e);if(null==o)throw new Error("invalid dracoGeometry.");if(o.geometryType!==t.POINT_CLOUD)throw new Error("invalid geometryType of drc file.");const a=[],i=[],r=[];this.__getPositions(t,n,o,a,i,r),this.__getColors(t,n,o,a,i,r),this.__getNormals(t,n,o,a,i,r),this.__getTextureCoords(t,n,o,a,i,r);const s=be.s.createPrimitive({attributeSemantics:i,attributes:r,material:Ne.m.createClassicUberMaterial({isSkinning:!1,isLighting:!0}),primitiveMode:se.R.Points});return t.destroy(n),t.destroy(o),s}__getGeometryFromDracoBuffer(e,t,n){const o=new e.DecoderBuffer;o.Init(new Int8Array(n),n.byteLength);const a=t.GetEncodedGeometryType(o);let i,r;if(a===e.TRIANGULAR_MESH)i=new e.Mesh,r=t.DecodeBufferToMesh(o,i);else if(a===e.POINT_CLOUD)i=new e.PointCloud,r=t.DecodeBufferToPointCloud(o,i);else{const e="Unknown geometry type.";P.V.error(e)}if(i.geometryType=a,!r.ok()||0==i.ptr){let n="Decoding failed: ";return n+=r.error_msg(),P.V.error(n),e.destroy(t),void e.destroy(i)}return e.destroy(o),i}__getPositions(e,t,n,o,a,i){const r=t.GetAttributeId(n,e.POSITION);if(-1===r)throw e.destroy(t),e.destroy(n),new Error("Draco: No position attribute found.");const s=t.GetAttribute(n,r),l=new e.DracoFloat32Array;t.GetAttributeFloatForAllPoints(n,s,l);const c=3*n.num_points(),_=new Float32Array(c);for(let e=0;e<c;e+=1)_[e]=l.GetValue(e);return o.push(w.h.Vec3),a.push(re.r.Position.XYZ),i.push(_),e.destroy(l),_}__getColors(e,t,n,o,a,i){const r=t.GetAttributeId(n,e.COLOR);if(-1===r)return null;{const s=t.GetAttribute(n,r),l=new e.DracoFloat32Array;t.GetAttributeFloatForAllPoints(n,s,l);const c=n.num_points(),_=s.num_components(),u=4*c,f=new Float32Array(u);for(let e=0;e<u;e+=_)f[e]=l.GetValue(e),f[e+1]=l.GetValue(e+1),f[e+2]=l.GetValue(e+2),f[e+3]=4==_?l.GetValue(e+3):1;return o.push(w.h.Vec3),a.push(re.r.Color0.XYZ),i.push(f),e.destroy(l),f}}__getNormals(e,t,n,o,a,i){const r=t.GetAttributeId(n,e.NORMAL);if(-1===r)return null;{const s=t.GetAttribute(n,r),l=new e.DracoFloat32Array;t.GetAttributeFloatForAllPoints(n,s,l);const c=3*n.num_points(),_=new Float32Array(c);for(let e=0;e<c;e+=1)_[e]=l.GetValue(e);return o.push(w.h.Vec3),a.push(re.r.Normal.XYZ),i.push(_),e.destroy(l),_}}__getTextureCoords(e,t,n,o,a,i){const r=t.GetAttributeId(n,e.TEX_COORD);if(-1===r)return null;{const s=t.GetAttribute(n,r),l=new e.DracoFloat32Array;t.GetAttributeFloatForAllPoints(n,s,l);const c=2*n.num_points(),_=new Float32Array(c);for(let e=0;e<c;e+=1)_[e]=l.GetValue(e);return o.push(w.h.Vec2),a.push(re.r.Texcoord0.XY),i.push(_),e.destroy(l),_}}}var Rt=o(6747);function Pt(e){for(const t in e){const e=S.$.getExtension(t);if("gltf"===e)return Rt.p.Gltf;if("glb"===e)return Rt.p.GltfBinary;if("vrm"===e)return Rt.p.VRM;if("drc"===e)return Rt.p.Draco}return Rt.p.Unknown}function Nt(e){const t=e.split("."),n=t[t.length-1];return"efk"===n?"Effekseer":"drc"===n?"Draco":"vrm"===n?"VRM":"gltf"===n?"glTF":"Unknown"}var Mt=o(148),Dt=o(5697),Ft=o(6603),Bt=o(6612),Lt=o(6253);class Vt{constructor(){}getParentRotation(e){return null!=e.parent?e.parent.getRotationTo(Vt.__tmp_getParentRotation_quat_0):Vt.__tmp_getParentRotation_quat_1_identity}update(){const e=this.__spring;I.Is.exist(e)&&this.updateInner(e.bones,e)}updateInner(e,t){const n=t.center,o=t.colliderGroups;for(const t of e)t.setup(n);for(const t of e)this.process(o,t,n)}process(e,t,n){t._calcWorldSpaceBoneLength();const o=t.dragForce,a=t.stiffnessForce*Bt.g.intervalProcessBegin*f.T.physicsTimeIntervalScale;let i=Dt.tp.multiplyTo(fe.Pq.subtractTo(t.currentTail,t.prevTail,Vt.__tmp_process_vec3_0),1-o,Vt.__tmp_process_vec3_1);const r=fe.Pq.addTo(t.currentTail,i,Vt.__tmp_process_vec3_2),s=null!=n?n.getWorldPositionOfTo(r,Vt.__tmp_process_vec3_3):r,l=Ft.P.multiplyTo(this.getParentRotation(t.node.getSceneGraph()),t.node.localRotationRestInner,Vt.__tmp_process_quat_0),c=fe.Pq.multiplyTo(l.transformVector3To(t.boneAxis,Vt.__tmp_process_vec3_4),a,Vt.__tmp_process_vec3_5),_=fe.Pq.multiplyTo(t.gravityDir,t.gravityPower*Bt.g.intervalProcessBegin*f.T.physicsTimeIntervalScale,Vt.__tmp_process_vec3_6);let u=fe.Pq.addTo(fe.Pq.addTo(s,c,Vt.__tmp_process_vec3_7),_,Vt.__tmp_process_vec3_8);u=this.normalizeBoneLength(u,t),u=this.collision(e,u,t.hitRadius,t),t.prevTail=t.currentTail.clone(),t.currentTail=null!=n?n.getLocalPositionOfTo(u,Vt.__tmp_process_vec3_9).clone():u.clone();const d=this.applyRotation(u,t);t.node.localRotation=d,t.node.getSceneGraph().setWorldMatrixDirty()}normalizeBoneLength(e,t){const n=fe.Pq.normalizeTo(fe.Pq.subtractTo(e,t.node.getSceneGraph().getPositionTo(Vt.__tmp_normalizeBoneLength_vec3_4),Vt.__tmp_normalizeBoneLength_vec3_0),Vt.__tmp_normalizeBoneLength_vec3_1);return fe.Pq.addTo(t.node.getSceneGraph().getPositionTo(Vt.__tmp_normalizeBoneLength_vec3_5),fe.Pq.multiplyTo(n,t.boneLength,Vt.__tmp_normalizeBoneLength_vec3_2),Vt.__tmp_normalizeBoneLength_vec3_3)}applyRotation(e,t){const n=fe.Pq.subtractTo(e,t.node.getSceneGraph().getPositionTo(Vt.__tmp_applyRotation_vec3_3),Vt.__tmp_applyRotation_vec3_0),o=Ft.P.invertTo(Ft.P.multiplyTo(t.node.parent.getRotationTo(Vt.__tmp_applyRotation_quat_4),t.node.localRotationRestInner,Vt.__tmp_applyRotation_quat_0),Vt.__tmp_applyRotation_quat_1).transformVector3To(n,Vt.__tmp_applyRotation_vec3_1),a=Ft.P.fromToRotationTo(t.boneAxis,fe.Pq.normalizeTo(o,Vt.__tmp_applyRotation_vec3_2),Vt.__tmp_applyRotation_quat_2);return Ft.P.multiplyTo(t.node.localRotationRestInner,a,Vt.__tmp_applyRotation_quat_3)}collision(e,t,n,o){for(const a of e){for(const e of a.sphereColliders){const{direction:a,distance:i}=e.collision(t,n);i<0&&(t=fe.Pq.addTo(t,fe.Pq.multiplyTo(a,-i,Vt.__tmp_collision_vec3_0),Vt.__tmp_collision_vec3_1),t=this.normalizeBoneLength(t,o))}for(const e of a.capsuleColliders){const{direction:a,distance:i}=e.collision(t,n);i<0&&(t=fe.Pq.addTo(t,fe.Pq.multiplyTo(a,-i,Vt.__tmp_collision_vec3_2),Vt.__tmp_collision_vec3_3),t=this.normalizeBoneLength(t,o))}}return t}setSpring(e){this.__spring=e}}Vt.__tmp_process_vec3_0=Dt.tp.zero(),Vt.__tmp_process_vec3_1=Dt.tp.zero(),Vt.__tmp_process_vec3_2=Dt.tp.zero(),Vt.__tmp_process_vec3_3=Dt.tp.zero(),Vt.__tmp_process_vec3_4=Dt.tp.zero(),Vt.__tmp_process_vec3_5=Dt.tp.zero(),Vt.__tmp_process_vec3_6=Dt.tp.zero(),Vt.__tmp_process_vec3_7=Dt.tp.zero(),Vt.__tmp_process_vec3_8=Dt.tp.zero(),Vt.__tmp_process_vec3_9=Dt.tp.zero(),Vt.__tmp_process_quat_0=Lt.h.identity(),Vt.__tmp_normalizeBoneLength_vec3_0=Dt.tp.zero(),Vt.__tmp_normalizeBoneLength_vec3_1=Dt.tp.zero(),Vt.__tmp_normalizeBoneLength_vec3_2=Dt.tp.zero(),Vt.__tmp_normalizeBoneLength_vec3_3=Dt.tp.zero(),Vt.__tmp_normalizeBoneLength_vec3_4=Dt.tp.zero(),Vt.__tmp_normalizeBoneLength_vec3_5=Dt.tp.zero(),Vt.__tmp_applyRotation_vec3_0=Dt.tp.zero(),Vt.__tmp_applyRotation_vec3_1=Dt.tp.zero(),Vt.__tmp_applyRotation_vec3_2=Dt.tp.zero(),Vt.__tmp_applyRotation_vec3_3=Dt.tp.zero(),Vt.__tmp_applyRotation_quat_0=Lt.h.identity(),Vt.__tmp_applyRotation_quat_1=Lt.h.identity(),Vt.__tmp_applyRotation_quat_2=Lt.h.identity(),Vt.__tmp_applyRotation_quat_3=Lt.h.identity(),Vt.__tmp_applyRotation_quat_4=Lt.h.identity(),Vt.__tmp_getParentRotation_quat_0=Lt.h.identity(),Vt.__tmp_getParentRotation_quat_1_identity=Lt.h.identity(),Vt.__tmp_collision_vec3_0=Dt.tp.zero(),Vt.__tmp_collision_vec3_1=Dt.tp.zero(),Vt.__tmp_collision_vec3_2=Dt.tp.zero(),Vt.__tmp_collision_vec3_3=Dt.tp.zero();class zt{constructor(){this.position=fe.Pq.zero(),this.radius=0}collision(e,t){const n=this.baseSceneGraph.getWorldPositionOfTo(this.position,zt.__tmp_vec3_0),o=fe.Pq.subtractTo(e,n,zt.__tmp_vec3_1),a=fe.Pq.normalizeTo(o,zt.__tmp_vec3_2),i=this.radius+t;return{direction:a,distance:o.length()-i}}}zt.__tmp_vec3_0=Dt.tp.zero(),zt.__tmp_vec3_1=Dt.tp.zero(),zt.__tmp_vec3_2=Dt.tp.zero();class Gt{constructor(){this.sphereColliders=[],this.capsuleColliders=[]}}class Ot extends v.E{constructor(e){super(),this.bones=[],this.colliderGroups=[],this.rootBone=e}}var Ut=o(1663),kt=o(6227);class Wt extends v.E{constructor(e){super(),this.stiffnessForce=1,this.gravityPower=0,this.gravityDir=fe.Pq.fromCopyArray([0,-1,0]),this.dragForce=.4,this.hitRadius=.02,this.currentTail=fe.Pq.zero(),this.prevTail=fe.Pq.zero(),this.boneAxis=fe.Pq.zero(),this.boneLength=0,this.initialLocalChildPosition=fe.Pq.zero(),this.initialized=!1,this.node=e}setup(e){if(!this.initialized){this.node.getTransform()._backupTransformAsRest();const t=this.node.getSceneGraph().children;t.length>0?this.initialLocalChildPosition=t[0].entity.getTransform().localPosition:this.initialLocalChildPosition=fe.Pq.multiply(fe.Pq.normalize(this.node.getTransform().localPosition),.07);const n=this.node.matrixInner.multiplyVector3(this.initialLocalChildPosition);this.currentTail=null!=e?e.getLocalPositionOf(n):n,this.prevTail=this.currentTail.clone(),this.boneAxis=fe.Pq.normalize(this.initialLocalChildPosition),this.initialized=!0}}_getMatrixCenterToWorld(e){return null!=e?e.matrixInner:kt._0.identity()}_getMatrixWorldToCenter(e){return null!=e?kt._0.invert(e.matrixInner):kt._0.identity()}_calcWorldSpaceBoneLength(){const e=this.node.getSceneGraph().matrixInner.getTranslateTo(Wt.__tmp_vec3_0);let t=Wt.__tmp_vec3_2_zero;const n=this.node.getSceneGraph().children;t=n.length>0?n[0].matrixInner.getTranslateTo(Wt.__tmp_vec3_1):fe.Pq.multiplyMatrix4(this.initialLocalChildPosition,this.node.getSceneGraph().matrixInner),this.boneLength=fe.Pq.subtract(e,t).length()}}Wt.__tmp_vec3_0=kt.tp.zero(),Wt.__tmp_vec3_1=kt.tp.zero(),Wt.__tmp_vec3_2_zero=fe.Pq.zero();class Qt{constructor(){}static async importFromUri(e,t){var n,o;t=this._getOptions(t);const a=await Mt.a.importFromUri(e,t);if(a.isErr())return new wt._({message:"Failed to import VRM file.",error:a});(0,wt.j3)(a);const i=a.get(),r=Qt._createTextures(i),s=Qt._createSamplers(i),l=null===(o=null===(n=i.asset.extras)||void 0===n?void 0:n.rnLoaderOptions)||void 0===o?void 0:o.defaultMaterialHelperArgumentArray;let c;I.Is.exist(l)&&(l[0].textures=r,l[0].samplers=s),Qt._initializeMaterialProperties(i,r.length);const _=gt.w.convertToRhodoniteObject(i);return Qt._existOutlineMaterial(i.extensions.VRM)?(I.Is.exist(l)&&(l[0].isOutline=!0),c=[_,gt.w.convertToRhodoniteObject(i)]):c=[_],Qt._readSpringBone(i),Qt._readVRMHumanoidInfo(i,_),new wt.Ok(c)}static async importJsonOfVRM(e,t){t=this._getOptions(t);const n=await Mt.a.importFromUri(e,t);if(n.isErr())return new wt._({message:"Failed to import VRM file.",error:n});(0,wt.j3)(n);const o=n.get();return Qt._readVRMHumanoidInfo(o),new wt.Ok(o)}static async __importVRM0x(e,t){var n,o,a,i,r,s;const l=null===(o=null===(n=e.asset.extras)||void 0===n?void 0:n.rnLoaderOptions)||void 0===o?void 0:o.defaultMaterialHelperArgumentArray,c=this._createTextures(e),_=this._createSamplers(e);let u;if(I.Is.exist(l)&&(l[0].textures=null!==(a=l[0].textures)&&void 0!==a?a:c,l[0].samplers=null!==(i=l[0].samplers)&&void 0!==i?i:_,l[0].isLighting=null===(r=l[0].isLighting)||void 0===r||r),this._initializeMaterialProperties(e,c.length),this._existOutlineMaterial(e.extensions.VRM)){t[1]=null!==(s=t[1])&&void 0!==s?s:new De.A;const n=t[1];n.toClearColorBuffer=!1,n.toClearDepthBuffer=!1,e.extensions.VRM.rnExtension={renderPassOutline:n},u=gt.w.convertToRhodoniteObject(e),n.addEntities([u])}else u=gt.w.convertToRhodoniteObject(e);const f=t[0];f.tryToSetUniqueName("VRM Main RenderPass",!0),f.addEntities([u]),this._readSpringBone(e),this._readVRMHumanoidInfo(e,u),this._readBlendShapeGroup(e,u)}static _readBlendShapeGroup(e,t){const n=[],o=e.extensions.VRM.blendShapeMaster.blendShapeGroups;for(const t of o){const o={name:t.presetName,isBinary:t.isBinary,binds:t.binds.map((t=>{for(let n=0;n<e.nodes.length;n++)if(e.nodes[n].mesh===t.mesh)return{entityIdx:e.extras.rnEntities[n].entityUID,blendShapeIdx:t.index,weight:t.weight/100};throw new Error("Not Found node in blendShapeGroup Process")}))};n.push(o)}const a=h.YY.addComponentToEntity(Ut.r,t);a.getVrm().setVrmExpressions(n),a.getVrm()._version="0.x"}static _readVRMHumanoidInfo(e,t){const n=e.extensions.VRM.humanoid.humanBones,o=new Map;for(const t of n){o.set(t.bone,t.node);const n=e.nodes[t.node];t.name=n.name}null!=t&&t.tryToSetTag({tag:"humanoid_map_name_nodeId",value:o})}static _readSpringBone(e){const t=[];for(const n in e.extensions.VRM.secondaryAnimation.colliderGroups){const o=e.extensions.VRM.secondaryAnimation.colliderGroups[n],a=new Gt;t.push(a);const i=[],r=e.asset.extras.rnEntities[o.node].getSceneGraph();for(const e of o.colliders){const t=new zt;t.baseSceneGraph=r,t.position=fe.Pq.fromCopyArray([e.offset.x,e.offset.y,e.offset.z]),t.radius=e.radius,i.push(t)}a.sphereColliders=i}const n=[];for(const o of e.extensions.VRM.secondaryAnimation.boneGroups){if(0===o.bones.length)continue;const a=o.bones[0],i=e.asset.extras.rnEntities[a],r=new Ot(i.getSceneGraph());r.tryToSetUniqueName(o.comment,!0),r.colliderGroups=o.colliderGroups.map((e=>t[e]));const s=[];for(const t in o.bones){const n=o.bones[t],a=e.asset.extras.rnEntities[n];this.__addSpringBoneRecursively(r,a,o,s)}null!=o.center&&-1!==o.center&&(r.center=e.asset.extras.rnEntities[o.center].getSceneGraph()),n.push(r)}for(const e of n)this.__addPhysicsComponent(e,e.rootBone)}static __addSpringBoneRecursively(e,t,n,o){const a=t.getSceneGraph().children;if(!o.includes(t)){const a=new Wt(t);a.dragForce=n.dragForce,a.stiffnessForce=n.stiffiness,a.gravityPower=n.gravityPower,a.gravityDir=fe.Pq.fromCopyArray([n.gravityDir.x,n.gravityDir.y,n.gravityDir.z]),a.hitRadius=n.hitRadius,e.bones.push(a),o.push(t)}for(const t of a)this.__addSpringBoneRecursively(e,t.entity,n,o)}static __addPhysicsComponent(e,t){const n=t.entity,o=h.YY.addComponentToEntity(lt.l,n).getPhysics(),a=new Vt;a.setSpring(e),o.setStrategy(a)}static _createTextures(e){e.textures||(e.textures=[]);const t=e.textures,n=[];for(let o=0;o<t.length;o++){const a=gt.w._createTexture(t[o],e);n[o]=a}const o=new Ke.g;o.generate1x1TextureFrom(),n.push(o);const a=new Ke.g;return a.generate1x1TextureFrom("rgba(0, 0, 0, 1)"),n.push(a),n}static _createSamplers(e){e.textures||(e.textures=[]);const t=e.textures,n=[];for(let e=0;e<t.length;e++){const o=gt.w._createSampler(t[e]);n[e]=o}const o=new Fe.L({wrapS:x.gu.ClampToEdge,wrapT:x.gu.ClampToEdge,minFilter:x.gu.Linear,magFilter:x.gu.Linear});return o.create(),n.push(o),n.push(o),n}static _existOutlineMaterial(e){const t=e.materialProperties;if(null!=t)for(const e of t)if(0!==e.floatProperties._OutlineWidthMode)return!0;return!1}static _initializeMaterialProperties(e,t){const n=e.extensions.VRM.materialProperties;for(const o of n)if("VRM/MToon"===o.shader){this.__initializeMToonMaterialProperties(e,t);break}}static __initializeMToonMaterialProperties(e,t){const n=e.extensions.VRM.materialProperties,o=t-2,a=t-1;for(let e=0;e<n.length;e++){const t=n[e].floatProperties;this.__initializeForUndefinedProperty(t,"_BlendMode",0),this.__initializeForUndefinedProperty(t,"_BumpScale",1),this.__initializeForUndefinedProperty(t,"_CullMode",2),this.__initializeForUndefinedProperty(t,"_Cutoff",.5),this.__initializeForUndefinedProperty(t,"_DebugMode",0),this.__initializeForUndefinedProperty(t,"_DstBlend",0),this.__initializeForUndefinedProperty(t,"_IndirectLightIntensity",.1),this.__initializeForUndefinedProperty(t,"_LightColorAttenuation",0),this.__initializeForUndefinedProperty(t,"_OutlineColorMode",0),this.__initializeForUndefinedProperty(t,"_OutlineCullMode",1),this.__initializeForUndefinedProperty(t,"_OutlineLightingMix",1),this.__initializeForUndefinedProperty(t,"_OutlineScaledMaxDistance",1),this.__initializeForUndefinedProperty(t,"_OutlineWidth",.5),this.__initializeForUndefinedProperty(t,"_OutlineWidthMode",0),this.__initializeForUndefinedProperty(t,"_ReceiveShadowRate",1),this.__initializeForUndefinedProperty(t,"_RimFresnelPower",1),this.__initializeForUndefinedProperty(t,"_RimLift",0),this.__initializeForUndefinedProperty(t,"_RimLightingMix",0),this.__initializeForUndefinedProperty(t,"_ShadeShift",0),this.__initializeForUndefinedProperty(t,"_ShadeToony",.9),this.__initializeForUndefinedProperty(t,"_ShadingGradeRate",1),this.__initializeForUndefinedProperty(t,"_SrcBlend",1),this.__initializeForUndefinedProperty(t,"_ZWrite",1);const i=n[e].vectorProperties;this.__initializeForUndefinedProperty(i,"_Color",[1,1,1,1]),this.__initializeForUndefinedProperty(i,"_EmissionColor",[0,0,0]),this.__initializeForUndefinedProperty(i,"_OutlineColor",[0,0,0,1]),this.__initializeForUndefinedProperty(i,"_ShadeColor",[.97,.81,.86,1]),this.__initializeForUndefinedProperty(i,"_RimColor",[0,0,0]);const r=n[e].textureProperties;this.__initializeForUndefinedProperty(r,"_BumpMap",o),this.__initializeForUndefinedProperty(r,"_EmissionMap",a),this.__initializeForUndefinedProperty(r,"_MainTex",o),this.__initializeForUndefinedProperty(r,"_OutlineWidthTexture",o),this.__initializeForUndefinedProperty(r,"_ReceiveShadowTexture",o),this.__initializeForUndefinedProperty(r,"_RimTexture",a),this.__initializeForUndefinedProperty(r,"_ShadeTexture",o),this.__initializeForUndefinedProperty(r,"_ShadingGradeTexture",o),this.__initializeForUndefinedProperty(r,"_SphereAdd",a)}for(let t=0;t<e.materials.length;t++){const o=e.materials[t];null==o.extras&&(o.extras={}),o.extras.vrm0xMaterialProperty=n[t]}}static __initializeForUndefinedProperty(e,t,n){null==e[t]&&(e[t]=n)}static _getOptions(e){if(null!=e){for(const t in e.files){const n=t.split(".vrm")[0];if(n){const o=e.files[t];e.files[n+".glb"]=o,delete e.files[t]}}e.__isImportVRM0x=!0,null==e.defaultMaterialHelperArgumentArray&&(e.defaultMaterialHelperArgumentArray=[{}]),e.defaultMaterialHelperArgumentArray[0].isMorphing||(e.maxMorphTargetNumber=0)}else e={files:{},loaderExtension:void 0,defaultMaterialHelperName:void 0,defaultMaterialHelperArgumentArray:[{isLighting:!0,isMorphing:!0,isSkinning:!0}],statesOfElements:[{targets:[],states:{enable:[],functions:{}},isTransparent:!0,opacity:1,isTextureImageToLoadPreMultipliedAlpha:!1}],__isImportVRM0x:!0,__importedType:"vrm0x"};return e}}class qt{constructor(){this.position=fe.Pq.zero(),this.radius=0,this.tail=fe.Pq.zero()}collision(e,t){const n=this.baseSceneGraph.getWorldPositionOf(this.position);let o=this.baseSceneGraph.getWorldPositionOf(this.tail);o=fe.Pq.subtract(o,n);const a=o.lengthSquared();let i=fe.Pq.subtract(e,n);const r=o.dot(i);r<=0||(a<=r||(o=fe.Pq.multiply(o,r/a)),i=fe.Pq.subtract(i,o));const s=this.radius+t,l=i.length()-s;return i=fe.Pq.normalize(i),{direction:i,distance:l}}}var Xt=o(5999);class Ht{constructor(e,t,n,o){this.__srcEntity=e,this.__rollAxis=t,this.__weight=n,this.__dstEntity=o,this.__dstEntity.getTransform()._backupTransformAsRest()}getAxisVector(e){switch(e){case"X":return fe.Pq.fromCopy3(1,0,0);case"Y":return fe.Pq.fromCopy3(0,1,0);case"Z":return fe.Pq.fromCopy3(0,0,1);default:throw new Error("Invalid roll axis")}}update(){const e=Ft.P.multiply(Ft.P.invert(this.__srcEntity.localRotationRestInner),this.__srcEntity.localRotationInner),t=Ft.P.multiply(Ft.P.multiply(this.__srcEntity.localRotationRestInner,e),Ft.P.invert(this.__srcEntity.localRotationRestInner)),n=Ft.P.multiply(Ft.P.multiply(Ft.P.invert(this.__dstEntity.localRotationRestInner),t),this.__dstEntity.localRotationRestInner),o=this.getAxisVector(this.__rollAxis),a=n.transformVector3(o),i=Ft.P.fromToRotation(o,a),r=Ft.P.lerp(this.__dstEntity.localRotationRestInner,Ft.P.multiply(Ft.P.multiply(this.__dstEntity.localRotationRestInner,Ft.P.invert(i)),n),this.__weight);this.__dstEntity.localRotation=r}}class jt{constructor(e,t,n,o){this.__srcEntity=e,this.__aimAxis=t,this.__weight=n,this.__dstEntity=o,this.__dstEntity.getTransform()._backupTransformAsRest()}getAxisVector(e){switch(e){case"PositiveX":return fe.Pq.fromCopy3(1,0,0);case"NegativeX":return fe.Pq.fromCopy3(-1,0,0);case"PositiveY":return fe.Pq.fromCopy3(0,1,0);case"NegativeY":return fe.Pq.fromCopy3(0,-1,0);case"PositiveZ":return fe.Pq.fromCopy3(0,0,1);case"NegativeZ":return fe.Pq.fromCopy3(0,0,-1);default:throw new Error("Invalid roll axis")}}update(){const e=this.getAxisVector(this.__aimAxis),t=I.Is.exist(this.__dstEntity.getSceneGraph().parent)?this.__dstEntity.getSceneGraph().parent.rotation:kt.PT.identity(),n=this.__dstEntity.localRotationRestInner,o=kt.PT.multiply(t,n).transformVector3(e),a=fe.Pq.normalize(fe.Pq.subtract(this.__srcEntity.position,this.__dstEntity.position)),i=kt.PT.fromToRotation(o,a),r=kt.PT.lerp(n,kt.PT.multiply(kt.PT.multiply(kt.PT.multiply(kt.PT.invert(t),i),t),n),this.__weight);this.__dstEntity.localRotation=r}}class Yt{constructor(e,t,n){this.__srcEntity=e,this.__weight=t,this.__dstEntity=n,this.__dstEntity.getTransform()._backupTransformAsRest()}update(){const e=kt.PT.multiply(kt.PT.invert(this.__srcEntity.localRotationRestInner),this.__srcEntity.localRotationInner),t=kt.PT.lerp(this.__dstEntity.localRotationRestInner,kt.PT.multiply(this.__dstEntity.localRotationRestInner,e),this.__weight);this.__dstEntity.localRotation=t}}class Kt{constructor(){}static async __importVRM(e,t){var n,o,a,i,r,s,l;const c=null===(o=null===(n=e.asset.extras)||void 0===n?void 0:n.rnLoaderOptions)||void 0===o?void 0:o.defaultMaterialHelperArgumentArray,_=this._createTextures(e),u=this._createSamplers(e);let f;if(I.Is.exist(c)&&(c[0].textures=null!==(a=c[0].textures)&&void 0!==a?a:_,c[0].samplers=null!==(i=c[0].samplers)&&void 0!==i?i:u,c[0].isLighting=null===(r=c[0].isLighting)||void 0===r||r),this.__initializeMToonMaterialProperties(e,_.length)){t[1]=null!==(s=t[1])&&void 0!==s?s:new De.A;const n=t[1];n.toClearColorBuffer=!1,n.toClearDepthBuffer=!1,e.extensions.VRM={},e.extensions.VRM.rnExtension={renderPassOutline:n},f=gt.w.convertToRhodoniteObject(e),n.addEntities([f])}else f=gt.w.convertToRhodoniteObject(e);const d=t[0];d.tryToSetUniqueName("VRM Main RenderPass",!0),d.addEntities([f]),this._readSpringBone(e),this._readVRMHumanoidInfo(e,f),this._readExpressions(e,f),this._readConstraints(e),null!=(null===(l=e.asset.extras)||void 0===l?void 0:l.rnLoaderOptions)&&(e.asset.extras.rnLoaderOptions.defaultMaterialHelperArgumentArray=[])}static _readConstraints(e){var t,n;for(let o=0;o<e.nodes.length;o++){const a=null===(n=null===(t=e.nodes[o].extensions)||void 0===t?void 0:t.VRMC_node_constraint)||void 0===n?void 0:n.constraint;if(I.Is.exist(a))if(I.Is.exist(a.roll)){const t=a.roll,n=e.extras.rnEntities[o],i=e.extras.rnEntities[t.source],r=h.YY.addComponentToEntity(Xt.J,n),s=new Ht(i,t.rollAxis,I.Is.exist(t.weight)?t.weight:1,r);r.getConstraint().setConstraint(s)}else if(I.Is.exist(a.aim)){const t=a.aim,n=e.extras.rnEntities[o],i=e.extras.rnEntities[t.source],r=h.YY.addComponentToEntity(Xt.J,n),s=new jt(i,t.aimAxis,I.Is.exist(t.weight)?t.weight:1,r);r.getConstraint().setConstraint(s)}else if(I.Is.exist(a.rotation)){const t=a.rotation,n=e.extras.rnEntities[o],i=e.extras.rnEntities[t.source],r=h.YY.addComponentToEntity(Xt.J,n),s=new Yt(i,I.Is.exist(t.weight)?t.weight:1,r);r.getConstraint().setConstraint(s)}}}static _readExpressions(e,t){var n,o;const a=[];if(I.Is.not.exist(null===(o=null===(n=e.extensions.VRMC_vrm)||void 0===n?void 0:n.expressions)||void 0===o?void 0:o.preset))return;const i=e.extensions.VRMC_vrm.expressions.preset;for(const t in i){const n=i[t];let o=[];I.Is.exist(n.morphTargetBinds)&&(o=n.morphTargetBinds.map((t=>({entityIdx:e.extras.rnEntities[t.node].entityUID,blendShapeIdx:t.index,weight:t.weight}))));const r={name:t,isBinary:n.isBinary,binds:o};a.push(r)}const r=h.YY.addComponentToEntity(c.r0,t);r.getVrm().setVrmExpressions(a),r.getVrm()._version="1.0"}static _readVRMHumanoidInfo(e,t){const n=e.extensions.VRMC_vrm.humanoid.humanBones,o=new Map;for(const e in n){const t=n[e];o.set(e,t.node)}null!=t&&t.tryToSetTag({tag:"humanoid_map_name_nodeId",value:o})}static _readSpringBone(e){var t,n;const o=[];if(I.Is.exist(null===(t=e.extensions.VRMC_springBone)||void 0===t?void 0:t.colliderGroups))for(const t in e.extensions.VRMC_springBone.colliderGroups){const n=e.extensions.VRMC_springBone.colliderGroups[t],a=new Gt;o.push(a);for(const t of n.colliders){const n=e.extensions.VRMC_springBone.colliders[t],o=e.asset.extras.rnEntities[n.node].getSceneGraph();if(I.Is.exist(n.shape.sphere)){const e=new zt;e.baseSceneGraph=o,e.position=fe.Pq.fromCopyArray([n.shape.sphere.offset[0],n.shape.sphere.offset[1],n.shape.sphere.offset[2]]),e.radius=n.shape.sphere.radius,a.sphereColliders.push(e)}else if(I.Is.exist(n.shape.capsule)){const e=new qt;e.baseSceneGraph=o,e.position=fe.Pq.fromCopyArray([n.shape.capsule.offset[0],n.shape.capsule.offset[1],n.shape.capsule.offset[2]]),e.radius=n.shape.capsule.radius,e.tail=fe.Pq.fromCopyArray([n.shape.capsule.tail[0],n.shape.capsule.tail[1],n.shape.capsule.tail[2]]),a.capsuleColliders.push(e)}}}const a=[];if(I.Is.exist(null===(n=e.extensions.VRMC_springBone)||void 0===n?void 0:n.springs))for(const t of e.extensions.VRMC_springBone.springs){const n=t.joints[0],i=e.asset.extras.rnEntities[n.node],r=new Ot(i.getSceneGraph());r.tryToSetUniqueName(t.name,!0);const s=I.Is.exist(t.colliderGroups)?t.colliderGroups:[];r.colliderGroups=s.map((e=>o[e]));const l=[];for(const n in t.joints){const o=t.joints[n],a=e.asset.extras.rnEntities[o.node],i=new Wt(a);i.dragForce=o.dragForce,i.stiffnessForce=o.stiffness,i.gravityPower=I.Is.exist(o.gravityPower)?o.gravityPower:1,i.gravityDir=I.Is.exist(o.gravityDir)?fe.Pq.fromCopyArray3([o.gravityDir[0],o.gravityDir[1],o.gravityDir[2]]):fe.Pq.fromCopyArray3([0,-1,0]),i.hitRadius=o.hitRadius,r.bones.push(i),l.push(a)}null!=t.center&&-1!==t.center&&(r.center=e.asset.extras.rnEntities[t.center].getSceneGraph()),this.__addSpringBoneRecursively(r,i,l),a.push(r)}for(const e of a)this.__addPhysicsComponent(e,e.rootBone)}static __addSpringBoneRecursively(e,t,n){const o=t.getSceneGraph().children;if(!n.includes(t)){const o=new Wt(t);e.bones.push(o),n.push(t)}for(const t of o)this.__addSpringBoneRecursively(e,t.entity,n)}static __addPhysicsComponent(e,t){const n=t.entity,o=h.YY.addComponentToEntity(lt.l,n).getPhysics(),a=new Vt;a.setSpring(e),o.setStrategy(a)}static _createTextures(e){e.textures||(e.textures=[]);const t=e.textures,n=[];for(let o=0;o<t.length;o++){const a=gt.w._createTexture(t[o],e);n[o]=a}const o=new Ke.g;o.generate1x1TextureFrom(),n.push(o);const a=new Ke.g;return a.generate1x1TextureFrom("rgba(0, 0, 0, 1)"),n.push(a),n}static _createSamplers(e){e.textures||(e.textures=[]);const t=e.textures,n=[];for(let e=0;e<t.length;e++){const o=gt.w._createSampler(t[e]);n[e]=o}const o=new Fe.L({wrapS:Me.P.ClampToEdge,wrapT:Me.P.ClampToEdge,minFilter:Me.P.Linear,magFilter:Me.P.Linear});return o.create(),n.push(o),n.push(o),n}static __initializeMToonMaterialProperties(e,t){var n;let o=!1;for(const t of e.materials){const e=null===(n=t.extensions)||void 0===n?void 0:n.VRMC_materials_mtoon;null!=e&&(I.Is.not.exist(t.extras)&&(t.extras={}),"none"!==e.outlineWidthMode&&(o=!0))}return o}static _getOptions(e){if(null!=e){for(const t in e.files){const n=t.split(".vrm")[0];if(n){const o=e.files[t];e.files[n+".glb"]=o,delete e.files[t]}}e.__isImportVRM0x=!0,null==e.defaultMaterialHelperArgumentArray&&(e.defaultMaterialHelperArgumentArray=[{}]),e.defaultMaterialHelperArgumentArray[0].isMorphing||(e.maxMorphTargetNumber=0)}else e={files:{},loaderExtension:void 0,defaultMaterialHelperName:void 0,defaultMaterialHelperArgumentArray:[{isLighting:!0,isMorphing:!0,isSkinning:!0}],statesOfElements:[{targets:[],states:{enable:[],functions:{}},isTransparent:!0,opacity:1,isTextureImageToLoadPreMultipliedAlpha:!1}],__isImportVRM0x:!0,__importedType:"vrm1"};return e}static async importJsonOfVRM(e,t){t=this._getOptions(t);const n=await Mt.a.importFromUri(e,t);if(n.isErr())return new wt._({message:"Failed to import VRM file.",error:n});(0,wt.j3)(n);const o=n.get();return Kt._readVRMHumanoidInfo(o),new wt.Ok(o)}}class Zt{constructor(){}static async importFromUri(e,t,n){var o;const a=(null===(o=(t=this.__initOptions(t)).expression)||void 0===o?void 0:o.renderPasses)||[];0===a.length&&a.push(new De.A);const i=await S.$.fetchArrayBuffer(e);if(i.isErr())return new wt._({message:"Failed to fetch array buffer",error:i});if(t.files[e]=i.get(),await this.__detectTheModelFileTypeAndImport(e,a,t,e,n),t&&t.cameraComponent)for(const e of a)e.cameraComponent=t.cameraComponent;const r=this.__setRenderPassesToExpression(a,t);return new wt.Ok(r)}static async importFromArrayBuffers(e,t,n){var o;const a=(null===(o=(t=this.__initOptions(t)).expression)||void 0===o?void 0:o.renderPasses)||[];0===a.length&&a.push(new De.A);for(const o in e){const e=S.$.getExtension(o);this.__isValidExtension(e)&&await this.__detectTheModelFileTypeAndImport(o,a,t,o,n)}if(t&&t.cameraComponent)for(const e of a)e.cameraComponent=t.cameraComponent;const i=this.__setRenderPassesToExpression(a,t);return new wt.Ok(i)}static __initOptions(e){if(null==e)e=S.$.createDefaultGltfOptions();else{null==e.files&&(e.files={});for(const t in e.files){if(null==t.match(/.*\.vrm$/))continue;const n=t.split(".vrm")[0];if(n){const o=e.files[t];e.files[n+".glb"]=o,delete e.files[t]}}!1===Array.isArray(e.defaultMaterialHelperArgumentArray)?e.defaultMaterialHelperArgumentArray=[{}]:!1===e.defaultMaterialHelperArgumentArray[0].isMorphing&&(e.maxMorphTargetNumber=0)}return e}static __setRenderPassesToExpression(e,t){var n;const o=null!==(n=t.expression)&&void 0!==n?n:new ot.r;return o.renderPasses!==e&&(o.clearRenderPasses(),o.addRenderPasses(e)),o}static __isValidExtension(e){return"gltf"===e||"glb"===e||"vrm"===e||"drc"===e}static __isGlb(e){return 1179937895===new DataView(e,0,20).getUint32(0,!0)}static __getGlbVersion(e){return new DataView(e,0,20).getUint32(4,!0)}static __getGltfVersion(e){var t,n;return"2"===(null===(n=null===(t=e.asset)||void 0===t?void 0:t.version)||void 0===n?void 0:n.charAt(0))?2:1}static async __detectTheModelFileTypeAndImport(e,t,n,o,a){const i=n.fileType,r=this.__getFileTypeFromFilePromise(e,n,i),s=n.files[e];n.__isImportVRM0x=!1;let l=0;switch(r){case Rt.p.Gltf:{const o=S.$.arrayBufferToString(s),i=JSON.parse(o);l=this.__getGltfVersion(i);const r=Mt.a,c=await r._importGltf(i,n.files,n,e,a),_=gt.w.convertToRhodoniteObject(c);return t[0].addEntities([_]),n.__importedType="gltf2",new wt.Ok}case Rt.p.GltfBinary:{l=this.__getGlbVersion(s);const e=Mt.a,o=await e._importGlb(s,n.files,n),a=gt.w.convertToRhodoniteObject(o);return t[0].addEntities([a]),n.__importedType="glb2",new wt.Ok}case Rt.p.Draco:{const e=Ct.getInstance(),a=await e.importArrayBuffer(o,s,n);if(null==a)return new wt._({message:"importArrayBuffer error is occurred",error:void 0});{n.__importedType="draco";const e=gt.w.convertToRhodoniteObject(a);return t[0].addEntities([e]),new wt.Ok}}case Rt.p.VRM:{n.__isImportVRM0x=!0;const e=await Mt.a._importGltfOrGlbFromArrayBuffers(s,n.files,n);if(e.isOk()){const o=e.get();return o.extensionsUsed.indexOf("VRMC_vrm")>=0?(n.__isImportVRM0x=!1,o.asset.extras.rnLoaderOptions.__isImportVRM0x=!1,n.__importedType="vrm1",await Kt.__importVRM(o,t)):o.extensionsUsed.indexOf("VRM")>=0&&(n.__importedType="vrm0x",await Qt.__importVRM0x(o,t)),new wt.Ok}return(0,wt.ou)(e),new wt._({message:e.getRnError().message,error:void 0})}default:return new wt._({message:"detect invalid format",error:void 0})}}static __getFileTypeFromFilePromise(e,t,n){return null!=n?Rt.p.fromString(n):Pt({[e]:t.files[e]})}}var Jt=o(2345);class $t{static async importFromUri(e){const t=await Mt.a.importFromUri(e,{});if(t.isErr())return new wt._({message:"Failed to import VRM file.",error:t});(0,wt.j3)(t);const n=t.get();return this.readHumanoid(n),new wt.Ok(n)}static async importFromArrayBuffer(e){const t=await Mt.a.importFromArrayBuffers({"data.glb":e},{});if(t.isErr())return new wt._({message:"Failed to import VRM file.",error:t});(0,wt.j3)(t);const n=t.get();return this.readHumanoid(n),new wt.Ok(n)}static readHumanoid(e){var t;const n=null===(t=e.extensions.VRMC_vrm_animation.humanoid)||void 0===t?void 0:t.humanBones;if(I.Is.not.exist(n))return;const o=new Map;e.extensions.VRMC_vrm_animation.humanoidBoneNameMap=o;for(const e in n){const t=n[e];o.set(t.node,e)}}}var en=o(1255),tn=o(7014),nn=o(8374),on=o(7488),an=o(4132),rn=o(4876);class sn extends rn.q{constructor(e,t,n){super(),this.__functionName=e,this.__compositionType=t,this.__componentType=n,this.__constantValueStr=""}setConstantValue(e){let t="";this.__componentType.isFloatingPoint()?t=e.glslStrAsFloat:this.__componentType.isInteger()?t=e.glslStrAsInt:this.__componentType===E.I.Bool&&(t=e.x?"true":"false"),this.__constantValueStr=t}get vertexShaderDefinitions(){return ke.l.currentProcessApproach===We.m.WebGPU?`\n      fn ${this.__functionName}(\n        outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {\n        *outValue = ${this.__constantValueStr};\n      }\n      `:`\n      void ${this.__functionName}(\n        out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {\n        outValue = ${this.__constantValueStr};\n      }\n      `}get pixelShaderDefinitions(){return ke.l.currentProcessApproach===We.m.WebGPU?`\n      fn ${this.__functionName}(\n        outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {\n        *outValue = ${this.__constantValueStr};\n      }\n      `:`\n      void ${this.__functionName}(\n        out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {\n        outValue = ${this.__constantValueStr};\n      }\n      `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}class ln{constructor(e,t,n){this.name=e,this.compositionType=t,this.componentType=n}}class cn extends tn.Q{constructor(e,t,n){super(e,{}),this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new sn(this.__shaderFunctionName,t,n),this.__outputs.push(new ln("outValue",t,n))}setDefaultInputValue(e){this.__commonPart.setConstantValue(e)}getSocketOutput(){return this.__outputs[0]}}class _n extends cn{constructor(e){super("ConstantScalar",x.hY.Scalar,e)}setDefaultInputValue(e){this.__commonPart.setConstantValue(e)}}var un=o(9011);class fn extends cn{constructor(e){super("ConstantVector2",x.hY.Vec2,e)}setDefaultInputValue(e){this.__commonPart.setConstantValue(e)}}class dn extends cn{constructor(e){super("ConstantVector3",x.hY.Vec3,e)}setDefaultInputValue(e){this.__commonPart.setConstantValue(e)}}class hn extends cn{constructor(e){super("ConstantVector4",x.hY.Vec4,e)}setDefaultInputValue(e){this.__commonPart.setConstantValue(e)}}class mn extends rn.q{constructor(e,t,n){super(),this.__functionName=e,this.__compositionType=t,this.__componentType=n,this.__variableName="",this.__valueStr=""}setVariableName(e){this.__variableName=e}setDefaultValue(e){this.__valueStr=e.toString()}get vertexShaderDefinitions(){return ke.l.currentProcessApproach===We.m.WebGPU?`\n// #param ${this.__variableName}: ${this.__compositionType.toWGSLType(this.__componentType)}; // initialValue=${this.__valueStr}\nfn ${this.__functionName}(outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {\n  *outValue = get_${this.__variableName}(_materialSID, 0);\n}\n`:`\nuniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}\nvoid ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {\n  #ifdef RN_IS_DATATEXTURE_MODE\n    float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n  #else\n    float materialSID = u_materialSID;\n  #endif\n\n  outValue = get_${this.__variableName}(materialSID, 0);\n}\n`}get pixelShaderDefinitions(){return ke.l.currentProcessApproach===We.m.WebGPU?`\n// #param ${this.__variableName}: ${this.__compositionType.toWGSLType(this.__componentType)}; // initialValue=${this.__valueStr}\nfn ${this.__functionName}(outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {\n  *outValue = get_${this.__variableName}(_materialSID, 0);\n}\n`:`\nuniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}\nvoid ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n#else\n  float materialSID = u_materialSID;\n#endif\n\noutValue = get_${this.__variableName}(materialSID, 0);\n    }\n    `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}class pn extends tn.Q{constructor(e,t){super("uniformData",{}),this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new mn(this.__shaderFunctionName,e,t),this.__outputs.push(new ln("outValue",e,t))}setDefaultInputValue(e,t){"value"===e&&this.__commonPart.setDefaultValue(t)}setUniformDataName(e){this.__commonPart.setVariableName(e)}}class vn extends tn.Q{constructor(e,t){super("add",{codeGLSL:"\nvoid add(in float lfs, in float rhs, out float outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in int lfs, in int rhs, out int outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs + rhs;\n}\n",codeWGSL:"\nfn addF32F32(lfs: f32, rhs: f32, outValue: ptr<function, f32>) {\n  *outValue = lfs + rhs;\n}\nfn addI32I32(lfs: i32, rhs: i32, outValue: ptr<function, i32>) {\n  *outValue = lfs + rhs;\n}\nfn addVec2fVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = lfs + rhs;\n}\nfn addVec3fVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = lfs + rhs;\n}\nfn addVec4fVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = lfs + rhs;\n}\n"}),this.__inputs.push(new ln("lhs",e,t)),this.__inputs.push(new ln("rhs",e,t)),this.__outputs.push(new ln("outValue",e,t))}getSocketInputLhs(){return this.__inputs[0]}getSocketInputRhs(){return this.__inputs[1]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Scalar&&this.__inputs[1].compositionType===w.h.Scalar){if(this.__inputs[0].componentType===E.I.Float&&this.__inputs[1].componentType===E.I.Float)return this.__shaderFunctionName+"F32F32";if(this.__inputs[0].componentType===E.I.Int&&this.__inputs[1].componentType===E.I.Int)return this.__shaderFunctionName+"I32I32";throw new Error("Not implemented")}if(this.__inputs[0].compositionType===w.h.Vec2&&this.__inputs[1].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2fVec2f";if(this.__inputs[0].compositionType===w.h.Vec3&&this.__inputs[1].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3fVec3f";if(this.__inputs[0].compositionType===w.h.Vec4&&this.__inputs[1].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4fVec4f";throw new Error("Not implemented")}return this.__shaderFunctionName}}class xn extends tn.Q{constructor(e,t){super("_normalize",{codeGLSL:"\nvoid _normalize(in vec2 value, out vec2 outValue) {\n  outValue = normalize(value);\n}\n\nvoid _normalize(in vec3 value, out vec3 outValue) {\n  outValue = normalize(value);\n}\n\nvoid _normalize(in vec4 value, out vec4 outValue) {\n  outValue = normalize(value);\n}\n",codeWGSL:"\nfn _normalizeVec2f(value: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = normalize(value);\n}\n\nfn _normalizeVec3f(value: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = normalize(value);\n}\n\nfn _normalizeVec4f(value: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = normalize(value);\n}\n"}),this.__inputs.push({compositionType:e,componentType:t,name:"value"}),this.__outputs.push({compositionType:e,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not supported composition type.")}return this.__shaderFunctionName}}class gn extends tn.Q{constructor(e,t){super("dotProduct",{codeGLSL:"\nvoid dotProduct(in vec2 lfs, in vec2 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\nvoid dotProduct(in vec3 lfs, in vec3 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\nvoid dotProduct(in vec4 lfs, in vec4 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\n",codeWGSL:"fn dotProductVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, f32>) {\n  *outValue = dot(lfs, rhs);\n}\nfn dotProductVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, f32>) {\n  *outValue = dot(lfs, rhs);\n}\nfn dotProductVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, f32>) {\n  *outValue = dot(lfs, rhs);\n}\n"}),this.__inputs.push({compositionType:e,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:e,componentType:E.I.Float,name:"rhs"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not supported composition type.")}return this.__shaderFunctionName}}class yn extends tn.Q{constructor(e,t){super("multiply",{codeGLSL:"\nvoid multiply(in float lfs, in float rhs, out float outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in int lfs, in int rhs, out int outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in vec2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in vec3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in vec4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat2 lfs, in mat2 rhs, out mat2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat3 lfs, in mat3 rhs, out mat3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat4 lfs, in mat4 rhs, out mat4 outValue) {\n  outValue = lfs * rhs;\n}\n",codeWGSL:"fn multiplyF32F32(lfs: f32, rhs: f32, outValue: ptr<function, f32>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyI32I32(lfs: i32, rhs: i32, outValue: ptr<function, i32>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyVec2fVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyVec3fVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyVec4fVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyMat2x2fMat2x2f(lfs: mat2x2<f32>, rhs: mat2x2<f32>, outValue: ptr<function, mat2x2<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyMat3x3fMat3x3f(lfs: mat3x3<f32>, rhs: mat3x3<f32>, outValue: ptr<function, mat3x3<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyMat4x4fMat4x4f(lfs: mat4x4<f32>, rhs: mat4x4<f32>, outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = lfs * rhs;\n}\n"}),this.__inputs.push({compositionType:e,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:e,componentType:t,name:"rhs"}),this.__outputs.push({compositionType:e,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Scalar&&this.__inputs[1].compositionType===w.h.Scalar){if(this.__inputs[0].componentType===E.I.Float&&this.__inputs[1].componentType===E.I.Float)return this.__shaderFunctionName+"F32F32";if(this.__inputs[0].componentType===E.I.Int&&this.__inputs[1].componentType===E.I.Int)return this.__shaderFunctionName+"I32I32";throw new Error("Not implemented")}if(this.__inputs[0].compositionType===w.h.Vec2&&this.__inputs[1].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2fVec2f";if(this.__inputs[0].compositionType===w.h.Vec3&&this.__inputs[1].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3fVec3f";if(this.__inputs[0].compositionType===w.h.Vec4&&this.__inputs[1].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4fVec4f";if(this.__inputs[0].compositionType===w.h.Mat2&&this.__inputs[1].compositionType===w.h.Mat2)return this.__shaderFunctionName+"Mat2x2fMat2x2f";if(this.__inputs[0].compositionType===w.h.Mat3&&this.__inputs[1].compositionType===w.h.Mat3)return this.__shaderFunctionName+"Mat3x3fMat3x3f";if(this.__inputs[0].compositionType===w.h.Mat4&&this.__inputs[1].compositionType===w.h.Mat4)return this.__shaderFunctionName+"Mat4x4fMat4x4f";throw new Error("Not implemented")}return this.__shaderFunctionName}}class bn extends tn.Q{constructor(){super("attributeColor",{codeGLSL:"\nin vec4 a_color_0;\n\nvoid attributeColor(out vec4 outValue) {\n  outValue = a_color_0;\n}\n",codeWGSL:"fn attributeColor(outValue: ptr<function, vec4<f32>>) {\n  *outValue = a_color_0;\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Vec4,componentType:E.I.Float,name:"outValue"})}}class In extends tn.Q{constructor(){super("attributeNormal",{codeGLSL:"\nin vec3 a_normal;\n\nvoid attributeNormal(out vec3 outValue) {\n  outValue = a_normal;\n}\n",codeWGSL:"fn attributeNormal(outValue: ptr<function, vec3<f32>>) {\n  *outValue = a_normal;\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Vec3,componentType:E.I.Float,name:"outValue"})}}class An extends tn.Q{constructor(){super("attributePosition",{codeGLSL:"\nin vec4 a_position;\n\nvoid attributePosition(out vec4 outValue) {\n  outValue = a_position;\n}\n",codeWGSL:"fn attributePosition(outValue: ptr<function, vec4f>) {\n  *outValue = vec4f(a_position, 1.0);\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push(new ln("outValue",w.h.Vec4,E.I.Float))}getSocketOutput(){return this.__outputs[0]}}class En extends tn.Q{constructor(){super("attributeTexcoord",{codeGLSL:"\nin vec2 a_texcoord_0;\n\nvoid attributeTexcoord(out vec2 outValue) {\n  outValue = a_texcoord_0;\n}\n",codeWGSL:"\nfn attributeTexcoord(outValue: ptr<function, vec2<f32>>) {\n  *outValue = a_texcoord_0;\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Vec3,componentType:E.I.Float,name:"outValue"})}}class Sn extends tn.Q{constructor(){super("worldMatrix",{codeGLSL:"\nvoid worldMatrix(out mat4 outValue) {\n  outValue = get_worldMatrix(a_instanceInfo.x);\n}\n",codeWGSL:"\nfn worldMatrix(outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = get_worldMatrix(u32(a_instanceIds.x));\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Mat4,componentType:E.I.Float,name:"outValue"})}}class Tn extends tn.Q{constructor(){super("viewMatrix",{codeGLSL:"\nvoid viewMatrix(out mat4 outValue) {\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID}*/];\n  outValue = get_viewMatrix(cameraSID, 0);\n}\n",codeWGSL:"\nfn viewMatrix(outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = get_viewMatrix(_cameraSID, 0);\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Mat4,componentType:E.I.Float,name:"outValue"})}}class wn extends tn.Q{constructor(){super("projectionMatrix",{codeGLSL:"\nvoid projectionMatrix(out mat4 outValue) {\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID}*/];\n  outValue = get_projectionMatrix(cameraSID, 0);\n}\n",codeWGSL:"\nfn projectionMatrix(outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = get_projectionMatrix(_cameraSID, 0);\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Mat4,componentType:E.I.Float,name:"outValue"})}}class Cn extends tn.Q{constructor(){super("normalMatrix",{codeGLSL:"\nvoid normalMatrix(out mat3 outValue) {\n  outValue = get_normalMatrix(a_instanceInfo.x);\n}\n",codeWGSL:"\nfn normalMatrix(outValue: ptr<function, mat3x3<f32>>) {\n  *outValue = get_normalMatrix(u32(a_instanceIds.x));\n}\n"}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:w.h.Mat3,componentType:E.I.Float,name:"outValue"})}}class Pn extends tn.Q{constructor(e,t){super("greater",{codeGLSL:"\nvoid greater(in float lhs, in float rhs, out bool outValue) {\n  outValue = lhs > rhs;\n}\n\nvoid greater(in int lhs, in int rhs, out bool outValue) {\n  outValue = lhs > rhs;\n}\n"}),this.__inputs.push({compositionType:e,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:e,componentType:E.I.Float,name:"rhs"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:E.I.Bool,name:"outValue"})}}var Nn=o(9156);class Mn extends rn.q{constructor(){super()}static getInstance(){return this.__instance||(this.__instance=new Mn),this.__instance}get vertexShaderDefinitions(){return ke.l.currentProcessApproach===We.m.WebGPU?"\n      fn outPosition(inPosition: vec4<f32>) {\n        output.position = inPosition;\n      }\n      ":"\n      void outPosition(in vec4 inPosition) {\n        gl_Position = inPosition;\n      }\n      "}get vertexShaderBody(){return"\n\n    "}get pixelShaderDefinitions(){return ke.l.currentProcessApproach===We.m.WebGPU?"\n      fn outColor(inColor: vec4<f32>) {\n        rt0 = inColor;\n      }\n      ":"\n      void outColor(in vec4 inColor) {\n        rt0 = inColor;\n      }\n      "}getPixelShaderBody(){return""}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}Mn.materialElement=Nn.m.PBRShading;class Dn extends tn.Q{constructor(){super("outPosition",{commonPart:Mn.getInstance()}),this.__inputs.push(new ln("value",w.h.Vec4,E.I.Float))}getSocketInput(){return this.__inputs[0]}}class Fn extends tn.Q{constructor(){super("outColor",{commonPart:Mn.getInstance()}),this.setShaderStage("Fragment"),this.__inputs.push(new ln("value",w.h.Vec4,E.I.Float))}getSocketInput(){return this.__inputs[0]}}var Bn=o(8592);class Ln extends tn.Q{constructor(e,t,n,o){super("transform",{codeGLSL:"void transform(in mat2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid transform(in mat3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid transform(in mat4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs * rhs;\n}\n",codeWGSL:"fn transformMat2x2fVec2f(lfs: mat2x2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn transformMat3x3fVec3f(lfs: mat3x3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn transformMat4x4fVec4f(lfs: mat4x4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = lfs * rhs;\n}\n"});let a=w.h.Unknown;e===w.h.Mat4&&n===w.h.Vec4?a=w.h.Vec4:e===w.h.Mat3&&n===w.h.Vec3?a=w.h.Vec3:e===w.h.Mat2&&n===w.h.Vec2&&(a=w.h.Vec2),this.__inputs.push({compositionType:e,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:n,componentType:o,name:"rhs"}),this.__outputs.push({compositionType:a,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Mat2&&this.__inputs[1].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Mat2x2fVec2f";if(this.__inputs[0].compositionType===w.h.Mat3&&this.__inputs[1].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Mat3x3fVec3f";if(this.__inputs[0].compositionType===w.h.Mat4&&this.__inputs[1].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Mat4x4fVec4f";throw new Error("Not implemented")}return this.__shaderFunctionName}}class Vn extends rn.q{constructor(e,t,n){super(),this.__functionName=e,this.__valueInputs=t,this.__valueOutputs=n}get vertexShaderDefinitions(){let e=`void ${this.__functionName}(\nin bool context,\n      `;for(let t=0;t<this.__valueInputs.length;t++){const n=this.__valueInputs[t];e+=`\n        in ${n.compositionType.getGlslStr(n.componentType)} value${t},`}for(let t=0;t<this.__valueOutputs.length;t++){const n=this.__valueOutputs[t];e+=`\n        out ${n.compositionType.getGlslStr(n.componentType)} outValue${t}`+(t===this.__valueOutputs.length-1?"":",")}e+=") {\n";for(let t=0;t<this.__valueOutputs.length;t++)e+=`\n      outValue${t} = value${t};\n`;return e+="}",e}get pixelShaderDefinitions(){return this.vertexShaderDefinitions}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}class zn extends tn.Q{constructor(){super("blockBegin",{}),this.__valueInputs=[],this.__valueOutputs=[],this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new Vn(this.__shaderFunctionName,this.__valueInputs,this.__valueOutputs),this.__inputs.push({compositionType:w.h.Scalar,componentType:E.I.Bool,name:"blockStart"})}addInputAndOutput(e,t){const n={compositionType:e,componentType:t,name:`value_${this.__valueInputs.length}`},o={compositionType:e,componentType:t,name:`outValue_${this.__valueOutputs.length}`};this.__inputs.push(n),this.__outputs.push(o),this.__valueInputs.push(n),this.__valueOutputs.push(o)}}class Gn extends rn.q{constructor(e,t,n){super(),this.__functionName=e,this.__valueInputs=t,this.__valueOutputs=n}get vertexShaderDefinitions(){let e=`void ${this.__functionName}(`;for(let t=0;t<this.__valueInputs.length;t++){const n=this.__valueInputs[t];e+=`\n        in ${n.compositionType.getGlslStr(n.componentType)} value${t},`}for(let t=0;t<this.__valueOutputs.length;t++){const n=this.__valueOutputs[t];e+=`\n        out ${n.compositionType.getGlslStr(n.componentType)} outValue${t}`+(t===this.__valueOutputs.length-1?"":",")}e+=") {\n";for(let t=0;t<this.__valueOutputs.length;t++)e+=`\n      outValue${t} = value${t};\n`;return e+="}",e}get pixelShaderDefinitions(){return this.vertexShaderDefinitions}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}class On extends tn.Q{constructor(){super("blockEnd",{}),this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new Gn(this.__shaderFunctionName,this.__inputs,this.__outputs)}addInputAndOutput(e,t){const n={compositionType:e,componentType:t,name:`value_${this.__inputs.length}`},o={compositionType:e,componentType:t,name:`outValue_${this.__outputs.length}`};this.__inputs.push(n),this.__outputs.push(o)}}class Un extends rn.q{constructor(){super()}get vertexShaderDefinitions(){return"\n    "}get pixelShaderDefinitions(){return"\n    "}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}class kn extends tn.Q{constructor(){super("ifStatement",{commonPart:new Un}),this.__inputs.push({compositionType:w.h.Scalar,componentType:E.I.Bool,name:"condition"}),this.__outputs.push({compositionType:w.h.Unknown,componentType:E.I.Unknown,name:"ifStart"})}}class Wn extends tn.Q{constructor(){super("wireframe",{codeGLSL:"bool wireframe(\n  in vec4 existingFragColor,\n  in vec4 wireframeColor,\n  out vec4 outColor\n) {\n  vec3 wireframeInfo = get_wireframe(a_instanceInfo.x);\n\n  // Wireframe\n  float threshold = 0.001;\n  float wireframeWidthInner = wireframeInfo.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframeInfo.x > 0.5 && wireframeInfo.y < 0.5) {\n    outColor.a = 0.0;\n  }\n  vec4 wireframeResult = existingFragColor;\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + existingFragColor.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(existingFragColor.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframeInfo.x > 0.5) {\n    outColor = wireframeResult;\n    if (wireframeInfo.y < 0.5 && existingFragColor.a == 0.0) {\n      discard;\n    }\n  }\n}\n"}),this.__inputs.push({compositionType:w.h.Vec4,componentType:E.I.Float,name:"existingFragColor"}),this.__inputs.push({compositionType:w.h.Vec4,componentType:E.I.Float,name:"wireframeColor"}),this.__outputs.push({compositionType:w.h.Vec4,componentType:E.I.Float,name:"outColor"})}}class Qn extends tn.Q{constructor(){super("splitVector",{codeGLSL:"void splitVector(in vec4 xyzw, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {\n  outX = xyzw.x;\n  outY = xyzw.y;\n  outZ = xyzw.z;\n  outW = xyzw.w;\n  outXYZ = xyzw.xyz;\n  outXY = xyzw.xy;\n  outZW = xyzw.zw;\n}\n\nvoid splitVector(in vec3 xyz, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {\n  outX = xyz.x;\n  outY = xyz.y;\n  outZ = xyz.z;\n  outW = 0.0;\n  outXYZ = xyz;\n  outXY = xyz.xy;\n  outZW = vec2(xyz.z, 0.0);\n}\n\nvoid splitVector(in vec2 xy, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {\n  outX = xy.x;\n  outY = xy.y;\n  outZ = 0.0;\n  outW = 0.0;\n  outXYZ = vec3(xy, 0.0);\n  outXY = xy;\n  outZW = vec2(0.0);\n}\n",codeWGSL:"fn splitVectorXYZW(xyzw: vec4<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {\n  *outX = xyzw.x;\n  *outY = xyzw.y;\n  *outZ = xyzw.z;\n  *outW = xyzw.w;\n  *outXYZ = xyzw.xyz;\n  *outXY = xyzw.xy;\n  *outZW = xyzw.zw;\n}\n\nfn splitVectorXYZ(xyz: vec3<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {\n  *outX = xyz.x;\n  *outY = xyz.y;\n  *outZ = xyz.z;\n  *outW = 0.0;\n  *outXYZ = xyz;\n  *outXY = xyz.xy;\n  *outZW = vec2(xyz.z, 0.0);\n}\n\nfn splitVectorXY(xy: vec2<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {\n  *outX = xy.x;\n  *outY = xy.y;\n  *outZ = 0.0;\n  *outW = 0.0;\n  *outXYZ = vec3(xy, 0.0);\n  *outXY = xy;\n  *outZW = vec2(0.0);\n}\n"}),this.__inputs.push({compositionType:w.h.Vec4,componentType:E.I.Float,name:"xyzw"}),this.__inputs.push({compositionType:w.h.Vec3,componentType:E.I.Float,name:"xyz"}),this.__inputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"xy"}),this.__outputs.push({compositionType:w.h.Vec3,componentType:E.I.Float,name:"xyz"}),this.__outputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"xy"}),this.__outputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"zw"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"x"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"y"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"z"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"w"})}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){for(const e of this.inputConnections)if(null!=e){if("xyzw"===e.inputNameOfThis)return this.__shaderFunctionName+"XYZW";if("xyz"===e.inputNameOfThis)return this.__shaderFunctionName+"XYZ";if("xy"===e.inputNameOfThis)return this.__shaderFunctionName+"XY"}throw new Error("Not implemented")}return this.__shaderFunctionName}makeCallStatement(e,t,n,o,a){let i="",r="";if(o[e].length>0&&a[e].length>0){const t=ke.l.currentProcessApproach===We.m.WebGPU?[`var dummyXYZ_${e}: vec3<f32>;`,`var dummyXY_${e}: vec2<f32>;`,`var dummyZW_${e}: vec2<f32>;`,`var dummyX_${e}: f32;`,`var dummyY_${e}: f32;`,`var dummyZ_${e}: f32;`,`var dummyW_${e}: f32;`]:[`vec3 dummyXYZ_${e};`,`vec2 dummyXY_${e};`,`vec2 dummyZW_${e};`,`float dummyX_${e};`,`float dummyY_${e};`,`float dummyZ_${e};`,`float dummyW_${e};`],i=[`dummyXYZ_${e}`,`dummyXY_${e}`,`dummyZW_${e}`,`dummyX_${e}`,`dummyY_${e}`,`dummyZ_${e}`,`dummyW_${e}`];for(let n=0;n<a[e].length;n++){const o=a[e][n];o.indexOf("xyz")>=0?(t[0]="",i[0]=o):o.indexOf("xy")>=0?(t[1]="",i[1]=o):o.indexOf("zw")>=0?(t[2]="",i[2]=o):o.indexOf("x")>=0?(t[3]="",i[3]=o):o.indexOf("y")>=0?(t[4]="",i[4]=o):o.indexOf("z")>=0?(t[5]="",i[5]=o):o.indexOf("w")>=0&&(t[6]="",i[6]=o)}if(ke.l.currentProcessApproach===We.m.WebGPU)for(let e=0;e<i.length;e++)i[e]="&"+i[e];r+=t.join("\n"),r+=`${n}(`,r+=o[e][0],r+=", "+i.join(", "),r+=");\n"}return i+=r,i}}class qn extends tn.Q{constructor(){super("mergeVector",{codeGLSL:"void mergeVectorXYZ_W(in vec3 xyz, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = xyz.x;\n  outXYZW.y = xyz.y;\n  outXYZW.z = xyz.z;\n  outXYZW.w = w;\n  outXYZ = xyz;\n  outXY = xyz.xy;\n  outZW = vec2(xyz.z, w);\n}\n\nvoid mergeVectorXY_ZW(in vec2 xy, in vec2 zw, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = xy.x;\n  outXYZW.y = xy.y;\n  outXYZW.z = zw.x;\n  outXYZW.w = zw.y;\n  outXYZ = vec3(xy, zw.x);\n  outXY = xy;\n  outZW = zw;\n}\n\nvoid mergeVectorXY_Z_W(in vec2 xy, in float z, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = xy.x;\n  outXYZW.y = xy.y;\n  outXYZW.z = z;\n  outXYZW.w = w;\n  outXYZ = vec3(xy, z);\n  outXY = xy;\n  outZW = vec2(z, w);\n}\n\nvoid mergeVectorZW_X_Y(in vec2 zw, in float x, in float y, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = x;\n  outXYZW.y = y;\n  outXYZW.z = zw.x;\n  outXYZW.w = zw.y;\n  outXYZ = vec3(x, y, zw.x);\n  outXY = vec2(x, y);\n  outZW = zw;\n}\n\nvoid mergeVectorX_Y_Z_W(in float x, in float y, in float z, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = x;\n  outXYZW.y = y;\n  outXYZW.z = z;\n  outXYZW.w = w;\n  outXYZ = vec3(x, y, z);\n  outXY = vec2(x, y);\n  outZW = vec2(z, w);\n}\n",codeWGSL:"fn mergeVectorXYZ_W(xyz: vec3<f32>, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(xyz, w);\n  *outXYZ = xyz;\n  *outXY = xyz.xy;\n  *outZW = vec2f(xyz.z, w);\n}\n\nfn mergeVectorXY_ZW(xy: vec2<f32>, zw: vec2<f32>, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(xy, zw);\n  *outXYZ = vec3f(xy, zw.x);\n  *outXY = xy;\n  *outZW = zw;\n}\n\nfn mergeVectorXY_Z_W(xy: vec2<f32>, z: f32, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(xy.x, xy.y, z, w);\n  *outXYZ = vec3f(xy, z);\n  *outXY = xy;\n  *outZW = vec2f(z, w);\n}\n\nfn mergeVectorZW_X_Y(zw: vec2<f32>, x: f32, y: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(x, y, zw.x, zw.y);\n  *outXYZ = vec3f(x, y, zw.x);\n  *outXY = vec2f(x, y);\n  *outZW = zw;\n}\n\nfn mergeVectorX_Y_Z_W(x: f32, y: f32, z: f32, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(x, y, z, w);\n  *outXYZ = vec3f(x, y, z);\n  *outXY = vec2f(x, y);\n  *outZW = vec2f(z, w);\n}\n"}),this.__inputs.push({compositionType:w.h.Vec3,componentType:E.I.Float,name:"xyz"}),this.__inputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"xy"}),this.__inputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"zw"}),this.__inputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"x"}),this.__inputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"y"}),this.__inputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"z"}),this.__inputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"w"}),this.__outputs.push({compositionType:w.h.Vec4,componentType:E.I.Float,name:"xyzw"}),this.__outputs.push({compositionType:w.h.Vec3,componentType:E.I.Float,name:"xyz"}),this.__outputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"xy"}),this.__outputs.push({compositionType:w.h.Vec2,componentType:E.I.Float,name:"zw"})}getShaderFunctionNameDerivative(){if(null!=this.inputConnections[0]&&null!=this.inputConnections[6])return this.__shaderFunctionName+"XYZ_W";if(null!=this.inputConnections[1]&&null!=this.inputConnections[2])return this.__shaderFunctionName+"XY_ZW";if(null!=this.inputConnections[1]&&null!=this.inputConnections[5]&&null!=this.inputConnections[6])return this.__shaderFunctionName+"XY_Z_W";if(null!=this.inputConnections[2]&&null!=this.inputConnections[3]&&null!=this.inputConnections[4])return this.__shaderFunctionName+"ZW_X_Y";if(null!=this.inputConnections[3]&&null!=this.inputConnections[4]&&null!=this.inputConnections[5]&&null!=this.inputConnections[6])return this.__shaderFunctionName+"X_Y_Z_W";throw new Error("Not implemented")}makeCallStatement(e,t,n,o,a){let i="",r="";if(o[e].length>0&&a[e].length>0){const t=ke.l.currentProcessApproach===We.m.WebGPU?[`var dummyXYZW_${e}: vec4<f32>;`,`var dummyXYZ_${e}: vec3<f32>;`,`var dummyXY_${e}: vec2<f32>;`,`var dummyZW_${e}: vec2<f32>;`]:[`vec4 dummyXYZW_${e};`,`vec3 dummyXYZ_${e};`,`vec2 dummyXY_${e};`,`vec2 dummyZW_${e};`],i=[`dummyXYZW_${e}`,`dummyXYZ_${e}`,`dummyXY_${e}`,`dummyZW_${e}`];for(let n=0;n<a[e].length;n++){const o=a[e][n];o.indexOf("xyzw")>=0?(t[0]="",i[0]=o):o.indexOf("xyz")>=0?(t[1]="",i[1]=o):o.indexOf("xy")>=0?(t[2]="",i[2]=o):o.indexOf("zw")>=0&&(t[3]="",i[3]=o)}if(ke.l.currentProcessApproach===We.m.WebGPU)for(let e=0;e<i.length;e++)i[e]="&"+i[e];r+=t.join("\n"),r+=`${n}(`;for(let t=0;t<o[e].length;t++)0!==t&&(r+=", "),r+=o[e][t];r+=", "+i.join(", "),r+=");\n"}return i+=r,i}}class Xn extends tn.Q{constructor(e,t){super("_sin",{codeGLSL:"void _sin(in float value, out float outValue) {\n  outValue = sin(value);\n}\nvoid _sin(in vec2 value, out vec2 outValue) {\n  outValue = sin(value);\n}\nvoid _sin(in vec3 value, out vec3 outValue) {\n  outValue = sin(value);\n}\nvoid _sin(in vec4 value, out vec4 outValue) {\n  outValue = sin(value);\n}\n",codeWGSL:"fn _sinF32(value: f32, outValue: ptr<function, f32>) {\n  *outValue = sin(value);\n}\nfn _sinVec2f(value: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = sin(value);\n}\nfn _sinVec3f(value: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = sin(value);\n}\nfn _sinVec4f(value: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = sin(value);\n}\n"}),this.__inputs.push(new ln("value",e,t)),this.__outputs.push(new ln("outValue",e,t))}getSocketInputValue(){return this.__inputs[0]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Scalar)return this.__shaderFunctionName+"F32";if(this.__inputs[0].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not implemented")}return this.__shaderFunctionName}}class Hn extends tn.Q{constructor(e,t){super("_step",{codeGLSL:"void _step(in float value, in float edge, out float outValue) {\n  outValue = step(edge, value);\n}\nvoid _step(in vec2 value, in vec2 edge, out vec2 outValue) {\n  outValue = step(edge, value);\n}\nvoid _step(in vec3 value, in vec3 edge, out vec3 outValue) {\n  outValue = step(edge, value);\n}\nvoid _step(in vec4 value, in vec4 edge, out vec4 outValue) {\n  outValue = step(edge, value);\n}\n",codeWGSL:"fn _stepF32(value: f32, edge: f32, outValue: ptr<function, f32>) {\n  *outValue = step(edge, value);\n}\nfn _stepVec2f(value: vec2<f32>, edge: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = step(edge, value);\n}\nfn _stepVec3f(value: vec3<f32>, edge: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = step(edge, value);\n}\nfn _stepVec4f(value: vec4<f32>, edge: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = step(edge, value);\n}\n"}),this.__inputs.push(new ln("value",e,t)),this.__inputs.push(new ln("edge",e,t)),this.__outputs.push(new ln("outValue",e,t))}getSocketInputValue(){return this.__inputs[0]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Scalar)return this.__shaderFunctionName+"F32";if(this.__inputs[0].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not implemented")}return this.__shaderFunctionName}}class jn extends tn.Q{constructor(){super("time",{codeGLSL:"\nvoid time(out float outValue) {\n  outValue = get_time(0.0, 0);\n}\n",codeWGSL:"fn time(outValue: ptr<function, f32>) {\n  *outValue = get_time(0, 0);\n}\n"}),this.__outputs.push({compositionType:w.h.Scalar,componentType:E.I.Float,name:"outValue"})}}class Yn extends tn.Q{constructor(e,t){super("_smoothstep",{codeGLSL:"void _smoothstep(in float value, in float edge0, in float edge1, out float outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\nvoid _smoothstep(in vec2 value, in vec2 edge0, in vec2 edge1, out vec2 outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\nvoid _smoothstep(in vec3 value, in vec3 edge0, in vec3 edge1, out vec3 outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\nvoid _smoothstep(in vec4 value, in vec4 edge0, in vec4 edge1, out vec4 outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\n",codeWGSL:"fn _smoothstepF32(value: f32, edge0: f32, edge1: f32, outValue: ptr<function, f32>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\nfn _smoothstepVec2f(value: vec2<f32>, edge0: vec2<f32>, edge1: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\nfn _smoothstepVec3f(value: vec3<f32>, edge0: vec3<f32>, edge1: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\nfn _smoothstepVec4f(value: vec4<f32>, edge0: vec4<f32>, edge1: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\n"}),this.__inputs.push(new ln("value",e,t)),this.__inputs.push(new ln("edge0",e,t)),this.__inputs.push(new ln("edge1",e,t)),this.__outputs.push(new ln("outValue",e,t))}getSocketInputValue(){return this.__inputs[0]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(ke.l.currentProcessApproach===We.m.WebGPU){if(this.__inputs[0].compositionType===w.h.Scalar)return this.__shaderFunctionName+"F32";if(this.__inputs[0].compositionType===w.h.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===w.h.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===w.h.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not implemented")}return this.__shaderFunctionName}}class Kn{static createVertexShaderCode(e,t,n=!0){const o=e.concat(),a=this.__sortTopologically(o);let i="";const r=a.concat(t);n&&(i+=rn.q.getVertexPrerequisites(r));let s="";s+=Kn.__getFunctionDefinition(a.concat(t.filter((e=>"Fragment"!==e.getShaderStage()))),an.C.VertexShader);try{s+=Kn.__constructShaderWithNodes(r,!0,n)}catch(e){return void P.V.error(e)}return i+s}static createPixelShaderCode(e,t=!0){const n=e.concat(),o=this.__sortTopologically(n);let a="";t&&(a+=rn.q.getPixelPrerequisites(o));let i="";i+=Kn.__getFunctionDefinition(o.filter((e=>"Vertex"!==e.getShaderStage())),an.C.PixelShader);try{i+=Kn.__constructShaderWithNodes(o,!1,t)}catch(e){return void P.V.error(e)}return a+i}static __validateShaderNodes(e){for(let t=0;t<e.length;t++){const n=e[t];for(let e=0;e<n.inputConnections.length;e++)if(null==n.inputConnections[e])return!1}return!0}static __sortTopologically(e){const t=[],n=[],o=[];for(let t=0;t<e.length;t++){const o=e[t];let a=0;for(const e of o.inputConnections)null!=e&&a++;n[t]=a}const a=[];for(let t=0;t<e.length;t++){const n=e[t];for(const t of n.inputConnections){if(null==t)continue;const o=tn.Q.getShaderNodeByUid(t.shaderNodeUid),i=e.indexOf(o);null==a[i]&&(a[i]=[]),a[i].push(n)}}for(let t=0;t<e.length;t++)null==a[t]&&(a[t]=[]);for(let t=0;t<e.length;t++)0===n[t]&&o.push(e[t]);for(;o.length>0;){const i=o.shift();t.push(i);const r=e.indexOf(i);for(const t of a[r])n[e.indexOf(t)]--,0===n[e.indexOf(t)]&&o.push(t)}return t.length!=e.length&&P.V.error("graph is cyclic"),t}static __getFunctionDefinition(e,t){let n="";const o=[];for(let a=0;a<e.length;a++){const i=e[a];-1===o.indexOf(i.shaderFunctionName)&&(n+=i.getShaderCode(t),o.push(i.shaderFunctionName))}return n}static __constructShaderWithNodes(e,t,n){let o="";if(Bn.lK.currentProcessApproach!==We.m.WebGPU)for(let n=0;n<e.length;n++){const a=e[n];for(let e=0;e<a.inputConnections.length;e++){const n=a.inputConnections[e];if(null==n)continue;const i=a.getInputs()[e],r=tn.Q.getShaderNodeByUid(n.shaderNodeUid);"Vertex"===r.getShaderStage()&&"Fragment"===a.getShaderStage()&&(o+=`${t?"out":"in"} ${i.compositionType.getGlslStr(i.componentType)} v_${r.shaderFunctionName}_${r.shaderNodeUid};\n`)}}o+=rn.q.getMainBegin(t),n&&(o+=rn.q.getMainPrerequisites());const a=[],i=[];{const n=new Set,r=new Set,s=new Map;for(let l=1;l<e.length;l++){const c=e[l];null==a[l]&&(a[l]=[]),l-1>=0&&null==i[l-1]&&(i[l-1]=[]);const _=c.inputConnections;for(let e=0;e<_.length;e++){const i=_[e];if(null==i)continue;const r=tn.Q._shaderNodes[i.shaderNodeUid],u=r.getOutput(i.outputNameOfPrev),f=c.getInput(i.inputNameOfThis),d=`${u.name}_${i.shaderNodeUid}_to_${c.shaderNodeUid}`;if(!n.has(`${r.shaderNodeUid}_${i.outputNameOfPrev}`)){let e=rn.q.getAssignmentStatement(d,f);t||"Vertex"===r.getShaderStage()&&"Fragment"===c.getShaderStage()&&(e=rn.q.getAssignmentVaryingStatementInPixelShader(d,f,r)),o+=e}const h=s.get(r.shaderNodeUid);a[l].push(h||d),n.add(`${i.shaderNodeUid}_${i.outputNameOfPrev}`)}for(let t=l;t<e.length;t++){const n=e[t],o=e[l-1],a=n.inputConnections;for(let e=0;e<a.length;e++){const t=a[e];if(null==t)continue;if((null==o?void 0:o.shaderNodeUid)!==t.shaderNodeUid)continue;const c=tn.Q._shaderNodes[t.shaderNodeUid];if(!r.has(`${c.shaderNodeUid}_${t.outputNameOfPrev}`)){const e=`${c.getOutput(t.outputNameOfPrev).name}_${t.shaderNodeUid}_to_${n.shaderNodeUid}`;l-1>=0&&i[l-1].push(e),s.set(t.shaderNodeUid,e)}r.add(`${t.shaderNodeUid}_${t.outputNameOfPrev}`)}}}}for(let n=0;n<e.length;n++){const r=e[n],s=r.getShaderFunctionNameDerivative();null==a[n]&&(a[n]=[]),null==i[n]&&(i[n]=[]),t&&"Fragment"===r.getShaderStage()||(t||"Vertex"!==r.getShaderStage())&&(o+=r.makeCallStatement(n,r,s,a,i))}if(t)for(let t=0;t<e.length;t++){const n=e[t],r=a[t].concat(i[t]);for(let e=0;e<n.inputConnections.length;e++){const t=n.inputConnections[e];if(null==t)continue;const a=tn.Q.getShaderNodeByUid(t.shaderNodeUid);"Vertex"===a.getShaderStage()&&"Fragment"===n.getShaderStage()&&(o+=rn.q.getAssignmentVaryingStatementInVertexShader(a,r,e))}}return o+=rn.q.getMainEnd(t),o}static generateShaderCodeFromJson(e){const t=Object.values(function(e){const t={},n={};for(const o of e.nodes)switch(n[o.id]=o,o.name){case"ConstantScalar":{const e=new _n(E.I.Float);e.setDefaultInputValue(un.X5.fromCopyNumber(o.controls.in1.value)),t[o.id]=e;break}case"ConstantVector2":{const e=new fn(E.I.Float);e.setDefaultInputValue(nt.I9.fromCopy2(o.controls.in1.value,o.controls.in2.value)),t[o.id]=e;break}case"ConstantVector3":{const e=new dn(E.I.Float);e.setDefaultInputValue(fe.Pq.fromCopy3(o.controls.in1.value,o.controls.in2.value,o.controls.in3.value)),t[o.id]=e;break}case"ConstantVector4":{const e=new hn(E.I.Float);e.setDefaultInputValue(F.IU.fromCopy4(o.controls.in1.value,o.controls.in2.value,o.controls.in3.value,o.controls.in4.value)),t[o.id]=e;break}case"UniformVector4":{const e=new pn(w.h.Vec4,E.I.Float);e.setDefaultInputValue("value",F.IU.fromCopyArray4([o.controls.initialX.value,o.controls.initialY.value,o.controls.initialZ.value,o.controls.initialW.value])),e.setUniformDataName(o.controls.name.value),t[o.id]=e;break}case"Time":{const e=new jn;t[o.id]=e;break}case"Add":{const e=o.outputs.out1.socket.name;let n;if("Scalar"===e)n=new vn(w.h.Scalar,E.I.Float);else if("Vector2"===e)n=new vn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new vn(w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Add node: Unknown socket name: "+e);break}n=new vn(w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"Sin":{const e=o.outputs.out1.socket.name;let n;if("Scalar"===e)n=new Xn(w.h.Scalar,E.I.Float);else if("Vector2"===e)n=new Xn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new Xn(w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Sin node: Unknown socket name: "+e);break}n=new Xn(w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"Step":{const e=o.outputs.out1.socket.name;let n;if("Scalar"===e)n=new Hn(w.h.Scalar,E.I.Float);else if("Vector2"===e)n=new Hn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new Hn(w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Add node: Unknown socket name: "+e);break}n=new Hn(w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"SmoothStep":{const e=o.outputs.out1.socket.name;let n;if("Scalar"===e)n=new Yn(w.h.Scalar,E.I.Float);else if("Vector2"===e)n=new Yn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new Yn(w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Add node: Unknown socket name: "+e);break}n=new Yn(w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"Normalize":{const e=o.outputs.out1.socket.name;let n;if("Vector2"===e)n=new xn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new xn(w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Normalize node: Unknown socket name: "+e);break}n=new xn(w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"Dot":{const e=o.inputs.in1.socket.name;let n;if("Vector2"===e)n=new gn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new gn(w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Dot node: Unknown socket name: "+e);break}n=new gn(w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"Multiply":{const e=o.outputs.out1.socket.name;let n;if("Scalar"===e)n=new yn(w.h.Scalar,E.I.Float);else if("Vector2"===e)n=new yn(w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new yn(w.h.Vec3,E.I.Float);else if("Vector4"===e)n=new yn(w.h.Vec4,E.I.Float);else if("Matrix2"===e)n=new yn(w.h.Mat2,E.I.Float);else if("Matrix3"===e)n=new yn(w.h.Mat3,E.I.Float);else{if("Matrix4"!==e){P.V.error("Multiply node: Unknown socket name: "+e);break}n=new yn(w.h.Mat4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"Transform":{const e=o.outputs.out1.socket.name;let n;if("Vector2"===e)n=new Ln(w.h.Mat2,E.I.Float,w.h.Vec2,E.I.Float);else if("Vector3"===e)n=new Ln(w.h.Mat3,E.I.Float,w.h.Vec3,E.I.Float);else{if("Vector4"!==e){P.V.error("Transform node: Unknown socket name: "+e);break}n=new Ln(w.h.Mat4,E.I.Float,w.h.Vec4,E.I.Float)}n.setShaderStage(o.controls.shaderStage.value),t[o.id]=n;break}case"SplitVector":{const e=new Qn;e.setShaderStage(o.controls.shaderStage.value),t[o.id]=e;break}case"MergeVector":{const e=new qn;e.setShaderStage(o.controls.shaderStage.value),t[o.id]=e;break}case"AttributeColor":{const e=new bn;t[o.id]=e;break}case"AttributeNormal":{const e=new In;t[o.id]=e;break}case"AttributePosition":{const e=new An;t[o.id]=e;break}case"AttributeTexcoord":{const e=new En;t[o.id]=e;break}case"WorldMatrix":{const e=new Sn;t[o.id]=e;break}case"ViewMatrix":{const e=new Tn;t[o.id]=e;break}case"ProjectionMatrix":{const e=new wn;t[o.id]=e;break}case"NormalMatrix":{const e=new Cn;t[o.id]=e;break}case"Greater":{const e=new Pn(w.h.Scalar,E.I.Float);t[o.id]=e;break}case"OutPosition":{const e=new Dn;t[o.id]=e;break}case"OutColor":{const e=new Fn;t[o.id]=e;break}}for(let o=0;o<e.connections.length;o++){const a=e.connections[o],i=t[a.from.id],r=t[a.to.id];if(null==i||null==r){P.V.error("inputNodeInstance or outputNodeInstance is null");continue}let s=0;for(const e in n[a.to.id].inputs){if(e===a.to.portName)break;s++}let l=0;for(const e in n[a.from.id].outputs){if(e===a.from.portName)break;l++}const c=i.getOutputs()[l],_=r.getInputs()[s];r.addInputConnection(i,c,_)}return t}(e)),n=this.__sortTopologically(t);!function(e){for(let t=0;t<e.length;t++){const n=e[t];for(const e of n.inputConnections){if(null==e)continue;const t=tn.Q.getShaderNodeByUid(e.shaderNodeUid);"Vertex"===t.getShaderStage()&&"Neutral"===n.getShaderStage()?n.setShaderStage("Vertex"):"Fragment"===t.getShaderStage()&&n.setShaderStage("Fragment")}}}(n);const o=function(e,t){let n;for(let t=0;t<e.length;t++){const o=e[t];if(o.shaderFunctionName.toLowerCase().includes("outColor".toLowerCase())){n=o;break}}if(null==n)return[];let o=[];function a(e){for(let t=0;t<e.inputConnections.length;t++){const n=e.inputConnections[t];if(null==n)continue;const i=tn.Q.getShaderNodeByUid(n.shaderNodeUid);o.push(i),a(i)}}return function e(t){for(let n=0;n<t.inputConnections.length;n++){const i=t.inputConnections[n];if(null==i)continue;const r=tn.Q.getShaderNodeByUid(i.shaderNodeUid);if(null!=r&&"Vertex"===r.getShaderStage()&&"Fragment"===t.getShaderStage()){o.push(r),"Fragment"===t.getShaderStage()&&o.unshift(t),a(r);break}e(r)}}(n),o=[...new Set(o)],o.reverse()}(n),a=Jn(n,["outPosition"]),i=Jn(n,["outColor"]);if(0===a.length||0===i.length)return;const r=Kn.createVertexShaderCode(a,o),s=Kn.createPixelShaderCode(i);return null!=r&&null!=s?{vertexShader:r,pixelShader:s}:void 0}}function Zn(e,t){let n;for(let o=0;o<e.length;o++){const a=e[o];if(a.shaderFunctionName.toLowerCase().includes(t.toLowerCase())){n=a;break}}if(null==n)return[];const o=[n];return function e(t){for(let n=0;n<t.inputConnections.length;n++){const a=t.inputConnections[n];if(null!=a){const t=tn.Q.getShaderNodeByUid(a.shaderNodeUid);null!=t&&(o.push(t),e(t))}}}(n),o}function Jn(e,t){let n=[];for(let o=0;o<t.length;o++){const a=Zn(e,t[o]);n=n.concat(a)}return n=[...new Set(n)],n}var $n=o(9491),eo=o(589),to=o(7776),no=o(643),oo=o(4923),ao=o(9920),io=o(790),ro=o(4307),so=o(9516),lo=o(6131),co=o(9494),_o=o(3549),uo=o(2538),fo=o(581),ho=o(3795),mo=o(4066),po=o(3735),vo=o(1276),xo=o(6455),go=o(9827),yo=o(3583);class bo extends v.E{constructor(){super(),this.__width=0,this.__height=0,this.__isShadow=!1,this.__isBloom=!1,this.__isSimple=!1,this.__shadowMapSize=1024,this.__oFrame=new vo.NV,this.__oFrameDepthMoment=new vo.NV,this.__oFrameBufferMultiView=new vo.NV,this.__oFrameBufferMultiViewBlit=new vo.NV,this.__oFrameBufferMultiViewBlitBackBuffer=new vo.NV,this.__oFrameBufferMsaa=new vo.NV,this.__oFrameBufferResolve=new vo.NV,this.__oFrameBufferResolveForReference=new vo.NV,this.__oInitialExpression=new vo.NV,this.__expressions=[],this.__oGenerateMipmapsExpression=new vo.NV,this.__oMultiViewBlitBackBufferExpression=new vo.NV,this.__oMultiViewBlitExpression=new vo.NV,this.__oCameraComponentOfLight=new vo.NV,this.__depthMomentExpressions=[],this.__oBloomExpression=new vo.NV,this.__oToneMappingExpression=new vo.NV,this.__oToneMappingMaterial=new vo.NV,this.__transparentOnlyExpressions=[],this.__oWebXRSystem=new vo.NV,this.__oDrawFunc=new vo.NV,this.__oDiffuseCubeTexture=new vo.NV,this.__oSpecularCubeTexture=new vo.NV,this.__oSamplerForBackBuffer=new vo.NV,this.__toneMappingType=x.JK.GT_ToneMap}__destroyResources(){this.__oFrameDepthMoment.has()&&(this.__oFrameDepthMoment.get().destroy3DAPIResources(),this.__oFrameDepthMoment=new vo.NV),this.__oFrameBufferMultiView.has()&&(this.__oFrameBufferMultiView.get().destroy3DAPIResources(),this.__oFrameBufferMultiView=new vo.NV),this.__oFrameBufferMultiViewBlit.has()&&(this.__oFrameBufferMultiViewBlit.get().destroy3DAPIResources(),this.__oFrameBufferMultiViewBlit=new vo.NV),this.__oFrameBufferMsaa.has()&&(this.__oFrameBufferMsaa.get().destroy3DAPIResources(),this.__oFrameBufferMsaa=new vo.NV),this.__oFrameBufferResolve.has()&&(this.__oFrameBufferResolve.get().destroy3DAPIResources(),this.__oFrameBufferResolve=new vo.NV),this.__oFrameBufferResolveForReference.has()&&(this.__oFrameBufferResolveForReference.get().destroy3DAPIResources(),this.__oFrameBufferResolveForReference=new vo.NV),this.__oFrame=new vo.NV,this.__oGenerateMipmapsExpression=new vo.NV,this.__oMultiViewBlitExpression=new vo.NV,this.__oBloomExpression=new vo.NV,this.__oToneMappingExpression=new vo.NV}async setup(e,t,{isShadow:n=!1,isBloom:o=!1,shadowMapSize:a=1024,isSimple:i=!1}={}){if(this.__width=e,this.__height=t,this.__isBloom=o,this.__isShadow=n,this.__isSimple=i,this.__shadowMapSize=a,this.__oFrame.has())return new wt._({message:"Already setup",error:void 0});const r=new vo.p2(new xo.w);if(this.__oFrame=r,!this.__isSimple){const i=new vo.p2(new Fe.L({wrapS:Me.P.Repeat,wrapT:Me.P.Repeat,minFilter:Me.P.LinearMipmapLinear,magFilter:Me.P.Linear}));i.get().create(),this.__oSamplerForBackBuffer=i,this.__createRenderTargets(e,t),n&&!this.__isSimple&&(this.__oFrameDepthMoment=this.__setupDepthMomentFramebuffer(a)),this.__oFrameBufferResolveForReference.has()&&(this.__oGenerateMipmapsExpression=this.__setupGenerateMipmapsExpression(this.__oFrameBufferResolveForReference.get())),this.__oFrameBufferMultiView.has()&&(this.__oMultiViewBlitBackBufferExpression=this.__setupMultiViewBlitBackBufferExpression(this.__oFrameBufferMultiView.get()),this.__oMultiViewBlitExpression=this.__setupMultiViewBlitExpression(this.__oFrameBufferMultiView.get()));let r=this.__getMainFrameBufferResolve().unwrapForce().getColorAttachedRenderTargetTexture(0);if(o&&!this.__isSimple){const e=this.__getMainFrameBufferResolve().unwrapForce().getColorAttachedRenderTargetTexture(0),{bloomExpression:t,bloomedRenderTarget:n}=rt.createBloomExpression({textureToBloom:e,parameters:{}});this.__oBloomExpression=new vo.p2(t),r=n}const s=this.__setupToneMappingExpression(r);this.__oToneMappingExpression=new vo.p2(s)}const s=this.__setupInitialExpression(this.__oFrameDepthMoment);this.__oInitialExpression=new vo.p2(s);const l=await yo.e.getInstance().getModule("xr");return I.Is.exist(l)&&(this.__oWebXRSystem=new vo.p2(l.WebXRSystem.getInstance())),this.__expressions.length>0&&this.setExpressions(this.__expressions),new wt.Ok}__getMainFrameBufferBackBuffer(){return this.__oFrameBufferMultiView.has()?this.__oFrameBufferMultiViewBlitBackBuffer:this.__oFrameBufferResolveForReference}__getMainFrameBufferResolve(){return this.__oFrameBufferMultiView.has()?this.__oFrameBufferMultiViewBlit:this.__oFrameBufferResolve}__getMainFrameBuffer(){return this.__oFrameBufferMultiView.has()?this.__oFrameBufferMultiView:this.__oFrameBufferMsaa}setExpressions(e,t={isTransmission:!0}){const n=e.map((e=>e.clone()));this.__setExpressionsInner(e,{isTransmission:t.isTransmission}),t.isTransmission&&this.__setTransparentExpressionsForTransmission(n),Bn.lK.currentProcessApproach!==x.m7.WebGPU&&this.__oFrameDepthMoment.has()&&(this.__setDepthTextureToEntityMaterials(),this.__oCameraComponentOfLight.has()&&this.setCameraComponentOfLight(this.__oCameraComponentOfLight.get()))}__setDepthTextureToEntityMaterials(){if(I.Is.false(this.__isShadow))return;this.__depthMomentExpressions=[];for(const e of this.__expressions)this.__depthMomentExpressions.push(e.clone());const e=Ne.m.createDepthMomentEncodeMaterial();for(const t of this.__depthMomentExpressions)for(const n of t.renderPasses)n.setFramebuffer(this.__oFrameDepthMoment.unwrapForce()),n.setResolveFramebuffer(void 0),n.setResolveFramebuffer2(void 0),n.setToRenderOpaquePrimitives(!0),n.setToRenderTranslucentPrimitives(!0),n.setToRenderBlendWithZWritePrimitives(!0),n.setToRenderBlendWithoutZWritePrimitives(!1),n.setMaterial(e);const t=new Fe.L({wrapS:Me.P.ClampToEdge,wrapT:Me.P.ClampToEdge,minFilter:Me.P.Linear,magFilter:Me.P.Linear,anisotropy:!1});t.create();for(const e of this.__expressions)for(const n of e.renderPasses){const e=n.entities;for(const n of e){const e=n.tryToGetMesh();if(I.Is.exist(e)){const n=e.mesh;if(I.Is.exist(n)){const e=n.primitives;for(const n of e)n.material.setTextureParameter("depthTexture",this.__oFrameDepthMoment.unwrapForce().getColorAttachedRenderTargetTexture(0),t)}}}}}startRenderLoop(e){return this.__oFrame.doesNotHave()?new wt._({message:"not initialized.",error:void 0}):(this.__oDrawFunc=new vo.p2(e),go.i.startRenderLoop((()=>{this.__setExpressions(),e(this.__oFrame.unwrapForce())})),new wt.Ok)}draw(){this.__oDrawFunc.unwrapForce()(this.__oFrame.unwrapForce())}resize(e,t){if(this.__oFrame.doesNotHave())return new wt._({message:"not initialized.",error:void 0});const n=this.__oWebXRSystem.unwrapOrUndefined();return I.Is.exist(n)&&n.isWebXRMode&&(e=n.getCanvasWidthForVr(),t=n.getCanvasHeightForVr()),go.i.resizeCanvas(e,t),this.__destroyResources(),this.setup(e,t,{isShadow:this.__isShadow,isBloom:this.__isBloom,shadowMapSize:this.__shadowMapSize,isSimple:this.__isSimple}),new wt.Ok}async setIBLTextures(e,t){this.__oDiffuseCubeTexture=new vo.p2(e),this.__oSpecularCubeTexture=new vo.p2(t),await this.__setIblInner(),await this.__setIblInnerForTransparentOnly()}getInitialExpression(){return this.__oInitialExpression.unwrapOrUndefined()}getToneMappingExpression(){return this.__oToneMappingExpression.unwrapOrUndefined()}setDiffuseIBLContribution(e){for(const t of this.__expressions)for(const n of t.renderPasses)for(const t of n.entities){const n=t.tryToGetMeshRenderer();I.Is.exist(n)&&(n.diffuseCubeMapContribution=e)}for(const t of this.__transparentOnlyExpressions)for(const n of t.renderPasses)for(const t of n.entities){const n=t.tryToGetMeshRenderer();I.Is.exist(n)&&(n.diffuseCubeMapContribution=e)}}setSpecularIBLContribution(e){for(const t of this.__expressions)for(const n of t.renderPasses)for(const t of n.entities){const n=t.tryToGetMeshRenderer();I.Is.exist(n)&&(n.specularCubeMapContribution=e)}for(const t of this.__transparentOnlyExpressions)for(const n of t.renderPasses)for(const t of n.entities){const n=t.tryToGetMeshRenderer();I.Is.exist(n)&&(n.specularCubeMapContribution=e)}}setIBLRotation(e){for(const t of this.__expressions)for(const n of t.renderPasses)for(const t of n.entities){const n=t.tryToGetMeshRenderer();I.Is.exist(n)&&(n.rotationOfCubeMap=e)}}setCameraComponentOfLight(e){if(this.__isShadow){this.__oCameraComponentOfLight=new vo.p2(e);for(const t of this.__depthMomentExpressions)for(const n of t.renderPasses)n.cameraComponent=e;for(const t of this.__expressions)for(const n of t.renderPasses)n.setPostRenderFunction((function(){const t=n.entities;for(const n of t){const t=n.tryToGetMesh();if(I.Is.exist(t)){const n=t.mesh;if(I.Is.exist(n)){const t=n.primitives;for(const n of t)n.material.setParameter("depthBiasPV",e.biasViewProjectionMatrix)}}}}))}}async __setExpressionsInner(e,t={isTransmission:!0}){for(const n of e)for(const e of n.renderPasses)if(e.setToRenderOpaquePrimitives(!0),e.setToRenderBlendWithZWritePrimitives(!0),e.setToRenderBlendWithoutZWritePrimitives(!0),t.isTransmission?e.setToRenderTranslucentPrimitives(!1):e.setToRenderTranslucentPrimitives(!0),e.toClearDepthBuffer=!1,!this.__isSimple){const t=this.__getMainFrameBuffer();t.has()&&(e.setFramebuffer(t.get()),this.__oFrameBufferMsaa.has()&&(e.setResolveFramebuffer(this.__oFrameBufferResolve.unwrapForce()),e.setResolveFramebuffer2(this.__oFrameBufferResolveForReference.unwrapForce())))}this.__expressions=e,await this.__setIblInner()}__setTransparentExpressionsForTransmission(e){for(const t of e){t.tryToSetUniqueName("modelTransparentForTransmission",!0);for(const e of t.renderPasses)if(e.setToRenderOpaquePrimitives(!1),e.setToRenderTranslucentPrimitives(!0),e.setToRenderBlendWithZWritePrimitives(!1),e.setToRenderBlendWithoutZWritePrimitives(!1),e.toClearDepthBuffer=!1,!this.__isSimple){e.setFramebuffer(this.__getMainFrameBuffer().unwrapForce()),this.__oFrameBufferResolve.has()&&e.setResolveFramebuffer(this.__oFrameBufferResolve.unwrapForce());for(const t of e.entities){const e=t.tryToGetMesh();if(I.Is.exist(e)){const t=e.mesh;if(I.Is.exist(t))for(let e=0;e<t.getPrimitiveNumber();e++)t.getPrimitiveAt(e).material.setTextureParameter("backBufferTexture",this.__getMainFrameBufferBackBuffer().unwrapForce().getColorAttachedRenderTargetTexture(0),this.__oSamplerForBackBuffer.unwrapForce())}}}}this.__transparentOnlyExpressions=e,this.__setIblInnerForTransparentOnly()}__setupInitialExpression(e){const t=new ot.r;t.tryToSetUniqueName("Initial",!0);const n=new De.A;if(n.clearColor=F.IU.fromCopyArray4([0,0,0,0]),n.toClearColorBuffer=!0,n.toClearDepthBuffer=!0,n.tryToSetUniqueName("InitialRenderPass",!0),t.addRenderPasses([n]),!this.__isSimple){const e=new De.A;e.clearColor=F.IU.fromCopyArray4([0,0,0,0]),e.toClearColorBuffer=!0,e.toClearDepthBuffer=!0,e.setFramebuffer(this.__getMainFrameBuffer().unwrapForce()),e.tryToSetUniqueName("InitialRenderPassForFrameBuffer",!0),t.addRenderPasses([e])}if(e.has()){const n=e.get(),o=new De.A;o.clearColor=F.IU.fromCopyArray4([1,1,1,1]),o.toClearColorBuffer=!0,o.toClearDepthBuffer=!0,o.setFramebuffer(n),o.tryToSetUniqueName("InitialRenderPassForDepthMoment",!0),t.addRenderPasses([o])}return t}__createRenderTargets(e,t){const n=yo.e.getInstance().getModule("xr"),o=null==n?void 0:n.WebXRSystem.getInstance(),a=Ve.f.getCgApiResourceRepository();if(I.Is.exist(o)&&o.isWebXRMode&&a.isSupportMultiViewVRRendering()){const n=tt.createFrameBufferTextureArray({width:e/2,height:t,arrayLength:2,level:0,internalFormat:this.__isBloom?Qe.n.R11F_G11F_B10F:Qe.n.RGBA8,format:this.__isBloom?x.Ab.RGB:x.Ab.RGBA,type:this.__isBloom?x.I5.Float:x.I5.UnsignedByte});n.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiView",!0);const o=tt.createFrameBuffer({width:e,height:t,textureNum:1,textureFormats:[this.__isBloom?Qe.n.R11F_G11F_B10F:Qe.n.RGBA8],createDepthBuffer:!1});o.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiViewBlit",!0);const a=tt.createFrameBuffer({width:e,height:t,textureNum:1,textureFormats:[this.__isBloom?Qe.n.R11F_G11F_B10F:Qe.n.RGBA8],createDepthBuffer:!1});o.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiViewBlitBackBuffer",!0),this.__oFrameBufferMultiView=new vo.p2(n),this.__oFrameBufferMultiViewBlit=new vo.p2(o),this.__oFrameBufferMultiViewBlitBackBuffer=new vo.p2(a),this.__oFrameBufferMsaa=new vo.NV,this.__oFrameBufferResolve=new vo.NV,this.__oFrameBufferResolveForReference=new vo.NV}else{const n=tt.createFrameBufferMSAA({width:e,height:t,colorBufferNum:1,colorFormats:[this.__isBloom?Qe.n.R11F_G11F_B10F:Qe.n.RGBA8],sampleCountMSAA:4,depthBufferFormat:Qe.n.Depth32F});n.tryToSetUniqueName("FramebufferTargetOfToneMappingMsaa",!0);const o=tt.createFrameBuffer({width:e,height:t,textureNum:1,textureFormats:[this.__isBloom?Qe.n.R11F_G11F_B10F:Qe.n.RGBA8],createDepthBuffer:!0,depthTextureFormat:Qe.n.Depth32F});o.tryToSetUniqueName("FramebufferTargetOfToneMappingResolve",!0);const a=tt.createFrameBuffer({width:e,height:t,textureNum:1,textureFormats:[this.__isBloom?Qe.n.R11F_G11F_B10F:Qe.n.RGBA8],createDepthBuffer:!1});a.tryToSetUniqueName("FramebufferTargetOfToneMappingResolveForReference",!0),this.__oFrameBufferMultiView=new vo.NV,this.__oFrameBufferMultiViewBlit=new vo.NV,this.__oFrameBufferMultiViewBlitBackBuffer=new vo.NV,this.__oFrameBufferMsaa=new vo.p2(n),this.__oFrameBufferResolve=new vo.p2(o),this.__oFrameBufferResolveForReference=new vo.p2(a)}}__setupGenerateMipmapsExpression(e){const t=new ot.r;t.tryToSetUniqueName("GenerateMipmaps",!0);const n=new De.A;return t.addRenderPasses([n]),n.tryToSetUniqueName("GenerateMipmaps",!0),n.toClearDepthBuffer=!1,n.setPostRenderFunction((function(){e.getColorAttachedRenderTargetTexture(0).generateMipmaps()})),new vo.p2(t)}__setupMultiViewBlitBackBufferExpression(e){const t=new ot.r;t.tryToSetUniqueName("MultiViewBlitBackBuffer",!0);const n=new De.A;return t.addRenderPasses([n]),n.tryToSetUniqueName("MultiViewBlitBackBuffer",!0),n.toClearDepthBuffer=!1,n.setPostRenderFunction((()=>{if(this.__oFrameBufferMultiViewBlitBackBuffer.has()){const t=this.__oFrameBufferMultiViewBlitBackBuffer.unwrapForce().colorAttachments[0];e.colorAttachments[0].blitToTexture2dFromTexture2dArrayFake(t),t.generateMipmaps()}})),new vo.p2(t)}__setupMultiViewBlitExpression(e){const t=new ot.r;t.tryToSetUniqueName("MultiViewBlit",!0);const n=new De.A;return t.addRenderPasses([n]),n.tryToSetUniqueName("MultiViewBlit",!0),n.toClearDepthBuffer=!1,n.setPostRenderFunction((()=>{if(this.__oFrameBufferMultiViewBlit.has()){const t=this.__oFrameBufferMultiViewBlit.unwrapForce().colorAttachments[0];e.colorAttachments[0].blitToTexture2dFromTexture2dArrayFake(t)}})),new vo.p2(t)}__setupToneMappingExpression(e){const t=new ot.r,n=Ne.m.createToneMappingMaterial();this.__oToneMappingMaterial=new vo.p2(n),this.setToneMappingType(this.__toneMappingType);const o=Le.createScreenDrawRenderPassWithBaseColorTexture(n,e);o.tryToSetUniqueName("renderPassToneMapping",!0),o.toClearColorBuffer=!1,o.toClearDepthBuffer=!1,o.isDepthTest=!1,o.clearColor=F.IU.fromCopyArray4([0,0,0,0]),o.isVrRendering=!1,o.isOutputForVr=!1;const a=Le.createScreenDrawRenderPassWithBaseColorTexture(n,e);return a.tryToSetUniqueName("renderPassToneMappingVr",!0),a.toClearColorBuffer=!1,a.toClearDepthBuffer=!1,a.isDepthTest=!1,a.clearColor=F.IU.fromCopyArray4([0,0,0,0]),a.isVrRendering=!1,a.isOutputForVr=!0,t.addRenderPasses([o,a]),t}__setupDepthMomentFramebuffer(e){return new vo.p2(tt.createFrameBuffer({width:e,height:e,textureNum:1,textureFormats:[Qe.n.RG32F],createDepthBuffer:!0,depthTextureFormat:Qe.n.Depth32F}))}async __setIblInner(){for(const e of this.__expressions)for(const t of e.renderPasses)for(const e of t.entities){const t=e.tryToGetMeshRenderer();I.Is.exist(t)&&await t.setIBLCubeMap(this.__oDiffuseCubeTexture.unwrapOrUndefined(),this.__oSpecularCubeTexture.unwrapOrUndefined())}}async __setIblInnerForTransparentOnly(){for(const e of this.__transparentOnlyExpressions)for(const t of e.renderPasses)for(const e of t.entities){const t=e.tryToGetMeshRenderer();I.Is.exist(t)&&await t.setIBLCubeMap(this.__oDiffuseCubeTexture.unwrapOrUndefined(),this.__oSpecularCubeTexture.unwrapOrUndefined())}}setToneMappingType(e){this.__oToneMappingMaterial.has()&&(this.__toneMappingType=e,this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_KHRONOS_PBR_NEUTRAL"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_REINHARD"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_GT_TONEMAP"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_NARKOWICZ"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_HILL"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_HILL_EXPOSURE_BOOST"),e===x.JK.KhronosPbrNeutral?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_KHRONOS_PBR_NEUTRAL"):e===x.JK.Reinhard?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_REINHARD"):e===x.JK.GT_ToneMap?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_GT_TONEMAP"):e===x.JK.ACES_Narkowicz?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_NARKOWICZ"):e===x.JK.ACES_Hill?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_HILL"):e===x.JK.ACES_Hill_Exposure_Boost&&this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_HILL_EXPOSURE_BOOST"))}__setExpressions(){if(this.__oFrame.doesNotHave())return void console.error("Frame is not set.");const e=this.__oFrame.get();if(e.clearExpressions(),e.addExpression(this.getInitialExpression()),!this.__isSimple)for(const t of this.__depthMomentExpressions)e.addExpression(t);for(const t of this.__expressions)e.addExpression(t);!this.__isSimple&&this.__oGenerateMipmapsExpression.has()&&e.addExpression(this.__oGenerateMipmapsExpression.get()),!this.__isSimple&&this.__oMultiViewBlitBackBufferExpression.has()&&e.addExpression(this.__oMultiViewBlitBackBufferExpression.get());for(const t of this.__transparentOnlyExpressions)e.addExpression(t);!this.__isSimple&&this.__oMultiViewBlitExpression.has()&&e.addExpression(this.__oMultiViewBlitExpression.get()),!this.__isSimple&&this.__isBloom&&this.__oBloomExpression.has()&&e.addExpression(this.__oBloomExpression.get()),!this.__isSimple&&this.__oToneMappingExpression.has()&&e.addExpression(this.getToneMappingExpression())}}var Io=o(8909),Ao=o(7529),Eo=o(3430),So=o(700),To=o(4034),wo=o(8767),Co=o(3296);o(7865);class Ro extends rn.q{constructor(){super(),this.vertexShaderBody="\n\n\n  "}static getInstance(){return this.__instance||(this.__instance=new Ro),this.__instance}get vertexShaderDefinitions(){return"\n\n"}get pixelShaderDefinitions(){return`\nuniform int u_shadingModel;\nuniform float u_shininess;\n\nstruct Light {\n  vec4 lightPosition;\n  vec4 lightDirection;\n  vec4 lightIntensity;\n};\nuniform Light u_lights[${f.T.maxLightNumberInShader}];\nuniform int u_lightNumber;\nuniform vec3 u_viewPosition;\n\n\nbool classicShading(\n  in vec3 diffuseColor,\n  in vec3 position_inWorld,\n  in vec3 normal_inWorld,\n  out vec3 outColor\n  )\n{\n  // Lighting\n  outColor = vec3(0.0, 0.0, 0.0);\n  if (u_shadingModel > 0) {\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < ${f.T.maxLightNumberInShader}; i++) {\n      if (i >= u_lightNumber) {\n        break;\n      }\n\n      vec3 lightDirection = u_lights[i].lightDirection.xyz;\n      float lightType = u_lights[i].lightPosition.w;\n      float spotCosCutoff = u_lights[i].lightDirection.w;\n      float spotExponent = u_lights[i].lightIntensity.w;\n\n      if (0.75 < lightType) { // is pointlight or spotlight\n        lightDirection = normalize(u_lights[i].lightPosition.xyz - position_inWorld.xyz);\n      }\n      float spotEffect = 1.0;\n      if (lightType > 1.75) { // is spotlight\n        spotEffect = dot(u_lights[i].lightDirection.xyz, lightDirection);\n        if (spotEffect > spotCosCutoff) {\n          spotEffect = pow(spotEffect, spotExponent);\n        } else {\n          spotEffect = 0.0;\n        }\n      }\n\n      vec3 incidentLight = spotEffect * u_lights[i].lightIntensity.xyz;\n//      incidentLight *= M_PI;\n\n      normal_inWorld = normalize(normal_inWorld);\n\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, lightDirection)) * incidentLight;\n\n      if (u_shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(u_viewPosition - position_inWorld.xyz);\n        vec3 halfVector = normalize(lightDirection + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), u_shininess);\n      } else if (u_shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(u_viewPosition - position_inWorld.xyz);\n        vec3 R = reflect(lightDirection, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), u_shininess);\n      }\n\n    }\n\n    outColor = diffuse + specular;\n  } else {\n    outColor = diffuseColor;\n  }\n}\n\n    `}get pixelShaderBody(){return""}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}Ro.materialElement=Nn.m.PBRShading;class Po extends rn.q{constructor(){super(),this.__materialNodeUid=0,this.vertexShaderBody="\n  "}set materialNodeUid(e){this.__materialNodeUid=e}getPixelShaderBody(){return"\n    "}get vertexShaderDefinitions(){return""}get pixelShaderDefinitions(){return""}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}class No extends rn.q{constructor(e,t,n){super(),this.__functionName=e,this.__compositionType=t,this.__componentType=n,this.__variableName=""}setVariableName(e){this.__variableName=e}get vertexShaderDefinitions(){return`\n    out ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};\n    void ${this.__functionName}(\n      in ${this.__compositionType.getGlslStr(this.__componentType)} value) {\n      ${this.__variableName} = value;\n    }\n    `}get pixelShaderDefinitions(){return`\n    in ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};\n    void ${this.__functionName}(\n      out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {\n      outValue = ${this.__variableName};\n    }\n    `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}}var Mo=o(4169),Do=o(7976),Fo=o(69),Bo=o(3336),Lo=o(2238),Vo=o(494),zo=o(5012),Go=o(6727),Oo=o(5966);function Uo(){return yo.e.getInstance().getModule("xr").WebXRSystem.getInstance()}o(352);const ko=i;var Wo=a.A;export{Wo as default};