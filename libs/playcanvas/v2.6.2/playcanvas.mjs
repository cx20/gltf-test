/**
 * @license
 * PlayCanvas Engine v0.0.0 revision 0a75e06 (RELEASE)
 * Copyright 2011-2025 PlayCanvas Ltd. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TRACEID_RENDER_FRAME = 'RenderFrame';
var TRACEID_RENDER_FRAME_TIME = 'RenderFrameTime';
var TRACEID_RENDER_PASS = 'RenderPass';
var TRACEID_RENDER_PASS_DETAIL = 'RenderPassDetail';
var TRACEID_RENDER_ACTION = 'RenderAction';
var TRACEID_RENDER_TARGET_ALLOC = 'RenderTargetAlloc';
var TRACEID_TEXTURE_ALLOC = 'TextureAlloc';
var TRACEID_SHADER_ALLOC = 'ShaderAlloc';
var TRACEID_SHADER_COMPILE = 'ShaderCompile';
var TRACEID_VRAM_TEXTURE = 'VRAM.Texture';
var TRACEID_VRAM_VB = 'VRAM.Vb';
var TRACEID_VRAM_IB = 'VRAM.Ib';
var TRACEID_VRAM_SB = 'VRAM.Sb';
var TRACEID_BINDGROUP_ALLOC = 'BindGroupAlloc';
var TRACEID_BINDGROUPFORMAT_ALLOC = 'BindGroupFormatAlloc';
var TRACEID_RENDERPIPELINE_ALLOC = 'RenderPipelineAlloc';
var TRACEID_COMPUTEPIPELINE_ALLOC = 'ComputePipelineAlloc';
var TRACEID_PIPELINELAYOUT_ALLOC = 'PipelineLayoutAlloc';
var TRACE_ID_ELEMENT = 'Element';
var TRACEID_TEXTURES = 'Textures';
var TRACEID_RENDER_QUEUE = 'RenderQueue';
var TRACEID_GPU_TIMINGS = 'GpuTimings';

var version = '0.0.0';
var revision = '0a75e06';
function extend(target, ex) {
		for(var prop in ex){
				var copy = ex[prop];
				if (Array.isArray(copy)) {
						target[prop] = extend([], copy);
				} else if (copy && typeof copy === 'object') {
						target[prop] = extend({}, copy);
				} else {
						target[prop] = copy;
				}
		}
		return target;
}

var guid = {
		create () {
				return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
						var r = Math.random() * 16 | 0;
						var v = c === 'x' ? r : r & 0x3 | 0x8;
						return v.toString(16);
				});
		}
};

var path = {
		delimiter: '/',
		join () {
				for(var _len = arguments.length, sections = new Array(_len), _key = 0; _key < _len; _key++){
						sections[_key] = arguments[_key];
				}
				var result = sections[0];
				for(var i = 0; i < sections.length - 1; i++){
						var one = sections[i];
						var two = sections[i + 1];
						if (two[0] === path.delimiter) {
								result = two;
								continue;
						}
						if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
								result += path.delimiter + two;
						} else {
								result += two;
						}
				}
				return result;
		},
		normalize (pathname) {
				var lead = pathname.startsWith(path.delimiter);
				var trail = pathname.endsWith(path.delimiter);
				var parts = pathname.split('/');
				var result = '';
				var cleaned = [];
				for(var i = 0; i < parts.length; i++){
						if (parts[i] === '') continue;
						if (parts[i] === '.') continue;
						if (parts[i] === '..' && cleaned.length > 0) {
								cleaned = cleaned.slice(0, cleaned.length - 2);
								continue;
						}
						if (i > 0) cleaned.push(path.delimiter);
						cleaned.push(parts[i]);
				}
				result = cleaned.join('');
				if (!lead && result[0] === path.delimiter) {
						result = result.slice(1);
				}
				if (trail && result[result.length - 1] !== path.delimiter) {
						result += path.delimiter;
				}
				return result;
		},
		split (pathname) {
				var lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);
				if (lastDelimiterIndex !== -1) {
						return [
								pathname.substring(0, lastDelimiterIndex),
								pathname.substring(lastDelimiterIndex + 1)
						];
				}
				return [
						'',
						pathname
				];
		},
		getBasename (pathname) {
				return path.split(pathname)[1];
		},
		getDirectory (pathname) {
				return path.split(pathname)[0];
		},
		getExtension (pathname) {
				var ext = pathname.split('?')[0].split('.').pop();
				if (ext !== pathname) {
						return "." + ext;
				}
				return '';
		},
		isRelativePath (pathname) {
				return pathname.charAt(0) !== '/' && pathname.match(/:\/\//) === null;
		},
		extractPath (pathname) {
				var result = '';
				var parts = pathname.split('/');
				var i = 0;
				if (parts.length > 1) {
						if (path.isRelativePath(pathname)) {
								if (parts[0] === '.') {
										for(i = 0; i < parts.length - 1; ++i){
												result += i === 0 ? parts[i] : "/" + parts[i];
										}
								} else if (parts[0] === '..') {
										for(i = 0; i < parts.length - 1; ++i){
												result += i === 0 ? parts[i] : "/" + parts[i];
										}
								} else {
										result = '.';
										for(i = 0; i < parts.length - 1; ++i){
												result += "/" + parts[i];
										}
								}
						} else {
								for(i = 0; i < parts.length - 1; ++i){
										result += i === 0 ? parts[i] : "/" + parts[i];
								}
						}
				}
				return result;
		}
};

var detectPassiveEvents = ()=>{
		var result = false;
		try {
				var opts = Object.defineProperty({}, 'passive', {
						get: function get() {
								result = true;
								return false;
						}
				});
				window.addEventListener('testpassive', null, opts);
				window.removeEventListener('testpassive', null, opts);
		} catch (e) {}
		return result;
};
var ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';
var environment = typeof window !== 'undefined' ? 'browser' : typeof global !== 'undefined' ? 'node' : 'worker';
var platformName = /android/i.test(ua) ? 'android' : /ip(?:[ao]d|hone)/i.test(ua) ? 'ios' : /windows/i.test(ua) ? 'windows' : /mac os/i.test(ua) ? 'osx' : /linux/i.test(ua) ? 'linux' : /cros/i.test(ua) ? 'cros' : null;
var browserName = environment !== 'browser' ? null : /Chrome\/|Chromium\/|Edg.*\//.test(ua) ? 'chrome' : /Safari\//.test(ua) ? 'safari' : /Firefox\//.test(ua) ? 'firefox' : 'other';
var xbox = /xbox/i.test(ua);
var touch = environment === 'browser' && ('ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);
var gamepads = environment === 'browser' && (!!navigator.getGamepads || !!navigator.webkitGetGamepads);
var workers = typeof Worker !== 'undefined';
var passiveEvents = detectPassiveEvents();
var _ref, _ref1, _ref2;
var platform = {
		name: platformName,
		environment: environment,
		global: (_ref2 = (_ref1 = (_ref = typeof globalThis !== 'undefined' && globalThis) != null ? _ref : environment === 'browser' && window) != null ? _ref1 : environment === 'node' && global) != null ? _ref2 : environment === 'worker' && self,
		browser: environment === 'browser',
		worker: environment === 'worker',
		desktop: [
				'windows',
				'osx',
				'linux',
				'cros'
		].includes(platformName),
		mobile: [
				'android',
				'ios'
		].includes(platformName),
		ios: platformName === 'ios',
		android: platformName === 'android',
		xbox: xbox,
		gamepads: gamepads,
		touch: touch,
		workers: workers,
		passiveEvents: passiveEvents,
		browserName: browserName
};

var ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';
var ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
var HIGH_SURROGATE_BEGIN = 0xD800;
var HIGH_SURROGATE_END = 0xDBFF;
var LOW_SURROGATE_BEGIN = 0xDC00;
var LOW_SURROGATE_END = 0xDFFF;
var ZERO_WIDTH_JOINER = 0x200D;
var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
var REGIONAL_INDICATOR_END = 0x1F1FF;
var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
var FITZPATRICK_MODIFIER_END = 0x1F3FF;
var DIACRITICAL_MARKS_BEGIN = 0x20D0;
var DIACRITICAL_MARKS_END = 0x20FF;
var VARIATION_MODIFIER_BEGIN = 0xFE00;
var VARIATION_MODIFIER_END = 0xFE0F;
function getCodePointData(string, i) {
		if (i === void 0) i = 0;
		var size = string.length;
		if (i < 0 || i >= size) {
				return null;
		}
		var first = string.charCodeAt(i);
		if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
				var second = string.charCodeAt(i + 1);
				if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
						return {
								code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
								long: true
						};
				}
		}
		return {
				code: first,
				long: false
		};
}
function isCodeBetween(string, begin, end) {
		if (!string) {
				return false;
		}
		var codeData = getCodePointData(string);
		if (codeData) {
				var code = codeData.code;
				return code >= begin && code <= end;
		}
		return false;
}
function numCharsToTakeForNextSymbol(string, index) {
		if (index === string.length - 1) {
				return 1;
		}
		if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
				var first = string.substring(index, index + 2);
				var second = string.substring(index + 2, index + 4);
				if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
						return 4;
				}
				if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
						return 3;
				}
				return 2;
		}
		if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				return 2;
		}
		return 1;
}
var string = {
		ASCII_LOWERCASE: ASCII_LOWERCASE,
		ASCII_UPPERCASE: ASCII_UPPERCASE,
		ASCII_LETTERS: ASCII_LETTERS,
		format (s) {
				for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
						args[_key - 1] = arguments[_key];
				}
				for(var i = 0; i < args.length; i++){
						s = s.replace("{" + i + "}", args[i]);
				}
				return s;
		},
		getCodePoint (string, i) {
				var codePointData = getCodePointData(string, i);
				return codePointData && codePointData.code;
		},
		getCodePoints (string) {
				if (typeof string !== 'string') {
						throw new TypeError('Not a string');
				}
				var i = 0;
				var arr = [];
				var codePoint;
				while(!!(codePoint = getCodePointData(string, i))){
						arr.push(codePoint.code);
						i += codePoint.long ? 2 : 1;
				}
				return arr;
		},
		getSymbols (string) {
				if (typeof string !== 'string') {
						throw new TypeError('Not a string');
				}
				var index = 0;
				var length = string.length;
				var output = [];
				var take = 0;
				var ch;
				while(index < length){
						take += numCharsToTakeForNextSymbol(string, index + take);
						ch = string[index + take];
						if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
								ch = string[index + take++];
						}
						if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
								ch = string[index + take++];
						}
						if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
								ch = string[index + take++];
								continue;
						}
						var char = string.substring(index, index + take);
						output.push(char);
						index += take;
						take = 0;
				}
				return output;
		},
		fromCodePoint () {
				var chars = [];
				var current;
				var codePoint;
				var units;
				for(var i = 0; i < arguments.length; ++i){
						current = Number(arguments[i]);
						codePoint = current - 0x10000;
						units = current > 0xFFFF ? [
								(codePoint >> 10) + 0xD800,
								codePoint % 0x400 + 0xDC00
						] : [
								current
						];
						chars.push(String.fromCharCode.apply(null, units));
				}
				return chars.join('');
		}
};

class EventHandle {
		off() {
				if (this._removed) return;
				this.handler.offByHandle(this);
		}
		on(name, callback, scope) {
				if (scope === void 0) scope = this;
				return this.handler._addCallback(name, callback, scope, false);
		}
		once(name, callback, scope) {
				if (scope === void 0) scope = this;
				return this.handler._addCallback(name, callback, scope, true);
		}
		set removed(value) {
				if (!value) return;
				this._removed = true;
		}
		get removed() {
				return this._removed;
		}
		constructor(handler, name, callback, scope, once = false){
				this._removed = false;
				this.handler = handler;
				this.name = name;
				this.callback = callback;
				this.scope = scope;
				this._once = once;
		}
}

class EventHandler {
		initEventHandler() {
				this._callbacks = new Map();
				this._callbackActive = new Map();
		}
		_addCallback(name, callback, scope, once) {
				if (!this._callbacks.has(name)) {
						this._callbacks.set(name, []);
				}
				if (this._callbackActive.has(name)) {
						var callbackActive = this._callbackActive.get(name);
						if (callbackActive && callbackActive === this._callbacks.get(name)) {
								this._callbackActive.set(name, callbackActive.slice());
						}
				}
				var evt = new EventHandle(this, name, callback, scope, once);
				this._callbacks.get(name).push(evt);
				return evt;
		}
		on(name, callback, scope) {
				if (scope === void 0) scope = this;
				return this._addCallback(name, callback, scope, false);
		}
		once(name, callback, scope) {
				if (scope === void 0) scope = this;
				return this._addCallback(name, callback, scope, true);
		}
		off(name, callback, scope) {
				if (name) {
						if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
								this._callbackActive.set(name, this._callbackActive.get(name).slice());
						}
				} else {
						for (var [key, callbacks] of this._callbackActive){
								if (!this._callbacks.has(key)) {
										continue;
								}
								if (this._callbacks.get(key) !== callbacks) {
										continue;
								}
								this._callbackActive.set(key, callbacks.slice());
						}
				}
				if (!name) {
						for (var callbacks1 of this._callbacks.values()){
								for(var i = 0; i < callbacks1.length; i++){
										callbacks1[i].removed = true;
								}
						}
						this._callbacks.clear();
				} else if (!callback) {
						var callbacks2 = this._callbacks.get(name);
						if (callbacks2) {
								for(var i1 = 0; i1 < callbacks2.length; i1++){
										callbacks2[i1].removed = true;
								}
								this._callbacks.delete(name);
						}
				} else {
						var callbacks3 = this._callbacks.get(name);
						if (!callbacks3) {
								return this;
						}
						for(var i2 = 0; i2 < callbacks3.length; i2++){
								if (callbacks3[i2].callback !== callback) {
										continue;
								}
								if (scope && callbacks3[i2].scope !== scope) {
										continue;
								}
								callbacks3[i2].removed = true;
								callbacks3.splice(i2, 1);
								i2--;
						}
						if (callbacks3.length === 0) {
								this._callbacks.delete(name);
						}
				}
				return this;
		}
		offByHandle(handle) {
				var name = handle.name;
				handle.removed = true;
				if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
						this._callbackActive.set(name, this._callbackActive.get(name).slice());
				}
				var callbacks = this._callbacks.get(name);
				if (!callbacks) {
						return this;
				}
				var ind = callbacks.indexOf(handle);
				if (ind !== -1) {
						callbacks.splice(ind, 1);
						if (callbacks.length === 0) {
								this._callbacks.delete(name);
						}
				}
				return this;
		}
		fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
				if (!name) {
						return this;
				}
				var callbacksInitial = this._callbacks.get(name);
				if (!callbacksInitial) {
						return this;
				}
				var callbacks;
				if (!this._callbackActive.has(name)) {
						this._callbackActive.set(name, callbacksInitial);
				} else if (this._callbackActive.get(name) !== callbacksInitial) {
						callbacks = callbacksInitial.slice();
				}
				for(var i = 0; (callbacks || this._callbackActive.get(name)) && i < (callbacks || this._callbackActive.get(name)).length; i++){
						var evt = (callbacks || this._callbackActive.get(name))[i];
						if (!evt.callback) continue;
						evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
						if (evt._once) {
								var existingCallback = this._callbacks.get(name);
								var ind = existingCallback ? existingCallback.indexOf(evt) : -1;
								if (ind !== -1) {
										if (this._callbackActive.get(name) === existingCallback) {
												this._callbackActive.set(name, this._callbackActive.get(name).slice());
										}
										var callbacks1 = this._callbacks.get(name);
										if (!callbacks1) continue;
										callbacks1[ind].removed = true;
										callbacks1.splice(ind, 1);
										if (callbacks1.length === 0) {
												this._callbacks.delete(name);
										}
								}
						}
				}
				if (!callbacks) {
						this._callbackActive.delete(name);
				}
				return this;
		}
		hasEvent(name) {
				var _this__callbacks_get;
				return !!((_this__callbacks_get = this._callbacks.get(name)) == null ? void 0 : _this__callbacks_get.length);
		}
		constructor(){
				this._callbacks = new Map();
				this._callbackActive = new Map();
		}
}

class IndexedList {
		push(key, item) {
				if (this._index[key]) {
						throw Error("Key already in index " + key);
				}
				var location = this._list.push(item) - 1;
				this._index[key] = location;
		}
		has(key) {
				return this._index[key] !== undefined;
		}
		get(key) {
				var location = this._index[key];
				if (location !== undefined) {
						return this._list[location];
				}
				return null;
		}
		remove(key) {
				var location = this._index[key];
				if (location !== undefined) {
						this._list.splice(location, 1);
						delete this._index[key];
						for(key in this._index){
								var idx = this._index[key];
								if (idx > location) {
										this._index[key] = idx - 1;
								}
						}
						return true;
				}
				return false;
		}
		list() {
				return this._list;
		}
		clear() {
				this._list.length = 0;
				for(var prop in this._index){
						delete this._index[prop];
				}
		}
		constructor(){
				this._list = [];
				this._index = {};
		}
}

var cachedResult = (func)=>{
		var uninitToken = {};
		var result = uninitToken;
		return ()=>{
				if (result === uninitToken) {
						result = func();
				}
				return result;
		};
};
class Impl {
		static loadScript(url, callback) {
				var s = document.createElement("script");
				s.setAttribute('src', url);
				s.onload = ()=>{
						callback(null);
				};
				s.onerror = ()=>{
						callback("Failed to load script='" + url + "'");
				};
				document.body.appendChild(s);
		}
		static loadWasm(moduleName, config, callback) {
				var loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;
				if (loadUrl) {
						Impl.loadScript(loadUrl, (err)=>{
								if (err) {
										callback(err, null);
								} else {
										var module = window[moduleName];
										window[moduleName] = undefined;
										module({
												locateFile: ()=>config.wasmUrl,
												onAbort: ()=>{
														callback('wasm module aborted.');
												}
										}).then((instance)=>{
												callback(null, instance);
										});
								}
						});
				} else {
						callback('No supported wasm modules found.', null);
				}
		}
		static getModule(name) {
				if (!Impl.modules.hasOwnProperty(name)) {
						Impl.modules[name] = {
								config: null,
								initializing: false,
								instance: null,
								callbacks: []
						};
				}
				return Impl.modules[name];
		}
		static initialize(moduleName, module) {
				if (module.initializing) {
						return;
				}
				var config = module.config;
				if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
						module.initializing = true;
						Impl.loadWasm(moduleName, config, (err, instance)=>{
								if (err) {
										if (config.errorHandler) {
												config.errorHandler(err);
										} else {
												console.error("failed to initialize module=" + moduleName + " error=" + err);
										}
								} else {
										module.instance = instance;
										module.callbacks.forEach((callback)=>{
												callback(instance);
										});
								}
						});
				}
		}
}
Impl.modules = {};
Impl.wasmSupported = cachedResult(()=>{
		try {
				if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
						var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
						if (module instanceof WebAssembly.Module) {
								return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
						}
				}
		} catch (e) {}
		return false;
});
class WasmModule {
		static setConfig(moduleName, config) {
				var module = Impl.getModule(moduleName);
				module.config = config;
				if (module.callbacks.length > 0) {
						Impl.initialize(moduleName, module);
				}
		}
		static getConfig(moduleName) {
				var _Impl_modules_moduleName, _Impl_modules;
				return (_Impl_modules = Impl.modules) == null ? void 0 : (_Impl_modules_moduleName = _Impl_modules[moduleName]) == null ? void 0 : _Impl_modules_moduleName.config;
		}
		static getInstance(moduleName, callback) {
				var module = Impl.getModule(moduleName);
				if (module.instance) {
						callback(module.instance);
				} else {
						module.callbacks.push(callback);
						if (module.config) {
								Impl.initialize(moduleName, module);
						}
				}
		}
}

class ReadStream {
		get remainingBytes() {
				return this.dataView.byteLength - this.offset;
		}
		reset(offset) {
				if (offset === void 0) offset = 0;
				this.offset = offset;
		}
		skip(bytes) {
				this.offset += bytes;
		}
		align(bytes) {
				this.offset = this.offset + bytes - 1 & ~(bytes - 1);
		}
		_inc(amount) {
				this.offset += amount;
				return this.offset - amount;
		}
		readChar() {
				return String.fromCharCode(this.dataView.getUint8(this.offset++));
		}
		readChars(numChars) {
				var result = '';
				for(var i = 0; i < numChars; ++i){
						result += this.readChar();
				}
				return result;
		}
		readU8() {
				return this.dataView.getUint8(this.offset++);
		}
		readU16() {
				return this.dataView.getUint16(this._inc(2), true);
		}
		readU32() {
				return this.dataView.getUint32(this._inc(4), true);
		}
		readU64() {
				return this.readU32() + 2 ** 32 * this.readU32();
		}
		readU32be() {
				return this.dataView.getUint32(this._inc(4), false);
		}
		readArray(result) {
				for(var i = 0; i < result.length; ++i){
						result[i] = this.readU8();
				}
		}
		readLine() {
				var view = this.dataView;
				var result = '';
				while(true){
						if (this.offset >= view.byteLength) {
								break;
						}
						var c = String.fromCharCode(this.readU8());
						if (c === '\n') {
								break;
						}
						result += c;
				}
				return result;
		}
		constructor(arraybuffer){
				this.offset = 0;
				this.arraybuffer = arraybuffer;
				this.dataView = new DataView(arraybuffer);
		}
}

class SortedLoopArray {
		_binarySearch(item) {
				var left = 0;
				var right = this.items.length - 1;
				var search = item[this._sortBy];
				var middle;
				var current;
				while(left <= right){
						middle = Math.floor((left + right) / 2);
						current = this.items[middle][this._sortBy];
						if (current <= search) {
								left = middle + 1;
						} else if (current > search) {
								right = middle - 1;
						}
				}
				return left;
		}
		_doSort(a, b) {
				var sortBy = this._sortBy;
				return a[sortBy] - b[sortBy];
		}
		insert(item) {
				var index = this._binarySearch(item);
				this.items.splice(index, 0, item);
				this.length++;
				if (this.loopIndex >= index) {
						this.loopIndex++;
				}
		}
		append(item) {
				this.items.push(item);
				this.length++;
		}
		remove(item) {
				var idx = this.items.indexOf(item);
				if (idx < 0) return;
				this.items.splice(idx, 1);
				this.length--;
				if (this.loopIndex >= idx) {
						this.loopIndex--;
				}
		}
		sort() {
				var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
				this.items.sort(this._sortHandler);
				if (current !== null) {
						this.loopIndex = this.items.indexOf(current);
				}
		}
		constructor(args){
				this.items = [];
				this.length = 0;
				this.loopIndex = -1;
				this._sortBy = args.sortBy;
				this._sortHandler = this._doSort.bind(this);
		}
}

class Tags extends EventHandler {
		add() {
				for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
						args[_key] = arguments[_key];
				}
				var changed = false;
				var tags = this._processArguments(args, true);
				if (!tags.length) {
						return changed;
				}
				for(var i = 0; i < tags.length; i++){
						if (this._index[tags[i]]) {
								continue;
						}
						changed = true;
						this._index[tags[i]] = true;
						this._list.push(tags[i]);
						this.fire('add', tags[i], this._parent);
				}
				if (changed) {
						this.fire('change', this._parent);
				}
				return changed;
		}
		remove() {
				for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
						args[_key] = arguments[_key];
				}
				var changed = false;
				if (!this._list.length) {
						return changed;
				}
				var tags = this._processArguments(args, true);
				if (!tags.length) {
						return changed;
				}
				for(var i = 0; i < tags.length; i++){
						if (!this._index[tags[i]]) {
								continue;
						}
						changed = true;
						delete this._index[tags[i]];
						this._list.splice(this._list.indexOf(tags[i]), 1);
						this.fire('remove', tags[i], this._parent);
				}
				if (changed) {
						this.fire('change', this._parent);
				}
				return changed;
		}
		clear() {
				if (!this._list.length) {
						return;
				}
				var tags = this._list.slice(0);
				this._list = [];
				this._index = {};
				for(var i = 0; i < tags.length; i++){
						this.fire('remove', tags[i], this._parent);
				}
				this.fire('change', this._parent);
		}
		has() {
				for(var _len = arguments.length, query = new Array(_len), _key = 0; _key < _len; _key++){
						query[_key] = arguments[_key];
				}
				if (!this._list.length) {
						return false;
				}
				return this._has(this._processArguments(query));
		}
		_has(tags) {
				if (!this._list.length || !tags.length) {
						return false;
				}
				for(var i = 0; i < tags.length; i++){
						if (tags[i].length === 1) {
								if (this._index[tags[i][0]]) {
										return true;
								}
						} else {
								var multiple = true;
								for(var t = 0; t < tags[i].length; t++){
										if (this._index[tags[i][t]]) {
												continue;
										}
										multiple = false;
										break;
								}
								if (multiple) {
										return true;
								}
						}
				}
				return false;
		}
		list() {
				return this._list.slice(0);
		}
		_processArguments(args, flat) {
				var tags = [];
				var tmp = [];
				if (!args || !args.length) {
						return tags;
				}
				for(var i = 0; i < args.length; i++){
						if (args[i] instanceof Array) {
								if (!flat) {
										tmp = [];
								}
								for(var t = 0; t < args[i].length; t++){
										if (typeof args[i][t] !== 'string') {
												continue;
										}
										if (flat) {
												tags.push(args[i][t]);
										} else {
												tmp.push(args[i][t]);
										}
								}
								if (!flat && tmp.length) {
										tags.push(tmp);
								}
						} else if (typeof args[i] === 'string') {
								if (flat) {
										tags.push(args[i]);
								} else {
										tags.push([
												args[i]
										]);
								}
						}
				}
				return tags;
		}
		get size() {
				return this._list.length;
		}
		constructor(parent){
				super(), this._index = {}, this._list = [];
				this._parent = parent;
		}
}
Tags.EVENT_ADD = 'add';
Tags.EVENT_REMOVE = 'remove';
Tags.EVENT_CHANGE = 'change';

var now = typeof window !== 'undefined' && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now;

function createURI(options) {
		var s = '';
		if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
				throw new Error('Can\'t have \'scheme\' or \'authority\' and \'host\' or \'hostpath\' option');
		}
		if (options.host && options.hostpath) {
				throw new Error('Can\'t have \'host\' and \'hostpath\' option');
		}
		if (options.path && options.hostpath) {
				throw new Error('Can\'t have \'path\' and \'hostpath\' option');
		}
		if (options.scheme) {
				s += "" + options.scheme + ":";
		}
		if (options.authority) {
				s += "//" + options.authority;
		}
		if (options.host) {
				s += options.host;
		}
		if (options.path) {
				s += options.path;
		}
		if (options.hostpath) {
				s += options.hostpath;
		}
		if (options.query) {
				s += "?" + options.query;
		}
		if (options.fragment) {
				s += "#" + options.fragment;
		}
		return s;
}
var re = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class URI {
		toString() {
				var s = '';
				if (this.scheme) {
						s += "" + this.scheme + ":";
				}
				if (this.authority) {
						s += "//" + this.authority;
				}
				s += this.path;
				if (this.query) {
						s += "?" + this.query;
				}
				if (this.fragment) {
						s += "#" + this.fragment;
				}
				return s;
		}
		getQuery() {
				var result = {};
				if (this.query) {
						var queryParams = decodeURIComponent(this.query).split('&');
						for (var queryParam of queryParams){
								var pair = queryParam.split('=');
								result[pair[0]] = pair[1];
						}
				}
				return result;
		}
		setQuery(params) {
				var q = '';
				for(var key in params){
						if (params.hasOwnProperty(key)) {
								if (q !== '') {
										q += '&';
								}
								q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
						}
				}
				this.query = q;
		}
		constructor(uri){
				var result = uri.match(re);
				this.scheme = result[2];
				this.authority = result[4];
				this.path = result[5];
				this.query = result[7];
				this.fragment = result[9];
		}
}

class Tracing {
		static set(channel, enabled) {
		}
		static get(channel) {
				return Tracing._traceChannels.has(channel);
		}
}
Tracing._traceChannels = new Set();
Tracing.stack = false;

var CURVE_LINEAR = 0;
var CURVE_SMOOTHSTEP = 1;
var CURVE_SPLINE = 4;
var CURVE_STEP = 5;

var math = {
		DEG_TO_RAD: Math.PI / 180,
		RAD_TO_DEG: 180 / Math.PI,
		clamp (value, min, max) {
				if (value >= max) return max;
				if (value <= min) return min;
				return value;
		},
		intToBytes24 (i) {
				var r = i >> 16 & 0xff;
				var g = i >> 8 & 0xff;
				var b = i & 0xff;
				return [
						r,
						g,
						b
				];
		},
		intToBytes32 (i) {
				var r = i >> 24 & 0xff;
				var g = i >> 16 & 0xff;
				var b = i >> 8 & 0xff;
				var a = i & 0xff;
				return [
						r,
						g,
						b,
						a
				];
		},
		bytesToInt24 (r, g, b) {
				if (r.length) {
						b = r[2];
						g = r[1];
						r = r[0];
				}
				return r << 16 | g << 8 | b;
		},
		bytesToInt32 (r, g, b, a) {
				if (r.length) {
						a = r[3];
						b = r[2];
						g = r[1];
						r = r[0];
				}
				return (r << 24 | g << 16 | b << 8 | a) >>> 0;
		},
		lerp (a, b, alpha) {
				return a + (b - a) * math.clamp(alpha, 0, 1);
		},
		lerpAngle (a, b, alpha) {
				if (b - a > 180) {
						b -= 360;
				}
				if (b - a < -180) {
						b += 360;
				}
				return math.lerp(a, b, math.clamp(alpha, 0, 1));
		},
		powerOfTwo (x) {
				return x !== 0 && !(x & x - 1);
		},
		nextPowerOfTwo (val) {
				val--;
				val |= val >> 1;
				val |= val >> 2;
				val |= val >> 4;
				val |= val >> 8;
				val |= val >> 16;
				val++;
				return val;
		},
		nearestPowerOfTwo (val) {
				return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
		},
		random (min, max) {
				var diff = max - min;
				return Math.random() * diff + min;
		},
		smoothstep (min, max, x) {
				if (x <= min) return 0;
				if (x >= max) return 1;
				x = (x - min) / (max - min);
				return x * x * (3 - 2 * x);
		},
		smootherstep (min, max, x) {
				if (x <= min) return 0;
				if (x >= max) return 1;
				x = (x - min) / (max - min);
				return x * x * x * (x * (x * 6 - 15) + 10);
		},
		roundUp (numToRound, multiple) {
				if (multiple === 0) {
						return numToRound;
				}
				return Math.ceil(numToRound / multiple) * multiple;
		},
		between (num, a, b, inclusive) {
				var min = Math.min(a, b);
				var max = Math.max(a, b);
				return inclusive ? num >= min && num <= max : num > min && num < max;
		}
};

class Color {
		clone() {
				var cstr = this.constructor;
				return new cstr(this.r, this.g, this.b, this.a);
		}
		copy(rhs) {
				this.r = rhs.r;
				this.g = rhs.g;
				this.b = rhs.b;
				this.a = rhs.a;
				return this;
		}
		equals(rhs) {
				return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
		}
		set(r, g, b, a) {
				if (a === void 0) a = 1;
				this.r = r;
				this.g = g;
				this.b = b;
				this.a = a;
				return this;
		}
		lerp(lhs, rhs, alpha) {
				this.r = lhs.r + alpha * (rhs.r - lhs.r);
				this.g = lhs.g + alpha * (rhs.g - lhs.g);
				this.b = lhs.b + alpha * (rhs.b - lhs.b);
				this.a = lhs.a + alpha * (rhs.a - lhs.a);
				return this;
		}
		linear(src) {
				if (src === void 0) src = this;
				this.r = Math.pow(src.r, 2.2);
				this.g = Math.pow(src.g, 2.2);
				this.b = Math.pow(src.b, 2.2);
				this.a = src.a;
				return this;
		}
		gamma(src) {
				if (src === void 0) src = this;
				this.r = Math.pow(src.r, 1 / 2.2);
				this.g = Math.pow(src.g, 1 / 2.2);
				this.b = Math.pow(src.b, 1 / 2.2);
				this.a = src.a;
				return this;
		}
		mulScalar(scalar) {
				this.r *= scalar;
				this.g *= scalar;
				this.b *= scalar;
				return this;
		}
		fromString(hex) {
				var i = parseInt(hex.replace('#', '0x'), 16);
				var bytes;
				if (hex.length > 7) {
						bytes = math.intToBytes32(i);
				} else {
						bytes = math.intToBytes24(i);
						bytes[3] = 255;
				}
				this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
				return this;
		}
		fromArray(arr, offset) {
				if (offset === void 0) offset = 0;
				var _arr_offset;
				this.r = (_arr_offset = arr[offset]) != null ? _arr_offset : this.r;
				var _arr_;
				this.g = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.g;
				var _arr_1;
				this.b = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.b;
				var _arr_2;
				this.a = (_arr_2 = arr[offset + 3]) != null ? _arr_2 : this.a;
				return this;
		}
		toString(alpha, asArray) {
				var { r, g, b, a } = this;
				if (asArray || r > 1 || g > 1 || b > 1) {
						return r.toFixed(3) + ", " + g.toFixed(3) + ", " + b.toFixed(3) + ", " + a.toFixed(3);
				}
				var s = "#" + ((1 << 24) + (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
				if (alpha === true) {
						var aa = Math.round(a * 255).toString(16);
						if (this.a < 16 / 255) {
								s += "0" + aa;
						} else {
								s += aa;
						}
				}
				return s;
		}
		toArray(arr, offset, alpha) {
				if (arr === void 0) arr = [];
				if (offset === void 0) offset = 0;
				if (alpha === void 0) alpha = true;
				arr[offset] = this.r;
				arr[offset + 1] = this.g;
				arr[offset + 2] = this.b;
				if (alpha) {
						arr[offset + 3] = this.a;
				}
				return arr;
		}
		constructor(r = 0, g = 0, b = 0, a = 1){
				var length = r.length;
				if (length === 3 || length === 4) {
						this.r = r[0];
						this.g = r[1];
						this.b = r[2];
						var _r_;
						this.a = (_r_ = r[3]) != null ? _r_ : 1;
				} else {
						this.r = r;
						this.g = g;
						this.b = b;
						this.a = a;
				}
		}
}
Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
Color.RED = Object.freeze(new Color(1, 0, 0, 1));
Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));

class CurveEvaluator {
		evaluate(time, forceReset) {
				if (forceReset === void 0) forceReset = false;
				if (forceReset || time < this._left || time >= this._right) {
						this._reset(time);
				}
				var result;
				var type = this._curve.type;
				if (type === CURVE_STEP) {
						result = this._p0;
				} else {
						var t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
						if (type === CURVE_LINEAR) {
								result = math.lerp(this._p0, this._p1, t);
						} else if (type === CURVE_SMOOTHSTEP) {
								result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
						} else {
								result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
						}
				}
				return result;
		}
		_reset(time) {
				var keys = this._curve.keys;
				var len = keys.length;
				if (!len) {
						this._left = -Infinity;
						this._right = Infinity;
						this._recip = 0;
						this._p0 = this._p1 = this._m0 = this._m1 = 0;
				} else {
						if (time < keys[0][0]) {
								this._left = -Infinity;
								this._right = keys[0][0];
								this._recip = 0;
								this._p0 = this._p1 = keys[0][1];
								this._m0 = this._m1 = 0;
						} else if (time >= keys[len - 1][0]) {
								this._left = keys[len - 1][0];
								this._right = Infinity;
								this._recip = 0;
								this._p0 = this._p1 = keys[len - 1][1];
								this._m0 = this._m1 = 0;
						} else {
								var index = 0;
								while(time >= keys[index + 1][0]){
										index++;
								}
								this._left = keys[index][0];
								this._right = keys[index + 1][0];
								var diff = 1.0 / (this._right - this._left);
								this._recip = isFinite(diff) ? diff : 0;
								this._p0 = keys[index][1];
								this._p1 = keys[index + 1][1];
								if (this._curve.type === CURVE_SPLINE) {
										this._calcTangents(keys, index);
								}
						}
				}
		}
		_calcTangents(keys, index) {
				var a;
				var b = keys[index];
				var c = keys[index + 1];
				var d;
				if (index === 0) {
						a = [
								keys[0][0] + (keys[0][0] - keys[1][0]),
								keys[0][1] + (keys[0][1] - keys[1][1])
						];
				} else {
						a = keys[index - 1];
				}
				if (index === keys.length - 2) {
						d = [
								keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]),
								keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])
						];
				} else {
						d = keys[index + 2];
				}
				if (this._curve.type === CURVE_SPLINE) {
						var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
						var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
						this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
						this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
				} else {
						var s1 = (c[0] - b[0]) / (b[0] - a[0]);
						var s2 = (c[0] - b[0]) / (d[0] - c[0]);
						var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
						var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
						var tension = this._curve.tension;
						this._m0 = tension * (c[1] - a_);
						this._m1 = tension * (d_ - b[1]);
				}
		}
		_evaluateHermite(p0, p1, m0, m1, t) {
				var t2 = t * t;
				var twot = t + t;
				var omt = 1 - t;
				var omt2 = omt * omt;
				return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
		}
		constructor(curve, time = 0){
				this._left = -Infinity;
				this._right = Infinity;
				this._recip = 0;
				this._p0 = 0;
				this._p1 = 0;
				this._m0 = 0;
				this._m1 = 0;
				this._curve = curve;
				this._reset(time);
		}
}

class Curve {
		get length() {
				return this.keys.length;
		}
		add(time, value) {
				var keys = this.keys;
				var len = keys.length;
				var i = 0;
				for(; i < len; i++){
						if (keys[i][0] > time) {
								break;
						}
				}
				var key = [
						time,
						value
				];
				this.keys.splice(i, 0, key);
				return key;
		}
		get(index) {
				return this.keys[index];
		}
		sort() {
				this.keys.sort((a, b)=>a[0] - b[0]);
		}
		value(time) {
				return this._eval.evaluate(time, true);
		}
		closest(time) {
				var keys = this.keys;
				var length = keys.length;
				var min = 2;
				var result = null;
				for(var i = 0; i < length; i++){
						var diff = Math.abs(time - keys[i][0]);
						if (min >= diff) {
								min = diff;
								result = keys[i];
						} else {
								break;
						}
				}
				return result;
		}
		clone() {
				var result = new this.constructor();
				result.keys = this.keys.map((key)=>[
								...key
						]);
				result.type = this.type;
				result.tension = this.tension;
				return result;
		}
		quantize(precision) {
				precision = Math.max(precision, 2);
				var values = new Float32Array(precision);
				var step = 1.0 / (precision - 1);
				values[0] = this._eval.evaluate(0, true);
				for(var i = 1; i < precision; i++){
						values[i] = this._eval.evaluate(step * i);
				}
				return values;
		}
		quantizeClamped(precision, min, max) {
				var result = this.quantize(precision);
				for(var i = 0; i < result.length; ++i){
						result[i] = Math.min(max, Math.max(min, result[i]));
				}
				return result;
		}
		constructor(data){
				this.keys = [];
				this.type = CURVE_SMOOTHSTEP;
				this.tension = 0.5;
				this._eval = new CurveEvaluator(this);
				if (data) {
						for(var i = 0; i < data.length - 1; i += 2){
								this.keys.push([
										data[i],
										data[i + 1]
								]);
						}
				}
				this.sort();
		}
}

class CurveSet {
		get length() {
				return this.curves.length;
		}
		set type(value) {
				this._type = value;
				for(var i = 0; i < this.curves.length; i++){
						this.curves[i].type = value;
				}
		}
		get type() {
				return this._type;
		}
		get(index) {
				return this.curves[index];
		}
		value(time, result) {
				if (result === void 0) result = [];
				var length = this.curves.length;
				result.length = length;
				for(var i = 0; i < length; i++){
						result[i] = this.curves[i].value(time);
				}
				return result;
		}
		clone() {
				var result = new this.constructor();
				result.curves = [];
				for(var i = 0; i < this.curves.length; i++){
						result.curves.push(this.curves[i].clone());
				}
				result._type = this._type;
				return result;
		}
		quantize(precision) {
				precision = Math.max(precision, 2);
				var numCurves = this.curves.length;
				var values = new Float32Array(precision * numCurves);
				var step = 1.0 / (precision - 1);
				for(var c = 0; c < numCurves; c++){
						var ev = new CurveEvaluator(this.curves[c]);
						for(var i = 0; i < precision; i++){
								values[i * numCurves + c] = ev.evaluate(step * i);
						}
				}
				return values;
		}
		quantizeClamped(precision, min, max) {
				var result = this.quantize(precision);
				for(var i = 0; i < result.length; ++i){
						result[i] = Math.min(max, Math.max(min, result[i]));
				}
				return result;
		}
		constructor(){
				this.curves = [];
				this._type = CURVE_SMOOTHSTEP;
				if (arguments.length > 1) {
						for(var i = 0; i < arguments.length; i++){
								this.curves.push(new Curve(arguments[i]));
						}
				} else {
						if (arguments.length === 0) {
								this.curves.push(new Curve());
						} else {
								var arg = arguments[0];
								if (typeof arg === 'number') {
										for(var i1 = 0; i1 < arg; i1++){
												this.curves.push(new Curve());
										}
								} else {
										for(var i2 = 0; i2 < arg.length; i2++){
												this.curves.push(new Curve(arg[i2]));
										}
								}
						}
				}
		}
}

var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
class FloatPacking {
		static float2Half(value) {
				floatView[0] = value;
				var x = int32View[0];
				var bits = x >> 16 & 0x8000;
				var m = x >> 12 & 0x07ff;
				var e = x >> 23 & 0xff;
				if (e < 103) {
						return bits;
				}
				if (e > 142) {
						bits |= 0x7c00;
						bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
						return bits;
				}
				if (e < 113) {
						m |= 0x0800;
						bits |= (m >> 114 - e) + (m >> 113 - e & 1);
						return bits;
				}
				bits |= e - 112 << 10 | m >> 1;
				bits += m & 1;
				return bits;
		}
		static float2RGBA8(value, data) {
				floatView[0] = value;
				var intBits = int32View[0];
				data.r = (intBits >> 24 & 0xFF) / 255.0;
				data.g = (intBits >> 16 & 0xFF) / 255.0;
				data.b = (intBits >> 8 & 0xFF) / 255.0;
				data.a = (intBits & 0xFF) / 255.0;
		}
}

class Kernel {
		static concentric(numRings, numPoints) {
				var kernel = [];
				kernel.push(0, 0);
				var spacing = 2 * Math.PI / numRings / numPoints;
				for(var ring = 1; ring <= numRings; ring++){
						var radius = ring / numRings;
						var circumference = 2 * Math.PI * radius;
						var pointsPerRing = Math.max(1, Math.floor(circumference / spacing));
						var angleStep = 2 * Math.PI / pointsPerRing;
						for(var point = 0; point < pointsPerRing; point++){
								var angle = point * angleStep;
								var x = radius * Math.cos(angle);
								var y = radius * Math.sin(angle);
								kernel.push(x, y);
						}
				}
				return kernel;
		}
}

class Vec3 {
		add(rhs) {
				this.x += rhs.x;
				this.y += rhs.y;
				this.z += rhs.z;
				return this;
		}
		add2(lhs, rhs) {
				this.x = lhs.x + rhs.x;
				this.y = lhs.y + rhs.y;
				this.z = lhs.z + rhs.z;
				return this;
		}
		addScalar(scalar) {
				this.x += scalar;
				this.y += scalar;
				this.z += scalar;
				return this;
		}
		addScaled(rhs, scalar) {
				this.x += rhs.x * scalar;
				this.y += rhs.y * scalar;
				this.z += rhs.z * scalar;
				return this;
		}
		clone() {
				var cstr = this.constructor;
				return new cstr(this.x, this.y, this.z);
		}
		copy(rhs) {
				this.x = rhs.x;
				this.y = rhs.y;
				this.z = rhs.z;
				return this;
		}
		cross(lhs, rhs) {
				var lx = lhs.x;
				var ly = lhs.y;
				var lz = lhs.z;
				var rx = rhs.x;
				var ry = rhs.y;
				var rz = rhs.z;
				this.x = ly * rz - ry * lz;
				this.y = lz * rx - rz * lx;
				this.z = lx * ry - rx * ly;
				return this;
		}
		distance(rhs) {
				var x = this.x - rhs.x;
				var y = this.y - rhs.y;
				var z = this.z - rhs.z;
				return Math.sqrt(x * x + y * y + z * z);
		}
		div(rhs) {
				this.x /= rhs.x;
				this.y /= rhs.y;
				this.z /= rhs.z;
				return this;
		}
		div2(lhs, rhs) {
				this.x = lhs.x / rhs.x;
				this.y = lhs.y / rhs.y;
				this.z = lhs.z / rhs.z;
				return this;
		}
		divScalar(scalar) {
				this.x /= scalar;
				this.y /= scalar;
				this.z /= scalar;
				return this;
		}
		dot(rhs) {
				return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		}
		equals(rhs) {
				return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
		}
		equalsApprox(rhs, epsilon) {
				if (epsilon === void 0) epsilon = 1e-6;
				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon;
		}
		length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}
		lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z;
		}
		lerp(lhs, rhs, alpha) {
				this.x = lhs.x + alpha * (rhs.x - lhs.x);
				this.y = lhs.y + alpha * (rhs.y - lhs.y);
				this.z = lhs.z + alpha * (rhs.z - lhs.z);
				return this;
		}
		mul(rhs) {
				this.x *= rhs.x;
				this.y *= rhs.y;
				this.z *= rhs.z;
				return this;
		}
		mul2(lhs, rhs) {
				this.x = lhs.x * rhs.x;
				this.y = lhs.y * rhs.y;
				this.z = lhs.z * rhs.z;
				return this;
		}
		mulScalar(scalar) {
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				return this;
		}
		normalize(src) {
				if (src === void 0) src = this;
				var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z;
				if (lengthSq > 0) {
						var invLength = 1 / Math.sqrt(lengthSq);
						this.x = src.x * invLength;
						this.y = src.y * invLength;
						this.z = src.z * invLength;
				}
				return this;
		}
		floor(src) {
				if (src === void 0) src = this;
				this.x = Math.floor(src.x);
				this.y = Math.floor(src.y);
				this.z = Math.floor(src.z);
				return this;
		}
		ceil(src) {
				if (src === void 0) src = this;
				this.x = Math.ceil(src.x);
				this.y = Math.ceil(src.y);
				this.z = Math.ceil(src.z);
				return this;
		}
		round(src) {
				if (src === void 0) src = this;
				this.x = Math.round(src.x);
				this.y = Math.round(src.y);
				this.z = Math.round(src.z);
				return this;
		}
		min(rhs) {
				if (rhs.x < this.x) this.x = rhs.x;
				if (rhs.y < this.y) this.y = rhs.y;
				if (rhs.z < this.z) this.z = rhs.z;
				return this;
		}
		max(rhs) {
				if (rhs.x > this.x) this.x = rhs.x;
				if (rhs.y > this.y) this.y = rhs.y;
				if (rhs.z > this.z) this.z = rhs.z;
				return this;
		}
		project(rhs) {
				var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
				var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
				var s = a_dot_b / b_dot_b;
				this.x = rhs.x * s;
				this.y = rhs.y * s;
				this.z = rhs.z * s;
				return this;
		}
		set(x, y, z) {
				this.x = x;
				this.y = y;
				this.z = z;
				return this;
		}
		sub(rhs) {
				this.x -= rhs.x;
				this.y -= rhs.y;
				this.z -= rhs.z;
				return this;
		}
		sub2(lhs, rhs) {
				this.x = lhs.x - rhs.x;
				this.y = lhs.y - rhs.y;
				this.z = lhs.z - rhs.z;
				return this;
		}
		subScalar(scalar) {
				this.x -= scalar;
				this.y -= scalar;
				this.z -= scalar;
				return this;
		}
		fromArray(arr, offset) {
				if (offset === void 0) offset = 0;
				var _arr_offset;
				this.x = (_arr_offset = arr[offset]) != null ? _arr_offset : this.x;
				var _arr_;
				this.y = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.y;
				var _arr_1;
				this.z = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.z;
				return this;
		}
		toString() {
				return "[" + this.x + ", " + this.y + ", " + this.z + "]";
		}
		toArray(arr, offset) {
				if (arr === void 0) arr = [];
				if (offset === void 0) offset = 0;
				arr[offset] = this.x;
				arr[offset + 1] = this.y;
				arr[offset + 2] = this.z;
				return arr;
		}
		constructor(x = 0, y = 0, z = 0){
				if (x.length === 3) {
						this.x = x[0];
						this.y = x[1];
						this.z = x[2];
				} else {
						this.x = x;
						this.y = y;
						this.z = z;
				}
		}
}
Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
Vec3.HALF = Object.freeze(new Vec3(0.5, 0.5, 0.5));
Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
Vec3.DOWN = Object.freeze(new Vec3(0, -1, 0));
Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
Vec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));
Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
Vec3.BACK = Object.freeze(new Vec3(0, 0, 1));

class Mat3 {
		clone() {
				var cstr = this.constructor;
				return new cstr().copy(this);
		}
		copy(rhs) {
				var src = rhs.data;
				var dst = this.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[3];
				dst[4] = src[4];
				dst[5] = src[5];
				dst[6] = src[6];
				dst[7] = src[7];
				dst[8] = src[8];
				return this;
		}
		set(src) {
				var dst = this.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[3];
				dst[4] = src[4];
				dst[5] = src[5];
				dst[6] = src[6];
				dst[7] = src[7];
				dst[8] = src[8];
				return this;
		}
		getX(x) {
				if (x === void 0) x = new Vec3();
				return x.set(this.data[0], this.data[1], this.data[2]);
		}
		getY(y) {
				if (y === void 0) y = new Vec3();
				return y.set(this.data[3], this.data[4], this.data[5]);
		}
		getZ(z) {
				if (z === void 0) z = new Vec3();
				return z.set(this.data[6], this.data[7], this.data[8]);
		}
		equals(rhs) {
				var l = this.data;
				var r = rhs.data;
				return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
		}
		isIdentity() {
				var m = this.data;
				return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
		}
		setIdentity() {
				var m = this.data;
				m[0] = 1;
				m[1] = 0;
				m[2] = 0;
				m[3] = 0;
				m[4] = 1;
				m[5] = 0;
				m[6] = 0;
				m[7] = 0;
				m[8] = 1;
				return this;
		}
		toString() {
				return "[" + this.data.join(', ') + "]";
		}
		transpose(src) {
				if (src === void 0) src = this;
				var s = src.data;
				var t = this.data;
				if (s === t) {
						var tmp;
						tmp = s[1];
						t[1] = s[3];
						t[3] = tmp;
						tmp = s[2];
						t[2] = s[6];
						t[6] = tmp;
						tmp = s[5];
						t[5] = s[7];
						t[7] = tmp;
				} else {
						t[0] = s[0];
						t[1] = s[3];
						t[2] = s[6];
						t[3] = s[1];
						t[4] = s[4];
						t[5] = s[7];
						t[6] = s[2];
						t[7] = s[5];
						t[8] = s[8];
				}
				return this;
		}
		setFromMat4(m) {
				var src = m.data;
				var dst = this.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[4];
				dst[4] = src[5];
				dst[5] = src[6];
				dst[6] = src[8];
				dst[7] = src[9];
				dst[8] = src[10];
				return this;
		}
		setFromQuat(r) {
				var qx = r.x;
				var qy = r.y;
				var qz = r.z;
				var qw = r.w;
				var x2 = qx + qx;
				var y2 = qy + qy;
				var z2 = qz + qz;
				var xx = qx * x2;
				var xy = qx * y2;
				var xz = qx * z2;
				var yy = qy * y2;
				var yz = qy * z2;
				var zz = qz * z2;
				var wx = qw * x2;
				var wy = qw * y2;
				var wz = qw * z2;
				var m = this.data;
				m[0] = 1 - (yy + zz);
				m[1] = xy + wz;
				m[2] = xz - wy;
				m[3] = xy - wz;
				m[4] = 1 - (xx + zz);
				m[5] = yz + wx;
				m[6] = xz + wy;
				m[7] = yz - wx;
				m[8] = 1 - (xx + yy);
				return this;
		}
		invertMat4(src) {
				var s = src.data;
				var a0 = s[0];
				var a1 = s[1];
				var a2 = s[2];
				var a4 = s[4];
				var a5 = s[5];
				var a6 = s[6];
				var a8 = s[8];
				var a9 = s[9];
				var a10 = s[10];
				var b11 = a10 * a5 - a6 * a9;
				var b21 = -a10 * a1 + a2 * a9;
				var b31 = a6 * a1 - a2 * a5;
				var b12 = -a10 * a4 + a6 * a8;
				var b22 = a10 * a0 - a2 * a8;
				var b32 = -a6 * a0 + a2 * a4;
				var b13 = a9 * a4 - a5 * a8;
				var b23 = -a9 * a0 + a1 * a8;
				var b33 = a5 * a0 - a1 * a4;
				var det = a0 * b11 + a1 * b12 + a2 * b13;
				if (det === 0) {
						this.setIdentity();
				} else {
						var invDet = 1 / det;
						var t = this.data;
						t[0] = b11 * invDet;
						t[1] = b21 * invDet;
						t[2] = b31 * invDet;
						t[3] = b12 * invDet;
						t[4] = b22 * invDet;
						t[5] = b32 * invDet;
						t[6] = b13 * invDet;
						t[7] = b23 * invDet;
						t[8] = b33 * invDet;
				}
				return this;
		}
		transformVector(vec, res) {
				if (res === void 0) res = new Vec3();
				var m = this.data;
				var { x, y, z } = vec;
				res.x = x * m[0] + y * m[3] + z * m[6];
				res.y = x * m[1] + y * m[4] + z * m[7];
				res.z = x * m[2] + y * m[5] + z * m[8];
				return res;
		}
		constructor(){
				this.data = new Float32Array(9);
				this.data[0] = this.data[4] = this.data[8] = 1;
		}
}
Mat3.IDENTITY = Object.freeze(new Mat3());
Mat3.ZERO = Object.freeze(new Mat3().set([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
]));

class Vec2 {
		add(rhs) {
				this.x += rhs.x;
				this.y += rhs.y;
				return this;
		}
		add2(lhs, rhs) {
				this.x = lhs.x + rhs.x;
				this.y = lhs.y + rhs.y;
				return this;
		}
		addScalar(scalar) {
				this.x += scalar;
				this.y += scalar;
				return this;
		}
		addScaled(rhs, scalar) {
				this.x += rhs.x * scalar;
				this.y += rhs.y * scalar;
				return this;
		}
		clone() {
				var cstr = this.constructor;
				return new cstr(this.x, this.y);
		}
		copy(rhs) {
				this.x = rhs.x;
				this.y = rhs.y;
				return this;
		}
		cross(rhs) {
				return this.x * rhs.y - this.y * rhs.x;
		}
		distance(rhs) {
				var x = this.x - rhs.x;
				var y = this.y - rhs.y;
				return Math.sqrt(x * x + y * y);
		}
		div(rhs) {
				this.x /= rhs.x;
				this.y /= rhs.y;
				return this;
		}
		div2(lhs, rhs) {
				this.x = lhs.x / rhs.x;
				this.y = lhs.y / rhs.y;
				return this;
		}
		divScalar(scalar) {
				this.x /= scalar;
				this.y /= scalar;
				return this;
		}
		dot(rhs) {
				return this.x * rhs.x + this.y * rhs.y;
		}
		equals(rhs) {
				return this.x === rhs.x && this.y === rhs.y;
		}
		equalsApprox(rhs, epsilon) {
				if (epsilon === void 0) epsilon = 1e-6;
				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon;
		}
		length() {
				return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		lengthSq() {
				return this.x * this.x + this.y * this.y;
		}
		lerp(lhs, rhs, alpha) {
				this.x = lhs.x + alpha * (rhs.x - lhs.x);
				this.y = lhs.y + alpha * (rhs.y - lhs.y);
				return this;
		}
		mul(rhs) {
				this.x *= rhs.x;
				this.y *= rhs.y;
				return this;
		}
		mul2(lhs, rhs) {
				this.x = lhs.x * rhs.x;
				this.y = lhs.y * rhs.y;
				return this;
		}
		mulScalar(scalar) {
				this.x *= scalar;
				this.y *= scalar;
				return this;
		}
		normalize(src) {
				if (src === void 0) src = this;
				var lengthSq = src.x * src.x + src.y * src.y;
				if (lengthSq > 0) {
						var invLength = 1 / Math.sqrt(lengthSq);
						this.x = src.x * invLength;
						this.y = src.y * invLength;
				}
				return this;
		}
		rotate(degrees) {
				var angle = Math.atan2(this.x, this.y) + degrees * math.DEG_TO_RAD;
				var len = Math.sqrt(this.x * this.x + this.y * this.y);
				this.x = Math.sin(angle) * len;
				this.y = Math.cos(angle) * len;
				return this;
		}
		angle() {
				return Math.atan2(this.x, this.y) * math.RAD_TO_DEG;
		}
		angleTo(rhs) {
				return Math.atan2(this.x * rhs.y + this.y * rhs.x, this.x * rhs.x + this.y * rhs.y) * math.RAD_TO_DEG;
		}
		floor(src) {
				if (src === void 0) src = this;
				this.x = Math.floor(src.x);
				this.y = Math.floor(src.y);
				return this;
		}
		ceil(src) {
				if (src === void 0) src = this;
				this.x = Math.ceil(src.x);
				this.y = Math.ceil(src.y);
				return this;
		}
		round(src) {
				if (src === void 0) src = this;
				this.x = Math.round(src.x);
				this.y = Math.round(src.y);
				return this;
		}
		min(rhs) {
				if (rhs.x < this.x) this.x = rhs.x;
				if (rhs.y < this.y) this.y = rhs.y;
				return this;
		}
		max(rhs) {
				if (rhs.x > this.x) this.x = rhs.x;
				if (rhs.y > this.y) this.y = rhs.y;
				return this;
		}
		set(x, y) {
				this.x = x;
				this.y = y;
				return this;
		}
		sub(rhs) {
				this.x -= rhs.x;
				this.y -= rhs.y;
				return this;
		}
		sub2(lhs, rhs) {
				this.x = lhs.x - rhs.x;
				this.y = lhs.y - rhs.y;
				return this;
		}
		subScalar(scalar) {
				this.x -= scalar;
				this.y -= scalar;
				return this;
		}
		fromArray(arr, offset) {
				if (offset === void 0) offset = 0;
				var _arr_offset;
				this.x = (_arr_offset = arr[offset]) != null ? _arr_offset : this.x;
				var _arr_;
				this.y = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.y;
				return this;
		}
		toString() {
				return "[" + this.x + ", " + this.y + "]";
		}
		toArray(arr, offset) {
				if (arr === void 0) arr = [];
				if (offset === void 0) offset = 0;
				arr[offset] = this.x;
				arr[offset + 1] = this.y;
				return arr;
		}
		static angleRad(lhs, rhs) {
				return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
		}
		constructor(x = 0, y = 0){
				if (x.length === 2) {
						this.x = x[0];
						this.y = x[1];
				} else {
						this.x = x;
						this.y = y;
				}
		}
}
Vec2.ZERO = Object.freeze(new Vec2(0, 0));
Vec2.HALF = Object.freeze(new Vec2(0.5, 0.5));
Vec2.ONE = Object.freeze(new Vec2(1, 1));
Vec2.UP = Object.freeze(new Vec2(0, 1));
Vec2.DOWN = Object.freeze(new Vec2(0, -1));
Vec2.RIGHT = Object.freeze(new Vec2(1, 0));
Vec2.LEFT = Object.freeze(new Vec2(-1, 0));

class Vec4 {
		add(rhs) {
				this.x += rhs.x;
				this.y += rhs.y;
				this.z += rhs.z;
				this.w += rhs.w;
				return this;
		}
		add2(lhs, rhs) {
				this.x = lhs.x + rhs.x;
				this.y = lhs.y + rhs.y;
				this.z = lhs.z + rhs.z;
				this.w = lhs.w + rhs.w;
				return this;
		}
		addScalar(scalar) {
				this.x += scalar;
				this.y += scalar;
				this.z += scalar;
				this.w += scalar;
				return this;
		}
		addScaled(rhs, scalar) {
				this.x += rhs.x * scalar;
				this.y += rhs.y * scalar;
				this.z += rhs.z * scalar;
				this.w += rhs.w * scalar;
				return this;
		}
		clone() {
				var cstr = this.constructor;
				return new cstr(this.x, this.y, this.z, this.w);
		}
		copy(rhs) {
				this.x = rhs.x;
				this.y = rhs.y;
				this.z = rhs.z;
				this.w = rhs.w;
				return this;
		}
		div(rhs) {
				this.x /= rhs.x;
				this.y /= rhs.y;
				this.z /= rhs.z;
				this.w /= rhs.w;
				return this;
		}
		div2(lhs, rhs) {
				this.x = lhs.x / rhs.x;
				this.y = lhs.y / rhs.y;
				this.z = lhs.z / rhs.z;
				this.w = lhs.w / rhs.w;
				return this;
		}
		divScalar(scalar) {
				this.x /= scalar;
				this.y /= scalar;
				this.z /= scalar;
				this.w /= scalar;
				return this;
		}
		dot(rhs) {
				return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
		}
		equals(rhs) {
				return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		}
		equalsApprox(rhs, epsilon) {
				if (epsilon === void 0) epsilon = 1e-6;
				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
		}
		length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}
		lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}
		lerp(lhs, rhs, alpha) {
				this.x = lhs.x + alpha * (rhs.x - lhs.x);
				this.y = lhs.y + alpha * (rhs.y - lhs.y);
				this.z = lhs.z + alpha * (rhs.z - lhs.z);
				this.w = lhs.w + alpha * (rhs.w - lhs.w);
				return this;
		}
		mul(rhs) {
				this.x *= rhs.x;
				this.y *= rhs.y;
				this.z *= rhs.z;
				this.w *= rhs.w;
				return this;
		}
		mul2(lhs, rhs) {
				this.x = lhs.x * rhs.x;
				this.y = lhs.y * rhs.y;
				this.z = lhs.z * rhs.z;
				this.w = lhs.w * rhs.w;
				return this;
		}
		mulScalar(scalar) {
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
				return this;
		}
		normalize(src) {
				if (src === void 0) src = this;
				var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w;
				if (lengthSq > 0) {
						var invLength = 1 / Math.sqrt(lengthSq);
						this.x = src.x * invLength;
						this.y = src.y * invLength;
						this.z = src.z * invLength;
						this.w = src.w * invLength;
				}
				return this;
		}
		floor(src) {
				if (src === void 0) src = this;
				this.x = Math.floor(src.x);
				this.y = Math.floor(src.y);
				this.z = Math.floor(src.z);
				this.w = Math.floor(src.w);
				return this;
		}
		ceil(src) {
				if (src === void 0) src = this;
				this.x = Math.ceil(src.x);
				this.y = Math.ceil(src.y);
				this.z = Math.ceil(src.z);
				this.w = Math.ceil(src.w);
				return this;
		}
		round(src) {
				if (src === void 0) src = this;
				this.x = Math.round(src.x);
				this.y = Math.round(src.y);
				this.z = Math.round(src.z);
				this.w = Math.round(src.w);
				return this;
		}
		min(rhs) {
				if (rhs.x < this.x) this.x = rhs.x;
				if (rhs.y < this.y) this.y = rhs.y;
				if (rhs.z < this.z) this.z = rhs.z;
				if (rhs.w < this.w) this.w = rhs.w;
				return this;
		}
		max(rhs) {
				if (rhs.x > this.x) this.x = rhs.x;
				if (rhs.y > this.y) this.y = rhs.y;
				if (rhs.z > this.z) this.z = rhs.z;
				if (rhs.w > this.w) this.w = rhs.w;
				return this;
		}
		set(x, y, z, w) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
				return this;
		}
		sub(rhs) {
				this.x -= rhs.x;
				this.y -= rhs.y;
				this.z -= rhs.z;
				this.w -= rhs.w;
				return this;
		}
		sub2(lhs, rhs) {
				this.x = lhs.x - rhs.x;
				this.y = lhs.y - rhs.y;
				this.z = lhs.z - rhs.z;
				this.w = lhs.w - rhs.w;
				return this;
		}
		subScalar(scalar) {
				this.x -= scalar;
				this.y -= scalar;
				this.z -= scalar;
				this.w -= scalar;
				return this;
		}
		fromArray(arr, offset) {
				if (offset === void 0) offset = 0;
				var _arr_offset;
				this.x = (_arr_offset = arr[offset]) != null ? _arr_offset : this.x;
				var _arr_;
				this.y = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.y;
				var _arr_1;
				this.z = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.z;
				var _arr_2;
				this.w = (_arr_2 = arr[offset + 3]) != null ? _arr_2 : this.w;
				return this;
		}
		toString() {
				return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		}
		toArray(arr, offset) {
				if (arr === void 0) arr = [];
				if (offset === void 0) offset = 0;
				arr[offset] = this.x;
				arr[offset + 1] = this.y;
				arr[offset + 2] = this.z;
				arr[offset + 3] = this.w;
				return arr;
		}
		constructor(x = 0, y = 0, z = 0, w = 0){
				if (x.length === 4) {
						this.x = x[0];
						this.y = x[1];
						this.z = x[2];
						this.w = x[3];
				} else {
						this.x = x;
						this.y = y;
						this.z = z;
						this.w = w;
				}
		}
}
Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
Vec4.HALF = Object.freeze(new Vec4(0.5, 0.5, 0.5, 0.5));
Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));

var _halfSize$1 = new Vec2();
var x$1 = new Vec3();
var y = new Vec3();
var z = new Vec3();
var scale = new Vec3();
class Mat4 {
		static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
				if (fovIsHorizontal) {
						halfSize.x = znear * Math.tan(fov * Math.PI / 360);
						halfSize.y = halfSize.x / aspect;
				} else {
						halfSize.y = znear * Math.tan(fov * Math.PI / 360);
						halfSize.x = halfSize.y * aspect;
				}
		}
		add2(lhs, rhs) {
				var a = lhs.data, b = rhs.data, r = this.data;
				r[0] = a[0] + b[0];
				r[1] = a[1] + b[1];
				r[2] = a[2] + b[2];
				r[3] = a[3] + b[3];
				r[4] = a[4] + b[4];
				r[5] = a[5] + b[5];
				r[6] = a[6] + b[6];
				r[7] = a[7] + b[7];
				r[8] = a[8] + b[8];
				r[9] = a[9] + b[9];
				r[10] = a[10] + b[10];
				r[11] = a[11] + b[11];
				r[12] = a[12] + b[12];
				r[13] = a[13] + b[13];
				r[14] = a[14] + b[14];
				r[15] = a[15] + b[15];
				return this;
		}
		add(rhs) {
				return this.add2(this, rhs);
		}
		clone() {
				var cstr = this.constructor;
				return new cstr().copy(this);
		}
		copy(rhs) {
				var src = rhs.data, dst = this.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[3];
				dst[4] = src[4];
				dst[5] = src[5];
				dst[6] = src[6];
				dst[7] = src[7];
				dst[8] = src[8];
				dst[9] = src[9];
				dst[10] = src[10];
				dst[11] = src[11];
				dst[12] = src[12];
				dst[13] = src[13];
				dst[14] = src[14];
				dst[15] = src[15];
				return this;
		}
		equals(rhs) {
				var l = this.data, r = rhs.data;
				return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
		}
		isIdentity() {
				var m = this.data;
				return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
		}
		mul2(lhs, rhs) {
				var a = lhs.data;
				var b = rhs.data;
				var r = this.data;
				var a00 = a[0];
				var a01 = a[1];
				var a02 = a[2];
				var a03 = a[3];
				var a10 = a[4];
				var a11 = a[5];
				var a12 = a[6];
				var a13 = a[7];
				var a20 = a[8];
				var a21 = a[9];
				var a22 = a[10];
				var a23 = a[11];
				var a30 = a[12];
				var a31 = a[13];
				var a32 = a[14];
				var a33 = a[15];
				var b0, b1, b2, b3;
				b0 = b[0];
				b1 = b[1];
				b2 = b[2];
				b3 = b[3];
				r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
				r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
				r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
				r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
				b0 = b[4];
				b1 = b[5];
				b2 = b[6];
				b3 = b[7];
				r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
				r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
				r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
				r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
				b0 = b[8];
				b1 = b[9];
				b2 = b[10];
				b3 = b[11];
				r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
				r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
				r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
				r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
				b0 = b[12];
				b1 = b[13];
				b2 = b[14];
				b3 = b[15];
				r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
				r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
				r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
				r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
				return this;
		}
		mulAffine2(lhs, rhs) {
				var a = lhs.data;
				var b = rhs.data;
				var r = this.data;
				var a00 = a[0];
				var a01 = a[1];
				var a02 = a[2];
				var a10 = a[4];
				var a11 = a[5];
				var a12 = a[6];
				var a20 = a[8];
				var a21 = a[9];
				var a22 = a[10];
				var a30 = a[12];
				var a31 = a[13];
				var a32 = a[14];
				var b0, b1, b2;
				b0 = b[0];
				b1 = b[1];
				b2 = b[2];
				r[0] = a00 * b0 + a10 * b1 + a20 * b2;
				r[1] = a01 * b0 + a11 * b1 + a21 * b2;
				r[2] = a02 * b0 + a12 * b1 + a22 * b2;
				r[3] = 0;
				b0 = b[4];
				b1 = b[5];
				b2 = b[6];
				r[4] = a00 * b0 + a10 * b1 + a20 * b2;
				r[5] = a01 * b0 + a11 * b1 + a21 * b2;
				r[6] = a02 * b0 + a12 * b1 + a22 * b2;
				r[7] = 0;
				b0 = b[8];
				b1 = b[9];
				b2 = b[10];
				r[8] = a00 * b0 + a10 * b1 + a20 * b2;
				r[9] = a01 * b0 + a11 * b1 + a21 * b2;
				r[10] = a02 * b0 + a12 * b1 + a22 * b2;
				r[11] = 0;
				b0 = b[12];
				b1 = b[13];
				b2 = b[14];
				r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
				r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
				r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
				r[15] = 1;
				return this;
		}
		mul(rhs) {
				return this.mul2(this, rhs);
		}
		transformPoint(vec, res) {
				if (res === void 0) res = new Vec3();
				var m = this.data;
				var { x, y, z } = vec;
				res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
				res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
				res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
				return res;
		}
		transformVector(vec, res) {
				if (res === void 0) res = new Vec3();
				var m = this.data;
				var { x, y, z } = vec;
				res.x = x * m[0] + y * m[4] + z * m[8];
				res.y = x * m[1] + y * m[5] + z * m[9];
				res.z = x * m[2] + y * m[6] + z * m[10];
				return res;
		}
		transformVec4(vec, res) {
				if (res === void 0) res = new Vec4();
				var m = this.data;
				var { x, y, z, w } = vec;
				res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
				res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
				res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
				res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
				return res;
		}
		setLookAt(position, target, up) {
				z.sub2(position, target).normalize();
				y.copy(up).normalize();
				x$1.cross(y, z).normalize();
				y.cross(z, x$1);
				var r = this.data;
				r[0] = x$1.x;
				r[1] = x$1.y;
				r[2] = x$1.z;
				r[3] = 0;
				r[4] = y.x;
				r[5] = y.y;
				r[6] = y.z;
				r[7] = 0;
				r[8] = z.x;
				r[9] = z.y;
				r[10] = z.z;
				r[11] = 0;
				r[12] = position.x;
				r[13] = position.y;
				r[14] = position.z;
				r[15] = 1;
				return this;
		}
		setFrustum(left, right, bottom, top, znear, zfar) {
				var temp1 = 2 * znear;
				var temp2 = right - left;
				var temp3 = top - bottom;
				var temp4 = zfar - znear;
				var r = this.data;
				r[0] = temp1 / temp2;
				r[1] = 0;
				r[2] = 0;
				r[3] = 0;
				r[4] = 0;
				r[5] = temp1 / temp3;
				r[6] = 0;
				r[7] = 0;
				r[8] = (right + left) / temp2;
				r[9] = (top + bottom) / temp3;
				r[10] = (-zfar - znear) / temp4;
				r[11] = -1;
				r[12] = 0;
				r[13] = 0;
				r[14] = -temp1 * zfar / temp4;
				r[15] = 0;
				return this;
		}
		setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
				Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);
				return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
		}
		setOrtho(left, right, bottom, top, near, far) {
				var r = this.data;
				r[0] = 2 / (right - left);
				r[1] = 0;
				r[2] = 0;
				r[3] = 0;
				r[4] = 0;
				r[5] = 2 / (top - bottom);
				r[6] = 0;
				r[7] = 0;
				r[8] = 0;
				r[9] = 0;
				r[10] = -2 / (far - near);
				r[11] = 0;
				r[12] = -(right + left) / (right - left);
				r[13] = -(top + bottom) / (top - bottom);
				r[14] = -(far + near) / (far - near);
				r[15] = 1;
				return this;
		}
		setFromAxisAngle(axis, angle) {
				angle *= math.DEG_TO_RAD;
				var { x, y, z } = axis;
				var c = Math.cos(angle);
				var s = Math.sin(angle);
				var t = 1 - c;
				var tx = t * x;
				var ty = t * y;
				var m = this.data;
				m[0] = tx * x + c;
				m[1] = tx * y + s * z;
				m[2] = tx * z - s * y;
				m[3] = 0;
				m[4] = tx * y - s * z;
				m[5] = ty * y + c;
				m[6] = ty * z + s * x;
				m[7] = 0;
				m[8] = tx * z + s * y;
				m[9] = ty * z - x * s;
				m[10] = t * z * z + c;
				m[11] = 0;
				m[12] = 0;
				m[13] = 0;
				m[14] = 0;
				m[15] = 1;
				return this;
		}
		setTranslate(x, y, z) {
				var m = this.data;
				m[0] = 1;
				m[1] = 0;
				m[2] = 0;
				m[3] = 0;
				m[4] = 0;
				m[5] = 1;
				m[6] = 0;
				m[7] = 0;
				m[8] = 0;
				m[9] = 0;
				m[10] = 1;
				m[11] = 0;
				m[12] = x;
				m[13] = y;
				m[14] = z;
				m[15] = 1;
				return this;
		}
		setScale(x, y, z) {
				var m = this.data;
				m[0] = x;
				m[1] = 0;
				m[2] = 0;
				m[3] = 0;
				m[4] = 0;
				m[5] = y;
				m[6] = 0;
				m[7] = 0;
				m[8] = 0;
				m[9] = 0;
				m[10] = z;
				m[11] = 0;
				m[12] = 0;
				m[13] = 0;
				m[14] = 0;
				m[15] = 1;
				return this;
		}
		setViewport(x, y, width, height) {
				var m = this.data;
				m[0] = width * 0.5;
				m[1] = 0;
				m[2] = 0;
				m[3] = 0;
				m[4] = 0;
				m[5] = height * 0.5;
				m[6] = 0;
				m[7] = 0;
				m[8] = 0;
				m[9] = 0;
				m[10] = 0.5;
				m[11] = 0;
				m[12] = x + width * 0.5;
				m[13] = y + height * 0.5;
				m[14] = 0.5;
				m[15] = 1;
				return this;
		}
		setReflection(normal, distance) {
				var a = normal.x;
				var b = normal.y;
				var c = normal.z;
				var data = this.data;
				data[0] = 1.0 - 2 * a * a;
				data[1] = -2 * a * b;
				data[2] = -2 * a * c;
				data[3] = 0;
				data[4] = -2 * a * b;
				data[5] = 1.0 - 2 * b * b;
				data[6] = -2 * b * c;
				data[7] = 0;
				data[8] = -2 * a * c;
				data[9] = -2 * b * c;
				data[10] = 1.0 - 2 * c * c;
				data[11] = 0;
				data[12] = -2 * a * distance;
				data[13] = -2 * b * distance;
				data[14] = -2 * c * distance;
				data[15] = 1;
				return this;
		}
		invert(src) {
				if (src === void 0) src = this;
				var s = src.data;
				var a00 = s[0];
				var a01 = s[1];
				var a02 = s[2];
				var a03 = s[3];
				var a10 = s[4];
				var a11 = s[5];
				var a12 = s[6];
				var a13 = s[7];
				var a20 = s[8];
				var a21 = s[9];
				var a22 = s[10];
				var a23 = s[11];
				var a30 = s[12];
				var a31 = s[13];
				var a32 = s[14];
				var a33 = s[15];
				var b00 = a00 * a11 - a01 * a10;
				var b01 = a00 * a12 - a02 * a10;
				var b02 = a00 * a13 - a03 * a10;
				var b03 = a01 * a12 - a02 * a11;
				var b04 = a01 * a13 - a03 * a11;
				var b05 = a02 * a13 - a03 * a12;
				var b06 = a20 * a31 - a21 * a30;
				var b07 = a20 * a32 - a22 * a30;
				var b08 = a20 * a33 - a23 * a30;
				var b09 = a21 * a32 - a22 * a31;
				var b10 = a21 * a33 - a23 * a31;
				var b11 = a22 * a33 - a23 * a32;
				var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
				if (det === 0) {
						this.setIdentity();
				} else {
						var invDet = 1 / det;
						var t = this.data;
						t[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
						t[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
						t[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
						t[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
						t[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
						t[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
						t[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
						t[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
						t[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
						t[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
						t[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
						t[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
						t[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
						t[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
						t[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
						t[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
				}
				return this;
		}
		set(src) {
				var dst = this.data;
				dst[0] = src[0];
				dst[1] = src[1];
				dst[2] = src[2];
				dst[3] = src[3];
				dst[4] = src[4];
				dst[5] = src[5];
				dst[6] = src[6];
				dst[7] = src[7];
				dst[8] = src[8];
				dst[9] = src[9];
				dst[10] = src[10];
				dst[11] = src[11];
				dst[12] = src[12];
				dst[13] = src[13];
				dst[14] = src[14];
				dst[15] = src[15];
				return this;
		}
		setIdentity() {
				var m = this.data;
				m[0] = 1;
				m[1] = 0;
				m[2] = 0;
				m[3] = 0;
				m[4] = 0;
				m[5] = 1;
				m[6] = 0;
				m[7] = 0;
				m[8] = 0;
				m[9] = 0;
				m[10] = 1;
				m[11] = 0;
				m[12] = 0;
				m[13] = 0;
				m[14] = 0;
				m[15] = 1;
				return this;
		}
		setTRS(t, r, s) {
				var qx = r.x;
				var qy = r.y;
				var qz = r.z;
				var qw = r.w;
				var sx = s.x;
				var sy = s.y;
				var sz = s.z;
				var x2 = qx + qx;
				var y2 = qy + qy;
				var z2 = qz + qz;
				var xx = qx * x2;
				var xy = qx * y2;
				var xz = qx * z2;
				var yy = qy * y2;
				var yz = qy * z2;
				var zz = qz * z2;
				var wx = qw * x2;
				var wy = qw * y2;
				var wz = qw * z2;
				var m = this.data;
				m[0] = (1 - (yy + zz)) * sx;
				m[1] = (xy + wz) * sx;
				m[2] = (xz - wy) * sx;
				m[3] = 0;
				m[4] = (xy - wz) * sy;
				m[5] = (1 - (xx + zz)) * sy;
				m[6] = (yz + wx) * sy;
				m[7] = 0;
				m[8] = (xz + wy) * sz;
				m[9] = (yz - wx) * sz;
				m[10] = (1 - (xx + yy)) * sz;
				m[11] = 0;
				m[12] = t.x;
				m[13] = t.y;
				m[14] = t.z;
				m[15] = 1;
				return this;
		}
		transpose(src) {
				if (src === void 0) src = this;
				var s = src.data;
				var t = this.data;
				if (s === t) {
						var tmp;
						tmp = s[1];
						t[1] = s[4];
						t[4] = tmp;
						tmp = s[2];
						t[2] = s[8];
						t[8] = tmp;
						tmp = s[3];
						t[3] = s[12];
						t[12] = tmp;
						tmp = s[6];
						t[6] = s[9];
						t[9] = tmp;
						tmp = s[7];
						t[7] = s[13];
						t[13] = tmp;
						tmp = s[11];
						t[11] = s[14];
						t[14] = tmp;
				} else {
						t[0] = s[0];
						t[1] = s[4];
						t[2] = s[8];
						t[3] = s[12];
						t[4] = s[1];
						t[5] = s[5];
						t[6] = s[9];
						t[7] = s[13];
						t[8] = s[2];
						t[9] = s[6];
						t[10] = s[10];
						t[11] = s[14];
						t[12] = s[3];
						t[13] = s[7];
						t[14] = s[11];
						t[15] = s[15];
				}
				return this;
		}
		getTranslation(t) {
				if (t === void 0) t = new Vec3();
				return t.set(this.data[12], this.data[13], this.data[14]);
		}
		getX(x) {
				if (x === void 0) x = new Vec3();
				return x.set(this.data[0], this.data[1], this.data[2]);
		}
		getY(y) {
				if (y === void 0) y = new Vec3();
				return y.set(this.data[4], this.data[5], this.data[6]);
		}
		getZ(z) {
				if (z === void 0) z = new Vec3();
				return z.set(this.data[8], this.data[9], this.data[10]);
		}
		getScale(scale) {
				if (scale === void 0) scale = new Vec3();
				this.getX(x$1);
				this.getY(y);
				this.getZ(z);
				scale.set(x$1.length(), y.length(), z.length());
				return scale;
		}
		get scaleSign() {
				this.getX(x$1);
				this.getY(y);
				this.getZ(z);
				x$1.cross(x$1, y);
				return x$1.dot(z) < 0 ? -1 : 1;
		}
		setFromEulerAngles(ex, ey, ez) {
				ex *= math.DEG_TO_RAD;
				ey *= math.DEG_TO_RAD;
				ez *= math.DEG_TO_RAD;
				var s1 = Math.sin(-ex);
				var c1 = Math.cos(-ex);
				var s2 = Math.sin(-ey);
				var c2 = Math.cos(-ey);
				var s3 = Math.sin(-ez);
				var c3 = Math.cos(-ez);
				var m = this.data;
				m[0] = c2 * c3;
				m[1] = -c2 * s3;
				m[2] = s2;
				m[3] = 0;
				m[4] = c1 * s3 + c3 * s1 * s2;
				m[5] = c1 * c3 - s1 * s2 * s3;
				m[6] = -c2 * s1;
				m[7] = 0;
				m[8] = s1 * s3 - c1 * c3 * s2;
				m[9] = c3 * s1 + c1 * s2 * s3;
				m[10] = c1 * c2;
				m[11] = 0;
				m[12] = 0;
				m[13] = 0;
				m[14] = 0;
				m[15] = 1;
				return this;
		}
		getEulerAngles(eulers) {
				if (eulers === void 0) eulers = new Vec3();
				this.getScale(scale);
				var sx = scale.x;
				var sy = scale.y;
				var sz = scale.z;
				if (sx === 0 || sy === 0 || sz === 0) {
						return eulers.set(0, 0, 0);
				}
				var m = this.data;
				var y = Math.asin(-m[2] / sx);
				var halfPi = Math.PI * 0.5;
				var x, z;
				if (y < halfPi) {
						if (y > -halfPi) {
								x = Math.atan2(m[6] / sy, m[10] / sz);
								z = Math.atan2(m[1] / sx, m[0] / sx);
						} else {
								z = 0;
								x = -Math.atan2(m[4] / sy, m[5] / sy);
						}
				} else {
						z = 0;
						x = Math.atan2(m[4] / sy, m[5] / sy);
				}
				return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		}
		toString() {
				return "[" + this.data.join(', ') + "]";
		}
		constructor(){
				this.data = new Float32Array(16);
				this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
		}
}
Mat4.IDENTITY = Object.freeze(new Mat4());
Mat4.ZERO = Object.freeze(new Mat4().set([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
]));

class Quat {
		clone() {
				var cstr = this.constructor;
				return new cstr(this.x, this.y, this.z, this.w);
		}
		conjugate(src) {
				if (src === void 0) src = this;
				this.x = src.x * -1;
				this.y = src.y * -1;
				this.z = src.z * -1;
				this.w = src.w;
				return this;
		}
		copy(rhs) {
				this.x = rhs.x;
				this.y = rhs.y;
				this.z = rhs.z;
				this.w = rhs.w;
				return this;
		}
		equals(rhs) {
				return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		}
		equalsApprox(rhs, epsilon) {
				if (epsilon === void 0) epsilon = 1e-6;
				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
		}
		getAxisAngle(axis) {
				var rad = Math.acos(this.w) * 2;
				var s = Math.sin(rad / 2);
				if (s !== 0) {
						axis.x = this.x / s;
						axis.y = this.y / s;
						axis.z = this.z / s;
						if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
								axis.x *= -1;
								axis.y *= -1;
								axis.z *= -1;
								rad *= -1;
						}
				} else {
						axis.x = 1;
						axis.y = 0;
						axis.z = 0;
				}
				return rad * math.RAD_TO_DEG;
		}
		getEulerAngles(eulers) {
				if (eulers === void 0) eulers = new Vec3();
				var x, y, z;
				var qx = this.x;
				var qy = this.y;
				var qz = this.z;
				var qw = this.w;
				var a2 = 2 * (qw * qy - qx * qz);
				if (a2 <= -0.99999) {
						x = 2 * Math.atan2(qx, qw);
						y = -Math.PI / 2;
						z = 0;
				} else if (a2 >= 0.99999) {
						x = 2 * Math.atan2(qx, qw);
						y = Math.PI / 2;
						z = 0;
				} else {
						x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
						y = Math.asin(a2);
						z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
				}
				return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		}
		invert(src) {
				if (src === void 0) src = this;
				return this.conjugate(src).normalize();
		}
		length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}
		lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}
		mul(rhs) {
				var q1x = this.x;
				var q1y = this.y;
				var q1z = this.z;
				var q1w = this.w;
				var q2x = rhs.x;
				var q2y = rhs.y;
				var q2z = rhs.z;
				var q2w = rhs.w;
				this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
				this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
				this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
				this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
				return this;
		}
		mulScalar(scalar, src) {
				if (src === void 0) src = this;
				this.x = src.x * scalar;
				this.y = src.y * scalar;
				this.z = src.z * scalar;
				this.w = src.w * scalar;
				return this;
		}
		mul2(lhs, rhs) {
				var q1x = lhs.x;
				var q1y = lhs.y;
				var q1z = lhs.z;
				var q1w = lhs.w;
				var q2x = rhs.x;
				var q2y = rhs.y;
				var q2z = rhs.z;
				var q2w = rhs.w;
				this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
				this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
				this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
				this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
				return this;
		}
		normalize(src) {
				if (src === void 0) src = this;
				var len = src.length();
				if (len === 0) {
						this.x = this.y = this.z = 0;
						this.w = 1;
				} else {
						len = 1 / len;
						this.x = src.x * len;
						this.y = src.y * len;
						this.z = src.z * len;
						this.w = src.w * len;
				}
				return this;
		}
		set(x, y, z, w) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
				return this;
		}
		setFromAxisAngle(axis, angle) {
				angle *= 0.5 * math.DEG_TO_RAD;
				var sa = Math.sin(angle);
				var ca = Math.cos(angle);
				this.x = sa * axis.x;
				this.y = sa * axis.y;
				this.z = sa * axis.z;
				this.w = ca;
				return this;
		}
		setFromEulerAngles(ex, ey, ez) {
				if (ex instanceof Vec3) {
						var vec = ex;
						ex = vec.x;
						ey = vec.y;
						ez = vec.z;
				}
				var halfToRad = 0.5 * math.DEG_TO_RAD;
				ex *= halfToRad;
				ey *= halfToRad;
				ez *= halfToRad;
				var sx = Math.sin(ex);
				var cx = Math.cos(ex);
				var sy = Math.sin(ey);
				var cy = Math.cos(ey);
				var sz = Math.sin(ez);
				var cz = Math.cos(ez);
				this.x = sx * cy * cz - cx * sy * sz;
				this.y = cx * sy * cz + sx * cy * sz;
				this.z = cx * cy * sz - sx * sy * cz;
				this.w = cx * cy * cz + sx * sy * sz;
				return this;
		}
		setFromMat4(m) {
				var d = m.data;
				var m00 = d[0];
				var m01 = d[1];
				var m02 = d[2];
				var m10 = d[4];
				var m11 = d[5];
				var m12 = d[6];
				var m20 = d[8];
				var m21 = d[9];
				var m22 = d[10];
				var l;
				l = m00 * m00 + m01 * m01 + m02 * m02;
				if (l === 0) return this.set(0, 0, 0, 1);
				l = 1 / Math.sqrt(l);
				m00 *= l;
				m01 *= l;
				m02 *= l;
				l = m10 * m10 + m11 * m11 + m12 * m12;
				if (l === 0) return this.set(0, 0, 0, 1);
				l = 1 / Math.sqrt(l);
				m10 *= l;
				m11 *= l;
				m12 *= l;
				l = m20 * m20 + m21 * m21 + m22 * m22;
				if (l === 0) return this.set(0, 0, 0, 1);
				l = 1 / Math.sqrt(l);
				m20 *= l;
				m21 *= l;
				m22 *= l;
				if (m22 < 0) {
						if (m00 > m11) {
								this.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);
						} else {
								this.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);
						}
				} else {
						if (m00 < -m11) {
								this.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);
						} else {
								this.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);
						}
				}
				return this.mulScalar(1.0 / this.length());
		}
		setFromDirections(from, to) {
				var dotProduct = 1 + from.dot(to);
				if (dotProduct < Number.EPSILON) {
						if (Math.abs(from.x) > Math.abs(from.y)) {
								this.x = -from.z;
								this.y = 0;
								this.z = from.x;
								this.w = 0;
						} else {
								this.x = 0;
								this.y = -from.z;
								this.z = from.y;
								this.w = 0;
						}
				} else {
						this.x = from.y * to.z - from.z * to.y;
						this.y = from.z * to.x - from.x * to.z;
						this.z = from.x * to.y - from.y * to.x;
						this.w = dotProduct;
				}
				return this.normalize();
		}
		slerp(lhs, rhs, alpha) {
				var lx = lhs.x;
				var ly = lhs.y;
				var lz = lhs.z;
				var lw = lhs.w;
				var rx = rhs.x;
				var ry = rhs.y;
				var rz = rhs.z;
				var rw = rhs.w;
				var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
				if (cosHalfTheta < 0) {
						rw = -rw;
						rx = -rx;
						ry = -ry;
						rz = -rz;
						cosHalfTheta = -cosHalfTheta;
				}
				if (Math.abs(cosHalfTheta) >= 1) {
						this.w = lw;
						this.x = lx;
						this.y = ly;
						this.z = lz;
						return this;
				}
				var halfTheta = Math.acos(cosHalfTheta);
				var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
				if (Math.abs(sinHalfTheta) < 0.001) {
						this.w = lw * 0.5 + rw * 0.5;
						this.x = lx * 0.5 + rx * 0.5;
						this.y = ly * 0.5 + ry * 0.5;
						this.z = lz * 0.5 + rz * 0.5;
						return this;
				}
				var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
				var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
				this.w = lw * ratioA + rw * ratioB;
				this.x = lx * ratioA + rx * ratioB;
				this.y = ly * ratioA + ry * ratioB;
				this.z = lz * ratioA + rz * ratioB;
				return this;
		}
		transformVector(vec, res) {
				if (res === void 0) res = new Vec3();
				var x = vec.x, y = vec.y, z = vec.z;
				var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
				var ix = qw * x + qy * z - qz * y;
				var iy = qw * y + qz * x - qx * z;
				var iz = qw * z + qx * y - qy * x;
				var iw = -qx * x - qy * y - qz * z;
				res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
				res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
				res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
				return res;
		}
		toString() {
				return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		}
		constructor(x = 0, y = 0, z = 0, w = 1){
				if (x.length === 4) {
						this.x = x[0];
						this.y = x[1];
						this.z = x[2];
						this.w = x[3];
				} else {
						this.x = x;
						this.y = y;
						this.z = z;
						this.w = w;
				}
		}
}
Quat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));
Quat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));

var tmpVecA$1 = new Vec3();
var tmpVecB$1 = new Vec3();
var tmpVecC = new Vec3();
var tmpVecD = new Vec3();
var tmpVecE = new Vec3();
class BoundingBox {
		add(other) {
				var tc = this.center;
				var tcx = tc.x;
				var tcy = tc.y;
				var tcz = tc.z;
				var th = this.halfExtents;
				var thx = th.x;
				var thy = th.y;
				var thz = th.z;
				var tminx = tcx - thx;
				var tmaxx = tcx + thx;
				var tminy = tcy - thy;
				var tmaxy = tcy + thy;
				var tminz = tcz - thz;
				var tmaxz = tcz + thz;
				var oc = other.center;
				var ocx = oc.x;
				var ocy = oc.y;
				var ocz = oc.z;
				var oh = other.halfExtents;
				var ohx = oh.x;
				var ohy = oh.y;
				var ohz = oh.z;
				var ominx = ocx - ohx;
				var omaxx = ocx + ohx;
				var ominy = ocy - ohy;
				var omaxy = ocy + ohy;
				var ominz = ocz - ohz;
				var omaxz = ocz + ohz;
				if (ominx < tminx) tminx = ominx;
				if (omaxx > tmaxx) tmaxx = omaxx;
				if (ominy < tminy) tminy = ominy;
				if (omaxy > tmaxy) tmaxy = omaxy;
				if (ominz < tminz) tminz = ominz;
				if (omaxz > tmaxz) tmaxz = omaxz;
				tc.x = (tminx + tmaxx) * 0.5;
				tc.y = (tminy + tmaxy) * 0.5;
				tc.z = (tminz + tmaxz) * 0.5;
				th.x = (tmaxx - tminx) * 0.5;
				th.y = (tmaxy - tminy) * 0.5;
				th.z = (tmaxz - tminz) * 0.5;
		}
		copy(src) {
				this.center.copy(src.center);
				this.halfExtents.copy(src.halfExtents);
		}
		clone() {
				return new BoundingBox(this.center, this.halfExtents);
		}
		intersects(other) {
				var aMax = this.getMax();
				var aMin = this.getMin();
				var bMax = other.getMax();
				var bMin = other.getMin();
				return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
		}
		_intersectsRay(ray, point) {
				var tMin = tmpVecA$1.copy(this.getMin()).sub(ray.origin);
				var tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
				var dir = ray.direction;
				if (dir.x === 0) {
						tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
						tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				} else {
						tMin.x /= dir.x;
						tMax.x /= dir.x;
				}
				if (dir.y === 0) {
						tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
						tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				} else {
						tMin.y /= dir.y;
						tMax.y /= dir.y;
				}
				if (dir.z === 0) {
						tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
						tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				} else {
						tMin.z /= dir.z;
						tMax.z /= dir.z;
				}
				var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
				var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
				var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
				var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
				var intersects = minMax >= maxMin && maxMin >= 0;
				if (intersects) {
						point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
				}
				return intersects;
		}
		_fastIntersectsRay(ray) {
				var diff = tmpVecA$1;
				var cross = tmpVecB$1;
				var prod = tmpVecC;
				var absDiff = tmpVecD;
				var absDir = tmpVecE;
				var rayDir = ray.direction;
				diff.sub2(ray.origin, this.center);
				absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
				prod.mul2(diff, rayDir);
				if (absDiff.x > this.halfExtents.x && prod.x >= 0) {
						return false;
				}
				if (absDiff.y > this.halfExtents.y && prod.y >= 0) {
						return false;
				}
				if (absDiff.z > this.halfExtents.z && prod.z >= 0) {
						return false;
				}
				absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
				cross.cross(rayDir, diff);
				cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
				if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {
						return false;
				}
				if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {
						return false;
				}
				if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {
						return false;
				}
				return true;
		}
		intersectsRay(ray, point) {
				if (point) {
						return this._intersectsRay(ray, point);
				}
				return this._fastIntersectsRay(ray);
		}
		setMinMax(min, max) {
				this.center.add2(max, min).mulScalar(0.5);
				this.halfExtents.sub2(max, min).mulScalar(0.5);
		}
		getMin() {
				return this._min.copy(this.center).sub(this.halfExtents);
		}
		getMax() {
				return this._max.copy(this.center).add(this.halfExtents);
		}
		containsPoint(point) {
				var min = this.getMin();
				var max = this.getMax();
				if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
						return false;
				}
				return true;
		}
		setFromTransformedAabb(aabb, m, ignoreScale) {
				if (ignoreScale === void 0) ignoreScale = false;
				var ac = aabb.center;
				var ar = aabb.halfExtents;
				var d = m.data;
				var mx0 = d[0];
				var mx1 = d[4];
				var mx2 = d[8];
				var my0 = d[1];
				var my1 = d[5];
				var my2 = d[9];
				var mz0 = d[2];
				var mz1 = d[6];
				var mz2 = d[10];
				if (ignoreScale) {
						var lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;
						if (lengthSq > 0) {
								var invLength = 1 / Math.sqrt(lengthSq);
								mx0 *= invLength;
								mx1 *= invLength;
								mx2 *= invLength;
						}
						lengthSq = my0 * my0 + my1 * my1 + my2 * my2;
						if (lengthSq > 0) {
								var invLength1 = 1 / Math.sqrt(lengthSq);
								my0 *= invLength1;
								my1 *= invLength1;
								my2 *= invLength1;
						}
						lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;
						if (lengthSq > 0) {
								var invLength2 = 1 / Math.sqrt(lengthSq);
								mz0 *= invLength2;
								mz1 *= invLength2;
								mz2 *= invLength2;
						}
				}
				this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
				this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
		}
		static computeMinMax(vertices, min, max, numVerts) {
				if (numVerts === void 0) numVerts = vertices.length / 3;
				if (numVerts > 0) {
						var minx = vertices[0];
						var miny = vertices[1];
						var minz = vertices[2];
						var maxx = minx;
						var maxy = miny;
						var maxz = minz;
						var n = numVerts * 3;
						for(var i = 3; i < n; i += 3){
								var x = vertices[i];
								var y = vertices[i + 1];
								var z = vertices[i + 2];
								if (x < minx) minx = x;
								if (y < miny) miny = y;
								if (z < minz) minz = z;
								if (x > maxx) maxx = x;
								if (y > maxy) maxy = y;
								if (z > maxz) maxz = z;
						}
						min.set(minx, miny, minz);
						max.set(maxx, maxy, maxz);
				}
		}
		compute(vertices, numVerts) {
				BoundingBox.computeMinMax(vertices, tmpVecA$1, tmpVecB$1, numVerts);
				this.setMinMax(tmpVecA$1, tmpVecB$1);
		}
		intersectsBoundingSphere(sphere) {
				var sq = this._distanceToBoundingSphereSq(sphere);
				if (sq <= sphere.radius * sphere.radius) {
						return true;
				}
				return false;
		}
		_distanceToBoundingSphereSq(sphere) {
				var boxMin = this.getMin();
				var boxMax = this.getMax();
				var sq = 0;
				var axis = [
						'x',
						'y',
						'z'
				];
				for(var i = 0; i < 3; ++i){
						var out = 0;
						var pn = sphere.center[axis[i]];
						var bMin = boxMin[axis[i]];
						var bMax = boxMax[axis[i]];
						var val = 0;
						if (pn < bMin) {
								val = bMin - pn;
								out += val * val;
						}
						if (pn > bMax) {
								val = pn - bMax;
								out += val * val;
						}
						sq += out;
				}
				return sq;
		}
		_expand(expandMin, expandMax) {
				tmpVecA$1.add2(this.getMin(), expandMin);
				tmpVecB$1.add2(this.getMax(), expandMax);
				this.setMinMax(tmpVecA$1, tmpVecB$1);
		}
		constructor(center, halfExtents){
				this.center = new Vec3();
				this.halfExtents = new Vec3(0.5, 0.5, 0.5);
				this._min = new Vec3();
				this._max = new Vec3();
				if (center) {
						this.center.copy(center);
				}
				if (halfExtents) {
						this.halfExtents.copy(halfExtents);
				}
		}
}

var tmpVecA = new Vec3();
var tmpVecB = new Vec3();
class BoundingSphere {
		containsPoint(point) {
				var lenSq = tmpVecA.sub2(point, this.center).lengthSq();
				var r = this.radius;
				return lenSq < r * r;
		}
		intersectsRay(ray, point) {
				var m = tmpVecA.copy(ray.origin).sub(this.center);
				var b = m.dot(tmpVecB.copy(ray.direction).normalize());
				var c = m.dot(m) - this.radius * this.radius;
				if (c > 0 && b > 0) {
						return false;
				}
				var discr = b * b - c;
				if (discr < 0) {
						return false;
				}
				var t = Math.abs(-b - Math.sqrt(discr));
				if (point) {
						point.copy(ray.direction).mulScalar(t).add(ray.origin);
				}
				return true;
		}
		intersectsBoundingSphere(sphere) {
				tmpVecA.sub2(sphere.center, this.center);
				var totalRadius = sphere.radius + this.radius;
				if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {
						return true;
				}
				return false;
		}
		constructor(center = new Vec3(), radius = 0.5){
				this.center = center;
				this.radius = radius;
		}
}

class Plane {
		clone() {
				var cstr = this.constructor;
				return new cstr().copy(this);
		}
		copy(src) {
				this.normal.copy(src.normal);
				this.distance = src.distance;
				return this;
		}
		intersectsLine(start, end, point) {
				var d = this.distance;
				var d0 = this.normal.dot(start) + d;
				var d1 = this.normal.dot(end) + d;
				var t = d0 / (d0 - d1);
				var intersects = t >= 0 && t <= 1;
				if (intersects && point) {
						point.lerp(start, end, t);
				}
				return intersects;
		}
		intersectsRay(ray, point) {
				var denominator = this.normal.dot(ray.direction);
				if (denominator === 0) {
						return false;
				}
				var t = -(this.normal.dot(ray.origin) + this.distance) / denominator;
				if (t >= 0 && point) {
						point.copy(ray.direction).mulScalar(t).add(ray.origin);
				}
				return t >= 0;
		}
		normalize() {
				var invLength = 1 / this.normal.length();
				this.normal.mulScalar(invLength);
				this.distance *= invLength;
				return this;
		}
		set(nx, ny, nz, d) {
				this.normal.set(nx, ny, nz);
				this.distance = d;
				return this;
		}
		setFromPointNormal(point, normal) {
				this.normal.copy(normal);
				this.distance = -this.normal.dot(point);
				return this;
		}
		constructor(normal = Vec3.UP, distance = 0){
				this.normal = new Vec3();
				this.normal.copy(normal);
				this.distance = distance;
		}
}

class Frustum {
		clone() {
				var cstr = this.constructor;
				return new cstr().copy(this);
		}
		copy(src) {
				for(var i = 0; i < 6; i++){
						this.planes[i].copy(src.planes[i]);
				}
				return this;
		}
		setFromMat4(matrix) {
				var [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33] = matrix.data;
				var planes = this.planes;
				planes[0].set(m03 - m00, m13 - m10, m23 - m20, m33 - m30).normalize();
				planes[1].set(m03 + m00, m13 + m10, m23 + m20, m33 + m30).normalize();
				planes[2].set(m03 + m01, m13 + m11, m23 + m21, m33 + m31).normalize();
				planes[3].set(m03 - m01, m13 - m11, m23 - m21, m33 - m31).normalize();
				planes[4].set(m03 - m02, m13 - m12, m23 - m22, m33 - m32).normalize();
				planes[5].set(m03 + m02, m13 + m12, m23 + m22, m33 + m32).normalize();
		}
		containsPoint(point) {
				for(var p = 0; p < 6; p++){
						var { normal, distance } = this.planes[p];
						if (normal.dot(point) + distance <= 0) {
								return false;
						}
				}
				return true;
		}
		containsSphere(sphere) {
				var { center, radius } = sphere;
				var c = 0;
				for(var p = 0; p < 6; p++){
						var { normal, distance } = this.planes[p];
						var d = normal.dot(center) + distance;
						if (d <= -radius) {
								return 0;
						}
						if (d > radius) {
								c++;
						}
				}
				return c === 6 ? 2 : 1;
		}
		constructor(){
				this.planes = [];
				for(var i = 0; i < 6; i++){
						this.planes[i] = new Plane();
				}
		}
}

class Ray {
		set(origin, direction) {
				this.origin.copy(origin);
				this.direction.copy(direction);
				return this;
		}
		copy(src) {
				return this.set(src.origin, src.direction);
		}
		clone() {
				return new this.constructor(this.origin, this.direction);
		}
		constructor(origin, direction){
				this.origin = new Vec3();
				this.direction = Vec3.FORWARD.clone();
				if (origin) {
						this.origin.copy(origin);
				}
				if (direction) {
						this.direction.copy(direction);
				}
		}
}

var tmpRay = new Ray();
var tmpVec3$2 = new Vec3();
var tmpSphere = new BoundingSphere();
var tmpMat4$1 = new Mat4();
class OrientedBox {
		set worldTransform(value) {
				this._worldTransform.copy(value);
				this._modelTransform.copy(value).invert();
		}
		get worldTransform() {
				return this._worldTransform;
		}
		intersectsRay(ray, point) {
				this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
				this._modelTransform.transformVector(ray.direction, tmpRay.direction);
				if (point) {
						var result = this._aabb._intersectsRay(tmpRay, point);
						tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);
						return result;
				}
				return this._aabb._fastIntersectsRay(tmpRay);
		}
		containsPoint(point) {
				this._modelTransform.transformPoint(point, tmpVec3$2);
				return this._aabb.containsPoint(tmpVec3$2);
		}
		intersectsBoundingSphere(sphere) {
				this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
				tmpSphere.radius = sphere.radius;
				if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
						return true;
				}
				return false;
		}
		constructor(worldTransform = new Mat4(), halfExtents){
				this.halfExtents = new Vec3(0.5, 0.5, 0.5);
				if (halfExtents) {
						this.halfExtents.copy(halfExtents);
				}
				this._modelTransform = worldTransform.clone().invert();
				this._worldTransform = worldTransform.clone();
				this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
		}
}

var e1 = new Vec3();
var e2 = new Vec3();
var h = new Vec3();
var s = new Vec3();
var q$1 = new Vec3();
var EPSILON = 1e-6;
class Tri {
		set(v0, v1, v2) {
				this.v0.copy(v0);
				this.v1.copy(v1);
				this.v2.copy(v2);
				return this;
		}
		intersectsRay(ray, point) {
				e1.sub2(this.v1, this.v0);
				e2.sub2(this.v2, this.v0);
				h.cross(ray.direction, e2);
				var a = e1.dot(h);
				if (a > -1e-6 && a < EPSILON) {
						return false;
				}
				var f = 1 / a;
				s.sub2(ray.origin, this.v0);
				var u = f * s.dot(h);
				if (u < 0 || u > 1) {
						return false;
				}
				q$1.cross(s, e1);
				var v = f * ray.direction.dot(q$1);
				if (v < 0 || u + v > 1) {
						return false;
				}
				var t = f * e2.dot(q$1);
				if (t > EPSILON) {
						if (point instanceof Vec3) {
								point.copy(ray.direction).mulScalar(t).add(ray.origin);
						}
						return true;
				}
				return false;
		}
		toString() {
				return "[" + this.v0.toString() + ", " + this.v1.toString() + ", " + this.v2.toString() + "]";
		}
		constructor(v0 = Vec3.ZERO, v1 = Vec3.ZERO, v2 = Vec3.ZERO){
				this.v0 = new Vec3();
				this.v1 = new Vec3();
				this.v2 = new Vec3();
				this.set(v0, v1, v2);
		}
}

var DISTANCE_LINEAR = 'linear';
var DISTANCE_INVERSE = 'inverse';
var DISTANCE_EXPONENTIAL = 'exponential';

var ADDRESS_REPEAT = 0;
var ADDRESS_CLAMP_TO_EDGE = 1;
var ADDRESS_MIRRORED_REPEAT = 2;
var BLENDMODE_ZERO = 0;
var BLENDMODE_ONE = 1;
var BLENDMODE_SRC_COLOR = 2;
var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
var BLENDMODE_DST_COLOR = 4;
var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
var BLENDMODE_SRC_ALPHA = 6;
var BLENDMODE_SRC_ALPHA_SATURATE = 7;
var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
var BLENDMODE_DST_ALPHA = 9;
var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
var BLENDMODE_CONSTANT = 11;
var BLENDMODE_ONE_MINUS_CONSTANT = 12;
var BLENDEQUATION_ADD = 0;
var BLENDEQUATION_SUBTRACT = 1;
var BLENDEQUATION_REVERSE_SUBTRACT = 2;
var BLENDEQUATION_MIN = 3;
var BLENDEQUATION_MAX = 4;
var BUFFERUSAGE_READ = 0x0001;
var BUFFERUSAGE_WRITE = 0x0002;
var BUFFERUSAGE_COPY_SRC = 0x0004;
var BUFFERUSAGE_COPY_DST = 0x0008;
var BUFFERUSAGE_INDEX = 0x0010;
var BUFFERUSAGE_VERTEX = 0x0020;
var BUFFERUSAGE_UNIFORM = 0x0040;
var BUFFERUSAGE_STORAGE = 0x0080;
var BUFFERUSAGE_INDIRECT = 0x0100;
var BUFFER_STATIC = 0;
var BUFFER_DYNAMIC = 1;
var BUFFER_STREAM = 2;
var BUFFER_GPUDYNAMIC = 3;
var CLEARFLAG_COLOR = 1;
var CLEARFLAG_DEPTH = 2;
var CLEARFLAG_STENCIL = 4;
var CUBEFACE_POSX = 0;
var CUBEFACE_NEGX = 1;
var CUBEFACE_POSY = 2;
var CUBEFACE_NEGY = 3;
var CUBEFACE_POSZ = 4;
var CUBEFACE_NEGZ = 5;
var CULLFACE_NONE = 0;
var CULLFACE_BACK = 1;
var CULLFACE_FRONT = 2;
var CULLFACE_FRONTANDBACK = 3;
var FILTER_NEAREST = 0;
var FILTER_LINEAR = 1;
var FILTER_NEAREST_MIPMAP_NEAREST = 2;
var FILTER_NEAREST_MIPMAP_LINEAR = 3;
var FILTER_LINEAR_MIPMAP_NEAREST = 4;
var FILTER_LINEAR_MIPMAP_LINEAR = 5;
var FUNC_NEVER = 0;
var FUNC_LESS = 1;
var FUNC_EQUAL = 2;
var FUNC_LESSEQUAL = 3;
var FUNC_GREATER = 4;
var FUNC_NOTEQUAL = 5;
var FUNC_GREATEREQUAL = 6;
var FUNC_ALWAYS = 7;
var INDEXFORMAT_UINT8 = 0;
var INDEXFORMAT_UINT16 = 1;
var INDEXFORMAT_UINT32 = 2;
var PIXELFORMAT_A8 = 0;
var PIXELFORMAT_L8 = 1;
var PIXELFORMAT_LA8 = 2;
var PIXELFORMAT_RGB565 = 3;
var PIXELFORMAT_RGBA5551 = 4;
var PIXELFORMAT_RGBA4 = 5;
var PIXELFORMAT_RGB8 = 6;
var PIXELFORMAT_RGBA8 = 7;
var PIXELFORMAT_DXT1 = 8;
var PIXELFORMAT_DXT3 = 9;
var PIXELFORMAT_DXT5 = 10;
var PIXELFORMAT_RGB16F = 11;
var PIXELFORMAT_RGBA16F = 12;
var PIXELFORMAT_RGB32F = 13;
var PIXELFORMAT_RGBA32F = 14;
var PIXELFORMAT_R32F = 15;
var PIXELFORMAT_DEPTH = 16;
var PIXELFORMAT_DEPTHSTENCIL = 17;
var PIXELFORMAT_111110F = 18;
var PIXELFORMAT_SRGB8 = 19;
var PIXELFORMAT_SRGBA8 = 20;
var PIXELFORMAT_ETC1 = 21;
var PIXELFORMAT_ETC2_RGB = 22;
var PIXELFORMAT_ETC2_RGBA = 23;
var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
var PIXELFORMAT_ASTC_4x4 = 28;
var PIXELFORMAT_ATC_RGB = 29;
var PIXELFORMAT_ATC_RGBA = 30;
var PIXELFORMAT_BGRA8 = 31;
var PIXELFORMAT_R8I = 32;
var PIXELFORMAT_R8U = 33;
var PIXELFORMAT_R16I = 34;
var PIXELFORMAT_R16U = 35;
var PIXELFORMAT_R32I = 36;
var PIXELFORMAT_R32U = 37;
var PIXELFORMAT_RG8I = 38;
var PIXELFORMAT_RG8U = 39;
var PIXELFORMAT_RG16I = 40;
var PIXELFORMAT_RG16U = 41;
var PIXELFORMAT_RG32I = 42;
var PIXELFORMAT_RG32U = 43;
var PIXELFORMAT_RGBA8I = 44;
var PIXELFORMAT_RGBA8U = 45;
var PIXELFORMAT_RGBA16I = 46;
var PIXELFORMAT_RGBA16U = 47;
var PIXELFORMAT_RGBA32I = 48;
var PIXELFORMAT_RGBA32U = 49;
var PIXELFORMAT_R16F = 50;
var PIXELFORMAT_RG16F = 51;
var PIXELFORMAT_R8 = 52;
var PIXELFORMAT_RG8 = 53;
var PIXELFORMAT_DXT1_SRGB = 54;
var PIXELFORMAT_DXT3_SRGBA = 55;
var PIXELFORMAT_DXT5_SRGBA = 56;
var PIXELFORMAT_ETC2_SRGB = 61;
var PIXELFORMAT_ETC2_SRGBA = 62;
var PIXELFORMAT_ASTC_4x4_SRGB = 63;
var PIXELFORMAT_SBGRA8 = 64;
var PIXELFORMAT_BC6F = 65;
var PIXELFORMAT_BC6UF = 66;
var PIXELFORMAT_BC7 = 67;
var PIXELFORMAT_BC7_SRGBA = 68;
var PIXELFORMAT_DEPTH16 = 69;
var pixelFormatInfo = new Map([
		[
				PIXELFORMAT_A8,
				{
						name: 'A8',
						size: 1,
						ldr: true
				}
		],
		[
				PIXELFORMAT_R8,
				{
						name: 'R8',
						size: 1,
						ldr: true
				}
		],
		[
				PIXELFORMAT_L8,
				{
						name: 'L8',
						size: 1,
						ldr: true
				}
		],
		[
				PIXELFORMAT_LA8,
				{
						name: 'LA8',
						size: 2,
						ldr: true
				}
		],
		[
				PIXELFORMAT_RG8,
				{
						name: 'RG8',
						size: 2,
						ldr: true
				}
		],
		[
				PIXELFORMAT_RGB565,
				{
						name: 'RGB565',
						size: 2,
						ldr: true
				}
		],
		[
				PIXELFORMAT_RGBA5551,
				{
						name: 'RGBA5551',
						size: 2,
						ldr: true
				}
		],
		[
				PIXELFORMAT_RGBA4,
				{
						name: 'RGBA4',
						size: 2,
						ldr: true
				}
		],
		[
				PIXELFORMAT_RGB8,
				{
						name: 'RGB8',
						size: 4,
						ldr: true
				}
		],
		[
				PIXELFORMAT_RGBA8,
				{
						name: 'RGBA8',
						size: 4,
						ldr: true,
						srgbFormat: PIXELFORMAT_SRGBA8
				}
		],
		[
				PIXELFORMAT_R16F,
				{
						name: 'R16F',
						size: 2
				}
		],
		[
				PIXELFORMAT_RG16F,
				{
						name: 'RG16F',
						size: 4
				}
		],
		[
				PIXELFORMAT_RGB16F,
				{
						name: 'RGB16F',
						size: 8
				}
		],
		[
				PIXELFORMAT_RGBA16F,
				{
						name: 'RGBA16F',
						size: 8
				}
		],
		[
				PIXELFORMAT_RGB32F,
				{
						name: 'RGB32F',
						size: 16
				}
		],
		[
				PIXELFORMAT_RGBA32F,
				{
						name: 'RGBA32F',
						size: 16
				}
		],
		[
				PIXELFORMAT_R32F,
				{
						name: 'R32F',
						size: 4
				}
		],
		[
				PIXELFORMAT_DEPTH,
				{
						name: 'DEPTH',
						size: 4
				}
		],
		[
				PIXELFORMAT_DEPTH16,
				{
						name: 'DEPTH16',
						size: 2
				}
		],
		[
				PIXELFORMAT_DEPTHSTENCIL,
				{
						name: 'DEPTHSTENCIL',
						size: 4
				}
		],
		[
				PIXELFORMAT_111110F,
				{
						name: '111110F',
						size: 4
				}
		],
		[
				PIXELFORMAT_SRGB8,
				{
						name: 'SRGB8',
						size: 4,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_SRGBA8,
				{
						name: 'SRGBA8',
						size: 4,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_BGRA8,
				{
						name: 'BGRA8',
						size: 4,
						ldr: true
				}
		],
		[
				PIXELFORMAT_SBGRA8,
				{
						name: 'SBGRA8',
						size: 4,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_DXT1,
				{
						name: 'DXT1',
						blockSize: 8,
						ldr: true,
						srgbFormat: PIXELFORMAT_DXT1_SRGB
				}
		],
		[
				PIXELFORMAT_DXT3,
				{
						name: 'DXT3',
						blockSize: 16,
						ldr: true,
						srgbFormat: PIXELFORMAT_DXT3_SRGBA
				}
		],
		[
				PIXELFORMAT_DXT5,
				{
						name: 'DXT5',
						blockSize: 16,
						ldr: true,
						srgbFormat: PIXELFORMAT_DXT5_SRGBA
				}
		],
		[
				PIXELFORMAT_ETC1,
				{
						name: 'ETC1',
						blockSize: 8,
						ldr: true
				}
		],
		[
				PIXELFORMAT_ETC2_RGB,
				{
						name: 'ETC2_RGB',
						blockSize: 8,
						ldr: true,
						srgbFormat: PIXELFORMAT_ETC2_SRGB
				}
		],
		[
				PIXELFORMAT_ETC2_RGBA,
				{
						name: 'ETC2_RGBA',
						blockSize: 16,
						ldr: true,
						srgbFormat: PIXELFORMAT_ETC2_SRGBA
				}
		],
		[
				PIXELFORMAT_PVRTC_2BPP_RGB_1,
				{
						name: 'PVRTC_2BPP_RGB_1',
						ldr: true,
						blockSize: 8
				}
		],
		[
				PIXELFORMAT_PVRTC_2BPP_RGBA_1,
				{
						name: 'PVRTC_2BPP_RGBA_1',
						ldr: true,
						blockSize: 8
				}
		],
		[
				PIXELFORMAT_PVRTC_4BPP_RGB_1,
				{
						name: 'PVRTC_4BPP_RGB_1',
						ldr: true,
						blockSize: 8
				}
		],
		[
				PIXELFORMAT_PVRTC_4BPP_RGBA_1,
				{
						name: 'PVRTC_4BPP_RGBA_1',
						ldr: true,
						blockSize: 8
				}
		],
		[
				PIXELFORMAT_ASTC_4x4,
				{
						name: 'ASTC_4x4',
						blockSize: 16,
						ldr: true,
						srgbFormat: PIXELFORMAT_ASTC_4x4_SRGB
				}
		],
		[
				PIXELFORMAT_ATC_RGB,
				{
						name: 'ATC_RGB',
						blockSize: 8,
						ldr: true
				}
		],
		[
				PIXELFORMAT_ATC_RGBA,
				{
						name: 'ATC_RGBA',
						blockSize: 16,
						ldr: true
				}
		],
		[
				PIXELFORMAT_BC6F,
				{
						name: 'BC6H_RGBF',
						blockSize: 16
				}
		],
		[
				PIXELFORMAT_BC6UF,
				{
						name: 'BC6H_RGBUF',
						blockSize: 16
				}
		],
		[
				PIXELFORMAT_BC7,
				{
						name: 'BC7_RGBA',
						blockSize: 16,
						ldr: true,
						srgbFormat: PIXELFORMAT_BC7_SRGBA
				}
		],
		[
				PIXELFORMAT_DXT1_SRGB,
				{
						name: 'DXT1_SRGB',
						blockSize: 8,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_DXT3_SRGBA,
				{
						name: 'DXT3_SRGBA',
						blockSize: 16,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_DXT5_SRGBA,
				{
						name: 'DXT5_SRGBA',
						blockSize: 16,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_ETC2_SRGB,
				{
						name: 'ETC2_SRGB',
						blockSize: 8,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_ETC2_SRGBA,
				{
						name: 'ETC2_SRGBA',
						blockSize: 16,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_ASTC_4x4_SRGB,
				{
						name: 'ASTC_4x4_SRGB',
						blockSize: 16,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_BC7_SRGBA,
				{
						name: 'BC7_SRGBA',
						blockSize: 16,
						ldr: true,
						srgb: true
				}
		],
		[
				PIXELFORMAT_R8I,
				{
						name: 'R8I',
						size: 1,
						isInt: true
				}
		],
		[
				PIXELFORMAT_R8U,
				{
						name: 'R8U',
						size: 1,
						isInt: true
				}
		],
		[
				PIXELFORMAT_R16I,
				{
						name: 'R16I',
						size: 2,
						isInt: true
				}
		],
		[
				PIXELFORMAT_R16U,
				{
						name: 'R16U',
						size: 2,
						isInt: true
				}
		],
		[
				PIXELFORMAT_R32I,
				{
						name: 'R32I',
						size: 4,
						isInt: true
				}
		],
		[
				PIXELFORMAT_R32U,
				{
						name: 'R32U',
						size: 4,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RG8I,
				{
						name: 'RG8I',
						size: 2,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RG8U,
				{
						name: 'RG8U',
						size: 2,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RG16I,
				{
						name: 'RG16I',
						size: 4,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RG16U,
				{
						name: 'RG16U',
						size: 4,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RG32I,
				{
						name: 'RG32I',
						size: 8,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RG32U,
				{
						name: 'RG32U',
						size: 8,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RGBA8I,
				{
						name: 'RGBA8I',
						size: 4,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RGBA8U,
				{
						name: 'RGBA8U',
						size: 4,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RGBA16I,
				{
						name: 'RGBA16I',
						size: 8,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RGBA16U,
				{
						name: 'RGBA16U',
						size: 8,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RGBA32I,
				{
						name: 'RGBA32I',
						size: 16,
						isInt: true
				}
		],
		[
				PIXELFORMAT_RGBA32U,
				{
						name: 'RGBA32U',
						size: 16,
						isInt: true
				}
		]
]);
var isCompressedPixelFormat = (format)=>{
		var _pixelFormatInfo_get;
		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.blockSize) !== undefined;
};
var isSrgbPixelFormat = (format)=>{
		var _pixelFormatInfo_get;
		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.srgb) === true;
};
var isIntegerPixelFormat = (format)=>{
		var _pixelFormatInfo_get;
		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.isInt) === true;
};
var pixelFormatLinearToGamma = (format)=>{
		var _pixelFormatInfo_get;
		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.srgbFormat) || format;
};
var pixelFormatGammaToLinear = (format)=>{
		for (var [key, value] of pixelFormatInfo){
				if (value.srgbFormat === format) {
						return key;
				}
		}
		return format;
};
var requiresManualGamma = (format)=>{
		var info = pixelFormatInfo.get(format);
		return !!((info == null ? void 0 : info.ldr) && !(info == null ? void 0 : info.srgb));
};
var getPixelFormatArrayType = (format)=>{
		switch(format){
				case PIXELFORMAT_R32F:
				case PIXELFORMAT_RGB32F:
				case PIXELFORMAT_RGBA32F:
						return Float32Array;
				case PIXELFORMAT_R32I:
				case PIXELFORMAT_RG32I:
				case PIXELFORMAT_RGBA32I:
						return Int32Array;
				case PIXELFORMAT_R32U:
				case PIXELFORMAT_RG32U:
				case PIXELFORMAT_RGBA32U:
						return Uint32Array;
				case PIXELFORMAT_R16I:
				case PIXELFORMAT_RG16I:
				case PIXELFORMAT_RGBA16I:
						return Int16Array;
				case PIXELFORMAT_RG8:
				case PIXELFORMAT_R16U:
				case PIXELFORMAT_RG16U:
				case PIXELFORMAT_RGBA16U:
				case PIXELFORMAT_RGB565:
				case PIXELFORMAT_RGBA5551:
				case PIXELFORMAT_RGBA4:
				case PIXELFORMAT_R16F:
				case PIXELFORMAT_RG16F:
				case PIXELFORMAT_RGB16F:
				case PIXELFORMAT_RGBA16F:
						return Uint16Array;
				case PIXELFORMAT_R8I:
				case PIXELFORMAT_RG8I:
				case PIXELFORMAT_RGBA8I:
						return Int8Array;
				default:
						return Uint8Array;
		}
};
var PRIMITIVE_POINTS = 0;
var PRIMITIVE_LINES = 1;
var PRIMITIVE_LINELOOP = 2;
var PRIMITIVE_LINESTRIP = 3;
var PRIMITIVE_TRIANGLES = 4;
var PRIMITIVE_TRISTRIP = 5;
var PRIMITIVE_TRIFAN = 6;
var SEMANTIC_POSITION = 'POSITION';
var SEMANTIC_NORMAL = 'NORMAL';
var SEMANTIC_TANGENT = 'TANGENT';
var SEMANTIC_BLENDWEIGHT = 'BLENDWEIGHT';
var SEMANTIC_BLENDINDICES = 'BLENDINDICES';
var SEMANTIC_COLOR = 'COLOR';
var SEMANTIC_TEXCOORD = 'TEXCOORD';
var SEMANTIC_TEXCOORD0 = 'TEXCOORD0';
var SEMANTIC_TEXCOORD1 = 'TEXCOORD1';
var SEMANTIC_TEXCOORD2 = 'TEXCOORD2';
var SEMANTIC_TEXCOORD3 = 'TEXCOORD3';
var SEMANTIC_TEXCOORD4 = 'TEXCOORD4';
var SEMANTIC_TEXCOORD5 = 'TEXCOORD5';
var SEMANTIC_TEXCOORD6 = 'TEXCOORD6';
var SEMANTIC_TEXCOORD7 = 'TEXCOORD7';
var SEMANTIC_ATTR0 = 'ATTR0';
var SEMANTIC_ATTR1 = 'ATTR1';
var SEMANTIC_ATTR2 = 'ATTR2';
var SEMANTIC_ATTR3 = 'ATTR3';
var SEMANTIC_ATTR4 = 'ATTR4';
var SEMANTIC_ATTR5 = 'ATTR5';
var SEMANTIC_ATTR6 = 'ATTR6';
var SEMANTIC_ATTR7 = 'ATTR7';
var SEMANTIC_ATTR8 = 'ATTR8';
var SEMANTIC_ATTR9 = 'ATTR9';
var SEMANTIC_ATTR10 = 'ATTR10';
var SEMANTIC_ATTR11 = 'ATTR11';
var SEMANTIC_ATTR12 = 'ATTR12';
var SEMANTIC_ATTR13 = 'ATTR13';
var SEMANTIC_ATTR14 = 'ATTR14';
var SEMANTIC_ATTR15 = 'ATTR15';
var SHADERTAG_MATERIAL = 1;
var STENCILOP_KEEP = 0;
var STENCILOP_ZERO = 1;
var STENCILOP_REPLACE = 2;
var STENCILOP_INCREMENT = 3;
var STENCILOP_INCREMENTWRAP = 4;
var STENCILOP_DECREMENT = 5;
var STENCILOP_DECREMENTWRAP = 6;
var STENCILOP_INVERT = 7;
var TEXTURELOCK_NONE = 0;
var TEXTURELOCK_READ = 1;
var TEXTURELOCK_WRITE = 2;
var TEXTURETYPE_DEFAULT = 'default';
var TEXTURETYPE_RGBM = 'rgbm';
var TEXTURETYPE_RGBE = 'rgbe';
var TEXTURETYPE_RGBP = 'rgbp';
var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
var TEXHINT_NONE = 0;
var TEXHINT_SHADOWMAP = 1;
var TEXHINT_ASSET = 2;
var TEXHINT_LIGHTMAP = 3;
var TEXTUREDIMENSION_1D = '1d';
var TEXTUREDIMENSION_2D = '2d';
var TEXTUREDIMENSION_2D_ARRAY = '2d-array';
var TEXTUREDIMENSION_CUBE = 'cube';
var TEXTUREDIMENSION_CUBE_ARRAY = 'cube-array';
var TEXTUREDIMENSION_3D = '3d';
var SAMPLETYPE_FLOAT = 0;
var SAMPLETYPE_UNFILTERABLE_FLOAT = 1;
var SAMPLETYPE_DEPTH = 2;
var SAMPLETYPE_INT = 3;
var SAMPLETYPE_UINT = 4;
var TEXTUREPROJECTION_NONE = 'none';
var TEXTUREPROJECTION_CUBE = 'cube';
var TEXTUREPROJECTION_EQUIRECT = 'equirect';
var TEXTUREPROJECTION_OCTAHEDRAL = 'octahedral';
var SHADERLANGUAGE_GLSL = 'glsl';
var SHADERLANGUAGE_WGSL = 'wgsl';
var TYPE_INT8 = 0;
var TYPE_UINT8 = 1;
var TYPE_INT16 = 2;
var TYPE_UINT16 = 3;
var TYPE_INT32 = 4;
var TYPE_UINT32 = 5;
var TYPE_FLOAT32 = 6;
var TYPE_FLOAT16 = 7;
var UNIFORMTYPE_BOOL = 0;
var UNIFORMTYPE_INT = 1;
var UNIFORMTYPE_FLOAT = 2;
var UNIFORMTYPE_VEC2 = 3;
var UNIFORMTYPE_VEC3 = 4;
var UNIFORMTYPE_VEC4 = 5;
var UNIFORMTYPE_IVEC2 = 6;
var UNIFORMTYPE_IVEC3 = 7;
var UNIFORMTYPE_IVEC4 = 8;
var UNIFORMTYPE_BVEC2 = 9;
var UNIFORMTYPE_BVEC3 = 10;
var UNIFORMTYPE_BVEC4 = 11;
var UNIFORMTYPE_MAT2 = 12;
var UNIFORMTYPE_MAT3 = 13;
var UNIFORMTYPE_MAT4 = 14;
var UNIFORMTYPE_TEXTURE2D = 15;
var UNIFORMTYPE_TEXTURECUBE = 16;
var UNIFORMTYPE_FLOATARRAY = 17;
var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
var UNIFORMTYPE_TEXTURE3D = 20;
var UNIFORMTYPE_VEC2ARRAY = 21;
var UNIFORMTYPE_VEC3ARRAY = 22;
var UNIFORMTYPE_VEC4ARRAY = 23;
var UNIFORMTYPE_MAT4ARRAY = 24;
var UNIFORMTYPE_TEXTURE2D_ARRAY = 25;
var UNIFORMTYPE_UINT = 26;
var UNIFORMTYPE_UVEC2 = 27;
var UNIFORMTYPE_UVEC3 = 28;
var UNIFORMTYPE_UVEC4 = 29;
var UNIFORMTYPE_INTARRAY = 30;
var UNIFORMTYPE_UINTARRAY = 31;
var UNIFORMTYPE_BOOLARRAY = 32;
var UNIFORMTYPE_IVEC2ARRAY = 33;
var UNIFORMTYPE_UVEC2ARRAY = 34;
var UNIFORMTYPE_BVEC2ARRAY = 35;
var UNIFORMTYPE_IVEC3ARRAY = 36;
var UNIFORMTYPE_UVEC3ARRAY = 37;
var UNIFORMTYPE_BVEC3ARRAY = 38;
var UNIFORMTYPE_IVEC4ARRAY = 39;
var UNIFORMTYPE_UVEC4ARRAY = 40;
var UNIFORMTYPE_BVEC4ARRAY = 41;
var UNIFORMTYPE_ITEXTURE2D = 42;
var UNIFORMTYPE_UTEXTURE2D = 43;
var UNIFORMTYPE_ITEXTURECUBE = 44;
var UNIFORMTYPE_UTEXTURECUBE = 45;
var UNIFORMTYPE_ITEXTURE3D = 46;
var UNIFORMTYPE_UTEXTURE3D = 47;
var UNIFORMTYPE_ITEXTURE2D_ARRAY = 48;
var UNIFORMTYPE_UTEXTURE2D_ARRAY = 49;
var uniformTypeToName = [
		'bool',
		'int',
		'float',
		'vec2',
		'vec3',
		'vec4',
		'ivec2',
		'ivec3',
		'ivec4',
		'bvec2',
		'bvec3',
		'bvec4',
		'mat2',
		'mat3',
		'mat4',
		'sampler2D',
		'samplerCube',
		'',
		'sampler2DShadow',
		'samplerCubeShadow',
		'sampler3D',
		'',
		'',
		'',
		'',
		'sampler2DArray',
		'uint',
		'uvec2',
		'uvec3',
		'uvec4',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'isampler2D',
		'usampler2D',
		'isamplerCube',
		'usamplerCube',
		'isampler3D',
		'usampler3D',
		'isampler2DArray',
		'usampler2DArray'
];
var uniformTypeToNameWGSL = [
		[
				'bool'
		],
		[
				'i32'
		],
		[
				'f32'
		],
		[
				'vec2f',
				'vec2<f32>'
		],
		[
				'vec3f',
				'vec3<f32>'
		],
		[
				'vec4f',
				'vec4<f32>'
		],
		[
				'vec2i',
				'vec2<i32>'
		],
		[
				'vec3i',
				'vec3<i32>'
		],
		[
				'vec4i',
				'vec4<i32>'
		],
		[
				'vec2<bool>'
		],
		[
				'vec3<bool>'
		],
		[
				'vec4<bool>'
		],
		[
				'mat2x2f',
				'mat2x2<f32>'
		],
		[
				'mat3x3f',
				'mat3x3<f32>'
		],
		[
				'mat4x4f',
				'mat4x4<f32>'
		],
		[
				'texture_2d<f32>'
		],
		[
				'texture_cube<f32>'
		],
		[
				'array<f32>'
		],
		[
				'texture_depth_2d'
		],
		[
				'texture_depth_cube'
		],
		[
				'texture_3d<f32>'
		],
		[
				'array<vec2<f32>>'
		],
		[
				'array<vec3<f32>>'
		],
		[
				'array<vec4<f32>>'
		],
		[
				'array<mat4x4<f32>>'
		],
		[
				'texture_2d_array<f32>'
		],
		[
				'u32'
		],
		[
				'vec2u',
				'vec2<u32>'
		],
		[
				'vec3u',
				'vec3<u32>'
		],
		[
				'vec4u',
				'vec4<u32>'
		],
		[
				'array<i32>'
		],
		[
				'array<u32>'
		],
		[
				'array<bool>'
		],
		[
				'array<vec2i>',
				'array<vec2<i32>>'
		],
		[
				'array<vec2u>',
				'array<vec2<u32>>'
		],
		[
				'array<vec2b>',
				'array<vec2<bool>>'
		],
		[
				'array<vec3i>',
				'array<vec3<i32>>'
		],
		[
				'array<vec3u>',
				'array<vec3<u32>>'
		],
		[
				'array<vec3b>',
				'array<vec3<bool>>'
		],
		[
				'array<vec4i>',
				'array<vec4<i32>>'
		],
		[
				'array<vec4u>',
				'array<vec4<u32>>'
		],
		[
				'array<vec4b>',
				'array<vec4<bool>>'
		],
		[
				'texture_2d<i32>'
		],
		[
				'texture_2d<u32>'
		],
		[
				'texture_cube<i32>'
		],
		[
				'texture_cube<u32>'
		],
		[
				'texture_3d<i32>'
		],
		[
				'texture_3d<u32>'
		],
		[
				'texture_2d_array<i32>'
		],
		[
				'texture_2d_array<u32>'
		]
];
var uniformTypeToNameMapWGSL = new Map();
uniformTypeToNameWGSL.forEach((names, index)=>{
		names.forEach((name)=>uniformTypeToNameMapWGSL.set(name, index));
});
var uniformTypeToStorage = new Uint8Array([
		TYPE_INT32,
		TYPE_INT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_FLOAT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_FLOAT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_UINT32,
		TYPE_UINT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_UINT32,
		TYPE_INT32,
		TYPE_UINT32
]);
var DEVICETYPE_WEBGL2 = 'webgl2';
var DEVICETYPE_WEBGPU = 'webgpu';
var DEVICETYPE_NULL = 'null';
var SHADERSTAGE_VERTEX = 1;
var SHADERSTAGE_FRAGMENT = 2;
var SHADERSTAGE_COMPUTE = 4;
var DISPLAYFORMAT_LDR = 'ldr';
var DISPLAYFORMAT_LDR_SRGB = 'ldr_srgb';
var DISPLAYFORMAT_HDR = 'hdr';
var TEXPROPERTY_MIN_FILTER = 1;
var TEXPROPERTY_MAG_FILTER = 2;
var TEXPROPERTY_ADDRESS_U = 4;
var TEXPROPERTY_ADDRESS_V = 8;
var TEXPROPERTY_ADDRESS_W = 16;
var TEXPROPERTY_COMPARE_ON_READ = 32;
var TEXPROPERTY_COMPARE_FUNC = 64;
var TEXPROPERTY_ANISOTROPY = 128;
var TEXPROPERTY_ALL = 255;
var BINDGROUP_VIEW = 0;
var BINDGROUP_MESH = 1;
var BINDGROUP_MESH_UB = 2;
var bindGroupNames = [
		'view',
		'mesh',
		'mesh_ub'
];
var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';
var UNUSED_UNIFORM_NAME = '_unused_float_uniform';
var typedArrayTypes = [
		Int8Array,
		Uint8Array,
		Int16Array,
		Uint16Array,
		Int32Array,
		Uint32Array,
		Float32Array,
		Uint16Array
];
var typedArrayTypesByteSize = [
		1,
		1,
		2,
		2,
		4,
		4,
		4,
		2
];
var vertexTypesNames = [
		'INT8',
		'UINT8',
		'INT16',
		'UINT16',
		'INT32',
		'UINT32',
		'FLOAT32',
		'FLOAT16'
];
var typedArrayToType = {
		'Int8Array': TYPE_INT8,
		'Uint8Array': TYPE_UINT8,
		'Int16Array': TYPE_INT16,
		'Uint16Array': TYPE_UINT16,
		'Int32Array': TYPE_INT32,
		'Uint32Array': TYPE_UINT32,
		'Float32Array': TYPE_FLOAT32
};
var typedArrayIndexFormats = [
		Uint8Array,
		Uint16Array,
		Uint32Array
];
var typedArrayIndexFormatsByteSize = [
		1,
		2,
		4
];
var semanticToLocation = {};
semanticToLocation[SEMANTIC_POSITION] = 0;
semanticToLocation[SEMANTIC_NORMAL] = 1;
semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
semanticToLocation[SEMANTIC_COLOR] = 4;
semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
semanticToLocation[SEMANTIC_TANGENT] = 13;
semanticToLocation[SEMANTIC_ATTR0] = 0;
semanticToLocation[SEMANTIC_ATTR1] = 1;
semanticToLocation[SEMANTIC_ATTR2] = 2;
semanticToLocation[SEMANTIC_ATTR3] = 3;
semanticToLocation[SEMANTIC_ATTR4] = 4;
semanticToLocation[SEMANTIC_ATTR5] = 5;
semanticToLocation[SEMANTIC_ATTR6] = 6;
semanticToLocation[SEMANTIC_ATTR7] = 7;
semanticToLocation[SEMANTIC_ATTR8] = 8;
semanticToLocation[SEMANTIC_ATTR9] = 9;
semanticToLocation[SEMANTIC_ATTR10] = 10;
semanticToLocation[SEMANTIC_ATTR11] = 11;
semanticToLocation[SEMANTIC_ATTR12] = 12;
semanticToLocation[SEMANTIC_ATTR13] = 13;
semanticToLocation[SEMANTIC_ATTR14] = 14;
semanticToLocation[SEMANTIC_ATTR15] = 15;
var CHUNKAPI_1_51 = '1.51';
var CHUNKAPI_1_55 = '1.55';
var CHUNKAPI_1_56 = '1.56';
var CHUNKAPI_1_57 = '1.57';
var CHUNKAPI_1_58 = '1.58';
var CHUNKAPI_1_60 = '1.60';
var CHUNKAPI_1_62 = '1.62';
var CHUNKAPI_1_65 = '1.65';
var CHUNKAPI_1_70 = '1.70';
var CHUNKAPI_2_1 = '2.1';
var CHUNKAPI_2_3 = '2.3';
var CHUNKAPI_2_5 = '2.5';
var CHUNKAPI_2_6 = '2.6';

var id$b = 0;
class BindBaseFormat {
		constructor(name, visibility){
				this.slot = -1;
				this.scopeId = null;
				this.name = name;
				this.visibility = visibility;
		}
}
class BindUniformBufferFormat extends BindBaseFormat {
}
class BindStorageBufferFormat extends BindBaseFormat {
		constructor(name, visibility, readOnly = false){
				super(name, visibility), this.format = '';
				this.readOnly = readOnly;
		}
}
class BindTextureFormat extends BindBaseFormat {
		constructor(name, visibility, textureDimension = TEXTUREDIMENSION_2D, sampleType = SAMPLETYPE_FLOAT, hasSampler = true, samplerName = null){
				super(name, visibility);
				this.textureDimension = textureDimension;
				this.sampleType = sampleType;
				this.hasSampler = hasSampler;
				this.samplerName = samplerName != null ? samplerName : "" + name + "_sampler";
		}
}
class BindStorageTextureFormat extends BindBaseFormat {
		constructor(name, format = PIXELFORMAT_RGBA8, textureDimension = TEXTUREDIMENSION_2D, write = true, read = false){
				super(name, SHADERSTAGE_COMPUTE);
				this.format = format;
				this.textureDimension = textureDimension;
				this.write = write;
				this.read = read;
		}
}
class BindGroupFormat {
		destroy() {
				this.impl.destroy();
		}
		getTexture(name) {
				var index = this.textureFormatsMap.get(name);
				if (index !== undefined) {
						return this.textureFormats[index];
				}
				return null;
		}
		getStorageTexture(name) {
				var index = this.storageTextureFormatsMap.get(name);
				if (index !== undefined) {
						return this.storageTextureFormats[index];
				}
				return null;
		}
		loseContext() {}
		constructor(graphicsDevice, formats){
				this.uniformBufferFormats = [];
				this.textureFormats = [];
				this.storageTextureFormats = [];
				this.storageBufferFormats = [];
				this.id = id$b++;
				var slot = 0;
				formats.forEach((format)=>{
						format.slot = slot++;
						if (format instanceof BindTextureFormat && format.hasSampler) {
								slot++;
						}
						if (format instanceof BindUniformBufferFormat) {
								this.uniformBufferFormats.push(format);
						} else if (format instanceof BindTextureFormat) {
								this.textureFormats.push(format);
						} else if (format instanceof BindStorageTextureFormat) {
								this.storageTextureFormats.push(format);
						} else if (format instanceof BindStorageBufferFormat) {
								this.storageBufferFormats.push(format);
						} else ;
				});
				this.device = graphicsDevice;
				var scope = graphicsDevice.scope;
				this.bufferFormatsMap = new Map();
				this.uniformBufferFormats.forEach((bf, i)=>this.bufferFormatsMap.set(bf.name, i));
				this.textureFormatsMap = new Map();
				this.textureFormats.forEach((tf, i)=>{
						this.textureFormatsMap.set(tf.name, i);
						tf.scopeId = scope.resolve(tf.name);
				});
				this.storageTextureFormatsMap = new Map();
				this.storageTextureFormats.forEach((tf, i)=>{
						this.storageTextureFormatsMap.set(tf.name, i);
						tf.scopeId = scope.resolve(tf.name);
				});
				this.storageBufferFormatsMap = new Map();
				this.storageBufferFormats.forEach((bf, i)=>{
						this.storageBufferFormatsMap.set(bf.name, i);
						bf.scopeId = scope.resolve(bf.name);
				});
				this.impl = graphicsDevice.createBindGroupFormatImpl(this);
		}
}

class DeviceCache {
		get(device, onCreate) {
				if (!this._cache.has(device)) {
						this._cache.set(device, onCreate());
						device.on('destroy', ()=>{
								this.remove(device);
						});
						device.on('devicelost', ()=>{
								var _this__cache_get_loseContext, _this__cache_get;
								(_this__cache_get = this._cache.get(device)) == null ? void 0 : (_this__cache_get_loseContext = _this__cache_get.loseContext) == null ? void 0 : _this__cache_get_loseContext.call(_this__cache_get, device);
						});
				}
				return this._cache.get(device);
		}
		remove(device) {
				var _this__cache_get_destroy, _this__cache_get;
				(_this__cache_get = this._cache.get(device)) == null ? void 0 : (_this__cache_get_destroy = _this__cache_get.destroy) == null ? void 0 : _this__cache_get_destroy.call(_this__cache_get, device);
				this._cache.delete(device);
		}
		constructor(){
				this._cache = new Map();
		}
}

class TextureUtils {
		static calcLevelDimension(dimension, mipLevel) {
				return Math.max(dimension >> mipLevel, 1);
		}
		static calcMipLevelsCount(width, height, depth) {
				if (depth === void 0) depth = 1;
				return 1 + Math.floor(Math.log2(Math.max(width, height, depth)));
		}
		static calcLevelGpuSize(width, height, depth, format) {
				var _pixelFormatInfo_get;
				var formatInfo = pixelFormatInfo.get(format);
				var _pixelFormatInfo_get_size;
				var pixelSize = (_pixelFormatInfo_get_size = (_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.size) != null ? _pixelFormatInfo_get_size : 0;
				if (pixelSize > 0) {
						return width * height * depth * pixelSize;
				}
				var _formatInfo_blockSize;
				var blockSize = (_formatInfo_blockSize = formatInfo.blockSize) != null ? _formatInfo_blockSize : 0;
				var blockWidth = Math.floor((width + 3) / 4);
				var blockHeight = Math.floor((height + 3) / 4);
				var blockDepth = Math.floor((depth + 3) / 4);
				if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
						blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
				}
				return blockWidth * blockHeight * blockDepth * blockSize;
		}
		static calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
				var result = 0;
				while(1){
						result += TextureUtils.calcLevelGpuSize(width, height, depth, format);
						if (!mipmaps || width === 1 && height === 1 && depth === 1) {
								break;
						}
						width = Math.max(width >> 1, 1);
						height = Math.max(height >> 1, 1);
						depth = Math.max(depth >> 1, 1);
				}
				return result * (cubemap ? 6 : 1);
		}
}

var id$a = 0;
class Texture {
		destroy() {
				var device = this.device;
				if (device) {
						var idx = device.textures.indexOf(this);
						if (idx !== -1) {
								device.textures.splice(idx, 1);
						}
						device.scope.removeValue(this);
						this.impl.destroy(device);
						this.adjustVramSizeTracking(device._vram, -this._gpuSize);
						this._levels = null;
						this.device = null;
				}
		}
		recreateImpl(upload) {
				if (upload === void 0) upload = true;
				var _this_impl;
				var { device } = this;
				(_this_impl = this.impl) == null ? void 0 : _this_impl.destroy(device);
				this.impl = null;
				this.impl = device.createTextureImpl(this);
				this.dirtyAll();
				if (upload) {
						this.upload();
				}
		}
		resize(width, height, depth) {
				if (depth === void 0) depth = 1;
				var device = this.device;
				this.adjustVramSizeTracking(device._vram, -this._gpuSize);
				this.impl.destroy(device);
				this._width = Math.floor(width);
				this._height = Math.floor(height);
				this._depth = Math.floor(depth);
				this._updateNumLevel();
				this.impl = device.createTextureImpl(this);
				this.dirtyAll();
		}
		loseContext() {
				this.impl.loseContext();
				this.dirtyAll();
		}
		adjustVramSizeTracking(vram, size) {
				vram.tex += size;
		}
		propertyChanged(flag) {
				this.impl.propertyChanged(flag);
				this.renderVersionDirty = this.device.renderVersion;
		}
		_updateNumLevel() {
				var maxLevels = this.mipmaps ? TextureUtils.calcMipLevelsCount(this.width, this.height) : 1;
				var requestedLevels = this._numLevelsRequested;
				this._numLevels = Math.min(requestedLevels != null ? requestedLevels : maxLevels, maxLevels);
				this._mipmaps = this._numLevels > 1;
		}
		get lockedMode() {
				return this._lockedMode;
		}
		set minFilter(v) {
				if (this._minFilter !== v) {
						if (isIntegerPixelFormat(this._format)) ; else {
								this._minFilter = v;
								this.propertyChanged(TEXPROPERTY_MIN_FILTER);
						}
				}
		}
		get minFilter() {
				return this._minFilter;
		}
		set magFilter(v) {
				if (this._magFilter !== v) {
						if (isIntegerPixelFormat(this._format)) ; else {
								this._magFilter = v;
								this.propertyChanged(TEXPROPERTY_MAG_FILTER);
						}
				}
		}
		get magFilter() {
				return this._magFilter;
		}
		set addressU(v) {
				if (this._addressU !== v) {
						this._addressU = v;
						this.propertyChanged(TEXPROPERTY_ADDRESS_U);
				}
		}
		get addressU() {
				return this._addressU;
		}
		set addressV(v) {
				if (this._addressV !== v) {
						this._addressV = v;
						this.propertyChanged(TEXPROPERTY_ADDRESS_V);
				}
		}
		get addressV() {
				return this._addressV;
		}
		set addressW(addressW) {
				if (!this._volume) {
						return;
				}
				if (addressW !== this._addressW) {
						this._addressW = addressW;
						this.propertyChanged(TEXPROPERTY_ADDRESS_W);
				}
		}
		get addressW() {
				return this._addressW;
		}
		set compareOnRead(v) {
				if (this._compareOnRead !== v) {
						this._compareOnRead = v;
						this.propertyChanged(TEXPROPERTY_COMPARE_ON_READ);
				}
		}
		get compareOnRead() {
				return this._compareOnRead;
		}
		set compareFunc(v) {
				if (this._compareFunc !== v) {
						this._compareFunc = v;
						this.propertyChanged(TEXPROPERTY_COMPARE_FUNC);
				}
		}
		get compareFunc() {
				return this._compareFunc;
		}
		set anisotropy(v) {
				if (this._anisotropy !== v) {
						this._anisotropy = v;
						this.propertyChanged(TEXPROPERTY_ANISOTROPY);
				}
		}
		get anisotropy() {
				return this._anisotropy;
		}
		set mipmaps(v) {
				if (this._mipmaps !== v) {
						if (this.device.isWebGPU) ; else if (isIntegerPixelFormat(this._format)) ; else {
								this._mipmaps = v;
						}
						if (v) this._needsMipmapsUpload = true;
				}
		}
		get mipmaps() {
				return this._mipmaps;
		}
		get numLevels() {
				return this._numLevels;
		}
		get storage() {
				return this._storage;
		}
		get width() {
				return this._width;
		}
		get height() {
				return this._height;
		}
		get depth() {
				return this._depth;
		}
		get format() {
				return this._format;
		}
		get cubemap() {
				return this._cubemap;
		}
		get gpuSize() {
				var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
				return TextureUtils.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
		}
		get array() {
				return this._arrayLength > 0;
		}
		get arrayLength() {
				return this._arrayLength;
		}
		get volume() {
				return this._volume;
		}
		set srgb(value) {
				var currentSrgb = isSrgbPixelFormat(this.format);
				if (value !== currentSrgb) {
						if (value) {
								var srgbFormat = pixelFormatLinearToGamma(this.format);
								if (this._format !== srgbFormat) {
										this._format = srgbFormat;
										this.recreateImpl();
										this.device._shadersDirty = true;
								}
						} else {
								var linearFormat = pixelFormatGammaToLinear(this.format);
								if (this._format !== linearFormat) {
										this._format = linearFormat;
										this.recreateImpl();
										this.device._shadersDirty = true;
								}
						}
				}
		}
		get srgb() {
				return isSrgbPixelFormat(this.format);
		}
		set flipY(flipY) {
				if (this._flipY !== flipY) {
						this._flipY = flipY;
						this._needsUpload = true;
				}
		}
		get flipY() {
				return this._flipY;
		}
		set premultiplyAlpha(premultiplyAlpha) {
				if (this._premultiplyAlpha !== premultiplyAlpha) {
						this._premultiplyAlpha = premultiplyAlpha;
						this._needsUpload = true;
				}
		}
		get premultiplyAlpha() {
				return this._premultiplyAlpha;
		}
		get pot() {
				return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
		}
		get encoding() {
				switch(this.type){
						case TEXTURETYPE_RGBM:
								return 'rgbm';
						case TEXTURETYPE_RGBE:
								return 'rgbe';
						case TEXTURETYPE_RGBP:
								return 'rgbp';
				}
				return requiresManualGamma(this.format) ? 'srgb' : 'linear';
		}
		dirtyAll() {
				this._levelsUpdated = this._cubemap ? [
						[
								true,
								true,
								true,
								true,
								true,
								true
						]
				] : [
						true
				];
				this._needsUpload = true;
				this._needsMipmapsUpload = this._mipmaps;
				this._mipmapsUploaded = false;
				this.propertyChanged(TEXPROPERTY_ALL);
		}
		lock(options) {
				if (options === void 0) options = {};
				var _options, _options1, _options2;
				var _level;
				(_level = (_options = options).level) != null ? _level : _options.level = 0;
				var _face;
				(_face = (_options1 = options).face) != null ? _face : _options1.face = 0;
				var _mode;
				(_mode = (_options2 = options).mode) != null ? _mode : _options2.mode = TEXTURELOCK_WRITE;
				this._lockedMode = options.mode;
				this._lockedLevel = options.level;
				var levels = this.cubemap ? this._levels[options.face] : this._levels;
				if (levels[options.level] === null) {
						var width = Math.max(1, this._width >> options.level);
						var height = Math.max(1, this._height >> options.level);
						var depth = Math.max(1, this._depth >> options.level);
						var data = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, depth, this._format));
						levels[options.level] = new (getPixelFormatArrayType(this._format))(data);
				}
				return levels[options.level];
		}
		setSource(source, mipLevel) {
				if (mipLevel === void 0) mipLevel = 0;
				var invalid = false;
				var width, height;
				if (this._cubemap) {
						if (source[0]) {
								width = source[0].width || 0;
								height = source[0].height || 0;
								for(var i = 0; i < 6; i++){
										var face = source[i];
										if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
												invalid = true;
												break;
										}
								}
						} else {
								invalid = true;
						}
						if (!invalid) {
								for(var i1 = 0; i1 < 6; i1++){
										if (this._levels[mipLevel][i1] !== source[i1]) {
												this._levelsUpdated[mipLevel][i1] = true;
										}
								}
						}
				} else {
						if (!this.device._isBrowserInterface(source)) {
								invalid = true;
						}
						if (!invalid) {
								if (source !== this._levels[mipLevel]) {
										this._levelsUpdated[mipLevel] = true;
								}
								if (source instanceof HTMLVideoElement) {
										width = source.videoWidth;
										height = source.videoHeight;
								} else {
										width = source.width;
										height = source.height;
								}
						}
				}
				if (invalid) {
						this._width = 4;
						this._height = 4;
						if (this._cubemap) {
								for(var i2 = 0; i2 < 6; i2++){
										this._levels[mipLevel][i2] = null;
										this._levelsUpdated[mipLevel][i2] = true;
								}
						} else {
								this._levels[mipLevel] = null;
								this._levelsUpdated[mipLevel] = true;
						}
				} else {
						if (mipLevel === 0) {
								this._width = width;
								this._height = height;
						}
						this._levels[mipLevel] = source;
				}
				if (this._invalid !== invalid || !invalid) {
						this._invalid = invalid;
						this.upload();
				}
		}
		getSource(mipLevel) {
				if (mipLevel === void 0) mipLevel = 0;
				return this._levels[mipLevel];
		}
		unlock() {
				if (this._lockedMode === TEXTURELOCK_NONE) ;
				if (this._lockedMode === TEXTURELOCK_WRITE) {
						this.upload();
				}
				this._lockedLevel = -1;
				this._lockedMode = TEXTURELOCK_NONE;
		}
		upload() {
				this._needsUpload = true;
				this._needsMipmapsUpload = this._mipmaps;
				this.impl.uploadImmediate == null ? void 0 : this.impl.uploadImmediate.call(this.impl, this.device, this);
		}
		read(x, y, width, height, options) {
				if (options === void 0) options = {};
				return this.impl.read == null ? void 0 : this.impl.read.call(this.impl, x, y, width, height, options);
		}
		constructor(graphicsDevice, options = {}){
				this._gpuSize = 0;
				this.id = id$a++;
				this._invalid = false;
				this._lockedLevel = -1;
				this._lockedMode = TEXTURELOCK_NONE;
				this.renderVersionDirty = 0;
				this._storage = false;
				this._numLevels = 0;
				this.device = graphicsDevice;
				var _options_name;
				this.name = (_options_name = options.name) != null ? _options_name : '';
				var _options_width;
				this._width = Math.floor((_options_width = options.width) != null ? _options_width : 4);
				var _options_height;
				this._height = Math.floor((_options_height = options.height) != null ? _options_height : 4);
				var _options_format;
				this._format = (_options_format = options.format) != null ? _options_format : PIXELFORMAT_RGBA8;
				this._compressed = isCompressedPixelFormat(this._format);
				this._integerFormat = isIntegerPixelFormat(this._format);
				if (this._integerFormat) {
						options.minFilter = FILTER_NEAREST;
						options.magFilter = FILTER_NEAREST;
				}
				var _options_volume;
				this._volume = (_options_volume = options.volume) != null ? _options_volume : false;
				var _options_depth;
				this._depth = Math.floor((_options_depth = options.depth) != null ? _options_depth : 1);
				var _options_arrayLength;
				this._arrayLength = Math.floor((_options_arrayLength = options.arrayLength) != null ? _options_arrayLength : 0);
				var _options_storage;
				this._storage = (_options_storage = options.storage) != null ? _options_storage : false;
				var _options_cubemap;
				this._cubemap = (_options_cubemap = options.cubemap) != null ? _options_cubemap : false;
				var _options_flipY;
				this._flipY = (_options_flipY = options.flipY) != null ? _options_flipY : false;
				var _options_premultiplyAlpha;
				this._premultiplyAlpha = (_options_premultiplyAlpha = options.premultiplyAlpha) != null ? _options_premultiplyAlpha : false;
				var _options_mipmaps;
				this._mipmaps = (_options_mipmaps = options.mipmaps) != null ? _options_mipmaps : true;
				this._numLevelsRequested = options.numLevels;
				if (options.numLevels !== undefined) {
						this._numLevels = options.numLevels;
				}
				this._updateNumLevel();
				var _options_minFilter;
				this._minFilter = (_options_minFilter = options.minFilter) != null ? _options_minFilter : FILTER_LINEAR_MIPMAP_LINEAR;
				var _options_magFilter;
				this._magFilter = (_options_magFilter = options.magFilter) != null ? _options_magFilter : FILTER_LINEAR;
				var _options_anisotropy;
				this._anisotropy = (_options_anisotropy = options.anisotropy) != null ? _options_anisotropy : 1;
				var _options_addressU;
				this._addressU = (_options_addressU = options.addressU) != null ? _options_addressU : ADDRESS_REPEAT;
				var _options_addressV;
				this._addressV = (_options_addressV = options.addressV) != null ? _options_addressV : ADDRESS_REPEAT;
				var _options_addressW;
				this._addressW = (_options_addressW = options.addressW) != null ? _options_addressW : ADDRESS_REPEAT;
				var _options_compareOnRead;
				this._compareOnRead = (_options_compareOnRead = options.compareOnRead) != null ? _options_compareOnRead : false;
				var _options_compareFunc;
				this._compareFunc = (_options_compareFunc = options.compareFunc) != null ? _options_compareFunc : FUNC_LESS;
				this.type = options.hasOwnProperty('type') ? options.type : TEXTURETYPE_DEFAULT;
				this.projection = TEXTUREPROJECTION_NONE;
				if (this._cubemap) {
						this.projection = TEXTUREPROJECTION_CUBE;
				} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
						this.projection = options.projection;
				}
				this._levels = options.levels;
				var upload = !!options.levels;
				if (!this._levels) {
						this._levels = this._cubemap ? [
								[
										null,
										null,
										null,
										null,
										null,
										null
								]
						] : [
								null
						];
				}
				this.recreateImpl(upload);
				graphicsDevice.textures.push(this);
		}
}

var textureData = {
		white: [
				255,
				255,
				255,
				255
		],
		gray: [
				128,
				128,
				128,
				255
		],
		black: [
				0,
				0,
				0,
				255
		],
		normal: [
				128,
				128,
				255,
				255
		],
		pink: [
				255,
				128,
				255,
				255
		]
};
class BuiltInTextures {
		destroy() {
				this.map.forEach((texture)=>{
						texture.destroy();
				});
		}
		constructor(){
				this.map = new Map();
		}
}
var deviceCache$3 = new DeviceCache();
var getBuiltInTexture = (device, name)=>{
		var cache = deviceCache$3.get(device, ()=>{
				return new BuiltInTextures();
		});
		if (!cache.map.has(name)) {
				var texture = new Texture(device, {
						name: "built-in-texture-" + name,
						width: 1,
						height: 1,
						format: PIXELFORMAT_RGBA8
				});
				var pixels = texture.lock();
				var data = textureData[name];
				pixels.set(data);
				texture.unlock();
				cache.map.set(name, texture);
		}
		return cache.map.get(name);
};

var id$9 = 0;
class DynamicBindGroup {
		constructor(){
				this.offsets = [];
		}
}
class BindGroup {
		destroy() {
				this.impl.destroy();
				this.impl = null;
				this.format = null;
				this.defaultUniformBuffer = null;
		}
		setUniformBuffer(name, uniformBuffer) {
				var index = this.format.bufferFormatsMap.get(name);
				if (this.uniformBuffers[index] !== uniformBuffer) {
						this.uniformBuffers[index] = uniformBuffer;
						this.dirty = true;
				}
		}
		setStorageBuffer(name, storageBuffer) {
				var index = this.format.storageBufferFormatsMap.get(name);
				if (this.storageBuffers[index] !== storageBuffer) {
						this.storageBuffers[index] = storageBuffer;
						this.dirty = true;
				}
		}
		setTexture(name, texture) {
				var index = this.format.textureFormatsMap.get(name);
				if (this.textures[index] !== texture) {
						this.textures[index] = texture;
						this.dirty = true;
				} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
						this.dirty = true;
				}
		}
		setStorageTexture(name, texture) {
				var index = this.format.storageTextureFormatsMap.get(name);
				if (this.storageTextures[index] !== texture) {
						this.storageTextures[index] = texture;
						this.dirty = true;
				} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
						this.dirty = true;
				}
		}
		updateUniformBuffers() {
				for(var i = 0; i < this.uniformBuffers.length; i++){
						this.uniformBuffers[i].update();
				}
		}
		update() {
				var { textureFormats, storageTextureFormats, storageBufferFormats } = this.format;
				for(var i = 0; i < textureFormats.length; i++){
						var textureFormat = textureFormats[i];
						var value = textureFormat.scopeId.value;
						if (!value) {
								if (textureFormat.name === 'uSceneDepthMap') {
										value = getBuiltInTexture(this.device, 'white');
								}
								if (textureFormat.name === 'uSceneColorMap') {
										value = getBuiltInTexture(this.device, 'pink');
								}
								if (!value) {
										value = getBuiltInTexture(this.device, 'pink');
								}
						}
						this.setTexture(textureFormat.name, value);
				}
				for(var i1 = 0; i1 < storageTextureFormats.length; i1++){
						var storageTextureFormat = storageTextureFormats[i1];
						var value1 = storageTextureFormat.scopeId.value;
						this.setStorageTexture(storageTextureFormat.name, value1);
				}
				for(var i2 = 0; i2 < storageBufferFormats.length; i2++){
						var storageBufferFormat = storageBufferFormats[i2];
						var value2 = storageBufferFormat.scopeId.value;
						this.setStorageBuffer(storageBufferFormat.name, value2);
				}
				this.uniformBufferOffsets.length = this.uniformBuffers.length;
				for(var i3 = 0; i3 < this.uniformBuffers.length; i3++){
						var uniformBuffer = this.uniformBuffers[i3];
						this.uniformBufferOffsets[i3] = uniformBuffer.offset;
						if (this.renderVersionUpdated < uniformBuffer.renderVersionDirty) {
								this.dirty = true;
						}
				}
				if (this.dirty) {
						this.dirty = false;
						this.renderVersionUpdated = this.device.renderVersion;
						this.impl.update(this);
				}
		}
		constructor(graphicsDevice, format, defaultUniformBuffer){
				this.renderVersionUpdated = -1;
				this.uniformBufferOffsets = [];
				this.id = id$9++;
				this.device = graphicsDevice;
				this.format = format;
				this.dirty = true;
				this.impl = graphicsDevice.createBindGroupImpl(this);
				this.textures = [];
				this.storageTextures = [];
				this.storageBuffers = [];
				this.uniformBuffers = [];
				this.defaultUniformBuffer = defaultUniformBuffer;
				if (defaultUniformBuffer) {
						this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);
				}
		}
}

var BitPacking = {
		set (storage, value, shift, mask) {
				if (mask === void 0) mask = 1;
				var data = storage & ~(mask << shift);
				return data | value << shift;
		},
		get (storage, shift, mask) {
				if (mask === void 0) mask = 1;
				return storage >> shift & mask;
		},
		all (storage, shift, mask) {
				if (mask === void 0) mask = 1;
				var shifted = mask << shift;
				return (storage & shifted) === shifted;
		},
		any (storage, shift, mask) {
				if (mask === void 0) mask = 1;
				return (storage & mask << shift) !== 0;
		}
};

var opMask = 7;
var factorMask = 15;
var colorOpShift = 0;
var colorSrcFactorShift = 3;
var colorDstFactorShift = 7;
var alphaOpShift = 11;
var alphaSrcFactorShift = 14;
var alphaDstFactorShift = 18;
var redWriteShift = 22;
var greenWriteShift = 23;
var blueWriteShift = 24;
var alphaWriteShift = 25;
var blendShift = 26;
var allWriteMasks = 15;
var allWriteShift = redWriteShift;
class BlendState {
		set blend(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blendShift);
		}
		get blend() {
				return BitPacking.all(this.target0, blendShift);
		}
		setColorBlend(op, srcFactor, dstFactor) {
				this.target0 = BitPacking.set(this.target0, op, colorOpShift, opMask);
				this.target0 = BitPacking.set(this.target0, srcFactor, colorSrcFactorShift, factorMask);
				this.target0 = BitPacking.set(this.target0, dstFactor, colorDstFactorShift, factorMask);
		}
		setAlphaBlend(op, srcFactor, dstFactor) {
				this.target0 = BitPacking.set(this.target0, op, alphaOpShift, opMask);
				this.target0 = BitPacking.set(this.target0, srcFactor, alphaSrcFactorShift, factorMask);
				this.target0 = BitPacking.set(this.target0, dstFactor, alphaDstFactorShift, factorMask);
		}
		setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite) {
				this.redWrite = redWrite;
				this.greenWrite = greenWrite;
				this.blueWrite = blueWrite;
				this.alphaWrite = alphaWrite;
		}
		get colorOp() {
				return BitPacking.get(this.target0, colorOpShift, opMask);
		}
		get colorSrcFactor() {
				return BitPacking.get(this.target0, colorSrcFactorShift, factorMask);
		}
		get colorDstFactor() {
				return BitPacking.get(this.target0, colorDstFactorShift, factorMask);
		}
		get alphaOp() {
				return BitPacking.get(this.target0, alphaOpShift, opMask);
		}
		get alphaSrcFactor() {
				return BitPacking.get(this.target0, alphaSrcFactorShift, factorMask);
		}
		get alphaDstFactor() {
				return BitPacking.get(this.target0, alphaDstFactorShift, factorMask);
		}
		set redWrite(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, redWriteShift);
		}
		get redWrite() {
				return BitPacking.all(this.target0, redWriteShift);
		}
		set greenWrite(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, greenWriteShift);
		}
		get greenWrite() {
				return BitPacking.all(this.target0, greenWriteShift);
		}
		set blueWrite(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blueWriteShift);
		}
		get blueWrite() {
				return BitPacking.all(this.target0, blueWriteShift);
		}
		set alphaWrite(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, alphaWriteShift);
		}
		get alphaWrite() {
				return BitPacking.all(this.target0, alphaWriteShift);
		}
		get allWrite() {
				return BitPacking.get(this.target0, allWriteShift, allWriteMasks);
		}
		copy(rhs) {
				this.target0 = rhs.target0;
				return this;
		}
		clone() {
				var clone = new this.constructor();
				return clone.copy(this);
		}
		get key() {
				return this.target0;
		}
		equals(rhs) {
				return this.target0 === rhs.target0;
		}
		constructor(blend = false, colorOp = BLENDEQUATION_ADD, colorSrcFactor = BLENDMODE_ONE, colorDstFactor = BLENDMODE_ZERO, alphaOp, alphaSrcFactor, alphaDstFactor, redWrite = true, greenWrite = true, blueWrite = true, alphaWrite = true){
				this.target0 = 0;
				this.setColorBlend(colorOp, colorSrcFactor, colorDstFactor);
				this.setAlphaBlend(alphaOp != null ? alphaOp : colorOp, alphaSrcFactor != null ? alphaSrcFactor : colorSrcFactor, alphaDstFactor != null ? alphaDstFactor : colorDstFactor);
				this.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
				this.blend = blend;
		}
}
BlendState.NOBLEND = Object.freeze(new BlendState());
BlendState.NOWRITE = Object.freeze(new BlendState(undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, false, false, false));
BlendState.ALPHABLEND = Object.freeze(new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA));
BlendState.ADDBLEND = Object.freeze(new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE));

class StringIds {
		get(name) {
				var value = this.map.get(name);
				if (value === undefined) {
						value = this.id++;
						this.map.set(name, value);
				}
				return value;
		}
		constructor(){
				this.map = new Map();
				this.id = 0;
		}
}

var stringIds$4 = new StringIds();
var funcMask = 7;
var funcShift = 0;
var writeShift = 3;
class DepthState {
		set test(value) {
				this.func = value ? FUNC_LESSEQUAL : FUNC_ALWAYS;
				this.updateKey();
		}
		get test() {
				return this.func !== FUNC_ALWAYS;
		}
		set write(value) {
				this.data = BitPacking.set(this.data, value ? 1 : 0, writeShift);
				this.updateKey();
		}
		get write() {
				return BitPacking.all(this.data, writeShift);
		}
		set func(value) {
				this.data = BitPacking.set(this.data, value, funcShift, funcMask);
				this.updateKey();
		}
		get func() {
				return BitPacking.get(this.data, funcShift, funcMask);
		}
		set depthBias(value) {
				this._depthBias = value;
				this.updateKey();
		}
		get depthBias() {
				return this._depthBias;
		}
		set depthBiasSlope(value) {
				this._depthBiasSlope = value;
				this.updateKey();
		}
		get depthBiasSlope() {
				return this._depthBiasSlope;
		}
		copy(rhs) {
				this.data = rhs.data;
				this._depthBias = rhs._depthBias;
				this._depthBiasSlope = rhs._depthBiasSlope;
				this.key = rhs.key;
				return this;
		}
		clone() {
				var clone = new this.constructor();
				return clone.copy(this);
		}
		updateKey() {
				var { data, _depthBias, _depthBiasSlope } = this;
				var key = data + "-" + _depthBias + "-" + _depthBiasSlope;
				this.key = stringIds$4.get(key);
		}
		equals(rhs) {
				return this.key === rhs.key;
		}
		constructor(func = FUNC_LESSEQUAL, write = true){
				this.data = 0;
				this._depthBias = 0;
				this._depthBiasSlope = 0;
				this.key = 0;
				this.func = func;
				this.write = write;
		}
}
DepthState.DEFAULT = Object.freeze(new DepthState());
DepthState.NODEPTH = Object.freeze(new DepthState(FUNC_ALWAYS, false));
DepthState.WRITEDEPTH = Object.freeze(new DepthState(FUNC_ALWAYS, true));

class Version {
		equals(other) {
				return this.globalId === other.globalId && this.revision === other.revision;
		}
		copy(other) {
				this.globalId = other.globalId;
				this.revision = other.revision;
		}
		reset() {
				this.globalId = 0;
				this.revision = 0;
		}
		constructor(){
				this.globalId = 0;
				this.revision = 0;
		}
}

var idCounter = 0;
class VersionedObject {
		increment() {
				this.version.revision++;
		}
		constructor(){
				idCounter++;
				this.version = new Version();
				this.version.globalId = idCounter;
		}
}

class ScopeId {
		toJSON(key) {
				return undefined;
		}
		setValue(value) {
				this.value = value;
				this.versionObject.increment();
		}
		getValue() {
				return this.value;
		}
		constructor(name){
				this.name = name;
				this.value = null;
				this.versionObject = new VersionedObject();
		}
}

class ScopeSpace {
		resolve(name) {
				if (!this.variables.has(name)) {
						this.variables.set(name, new ScopeId(name));
				}
				return this.variables.get(name);
		}
		removeValue(value) {
				for(var uniformName in this.variables){
						var uniform = this.variables[uniformName];
						if (uniform.value === value) {
								uniform.value = null;
						}
				}
		}
		constructor(name){
				this.name = name;
				this.variables = new Map();
		}
}

var id$8 = 0;
class VertexBuffer {
		destroy() {
				var device = this.device;
				var idx = device.buffers.indexOf(this);
				if (idx !== -1) {
						device.buffers.splice(idx, 1);
				}
				if (this.impl.initialized) {
						this.impl.destroy(device);
						this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
				}
		}
		adjustVramSizeTracking(vram, size) {
				vram.vb += size;
		}
		loseContext() {
				this.impl.loseContext();
		}
		getFormat() {
				return this.format;
		}
		getUsage() {
				return this.usage;
		}
		getNumVertices() {
				return this.numVertices;
		}
		lock() {
				return this.storage;
		}
		unlock() {
				this.impl.unlock(this);
		}
		setData(data) {
				if (data.byteLength !== this.numBytes) {
						return false;
				}
				this.storage = data;
				this.unlock();
				return true;
		}
		constructor(graphicsDevice, format, numVertices, options){
				this.usage = BUFFER_STATIC;
				var _options_usage;
				this.usage = (_options_usage = options == null ? void 0 : options.usage) != null ? _options_usage : BUFFER_STATIC;
				this.device = graphicsDevice;
				this.format = format;
				this.numVertices = numVertices;
				this.id = id$8++;
				this.impl = graphicsDevice.createVertexBufferImpl(this, format, options);
				this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
				this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
				var initialData = options == null ? void 0 : options.data;
				if (initialData) {
						this.setData(initialData);
				} else {
						this.storage = new ArrayBuffer(this.numBytes);
				}
				this.device.buffers.push(this);
		}
}

function hashCode(str) {
		if (str === null || str === undefined) {
				return 0;
		}
		var hash = 0;
		for(var i = 0, len = str.length; i < len; i++){
				hash = (hash << 5) - hash + str.charCodeAt(i);
				hash |= 0;
		}
		return hash;
}
function hash32Fnv1a(array) {
		var prime = 16777619;
		var hash = 2166136261;
		for(var i = 0; i < array.length; i++){
				hash ^= array[i];
				hash *= prime;
		}
		return hash >>> 0;
}

var stringIds$3 = new StringIds();
var webgpuValidElementSizes = [
		2,
		4,
		8,
		12,
		16
];
var deviceCache$2 = new DeviceCache();
class VertexFormat {
		get elements() {
				return this._elements;
		}
		static getDefaultInstancingFormat(graphicsDevice) {
				return deviceCache$2.get(graphicsDevice, ()=>{
						return new VertexFormat(graphicsDevice, [
								{
										semantic: SEMANTIC_ATTR12,
										components: 4,
										type: TYPE_FLOAT32
								},
								{
										semantic: SEMANTIC_ATTR13,
										components: 4,
										type: TYPE_FLOAT32
								},
								{
										semantic: SEMANTIC_ATTR14,
										components: 4,
										type: TYPE_FLOAT32
								},
								{
										semantic: SEMANTIC_ATTR15,
										components: 4,
										type: TYPE_FLOAT32
								}
						]);
				});
		}
		static isElementValid(graphicsDevice, elementDesc) {
				var elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
				if (graphicsDevice.isWebGPU && !webgpuValidElementSizes.includes(elementSize)) {
						return false;
				}
				return true;
		}
		update() {
				this._evaluateHash();
		}
		_evaluateHash() {
				var stringElementsBatch = [];
				var stringElementsRender = [];
				var len = this._elements.length;
				for(var i = 0; i < len; i++){
						var { name, dataType, numComponents, normalize, offset, stride, size, asInt } = this._elements[i];
						var stringElementBatch = name + dataType + numComponents + normalize + asInt;
						stringElementsBatch.push(stringElementBatch);
						var stringElementRender = stringElementBatch + offset + stride + size;
						stringElementsRender.push(stringElementRender);
				}
				stringElementsBatch.sort();
				var batchingString = stringElementsBatch.join();
				this.batchingHash = hashCode(batchingString);
				this.shaderProcessingHashString = batchingString;
				this.renderingHashString = stringElementsRender.join('_');
				this.renderingHash = stringIds$3.get(this.renderingHashString);
		}
		constructor(graphicsDevice, description, vertexCount){
				this.device = graphicsDevice;
				this._elements = [];
				this.hasUv0 = false;
				this.hasUv1 = false;
				this.hasColor = false;
				this.hasTangents = false;
				this.verticesByteSize = 0;
				this.vertexCount = vertexCount;
				this.interleaved = vertexCount === undefined;
				this.instancing = false;
				this.size = description.reduce((total, desc)=>{
						return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
				}, 0);
				var offset = 0, elementSize;
				for(var i = 0, len = description.length; i < len; i++){
						var elementDesc = description[i];
						elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
						if (vertexCount) {
								offset = math.roundUp(offset, elementSize);
						}
						var _elementDesc_asInt;
						var asInt = (_elementDesc_asInt = elementDesc.asInt) != null ? _elementDesc_asInt : false;
						var _elementDesc_normalize;
						var normalize = asInt ? false : (_elementDesc_normalize = elementDesc.normalize) != null ? _elementDesc_normalize : false;
						var element = {
								name: elementDesc.semantic,
								offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
								stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
								dataType: elementDesc.type,
								numComponents: elementDesc.components,
								normalize: normalize,
								size: elementSize,
								asInt: asInt
						};
						this._elements.push(element);
						if (vertexCount) {
								offset += elementSize * vertexCount;
						} else {
								offset += Math.ceil(elementSize / 4) * 4;
						}
						if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
								this.hasUv0 = true;
						} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
								this.hasUv1 = true;
						} else if (elementDesc.semantic === SEMANTIC_COLOR) {
								this.hasColor = true;
						} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
								this.hasTangents = true;
						}
				}
				if (vertexCount) {
						this.verticesByteSize = offset;
				}
				this._evaluateHash();
		}
}

var stringIds$2 = new StringIds();
class StencilParameters {
		set func(value) {
				this._func = value;
				this._dirty = true;
		}
		get func() {
				return this._func;
		}
		set ref(value) {
				this._ref = value;
				this._dirty = true;
		}
		get ref() {
				return this._ref;
		}
		set fail(value) {
				this._fail = value;
				this._dirty = true;
		}
		get fail() {
				return this._fail;
		}
		set zfail(value) {
				this._zfail = value;
				this._dirty = true;
		}
		get zfail() {
				return this._zfail;
		}
		set zpass(value) {
				this._zpass = value;
				this._dirty = true;
		}
		get zpass() {
				return this._zpass;
		}
		set readMask(value) {
				this._readMask = value;
				this._dirty = true;
		}
		get readMask() {
				return this._readMask;
		}
		set writeMask(value) {
				this._writeMask = value;
				this._dirty = true;
		}
		get writeMask() {
				return this._writeMask;
		}
		_evalKey() {
				var { _func, _ref, _fail, _zfail, _zpass, _readMask, _writeMask } = this;
				var key = _func + "," + _ref + "," + _fail + "," + _zfail + "," + _zpass + "," + _readMask + "," + _writeMask;
				this._key = stringIds$2.get(key);
				this._dirty = false;
		}
		get key() {
				if (this._dirty) {
						this._evalKey();
				}
				return this._key;
		}
		copy(rhs) {
				this._func = rhs._func;
				this._ref = rhs._ref;
				this._readMask = rhs._readMask;
				this._writeMask = rhs._writeMask;
				this._fail = rhs._fail;
				this._zfail = rhs._zfail;
				this._zpass = rhs._zpass;
				this._dirty = rhs._dirty;
				this._key = rhs._key;
				return this;
		}
		clone() {
				var clone = new this.constructor();
				return clone.copy(this);
		}
		constructor(options = {}){
				this._dirty = true;
				var _options_func;
				this._func = (_options_func = options.func) != null ? _options_func : FUNC_ALWAYS;
				var _options_ref;
				this._ref = (_options_ref = options.ref) != null ? _options_ref : 0;
				var _options_readMask;
				this._readMask = (_options_readMask = options.readMask) != null ? _options_readMask : 0xFF;
				var _options_writeMask;
				this._writeMask = (_options_writeMask = options.writeMask) != null ? _options_writeMask : 0xFF;
				var _options_fail;
				this._fail = (_options_fail = options.fail) != null ? _options_fail : STENCILOP_KEEP;
				var _options_zfail;
				this._zfail = (_options_zfail = options.zfail) != null ? _options_zfail : STENCILOP_KEEP;
				var _options_zpass;
				this._zpass = (_options_zpass = options.zpass) != null ? _options_zpass : STENCILOP_KEEP;
				this._evalKey();
		}
}
StencilParameters.DEFAULT = Object.freeze(new StencilParameters());

function _extends$j() {
		_extends$j = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$j.apply(this, arguments);
}
class GraphicsDevice extends EventHandler {
		postInit() {
				var vertexFormat = new VertexFormat(this, [
						{
								semantic: SEMANTIC_POSITION,
								components: 2,
								type: TYPE_FLOAT32
						}
				]);
				var positions = new Float32Array([
						-1,
						-1,
						1,
						-1,
						-1,
						1,
						1,
						1
				]);
				this.quadVertexBuffer = new VertexBuffer(this, vertexFormat, 4, {
						data: positions
				});
		}
		initCapsDefines() {
				var { capsDefines } = this;
				capsDefines.clear();
				if (this.textureFloatFilterable) capsDefines.set('CAPS_TEXTURE_FLOAT_FILTERABLE', '');
				if (this.textureFloatRenderable) capsDefines.set('CAPS_TEXTURE_FLOAT_RENDERABLE', '');
		}
		destroy() {
				var _this_quadVertexBuffer, _this_dynamicBuffers, _this_gpuProfiler;
				this.fire('destroy');
				(_this_quadVertexBuffer = this.quadVertexBuffer) == null ? void 0 : _this_quadVertexBuffer.destroy();
				this.quadVertexBuffer = null;
				(_this_dynamicBuffers = this.dynamicBuffers) == null ? void 0 : _this_dynamicBuffers.destroy();
				this.dynamicBuffers = null;
				(_this_gpuProfiler = this.gpuProfiler) == null ? void 0 : _this_gpuProfiler.destroy();
				this.gpuProfiler = null;
		}
		onDestroyShader(shader) {
				this.fire('destroy:shader', shader);
				var idx = this.shaders.indexOf(shader);
				if (idx !== -1) {
						this.shaders.splice(idx, 1);
				}
		}
		postDestroy() {
				this.scope = null;
				this.canvas = null;
		}
		loseContext() {
				var _this_gpuProfiler;
				this.contextLost = true;
				this.backBufferSize.set(-1, -1);
				for (var texture of this.textures){
						texture.loseContext();
				}
				for (var buffer of this.buffers){
						buffer.loseContext();
				}
				for (var target of this.targets){
						target.loseContext();
				}
				(_this_gpuProfiler = this.gpuProfiler) == null ? void 0 : _this_gpuProfiler.loseContext();
		}
		restoreContext() {
				var _this_gpuProfiler_restoreContext, _this_gpuProfiler;
				this.contextLost = false;
				this.initializeRenderState();
				this.initializeContextCaches();
				for (var buffer of this.buffers){
						buffer.unlock();
				}
				(_this_gpuProfiler = this.gpuProfiler) == null ? void 0 : (_this_gpuProfiler_restoreContext = _this_gpuProfiler.restoreContext) == null ? void 0 : _this_gpuProfiler_restoreContext.call(_this_gpuProfiler);
		}
		toJSON(key) {
				return undefined;
		}
		initializeContextCaches() {
				this.indexBuffer = null;
				this.vertexBuffers = [];
				this.shader = null;
				this.shaderValid = undefined;
				this.shaderAsyncCompile = false;
				this.renderTarget = null;
		}
		initializeRenderState() {
				this.blendState = new BlendState();
				this.depthState = new DepthState();
				this.cullMode = CULLFACE_BACK;
				this.vx = this.vy = this.vw = this.vh = 0;
				this.sx = this.sy = this.sw = this.sh = 0;
				this.blendColor = new Color(0, 0, 0, 0);
		}
		setStencilState(stencilFront, stencilBack) {}
		setBlendState(blendState) {}
		setBlendColor(r, g, b, a) {}
		setDepthState(depthState) {}
		setCullMode(cullMode) {}
		setRenderTarget(renderTarget) {
				this.renderTarget = renderTarget;
		}
		setIndexBuffer(indexBuffer) {
				this.indexBuffer = indexBuffer;
		}
		setVertexBuffer(vertexBuffer) {
				if (vertexBuffer) {
						this.vertexBuffers.push(vertexBuffer);
				}
		}
		clearVertexBuffer() {
				this.vertexBuffers.length = 0;
		}
		clearIndexBuffer() {
				this.indexBuffer = null;
		}
		getRenderTarget() {
				return this.renderTarget;
		}
		initRenderTarget(target) {
				if (target.initialized) return;
				target.init();
				this.targets.add(target);
		}
		_isBrowserInterface(texture) {
				return this._isImageBrowserInterface(texture) || this._isImageCanvasInterface(texture) || this._isImageVideoInterface(texture);
		}
		_isImageBrowserInterface(texture) {
				return typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement;
		}
		_isImageCanvasInterface(texture) {
				return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement;
		}
		_isImageVideoInterface(texture) {
				return typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement;
		}
		resizeCanvas(width, height) {
				var pixelRatio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
				var w = Math.floor(width * pixelRatio);
				var h = Math.floor(height * pixelRatio);
				if (w !== this.canvas.width || h !== this.canvas.height) {
						this.setResolution(w, h);
				}
		}
		setResolution(width, height) {
				this.canvas.width = width;
				this.canvas.height = height;
				this.fire(GraphicsDevice.EVENT_RESIZE, width, height);
		}
		updateClientRect() {
				if (platform.worker) {
						this.clientRect.width = this.canvas.width;
						this.clientRect.height = this.canvas.height;
				} else {
						var rect = this.canvas.getBoundingClientRect();
						this.clientRect.width = rect.width;
						this.clientRect.height = rect.height;
				}
		}
		get width() {
				return this.canvas.width;
		}
		get height() {
				return this.canvas.height;
		}
		set fullscreen(fullscreen) {}
		get fullscreen() {
				return false;
		}
		set maxPixelRatio(ratio) {
				this._maxPixelRatio = ratio;
		}
		get maxPixelRatio() {
				return this._maxPixelRatio;
		}
		get deviceType() {
				return this._deviceType;
		}
		startRenderPass(renderPass) {}
		endRenderPass(renderPass) {}
		startComputePass(name) {}
		endComputePass() {}
		frameStart() {
				this.renderPassIndex = 0;
				this.renderVersion++;
		}
		frameEnd() {}
		computeDispatch(computes, name) {
		}
		getRenderableHdrFormat(formats, filterable, samples) {
				if (formats === void 0) formats = [
						PIXELFORMAT_111110F,
						PIXELFORMAT_RGBA16F,
						PIXELFORMAT_RGBA32F
				];
				if (filterable === void 0) filterable = true;
				if (samples === void 0) samples = 1;
				for(var i = 0; i < formats.length; i++){
						var format = formats[i];
						switch(format){
								case PIXELFORMAT_111110F:
										{
												if (this.textureRG11B10Renderable) {
														return format;
												}
												break;
										}
								case PIXELFORMAT_RGBA16F:
										if (this.textureHalfFloatRenderable) {
												return format;
										}
										break;
								case PIXELFORMAT_RGBA32F:
										if (this.isWebGPU && samples > 1) {
												continue;
										}
										if (this.textureFloatRenderable && (!filterable || this.textureFloatFilterable)) {
												return format;
										}
										break;
						}
				}
				return undefined;
		}
		validateAttributes(shader, vb0Format, vb1Format) {}
		constructor(canvas, options){
				var _this_initOptions, _this_initOptions1, _this_initOptions2, _this_initOptions3, _this_initOptions4, _this_initOptions5;
				super(), this.backBuffer = null, this.backBufferSize = new Vec2(), this.backBufferAntialias = false, this.isWebGPU = false, this.isWebGL2 = false, this.isHdr = false, this.maxColorAttachments = 1, this.maxSamples = 1, this.supportsCompute = false, this.supportsStorageTextureRead = false, this.renderTarget = null, this.shaders = [], this.textures = [], this.targets = new Set(), this.renderVersion = 0, this.insideRenderPass = false, this.supportsUniformBuffers = false, this.supportsClipDistances = false, this.textureRG11B10Renderable = false, this.textureFloatFilterable = false, this.blendState = new BlendState(), this.depthState = new DepthState(), this.stencilEnabled = false, this.stencilFront = new StencilParameters(), this.stencilBack = new StencilParameters(), this.defaultClearOptions = {
						color: [
								0,
								0,
								0,
								1
						],
						depth: 1,
						stencil: 0,
						flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
				}, this.clientRect = {
						width: 0,
						height: 0
				}, this._shadersDirty = false, this.capsDefines = new Map();
				this.canvas = canvas;
				this.initOptions = _extends$j({}, options);
				var _alpha;
				(_alpha = (_this_initOptions = this.initOptions).alpha) != null ? _alpha : _this_initOptions.alpha = true;
				var _depth;
				(_depth = (_this_initOptions1 = this.initOptions).depth) != null ? _depth : _this_initOptions1.depth = true;
				var _stencil;
				(_stencil = (_this_initOptions2 = this.initOptions).stencil) != null ? _stencil : _this_initOptions2.stencil = true;
				var _antialias;
				(_antialias = (_this_initOptions3 = this.initOptions).antialias) != null ? _antialias : _this_initOptions3.antialias = true;
				var _powerPreference;
				(_powerPreference = (_this_initOptions4 = this.initOptions).powerPreference) != null ? _powerPreference : _this_initOptions4.powerPreference = 'high-performance';
				var _displayFormat;
				(_displayFormat = (_this_initOptions5 = this.initOptions).displayFormat) != null ? _displayFormat : _this_initOptions5.displayFormat = DISPLAYFORMAT_LDR;
				this._maxPixelRatio = platform.browser ? Math.min(1, window.devicePixelRatio) : 1;
				this.buffers = [];
				this._vram = {
						tex: 0,
						vb: 0,
						ib: 0,
						ub: 0,
						sb: 0
				};
				this._shaderStats = {
						vsCompiled: 0,
						fsCompiled: 0,
						linked: 0,
						materialShaders: 0,
						compileTime: 0
				};
				this.initializeContextCaches();
				this._drawCallsPerFrame = 0;
				this._shaderSwitchesPerFrame = 0;
				this._primsPerFrame = [];
				for(var i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++){
						this._primsPerFrame[i] = 0;
				}
				this._renderTargetCreationTime = 0;
				this.scope = new ScopeSpace('Device');
				this.textureBias = this.scope.resolve('textureBias');
				this.textureBias.setValue(0.0);
		}
}
GraphicsDevice.EVENT_RESIZE = 'resizecanvas';

var id$7 = 0;
class RenderTarget {
		destroy() {
				var device = this._device;
				if (device) {
						device.targets.delete(this);
						if (device.renderTarget === this) {
								device.setRenderTarget(null);
						}
						this.destroyFrameBuffers();
				}
		}
		destroyFrameBuffers() {
				var device = this._device;
				if (device) {
						this.impl.destroy(device);
				}
		}
		destroyTextureBuffers() {
				var _this__depthBuffer, _this__colorBuffers;
				(_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.destroy();
				this._depthBuffer = null;
				(_this__colorBuffers = this._colorBuffers) == null ? void 0 : _this__colorBuffers.forEach((colorBuffer)=>{
						colorBuffer.destroy();
				});
				this._colorBuffers = null;
				this._colorBuffer = null;
		}
		resize(width, height) {
				if (this.width !== width || this.height !== height) {
						var _this__depthBuffer, _this__colorBuffers;
						if (this.mipLevel > 0) {
								return;
						}
						var device = this._device;
						this.destroyFrameBuffers();
						if (device.renderTarget === this) {
								device.setRenderTarget(null);
						}
						(_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.resize(width, height);
						(_this__colorBuffers = this._colorBuffers) == null ? void 0 : _this__colorBuffers.forEach((colorBuffer)=>{
								colorBuffer.resize(width, height);
						});
						this.validateMrt();
						this.impl = device.createRenderTargetImpl(this);
				}
		}
		validateMrt() {}
		init() {
				this.impl.init(this._device, this);
		}
		get initialized() {
				return this.impl.initialized;
		}
		get device() {
				return this._device;
		}
		loseContext() {
				this.impl.loseContext();
		}
		resolve(color, depth) {
				if (color === void 0) color = true;
				if (depth === void 0) depth = !!this._depthBuffer;
				if (this._device && this._samples > 1) {
						this.impl.resolve(this._device, this, color, depth);
				}
		}
		copy(source, color, depth) {
				if (!this._device) {
						if (source._device) {
								this._device = source._device;
						} else {
								return false;
						}
				}
				var success = this._device.copyRenderTarget(source, this, color, depth);
				return success;
		}
		get samples() {
				return this._samples;
		}
		get depth() {
				return this._depth;
		}
		get stencil() {
				return this._stencil;
		}
		get colorBuffer() {
				return this._colorBuffer;
		}
		getColorBuffer(index) {
				var _this__colorBuffers;
				return (_this__colorBuffers = this._colorBuffers) == null ? void 0 : _this__colorBuffers[index];
		}
		get depthBuffer() {
				return this._depthBuffer;
		}
		get face() {
				return this._face;
		}
		get mipLevel() {
				return this._mipLevel;
		}
		get mipmaps() {
				return this._mipmaps;
		}
		get width() {
				var _this__colorBuffer, _this__depthBuffer;
				var width = ((_this__colorBuffer = this._colorBuffer) == null ? void 0 : _this__colorBuffer.width) || ((_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.width) || this._device.width;
				if (this._mipLevel > 0) {
						width = TextureUtils.calcLevelDimension(width, this._mipLevel);
				}
				return width;
		}
		get height() {
				var _this__colorBuffer, _this__depthBuffer;
				var height = ((_this__colorBuffer = this._colorBuffer) == null ? void 0 : _this__colorBuffer.height) || ((_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.height) || this._device.height;
				if (this._mipLevel > 0) {
						height = TextureUtils.calcLevelDimension(height, this._mipLevel);
				}
				return height;
		}
		isColorBufferSrgb(index) {
				if (index === void 0) index = 0;
				if (this.device.backBuffer === this) {
						return isSrgbPixelFormat(this.device.backBufferFormat);
				}
				var colorBuffer = this.getColorBuffer(index);
				return colorBuffer ? isSrgbPixelFormat(colorBuffer.format) : false;
		}
		constructor(options = {}){
				var _options_colorBuffer, _options_colorBuffers, _options_depthBuffer;
				this.id = id$7++;
				var _options_colorBuffer_device, _ref, _ref1;
				var device = (_ref1 = (_ref = (_options_colorBuffer_device = (_options_colorBuffer = options.colorBuffer) == null ? void 0 : _options_colorBuffer.device) != null ? _options_colorBuffer_device : (_options_colorBuffers = options.colorBuffers) == null ? void 0 : _options_colorBuffers[0].device) != null ? _ref : (_options_depthBuffer = options.depthBuffer) == null ? void 0 : _options_depthBuffer.device) != null ? _ref1 : options.graphicsDevice;
				this._device = device;
				var { maxSamples } = this._device;
				var _options_samples;
				this._samples = Math.min((_options_samples = options.samples) != null ? _options_samples : 1, maxSamples);
				if (device.isWebGPU) {
						this._samples = this._samples > 1 ? maxSamples : 1;
				}
				this._colorBuffer = options.colorBuffer;
				if (options.colorBuffer) {
						this._colorBuffers = [
								options.colorBuffer
						];
				}
				this._depthBuffer = options.depthBuffer;
				var _options_face;
				this._face = (_options_face = options.face) != null ? _options_face : 0;
				if (this._depthBuffer) {
						var format = this._depthBuffer._format;
						if (format === PIXELFORMAT_DEPTH || format === PIXELFORMAT_DEPTH16) {
								this._depth = true;
								this._stencil = false;
						} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
								this._depth = true;
								this._stencil = true;
						} else if (format === PIXELFORMAT_R32F && this._depthBuffer.device.isWebGPU && this._samples > 1) {
								this._depth = true;
								this._stencil = false;
						} else {
								this._depth = false;
								this._stencil = false;
						}
				} else {
						var _options_depth;
						this._depth = (_options_depth = options.depth) != null ? _options_depth : true;
						var _options_stencil;
						this._stencil = (_options_stencil = options.stencil) != null ? _options_stencil : false;
				}
				if (options.colorBuffers) {
						if (!this._colorBuffers) {
								this._colorBuffers = [
										...options.colorBuffers
								];
								this._colorBuffer = options.colorBuffers[0];
						}
				}
				var _options_autoResolve;
				this.autoResolve = (_options_autoResolve = options.autoResolve) != null ? _options_autoResolve : true;
				this.name = options.name;
				if (!this.name) {
						var _this__colorBuffer;
						this.name = (_this__colorBuffer = this._colorBuffer) == null ? void 0 : _this__colorBuffer.name;
				}
				if (!this.name) {
						var _this__depthBuffer;
						this.name = (_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.name;
				}
				if (!this.name) {
						this.name = 'Untitled';
				}
				var _options_flipY;
				this.flipY = (_options_flipY = options.flipY) != null ? _options_flipY : false;
				var _options_mipLevel;
				this._mipLevel = (_options_mipLevel = options.mipLevel) != null ? _options_mipLevel : 0;
				if (this._mipLevel > 0 && this._depth) {
						this._mipLevel = 0;
				}
				this._mipmaps = options.mipLevel === undefined;
				this.validateMrt();
				this.impl = device.createRenderTargetImpl(this);
		}
}

class WebgpuBindGroup {
		update(bindGroup) {
				this.destroy();
				var device = bindGroup.device;
				var desc = this.createDescriptor(device, bindGroup);
				this.bindGroup = device.wgpu.createBindGroup(desc);
		}
		destroy() {
				this.bindGroup = null;
		}
		createDescriptor(device, bindGroup) {
				var entries = [];
				var format = bindGroup.format;
				var uniformBufferFormats = bindGroup.format.uniformBufferFormats;
				bindGroup.uniformBuffers.forEach((ub, i)=>{
						var slot = uniformBufferFormats[i].slot;
						var buffer = ub.persistent ? ub.impl.buffer : ub.allocation.gpuBuffer.buffer;
						entries.push({
								binding: slot,
								resource: {
										buffer: buffer,
										offset: 0,
										size: ub.format.byteSize
								}
						});
				});
				var textureFormats = bindGroup.format.textureFormats;
				bindGroup.textures.forEach((tex, textureIndex)=>{
						var wgpuTexture = tex.impl;
						var textureFormat = format.textureFormats[textureIndex];
						var slot = textureFormats[textureIndex].slot;
						var view = wgpuTexture.getView(device);
						entries.push({
								binding: slot,
								resource: view
						});
						if (textureFormat.hasSampler) {
								var sampler = wgpuTexture.getSampler(device, textureFormat.sampleType);
								entries.push({
										binding: slot + 1,
										resource: sampler
								});
						}
				});
				var storageTextureFormats = bindGroup.format.storageTextureFormats;
				bindGroup.storageTextures.forEach((tex, textureIndex)=>{
						var wgpuTexture = tex.impl;
						var slot = storageTextureFormats[textureIndex].slot;
						var view = wgpuTexture.getView(device);
						entries.push({
								binding: slot,
								resource: view
						});
				});
				var storageBufferFormats = bindGroup.format.storageBufferFormats;
				bindGroup.storageBuffers.forEach((buffer, bufferIndex)=>{
						var wgpuBuffer = buffer.impl.buffer;
						var slot = storageBufferFormats[bufferIndex].slot;
						entries.push({
								binding: slot,
								resource: {
										buffer: wgpuBuffer
								}
						});
				});
				var desc = {
						layout: bindGroup.format.impl.bindGroupLayout,
						entries: entries
				};
				return desc;
		}
}

class WebgpuUtils {
		static shaderStage(stage) {
				var ret = 0;
				if (stage & SHADERSTAGE_VERTEX) ret |= GPUShaderStage.VERTEX;
				if (stage & SHADERSTAGE_FRAGMENT) ret |= GPUShaderStage.FRAGMENT;
				if (stage & SHADERSTAGE_COMPUTE) ret |= GPUShaderStage.COMPUTE;
				return ret;
		}
}

var gpuTextureFormats = [];
gpuTextureFormats[PIXELFORMAT_A8] = '';
gpuTextureFormats[PIXELFORMAT_L8] = '';
gpuTextureFormats[PIXELFORMAT_LA8] = '';
gpuTextureFormats[PIXELFORMAT_R8] = 'r8unorm';
gpuTextureFormats[PIXELFORMAT_RG8] = 'rg8unorm';
gpuTextureFormats[PIXELFORMAT_RGB565] = '';
gpuTextureFormats[PIXELFORMAT_RGBA5551] = '';
gpuTextureFormats[PIXELFORMAT_RGBA4] = '';
gpuTextureFormats[PIXELFORMAT_RGB8] = 'rgba8unorm';
gpuTextureFormats[PIXELFORMAT_RGBA8] = 'rgba8unorm';
gpuTextureFormats[PIXELFORMAT_DXT1] = 'bc1-rgba-unorm';
gpuTextureFormats[PIXELFORMAT_DXT3] = 'bc2-rgba-unorm';
gpuTextureFormats[PIXELFORMAT_DXT5] = 'bc3-rgba-unorm';
gpuTextureFormats[PIXELFORMAT_RGB16F] = '';
gpuTextureFormats[PIXELFORMAT_RGBA16F] = 'rgba16float';
gpuTextureFormats[PIXELFORMAT_R16F] = 'r16float';
gpuTextureFormats[PIXELFORMAT_RG16F] = 'rg16float';
gpuTextureFormats[PIXELFORMAT_RGB32F] = '';
gpuTextureFormats[PIXELFORMAT_RGBA32F] = 'rgba32float';
gpuTextureFormats[PIXELFORMAT_R32F] = 'r32float';
gpuTextureFormats[PIXELFORMAT_DEPTH] = 'depth32float';
gpuTextureFormats[PIXELFORMAT_DEPTH16] = 'depth16unorm';
gpuTextureFormats[PIXELFORMAT_DEPTHSTENCIL] = 'depth24plus-stencil8';
gpuTextureFormats[PIXELFORMAT_111110F] = 'rg11b10ufloat';
gpuTextureFormats[PIXELFORMAT_SRGB8] = '';
gpuTextureFormats[PIXELFORMAT_SRGBA8] = 'rgba8unorm-srgb';
gpuTextureFormats[PIXELFORMAT_ETC1] = '';
gpuTextureFormats[PIXELFORMAT_ETC2_RGB] = 'etc2-rgb8unorm';
gpuTextureFormats[PIXELFORMAT_ETC2_RGBA] = 'etc2-rgba8unorm';
gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGB_1] = '';
gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = '';
gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGB_1] = '';
gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = '';
gpuTextureFormats[PIXELFORMAT_ASTC_4x4] = 'astc-4x4-unorm';
gpuTextureFormats[PIXELFORMAT_ATC_RGB] = '';
gpuTextureFormats[PIXELFORMAT_ATC_RGBA] = '';
gpuTextureFormats[PIXELFORMAT_BGRA8] = 'bgra8unorm';
gpuTextureFormats[PIXELFORMAT_SBGRA8] = 'bgra8unorm-srgb';
gpuTextureFormats[PIXELFORMAT_R8I] = 'r8sint';
gpuTextureFormats[PIXELFORMAT_R8U] = 'r8uint';
gpuTextureFormats[PIXELFORMAT_R16I] = 'r16sint';
gpuTextureFormats[PIXELFORMAT_R16U] = 'r16uint';
gpuTextureFormats[PIXELFORMAT_R32I] = 'r32sint';
gpuTextureFormats[PIXELFORMAT_R32U] = 'r32uint';
gpuTextureFormats[PIXELFORMAT_RG8I] = 'rg8sint';
gpuTextureFormats[PIXELFORMAT_RG8U] = 'rg8uint';
gpuTextureFormats[PIXELFORMAT_RG16I] = 'rg16sint';
gpuTextureFormats[PIXELFORMAT_RG16U] = 'rg16uint';
gpuTextureFormats[PIXELFORMAT_RG32I] = 'rg32sint';
gpuTextureFormats[PIXELFORMAT_RG32U] = 'rg32uint';
gpuTextureFormats[PIXELFORMAT_RGBA8I] = 'rgba8sint';
gpuTextureFormats[PIXELFORMAT_RGBA8U] = 'rgba8uint';
gpuTextureFormats[PIXELFORMAT_RGBA16I] = 'rgba16sint';
gpuTextureFormats[PIXELFORMAT_RGBA16U] = 'rgba16uint';
gpuTextureFormats[PIXELFORMAT_RGBA32I] = 'rgba32sint';
gpuTextureFormats[PIXELFORMAT_RGBA32U] = 'rgba32uint';
gpuTextureFormats[PIXELFORMAT_BC6F] = 'bc6h-rgb-float';
gpuTextureFormats[PIXELFORMAT_BC6UF] = 'bc6h-rgb-ufloat';
gpuTextureFormats[PIXELFORMAT_BC7] = 'bc7-rgba-unorm';
gpuTextureFormats[PIXELFORMAT_DXT1_SRGB] = 'bc1-rgba-unorm-srgb';
gpuTextureFormats[PIXELFORMAT_DXT3_SRGBA] = 'bc2-rgba-unorm-srgb';
gpuTextureFormats[PIXELFORMAT_DXT5_SRGBA] = 'bc3-rgba-unorm-srgb';
gpuTextureFormats[PIXELFORMAT_ETC2_SRGB] = 'etc2-rgb8unorm-srgb';
gpuTextureFormats[PIXELFORMAT_ETC2_SRGBA] = 'etc2-rgba8unorm-srgb';
gpuTextureFormats[PIXELFORMAT_BC7_SRGBA] = 'bc7-rgba-unorm-srgb';
gpuTextureFormats[PIXELFORMAT_ASTC_4x4_SRGB] = 'astc-4x4-unorm-srgb';

var samplerTypes = [];
samplerTypes[SAMPLETYPE_FLOAT] = 'filtering';
samplerTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'non-filtering';
samplerTypes[SAMPLETYPE_DEPTH] = 'comparison';
samplerTypes[SAMPLETYPE_INT] = 'comparison';
samplerTypes[SAMPLETYPE_UINT] = 'comparison';
var sampleTypes = [];
sampleTypes[SAMPLETYPE_FLOAT] = 'float';
sampleTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'unfilterable-float';
sampleTypes[SAMPLETYPE_DEPTH] = 'depth';
sampleTypes[SAMPLETYPE_INT] = 'sint';
sampleTypes[SAMPLETYPE_UINT] = 'uint';
var stringIds$1 = new StringIds();
class WebgpuBindGroupFormat {
		destroy() {
				this.bindGroupLayout = null;
		}
		loseContext() {}
		createDescriptor(bindGroupFormat) {
				var entries = [];
				var key = '';
				bindGroupFormat.uniformBufferFormats.forEach((bufferFormat)=>{
						var visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
						key += "#" + bufferFormat.slot + "U:" + visibility;
						entries.push({
								binding: bufferFormat.slot,
								visibility: visibility,
								buffer: {
										type: 'uniform',
										hasDynamicOffset: true
								}
						});
				});
				bindGroupFormat.textureFormats.forEach((textureFormat)=>{
						var visibility = WebgpuUtils.shaderStage(textureFormat.visibility);
						var sampleType = textureFormat.sampleType;
						var viewDimension = textureFormat.textureDimension;
						var multisampled = false;
						var gpuSampleType = sampleTypes[sampleType];
						key += "#" + textureFormat.slot + "T:" + visibility + "-" + gpuSampleType + "-" + viewDimension + "-" + multisampled;
						entries.push({
								binding: textureFormat.slot,
								visibility: visibility,
								texture: {
										sampleType: gpuSampleType,
										viewDimension: viewDimension,
										multisampled: multisampled
								}
						});
						if (textureFormat.hasSampler) {
								var gpuSamplerType = samplerTypes[sampleType];
								key += "#" + (textureFormat.slot + 1) + "S:" + visibility + "-" + gpuSamplerType;
								entries.push({
										binding: textureFormat.slot + 1,
										visibility: visibility,
										sampler: {
												type: gpuSamplerType
										}
								});
						}
				});
				bindGroupFormat.storageTextureFormats.forEach((textureFormat)=>{
						var { format, textureDimension } = textureFormat;
						var { read, write } = textureFormat;
						key += "#" + textureFormat.slot + "ST:" + format + "-" + textureDimension + "-" + (read ? 'r1' : 'r0') + "-" + (write ? 'w1' : 'w0');
						entries.push({
								binding: textureFormat.slot,
								visibility: GPUShaderStage.COMPUTE,
								storageTexture: {
										access: read ? write ? 'read-write' : 'read-only' : 'write-only',
										format: gpuTextureFormats[format],
										viewDimension: textureDimension
								}
						});
				});
				bindGroupFormat.storageBufferFormats.forEach((bufferFormat)=>{
						var readOnly = bufferFormat.readOnly;
						var visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
						key += "#" + bufferFormat.slot + "SB:" + visibility + "-" + (readOnly ? 'ro' : 'rw');
						entries.push({
								binding: bufferFormat.slot,
								visibility: visibility,
								buffer: {
										type: readOnly ? 'read-only-storage' : 'storage'
								}
						});
				});
				var desc = {
						entries: entries
				};
				return {
						key,
						desc
				};
		}
		constructor(bindGroupFormat){
				var device = bindGroupFormat.device;
				var { key, desc } = this.createDescriptor(bindGroupFormat);
				this.key = stringIds$1.get(key);
				this.bindGroupLayout = device.wgpu.createBindGroupLayout(desc);
		}
}

class WebgpuBuffer {
		destroy(device) {
				if (this.buffer) {
						this.buffer.destroy();
						this.buffer = null;
				}
		}
		get initialized() {
				return !!this.buffer;
		}
		loseContext() {}
		allocate(device, size) {
				this.buffer = device.wgpu.createBuffer({
						size,
						usage: this.usageFlags
				});
		}
		unlock(device, storage) {
				var wgpu = device.wgpu;
				if (!this.buffer) {
						var size = storage.byteLength + 3 & -4;
						this.usageFlags |= GPUBufferUsage.COPY_DST;
						this.allocate(device, size);
				}
				var _storage_byteOffset;
				var srcOffset = (_storage_byteOffset = storage.byteOffset) != null ? _storage_byteOffset : 0;
				var _storage_buffer;
				var srcData = new Uint8Array((_storage_buffer = storage.buffer) != null ? _storage_buffer : storage, srcOffset, storage.byteLength);
				var data = new Uint8Array(this.buffer.size);
				data.set(srcData);
				wgpu.queue.writeBuffer(this.buffer, 0, data, 0, data.length);
		}
		read(device, offset, size, data) {
				return device.readStorageBuffer(this, offset, size, data);
		}
		write(device, bufferOffset, data, dataOffset, size) {
				device.writeStorageBuffer(this, bufferOffset, data, dataOffset, size);
		}
		clear(device, offset, size) {
				device.clearStorageBuffer(this, offset, size);
		}
		constructor(usageFlags = 0){
				this.buffer = null;
				this.usageFlags = 0;
				this.usageFlags = usageFlags;
		}
}

class WebgpuIndexBuffer extends WebgpuBuffer {
		unlock(indexBuffer) {
				var device = indexBuffer.device;
				super.unlock(device, indexBuffer.storage);
		}
		constructor(indexBuffer, options){
				super(BUFFERUSAGE_INDEX | ((options == null ? void 0 : options.storage) ? BUFFERUSAGE_STORAGE : 0)), this.format = null;
				this.format = indexBuffer.format === INDEXFORMAT_UINT16 ? 'uint16' : 'uint32';
		}
}

var array = {
		equals (arr1, arr2) {
				if (arr1.length !== arr2.length) {
						return false;
				}
				for(var i = 0; i < arr1.length; i++){
						if (arr1[i] !== arr2[i]) {
								return false;
						}
				}
				return true;
		}
};

var gpuVertexFormats = [];
gpuVertexFormats[TYPE_INT8] = 'sint8';
gpuVertexFormats[TYPE_UINT8] = 'uint8';
gpuVertexFormats[TYPE_INT16] = 'sint16';
gpuVertexFormats[TYPE_UINT16] = 'uint16';
gpuVertexFormats[TYPE_INT32] = 'sint32';
gpuVertexFormats[TYPE_UINT32] = 'uint32';
gpuVertexFormats[TYPE_FLOAT32] = 'float32';
gpuVertexFormats[TYPE_FLOAT16] = 'float16';
var gpuVertexFormatsNormalized = [];
gpuVertexFormatsNormalized[TYPE_INT8] = 'snorm8';
gpuVertexFormatsNormalized[TYPE_UINT8] = 'unorm8';
gpuVertexFormatsNormalized[TYPE_INT16] = 'snorm16';
gpuVertexFormatsNormalized[TYPE_UINT16] = 'unorm16';
gpuVertexFormatsNormalized[TYPE_INT32] = 'sint32';
gpuVertexFormatsNormalized[TYPE_UINT32] = 'uint32';
gpuVertexFormatsNormalized[TYPE_FLOAT32] = 'float32';
gpuVertexFormatsNormalized[TYPE_FLOAT16] = 'float16';
class WebgpuVertexBufferLayout {
		get(vertexFormat0, vertexFormat1) {
				if (vertexFormat1 === void 0) vertexFormat1 = null;
				var key = this.getKey(vertexFormat0, vertexFormat1);
				var layout = this.cache.get(key);
				if (!layout) {
						layout = this.create(vertexFormat0, vertexFormat1);
						this.cache.set(key, layout);
				}
				return layout;
		}
		getKey(vertexFormat0, vertexFormat1) {
				if (vertexFormat1 === void 0) vertexFormat1 = null;
				return (vertexFormat0 == null ? void 0 : vertexFormat0.renderingHashString) + "-" + (vertexFormat1 == null ? void 0 : vertexFormat1.renderingHashString);
		}
		create(vertexFormat0, vertexFormat1) {
				var layout = [];
				var addFormat = (format)=>{
						var interleaved = format.interleaved;
						var stepMode = format.instancing ? 'instance' : 'vertex';
						var attributes = [];
						var elementCount = format.elements.length;
						for(var i = 0; i < elementCount; i++){
								var element = format.elements[i];
								var location = semanticToLocation[element.name];
								var formatTable = element.normalize ? gpuVertexFormatsNormalized : gpuVertexFormats;
								attributes.push({
										shaderLocation: location,
										offset: interleaved ? element.offset : 0,
										format: "" + formatTable[element.dataType] + (element.numComponents > 1 ? "x" + element.numComponents : '')
								});
								if (!interleaved || i === elementCount - 1) {
										layout.push({
												attributes: attributes,
												arrayStride: element.stride,
												stepMode: stepMode
										});
										attributes = [];
								}
						}
				};
				if (vertexFormat0) {
						addFormat(vertexFormat0);
				}
				if (vertexFormat1) {
						addFormat(vertexFormat1);
				}
				return layout;
		}
		constructor(){
				this.cache = new Map();
		}
}

class WebgpuPipeline {
		getPipelineLayout(bindGroupFormats) {
				var bindGroupLayouts = [];
				bindGroupFormats.forEach((format)=>{
						bindGroupLayouts.push(format.bindGroupLayout);
				});
				var desc = {
						bindGroupLayouts: bindGroupLayouts
				};
				var pipelineLayout = this.device.wgpu.createPipelineLayout(desc);
				return pipelineLayout;
		}
		constructor(device){
				this.device = device;
		}
}

var _primitiveTopology = [
		'point-list',
		'line-list',
		undefined,
		'line-strip',
		'triangle-list',
		'triangle-strip',
		undefined
];
var _blendOperation = [
		'add',
		'subtract',
		'reverse-subtract',
		'min',
		'max'
];
var _blendFactor = [
		'zero',
		'one',
		'src',
		'one-minus-src',
		'dst',
		'one-minus-dst',
		'src-alpha',
		'src-alpha-saturated',
		'one-minus-src-alpha',
		'dst-alpha',
		'one-minus-dst-alpha',
		'constant',
		'one-minus-constant'
];
var _compareFunction = [
		'never',
		'less',
		'equal',
		'less-equal',
		'greater',
		'not-equal',
		'greater-equal',
		'always'
];
var _cullModes = [
		'none',
		'back',
		'front'
];
var _stencilOps = [
		'keep',
		'zero',
		'replace',
		'increment-clamp',
		'increment-wrap',
		'decrement-clamp',
		'decrement-wrap',
		'invert'
];
class CacheEntry {
}
class WebgpuRenderPipeline extends WebgpuPipeline {
		get(primitive, vertexFormat0, vertexFormat1, shader, renderTarget, bindGroupFormats, blendState, depthState, cullMode, stencilEnabled, stencilFront, stencilBack) {
				var _bindGroupFormats_, _bindGroupFormats_1, _bindGroupFormats_2;
				var lookupHashes = this.lookupHashes;
				lookupHashes[0] = primitive.type;
				lookupHashes[1] = shader.id;
				lookupHashes[2] = cullMode;
				lookupHashes[3] = depthState.key;
				lookupHashes[4] = blendState.key;
				var _vertexFormat0_renderingHash;
				lookupHashes[5] = (_vertexFormat0_renderingHash = vertexFormat0 == null ? void 0 : vertexFormat0.renderingHash) != null ? _vertexFormat0_renderingHash : 0;
				var _vertexFormat1_renderingHash;
				lookupHashes[6] = (_vertexFormat1_renderingHash = vertexFormat1 == null ? void 0 : vertexFormat1.renderingHash) != null ? _vertexFormat1_renderingHash : 0;
				lookupHashes[7] = renderTarget.impl.key;
				var _bindGroupFormats__key;
				lookupHashes[8] = (_bindGroupFormats__key = (_bindGroupFormats_ = bindGroupFormats[0]) == null ? void 0 : _bindGroupFormats_.key) != null ? _bindGroupFormats__key : 0;
				var _bindGroupFormats__key1;
				lookupHashes[9] = (_bindGroupFormats__key1 = (_bindGroupFormats_1 = bindGroupFormats[1]) == null ? void 0 : _bindGroupFormats_1.key) != null ? _bindGroupFormats__key1 : 0;
				var _bindGroupFormats__key2;
				lookupHashes[10] = (_bindGroupFormats__key2 = (_bindGroupFormats_2 = bindGroupFormats[2]) == null ? void 0 : _bindGroupFormats_2.key) != null ? _bindGroupFormats__key2 : 0;
				lookupHashes[11] = stencilEnabled ? stencilFront.key : 0;
				lookupHashes[12] = stencilEnabled ? stencilBack.key : 0;
				var hash = hash32Fnv1a(lookupHashes);
				var cacheEntries = this.cache.get(hash);
				if (cacheEntries) {
						for(var i = 0; i < cacheEntries.length; i++){
								var entry = cacheEntries[i];
								if (array.equals(entry.hashes, lookupHashes)) {
										return entry.pipeline;
								}
						}
				}
				var primitiveTopology = _primitiveTopology[primitive.type];
				var pipelineLayout = this.getPipelineLayout(bindGroupFormats);
				var vertexBufferLayout = this.vertexBufferLayout.get(vertexFormat0, vertexFormat1);
				var cacheEntry = new CacheEntry();
				cacheEntry.hashes = new Uint32Array(lookupHashes);
				cacheEntry.pipeline = this.create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack);
				if (cacheEntries) {
						cacheEntries.push(cacheEntry);
				} else {
						cacheEntries = [
								cacheEntry
						];
				}
				this.cache.set(hash, cacheEntries);
				return cacheEntry.pipeline;
		}
		getBlend(blendState) {
				var blend;
				if (blendState.blend) {
						blend = {
								color: {
										operation: _blendOperation[blendState.colorOp],
										srcFactor: _blendFactor[blendState.colorSrcFactor],
										dstFactor: _blendFactor[blendState.colorDstFactor]
								},
								alpha: {
										operation: _blendOperation[blendState.alphaOp],
										srcFactor: _blendFactor[blendState.alphaSrcFactor],
										dstFactor: _blendFactor[blendState.alphaDstFactor]
								}
						};
				}
				return blend;
		}
		getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack) {
				var depthStencil;
				var { depth, stencil } = renderTarget;
				if (depth || stencil) {
						depthStencil = {
								format: renderTarget.impl.depthAttachment.format
						};
						if (depth) {
								depthStencil.depthWriteEnabled = depthState.write;
								depthStencil.depthCompare = _compareFunction[depthState.func];
								depthStencil.depthBias = depthState.depthBias;
								depthStencil.depthBiasSlopeScale = depthState.depthBiasSlope;
						} else {
								depthStencil.depthWriteEnabled = false;
								depthStencil.depthCompare = 'always';
						}
						if (stencil && stencilEnabled) {
								depthStencil.stencilReadMas = stencilFront.readMask;
								depthStencil.stencilWriteMask = stencilFront.writeMask;
								depthStencil.stencilFront = {
										compare: _compareFunction[stencilFront.func],
										failOp: _stencilOps[stencilFront.fail],
										passOp: _stencilOps[stencilFront.zpass],
										depthFailOp: _stencilOps[stencilFront.zfail]
								};
								depthStencil.stencilBack = {
										compare: _compareFunction[stencilBack.func],
										failOp: _stencilOps[stencilBack.fail],
										passOp: _stencilOps[stencilBack.zpass],
										depthFailOp: _stencilOps[stencilBack.zfail]
								};
						}
				}
				return depthStencil;
		}
		create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack) {
				var wgpu = this.device.wgpu;
				var webgpuShader = shader.impl;
				var desc = {
						vertex: {
								module: webgpuShader.getVertexShaderModule(),
								entryPoint: webgpuShader.vertexEntryPoint,
								buffers: vertexBufferLayout
						},
						primitive: {
								topology: primitiveTopology,
								frontFace: 'ccw',
								cullMode: _cullModes[cullMode]
						},
						depthStencil: this.getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack),
						multisample: {
								count: renderTarget.samples
						},
						layout: pipelineLayout
				};
				desc.fragment = {
						module: webgpuShader.getFragmentShaderModule(),
						entryPoint: webgpuShader.fragmentEntryPoint,
						targets: []
				};
				var colorAttachments = renderTarget.impl.colorAttachments;
				if (colorAttachments.length > 0) {
						var writeMask = 0;
						if (blendState.redWrite) writeMask |= GPUColorWrite.RED;
						if (blendState.greenWrite) writeMask |= GPUColorWrite.GREEN;
						if (blendState.blueWrite) writeMask |= GPUColorWrite.BLUE;
						if (blendState.alphaWrite) writeMask |= GPUColorWrite.ALPHA;
						var blend = this.getBlend(blendState);
						colorAttachments.forEach((attachment)=>{
								desc.fragment.targets.push({
										format: attachment.format,
										writeMask: writeMask,
										blend: blend
								});
						});
				}
				var pipeline = wgpu.createRenderPipeline(desc);
				return pipeline;
		}
		constructor(device){
				super(device), this.lookupHashes = new Uint32Array(13);
				this.vertexBufferLayout = new WebgpuVertexBufferLayout();
				this.cache = new Map();
		}
}

class WebgpuComputePipeline extends WebgpuPipeline {
		get(shader, bindGroupFormat) {
				var pipelineLayout = this.getPipelineLayout([
						bindGroupFormat.impl
				]);
				var pipeline = this.create(shader, pipelineLayout);
				return pipeline;
		}
		create(shader, pipelineLayout) {
				var wgpu = this.device.wgpu;
				var webgpuShader = shader.impl;
				var desc = {
						compute: {
								module: webgpuShader.getComputeShaderModule(),
								entryPoint: webgpuShader.computeEntryPoint
						},
						layout: pipelineLayout
				};
				var pipeline = wgpu.createComputePipeline(desc);
				return pipeline;
		}
}

class RefCountedObject {
		incRefCount() {
				this._refCount++;
		}
		decRefCount() {
				this._refCount--;
		}
		get refCount() {
				return this._refCount;
		}
		constructor(){
				this._refCount = 0;
		}
}

class Entry extends RefCountedObject {
		constructor(obj){
				super();
				this.object = obj;
				this.incRefCount();
		}
}
class RefCountedKeyCache {
		destroy() {
				this.cache.forEach((entry)=>{
						var _entry_object;
						(_entry_object = entry.object) == null ? void 0 : _entry_object.destroy();
				});
				this.cache.clear();
		}
		clear() {
				this.cache.clear();
		}
		get(key) {
				var entry = this.cache.get(key);
				if (entry) {
						entry.incRefCount();
						return entry.object;
				}
				return null;
		}
		set(key, object) {
				this.cache.set(key, new Entry(object));
		}
		release(key) {
				var entry = this.cache.get(key);
				if (entry) {
						entry.decRefCount();
						if (entry.refCount === 0) {
								var _entry_object;
								this.cache.delete(key);
								(_entry_object = entry.object) == null ? void 0 : _entry_object.destroy();
						}
				}
		}
		constructor(){
				this.cache = new Map();
		}
}

class MultisampledTextureCache extends RefCountedKeyCache {
		loseContext(device) {
				this.clear();
		}
}
var multisampledTextureCache = new DeviceCache();
var getMultisampledTextureCache = (device)=>{
		return multisampledTextureCache.get(device, ()=>{
				return new MultisampledTextureCache();
		});
};

var stringIds = new StringIds();
class ColorAttachment {
		destroy() {
				var _this_multisampledBuffer;
				(_this_multisampledBuffer = this.multisampledBuffer) == null ? void 0 : _this_multisampledBuffer.destroy();
				this.multisampledBuffer = null;
		}
}
class DepthAttachment {
		destroy(device) {
				if (this.depthTextureInternal) {
						var _this_depthTexture;
						(_this_depthTexture = this.depthTexture) == null ? void 0 : _this_depthTexture.destroy();
						this.depthTexture = null;
				}
				if (this.multisampledDepthBuffer) {
						this.multisampledDepthBuffer = null;
						getMultisampledTextureCache(device).release(this.multisampledDepthBufferKey);
				}
		}
		constructor(gpuFormat){
				this.depthTexture = null;
				this.depthTextureInternal = false;
				this.multisampledDepthBuffer = null;
				this.format = gpuFormat;
				this.hasStencil = gpuFormat === 'depth24plus-stencil8';
		}
}
class WebgpuRenderTarget {
		destroy(device) {
				var _this_depthAttachment;
				this.initialized = false;
				this.assignedColorTexture = null;
				this.colorAttachments.forEach((colorAttachment)=>{
						colorAttachment.destroy();
				});
				this.colorAttachments.length = 0;
				(_this_depthAttachment = this.depthAttachment) == null ? void 0 : _this_depthAttachment.destroy(device);
				this.depthAttachment = null;
		}
		updateKey() {
				var rt = this.renderTarget;
				var key = rt.samples + ":" + (this.depthAttachment ? this.depthAttachment.format : 'nodepth');
				this.colorAttachments.forEach((colorAttachment)=>{
						key += ":" + colorAttachment.format;
				});
				this.key = stringIds.get(key);
		}
		assignColorTexture(device, gpuTexture) {
				this.assignedColorTexture = gpuTexture;
				var view = gpuTexture.createView({
						format: device.backBufferViewFormat
				});
				var colorAttachment = this.renderPassDescriptor.colorAttachments[0];
				var samples = this.renderTarget.samples;
				if (samples > 1) {
						colorAttachment.resolveTarget = view;
				} else {
						colorAttachment.view = view;
				}
				this.setColorAttachment(0, undefined, device.backBufferViewFormat);
				this.updateKey();
		}
		setColorAttachment(index, multisampledBuffer, format) {
				if (!this.colorAttachments[index]) {
						this.colorAttachments[index] = new ColorAttachment();
				}
				if (multisampledBuffer) {
						this.colorAttachments[index].multisampledBuffer = multisampledBuffer;
				}
				if (format) {
						this.colorAttachments[index].format = format;
				}
		}
		init(device, renderTarget) {
				var _renderTarget__colorBuffers;
				var wgpu = device.wgpu;
				this.initDepthStencil(device, wgpu, renderTarget);
				if (renderTarget._colorBuffers) {
						renderTarget._colorBuffers.forEach((colorBuffer, index)=>{
								this.setColorAttachment(index, undefined, colorBuffer.impl.format);
						});
				}
				this.renderPassDescriptor.colorAttachments = [];
				var _renderTarget__colorBuffers_length;
				var count = this.isBackbuffer ? 1 : (_renderTarget__colorBuffers_length = (_renderTarget__colorBuffers = renderTarget._colorBuffers) == null ? void 0 : _renderTarget__colorBuffers.length) != null ? _renderTarget__colorBuffers_length : 0;
				for(var i = 0; i < count; ++i){
						var _this_colorAttachments_;
						var colorAttachment = this.initColor(device, wgpu, renderTarget, i);
						var isDefaultFramebuffer = i === 0 && ((_this_colorAttachments_ = this.colorAttachments[0]) == null ? void 0 : _this_colorAttachments_.format);
						if (colorAttachment.view || isDefaultFramebuffer) {
								this.renderPassDescriptor.colorAttachments.push(colorAttachment);
						}
				}
				this.updateKey();
				this.initialized = true;
		}
		initDepthStencil(device, wgpu, renderTarget) {
				var { samples, width, height, depth, depthBuffer } = renderTarget;
				if (depth || depthBuffer) {
						var renderingView;
						if (!depthBuffer) {
								this.depthAttachment = new DepthAttachment('depth24plus-stencil8');
								var depthTextureDesc = {
										size: [
												width,
												height,
												1
										],
										dimension: '2d',
										sampleCount: samples,
										format: this.depthAttachment.format,
										usage: GPUTextureUsage.RENDER_ATTACHMENT
								};
								if (samples > 1) {
										depthTextureDesc.usage |= GPUTextureUsage.TEXTURE_BINDING;
								} else {
										depthTextureDesc.usage |= GPUTextureUsage.COPY_SRC;
								}
								var depthTexture = wgpu.createTexture(depthTextureDesc);
								this.depthAttachment.depthTexture = depthTexture;
								this.depthAttachment.depthTextureInternal = true;
								renderingView = depthTexture.createView();
						} else {
								this.depthAttachment = new DepthAttachment(depthBuffer.impl.format);
								if (samples > 1) {
										var depthFormat = 'depth24plus-stencil8';
										this.depthAttachment.format = depthFormat;
										this.depthAttachment.hasStencil = depthFormat === 'depth24plus-stencil8';
										var key = depthBuffer.id + ":" + width + ":" + height + ":" + samples + ":" + depthFormat;
										var msTextures = getMultisampledTextureCache(device);
										var msDepthTexture = msTextures.get(key);
										if (!msDepthTexture) {
												var multisampledDepthDesc = {
														size: [
																width,
																height,
																1
														],
														dimension: '2d',
														sampleCount: samples,
														format: depthFormat,
														usage: GPUTextureUsage.RENDER_ATTACHMENT | (depthFormat !== depthBuffer.impl.format ? GPUTextureUsage.TEXTURE_BINDING : 0)
												};
												msDepthTexture = wgpu.createTexture(multisampledDepthDesc);
												msTextures.set(key, msDepthTexture);
										}
										this.depthAttachment.multisampledDepthBuffer = msDepthTexture;
										this.depthAttachment.multisampledDepthBufferKey = key;
										renderingView = msDepthTexture.createView();
								} else {
										var depthTexture1 = depthBuffer.impl.gpuTexture;
										this.depthAttachment.depthTexture = depthTexture1;
										renderingView = depthTexture1.createView();
								}
						}
						this.renderPassDescriptor.depthStencilAttachment = {
								view: renderingView
						};
				}
		}
		initColor(device, wgpu, renderTarget, index) {
				var colorAttachment = {};
				var { samples, width, height, mipLevel } = renderTarget;
				var colorBuffer = renderTarget.getColorBuffer(index);
				var colorView = null;
				if (colorBuffer) {
						var mipLevelCount = 1;
						if (colorBuffer.cubemap) {
								colorView = colorBuffer.impl.createView({
										dimension: '2d',
										baseArrayLayer: renderTarget.face,
										arrayLayerCount: 1,
										mipLevelCount,
										baseMipLevel: mipLevel
								});
						} else {
								colorView = colorBuffer.impl.createView({
										mipLevelCount,
										baseMipLevel: mipLevel
								});
						}
				}
				if (samples > 1) {
						var format = this.isBackbuffer ? device.backBufferViewFormat : colorBuffer.impl.format;
						var multisampledTextureDesc = {
								size: [
										width,
										height,
										1
								],
								dimension: '2d',
								sampleCount: samples,
								format: format,
								usage: GPUTextureUsage.RENDER_ATTACHMENT
						};
						var multisampledColorBuffer = wgpu.createTexture(multisampledTextureDesc);
						this.setColorAttachment(index, multisampledColorBuffer, multisampledTextureDesc.format);
						colorAttachment.view = multisampledColorBuffer.createView();
						colorAttachment.resolveTarget = colorView;
				} else {
						colorAttachment.view = colorView;
				}
				return colorAttachment;
		}
		setupForRenderPass(renderPass, renderTarget) {
				var _this_renderPassDescriptor_colorAttachments;
				var _this_renderPassDescriptor_colorAttachments_length;
				var count = (_this_renderPassDescriptor_colorAttachments_length = (_this_renderPassDescriptor_colorAttachments = this.renderPassDescriptor.colorAttachments) == null ? void 0 : _this_renderPassDescriptor_colorAttachments.length) != null ? _this_renderPassDescriptor_colorAttachments_length : 0;
				for(var i = 0; i < count; ++i){
						var colorAttachment = this.renderPassDescriptor.colorAttachments[i];
						var colorOps = renderPass.colorArrayOps[i];
						var srgb = renderTarget.isColorBufferSrgb(i);
						colorAttachment.clearValue = srgb ? colorOps.clearValueLinear : colorOps.clearValue;
						colorAttachment.loadOp = colorOps.clear ? 'clear' : 'load';
						colorAttachment.storeOp = colorOps.store ? 'store' : 'discard';
				}
				var depthAttachment = this.renderPassDescriptor.depthStencilAttachment;
				if (depthAttachment) {
						depthAttachment.depthClearValue = renderPass.depthStencilOps.clearDepthValue;
						depthAttachment.depthLoadOp = renderPass.depthStencilOps.clearDepth ? 'clear' : 'load';
						depthAttachment.depthStoreOp = renderPass.depthStencilOps.storeDepth ? 'store' : 'discard';
						depthAttachment.depthReadOnly = false;
						if (this.depthAttachment.hasStencil) {
								depthAttachment.stencilClearValue = renderPass.depthStencilOps.clearStencilValue;
								depthAttachment.stencilLoadOp = renderPass.depthStencilOps.clearStencil ? 'clear' : 'load';
								depthAttachment.stencilStoreOp = renderPass.depthStencilOps.storeStencil ? 'store' : 'discard';
								depthAttachment.stencilReadOnly = false;
						}
				}
		}
		loseContext() {
				this.initialized = false;
		}
		resolve(device, target, color, depth) {}
		constructor(renderTarget){
				this.initialized = false;
				this.colorAttachments = [];
				this.depthAttachment = null;
				this.assignedColorTexture = null;
				this.renderPassDescriptor = {};
				this.isBackbuffer = false;
				this.renderTarget = renderTarget;
		}
}

var uniformTypeToNumComponents = [];
uniformTypeToNumComponents[UNIFORMTYPE_FLOAT] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_VEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_VEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_VEC4] = 4;
uniformTypeToNumComponents[UNIFORMTYPE_INT] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_IVEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_IVEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_IVEC4] = 4;
uniformTypeToNumComponents[UNIFORMTYPE_BOOL] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_BVEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_BVEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_BVEC4] = 4;
uniformTypeToNumComponents[UNIFORMTYPE_MAT2] = 8;
uniformTypeToNumComponents[UNIFORMTYPE_MAT3] = 12;
uniformTypeToNumComponents[UNIFORMTYPE_MAT4] = 16;
uniformTypeToNumComponents[UNIFORMTYPE_UINT] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_UVEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_UVEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_UVEC4] = 4;
class UniformFormat {
		get isArrayType() {
				return this.count > 0;
		}
		calculateOffset(offset) {
				var alignment = this.byteSize <= 8 ? this.byteSize : 16;
				if (this.count) {
						alignment = 16;
				}
				offset = math.roundUp(offset, alignment);
				this.offset = offset / 4;
		}
		constructor(name, type, count = 0){
				this.shortName = name;
				this.name = count ? "" + name + "[0]" : name;
				this.type = type;
				this.numComponents = uniformTypeToNumComponents[type];
				this.updateType = type;
				if (count > 0) {
						switch(type){
								case UNIFORMTYPE_FLOAT:
										this.updateType = UNIFORMTYPE_FLOATARRAY;
										break;
								case UNIFORMTYPE_INT:
										this.updateType = UNIFORMTYPE_INTARRAY;
										break;
								case UNIFORMTYPE_UINT:
										this.updateType = UNIFORMTYPE_UINTARRAY;
										break;
								case UNIFORMTYPE_BOOL:
										this.updateType = UNIFORMTYPE_BOOLARRAY;
										break;
								case UNIFORMTYPE_VEC2:
										this.updateType = UNIFORMTYPE_VEC2ARRAY;
										break;
								case UNIFORMTYPE_IVEC2:
										this.updateType = UNIFORMTYPE_IVEC2ARRAY;
										break;
								case UNIFORMTYPE_UVEC2:
										this.updateType = UNIFORMTYPE_UVEC2ARRAY;
										break;
								case UNIFORMTYPE_BVEC2:
										this.updateType = UNIFORMTYPE_BVEC2ARRAY;
										break;
								case UNIFORMTYPE_VEC3:
										this.updateType = UNIFORMTYPE_VEC3ARRAY;
										break;
								case UNIFORMTYPE_IVEC3:
										this.updateType = UNIFORMTYPE_IVEC3ARRAY;
										break;
								case UNIFORMTYPE_UVEC3:
										this.updateType = UNIFORMTYPE_UVEC3ARRAY;
										break;
								case UNIFORMTYPE_BVEC3:
										this.updateType = UNIFORMTYPE_BVEC3ARRAY;
										break;
								case UNIFORMTYPE_VEC4:
										this.updateType = UNIFORMTYPE_VEC4ARRAY;
										break;
								case UNIFORMTYPE_IVEC4:
										this.updateType = UNIFORMTYPE_IVEC4ARRAY;
										break;
								case UNIFORMTYPE_UVEC4:
										this.updateType = UNIFORMTYPE_UVEC4ARRAY;
										break;
								case UNIFORMTYPE_BVEC4:
										this.updateType = UNIFORMTYPE_BVEC4ARRAY;
										break;
								case UNIFORMTYPE_MAT4:
										this.updateType = UNIFORMTYPE_MAT4ARRAY;
										break;
						}
				}
				this.count = count;
				var componentSize = this.numComponents;
				if (count) {
						componentSize = math.roundUp(componentSize, 4);
				}
				this.byteSize = componentSize * 4;
				if (count) {
						this.byteSize *= count;
				}
		}
}
class UniformBufferFormat {
		get(name) {
				return this.map.get(name);
		}
		constructor(graphicsDevice, uniforms){
				this.byteSize = 0;
				this.map = new Map();
				this.scope = graphicsDevice.scope;
				this.uniforms = uniforms;
				var offset = 0;
				for(var i = 0; i < uniforms.length; i++){
						var uniform = uniforms[i];
						uniform.calculateOffset(offset);
						offset = uniform.offset * 4 + uniform.byteSize;
						uniform.scopeId = this.scope.resolve(uniform.name);
						this.map.set(uniform.name, uniform);
				}
				this.byteSize = math.roundUp(offset, 16);
		}
}

var KEYWORD$2 = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g;
var KEYWORD_LINE$1 = /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)(;+)/g;
var MARKER$1 = '@@@';
var ARRAY_IDENTIFIER = /([\w-]+)\[(.*?)\]/;
var precisionQualifiers = new Set([
		'highp',
		'mediump',
		'lowp'
]);
var shadowSamplers = new Set([
		'sampler2DShadow',
		'samplerCubeShadow',
		'sampler2DArrayShadow'
]);
var textureDimensions = {
		sampler2D: TEXTUREDIMENSION_2D,
		sampler3D: TEXTUREDIMENSION_3D,
		samplerCube: TEXTUREDIMENSION_CUBE,
		samplerCubeShadow: TEXTUREDIMENSION_CUBE,
		sampler2DShadow: TEXTUREDIMENSION_2D,
		sampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
		sampler2DArrayShadow: TEXTUREDIMENSION_2D_ARRAY,
		isampler2D: TEXTUREDIMENSION_2D,
		usampler2D: TEXTUREDIMENSION_2D,
		isampler3D: TEXTUREDIMENSION_3D,
		usampler3D: TEXTUREDIMENSION_3D,
		isamplerCube: TEXTUREDIMENSION_CUBE,
		usamplerCube: TEXTUREDIMENSION_CUBE,
		isampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
		usampler2DArray: TEXTUREDIMENSION_2D_ARRAY
};
var textureDimensionInfo = {
		[TEXTUREDIMENSION_2D]: 'texture2D',
		[TEXTUREDIMENSION_CUBE]: 'textureCube',
		[TEXTUREDIMENSION_3D]: 'texture3D',
		[TEXTUREDIMENSION_2D_ARRAY]: 'texture2DArray'
};
let UniformLine$1 = class UniformLine {
		constructor(line, shader){
				this.line = line;
				var words = line.trim().split(/\s+/);
				if (precisionQualifiers.has(words[0])) {
						this.precision = words.shift();
				}
				this.type = words.shift();
				if (line.includes(',')) ;
				if (line.includes('[')) {
						var rest = words.join(' ');
						var match = ARRAY_IDENTIFIER.exec(rest);
						this.name = match[1];
						this.arraySize = Number(match[2]);
						if (isNaN(this.arraySize)) {
								shader.failed = true;
						}
				} else {
						this.name = words.shift();
						this.arraySize = 0;
				}
				this.isSampler = this.type.indexOf('sampler') !== -1;
				this.isSignedInt = this.type.indexOf('isampler') !== -1;
				this.isUnsignedInt = this.type.indexOf('usampler') !== -1;
		}
};
class ShaderProcessorGLSL {
		static run(device, shaderDefinition, shader) {
				var varyingMap = new Map();
				var vertexExtracted = ShaderProcessorGLSL.extract(shaderDefinition.vshader);
				var fragmentExtracted = ShaderProcessorGLSL.extract(shaderDefinition.fshader);
				var attributesMap = new Map();
				var attributesBlock = ShaderProcessorGLSL.processAttributes(vertexExtracted.attributes, shaderDefinition.attributes, attributesMap, shaderDefinition.processingOptions);
				var vertexVaryingsBlock = ShaderProcessorGLSL.processVaryings(vertexExtracted.varyings, varyingMap, true);
				var fragmentVaryingsBlock = ShaderProcessorGLSL.processVaryings(fragmentExtracted.varyings, varyingMap, false);
				var outBlock = ShaderProcessorGLSL.processOuts(fragmentExtracted.outs);
				var concatUniforms = vertexExtracted.uniforms.concat(fragmentExtracted.uniforms);
				var uniforms = Array.from(new Set(concatUniforms));
				var parsedUniforms = uniforms.map((line)=>new UniformLine$1(line, shader));
				var uniformsData = ShaderProcessorGLSL.processUniforms(device, parsedUniforms, shaderDefinition.processingOptions, shader);
				var vBlock = attributesBlock + "\n" + vertexVaryingsBlock + "\n" + uniformsData.code;
				var vshader = vertexExtracted.src.replace(MARKER$1, vBlock);
				var fBlock = fragmentVaryingsBlock + "\n" + outBlock + "\n" + uniformsData.code;
				var fshader = fragmentExtracted.src.replace(MARKER$1, fBlock);
				return {
						vshader: vshader,
						fshader: fshader,
						attributes: attributesMap,
						meshUniformBufferFormat: uniformsData.meshUniformBufferFormat,
						meshBindGroupFormat: uniformsData.meshBindGroupFormat
				};
		}
		static extract(src) {
				var attributes = [];
				var varyings = [];
				var outs = [];
				var uniforms = [];
				var replacement = "" + MARKER$1 + "\n";
				var match;
				while((match = KEYWORD$2.exec(src)) !== null){
						var keyword = match[1];
						switch(keyword){
								case 'attribute':
								case 'varying':
								case 'uniform':
								case 'out':
										{
												KEYWORD_LINE$1.lastIndex = match.index;
												var lineMatch = KEYWORD_LINE$1.exec(src);
												if (keyword === 'attribute') {
														attributes.push(lineMatch[2]);
												} else if (keyword === 'varying') {
														varyings.push(lineMatch[2]);
												} else if (keyword === 'out') {
														outs.push(lineMatch[2]);
												} else if (keyword === 'uniform') {
														uniforms.push(lineMatch[2]);
												}
												src = ShaderProcessorGLSL.cutOut(src, match.index, KEYWORD_LINE$1.lastIndex, replacement);
												KEYWORD$2.lastIndex = match.index + replacement.length;
												replacement = '';
												break;
										}
						}
				}
				return {
						src,
						attributes,
						varyings,
						outs,
						uniforms
				};
		}
		static processUniforms(device, uniforms, processingOptions, shader) {
				var uniformLinesSamplers = [];
				var uniformLinesNonSamplers = [];
				uniforms.forEach((uniform)=>{
						if (uniform.isSampler) {
								uniformLinesSamplers.push(uniform);
						} else {
								uniformLinesNonSamplers.push(uniform);
						}
				});
				var meshUniforms = [];
				uniformLinesNonSamplers.forEach((uniform)=>{
						if (!processingOptions.hasUniform(uniform.name)) {
								var uniformType = uniformTypeToName.indexOf(uniform.type);
								var uniformFormat = new UniformFormat(uniform.name, uniformType, uniform.arraySize);
								meshUniforms.push(uniformFormat);
						}
				});
				if (meshUniforms.length === 0) {
						meshUniforms.push(new UniformFormat(UNUSED_UNIFORM_NAME, UNIFORMTYPE_FLOAT));
				}
				var meshUniformBufferFormat = meshUniforms.length ? new UniformBufferFormat(device, meshUniforms) : null;
				var textureFormats = [];
				uniformLinesSamplers.forEach((uniform)=>{
						if (!processingOptions.hasTexture(uniform.name)) {
								var sampleType = SAMPLETYPE_FLOAT;
								if (uniform.isSignedInt) {
										sampleType = SAMPLETYPE_INT;
								} else if (uniform.isUnsignedInt) {
										sampleType = SAMPLETYPE_UINT;
								} else {
										if (uniform.precision === 'highp') {
												sampleType = SAMPLETYPE_UNFILTERABLE_FLOAT;
										}
										if (shadowSamplers.has(uniform.type)) {
												sampleType = SAMPLETYPE_DEPTH;
										}
								}
								var dimension = textureDimensions[uniform.type];
								textureFormats.push(new BindTextureFormat(uniform.name, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT, dimension, sampleType));
						}
				});
				var meshBindGroupFormat = new BindGroupFormat(device, textureFormats);
				var code = '';
				processingOptions.uniformFormats.forEach((format, bindGroupIndex)=>{
						if (format) {
								code += ShaderProcessorGLSL.getUniformShaderDeclaration(format, bindGroupIndex, 0);
						}
				});
				if (meshUniformBufferFormat) {
						code += ShaderProcessorGLSL.getUniformShaderDeclaration(meshUniformBufferFormat, BINDGROUP_MESH_UB, 0);
				}
				processingOptions.bindGroupFormats.forEach((format, bindGroupIndex)=>{
						if (format) {
								code += ShaderProcessorGLSL.getTexturesShaderDeclaration(format, bindGroupIndex);
						}
				});
				code += ShaderProcessorGLSL.getTexturesShaderDeclaration(meshBindGroupFormat, BINDGROUP_MESH);
				return {
						code,
						meshUniformBufferFormat,
						meshBindGroupFormat
				};
		}
		static processVaryings(varyingLines, varyingMap, isVertex) {
				var block = '';
				var op = isVertex ? 'out' : 'in';
				varyingLines.forEach((line, index)=>{
						var words = ShaderProcessorGLSL.splitToWords(line);
						var type = words.slice(0, -1).join(' ');
						var name = words[words.length - 1];
						if (isVertex) {
								varyingMap.set(name, index);
						} else {
								index = varyingMap.get(name);
						}
						block += "layout(location = " + index + ") " + op + " " + type + " " + name + ";\n";
				});
				return block;
		}
		static processOuts(outsLines) {
				var block = '';
				outsLines.forEach((line, index)=>{
						block += "layout(location = " + index + ") out " + line + ";\n";
				});
				return block;
		}
		static getTypeCount(type) {
				var lastChar = type.substring(type.length - 1);
				var num = parseInt(lastChar, 10);
				return isNaN(num) ? 1 : num;
		}
		static processAttributes(attributeLines, shaderDefinitionAttributes, attributesMap, processingOptions) {
				var block = '';
				attributeLines.forEach((line)=>{
						var words = ShaderProcessorGLSL.splitToWords(line);
						var type = words[0];
						var name = words[1];
						if (shaderDefinitionAttributes.hasOwnProperty(name)) {
								var semantic = shaderDefinitionAttributes[name];
								var location = semanticToLocation[semantic];
								attributesMap.set(location, name);
								var copyCode;
								var element = processingOptions.getVertexElement(semantic);
								if (element) {
										var dataType = element.dataType;
										if (dataType !== TYPE_FLOAT32 && dataType !== TYPE_FLOAT16 && !element.normalize && !element.asInt) {
												var attribNumElements = ShaderProcessorGLSL.getTypeCount(type);
												var newName = "_private_" + name;
												copyCode = "vec" + attribNumElements + " " + name + " = vec" + attribNumElements + "(" + newName + ");\n";
												name = newName;
												var isSignedType = dataType === TYPE_INT8 || dataType === TYPE_INT16 || dataType === TYPE_INT32;
												if (attribNumElements === 1) {
														type = isSignedType ? 'int' : 'uint';
												} else {
														type = isSignedType ? "ivec" + attribNumElements : "uvec" + attribNumElements;
												}
										}
								}
								block += "layout(location = " + location + ") in " + type + " " + name + ";\n";
								if (copyCode) {
										block += copyCode;
								}
						}
				});
				return block;
		}
		static splitToWords(line) {
				line = line.replace(/\s+/g, ' ').trim();
				return line.split(' ');
		}
		static cutOut(src, start, end, replacement) {
				return src.substring(0, start) + replacement + src.substring(end);
		}
		static getUniformShaderDeclaration(format, bindGroup, bindIndex) {
				var name = bindGroupNames[bindGroup];
				var code = "layout(set = " + bindGroup + ", binding = " + bindIndex + ", std140) uniform ub_" + name + " {\n";
				format.uniforms.forEach((uniform)=>{
						var typeString = uniformTypeToName[uniform.type];
						code += "    " + typeString + " " + uniform.shortName + (uniform.count ? "[" + uniform.count + "]" : '') + ";\n";
				});
				return "" + code + "};\n";
		}
		static getTexturesShaderDeclaration(bindGroupFormat, bindGroup) {
				var code = '';
				bindGroupFormat.textureFormats.forEach((format)=>{
						var textureType = textureDimensionInfo[format.textureDimension];
						var isArray = textureType === 'texture2DArray';
						var sampleTypePrefix = format.sampleType === SAMPLETYPE_UINT ? 'u' : format.sampleType === SAMPLETYPE_INT ? 'i' : '';
						textureType = "" + sampleTypePrefix + textureType;
						var namePostfix = '';
						var extraCode = '';
						if (isArray) {
								namePostfix = '_texture';
								extraCode = "#define " + format.name + " " + sampleTypePrefix + "sampler2DArray(" + format.name + namePostfix + ", " + format.name + "_sampler)\n";
						}
						code += "layout(set = " + bindGroup + ", binding = " + format.slot + ") uniform " + textureType + " " + format.name + namePostfix + ";\n";
						if (format.hasSampler) {
								code += "layout(set = " + bindGroup + ", binding = " + (format.slot + 1) + ") uniform sampler " + format.name + "_sampler;\n";
						}
						code += extraCode;
				});
				return code;
		}
}

var KEYWORD$1 = /^[ \t]*(attribute|varying|uniform)[\t ]+/gm;
var KEYWORD_LINE = /^[ \t]*(attribute|varying|uniform)[ \t]*([^;]+)(;+)/gm;
var KEYWORD_RESOURCE = /^[ \t]*var\s*(<[^>]+>)?\s*[\w\d_]+\s*:\s*(texture_.*|storage_texture_.*|storage.*|external_texture|array<.*>|sampler|sampler_comparison).*;\s*$/gm;
var VARYING = /(?:@interpolate\([^)]*\)\s*)?([\w]+)\s*:/;
var MARKER = '@@@';
var getTextureDimension = (textureType, isArray)=>{
		if (isArray) {
				if (textureType === '2d') return TEXTUREDIMENSION_2D_ARRAY;
				else if (textureType === 'cube') return TEXTUREDIMENSION_CUBE_ARRAY;
		} else {
				switch(textureType){
						case '1d':
								return TEXTUREDIMENSION_1D;
						case '2d':
								return TEXTUREDIMENSION_2D;
						case '3d':
								return TEXTUREDIMENSION_3D;
						case 'cube':
								return TEXTUREDIMENSION_CUBE;
				}
		}
};
var getTextureTypeCode = (dimension, sampleType)=>{
		var sampleFormat = sampleType === SAMPLETYPE_FLOAT ? 'f32' : sampleType === SAMPLETYPE_INT ? 'i32' : 'u32';
		switch(dimension){
				case TEXTUREDIMENSION_1D:
						return "texture_1d<" + sampleFormat + ">";
				case TEXTUREDIMENSION_2D:
						return "texture_2d<" + sampleFormat + ">";
				case TEXTUREDIMENSION_3D:
						return "texture_3d<" + sampleFormat + ">";
				case TEXTUREDIMENSION_CUBE:
						return "texture_cube<" + sampleFormat + ">";
				case TEXTUREDIMENSION_2D_ARRAY:
						return "texture_2d_array<" + sampleFormat + ">";
				case TEXTUREDIMENSION_CUBE_ARRAY:
						return "texture_cube_array<" + sampleFormat + ">";
		}
};
var textureFormat2SampleType = {
		'f32': SAMPLETYPE_FLOAT,
		'i32': SAMPLETYPE_INT,
		'u32': SAMPLETYPE_UINT
};
var wrappedArrayTypes = {
		'f32': 'WrappedF32',
		'i32': 'WrappedI32',
		'u32': 'WrappedU32',
		'vec2f': 'WrappedVec2F',
		'vec2i': 'WrappedVec2I',
		'vec2u': 'WrappedVec2U'
};
var splitToWords = (line)=>{
		line = line.replace(/\s+/g, ' ').trim();
		return line.split(/[\s:]+/);
};
var UNIFORM_ARRAY_REGEX = /array<([^,]+),\s*([^>]+)>/;
class UniformLine {
		constructor(line, shader){
				this.ubName = null;
				this.arraySize = 0;
				this.line = line;
				var parts = splitToWords(line);
				if (parts.length < 2) {
						shader.failed = true;
						return;
				}
				this.name = parts[0];
				this.type = parts.slice(1).join(' ');
				if (this.type.includes('array<')) {
						var match = UNIFORM_ARRAY_REGEX.exec(this.type);
						this.type = match[1].trim();
						this.arraySize = Number(match[2]);
						if (isNaN(this.arraySize)) {
								shader.failed = true;
						}
				}
		}
}
var ARRAY_REGEX = /^\s*var\s+([\w\d_]+)\s*:\s*array<([\w\d_<>]+),\s*(\d+)>;\s*$/;
var TEXTURE_REGEX = /^\s*var\s+([\w\d_]+)\s*:\s*texture_(\w+)<([a-zA-Z0-9_,<>]*)>;\s*$/;
var STORAGE_TEXTURE_REGEX = /^\s*var\s+([\w\d_]+)\s*:\s*(texture_storage_2d|texture_storage_2d_array)<([\w\d_]+),\s*(\w+)>\s*;\s*$/;
var STORAGE_BUFFER_REGEX = /^\s*var\s*<storage,\s*(read|write)?>\s*([\w\d_]+)\s*:\s*(.*)\s*;\s*$/;
var EXTERNAL_TEXTURE_REGEX = /^\s*var\s+([\w\d_]+)\s*:\s*texture_external;\s*$/;
var SAMPLER_REGEX = /^\s*var\s+([\w\d_]+)\s*:\s*(sampler|sampler_comparison)\s*;\s*$/;
class ResourceLine {
		constructor(line, shader){
				this.originalLine = line;
				this.line = line;
				this.isTexture = false;
				this.isSampler = false;
				this.isStorageTexture = false;
				this.isStorageBuffer = false;
				this.isExternalTexture = false;
				this.arraySize = 0;
				this.type = '';
				this.matchedElements = [];
				var arrayMatch = line.match(ARRAY_REGEX);
				if (arrayMatch) {
						this.name = arrayMatch[1];
						this.arraySize = parseInt(arrayMatch[3], 10);
						this.line = "var " + this.name + " : " + arrayMatch[2] + ";";
						this.matchedElements.push(...arrayMatch);
						if (isNaN(this.arraySize)) {
								shader.failed = true;
						}
				}
				var textureMatch = this.line.match(TEXTURE_REGEX);
				if (textureMatch) {
						this.name = textureMatch[1];
						this.type = textureMatch[2];
						this.textureFormat = textureMatch[3];
						this.isTexture = true;
						this.matchedElements.push(...textureMatch);
						this.textureDimension = getTextureDimension(this.type, this.arraySize > 0);
						this.sampleType = textureFormat2SampleType[this.textureFormat];
				}
				var storageTextureMatch = this.line.match(STORAGE_TEXTURE_REGEX);
				if (storageTextureMatch) {
						this.isStorageTexture = true;
						this.name = storageTextureMatch[1];
						this.textureType = storageTextureMatch[2];
						this.format = storageTextureMatch[3];
						this.access = storageTextureMatch[4];
						this.matchedElements.push(...storageTextureMatch);
				}
				var storageBufferMatch = this.line.match(STORAGE_BUFFER_REGEX);
				if (storageBufferMatch) {
						this.isStorageBuffer = true;
						this.accessMode = storageBufferMatch[1] || 'none';
						this.name = storageBufferMatch[2];
						this.type = storageBufferMatch[3];
						this.matchedElements.push(...storageBufferMatch);
				}
				var externalTextureMatch = this.line.match(EXTERNAL_TEXTURE_REGEX);
				if (externalTextureMatch) {
						this.name = externalTextureMatch[1];
						this.isExternalTexture = true;
						this.matchedElements.push(...storageBufferMatch);
				}
				var samplerMatch = this.line.match(SAMPLER_REGEX);
				if (samplerMatch) {
						this.name = samplerMatch[1];
						this.samplerType = samplerMatch[2];
						this.isSampler = true;
						this.matchedElements.push(...samplerMatch);
				}
				if (this.matchedElements.length === 0) {
						shader.failed = true;
				}
		}
}
class WebgpuShaderProcessorWGSL {
		static run(device, shaderDefinition, shader) {
				var varyingMap = new Map();
				var vertexExtracted = WebgpuShaderProcessorWGSL.extract(shaderDefinition.vshader);
				var fragmentExtracted = WebgpuShaderProcessorWGSL.extract(shaderDefinition.fshader);
				var attributesMap = new Map();
				var attributesBlock = WebgpuShaderProcessorWGSL.processAttributes(vertexExtracted.attributes, shaderDefinition.attributes, attributesMap, shaderDefinition.processingOptions);
				var vertexVaryingsBlock = WebgpuShaderProcessorWGSL.processVaryings(vertexExtracted.varyings, varyingMap, true);
				var fragmentVaryingsBlock = WebgpuShaderProcessorWGSL.processVaryings(fragmentExtracted.varyings, varyingMap, false);
				var concatUniforms = vertexExtracted.uniforms.concat(fragmentExtracted.uniforms);
				var uniforms = Array.from(new Set(concatUniforms));
				var parsedUniforms = uniforms.map((line)=>new UniformLine(line, shader));
				var uniformsData = WebgpuShaderProcessorWGSL.processUniforms(device, parsedUniforms, shaderDefinition.processingOptions, shader);
				vertexExtracted.src = WebgpuShaderProcessorWGSL.renameUniformAccess(vertexExtracted.src, parsedUniforms);
				fragmentExtracted.src = WebgpuShaderProcessorWGSL.renameUniformAccess(fragmentExtracted.src, parsedUniforms);
				var concatResources = vertexExtracted.resources.concat(fragmentExtracted.resources);
				var resources = Array.from(new Set(concatResources));
				var parsedResources = resources.map((line)=>new ResourceLine(line, shader));
				var resourcesData = WebgpuShaderProcessorWGSL.processResources(device, parsedResources, shaderDefinition.processingOptions, shader);
				var fOutput = WebgpuShaderProcessorWGSL.generateFragmentOutputStruct(fragmentExtracted.src, device.maxColorAttachments);
				var vBlock = attributesBlock + "\n" + vertexVaryingsBlock + "\n" + uniformsData.code + "\n" + resourcesData.code + "\n";
				var vshader = vertexExtracted.src.replace(MARKER, vBlock);
				var fBlock = fragmentVaryingsBlock + "\n" + fOutput + "\n" + uniformsData.code + "\n" + resourcesData.code + "\n";
				var fshader = fragmentExtracted.src.replace(MARKER, fBlock);
				return {
						vshader: vshader,
						fshader: fshader,
						attributes: attributesMap,
						meshUniformBufferFormat: uniformsData.meshUniformBufferFormat,
						meshBindGroupFormat: resourcesData.meshBindGroupFormat
				};
		}
		static extract(src) {
				var attributes = [];
				var varyings = [];
				var uniforms = [];
				var resources = [];
				var replacement = "" + MARKER + "\n";
				var match;
				while((match = KEYWORD$1.exec(src)) !== null){
						var keyword = match[1];
						KEYWORD_LINE.lastIndex = match.index;
						var lineMatch = KEYWORD_LINE.exec(src);
						if (keyword === 'attribute') {
								attributes.push(lineMatch[2]);
						} else if (keyword === 'varying') {
								varyings.push(lineMatch[2]);
						} else if (keyword === 'uniform') {
								uniforms.push(lineMatch[2]);
						}
						src = WebgpuShaderProcessorWGSL.cutOut(src, match.index, KEYWORD_LINE.lastIndex, replacement);
						KEYWORD$1.lastIndex = match.index + replacement.length;
						replacement = '';
				}
				while((match = KEYWORD_RESOURCE.exec(src)) !== null){
						resources.push(match[0]);
						src = WebgpuShaderProcessorWGSL.cutOut(src, match.index, KEYWORD_RESOURCE.lastIndex, replacement);
						KEYWORD_RESOURCE.lastIndex = match.index + replacement.length;
						replacement = '';
				}
				return {
						src,
						attributes,
						varyings,
						uniforms,
						resources
				};
		}
		static processUniforms(device, uniforms, processingOptions, shader) {
				var meshUniforms = [];
				uniforms.forEach((uniform)=>{
						if (!processingOptions.hasUniform(uniform.name)) {
								uniform.ubName = 'ub_mesh_ub';
								var uniformType = uniformTypeToNameMapWGSL.get(uniform.type);
								var uniformFormat = new UniformFormat(uniform.name, uniformType, uniform.arraySize);
								meshUniforms.push(uniformFormat);
						} else {
								uniform.ubName = 'ub_view';
						}
				});
				if (meshUniforms.length === 0) {
						meshUniforms.push(new UniformFormat(UNUSED_UNIFORM_NAME, UNIFORMTYPE_FLOAT));
				}
				var meshUniformBufferFormat = new UniformBufferFormat(device, meshUniforms);
				var code = '';
				processingOptions.uniformFormats.forEach((format, bindGroupIndex)=>{
						if (format) {
								code += WebgpuShaderProcessorWGSL.getUniformShaderDeclaration(format, bindGroupIndex, 0);
						}
				});
				if (meshUniformBufferFormat) {
						code += WebgpuShaderProcessorWGSL.getUniformShaderDeclaration(meshUniformBufferFormat, BINDGROUP_MESH_UB, 0);
				}
				return {
						code,
						meshUniformBufferFormat
				};
		}
		static renameUniformAccess(source, uniforms) {
				uniforms.forEach((uniform)=>{
						var srcName = "uniform." + uniform.name;
						var dstName = uniform.ubName + "." + uniform.name;
						var regex = new RegExp("\\b" + srcName + "\\b", 'g');
						source = source.replace(regex, dstName);
				});
				return source;
		}
		static processResources(device, resources, processingOptions, shader) {
				var textureFormats = [];
				for(var i = 0; i < resources.length; i++){
						var resource = resources[i];
						if (resource.isTexture) {
								var sampler = resources[i + 1];
								var hasSampler = sampler == null ? void 0 : sampler.isSampler;
								var sampleType = resource.sampleType;
								var dimension = resource.textureDimension;
								textureFormats.push(new BindTextureFormat(resource.name, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT, dimension, sampleType, hasSampler, hasSampler ? sampler.name : null));
								if (hasSampler) i++;
						}
						if (resource.isStorageBuffer) {
								var readOnly = resource.accessMode !== 'read_write';
								var bufferFormat = new BindStorageBufferFormat(resource.name, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT, readOnly);
								bufferFormat.format = resource.type;
								textureFormats.push(bufferFormat);
						}
				}
				var meshBindGroupFormat = new BindGroupFormat(device, textureFormats);
				var code = '';
				processingOptions.bindGroupFormats.forEach((format, bindGroupIndex)=>{
						if (format) {
								code += WebgpuShaderProcessorWGSL.getTextureShaderDeclaration(format, bindGroupIndex, 1);
						}
				});
				code += WebgpuShaderProcessorWGSL.getTextureShaderDeclaration(meshBindGroupFormat, BINDGROUP_MESH, 0);
				return {
						code,
						meshBindGroupFormat
				};
		}
		static getUniformShaderDeclaration(ubFormat, bindGroup, bindIndex) {
				var name = bindGroupNames[bindGroup];
				var structName = "struct_ub_" + name;
				var code = "struct " + structName + " {\n";
				ubFormat.uniforms.forEach((uniform)=>{
						var typeString = uniformTypeToNameWGSL[uniform.type][0];
						if (uniform.count > 0) {
								if (wrappedArrayTypes.hasOwnProperty(typeString)) {
										typeString = wrappedArrayTypes[typeString];
								}
								code += "    " + uniform.shortName + ": array<" + typeString + ", " + uniform.count + ">,\n";
						} else {
								code += "    " + uniform.shortName + ": " + typeString + ",\n";
						}
				});
				code += '};\n';
				code += "@group(" + bindGroup + ") @binding(" + bindIndex + ") var<uniform> ub_" + name + " : " + structName + ";\n\n";
				return code;
		}
		static getTextureShaderDeclaration(format, bindGroup, startBindIndex) {
				var code = '';
				var bindIndex = startBindIndex;
				format.textureFormats.forEach((format)=>{
						var typeCode = getTextureTypeCode(format.textureDimension, format.sampleType);
						code += "@group(" + bindGroup + ") @binding(" + bindIndex + ") var " + format.name + ": " + typeCode + ";\n";
						bindIndex++;
						if (format.hasSampler) {
								code += "@group(" + bindGroup + ") @binding(" + bindIndex + ") var " + format.samplerName + ": sampler;\n";
								bindIndex++;
						}
				});
				format.storageBufferFormats.forEach((format)=>{
						var access = format.readOnly ? 'read' : 'read_write';
						code += "@group(" + bindGroup + ") @binding(" + bindIndex + ") var<storage, " + access + "> " + format.name + " : " + format.format + ";\n";
						bindIndex++;
				});
				return code;
		}
		static processVaryings(varyingLines, varyingMap, isVertex) {
				var block = '';
				varyingLines.forEach((line, index)=>{
						var match = line.match(VARYING);
						if (match) {
								var name = match[1];
								if (isVertex) {
										varyingMap.set(name, index);
								} else {
										index = varyingMap.get(name);
								}
								block += "    @location(" + index + ") " + line + ",\n";
						}
				});
				if (isVertex) {
						block += '    @builtin(position) position : vec4f,\n';
				} else {
						block += '    @builtin(position) position : vec4f,\n';
						block += '    @builtin(front_facing) frontFacing : bool,\n';
						block += '    @builtin(sample_index) sampleIndex : u32\n';
				}
				var structName = isVertex ? 'VertexOutput' : 'FragmentInput';
				return "struct " + structName + " {\n" + block + "};\n";
		}
		static generateFragmentOutputStruct(src, numRenderTargets) {
				var structCode = 'struct FragmentOutput {\n';
				for(var i = 0; i < numRenderTargets; i++){
						structCode += "    @location(" + i + ") color" + (i > 0 ? i : '') + " : vec4f,\n";
				}
				var needsFragDepth = src.search(/\.fragDepth\s*=/) !== -1;
				if (needsFragDepth) {
						structCode += '    @builtin(frag_depth) fragDepth : f32\n';
				}
				return "" + structCode + "};\n";
		}
		static processAttributes(attributeLines, shaderDefinitionAttributes, attributesMap, processingOptions) {
				if (shaderDefinitionAttributes === void 0) shaderDefinitionAttributes = {};
				var block = '';
				attributeLines.forEach((line)=>{
						var words = splitToWords(line);
						var name = words[0];
						if (shaderDefinitionAttributes.hasOwnProperty(name)) {
								var semantic = shaderDefinitionAttributes[name];
								var location = semanticToLocation[semantic];
								attributesMap.set(location, name);
								block += "    @location(" + location + ") " + line + ",\n";
						}
				});
				block += '    @builtin(vertex_index) vertexIndex : u32,\n';
				block += '    @builtin(instance_index) instanceIndex : u32\n';
				return "struct VertexInput {\n" + block + "};\n";
		}
		static cutOut(src, start, end, replacement) {
				return src.substring(0, start) + replacement + src.substring(end);
		}
}

class WebgpuShader {
		destroy(shader) {
				this._vertexCode = null;
				this._fragmentCode = null;
		}
		createShaderModule(code, shaderType) {
				var device = this.shader.device;
				var wgpu = device.wgpu;
				var shaderModule = wgpu.createShaderModule({
						code: code
				});
				return shaderModule;
		}
		getVertexShaderModule() {
				return this.createShaderModule(this._vertexCode, 'Vertex');
		}
		getFragmentShaderModule() {
				return this.createShaderModule(this._fragmentCode, 'Fragment');
		}
		getComputeShaderModule() {
				return this.createShaderModule(this._computeCode, 'Compute');
		}
		processGLSL() {
				var shader = this.shader;
				var processed = ShaderProcessorGLSL.run(shader.device, shader.definition, shader);
				this._vertexCode = this.transpile(processed.vshader, 'vertex', shader.definition.vshader);
				this._fragmentCode = this.transpile(processed.fshader, 'fragment', shader.definition.fshader);
				if (!(this._vertexCode && this._fragmentCode)) {
						shader.failed = true;
				} else {
						shader.ready = true;
				}
				shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
				shader.meshBindGroupFormat = processed.meshBindGroupFormat;
				shader.attributes = processed.attributes;
		}
		processWGSL() {
				var shader = this.shader;
				var processed = WebgpuShaderProcessorWGSL.run(shader.device, shader.definition, shader);
				this._vertexCode = processed.vshader;
				this._fragmentCode = processed.fshader;
				shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
				shader.meshBindGroupFormat = processed.meshBindGroupFormat;
				shader.attributes = processed.attributes;
		}
		transpile(src, shaderType, originalSrc) {
				try {
						var spirv = this.shader.device.glslang.compileGLSL(src, shaderType);
						var wgsl = this.shader.device.twgsl.convertSpirV2WGSL(spirv);
						return wgsl;
				} catch (err) {
						console.error("Failed to transpile webgl " + shaderType + " shader [" + this.shader.label + "] to WebGPU while rendering " + void 0 + ", error:\n [" + err.stack + "]", {
								processed: src,
								original: originalSrc,
								shader: this.shader,
								error: err,
								stack: err.stack
						});
				}
		}
		get vertexCode() {
				return this._vertexCode;
		}
		get fragmentCode() {
				return this._fragmentCode;
		}
		loseContext() {}
		restoreContext(device, shader) {}
		constructor(shader){
				this._vertexCode = null;
				this._fragmentCode = null;
				this._computeCode = null;
				this.vertexEntryPoint = 'main';
				this.fragmentEntryPoint = 'main';
				this.computeEntryPoint = 'main';
				this.shader = shader;
				var definition = shader.definition;
				if (definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
						if (definition.cshader) {
								var _definition_cshader;
								this._computeCode = (_definition_cshader = definition.cshader) != null ? _definition_cshader : null;
								this.computeUniformBufferFormats = definition.computeUniformBufferFormats;
								this.computeBindGroupFormat = definition.computeBindGroupFormat;
						} else {
								this.vertexEntryPoint = 'vertexMain';
								this.fragmentEntryPoint = 'fragmentMain';
								if (definition.processingOptions) {
										this.processWGSL();
								} else {
										var _definition_vshader;
										this._vertexCode = (_definition_vshader = definition.vshader) != null ? _definition_vshader : null;
										var _definition_fshader;
										this._fragmentCode = (_definition_fshader = definition.fshader) != null ? _definition_fshader : null;
										shader.meshUniformBufferFormat = definition.meshUniformBufferFormat;
										shader.meshBindGroupFormat = definition.meshBindGroupFormat;
								}
						}
						shader.ready = true;
				} else {
						if (definition.processingOptions) {
								this.processGLSL();
						}
				}
		}
}

var gpuAddressModes = [];
gpuAddressModes[ADDRESS_REPEAT] = 'repeat';
gpuAddressModes[ADDRESS_CLAMP_TO_EDGE] = 'clamp-to-edge';
gpuAddressModes[ADDRESS_MIRRORED_REPEAT] = 'mirror-repeat';
var gpuFilterModes = [];
gpuFilterModes[FILTER_NEAREST] = {
		level: 'nearest',
		mip: 'nearest'
};
gpuFilterModes[FILTER_LINEAR] = {
		level: 'linear',
		mip: 'nearest'
};
gpuFilterModes[FILTER_NEAREST_MIPMAP_NEAREST] = {
		level: 'nearest',
		mip: 'nearest'
};
gpuFilterModes[FILTER_NEAREST_MIPMAP_LINEAR] = {
		level: 'nearest',
		mip: 'linear'
};
gpuFilterModes[FILTER_LINEAR_MIPMAP_NEAREST] = {
		level: 'linear',
		mip: 'nearest'
};
gpuFilterModes[FILTER_LINEAR_MIPMAP_LINEAR] = {
		level: 'linear',
		mip: 'linear'
};
var dummyUse = (thingOne)=>{};
class WebgpuTexture {
		create(device) {
				var texture = this.texture;
				var wgpu = device.wgpu;
				var numLevels = texture.numLevels;
				this.desc = {
						size: {
								width: texture.width,
								height: texture.height,
								depthOrArrayLayers: texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1
						},
						format: this.format,
						mipLevelCount: numLevels,
						sampleCount: 1,
						dimension: texture.volume ? '3d' : '2d',
						usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (isCompressedPixelFormat(texture.format) ? 0 : GPUTextureUsage.RENDER_ATTACHMENT) | (texture.storage ? GPUTextureUsage.STORAGE_BINDING : 0)
				};
				this.gpuTexture = wgpu.createTexture(this.desc);
				var viewDescr;
				if (this.texture.format === PIXELFORMAT_DEPTHSTENCIL) {
						viewDescr = {
								format: 'depth24plus',
								aspect: 'depth-only'
						};
				}
				this.view = this.createView(viewDescr);
		}
		destroy(device) {}
		propertyChanged(flag) {
				this.samplers.length = 0;
		}
		getView(device) {
				this.uploadImmediate(device, this.texture);
				return this.view;
		}
		createView(viewDescr) {
				var options = viewDescr != null ? viewDescr : {};
				var textureDescr = this.desc;
				var texture = this.texture;
				var defaultViewDimension = ()=>{
						if (texture.cubemap) return 'cube';
						if (texture.volume) return '3d';
						if (texture.array) return '2d-array';
						return '2d';
				};
				var _options_format, _options_dimension, _options_aspect, _options_baseMipLevel, _options_mipLevelCount, _options_baseArrayLayer, _options_arrayLayerCount;
				var desc = {
						format: (_options_format = options.format) != null ? _options_format : textureDescr.format,
						dimension: (_options_dimension = options.dimension) != null ? _options_dimension : defaultViewDimension(),
						aspect: (_options_aspect = options.aspect) != null ? _options_aspect : 'all',
						baseMipLevel: (_options_baseMipLevel = options.baseMipLevel) != null ? _options_baseMipLevel : 0,
						mipLevelCount: (_options_mipLevelCount = options.mipLevelCount) != null ? _options_mipLevelCount : textureDescr.mipLevelCount,
						baseArrayLayer: (_options_baseArrayLayer = options.baseArrayLayer) != null ? _options_baseArrayLayer : 0,
						arrayLayerCount: (_options_arrayLayerCount = options.arrayLayerCount) != null ? _options_arrayLayerCount : textureDescr.depthOrArrayLayers
				};
				var view = this.gpuTexture.createView(desc);
				return view;
		}
		getSampler(device, sampleType) {
				var sampler = this.samplers[sampleType];
				if (!sampler) {
						var texture = this.texture;
						var desc = {
								addressModeU: gpuAddressModes[texture.addressU],
								addressModeV: gpuAddressModes[texture.addressV],
								addressModeW: gpuAddressModes[texture.addressW]
						};
						if (!sampleType && texture.compareOnRead) {
								sampleType = SAMPLETYPE_DEPTH;
						}
						if (sampleType === SAMPLETYPE_DEPTH || sampleType === SAMPLETYPE_INT || sampleType === SAMPLETYPE_UINT) {
								desc.compare = 'less';
								desc.magFilter = 'linear';
								desc.minFilter = 'linear';
						} else if (sampleType === SAMPLETYPE_UNFILTERABLE_FLOAT) {
								desc.magFilter = 'nearest';
								desc.minFilter = 'nearest';
								desc.mipmapFilter = 'nearest';
						} else {
								var forceNearest = !device.textureFloatFilterable && (texture.format === PIXELFORMAT_RGBA32F || texture.format === PIXELFORMAT_RGBA16F);
								if (forceNearest || this.texture.format === PIXELFORMAT_DEPTHSTENCIL || isIntegerPixelFormat(this.texture.format)) {
										desc.magFilter = 'nearest';
										desc.minFilter = 'nearest';
										desc.mipmapFilter = 'nearest';
								} else {
										desc.magFilter = gpuFilterModes[texture.magFilter].level;
										desc.minFilter = gpuFilterModes[texture.minFilter].level;
										desc.mipmapFilter = gpuFilterModes[texture.minFilter].mip;
								}
						}
						var allLinear = desc.minFilter === 'linear' && desc.magFilter === 'linear' && desc.mipmapFilter === 'linear';
						desc.maxAnisotropy = allLinear ? math.clamp(Math.round(texture._anisotropy), 1, device.maxTextureAnisotropy) : 1;
						sampler = device.wgpu.createSampler(desc);
						this.samplers[sampleType] = sampler;
				}
				return sampler;
		}
		loseContext() {}
		uploadImmediate(device, texture) {
				if (texture._needsUpload || texture._needsMipmapsUpload) {
						this.uploadData(device);
						texture._needsUpload = false;
						texture._needsMipmapsUpload = false;
				}
		}
		uploadData(device) {
				var texture = this.texture;
				if (texture._levels) {
						var anyUploads = false;
						var anyLevelMissing = false;
						var requiredMipLevels = texture.numLevels;
						for(var mipLevel = 0; mipLevel < requiredMipLevels; mipLevel++){
								var mipObject = texture._levels[mipLevel];
								if (mipObject) {
										if (texture.cubemap) {
												for(var face = 0; face < 6; face++){
														var faceSource = mipObject[face];
														if (faceSource) {
																if (this.isExternalImage(faceSource)) {
																		this.uploadExternalImage(device, faceSource, mipLevel, face);
																		anyUploads = true;
																} else if (ArrayBuffer.isView(faceSource)) {
																		this.uploadTypedArrayData(device, faceSource, mipLevel, face);
																		anyUploads = true;
																} else ;
														} else {
																anyLevelMissing = true;
														}
												}
										} else if (texture._volume) ; else if (texture.array) {
												if (texture.arrayLength === mipObject.length) {
														for(var index = 0; index < texture._arrayLength; index++){
																var arraySource = mipObject[index];
																if (this.isExternalImage(arraySource)) {
																		this.uploadExternalImage(device, arraySource, mipLevel, index);
																		anyUploads = true;
																} else if (ArrayBuffer.isView(arraySource)) {
																		this.uploadTypedArrayData(device, arraySource, mipLevel, index);
																		anyUploads = true;
																} else ;
														}
												} else {
														anyLevelMissing = true;
												}
										} else {
												if (this.isExternalImage(mipObject)) {
														this.uploadExternalImage(device, mipObject, mipLevel, 0);
														anyUploads = true;
												} else if (ArrayBuffer.isView(mipObject)) {
														this.uploadTypedArrayData(device, mipObject, mipLevel, 0);
														anyUploads = true;
												} else ;
										}
								} else {
										anyLevelMissing = true;
								}
						}
						if (anyUploads && anyLevelMissing && texture.mipmaps && !isCompressedPixelFormat(texture.format) && !isIntegerPixelFormat(texture.format)) {
								device.mipmapRenderer.generate(this);
						}
						if (texture._gpuSize) {
								texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
						}
						texture._gpuSize = texture.gpuSize;
						texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
				}
		}
		isExternalImage(image) {
				return image instanceof ImageBitmap || image instanceof HTMLVideoElement || image instanceof HTMLCanvasElement || image instanceof OffscreenCanvas;
		}
		uploadExternalImage(device, image, mipLevel, index) {
				var src = {
						source: image,
						origin: [
								0,
								0
						],
						flipY: false
				};
				var dst = {
						texture: this.gpuTexture,
						mipLevel: mipLevel,
						origin: [
								0,
								0,
								index
						],
						aspect: 'all'
				};
				var copySize = {
						width: this.desc.size.width,
						height: this.desc.size.height,
						depthOrArrayLayers: 1
				};
				device.submit();
				dummyUse(image instanceof HTMLCanvasElement && image.getContext('2d'));
				device.wgpu.queue.copyExternalImageToTexture(src, dst, copySize);
		}
		uploadTypedArrayData(device, data, mipLevel, index) {
				var texture = this.texture;
				var wgpu = device.wgpu;
				var dest = {
						texture: this.gpuTexture,
						origin: [
								0,
								0,
								index
						],
						mipLevel: mipLevel
				};
				var width = TextureUtils.calcLevelDimension(texture.width, mipLevel);
				var height = TextureUtils.calcLevelDimension(texture.height, mipLevel);
				TextureUtils.calcLevelGpuSize(width, height, 1, texture.format);
				var formatInfo = pixelFormatInfo.get(texture.format);
				var dataLayout;
				var size;
				if (formatInfo.size) {
						dataLayout = {
								offset: 0,
								bytesPerRow: formatInfo.size * width,
								rowsPerImage: height
						};
						size = {
								width: width,
								height: height
						};
				} else if (formatInfo.blockSize) {
						var blockDim = (size)=>{
								return Math.floor((size + 3) / 4);
						};
						dataLayout = {
								offset: 0,
								bytesPerRow: formatInfo.blockSize * blockDim(width),
								rowsPerImage: blockDim(height)
						};
						size = {
								width: Math.max(4, width),
								height: Math.max(4, height)
						};
				} else ;
				device.submit();
				wgpu.queue.writeTexture(dest, data, dataLayout, size);
		}
		read(x, y, width, height, options) {
				var _options_mipLevel;
				var mipLevel = (_options_mipLevel = options.mipLevel) != null ? _options_mipLevel : 0;
				var _options_face;
				var face = (_options_face = options.face) != null ? _options_face : 0;
				var _options_data;
				var data = (_options_data = options.data) != null ? _options_data : null;
				var _options_immediate;
				var immediate = (_options_immediate = options.immediate) != null ? _options_immediate : false;
				var texture = this.texture;
				var formatInfo = pixelFormatInfo.get(texture.format);
				var bytesPerRow = width * formatInfo.size;
				var paddedBytesPerRow = math.roundUp(bytesPerRow, 256);
				var size = paddedBytesPerRow * height;
				var device = texture.device;
				var stagingBuffer = device.createBufferImpl(BUFFERUSAGE_READ | BUFFERUSAGE_COPY_DST);
				stagingBuffer.allocate(device, size);
				var src = {
						texture: this.gpuTexture,
						mipLevel: mipLevel,
						origin: [
								x,
								y,
								face
						]
				};
				var dst = {
						buffer: stagingBuffer.buffer,
						offset: 0,
						bytesPerRow: paddedBytesPerRow
				};
				var copySize = {
						width,
						height,
						depthOrArrayLayers: 1
				};
				var commandEncoder = device.getCommandEncoder();
				commandEncoder.copyTextureToBuffer(src, dst, copySize);
				return device.readBuffer(stagingBuffer, size, null, immediate).then((temp)=>{
						data != null ? data : data = new Uint8Array(height * bytesPerRow);
						for(var i = 0; i < height; i++){
								var srcOffset = i * paddedBytesPerRow;
								var dstOffset = i * bytesPerRow;
								var sub = temp.subarray(srcOffset, srcOffset + bytesPerRow);
								data.set(sub, dstOffset);
						}
						return data;
				});
		}
		constructor(texture){
				this.samplers = [];
				this.texture = texture;
				this.format = gpuTextureFormats[texture.format];
				this.create(texture.device);
		}
}

class WebgpuUniformBuffer extends WebgpuBuffer {
		unlock(uniformBuffer) {
				var device = uniformBuffer.device;
				super.unlock(device, uniformBuffer.storageInt32.buffer);
		}
		constructor(uniformBuffer){
				super(BUFFERUSAGE_UNIFORM);
		}
}

class WebgpuVertexBuffer extends WebgpuBuffer {
		unlock(vertexBuffer) {
				var device = vertexBuffer.device;
				super.unlock(device, vertexBuffer.storage);
		}
		constructor(vertexBuffer, format, options){
				super(BUFFERUSAGE_VERTEX | ((options == null ? void 0 : options.storage) ? BUFFERUSAGE_STORAGE : 0));
		}
}

var KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g;
var DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;
var EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;
var UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;
var IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;
var ENDIF = /(endif|else|elif)(?:[ \t]+([^\r\n]*))?\r?\n?/g;
var IDENTIFIER$1 = /\{?[\w-]+\}?/;
var DEFINED = /(!|\s)?defined\(([\w-]+)\)/;
var COMPARISON = /([a-z_]\w*)\s*(==|!=|<|<=|>|>=)\s*([\w"']+)/i;
var INVALID = /[+\-]/g;
var INCLUDE = /include[ \t]+"([\w-]+)(?:\s*,\s*([\w-]+))?"\r?(?:\n|$)/g;
var LOOP_INDEX = /\{i\}/g;
var FRAGCOLOR = /(pcFragColor[1-8])\b/g;
class Preprocessor {
		static run(source, includes, options) {
				if (includes === void 0) includes = new Map();
				if (options === void 0) options = {};
				Preprocessor.sourceName = options.sourceName;
				source = this.stripComments(source);
				source = source.split(/\r?\n/).map((line)=>line.trimEnd()).join('\n');
				var defines = new Map();
				var injectDefines = new Map();
				source = this._preprocess(source, defines, injectDefines, includes, options.stripDefines);
				var intDefines = new Map();
				defines.forEach((value, key)=>{
						if (Number.isInteger(parseFloat(value)) && !value.includes('.')) {
								intDefines.set(key, value);
						}
				});
				source = this.stripComments(source);
				source = this.stripUnusedColorAttachments(source, options);
				source = this.RemoveEmptyLines(source);
				source = this.processArraySize(source, intDefines);
				source = this.injectDefines(source, injectDefines);
				return source;
		}
		static stripUnusedColorAttachments(source, options) {
				if (options.stripUnusedColorAttachments) {
						var counts = new Map();
						var matches = source.match(FRAGCOLOR);
						matches == null ? void 0 : matches.forEach((match)=>{
								var index = parseInt(match.charAt(match.length - 1), 10);
								var _counts_get;
								counts.set(index, ((_counts_get = counts.get(index)) != null ? _counts_get : 0) + 1);
						});
						var anySingleUse = Array.from(counts.values()).some((count)=>count === 1);
						if (anySingleUse) {
								var lines = source.split('\n');
								var keepLines = [];
								for(var i = 0; i < lines.length; i++){
										var match = lines[i].match(FRAGCOLOR);
										if (match) {
												var index = parseInt(match[0].charAt(match[0].length - 1), 10);
												if (index > 0 && counts.get(index) === 1) {
														continue;
												}
										}
										keepLines.push(lines[i]);
								}
								source = keepLines.join('\n');
						}
				}
				return source;
		}
		static stripComments(source) {
				return source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
		}
		static processArraySize(source, intDefines) {
				if (source !== null) {
						intDefines.forEach((value, key)=>{
								source = source.replace(new RegExp("\\[" + key + "\\]", 'g'), "[" + value + "]");
						});
				}
				return source;
		}
		static injectDefines(source, injectDefines) {
				if (source !== null && injectDefines.size > 0) {
						var lines = source.split('\n');
						injectDefines.forEach((value, key)=>{
								var regex = new RegExp(key, 'g');
								for(var i = 0; i < lines.length; i++){
										if (!lines[i].includes('#')) {
												lines[i] = lines[i].replace(regex, value);
										}
								}
						});
						source = lines.join('\n');
				}
				return source;
		}
		static RemoveEmptyLines(source) {
				if (source !== null) {
						source = source.split(/\r?\n/).map((line)=>line.trim() === '' ? '' : line).join('\n');
						source = source.replace(/(\n\n){3,}/g, '\n\n');
				}
				return source;
		}
		static _preprocess(source, defines, injectDefines, includes, stripDefines) {
				if (defines === void 0) defines = new Map();
				var originalSource = source;
				var stack = [];
				var error = false;
				var match;
				while((match = KEYWORD.exec(source)) !== null && !error){
						var keyword = match[1];
						switch(keyword){
								case 'define':
										{
												DEFINE.lastIndex = match.index;
												var define = DEFINE.exec(source);
												error || (error = define === null);
												var expression = define[1];
												IDENTIFIER$1.lastIndex = define.index;
												var identifierValue = IDENTIFIER$1.exec(expression);
												var identifier = identifierValue[0];
												var value = expression.substring(identifier.length).trim();
												if (value === '') value = 'true';
												var keep = Preprocessor._keep(stack);
												var stripThisDefine = stripDefines;
												if (keep) {
														var replacementDefine = identifier.startsWith('{') && identifier.endsWith('}');
														if (replacementDefine) {
																stripThisDefine = true;
														}
														if (replacementDefine) {
																injectDefines.set(identifier, value);
														} else {
																defines.set(identifier, value);
														}
														if (stripThisDefine) {
																source = source.substring(0, define.index - 1) + source.substring(DEFINE.lastIndex);
																KEYWORD.lastIndex = define.index - 1;
														}
												}
												if (!stripThisDefine) {
														KEYWORD.lastIndex = define.index + define[0].length;
												}
												break;
										}
								case 'undef':
										{
												UNDEF.lastIndex = match.index;
												var undef = UNDEF.exec(source);
												var identifier1 = undef[1].trim();
												var keep1 = Preprocessor._keep(stack);
												if (keep1) {
														defines.delete(identifier1);
														if (stripDefines) {
																source = source.substring(0, undef.index - 1) + source.substring(UNDEF.lastIndex);
																KEYWORD.lastIndex = undef.index - 1;
														}
												}
												if (!stripDefines) {
														KEYWORD.lastIndex = undef.index + undef[0].length;
												}
												break;
										}
								case 'extension':
										{
												EXTENSION.lastIndex = match.index;
												var extension = EXTENSION.exec(source);
												error || (error = extension === null);
												if (extension) {
														var identifier2 = extension[1];
														var keep2 = Preprocessor._keep(stack);
														if (keep2) {
																defines.set(identifier2, 'true');
														}
												}
												KEYWORD.lastIndex = extension.index + extension[0].length;
												break;
										}
								case 'ifdef':
								case 'ifndef':
								case 'if':
										{
												IF.lastIndex = match.index;
												var iff = IF.exec(source);
												var expression1 = iff[2];
												var evaluated = Preprocessor.evaluate(expression1, defines);
												error || (error = evaluated.error);
												var result = evaluated.result;
												if (keyword === 'ifndef') {
														result = !result;
												}
												stack.push({
														anyKeep: result,
														keep: result,
														start: match.index,
														end: IF.lastIndex
												});
												KEYWORD.lastIndex = iff.index + iff[0].length;
												break;
										}
								case 'endif':
								case 'else':
								case 'elif':
										{
												ENDIF.lastIndex = match.index;
												var endif = ENDIF.exec(source);
												var blockInfo = stack.pop();
												if (!blockInfo) {
														console.error('Shader preprocessing encountered "#' + endif[1] + '" without a preceding #if #ifdef #ifndef while preprocessing ' + Preprocessor.sourceName + " on line:\n " + source.substring(match.index, match.index + 100) + "...", {
																source: originalSource
														});
														error = true;
														continue;
												}
												var blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : '';
												source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
												KEYWORD.lastIndex = blockInfo.start + blockCode.length;
												var endifCommand = endif[1];
												if (endifCommand === 'else' || endifCommand === 'elif') {
														var result1 = false;
														if (!blockInfo.anyKeep) {
																if (endifCommand === 'else') {
																		result1 = !blockInfo.keep;
																} else {
																		var evaluated1 = Preprocessor.evaluate(endif[2], defines);
																		result1 = evaluated1.result;
																		error || (error = evaluated1.error);
																}
														}
														stack.push({
																anyKeep: blockInfo.anyKeep || result1,
																keep: result1,
																start: KEYWORD.lastIndex,
																end: KEYWORD.lastIndex
														});
												}
												break;
										}
								case 'include':
										{
												var _include_;
												INCLUDE.lastIndex = match.index;
												var include = INCLUDE.exec(source);
												error || (error = include === null);
												var identifier3 = include[1].trim();
												var countIdentifier = (_include_ = include[2]) == null ? void 0 : _include_.trim();
												var keep3 = Preprocessor._keep(stack);
												if (keep3) {
														var includeSource = includes == null ? void 0 : includes.get(identifier3);
														if (includeSource !== undefined) {
																includeSource = this.stripComments(includeSource);
																if (countIdentifier) {
																		var countString = defines.get(countIdentifier);
																		var count = parseFloat(countString);
																		if (Number.isInteger(count)) {
																				var result2 = '';
																				for(var i = 0; i < count; i++){
																						result2 += includeSource.replace(LOOP_INDEX, String(i));
																				}
																				includeSource = result2;
																		} else {
																				console.error('Include Count identifier "' + countIdentifier + '" not resolved while preprocessing ' + Preprocessor.sourceName + " on line:\n " + source.substring(match.index, match.index + 100) + "...", {
																						source: originalSource
																				});
																				error = true;
																		}
																}
																source = source.substring(0, include.index - 1) + includeSource + source.substring(INCLUDE.lastIndex);
																KEYWORD.lastIndex = include.index - 1;
														} else {
																console.error('Include "' + identifier3 + '" not resolved while preprocessing ' + Preprocessor.sourceName, {
																		source: originalSource
																});
																error = true;
																continue;
														}
												}
												break;
										}
						}
				}
				if (stack.length > 0) {
						console.error("Shader preprocessing reached the end of the file without encountering the necessary #endif to close a preceding #if, #ifdef, or #ifndef block. " + Preprocessor.sourceName);
						error = true;
				}
				if (error) {
						console.error('Failed to preprocess shader: ', {
								source: originalSource
						});
						return originalSource;
				}
				return source;
		}
		static _keep(stack) {
				for(var i = 0; i < stack.length; i++){
						if (!stack[i].keep) {
								return false;
						}
				}
				return true;
		}
		static evaluateAtomicExpression(expr, defines) {
				var error = false;
				expr = expr.trim();
				var invert = false;
				var definedMatch = DEFINED.exec(expr);
				if (definedMatch) {
						invert = definedMatch[1] === '!';
						expr = definedMatch[2].trim();
						var exists = defines.has(expr);
						return {
								result: invert ? !exists : exists,
								error
						};
				}
				var comparisonMatch = COMPARISON.exec(expr);
				if (comparisonMatch) {
						var _defines_get;
						var left = (_defines_get = defines.get(comparisonMatch[1].trim())) != null ? _defines_get : comparisonMatch[1].trim();
						var _defines_get1;
						var right = (_defines_get1 = defines.get(comparisonMatch[3].trim())) != null ? _defines_get1 : comparisonMatch[3].trim();
						var operator = comparisonMatch[2].trim();
						var result = false;
						switch(operator){
								case '==':
										result = left === right;
										break;
								case '!=':
										result = left !== right;
										break;
								case '<':
										result = left < right;
										break;
								case '<=':
										result = left <= right;
										break;
								case '>':
										result = left > right;
										break;
								case '>=':
										result = left >= right;
										break;
								default:
										error = true;
						}
						return {
								result,
								error
						};
				}
				var result1 = defines.has(expr);
				return {
						result: result1,
						error
				};
		}
		static evaluate(expression, defines) {
				var correct = INVALID.exec(expression) === null;
				var orSegments = expression.split('||');
				for (var orSegment of orSegments){
						var andSegments = orSegment.split('&&');
						var andResult = true;
						for (var andSegment of andSegments){
								var { result, error } = Preprocessor.evaluateAtomicExpression(andSegment.trim(), defines);
								if (!result || error) {
										andResult = false;
										break;
								}
						}
						if (andResult) {
								return {
										result: true,
										error: !correct
								};
						}
				}
				return {
						result: false,
						error: !correct
				};
		}
}

var gles3PS = "\n#ifndef outType_0\n#define outType_0 vec4\n#endif\nlayout(location = 0) out highp outType_0 pcFragColor0;\n#if COLOR_ATTACHMENT_1\nlayout(location = 1) out highp outType_1 pcFragColor1;\n#endif\n#if COLOR_ATTACHMENT_2\nlayout(location = 2) out highp outType_2 pcFragColor2;\n#endif\n#if COLOR_ATTACHMENT_3\nlayout(location = 3) out highp outType_3 pcFragColor3;\n#endif\n#if COLOR_ATTACHMENT_4\nlayout(location = 4) out highp outType_4 pcFragColor4;\n#endif\n#if COLOR_ATTACHMENT_5\nlayout(location = 5) out highp outType_5 pcFragColor5;\n#endif\n#if COLOR_ATTACHMENT_6\nlayout(location = 6) out highp outType_6 pcFragColor6;\n#endif\n#if COLOR_ATTACHMENT_7\nlayout(location = 7) out highp outType_7 pcFragColor7;\n#endif\n#define gl_FragColor pcFragColor0\n#define varying in\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLod textureLod\n#define texture2DProjLod textureProjLod\n#define textureCubeLod textureLod\n#define texture2DGrad textureGrad\n#define texture2DProjGrad textureProjGrad\n#define textureCubeGrad textureGrad\n#define utexture2D texture\n#define itexture2D texture\n#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead\n#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod\n#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead\n#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead\n#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead\n#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead\n#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2DShadow name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n#define GL2\n";

var gles3VS = "\n#define attribute in\n#define varying out\n#define texture2D texture\n#define utexture2D texture\n#define itexture2D texture\n#define GL2\n#define VERTEXSHADER\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n";

var webgpuPS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#ifndef outType_0\n#define outType_0 vec4\n#endif\n#ifndef outType_1\n#define outType_1 vec4\n#endif\n#ifndef outType_2\n#define outType_2 vec4\n#endif\n#ifndef outType_3\n#define outType_3 vec4\n#endif\n#ifndef outType_4\n#define outType_4 vec4\n#endif\n#ifndef outType_5\n#define outType_5 vec4\n#endif\n#ifndef outType_6\n#define outType_6 vec4\n#endif\n#ifndef outType_7\n#define outType_7 vec4\n#endif\nlayout(location = 0) out highp outType_0 pcFragColor0;\nlayout(location = 1) out highp outType_1 pcFragColor1;\nlayout(location = 2) out highp outType_2 pcFragColor2;\nlayout(location = 3) out highp outType_3 pcFragColor3;\nlayout(location = 4) out highp outType_4 pcFragColor4;\nlayout(location = 5) out highp outType_5 pcFragColor5;\nlayout(location = 6) out highp outType_6 pcFragColor6;\nlayout(location = 7) out highp outType_7 pcFragColor7;\n#define gl_FragColor pcFragColor0\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n#define texture2DLod(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)\n#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)\n#define textureCubeLod(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)\n#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead\n#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod\n#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead\n#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead\n#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead\n#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead\n#define SHADOWMAP_PASS(name) name, name ## _sampler\n#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n";

var webgpuVS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n#define VERTEXSHADER\n#define gl_VertexID gl_VertexIndex\n#define gl_InstanceID gl_InstanceIndex\n";

var wgslFS = "\n";

var wgslVS = "\n#define VERTEXSHADER\n";

var sharedGLSL = "\nvec2 getGrabScreenPos(vec4 clipPos) {\n	vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n	#ifdef WEBGPU\n		uv.y = 1.0 - uv.y;\n	#endif\n	return uv;\n}\nvec2 getImageEffectUV(vec2 uv) {\n	#ifdef WEBGPU\n		uv.y = 1.0 - uv.y;\n	#endif\n	return uv;\n}\n";

var sharedWGSL = "\nfn getGrabScreenPos(clipPos: vec4<f32>) -> vec2<f32> {\n	var uv: vec2<f32> = (clipPos.xy / clipPos.w) * 0.5 + vec2<f32>(0.5);\n	uv.y = 1.0 - uv.y;\n	return uv;\n}\nfn getImageEffectUV(uv: vec2<f32>) -> vec2<f32> {\n	var modifiedUV: vec2<f32> = uv;\n	modifiedUV.y = 1.0 - modifiedUV.y;\n	return modifiedUV;\n}\nstruct WrappedF32 { @size(16) element: f32 }\nstruct WrappedI32 { @size(16) element: i32 }\nstruct WrappedU32 { @size(16) element: u32 }\nstruct WrappedVec2F { @size(16) element: vec2f }\nstruct WrappedVec2I { @size(16) element: vec2i }\nstruct WrappedVec2U { @size(16) element: vec2u }\n";

var _attrib2Semantic = {
		vertex_position: SEMANTIC_POSITION,
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_texCoord2: SEMANTIC_TEXCOORD2,
		vertex_texCoord3: SEMANTIC_TEXCOORD3,
		vertex_texCoord4: SEMANTIC_TEXCOORD4,
		vertex_texCoord5: SEMANTIC_TEXCOORD5,
		vertex_texCoord6: SEMANTIC_TEXCOORD6,
		vertex_texCoord7: SEMANTIC_TEXCOORD7,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneIndices: SEMANTIC_BLENDINDICES,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT
};
class ShaderUtils {
		static createDefinition(device, options) {
				var getDefines = (gpu, gl2, isVertex, options)=>{
						var deviceIntro = device.isWebGPU ? gpu : gl2;
						var attachmentsDefine = '';
						if (!isVertex) {
								var _options_fragmentOutputTypes;
								var fragmentOutputTypes = (_options_fragmentOutputTypes = options.fragmentOutputTypes) != null ? _options_fragmentOutputTypes : 'vec4';
								if (!Array.isArray(fragmentOutputTypes)) {
										fragmentOutputTypes = [
												fragmentOutputTypes
										];
								}
								for(var i = 0; i < device.maxColorAttachments; i++){
										attachmentsDefine += "#define COLOR_ATTACHMENT_" + i + "\n";
										var _fragmentOutputTypes_i;
										var outType = (_fragmentOutputTypes_i = fragmentOutputTypes[i]) != null ? _fragmentOutputTypes_i : 'vec4';
										attachmentsDefine += "#define outType_" + i + " " + outType + "\n";
								}
						}
						return attachmentsDefine + deviceIntro;
				};
				var _options_name;
				var name = (_options_name = options.name) != null ? _options_name : 'Untitled';
				var vertCode;
				var fragCode;
				var vertexDefinesCode = ShaderUtils.getDefinesCode(device, options.vertexDefines);
				var fragmentDefinesCode = ShaderUtils.getDefinesCode(device, options.fragmentDefines);
				var wgsl = options.shaderLanguage === SHADERLANGUAGE_WGSL;
				if (wgsl) {
						vertCode = "\n                " + wgslVS + "\n                " + sharedWGSL + "\n                " + vertexDefinesCode + "\n                " + options.vertexCode + "\n            ";
						fragCode = "\n                " + wgslFS + "\n                " + sharedWGSL + "\n                " + fragmentDefinesCode + "\n                " + options.fragmentCode + "\n            ";
				} else {
						vertCode = ShaderUtils.versionCode(device) + getDefines(webgpuVS, gles3VS, true, options) + vertexDefinesCode + ShaderUtils.precisionCode(device) + "\n                " + sharedGLSL + "\n                " + ShaderUtils.getShaderNameCode(name) + "\n                " + options.vertexCode;
						fragCode = (options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + getDefines(webgpuPS, gles3PS, false, options) + fragmentDefinesCode + ShaderUtils.precisionCode(device) + "\n                " + sharedGLSL + "\n                " + ShaderUtils.getShaderNameCode(name) + "\n                " + (options.fragmentCode || ShaderUtils.dummyFragmentCode());
				}
				var _options_shaderLanguage;
				return {
						name: name,
						shaderLanguage: (_options_shaderLanguage = options.shaderLanguage) != null ? _options_shaderLanguage : SHADERLANGUAGE_GLSL,
						attributes: options.attributes,
						vshader: vertCode,
						vincludes: options.vertexIncludes,
						fincludes: options.fragmentIncludes,
						fshader: fragCode,
						useTransformFeedback: options.useTransformFeedback,
						meshUniformBufferFormat: options.meshUniformBufferFormat,
						meshBindGroupFormat: options.meshBindGroupFormat
				};
		}
		static getDefinesCode(device, defines) {
				var code = '';
				device.capsDefines.forEach((value, key)=>{
						code += "#define " + key + " " + value + "\n";
				});
				code += '\n';
				defines == null ? void 0 : defines.forEach((value, key)=>{
						code += "#define " + key + " " + value + "\n";
				});
				code += '\n';
				return code;
		}
		static getShaderNameCode(name) {
				return "#define SHADER_NAME " + name + "\n";
		}
		static dummyFragmentCode() {
				return 'void main(void) {gl_FragColor = vec4(0.0);}';
		}
		static versionCode(device) {
				return device.isWebGPU ? '#version 450\n' : '#version 300 es\n';
		}
		static precisionCode(device, forcePrecision) {
				if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {
						forcePrecision = null;
				}
				if (forcePrecision) {
						if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {
								forcePrecision = 'mediump';
						}
						if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {
								forcePrecision = 'lowp';
						}
				}
				var precision = forcePrecision ? forcePrecision : device.precision;
				var code = "\n            precision " + precision + " float;\n            precision " + precision + " int;\n            precision " + precision + " usampler2D;\n            precision " + precision + " isampler2D;\n            precision " + precision + " sampler2DShadow;\n            precision " + precision + " samplerCubeShadow;\n            precision " + precision + " sampler2DArray;\n        ";
				return code;
		}
		static collectAttributes(vsCode) {
				var attribs = {};
				var attrs = 0;
				var found = vsCode.indexOf('attribute');
				while(found >= 0){
						if (found > 0 && vsCode[found - 1] === '/') break;
						var ignore = false;
						if (found > 0) {
								var startOfLine = vsCode.lastIndexOf('\n', found);
								startOfLine = startOfLine !== -1 ? startOfLine + 1 : 0;
								var lineStartString = vsCode.substring(startOfLine, found);
								if (lineStartString.includes('#')) {
										ignore = true;
								}
						}
						if (!ignore) {
								var endOfLine = vsCode.indexOf(';', found);
								var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
								var attribName = vsCode.substring(startOfAttribName + 1, endOfLine);
								if (attribs[attribName]) ; else {
										var semantic = _attrib2Semantic[attribName];
										if (semantic !== undefined) {
												attribs[attribName] = semantic;
										} else {
												attribs[attribName] = "ATTR" + attrs;
												attrs++;
										}
								}
						}
						found = vsCode.indexOf('attribute', found + 1);
				}
				return attribs;
		}
}

var id$6 = 0;
class Shader {
		init() {
				this.ready = false;
				this.failed = false;
		}
		get label() {
				return "Shader Id " + this.id + " (" + (this.definition.shaderLanguage === SHADERLANGUAGE_WGSL ? 'WGSL' : 'GLSL') + ") " + this.name;
		}
		destroy() {
				this.device.onDestroyShader(this);
				this.impl.destroy(this);
		}
		loseContext() {
				this.init();
				this.impl.loseContext();
		}
		restoreContext() {
				this.impl.restoreContext(this.device, this);
		}
		constructor(graphicsDevice, definition){
				this.attributes = new Map();
				this.id = id$6++;
				this.device = graphicsDevice;
				this.definition = definition;
				this.name = definition.name || 'Untitled';
				this.init();
				if (definition.cshader) ; else {
						var wgsl = definition.shaderLanguage === SHADERLANGUAGE_WGSL;
						definition.vshader = Preprocessor.run(definition.vshader, definition.vincludes, {
								sourceName: "vertex shader for " + this.label,
								stripDefines: wgsl
						});
						if (definition.shaderLanguage === SHADERLANGUAGE_GLSL) {
								var _definition;
								var _attributes;
								(_attributes = (_definition = definition).attributes) != null ? _attributes : _definition.attributes = ShaderUtils.collectAttributes(definition.vshader);
						}
						var stripUnusedColorAttachments = graphicsDevice.isWebGL2 && (platform.name === 'osx' || platform.name === 'ios');
						definition.fshader = Preprocessor.run(definition.fshader, definition.fincludes, {
								stripUnusedColorAttachments,
								stripDefines: wgsl,
								sourceName: "fragment shader for " + this.label
						});
				}
				this.impl = graphicsDevice.createShaderImpl(this);
		}
}

class UsedBuffer {
}
class DynamicBufferAllocation {
}
class DynamicBuffers {
		destroy() {
				this.gpuBuffers.forEach((gpuBuffer)=>{
						gpuBuffer.destroy(this.device);
				});
				this.gpuBuffers = null;
				this.stagingBuffers.forEach((stagingBuffer)=>{
						stagingBuffer.destroy(this.device);
				});
				this.stagingBuffers = null;
				this.usedBuffers = null;
				this.activeBuffer = null;
		}
		alloc(allocation, size) {
				if (this.activeBuffer) {
						var alignedStart = math.roundUp(this.activeBuffer.size, this.bufferAlignment);
						var space = this.bufferSize - alignedStart;
						if (space < size) {
								this.scheduleSubmit();
						}
				}
				if (!this.activeBuffer) {
						var gpuBuffer = this.gpuBuffers.pop();
						if (!gpuBuffer) {
								gpuBuffer = this.createBuffer(this.device, this.bufferSize, false);
						}
						var stagingBuffer = this.stagingBuffers.pop();
						if (!stagingBuffer) {
								stagingBuffer = this.createBuffer(this.device, this.bufferSize, true);
						}
						this.activeBuffer = new UsedBuffer();
						this.activeBuffer.stagingBuffer = stagingBuffer;
						this.activeBuffer.gpuBuffer = gpuBuffer;
						this.activeBuffer.offset = 0;
						this.activeBuffer.size = 0;
				}
				var activeBuffer = this.activeBuffer;
				var alignedStart1 = math.roundUp(activeBuffer.size, this.bufferAlignment);
				allocation.gpuBuffer = activeBuffer.gpuBuffer;
				allocation.offset = alignedStart1;
				allocation.storage = activeBuffer.stagingBuffer.alloc(alignedStart1, size);
				activeBuffer.size = alignedStart1 + size;
		}
		scheduleSubmit() {
				if (this.activeBuffer) {
						this.usedBuffers.push(this.activeBuffer);
						this.activeBuffer = null;
				}
		}
		submit() {
				this.scheduleSubmit();
		}
		constructor(device, bufferSize, bufferAlignment){
				this.gpuBuffers = [];
				this.stagingBuffers = [];
				this.usedBuffers = [];
				this.activeBuffer = null;
				this.device = device;
				this.bufferSize = bufferSize;
				this.bufferAlignment = bufferAlignment;
		}
}

var _updateFunctions = [];
_updateFunctions[UNIFORMTYPE_FLOAT] = function(uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value;
};
_updateFunctions[UNIFORMTYPE_VEC2] = (uniformBuffer, value, offset)=>{
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
};
_updateFunctions[UNIFORMTYPE_VEC3] = (uniformBuffer, value, offset)=>{
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
};
_updateFunctions[UNIFORMTYPE_VEC4] = (uniformBuffer, value, offset)=>{
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
};
_updateFunctions[UNIFORMTYPE_INT] = function(uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value;
};
_updateFunctions[UNIFORMTYPE_IVEC2] = function(uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
};
_updateFunctions[UNIFORMTYPE_IVEC3] = function(uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
};
_updateFunctions[UNIFORMTYPE_IVEC4] = function(uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
};
_updateFunctions[UNIFORMTYPE_MAT2] = (uniformBuffer, value, offset)=>{
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 4] = value[2];
		dst[offset + 5] = value[3];
		dst[offset + 8] = value[4];
		dst[offset + 9] = value[5];
};
_updateFunctions[UNIFORMTYPE_MAT3] = (uniformBuffer, value, offset)=>{
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 4] = value[3];
		dst[offset + 5] = value[4];
		dst[offset + 6] = value[5];
		dst[offset + 8] = value[6];
		dst[offset + 9] = value[7];
		dst[offset + 10] = value[8];
};
_updateFunctions[UNIFORMTYPE_FLOATARRAY] = function(uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i];
		}
};
_updateFunctions[UNIFORMTYPE_VEC2ARRAY] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageFloat32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i * 2];
				dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
};
_updateFunctions[UNIFORMTYPE_VEC3ARRAY] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageFloat32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i * 3];
				dst[offset + i * 4 + 1] = value[i * 3 + 1];
				dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
};
_updateFunctions[UNIFORMTYPE_UINT] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value;
};
_updateFunctions[UNIFORMTYPE_UVEC2] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
};
_updateFunctions[UNIFORMTYPE_UVEC3] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
};
_updateFunctions[UNIFORMTYPE_UVEC4] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
};
_updateFunctions[UNIFORMTYPE_INTARRAY] = function(uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageInt32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i];
		}
};
_updateFunctions[UNIFORMTYPE_BOOLARRAY] = _updateFunctions[UNIFORMTYPE_INTARRAY];
_updateFunctions[UNIFORMTYPE_UINTARRAY] = function(uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i];
		}
};
_updateFunctions[UNIFORMTYPE_IVEC2ARRAY] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageInt32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i * 2];
				dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
};
_updateFunctions[UNIFORMTYPE_BVEC2ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC2ARRAY];
_updateFunctions[UNIFORMTYPE_UVEC2ARRAY] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageUint32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i * 2];
				dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
};
_updateFunctions[UNIFORMTYPE_IVEC3ARRAY] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageInt32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i * 3];
				dst[offset + i * 4 + 1] = value[i * 3 + 1];
				dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
};
_updateFunctions[UNIFORMTYPE_BVEC3ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC3ARRAY];
_updateFunctions[UNIFORMTYPE_UVEC3ARRAY] = (uniformBuffer, value, offset, count)=>{
		var dst = uniformBuffer.storageUint32;
		for(var i = 0; i < count; i++){
				dst[offset + i * 4] = value[i * 3];
				dst[offset + i * 4 + 1] = value[i * 3 + 1];
				dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
};
class UniformBuffer {
		destroy() {
				if (this.persistent) {
						var device = this.device;
						this.impl.destroy(device);
						device._vram.ub -= this.format.byteSize;
				}
		}
		get offset() {
				return this.persistent ? 0 : this.allocation.offset;
		}
		assignStorage(storage) {
				this.storageInt32 = storage;
				this.storageUint32 = new Uint32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
				this.storageFloat32 = new Float32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
		}
		loseContext() {
				var _this_impl;
				(_this_impl = this.impl) == null ? void 0 : _this_impl.loseContext();
		}
		setUniform(uniformFormat, value) {
				var offset = uniformFormat.offset;
				if (value !== null && value !== undefined) {
						var updateFunction = _updateFunctions[uniformFormat.updateType];
						if (updateFunction) {
								updateFunction(this, value, offset, uniformFormat.count);
						} else {
								this.storageFloat32.set(value, offset);
						}
				}
		}
		set(name, value) {
				var uniformFormat = this.format.map.get(name);
				if (uniformFormat) {
						this.setUniform(uniformFormat, value);
				}
		}
		startUpdate(dynamicBindGroup) {
				if (!this.persistent) {
						var allocation = this.allocation;
						var oldGpuBuffer = allocation.gpuBuffer;
						this.device.dynamicBuffers.alloc(allocation, this.format.byteSize);
						this.assignStorage(allocation.storage);
						if (dynamicBindGroup) {
								dynamicBindGroup.bindGroup = allocation.gpuBuffer.getBindGroup(this);
								dynamicBindGroup.offsets[0] = allocation.offset;
						}
						if (oldGpuBuffer !== allocation.gpuBuffer) {
								this.renderVersionDirty = this.device.renderVersion;
						}
				}
		}
		endUpdate() {
				if (this.persistent) {
						this.impl.unlock(this);
				} else {
						this.storageFloat32 = null;
						this.storageInt32 = null;
				}
		}
		update(dynamicBindGroup) {
				this.startUpdate(dynamicBindGroup);
				var uniforms = this.format.uniforms;
				for(var i = 0; i < uniforms.length; i++){
						var value = uniforms[i].scopeId.value;
						this.setUniform(uniforms[i], value);
				}
				this.endUpdate();
		}
		constructor(graphicsDevice, format, persistent = true){
				this.renderVersionDirty = 0;
				this.device = graphicsDevice;
				this.format = format;
				this.persistent = persistent;
				if (persistent) {
						this.impl = graphicsDevice.createUniformBufferImpl(this);
						var storage = new ArrayBuffer(format.byteSize);
						this.assignStorage(new Int32Array(storage));
						graphicsDevice._vram.ub += this.format.byteSize;
				} else {
						this.allocation = new DynamicBufferAllocation();
				}
		}
}

var primitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
};
class WebgpuClearRenderer {
		destroy() {
				this.shader.destroy();
				this.shader = null;
				this.uniformBuffer.destroy();
				this.uniformBuffer = null;
		}
		clear(device, renderTarget, options, defaultOptions) {
				options = options || defaultOptions;
				var _options_flags;
				var flags = (_options_flags = options.flags) != null ? _options_flags : defaultOptions.flags;
				if (flags !== 0) {
						var { uniformBuffer, dynamicBindGroup } = this;
						uniformBuffer.startUpdate(dynamicBindGroup);
						device.setBindGroup(BINDGROUP_MESH_UB, dynamicBindGroup.bindGroup, dynamicBindGroup.offsets);
						device.setBindGroup(BINDGROUP_MESH, device.emptyBindGroup);
						if (flags & CLEARFLAG_COLOR && (renderTarget.colorBuffer || renderTarget.impl.assignedColorTexture)) {
								var _options_color;
								var color = (_options_color = options.color) != null ? _options_color : defaultOptions.color;
								this.colorData.set(color);
								device.setBlendState(BlendState.NOBLEND);
						} else {
								device.setBlendState(BlendState.NOWRITE);
						}
						uniformBuffer.set('color', this.colorData);
						if (flags & CLEARFLAG_DEPTH && renderTarget.depth) {
								var _options_depth;
								var depth = (_options_depth = options.depth) != null ? _options_depth : defaultOptions.depth;
								uniformBuffer.set('depth', depth);
								device.setDepthState(DepthState.WRITEDEPTH);
						} else {
								uniformBuffer.set('depth', 1);
								device.setDepthState(DepthState.NODEPTH);
						}
						if (flags & CLEARFLAG_STENCIL && renderTarget.stencil) ;
						uniformBuffer.endUpdate();
						device.setCullMode(CULLFACE_NONE);
						device.setShader(this.shader);
						device.draw(primitive);
				}
		}
		constructor(device){
				var code = "\n\n            struct ub_mesh {\n                color : vec4f,\n                depth: f32\n            }\n\n            @group(2) @binding(0) var<uniform> ubMesh : ub_mesh;\n\n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0),\n                vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f\n            }\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                var output : VertexOutput;\n                output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);\n                return output;\n            }\n\n            @fragment\n            fn fragmentMain() -> @location(0) vec4f {\n                return ubMesh.color;\n            }\n        ";
				this.shader = new Shader(device, {
						name: 'WebGPUClearRendererShader',
						shaderLanguage: SHADERLANGUAGE_WGSL,
						vshader: code,
						fshader: code
				});
				this.uniformBuffer = new UniformBuffer(device, new UniformBufferFormat(device, [
						new UniformFormat('color', UNIFORMTYPE_VEC4),
						new UniformFormat('depth', UNIFORMTYPE_FLOAT)
				]), false);
				this.dynamicBindGroup = new DynamicBindGroup();
				this.colorData = new Float32Array(4);
		}
}

class WebgpuMipmapRenderer {
		destroy() {
				this.shader.destroy();
				this.shader = null;
		}
		generate(webgpuTexture) {
				var textureDescr = webgpuTexture.desc;
				if (textureDescr.mipLevelCount <= 1) {
						return;
				}
				if (webgpuTexture.texture.volume) {
						return;
				}
				var device = this.device;
				var wgpu = device.wgpu;
				var webgpuShader = this.shader.impl;
				var pipeline = wgpu.createRenderPipeline({
						layout: 'auto',
						vertex: {
								module: webgpuShader.getVertexShaderModule(),
								entryPoint: webgpuShader.vertexEntryPoint
						},
						fragment: {
								module: webgpuShader.getFragmentShaderModule(),
								entryPoint: webgpuShader.fragmentEntryPoint,
								targets: [
										{
												format: textureDescr.format
										}
								]
						},
						primitive: {
								topology: 'triangle-strip'
						}
				});
				var texture = webgpuTexture.texture;
				var numFaces = texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1;
				var srcViews = [];
				for(var face = 0; face < numFaces; face++){
						srcViews.push(webgpuTexture.createView({
								dimension: '2d',
								baseMipLevel: 0,
								mipLevelCount: 1,
								baseArrayLayer: face
						}));
				}
				var commandEncoder = device.getCommandEncoder();
				for(var i = 1; i < textureDescr.mipLevelCount; i++){
						for(var face1 = 0; face1 < numFaces; face1++){
								var dstView = webgpuTexture.createView({
										dimension: '2d',
										baseMipLevel: i,
										mipLevelCount: 1,
										baseArrayLayer: face1
								});
								var passEncoder = commandEncoder.beginRenderPass({
										colorAttachments: [
												{
														view: dstView,
														loadOp: 'clear',
														storeOp: 'store'
												}
										]
								});
								var bindGroup = wgpu.createBindGroup({
										layout: pipeline.getBindGroupLayout(0),
										entries: [
												{
														binding: 0,
														resource: this.minSampler
												},
												{
														binding: 1,
														resource: srcViews[face1]
												}
										]
								});
								passEncoder.setPipeline(pipeline);
								passEncoder.setBindGroup(0, bindGroup);
								passEncoder.draw(4);
								passEncoder.end();
								srcViews[face1] = dstView;
						}
				}
				device.pipeline = null;
		}
		constructor(device){
				this.device = device;
				var code = "\n \n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0),\n                vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f,\n                @location(0) texCoord : vec2f\n            };\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\n              output.position = vec4f(pos[vertexIndex], 0, 1);\n              return output;\n            }\n\n            @group(0) @binding(0) var imgSampler : sampler;\n            @group(0) @binding(1) var img : texture_2d<f32>;\n\n            @fragment\n            fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\n              return textureSample(img, imgSampler, texCoord);\n            }\n        ";
				this.shader = new Shader(device, {
						name: 'WebGPUMipmapRendererShader',
						shaderLanguage: SHADERLANGUAGE_WGSL,
						vshader: code,
						fshader: code
				});
				this.minSampler = device.wgpu.createSampler({
						minFilter: 'linear'
				});
		}
}

class DynamicBuffer {
		getBindGroup(ub) {
				var ubSize = ub.format.byteSize;
				var bindGroup = this.bindGroupCache.get(ubSize);
				if (!bindGroup) {
						bindGroup = new BindGroup(this.device, this.bindGroupFormat, ub);
						bindGroup.update();
						this.bindGroupCache.set(ubSize, bindGroup);
				}
				return bindGroup;
		}
		constructor(device){
				this.bindGroupCache = new Map();
				this.device = device;
				this.bindGroupFormat = new BindGroupFormat(this.device, [
						new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)
				]);
		}
}

class WebgpuDynamicBuffer extends DynamicBuffer {
		destroy(device) {
				device._vram.ub -= this.buffer.size;
				this.buffer.destroy();
				this.buffer = null;
		}
		onAvailable() {
				this.mappedRange = this.buffer.getMappedRange();
		}
		alloc(offset, size) {
				return new Int32Array(this.mappedRange, offset, size / 4);
		}
		constructor(device, size, isStaging){
				super(device), this.buffer = null, this.mappedRange = null;
				this.buffer = device.wgpu.createBuffer({
						size: size,
						usage: isStaging ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
						mappedAtCreation: isStaging
				});
				if (isStaging) {
						this.onAvailable();
				}
				device._vram.ub += size;
		}
}

class WebgpuDynamicBuffers extends DynamicBuffers {
		createBuffer(device, size, isStaging) {
				return new WebgpuDynamicBuffer(device, size, isStaging);
		}
		submit() {
				super.submit();
				var count = this.usedBuffers.length;
				if (count) {
						var device = this.device;
						var gpuBuffers = this.gpuBuffers;
						var commandEncoder = device.wgpu.createCommandEncoder();
						for(var i = count - 1; i >= 0; i--){
								var usedBuffer = this.usedBuffers[i];
								var { stagingBuffer, gpuBuffer, offset, size } = usedBuffer;
								var src = stagingBuffer.buffer;
								src.unmap();
								commandEncoder.copyBufferToBuffer(src, offset, gpuBuffer.buffer, offset, size);
								gpuBuffers.push(gpuBuffer);
						}
						var cb = commandEncoder.finish();
						device.addCommandBuffer(cb, true);
						for(var i1 = 0; i1 < count; i1++){
								var stagingBuffer1 = this.usedBuffers[i1].stagingBuffer;
								this.pendingStagingBuffers.push(stagingBuffer1);
						}
						this.usedBuffers.length = 0;
				}
		}
		onCommandBuffersSubmitted() {
				var count = this.pendingStagingBuffers.length;
				if (count) {
						var _this, _loop = function(i) {
								var stagingBuffer = _this.pendingStagingBuffers[i];
								stagingBuffer.buffer.mapAsync(GPUMapMode.WRITE).then(()=>{
										if (_this.stagingBuffers) {
												stagingBuffer.onAvailable();
												_this.stagingBuffers.push(stagingBuffer);
										}
								});
						};
						for(var i = 0; i < count; i++)_this = this, _loop(i);
						this.pendingStagingBuffers.length = 0;
				}
		}
		constructor(...args){
				super(...args), this.pendingStagingBuffers = [];
		}
}

class GpuProfiler {
		loseContext() {
				this.pastFrameAllocations.clear();
		}
		set enabled(value) {
				this._enableRequest = value;
		}
		get enabled() {
				return this._enableRequest;
		}
		processEnableRequest() {
				if (this._enableRequest !== this._enabled) {
						this._enabled = this._enableRequest;
						if (!this._enabled) {
								this._frameTime = 0;
						}
				}
		}
		request(renderVersion) {
				this.pastFrameAllocations.set(renderVersion, this.frameAllocations);
				this.frameAllocations = [];
		}
		report(renderVersion, timings) {
				if (timings) {
						var allocations = this.pastFrameAllocations.get(renderVersion);
						if (timings.length > 0) {
								this._frameTime = timings[0];
						}
						if (Tracing.get(TRACEID_GPU_TIMINGS)) {
								var total = 0;
								for(var i = 0; i < allocations.length; ++i){
										allocations[i];
										total += timings[i];
								}
						}
				}
				this.pastFrameAllocations.delete(renderVersion);
		}
		getSlot(name) {
				var slot = this.frameAllocations.length;
				this.frameAllocations.push(name);
				return slot;
		}
		get slotCount() {
				return this.frameAllocations.length;
		}
		constructor(){
				this.frameAllocations = [];
				this.pastFrameAllocations = new Map();
				this._enabled = false;
				this._enableRequest = false;
				this._frameTime = 0;
		}
}

class WebgpuQuerySet {
		destroy() {
				var _this_querySet, _this_queryBuffer;
				(_this_querySet = this.querySet) == null ? void 0 : _this_querySet.destroy();
				this.querySet = null;
				(_this_queryBuffer = this.queryBuffer) == null ? void 0 : _this_queryBuffer.destroy();
				this.queryBuffer = null;
				this.activeStagingBuffer = null;
				this.stagingBuffers.forEach((stagingBuffer)=>{
						stagingBuffer.destroy();
				});
				this.stagingBuffers = null;
		}
		getStagingBuffer() {
				var stagingBuffer = this.stagingBuffers.pop();
				if (!stagingBuffer) {
						stagingBuffer = this.device.wgpu.createBuffer({
								size: this.queryBuffer.size,
								usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
						});
				}
				return stagingBuffer;
		}
		resolve(count) {
				var device = this.device;
				var commandEncoder = device.getCommandEncoder();
				commandEncoder.resolveQuerySet(this.querySet, 0, count, this.queryBuffer, 0);
				var activeStagingBuffer = this.getStagingBuffer();
				this.activeStagingBuffer = activeStagingBuffer;
				commandEncoder.copyBufferToBuffer(this.queryBuffer, 0, activeStagingBuffer, 0, this.bytesPerSlot * count);
		}
		request(count, renderVersion) {
				var stagingBuffer = this.activeStagingBuffer;
				this.activeStagingBuffer = null;
				return stagingBuffer.mapAsync(GPUMapMode.READ).then(()=>{
						var _this_stagingBuffers;
						var srcTimings = new BigInt64Array(stagingBuffer.getMappedRange());
						var timings = [];
						for(var i = 0; i < count; i++){
								timings.push(Number(srcTimings[i * 2 + 1] - srcTimings[i * 2]) * 0.000001);
						}
						stagingBuffer.unmap();
						(_this_stagingBuffers = this.stagingBuffers) == null ? void 0 : _this_stagingBuffers.push(stagingBuffer);
						return {
								renderVersion,
								timings
						};
				});
		}
		constructor(device, isTimestamp, capacity){
				this.stagingBuffers = [];
				this.activeStagingBuffer = null;
				this.device = device;
				this.capacity = capacity;
				this.bytesPerSlot = isTimestamp ? 8 : 4;
				var wgpu = device.wgpu;
				this.querySet = wgpu.createQuerySet({
						type: isTimestamp ? 'timestamp' : 'occlusion',
						count: capacity
				});
				this.queryBuffer = wgpu.createBuffer({
						size: this.bytesPerSlot * capacity,
						usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
				});
		}
}

class WebgpuGpuProfiler extends GpuProfiler {
		destroy() {
				var _this_timestampQueriesSet;
				(_this_timestampQueriesSet = this.timestampQueriesSet) == null ? void 0 : _this_timestampQueriesSet.destroy();
				this.timestampQueriesSet = null;
		}
		frameStart() {
				this.processEnableRequest();
		}
		frameEnd() {
				if (this._enabled) {
						var _this_timestampQueriesSet;
						(_this_timestampQueriesSet = this.timestampQueriesSet) == null ? void 0 : _this_timestampQueriesSet.resolve(this.slotCount * 2);
				}
		}
		request() {
				if (this._enabled) {
						var _this_timestampQueriesSet;
						var renderVersion = this.device.renderVersion;
						(_this_timestampQueriesSet = this.timestampQueriesSet) == null ? void 0 : _this_timestampQueriesSet.request(this.slotCount, renderVersion).then((results)=>{
								this.report(results.renderVersion, results.timings);
						});
						super.request(renderVersion);
				}
		}
		constructor(device){
				super();
				this.device = device;
				this.timestampQueriesSet = device.supportsTimestampQuery ? new WebgpuQuerySet(device, true, 512) : null;
		}
}

class WebgpuResolver {
		destroy() {
				this.shader.destroy();
				this.shader = null;
				this.pipelineCache = null;
		}
		getPipeline(format) {
				var pipeline = this.pipelineCache.get(format);
				if (!pipeline) {
						pipeline = this.createPipeline(format);
						this.pipelineCache.set(format, pipeline);
				}
				return pipeline;
		}
		createPipeline(format) {
				var webgpuShader = this.shader.impl;
				var pipeline = this.device.wgpu.createRenderPipeline({
						layout: 'auto',
						vertex: {
								module: webgpuShader.getVertexShaderModule(),
								entryPoint: webgpuShader.vertexEntryPoint
						},
						fragment: {
								module: webgpuShader.getFragmentShaderModule(),
								entryPoint: webgpuShader.fragmentEntryPoint,
								targets: [
										{
												format: format
										}
								]
						},
						primitive: {
								topology: 'triangle-strip'
						}
				});
				return pipeline;
		}
		resolveDepth(commandEncoder, sourceTexture, destinationTexture) {
				var device = this.device;
				var wgpu = device.wgpu;
				var pipeline = this.getPipeline(destinationTexture.format);
				var numFaces = sourceTexture.depthOrArrayLayers;
				for(var face = 0; face < numFaces; face++){
						var srcView = sourceTexture.createView({
								dimension: '2d',
								aspect: 'depth-only',
								baseMipLevel: 0,
								mipLevelCount: 1,
								baseArrayLayer: face
						});
						var dstView = destinationTexture.createView({
								dimension: '2d',
								baseMipLevel: 0,
								mipLevelCount: 1,
								baseArrayLayer: face
						});
						var passEncoder = commandEncoder.beginRenderPass({
								colorAttachments: [
										{
												view: dstView,
												loadOp: 'clear',
												storeOp: 'store'
										}
								]
						});
						var bindGroup = wgpu.createBindGroup({
								layout: pipeline.getBindGroupLayout(0),
								entries: [
										{
												binding: 0,
												resource: srcView
										}
								]
						});
						passEncoder.setPipeline(pipeline);
						passEncoder.setBindGroup(0, bindGroup);
						passEncoder.draw(4);
						passEncoder.end();
				}
				device.pipeline = null;
		}
		constructor(device){
				this.pipelineCache = new Map();
				this.device = device;
				var code = "\n \n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f,\n            };\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.position = vec4f(pos[vertexIndex], 0, 1);\n              return output;\n            }\n\n            @group(0) @binding(0) var img : texture_depth_multisampled_2d;\n\n            @fragment\n            fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {\n                // load th depth value from sample index 0\n                var depth = textureLoad(img, vec2i(fragColor.xy), 0u);\n                return vec4f(depth, 0.0, 0.0, 0.0);\n            }\n        ";
				this.shader = new Shader(device, {
						name: 'WebGPUResolverDepthShader',
						shaderLanguage: SHADERLANGUAGE_WGSL,
						vshader: code,
						fshader: code
				});
		}
}

class WebgpuCompute {
		destroy() {
				this.uniformBuffers.forEach((ub)=>ub.destroy());
				this.uniformBuffers.length = 0;
				this.bindGroup.destroy();
				this.bindGroup = null;
		}
		updateBindGroup() {
				var { bindGroup } = this;
				bindGroup.updateUniformBuffers();
				bindGroup.update();
		}
		dispatch(x, y, z) {
				var device = this.compute.device;
				device.setBindGroup(0, this.bindGroup);
				var passEncoder = device.passEncoder;
				passEncoder.setPipeline(this.pipeline);
				passEncoder.dispatchWorkgroups(x, y, z);
		}
		constructor(compute){
				this.uniformBuffers = [];
				this.bindGroup = null;
				this.compute = compute;
				var { device, shader } = compute;
				var { computeBindGroupFormat, computeUniformBufferFormats } = shader.impl;
				this.bindGroup = new BindGroup(device, computeBindGroupFormat);
				if (computeUniformBufferFormats) {
						for(var name in computeUniformBufferFormats){
								if (computeUniformBufferFormats.hasOwnProperty(name)) {
										var ub = new UniformBuffer(device, computeUniformBufferFormats[name], true);
										this.uniformBuffers.push(ub);
										this.bindGroup.setUniformBuffer(name, ub);
								}
						}
				}
				this.pipeline = device.computePipeline.get(shader, computeBindGroupFormat);
		}
}

function asyncGeneratorStep$5(gen, resolve, reject, _next, _throw, key, arg) {
		try {
				var info = gen[key](arg);
				var value = info.value;
		} catch (error) {
				reject(error);
				return;
		}
		if (info.done) {
				resolve(value);
		} else {
				Promise.resolve(value).then(_next, _throw);
		}
}
function _async_to_generator$5(fn) {
		return function() {
				var self = this, args = arguments;
				return new Promise(function(resolve, reject) {
						var gen = fn.apply(self, args);
						function _next(value) {
								asyncGeneratorStep$5(gen, resolve, reject, _next, _throw, "next", value);
						}
						function _throw(err) {
								asyncGeneratorStep$5(gen, resolve, reject, _next, _throw, "throw", err);
						}
						_next(undefined);
				});
		};
}
var _uniqueLocations = new Map();
class WebgpuGraphicsDevice extends GraphicsDevice {
		destroy() {
				this.clearRenderer.destroy();
				this.clearRenderer = null;
				this.mipmapRenderer.destroy();
				this.mipmapRenderer = null;
				this.resolver.destroy();
				this.resolver = null;
				super.destroy();
		}
		initDeviceCaps() {
				var _this_wgpu;
				var limits = (_this_wgpu = this.wgpu) == null ? void 0 : _this_wgpu.limits;
				this.limits = limits;
				this.precision = 'highp';
				this.maxPrecision = 'highp';
				this.maxSamples = 4;
				this.maxTextures = 16;
				this.maxTextureSize = limits.maxTextureDimension2D;
				this.maxCubeMapSize = limits.maxTextureDimension2D;
				this.maxVolumeSize = limits.maxTextureDimension3D;
				this.maxColorAttachments = limits.maxColorAttachments;
				this.maxPixelRatio = 1;
				this.maxAnisotropy = 16;
				this.fragmentUniformsCount = limits.maxUniformBufferBindingSize / 16;
				this.vertexUniformsCount = limits.maxUniformBufferBindingSize / 16;
				this.supportsUniformBuffers = true;
				this.supportsAreaLights = true;
				this.supportsGpuParticles = true;
				this.supportsCompute = true;
				this.textureFloatRenderable = true;
				this.textureHalfFloatRenderable = true;
				this.supportsImageBitmap = true;
				this.samples = this.backBufferAntialias ? 4 : 1;
				var wgslFeatures = navigator.gpu.wgslLanguageFeatures;
				this.supportsStorageTextureRead = wgslFeatures == null ? void 0 : wgslFeatures.has('readonly_and_readwrite_storage_textures');
				this.initCapsDefines();
		}
		initWebGpu(glslangUrl, twgslUrl) {
				var _this = this;
				return _async_to_generator$5(function*() {
						if (!window.navigator.gpu) {
								throw new Error('Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.');
						}
						var buildUrl = (srcPath)=>{
								return new URL(srcPath, window.location.href).toString();
						};
						var results = yield Promise.all([
								import(/* @vite-ignore */ /* webpackIgnore: true */ "" + buildUrl(twgslUrl)).then((module)=>twgsl(twgslUrl.replace('.js', '.wasm'))),
								import(/* @vite-ignore */ /* webpackIgnore: true */ "" + buildUrl(glslangUrl)).then((module)=>module.default())
						]);
						_this.twgsl = results[0];
						_this.glslang = results[1];
						return _this.createDevice();
				})();
		}
		createDevice() {
				var _this = this;
				return _async_to_generator$5(function*() {
						var _this_gpuAdapter, _this_wgpu_lost;
						var adapterOptions = {
								powerPreference: _this.initOptions.powerPreference !== 'default' ? _this.initOptions.powerPreference : undefined
						};
						_this.gpuAdapter = yield window.navigator.gpu.requestAdapter(adapterOptions);
						var requiredFeatures = [];
						var requireFeature = (feature)=>{
								var supported = _this.gpuAdapter.features.has(feature);
								if (supported) {
										requiredFeatures.push(feature);
								}
								return supported;
						};
						_this.textureFloatFilterable = requireFeature('float32-filterable');
						_this.textureFloatBlendable = requireFeature('float32-blendable');
						_this.extCompressedTextureS3TC = requireFeature('texture-compression-bc');
						_this.extCompressedTextureETC = requireFeature('texture-compression-etc2');
						_this.extCompressedTextureASTC = requireFeature('texture-compression-astc');
						_this.supportsTimestampQuery = requireFeature('timestamp-query');
						_this.supportsDepthClip = requireFeature('depth-clip-control');
						_this.supportsDepth32Stencil = requireFeature('depth32float-stencil8');
						_this.supportsIndirectFirstInstance = requireFeature('indirect-first-instance');
						_this.supportsShaderF16 = requireFeature('shader-f16');
						_this.supportsStorageRGBA8 = requireFeature('bgra8unorm-storage');
						_this.textureRG11B10Renderable = requireFeature('rg11b10ufloat-renderable');
						_this.supportsClipDistances = requireFeature('clip-distances');
						var adapterLimits = (_this_gpuAdapter = _this.gpuAdapter) == null ? void 0 : _this_gpuAdapter.limits;
						var requiredLimits = {};
						if (adapterLimits) {
								for(var limitName in adapterLimits){
										if (limitName === 'minSubgroupSize' || limitName === 'maxSubgroupSize') {
												continue;
										}
										requiredLimits[limitName] = adapterLimits[limitName];
								}
						}
						var deviceDescr = {
								requiredFeatures,
								requiredLimits,
								defaultQueue: {
										label: 'Default Queue'
								}
						};
						_this.wgpu = yield _this.gpuAdapter.requestDevice(deviceDescr);
						(_this_wgpu_lost = _this.wgpu.lost) == null ? void 0 : _this_wgpu_lost.then(_this.handleDeviceLost.bind(_this));
						_this.initDeviceCaps();
						_this.gpuContext = _this.canvas.getContext('webgpu');
						var canvasToneMapping = 'standard';
						var preferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat();
						var displayFormat = _this.initOptions.displayFormat;
						_this.backBufferFormat = preferredCanvasFormat === 'rgba8unorm' ? displayFormat === DISPLAYFORMAT_LDR_SRGB ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8 : displayFormat === DISPLAYFORMAT_LDR_SRGB ? PIXELFORMAT_SBGRA8 : PIXELFORMAT_BGRA8;
						_this.backBufferViewFormat = displayFormat === DISPLAYFORMAT_LDR_SRGB ? "" + preferredCanvasFormat + "-srgb" : preferredCanvasFormat;
						if (displayFormat === DISPLAYFORMAT_HDR && _this.textureFloatFilterable) {
								var hdrMediaQuery = window.matchMedia('(dynamic-range: high)');
								if (hdrMediaQuery == null ? void 0 : hdrMediaQuery.matches) {
										_this.backBufferFormat = PIXELFORMAT_RGBA16F;
										_this.backBufferViewFormat = 'rgba16float';
										preferredCanvasFormat = 'rgba16float';
										_this.isHdr = true;
										canvasToneMapping = 'extended';
								}
						}
						_this.canvasConfig = {
								device: _this.wgpu,
								colorSpace: 'srgb',
								alphaMode: _this.initOptions.alpha ? 'premultiplied' : 'opaque',
								format: preferredCanvasFormat,
								toneMapping: {
										mode: canvasToneMapping
								},
								usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,
								viewFormats: displayFormat === DISPLAYFORMAT_LDR_SRGB ? [
										_this.backBufferViewFormat
								] : []
						};
						_this.gpuContext.configure(_this.canvasConfig);
						_this.createBackbuffer();
						_this.clearRenderer = new WebgpuClearRenderer(_this);
						_this.mipmapRenderer = new WebgpuMipmapRenderer(_this);
						_this.resolver = new WebgpuResolver(_this);
						_this.postInit();
						return _this;
				})();
		}
		handleDeviceLost(info) {
				var _this = this, _superprop_get_loseContext = ()=>super.loseContext, _superprop_get_restoreContext = ()=>super.restoreContext;
				return _async_to_generator$5(function*() {
						if (info.reason !== 'destroyed') {
								_superprop_get_loseContext().call(_this);
								yield _this.createDevice();
								_superprop_get_restoreContext().call(_this);
						}
				})();
		}
		postInit() {
				super.postInit();
				this.initializeRenderState();
				this.setupPassEncoderDefaults();
				this.gpuProfiler = new WebgpuGpuProfiler(this);
				this.dynamicBuffers = new WebgpuDynamicBuffers(this, 100 * 1024, this.limits.minUniformBufferOffsetAlignment);
				this.emptyBindGroup = new BindGroup(this, new BindGroupFormat(this, []));
				this.emptyBindGroup.update();
		}
		createBackbuffer() {
				this.supportsStencil = this.initOptions.stencil;
				this.backBuffer = new RenderTarget({
						name: 'WebgpuFramebuffer',
						graphicsDevice: this,
						depth: this.initOptions.depth,
						stencil: this.supportsStencil,
						samples: this.samples
				});
				this.backBuffer.impl.isBackbuffer = true;
		}
		frameStart() {
				super.frameStart();
				this.gpuProfiler.frameStart();
				this.submit();
				var outColorBuffer = this.gpuContext.getCurrentTexture();
				if (this.backBufferSize.x !== outColorBuffer.width || this.backBufferSize.y !== outColorBuffer.height) {
						this.backBufferSize.set(outColorBuffer.width, outColorBuffer.height);
						this.backBuffer.destroy();
						this.backBuffer = null;
						this.createBackbuffer();
				}
				var rt = this.backBuffer;
				var wrt = rt.impl;
				wrt.setColorAttachment(0, undefined, this.backBufferViewFormat);
				this.initRenderTarget(rt);
				wrt.assignColorTexture(this, outColorBuffer);
		}
		frameEnd() {
				super.frameEnd();
				this.gpuProfiler.frameEnd();
				this.submit();
				if (!this.contextLost) {
						this.gpuProfiler.request();
				}
		}
		createBufferImpl(usageFlags) {
				return new WebgpuBuffer(usageFlags);
		}
		createUniformBufferImpl(uniformBuffer) {
				return new WebgpuUniformBuffer(uniformBuffer);
		}
		createVertexBufferImpl(vertexBuffer, format, options) {
				return new WebgpuVertexBuffer(vertexBuffer, format, options);
		}
		createIndexBufferImpl(indexBuffer, options) {
				return new WebgpuIndexBuffer(indexBuffer, options);
		}
		createShaderImpl(shader) {
				return new WebgpuShader(shader);
		}
		createTextureImpl(texture) {
				return new WebgpuTexture(texture);
		}
		createRenderTargetImpl(renderTarget) {
				return new WebgpuRenderTarget(renderTarget);
		}
		createBindGroupFormatImpl(bindGroupFormat) {
				return new WebgpuBindGroupFormat(bindGroupFormat);
		}
		createBindGroupImpl(bindGroup) {
				return new WebgpuBindGroup();
		}
		createComputeImpl(compute) {
				return new WebgpuCompute(compute);
		}
		setBindGroup(index, bindGroup, offsets) {
				if (this.passEncoder) {
						this.passEncoder.setBindGroup(index, bindGroup.impl.bindGroup, offsets != null ? offsets : bindGroup.uniformBufferOffsets);
						this.bindGroupFormats[index] = bindGroup.format.impl;
				}
		}
		submitVertexBuffer(vertexBuffer, slot) {
				var format = vertexBuffer.format;
				var { interleaved, elements } = format;
				var elementCount = elements.length;
				var vbBuffer = vertexBuffer.impl.buffer;
				if (interleaved) {
						this.passEncoder.setVertexBuffer(slot, vbBuffer);
						return 1;
				}
				for(var i = 0; i < elementCount; i++){
						this.passEncoder.setVertexBuffer(slot + i, vbBuffer, elements[i].offset);
				}
				return elementCount;
		}
		validateVBLocations(vb0, vb1) {
				var validateVB = (vb)=>{
						var { elements } = vb.format;
						for(var i = 0; i < elements.length; i++){
								var name = elements[i].name;
								var location = semanticToLocation[name];
								if (_uniqueLocations.has(location)) ;
								_uniqueLocations.set(location, name);
						}
				};
				validateVB(vb0);
				validateVB(vb1);
				_uniqueLocations.clear();
		}
		draw(primitive, numInstances, keepBuffers) {
				if (numInstances === void 0) numInstances = 1;
				if (this.shader.ready && !this.shader.failed) {
						var passEncoder = this.passEncoder;
						var vb0 = this.vertexBuffers[0];
						var vb1 = this.vertexBuffers[1];
						if (vb0) {
								var vbSlot = this.submitVertexBuffer(vb0, 0);
								if (vb1) {
										this.submitVertexBuffer(vb1, vbSlot);
								}
						}
						var pipeline = this.renderPipeline.get(primitive, vb0 == null ? void 0 : vb0.format, vb1 == null ? void 0 : vb1.format, this.shader, this.renderTarget, this.bindGroupFormats, this.blendState, this.depthState, this.cullMode, this.stencilEnabled, this.stencilFront, this.stencilBack);
						if (this.pipeline !== pipeline) {
								this.pipeline = pipeline;
								passEncoder.setPipeline(pipeline);
						}
						var ib = this.indexBuffer;
						if (ib) {
								passEncoder.setIndexBuffer(ib.impl.buffer, ib.impl.format);
								passEncoder.drawIndexed(primitive.count, numInstances, primitive.base, 0, 0);
						} else {
								passEncoder.draw(primitive.count, numInstances, primitive.base, 0);
						}
				}
				this.vertexBuffers.length = 0;
				this.indexBuffer = null;
		}
		setShader(shader, asyncCompile) {
				if (shader !== this.shader) {
						this.shader = shader;
				}
		}
		setBlendState(blendState) {
				this.blendState.copy(blendState);
		}
		setDepthState(depthState) {
				this.depthState.copy(depthState);
		}
		setStencilState(stencilFront, stencilBack) {
				if (stencilFront || stencilBack) {
						this.stencilEnabled = true;
						this.stencilFront.copy(stencilFront != null ? stencilFront : StencilParameters.DEFAULT);
						this.stencilBack.copy(stencilBack != null ? stencilBack : StencilParameters.DEFAULT);
						var ref = this.stencilFront.ref;
						if (this.stencilRef !== ref) {
								this.stencilRef = ref;
								this.passEncoder.setStencilReference(ref);
						}
				} else {
						this.stencilEnabled = false;
				}
		}
		setBlendColor(r, g, b, a) {
				var c = this.blendColor;
				if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
						c.set(r, g, b, a);
						this.passEncoder.setBlendConstant(c);
				}
		}
		setCullMode(cullMode) {
				this.cullMode = cullMode;
		}
		setAlphaToCoverage(state) {}
		initializeContextCaches() {
				super.initializeContextCaches();
		}
		setupPassEncoderDefaults() {
				this.pipeline = null;
				this.stencilRef = 0;
				this.blendColor.set(0, 0, 0, 0);
		}
		_uploadDirtyTextures() {
				this.textures.forEach((texture)=>{
						if (texture._needsUpload || texture._needsMipmaps) {
								texture.upload();
						}
				});
		}
		setupTimeStampWrites(passDesc, name) {
				if (this.gpuProfiler._enabled) {
						if (this.gpuProfiler.timestampQueriesSet) {
								var slot = this.gpuProfiler.getSlot(name);
								passDesc = passDesc != null ? passDesc : {};
								passDesc.timestampWrites = {
										querySet: this.gpuProfiler.timestampQueriesSet.querySet,
										beginningOfPassWriteIndex: slot * 2,
										endOfPassWriteIndex: slot * 2 + 1
								};
						}
				}
				return passDesc;
		}
		startRenderPass(renderPass) {
				this._uploadDirtyTextures();
				var rt = renderPass.renderTarget || this.backBuffer;
				this.renderTarget = rt;
				var wrt = rt.impl;
				if (rt !== this.backBuffer) {
						this.initRenderTarget(rt);
				}
				wrt.setupForRenderPass(renderPass, rt);
				var renderPassDesc = wrt.renderPassDescriptor;
				this.setupTimeStampWrites(renderPassDesc, renderPass.name);
				var commandEncoder = this.getCommandEncoder();
				this.passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
				this.passEncoder.label = renderPass.name + "-PassEncoder RT:" + rt.name;
				this.setupPassEncoderDefaults();
				var { width, height } = rt;
				this.setViewport(0, 0, width, height);
				this.setScissor(0, 0, width, height);
				this.insideRenderPass = true;
		}
		endRenderPass(renderPass) {
				this.passEncoder.end();
				this.passEncoder = null;
				this.insideRenderPass = false;
				this.bindGroupFormats.length = 0;
				var target = this.renderTarget;
				if (target) {
						if (target.depthBuffer && renderPass.depthStencilOps.resolveDepth) {
								if (renderPass.samples > 1 && target.autoResolve) {
										var depthAttachment = target.impl.depthAttachment;
										var destTexture = target.depthBuffer.impl.gpuTexture;
										if (depthAttachment && destTexture) {
												this.resolver.resolveDepth(this.commandEncoder, depthAttachment.multisampledDepthBuffer, destTexture);
										}
								}
						}
				}
				for(var i = 0; i < renderPass.colorArrayOps.length; i++){
						var colorOps = renderPass.colorArrayOps[i];
						if (colorOps.genMipmaps) {
								this.mipmapRenderer.generate(renderPass.renderTarget._colorBuffers[i].impl);
						}
				}
		}
		startComputePass(name) {
				this.pipeline = null;
				var computePassDesc = this.setupTimeStampWrites(undefined, name);
				var commandEncoder = this.getCommandEncoder();
				this.passEncoder = commandEncoder.beginComputePass(computePassDesc);
				this.insideRenderPass = true;
		}
		endComputePass() {
				this.passEncoder.end();
				this.passEncoder = null;
				this.insideRenderPass = false;
				this.bindGroupFormats.length = 0;
		}
		computeDispatch(computes, name) {
				if (name === void 0) name = 'Unnamed';
				this.startComputePass(name);
				for(var i = 0; i < computes.length; i++){
						var compute = computes[i];
						compute.applyParameters();
						compute.impl.updateBindGroup();
				}
				for(var i1 = 0; i1 < computes.length; i1++){
						var compute1 = computes[i1];
						compute1.impl.dispatch(compute1.countX, compute1.countY, compute1.countZ);
				}
				this.endComputePass();
		}
		getCommandEncoder() {
				var commandEncoder = this.commandEncoder;
				if (!commandEncoder) {
						commandEncoder = this.wgpu.createCommandEncoder();
						this.commandEncoder = commandEncoder;
				}
				return commandEncoder;
		}
		endCommandEncoder() {
				var { commandEncoder } = this;
				if (commandEncoder) {
						var cb = commandEncoder.finish();
						this.addCommandBuffer(cb);
						this.commandEncoder = null;
				}
		}
		addCommandBuffer(commandBuffer, front) {
				if (front === void 0) front = false;
				if (front) {
						this.commandBuffers.unshift(commandBuffer);
				} else {
						this.commandBuffers.push(commandBuffer);
				}
		}
		submit() {
				this.endCommandEncoder();
				if (this.commandBuffers.length > 0) {
						this.dynamicBuffers.submit();
						this.wgpu.queue.submit(this.commandBuffers);
						this.commandBuffers.length = 0;
						this.dynamicBuffers.onCommandBuffersSubmitted();
				}
		}
		clear(options) {
				if (options.flags) {
						this.clearRenderer.clear(this, this.renderTarget, options, this.defaultClearOptions);
				}
		}
		setViewport(x, y, w, h) {
				if (this.passEncoder) {
						if (!this.renderTarget.flipY) {
								y = this.renderTarget.height - y - h;
						}
						this.vx = x;
						this.vy = y;
						this.vw = w;
						this.vh = h;
						this.passEncoder.setViewport(x, y, w, h, 0, 1);
				}
		}
		setScissor(x, y, w, h) {
				if (this.passEncoder) {
						if (!this.renderTarget.flipY) {
								y = this.renderTarget.height - y - h;
						}
						this.sx = x;
						this.sy = y;
						this.sw = w;
						this.sh = h;
						this.passEncoder.setScissorRect(x, y, w, h);
				}
		}
		clearStorageBuffer(storageBuffer, offset, size) {
				if (offset === void 0) offset = 0;
				if (size === void 0) size = storageBuffer.byteSize;
				var commandEncoder = this.getCommandEncoder();
				commandEncoder.clearBuffer(storageBuffer.buffer, offset, size);
		}
		readStorageBuffer(storageBuffer, offset, size, data, immediate) {
				if (offset === void 0) offset = 0;
				if (size === void 0) size = storageBuffer.byteSize - offset;
				if (data === void 0) data = null;
				if (immediate === void 0) immediate = false;
				var stagingBuffer = this.createBufferImpl(BUFFERUSAGE_READ | BUFFERUSAGE_COPY_DST);
				stagingBuffer.allocate(this, size);
				var destBuffer = stagingBuffer.buffer;
				var commandEncoder = this.getCommandEncoder();
				commandEncoder.copyBufferToBuffer(storageBuffer.buffer, offset, destBuffer, 0, size);
				return this.readBuffer(stagingBuffer, size, data, immediate);
		}
		readBuffer(stagingBuffer, size, data, immediate) {
				if (data === void 0) data = null;
				if (immediate === void 0) immediate = false;
				var destBuffer = stagingBuffer.buffer;
				return new Promise((resolve, reject)=>{
						var read = ()=>{
								destBuffer == null ? void 0 : destBuffer.mapAsync(GPUMapMode.READ).then(()=>{
										data != null ? data : data = new Uint8Array(size);
										var copySrc = destBuffer.getMappedRange(0, size);
										var srcType = data.constructor;
										data.set(new srcType(copySrc));
										destBuffer.unmap();
										stagingBuffer.destroy(this);
										resolve(data);
								});
						};
						if (immediate) {
								this.submit();
								read();
						} else {
								setTimeout(()=>{
										read();
								});
						}
				});
		}
		writeStorageBuffer(storageBuffer, bufferOffset, data, dataOffset, size) {
				if (bufferOffset === void 0) bufferOffset = 0;
				if (dataOffset === void 0) dataOffset = 0;
				this.wgpu.queue.writeBuffer(storageBuffer.buffer, bufferOffset, data, dataOffset, size);
		}
		copyRenderTarget(source, dest, color, depth) {
				var copySize = {
						width: source ? source.width : dest.width,
						height: source ? source.height : dest.height,
						depthOrArrayLayers: 1
				};
				var commandEncoder = this.getCommandEncoder();
				if (color) {
						var copySrc = {
								texture: source ? source.colorBuffer.impl.gpuTexture : this.backBuffer.impl.assignedColorTexture,
								mipLevel: 0
						};
						var copyDst = {
								texture: dest ? dest.colorBuffer.impl.gpuTexture : this.backBuffer.impl.assignedColorTexture,
								mipLevel: 0
						};
						commandEncoder.copyTextureToTexture(copySrc, copyDst, copySize);
				}
				if (depth) {
						var sourceRT = source ? source : this.renderTarget;
						var sourceTexture = sourceRT.impl.depthAttachment.depthTexture;
						if (source.samples > 1) {
								var destTexture = dest.colorBuffer.impl.gpuTexture;
								this.resolver.resolveDepth(commandEncoder, sourceTexture, destTexture);
						} else {
								var destTexture1 = dest ? dest.depthBuffer.impl.gpuTexture : this.renderTarget.impl.depthAttachment.depthTexture;
								var copySrc1 = {
										texture: sourceTexture,
										mipLevel: 0
								};
								var copyDst1 = {
										texture: destTexture1,
										mipLevel: 0
								};
								commandEncoder.copyTextureToTexture(copySrc1, copyDst1, copySize);
						}
				}
				return true;
		}
		constructor(canvas, options = {}){
				super(canvas, options), this.renderPipeline = new WebgpuRenderPipeline(this), this.computePipeline = new WebgpuComputePipeline(this), this.bindGroupFormats = [], this.commandEncoder = null, this.commandBuffers = [];
				options = this.initOptions;
				var _options_alpha;
				options.alpha = (_options_alpha = options.alpha) != null ? _options_alpha : true;
				var _options_antialias;
				this.backBufferAntialias = (_options_antialias = options.antialias) != null ? _options_antialias : false;
				this.isWebGPU = true;
				this._deviceType = DEVICETYPE_WEBGPU;
				this.scope.resolve(UNUSED_UNIFORM_NAME).setValue(0);
		}
}

class WebglBuffer {
		destroy(device) {
				if (this.bufferId) {
						device.gl.deleteBuffer(this.bufferId);
						this.bufferId = null;
				}
		}
		get initialized() {
				return !!this.bufferId;
		}
		loseContext() {
				this.bufferId = null;
		}
		unlock(device, usage, target, storage) {
				var gl = device.gl;
				if (!this.bufferId) {
						var glUsage;
						switch(usage){
								case BUFFER_STATIC:
										glUsage = gl.STATIC_DRAW;
										break;
								case BUFFER_DYNAMIC:
										glUsage = gl.DYNAMIC_DRAW;
										break;
								case BUFFER_STREAM:
										glUsage = gl.STREAM_DRAW;
										break;
								case BUFFER_GPUDYNAMIC:
										glUsage = gl.DYNAMIC_COPY;
										break;
						}
						this.bufferId = gl.createBuffer();
						gl.bindBuffer(target, this.bufferId);
						gl.bufferData(target, storage, glUsage);
				} else {
						gl.bindBuffer(target, this.bufferId);
						gl.bufferSubData(target, 0, storage);
				}
		}
		constructor(){
				this.bufferId = null;
		}
}

class WebglVertexBuffer extends WebglBuffer {
		destroy(device) {
				super.destroy(device);
				device.unbindVertexArray();
		}
		loseContext() {
				super.loseContext();
				this.vao = null;
		}
		unlock(vertexBuffer) {
				var device = vertexBuffer.device;
				super.unlock(device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
		}
		constructor(...args){
				super(...args), this.vao = null;
		}
}

class WebglIndexBuffer extends WebglBuffer {
		unlock(indexBuffer) {
				var device = indexBuffer.device;
				super.unlock(device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
		}
		constructor(indexBuffer){
				super();
				var gl = indexBuffer.device.gl;
				var format = indexBuffer.format;
				if (format === INDEXFORMAT_UINT8) {
						this.glFormat = gl.UNSIGNED_BYTE;
				} else if (format === INDEXFORMAT_UINT16) {
						this.glFormat = gl.UNSIGNED_SHORT;
				} else if (format === INDEXFORMAT_UINT32) {
						this.glFormat = gl.UNSIGNED_INT;
				}
		}
}

class WebglShaderInput {
		constructor(graphicsDevice, name, type, locationId){
				this.locationId = locationId;
				this.scopeId = graphicsDevice.scope.resolve(name);
				this.version = new Version();
				if (name.substring(name.length - 3) === '[0]') {
						switch(type){
								case UNIFORMTYPE_FLOAT:
										type = UNIFORMTYPE_FLOATARRAY;
										break;
								case UNIFORMTYPE_INT:
										type = UNIFORMTYPE_INTARRAY;
										break;
								case UNIFORMTYPE_UINT:
										type = UNIFORMTYPE_UINTARRAY;
										break;
								case UNIFORMTYPE_BOOL:
										type = UNIFORMTYPE_BOOLARRAY;
										break;
								case UNIFORMTYPE_VEC2:
										type = UNIFORMTYPE_VEC2ARRAY;
										break;
								case UNIFORMTYPE_IVEC2:
										type = UNIFORMTYPE_IVEC2ARRAY;
										break;
								case UNIFORMTYPE_UVEC2:
										type = UNIFORMTYPE_UVEC2ARRAY;
										break;
								case UNIFORMTYPE_BVEC2:
										type = UNIFORMTYPE_BVEC2ARRAY;
										break;
								case UNIFORMTYPE_VEC3:
										type = UNIFORMTYPE_VEC3ARRAY;
										break;
								case UNIFORMTYPE_IVEC3:
										type = UNIFORMTYPE_IVEC3ARRAY;
										break;
								case UNIFORMTYPE_UVEC3:
										type = UNIFORMTYPE_UVEC3ARRAY;
										break;
								case UNIFORMTYPE_BVEC3:
										type = UNIFORMTYPE_BVEC3ARRAY;
										break;
								case UNIFORMTYPE_VEC4:
										type = UNIFORMTYPE_VEC4ARRAY;
										break;
								case UNIFORMTYPE_IVEC4:
										type = UNIFORMTYPE_IVEC4ARRAY;
										break;
								case UNIFORMTYPE_UVEC4:
										type = UNIFORMTYPE_UVEC4ARRAY;
										break;
								case UNIFORMTYPE_BVEC4:
										type = UNIFORMTYPE_BVEC4ARRAY;
										break;
						}
				}
				this.dataType = type;
				this.value = [
						null,
						null,
						null,
						null
				];
				this.array = [];
		}
}

var _vertexShaderBuiltins = new Set([
		'gl_VertexID',
		'gl_InstanceID',
		'gl_DrawID',
		'gl_BaseVertex',
		'gl_BaseInstance'
]);
class CompiledShaderCache {
		destroy(device) {
				this.map.forEach((shader)=>{
						device.gl.deleteShader(shader);
				});
		}
		loseContext(device) {
				this.map.clear();
		}
		constructor(){
				this.map = new Map();
		}
}
var _vertexShaderCache = new DeviceCache();
var _fragmentShaderCache = new DeviceCache();
class WebglShader {
		destroy(shader) {
				if (this.glProgram) {
						shader.device.gl.deleteProgram(this.glProgram);
						this.glProgram = null;
				}
		}
		init() {
				this.uniforms = [];
				this.samplers = [];
				this.attributes = [];
				this.glProgram = null;
				this.glVertexShader = null;
				this.glFragmentShader = null;
		}
		loseContext() {
				this.init();
		}
		restoreContext(device, shader) {
				this.compile(device, shader);
				this.link(device, shader);
		}
		compile(device, shader) {
				var definition = shader.definition;
				this.glVertexShader = this._compileShaderSource(device, definition.vshader, true);
				this.glFragmentShader = this._compileShaderSource(device, definition.fshader, false);
		}
		link(device, shader) {
				if (this.glProgram) {
						return;
				}
				var gl = device.gl;
				if (gl.isContextLost()) {
						return;
				}
				var glProgram = gl.createProgram();
				this.glProgram = glProgram;
				gl.attachShader(glProgram, this.glVertexShader);
				gl.attachShader(glProgram, this.glFragmentShader);
				var definition = shader.definition;
				var attrs = definition.attributes;
				if (definition.useTransformFeedback) {
						var outNames = [];
						for(var attr in attrs){
								if (attrs.hasOwnProperty(attr)) {
										outNames.push("out_" + attr);
								}
						}
						gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
				}
				for(var attr1 in attrs){
						if (attrs.hasOwnProperty(attr1)) {
								var semantic = attrs[attr1];
								var loc = semanticToLocation[semantic];
								gl.bindAttribLocation(glProgram, loc, attr1);
						}
				}
				gl.linkProgram(glProgram);
		}
		_compileShaderSource(device, src, isVertexShader) {
				var gl = device.gl;
				if (gl.isContextLost()) {
						return null;
				}
				var shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;
				var shaderCache = shaderDeviceCache.get(device, ()=>{
						return new CompiledShaderCache();
				});
				var glShader = shaderCache.map.get(src);
				if (!glShader) {
						glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
						gl.shaderSource(glShader, src);
						gl.compileShader(glShader);
						shaderCache.map.set(src, glShader);
				}
				return glShader;
		}
		finalize(device, shader) {
				var gl = device.gl;
				if (gl.isContextLost()) {
						return true;
				}
				var glProgram = this.glProgram;
				var definition = shader.definition;
				var linkStatus = gl.getProgramParameter(glProgram, gl.LINK_STATUS);
				if (!linkStatus) {
						if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, 'vertex')) {
								return false;
						}
						if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, 'fragment')) {
								return false;
						}
						var message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
						console.error(message);
						return false;
				}
				var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
				shader.attributes.clear();
				for(var i = 0; i < numAttributes; i++){
						var info = gl.getActiveAttrib(glProgram, i);
						var location = gl.getAttribLocation(glProgram, info.name);
						if (_vertexShaderBuiltins.has(info.name)) {
								continue;
						}
						if (definition.attributes[info.name] === undefined) {
								console.error('Vertex shader attribute "' + info.name + '" is not mapped to a semantic in shader definition, shader [' + shader.label + "]", shader);
								shader.failed = true;
						} else {
								shader.attributes.set(location, info.name);
						}
				}
				var samplerTypes = device._samplerTypes;
				var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
				for(var i1 = 0; i1 < numUniforms; i1++){
						var info1 = gl.getActiveUniform(glProgram, i1);
						var location1 = gl.getUniformLocation(glProgram, info1.name);
						var shaderInput = new WebglShaderInput(device, info1.name, device.pcUniformType[info1.type], location1);
						if (samplerTypes.has(info1.type)) {
								this.samplers.push(shaderInput);
						} else {
								this.uniforms.push(shaderInput);
						}
				}
				shader.ready = true;
				return true;
		}
		_isCompiled(device, shader, glShader, source, shaderType) {
				var gl = device.gl;
				if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
						var infoLog = gl.getShaderInfoLog(glShader);
						var [code, error] = this._processError(source, infoLog);
						var message = "Failed to compile " + shaderType + " shader:\n\n" + infoLog + "\n" + code + " while rendering " + void 0;
						console.error(message);
						return false;
				}
				return true;
		}
		isLinked(device) {
				var { extParallelShaderCompile } = device;
				if (extParallelShaderCompile) {
						return device.gl.getProgramParameter(this.glProgram, extParallelShaderCompile.COMPLETION_STATUS_KHR);
				}
				return true;
		}
		_processError(src, infoLog) {
				var error = {};
				var code = '';
				if (src) {
						var lines = src.split('\n');
						var from = 0;
						var to = lines.length;
						if (infoLog && infoLog.startsWith('ERROR:')) {
								var match = infoLog.match(/^ERROR:\s(\d+):(\d+):\s*(.+)/);
								if (match) {
										error.message = match[3];
										error.line = parseInt(match[2], 10);
										from = Math.max(0, error.line - 6);
										to = Math.min(lines.length, error.line + 5);
								}
						}
						for(var i = from; i < to; i++){
								var linePrefix = i + 1 === error.line ? '> ' : '  ';
								code += "" + linePrefix + (i + 1) + ":	" + lines[i] + "\n";
						}
						error.source = src;
				}
				return [
						code,
						error
				];
		}
		constructor(shader){
				this.compileDuration = 0;
				this.init();
				this.compile(shader.device, shader);
				this.link(shader.device, shader);
				shader.device.shaders.push(shader);
		}
}

function downsampleImage(image, size) {
		var srcW = image.width;
		var srcH = image.height;
		if (srcW > size || srcH > size) {
				var scale = size / Math.max(srcW, srcH);
				var dstW = Math.floor(srcW * scale);
				var dstH = Math.floor(srcH * scale);
				var canvas = document.createElement('canvas');
				canvas.width = dstW;
				canvas.height = dstH;
				var context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
				return canvas;
		}
		return image;
}
class WebglTexture {
		destroy(device) {
				if (this._glTexture) {
						for(var i = 0; i < device.textureUnits.length; i++){
								var textureUnit = device.textureUnits[i];
								for(var j = 0; j < textureUnit.length; j++){
										if (textureUnit[j] === this._glTexture) {
												textureUnit[j] = null;
										}
								}
						}
						device.gl.deleteTexture(this._glTexture);
						this._glTexture = null;
				}
		}
		loseContext() {
				this._glTexture = null;
		}
		propertyChanged(flag) {
				this.dirtyParameterFlags |= flag;
		}
		initialize(device, texture) {
				var gl = device.gl;
				this._glTexture = gl.createTexture();
				this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : texture.array ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
				switch(texture._format){
						case PIXELFORMAT_A8:
								this._glFormat = gl.ALPHA;
								this._glInternalFormat = gl.ALPHA;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_L8:
								this._glFormat = gl.LUMINANCE;
								this._glInternalFormat = gl.LUMINANCE;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_LA8:
								this._glFormat = gl.LUMINANCE_ALPHA;
								this._glInternalFormat = gl.LUMINANCE_ALPHA;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_R8:
								this._glFormat = gl.RED;
								this._glInternalFormat = gl.R8;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_RG8:
								this._glFormat = gl.RG;
								this._glInternalFormat = gl.RG8;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_RGB565:
								this._glFormat = gl.RGB;
								this._glInternalFormat = gl.RGB;
								this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
								break;
						case PIXELFORMAT_RGBA5551:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = gl.RGBA;
								this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
								break;
						case PIXELFORMAT_RGBA4:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = gl.RGBA;
								this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
								break;
						case PIXELFORMAT_RGB8:
								this._glFormat = gl.RGB;
								this._glInternalFormat = gl.RGB8;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_RGBA8:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = gl.RGBA8;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_BGRA8:
						case PIXELFORMAT_SBGRA8:
								break;
						case PIXELFORMAT_DXT1:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
								break;
						case PIXELFORMAT_DXT3:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								break;
						case PIXELFORMAT_DXT5:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
								break;
						case PIXELFORMAT_ETC1:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
								break;
						case PIXELFORMAT_PVRTC_2BPP_RGB_1:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
								break;
						case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
								break;
						case PIXELFORMAT_PVRTC_4BPP_RGB_1:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
								break;
						case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
								break;
						case PIXELFORMAT_ETC2_RGB:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
								break;
						case PIXELFORMAT_ETC2_RGBA:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
								break;
						case PIXELFORMAT_ASTC_4x4:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
								break;
						case PIXELFORMAT_ATC_RGB:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
								break;
						case PIXELFORMAT_ATC_RGBA:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
								break;
						case PIXELFORMAT_BC6F:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
								break;
						case PIXELFORMAT_BC6UF:
								this._glFormat = gl.RGB;
								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
								break;
						case PIXELFORMAT_BC7:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGBA_BPTC_UNORM_EXT;
								break;
						case PIXELFORMAT_DXT1_SRGB:
								this._glFormat = gl.SRGB;
								this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_S3TC_DXT1_EXT;
								break;
						case PIXELFORMAT_DXT3_SRGBA:
								this._glFormat = gl.SRGB_ALPHA;
								this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
								break;
						case PIXELFORMAT_DXT5_SRGBA:
								this._glFormat = gl.SRGB_ALPHA;
								this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
								break;
						case PIXELFORMAT_ETC2_SRGB:
								this._glFormat = gl.SRGB;
								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_SRGB8_ETC2;
								break;
						case PIXELFORMAT_ETC2_SRGBA:
								this._glFormat = gl.SRGB_ALPHA;
								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
								break;
						case PIXELFORMAT_ASTC_4x4_SRGB:
								this._glFormat = gl.SRGB_ALPHA;
								this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
								break;
						case PIXELFORMAT_BC7_SRGBA:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
								break;
						case PIXELFORMAT_R16F:
								this._glFormat = gl.RED;
								this._glInternalFormat = gl.R16F;
								this._glPixelType = gl.HALF_FLOAT;
								break;
						case PIXELFORMAT_RG16F:
								this._glFormat = gl.RG;
								this._glInternalFormat = gl.RG16F;
								this._glPixelType = gl.HALF_FLOAT;
								break;
						case PIXELFORMAT_RGB16F:
								this._glFormat = gl.RGB;
								this._glInternalFormat = gl.RGB16F;
								this._glPixelType = gl.HALF_FLOAT;
								break;
						case PIXELFORMAT_RGBA16F:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = gl.RGBA16F;
								this._glPixelType = gl.HALF_FLOAT;
								break;
						case PIXELFORMAT_RGB32F:
								this._glFormat = gl.RGB;
								this._glInternalFormat = gl.RGB32F;
								this._glPixelType = gl.FLOAT;
								break;
						case PIXELFORMAT_RGBA32F:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = gl.RGBA32F;
								this._glPixelType = gl.FLOAT;
								break;
						case PIXELFORMAT_R32F:
								this._glFormat = gl.RED;
								this._glInternalFormat = gl.R32F;
								this._glPixelType = gl.FLOAT;
								break;
						case PIXELFORMAT_DEPTH:
								this._glFormat = gl.DEPTH_COMPONENT;
								this._glInternalFormat = gl.DEPTH_COMPONENT32F;
								this._glPixelType = gl.FLOAT;
								break;
						case PIXELFORMAT_DEPTH16:
								this._glFormat = gl.DEPTH_COMPONENT;
								this._glInternalFormat = gl.DEPTH_COMPONENT16;
								this._glPixelType = gl.UNSIGNED_SHORT;
								break;
						case PIXELFORMAT_DEPTHSTENCIL:
								this._glFormat = gl.DEPTH_STENCIL;
								this._glInternalFormat = gl.DEPTH24_STENCIL8;
								this._glPixelType = gl.UNSIGNED_INT_24_8;
								break;
						case PIXELFORMAT_111110F:
								this._glFormat = gl.RGB;
								this._glInternalFormat = gl.R11F_G11F_B10F;
								this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
								break;
						case PIXELFORMAT_SRGB8:
								this._glFormat = gl.RGB;
								this._glInternalFormat = gl.SRGB8;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_SRGBA8:
								this._glFormat = gl.RGBA;
								this._glInternalFormat = gl.SRGB8_ALPHA8;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_R8I:
								this._glFormat = gl.RED_INTEGER;
								this._glInternalFormat = gl.R8I;
								this._glPixelType = gl.BYTE;
								break;
						case PIXELFORMAT_R8U:
								this._glFormat = gl.RED_INTEGER;
								this._glInternalFormat = gl.R8UI;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_R16I:
								this._glFormat = gl.RED_INTEGER;
								this._glInternalFormat = gl.R16I;
								this._glPixelType = gl.SHORT;
								break;
						case PIXELFORMAT_R16U:
								this._glFormat = gl.RED_INTEGER;
								this._glInternalFormat = gl.R16UI;
								this._glPixelType = gl.UNSIGNED_SHORT;
								break;
						case PIXELFORMAT_R32I:
								this._glFormat = gl.RED_INTEGER;
								this._glInternalFormat = gl.R32I;
								this._glPixelType = gl.INT;
								break;
						case PIXELFORMAT_R32U:
								this._glFormat = gl.RED_INTEGER;
								this._glInternalFormat = gl.R32UI;
								this._glPixelType = gl.UNSIGNED_INT;
								break;
						case PIXELFORMAT_RG8I:
								this._glFormat = gl.RG_INTEGER;
								this._glInternalFormat = gl.RG8I;
								this._glPixelType = gl.BYTE;
								break;
						case PIXELFORMAT_RG8U:
								this._glFormat = gl.RG_INTEGER;
								this._glInternalFormat = gl.RG8UI;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_RG16I:
								this._glFormat = gl.RG_INTEGER;
								this._glInternalFormat = gl.RG16I;
								this._glPixelType = gl.SHORT;
								break;
						case PIXELFORMAT_RG16U:
								this._glFormat = gl.RG_INTEGER;
								this._glInternalFormat = gl.RG16UI;
								this._glPixelType = gl.UNSIGNED_SHORT;
								break;
						case PIXELFORMAT_RG32I:
								this._glFormat = gl.RG_INTEGER;
								this._glInternalFormat = gl.RG32I;
								this._glPixelType = gl.INT;
								break;
						case PIXELFORMAT_RG32U:
								this._glFormat = gl.RG_INTEGER;
								this._glInternalFormat = gl.RG32UI;
								this._glPixelType = gl.UNSIGNED_INT;
								break;
						case PIXELFORMAT_RGBA8I:
								this._glFormat = gl.RGBA_INTEGER;
								this._glInternalFormat = gl.RGBA8I;
								this._glPixelType = gl.BYTE;
								break;
						case PIXELFORMAT_RGBA8U:
								this._glFormat = gl.RGBA_INTEGER;
								this._glInternalFormat = gl.RGBA8UI;
								this._glPixelType = gl.UNSIGNED_BYTE;
								break;
						case PIXELFORMAT_RGBA16I:
								this._glFormat = gl.RGBA_INTEGER;
								this._glInternalFormat = gl.RGBA16I;
								this._glPixelType = gl.SHORT;
								break;
						case PIXELFORMAT_RGBA16U:
								this._glFormat = gl.RGBA_INTEGER;
								this._glInternalFormat = gl.RGBA16UI;
								this._glPixelType = gl.UNSIGNED_SHORT;
								break;
						case PIXELFORMAT_RGBA32I:
								this._glFormat = gl.RGBA_INTEGER;
								this._glInternalFormat = gl.RGBA32I;
								this._glPixelType = gl.INT;
								break;
						case PIXELFORMAT_RGBA32U:
								this._glFormat = gl.RGBA_INTEGER;
								this._glInternalFormat = gl.RGBA32UI;
								this._glPixelType = gl.UNSIGNED_INT;
								break;
				}
				this._glCreated = false;
		}
		upload(device, texture) {
				var gl = device.gl;
				if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) {
						return;
				}
				var mipLevel = 0;
				var mipObject;
				var resMult;
				var requiredMipLevels = texture.numLevels;
				if (texture.array) {
						gl.texStorage3D(gl.TEXTURE_2D_ARRAY, requiredMipLevels, this._glInternalFormat, texture._width, texture._height, texture._arrayLength);
				}
				while(texture._levels[mipLevel] || mipLevel === 0){
						if (!texture._needsUpload && mipLevel === 0) {
								mipLevel++;
								continue;
						} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
								break;
						}
						mipObject = texture._levels[mipLevel];
						resMult = 1 / Math.pow(2, mipLevel);
						if (mipLevel === 1 && !texture._compressed && !texture._integerFormat && texture._levels.length < requiredMipLevels) {
								gl.generateMipmap(this._glTarget);
								texture._mipmapsUploaded = true;
						}
						if (texture._cubemap) {
								var face = void 0;
								if (device._isBrowserInterface(mipObject[0])) {
										for(face = 0; face < 6; face++){
												if (!texture._levelsUpdated[0][face]) {
														continue;
												}
												var src = mipObject[face];
												if (device._isImageBrowserInterface(src)) {
														if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
																src = downsampleImage(src, device.maxCubeMapSize);
																if (mipLevel === 0) {
																		texture._width = src.width;
																		texture._height = src.height;
																}
														}
												}
												device.setUnpackFlipY(false);
												device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
												if (this._glCreated) {
														gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, this._glFormat, this._glPixelType, src);
												} else {
														gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
												}
										}
								} else {
										resMult = 1 / Math.pow(2, mipLevel);
										for(face = 0; face < 6; face++){
												if (!texture._levelsUpdated[0][face]) {
														continue;
												}
												var texData = mipObject[face];
												if (texture._compressed) {
														if (this._glCreated && texData) {
																gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glInternalFormat, texData);
														} else {
																gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
														}
												} else {
														device.setUnpackFlipY(false);
														device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
														if (this._glCreated && texData) {
																gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, texData);
														} else {
																gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
														}
												}
										}
								}
						} else if (texture._volume) {
								if (texture._compressed) {
										gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
								} else {
										device.setUnpackFlipY(false);
										device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
										gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
								}
						} else if (texture.array && typeof mipObject === 'object') {
								if (texture._arrayLength === mipObject.length) {
										if (texture._compressed) {
												for(var index = 0; index < texture._arrayLength; index++){
														gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glInternalFormat, mipObject[index]);
												}
										} else {
												for(var index1 = 0; index1 < texture._arrayLength; index1++){
														gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index1, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, this._glPixelType, mipObject[index1]);
												}
										}
								}
						} else {
								if (device._isBrowserInterface(mipObject)) {
										if (device._isImageBrowserInterface(mipObject)) {
												if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
														mipObject = downsampleImage(mipObject, device.maxTextureSize);
														if (mipLevel === 0) {
																texture._width = mipObject.width;
																texture._height = mipObject.height;
														}
												}
										}
										var w = mipObject.width || mipObject.videoWidth;
										var h = mipObject.height || mipObject.videoHeight;
										device.setUnpackFlipY(texture._flipY);
										device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
										if (this._glCreated && texture._width === w && texture._height === h && !device._isImageVideoInterface(mipObject)) {
												gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, this._glFormat, this._glPixelType, mipObject);
										} else {
												gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
												if (mipLevel === 0) {
														texture._width = w;
														texture._height = h;
												}
										}
								} else {
										resMult = 1 / Math.pow(2, mipLevel);
										if (texture._compressed) {
												if (this._glCreated && mipObject) {
														gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), this._glInternalFormat, mipObject);
												} else {
														gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
												}
										} else {
												device.setUnpackFlipY(false);
												device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
												if (this._glCreated && mipObject) {
														gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, mipObject);
												} else {
														gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
												}
										}
								}
								if (mipLevel === 0) {
										texture._mipmapsUploaded = false;
								} else {
										texture._mipmapsUploaded = true;
								}
						}
						mipLevel++;
				}
				if (texture._needsUpload) {
						if (texture._cubemap) {
								for(var i = 0; i < 6; i++){
										texture._levelsUpdated[0][i] = false;
								}
						} else {
								texture._levelsUpdated[0] = false;
						}
				}
				if (!texture._compressed && !texture._integerFormat && texture._mipmaps && texture._needsMipmapsUpload && texture._levels.length === 1) {
						gl.generateMipmap(this._glTarget);
						texture._mipmapsUploaded = true;
				}
				if (texture._gpuSize) {
						texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
				}
				texture._gpuSize = texture.gpuSize;
				texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
				this._glCreated = true;
		}
		read(x, y, width, height, options) {
				var texture = this.texture;
				var device = texture.device;
				return device.readTextureAsync(texture, x, y, width, height, options);
		}
		constructor(texture){
				this._glTexture = null;
				this.dirtyParameterFlags = 0;
				this.texture = texture;
		}
}

class FramebufferPair {
		destroy(gl) {
				if (this.msaaFB) {
						gl.deleteRenderbuffer(this.msaaFB);
						this.msaaFB = null;
				}
				if (this.resolveFB) {
						gl.deleteRenderbuffer(this.resolveFB);
						this.resolveFB = null;
				}
		}
		constructor(msaaFB, resolveFB){
				this.msaaFB = msaaFB;
				this.resolveFB = resolveFB;
		}
}
class WebglRenderTarget {
		destroy(device) {
				var _this_colorMrtFramebuffers;
				var gl = device.gl;
				this._isInitialized = false;
				if (this._glFrameBuffer) {
						if (this._glFrameBuffer !== this.suppliedColorFramebuffer) {
								gl.deleteFramebuffer(this._glFrameBuffer);
						}
						this._glFrameBuffer = null;
				}
				if (this._glDepthBuffer) {
						gl.deleteRenderbuffer(this._glDepthBuffer);
						this._glDepthBuffer = null;
				}
				if (this._glResolveFrameBuffer) {
						if (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer) {
								gl.deleteFramebuffer(this._glResolveFrameBuffer);
						}
						this._glResolveFrameBuffer = null;
				}
				this._glMsaaColorBuffers.forEach((buffer)=>{
						gl.deleteRenderbuffer(buffer);
				});
				this._glMsaaColorBuffers.length = 0;
				(_this_colorMrtFramebuffers = this.colorMrtFramebuffers) == null ? void 0 : _this_colorMrtFramebuffers.forEach((framebuffer)=>{
						framebuffer.destroy(gl);
				});
				this.colorMrtFramebuffers = null;
				if (this._glMsaaDepthBuffer) {
						this._glMsaaDepthBuffer = null;
						if (this.msaaDepthBufferKey) {
								getMultisampledTextureCache(device).release(this.msaaDepthBufferKey);
						}
				}
				this.suppliedColorFramebuffer = undefined;
		}
		get initialized() {
				return this._isInitialized;
		}
		init(device, target) {
				var gl = device.gl;
				this._isInitialized = true;
				var buffers = [];
				if (this.suppliedColorFramebuffer !== undefined) {
						this._glFrameBuffer = this.suppliedColorFramebuffer;
				} else {
						var _target__colorBuffers;
						this._glFrameBuffer = gl.createFramebuffer();
						device.setFramebuffer(this._glFrameBuffer);
						var _target__colorBuffers_length;
						var colorBufferCount = (_target__colorBuffers_length = (_target__colorBuffers = target._colorBuffers) == null ? void 0 : _target__colorBuffers.length) != null ? _target__colorBuffers_length : 0;
						var attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
						for(var i = 0; i < colorBufferCount; ++i){
								var colorBuffer = target.getColorBuffer(i);
								if (colorBuffer) {
										if (!colorBuffer.impl._glTexture) {
												colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
												colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
												device.setTexture(colorBuffer, 0);
										}
										gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant + i, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, target.mipLevel);
										buffers.push(attachmentBaseConstant + i);
								}
						}
						gl.drawBuffers(buffers);
						var depthBuffer = target._depthBuffer;
						if (depthBuffer || target._depth) {
								var attachmentPoint = target._stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
								if (depthBuffer) {
										if (!depthBuffer.impl._glTexture) {
												depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
												depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
												device.setTexture(depthBuffer, 0);
										}
										gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, target.mipLevel);
								} else {
										var willRenderMsaa = target._samples > 1;
										if (!willRenderMsaa) {
												if (!this._glDepthBuffer) {
														this._glDepthBuffer = gl.createRenderbuffer();
												}
												var internalFormat = target._stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT32F;
												gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);
												gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width, target.height);
												gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._glDepthBuffer);
												gl.bindRenderbuffer(gl.RENDERBUFFER, null);
										}
								}
						}
				}
				if (target._samples > 1) {
						var _target__colorBuffers1;
						this._glResolveFrameBuffer = this._glFrameBuffer;
						this._glFrameBuffer = gl.createFramebuffer();
						device.setFramebuffer(this._glFrameBuffer);
						var _target__colorBuffers_length1;
						var colorBufferCount1 = (_target__colorBuffers_length1 = (_target__colorBuffers1 = target._colorBuffers) == null ? void 0 : _target__colorBuffers1.length) != null ? _target__colorBuffers_length1 : 0;
						if (this.suppliedColorFramebuffer !== undefined) {
								var buffer = gl.createRenderbuffer();
								this._glMsaaColorBuffers.push(buffer);
								var internalFormat1 = device.backBufferFormat === PIXELFORMAT_RGBA8 ? gl.RGBA8 : gl.RGB8;
								gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
								gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, internalFormat1, target.width, target.height);
								gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
						} else {
								for(var i1 = 0; i1 < colorBufferCount1; ++i1){
										var colorBuffer1 = target.getColorBuffer(i1);
										if (colorBuffer1) {
												var buffer1 = gl.createRenderbuffer();
												this._glMsaaColorBuffers.push(buffer1);
												gl.bindRenderbuffer(gl.RENDERBUFFER, buffer1);
												gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer1.impl._glInternalFormat, target.width, target.height);
												gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i1, gl.RENDERBUFFER, buffer1);
										}
								}
						}
						if (target._depth) {
								var internalFormat2 = target._stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT32F;
								var attachmentPoint1 = target._stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
								var key;
								var depthBuffer1 = target._depthBuffer;
								if (depthBuffer1) {
										key = depthBuffer1.id + ":" + target.width + ":" + target.height + ":" + target._samples + ":" + internalFormat2 + ":" + attachmentPoint1;
										this._glMsaaDepthBuffer = getMultisampledTextureCache(device).get(key);
								}
								if (!this._glMsaaDepthBuffer) {
										this._glMsaaDepthBuffer = gl.createRenderbuffer();
										gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);
										gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, internalFormat2, target.width, target.height);
										this._glMsaaDepthBuffer.destroy = function() {
												gl.deleteRenderbuffer(this);
										};
										if (depthBuffer1) {
												getMultisampledTextureCache(device).set(key, this._glMsaaDepthBuffer);
										}
								}
								this.msaaDepthBufferKey = key;
								gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint1, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
						}
						if (colorBufferCount1 > 1) {
								this._createMsaaMrtFramebuffers(device, target, colorBufferCount1);
								device.setFramebuffer(this._glFrameBuffer);
								gl.drawBuffers(buffers);
						}
				}
		}
		_createMsaaMrtFramebuffers(device, target, colorBufferCount) {
				var gl = device.gl;
				this.colorMrtFramebuffers = [];
				for(var i = 0; i < colorBufferCount; ++i){
						var colorBuffer = target.getColorBuffer(i);
						var srcFramebuffer = gl.createFramebuffer();
						device.setFramebuffer(srcFramebuffer);
						var buffer = this._glMsaaColorBuffers[i];
						gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
						gl.drawBuffers([
								gl.COLOR_ATTACHMENT0
						]);
						var dstFramebuffer = gl.createFramebuffer();
						device.setFramebuffer(dstFramebuffer);
						gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
						this.colorMrtFramebuffers[i] = new FramebufferPair(srcFramebuffer, dstFramebuffer);
				}
		}
		_checkFbo(device, target, type) {
				var gl = device.gl;
				var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				switch(status){
						case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
								break;
						case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
								break;
						case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
								break;
						case gl.FRAMEBUFFER_UNSUPPORTED:
								break;
				}
		}
		loseContext() {
				this._glFrameBuffer = null;
				this._glDepthBuffer = null;
				this._glResolveFrameBuffer = null;
				this._glMsaaColorBuffers.length = 0;
				this._glMsaaDepthBuffer = null;
				this.msaaDepthBufferKey = undefined;
				this.colorMrtFramebuffers = null;
				this.suppliedColorFramebuffer = undefined;
				this._isInitialized = false;
		}
		internalResolve(device, src, dst, target, mask) {
				device.setScissor(0, 0, target.width, target.height);
				var gl = device.gl;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
				gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, mask, gl.NEAREST);
		}
		resolve(device, target, color, depth) {
				var gl = device.gl;
				if (this.colorMrtFramebuffers) {
						if (color) {
								for(var i = 0; i < this.colorMrtFramebuffers.length; i++){
										var fbPair = this.colorMrtFramebuffers[i];
										this.internalResolve(device, fbPair.msaaFB, fbPair.resolveFB, target, gl.COLOR_BUFFER_BIT);
								}
						}
						if (depth) {
								this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, gl.DEPTH_BUFFER_BIT);
						}
				} else {
						this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0));
				}
				gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
		}
		constructor(){
				this._glFrameBuffer = null;
				this._glDepthBuffer = null;
				this._glResolveFrameBuffer = null;
				this.colorMrtFramebuffers = null;
				this._glMsaaColorBuffers = [];
				this._glMsaaDepthBuffer = null;
				this._isInitialized = false;
		}
}

class FrameQueriesInfo {
		destroy(gl) {
				this.queries.forEach((query)=>gl.deleteQuery(query));
				this.queries = null;
		}
		constructor(){
				this.queries = [];
		}
}
class WebglGpuProfiler extends GpuProfiler {
		destroy() {
				this.freeQueries.forEach((query)=>this.device.gl.deleteQuery(query));
				this.frameQueries.forEach((query)=>this.device.gl.deleteQuery(query));
				this.previousFrameQueries.forEach((frameQueriesInfo)=>frameQueriesInfo.destroy(this.device.gl));
				this.freeQueries = null;
				this.frameQueries = null;
				this.previousFrameQueries = null;
		}
		loseContext() {
				super.loseContext();
				this.freeQueries = [];
				this.frameQueries = [];
				this.previousFrameQueries = [];
		}
		restoreContext() {
				this.ext = this.device.extDisjointTimerQuery;
		}
		getQuery() {
				var _this_freeQueries_pop;
				return (_this_freeQueries_pop = this.freeQueries.pop()) != null ? _this_freeQueries_pop : this.device.gl.createQuery();
		}
		start(name) {
				if (this.ext) {
						var slot = this.getSlot(name);
						var query = this.getQuery();
						this.frameQueries[slot] = query;
						this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
						return slot;
				}
				return undefined;
		}
		end(slot) {
				if (slot !== undefined) {
						this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
				}
		}
		frameStart() {
				this.processEnableRequest();
				if (this._enabled) {
						this.frameGPUMarkerSlot = this.start('GpuFrame');
				}
		}
		frameEnd() {
				if (this._enabled) {
						this.end(this.frameGPUMarkerSlot);
				}
		}
		request() {
				if (this._enabled) {
						var ext = this.ext;
						var gl = this.device.gl;
						var renderVersion = this.device.renderVersion;
						var frameQueries = this.frameQueries;
						if (frameQueries.length > 0) {
								this.frameQueries = [];
								var frameQueriesInfo = new FrameQueriesInfo();
								frameQueriesInfo.queries = frameQueries;
								frameQueriesInfo.renderVersion = renderVersion;
								this.previousFrameQueries.push(frameQueriesInfo);
						}
						if (this.previousFrameQueries.length > 0) {
								var previousQueriesInfo = this.previousFrameQueries[0];
								var previousQueries = previousQueriesInfo.queries;
								var lastQuery = previousQueries[previousQueries.length - 1];
								var available = gl.getQueryParameter(lastQuery, gl.QUERY_RESULT_AVAILABLE);
								var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
								if (available && !disjoint) {
										this.previousFrameQueries.shift();
										var timings = this.timings;
										timings.length = 0;
										for(var i = 0; i < previousQueries.length; i++){
												var query = previousQueries[i];
												var duration = gl.getQueryParameter(query, gl.QUERY_RESULT);
												timings[i] = duration * 0.000001;
												this.freeQueries.push(query);
										}
										this.report(previousQueriesInfo.renderVersion, timings);
								}
								if (disjoint) {
										this.previousFrameQueries.forEach((frameQueriesInfo)=>{
												this.report(frameQueriesInfo.renderVersion, null);
												frameQueriesInfo.destroy(gl);
										});
										this.previousFrameQueries.length = 0;
								}
						}
						super.request(renderVersion);
				}
		}
		constructor(device){
				super(), this.freeQueries = [], this.frameQueries = [], this.previousFrameQueries = [], this.timings = [];
				this.device = device;
				this.ext = device.extDisjointTimerQuery;
		}
}

function asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, key, arg) {
		try {
				var info = gen[key](arg);
				var value = info.value;
		} catch (error) {
				reject(error);
				return;
		}
		if (info.done) {
				resolve(value);
		} else {
				Promise.resolve(value).then(_next, _throw);
		}
}
function _async_to_generator$4(fn) {
		return function() {
				var self = this, args = arguments;
				return new Promise(function(resolve, reject) {
						var gen = fn.apply(self, args);
						function _next(value) {
								asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, "next", value);
						}
						function _throw(err) {
								asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, "throw", err);
						}
						_next(undefined);
				});
		};
}
var invalidateAttachments = [];
class WebglGraphicsDevice extends GraphicsDevice {
		postInit() {
				super.postInit();
				this.gpuProfiler = new WebglGpuProfiler(this);
		}
		destroy() {
				super.destroy();
				var gl = this.gl;
				if (this.feedback) {
						gl.deleteTransformFeedback(this.feedback);
				}
				this.clearVertexArrayObjectCache();
				this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
				this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
				this._contextLostHandler = null;
				this._contextRestoredHandler = null;
				this.gl = null;
				super.postDestroy();
		}
		createBackbuffer(frameBuffer) {
				this.supportsStencil = this.initOptions.stencil;
				this.backBuffer = new RenderTarget({
						name: 'WebglFramebuffer',
						graphicsDevice: this,
						depth: this.initOptions.depth,
						stencil: this.supportsStencil,
						samples: this.samples
				});
				this.backBuffer.impl.suppliedColorFramebuffer = frameBuffer;
		}
		updateBackbufferFormat(framebuffer) {
				var gl = this.gl;
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				var alphaBits = this.gl.getParameter(this.gl.ALPHA_BITS);
				this.backBufferFormat = alphaBits ? PIXELFORMAT_RGBA8 : PIXELFORMAT_RGB8;
		}
		updateBackbuffer() {
				var resolutionChanged = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;
				if (this._defaultFramebufferChanged || resolutionChanged) {
						if (this._defaultFramebufferChanged) {
								this.updateBackbufferFormat(this._defaultFramebuffer);
						}
						this._defaultFramebufferChanged = false;
						this.backBufferSize.set(this.canvas.width, this.canvas.height);
						this.backBuffer.destroy();
						this.createBackbuffer(this._defaultFramebuffer);
				}
		}
		createVertexBufferImpl(vertexBuffer, format) {
				return new WebglVertexBuffer();
		}
		createIndexBufferImpl(indexBuffer) {
				return new WebglIndexBuffer(indexBuffer);
		}
		createShaderImpl(shader) {
				return new WebglShader(shader);
		}
		createTextureImpl(texture) {
				return new WebglTexture(texture);
		}
		createRenderTargetImpl(renderTarget) {
				return new WebglRenderTarget();
		}
		getPrecision() {
				var gl = this.gl;
				var precision = 'highp';
				if (gl.getShaderPrecisionFormat) {
						var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
						var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
						var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
						var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
						if (vertexShaderPrecisionHighpFloat && vertexShaderPrecisionMediumpFloat && fragmentShaderPrecisionHighpFloat && fragmentShaderPrecisionMediumpFloat) {
								var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
								var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
								if (!highpAvailable) {
										if (mediumpAvailable) {
												precision = 'mediump';
										} else {
												precision = 'lowp';
										}
								}
						}
				}
				return precision;
		}
		getExtension() {
				for(var i = 0; i < arguments.length; i++){
						if (this.supportedExtensions.indexOf(arguments[i]) !== -1) {
								return this.gl.getExtension(arguments[i]);
						}
				}
				return null;
		}
		get extDisjointTimerQuery() {
				if (!this._extDisjointTimerQuery) {
						this._extDisjointTimerQuery = this.getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
				}
				return this._extDisjointTimerQuery;
		}
		initializeExtensions() {
				var gl = this.gl;
				var _gl_getSupportedExtensions;
				this.supportedExtensions = (_gl_getSupportedExtensions = gl.getSupportedExtensions()) != null ? _gl_getSupportedExtensions : [];
				this._extDisjointTimerQuery = null;
				this.textureRG11B10Renderable = true;
				this.extColorBufferFloat = this.getExtension('EXT_color_buffer_float');
				this.textureFloatRenderable = !!this.extColorBufferFloat;
				this.extColorBufferHalfFloat = this.getExtension('EXT_color_buffer_half_float');
				this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat || !!this.extColorBufferFloat;
				this.extDebugRendererInfo = this.getExtension('WEBGL_debug_renderer_info');
				this.extTextureFloatLinear = this.getExtension('OES_texture_float_linear');
				this.textureFloatFilterable = !!this.extTextureFloatLinear;
				this.extFloatBlend = this.getExtension('EXT_float_blend');
				this.extTextureFilterAnisotropic = this.getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
				this.extParallelShaderCompile = this.getExtension('KHR_parallel_shader_compile');
				this.extCompressedTextureETC1 = this.getExtension('WEBGL_compressed_texture_etc1');
				this.extCompressedTextureETC = this.getExtension('WEBGL_compressed_texture_etc');
				this.extCompressedTexturePVRTC = this.getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
				this.extCompressedTextureS3TC = this.getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
				this.extCompressedTextureS3TC_SRGB = this.getExtension('WEBGL_compressed_texture_s3tc_srgb');
				this.extCompressedTextureATC = this.getExtension('WEBGL_compressed_texture_atc');
				this.extCompressedTextureASTC = this.getExtension('WEBGL_compressed_texture_astc');
				this.extTextureCompressionBPTC = this.getExtension('EXT_texture_compression_bptc');
		}
		initializeCapabilities() {
				var gl = this.gl;
				var ext;
				var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';
				this.maxPrecision = this.precision = this.getPrecision();
				var contextAttribs = gl.getContextAttributes();
				var _contextAttribs_antialias;
				this.supportsMsaa = (_contextAttribs_antialias = contextAttribs == null ? void 0 : contextAttribs.antialias) != null ? _contextAttribs_antialias : false;
				var _contextAttribs_stencil;
				this.supportsStencil = (_contextAttribs_stencil = contextAttribs == null ? void 0 : contextAttribs.stencil) != null ? _contextAttribs_stencil : false;
				this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
				this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
				this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
				this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
				this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
				this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
				this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
				this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
				this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
				this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
				ext = this.extDebugRendererInfo;
				this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
				this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
				var maliRendererRegex = /\bMali-G52+/;
				var samsungModelRegex = /SM-[a-zA-Z0-9]+/;
				this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex)) && !this.unmaskedRenderer.match(maliRendererRegex);
				ext = this.extTextureFilterAnisotropic;
				this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
				var antialiasSupported = !this.forceDisableMultisampling;
				this.maxSamples = antialiasSupported ? gl.getParameter(gl.MAX_SAMPLES) : 1;
				this.maxSamples = Math.min(this.maxSamples, 4);
				this.samples = antialiasSupported && this.backBufferAntialias ? this.maxSamples : 1;
				this.supportsAreaLights = !platform.android;
				if (this.maxTextures <= 8) {
						this.supportsAreaLights = false;
				}
				this.initCapsDefines();
		}
		initializeRenderState() {
				super.initializeRenderState();
				var gl = this.gl;
				gl.disable(gl.BLEND);
				gl.blendFunc(gl.ONE, gl.ZERO);
				gl.blendEquation(gl.FUNC_ADD);
				gl.colorMask(true, true, true, true);
				gl.blendColor(0, 0, 0, 0);
				gl.enable(gl.CULL_FACE);
				this.cullFace = gl.BACK;
				gl.cullFace(gl.BACK);
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				gl.depthMask(true);
				this.stencil = false;
				gl.disable(gl.STENCIL_TEST);
				this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
				this.stencilRefFront = this.stencilRefBack = 0;
				this.stencilMaskFront = this.stencilMaskBack = 0xFF;
				gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
				this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
				this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
				this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
				this.stencilWriteMaskFront = 0xFF;
				this.stencilWriteMaskBack = 0xFF;
				gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
				gl.stencilMask(0xFF);
				this.alphaToCoverage = false;
				this.raster = true;
				gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
				gl.disable(gl.RASTERIZER_DISCARD);
				this.depthBiasEnabled = false;
				gl.disable(gl.POLYGON_OFFSET_FILL);
				this.clearDepth = 1;
				gl.clearDepth(1);
				this.clearColor = new Color(0, 0, 0, 0);
				gl.clearColor(0, 0, 0, 0);
				this.clearStencil = 0;
				gl.clearStencil(0);
				gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
				gl.enable(gl.SCISSOR_TEST);
				gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
				this.unpackFlipY = false;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				this.unpackPremultiplyAlpha = false;
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
				gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		}
		initTextureUnits(count) {
				if (count === void 0) count = 16;
				this.textureUnits = [];
				for(var i = 0; i < count; i++){
						this.textureUnits.push([
								null,
								null,
								null
						]);
				}
		}
		initializeContextCaches() {
				super.initializeContextCaches();
				this._vaoMap = new Map();
				this.boundVao = null;
				this.activeFramebuffer = null;
				this.feedback = null;
				this.transformFeedbackBuffer = null;
				this.textureUnit = 0;
				this.initTextureUnits(this.maxCombinedTextures);
		}
		loseContext() {
				super.loseContext();
				for (var shader of this.shaders){
						shader.loseContext();
				}
		}
		restoreContext() {
				this.initializeExtensions();
				this.initializeCapabilities();
				super.restoreContext();
				for (var shader of this.shaders){
						shader.restoreContext();
				}
		}
		setViewport(x, y, w, h) {
				if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
						this.gl.viewport(x, y, w, h);
						this.vx = x;
						this.vy = y;
						this.vw = w;
						this.vh = h;
				}
		}
		setScissor(x, y, w, h) {
				if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
						this.gl.scissor(x, y, w, h);
						this.sx = x;
						this.sy = y;
						this.sw = w;
						this.sh = h;
				}
		}
		setFramebuffer(fb) {
				if (this.activeFramebuffer !== fb) {
						var gl = this.gl;
						gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
						this.activeFramebuffer = fb;
				}
		}
		copyRenderTarget(source, dest, color, depth) {
				var _this_backBuffer, _this_backBuffer1;
				var gl = this.gl;
				if (source === this.backBuffer) {
						source = null;
				}
				if (color) {
						if (!dest) {
								if (!source._colorBuffer) {
										return false;
								}
						} else if (source) {
								if (!source._colorBuffer || !dest._colorBuffer) {
										return false;
								}
								if (source._colorBuffer._format !== dest._colorBuffer._format) {
										return false;
								}
						}
				}
				if (depth && source) {
						if (!source._depth) {
								if (!source._depthBuffer || !dest._depthBuffer) {
										return false;
								}
								if (source._depthBuffer._format !== dest._depthBuffer._format) {
										return false;
								}
						}
				}
				var prevRt = this.renderTarget;
				this.renderTarget = dest;
				this.updateBegin();
				var src = source ? source.impl._glFrameBuffer : (_this_backBuffer = this.backBuffer) == null ? void 0 : _this_backBuffer.impl._glFrameBuffer;
				var dst = dest ? dest.impl._glFrameBuffer : (_this_backBuffer1 = this.backBuffer) == null ? void 0 : _this_backBuffer1.impl._glFrameBuffer;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
				var w = source ? source.width : dest ? dest.width : this.width;
				var h = source ? source.height : dest ? dest.height : this.height;
				gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
				this.renderTarget = prevRt;
				gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
				return true;
		}
		frameStart() {
				super.frameStart();
				this.updateBackbuffer();
				this.gpuProfiler.frameStart();
		}
		frameEnd() {
				super.frameEnd();
				this.gpuProfiler.frameEnd();
				this.gpuProfiler.request();
		}
		startRenderPass(renderPass) {
				var _renderPass_renderTarget;
				var rt = (_renderPass_renderTarget = renderPass.renderTarget) != null ? _renderPass_renderTarget : this.backBuffer;
				this.renderTarget = rt;
				this.updateBegin();
				var { width, height } = rt;
				this.setViewport(0, 0, width, height);
				this.setScissor(0, 0, width, height);
				var colorOps = renderPass.colorOps;
				var depthStencilOps = renderPass.depthStencilOps;
				if ((colorOps == null ? void 0 : colorOps.clear) || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {
						var clearFlags = 0;
						var clearOptions = {};
						if (colorOps == null ? void 0 : colorOps.clear) {
								clearFlags |= CLEARFLAG_COLOR;
								clearOptions.color = [
										colorOps.clearValue.r,
										colorOps.clearValue.g,
										colorOps.clearValue.b,
										colorOps.clearValue.a
								];
						}
						if (depthStencilOps.clearDepth) {
								clearFlags |= CLEARFLAG_DEPTH;
								clearOptions.depth = depthStencilOps.clearDepthValue;
						}
						if (depthStencilOps.clearStencil) {
								clearFlags |= CLEARFLAG_STENCIL;
								clearOptions.stencil = depthStencilOps.clearStencilValue;
						}
						clearOptions.flags = clearFlags;
						this.clear(clearOptions);
				}
				this.insideRenderPass = true;
		}
		endRenderPass(renderPass) {
				this.unbindVertexArray();
				var target = this.renderTarget;
				var colorBufferCount = renderPass.colorArrayOps.length;
				if (target) {
						var _renderPass_colorOps;
						invalidateAttachments.length = 0;
						var gl = this.gl;
						for(var i = 0; i < colorBufferCount; i++){
								var colorOps = renderPass.colorArrayOps[i];
								if (!(colorOps.store || colorOps.resolve)) {
										invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + i);
								}
						}
						if (target !== this.backBuffer) {
								if (!renderPass.depthStencilOps.storeDepth) {
										invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
								}
								if (!renderPass.depthStencilOps.storeStencil) {
										invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
								}
						}
						if (invalidateAttachments.length > 0) {
								if (renderPass.fullSizeClearRect) {
										gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);
								}
						}
						if (colorBufferCount && ((_renderPass_colorOps = renderPass.colorOps) == null ? void 0 : _renderPass_colorOps.resolve)) {
								if (renderPass.samples > 1 && target.autoResolve) {
										target.resolve(true, false);
								}
						}
						if (target.depthBuffer && renderPass.depthStencilOps.resolveDepth) {
								if (renderPass.samples > 1 && target.autoResolve) {
										target.resolve(false, true);
								}
						}
						for(var i1 = 0; i1 < colorBufferCount; i1++){
								var colorOps1 = renderPass.colorArrayOps[i1];
								if (colorOps1.genMipmaps) {
										var colorBuffer = target._colorBuffers[i1];
										if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
												this.activeTexture(this.maxCombinedTextures - 1);
												this.bindTexture(colorBuffer);
												this.gl.generateMipmap(colorBuffer.impl._glTarget);
										}
								}
						}
				}
				this.insideRenderPass = false;
		}
		set defaultFramebuffer(value) {
				if (this._defaultFramebuffer !== value) {
						this._defaultFramebuffer = value;
						this._defaultFramebufferChanged = true;
				}
		}
		get defaultFramebuffer() {
				return this._defaultFramebuffer;
		}
		updateBegin() {
				this.boundVao = null;
				if (this._tempEnableSafariTextureUnitWorkaround) {
						for(var unit = 0; unit < this.textureUnits.length; ++unit){
								for(var slot = 0; slot < 3; ++slot){
										this.textureUnits[unit][slot] = null;
								}
						}
				}
				var _this_renderTarget;
				var target = (_this_renderTarget = this.renderTarget) != null ? _this_renderTarget : this.backBuffer;
				var targetImpl = target.impl;
				if (!targetImpl.initialized) {
						this.initRenderTarget(target);
				}
				this.setFramebuffer(targetImpl._glFrameBuffer);
		}
		updateEnd() {
				this.unbindVertexArray();
				var target = this.renderTarget;
				if (target && target !== this.backBuffer) {
						if (target._samples > 1 && target.autoResolve) {
								target.resolve();
						}
						var colorBuffer = target._colorBuffer;
						if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
								this.activeTexture(this.maxCombinedTextures - 1);
								this.bindTexture(colorBuffer);
								this.gl.generateMipmap(colorBuffer.impl._glTarget);
						}
				}
		}
		setUnpackFlipY(flipY) {
				if (this.unpackFlipY !== flipY) {
						this.unpackFlipY = flipY;
						var gl = this.gl;
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
				}
		}
		setUnpackPremultiplyAlpha(premultiplyAlpha) {
				if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
						this.unpackPremultiplyAlpha = premultiplyAlpha;
						var gl = this.gl;
						gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
				}
		}
		activeTexture(textureUnit) {
				if (this.textureUnit !== textureUnit) {
						this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
						this.textureUnit = textureUnit;
				}
		}
		bindTexture(texture) {
				var impl = texture.impl;
				var textureTarget = impl._glTarget;
				var textureObject = impl._glTexture;
				var textureUnit = this.textureUnit;
				var slot = this.targetToSlot[textureTarget];
				if (this.textureUnits[textureUnit][slot] !== textureObject) {
						this.gl.bindTexture(textureTarget, textureObject);
						this.textureUnits[textureUnit][slot] = textureObject;
				}
		}
		bindTextureOnUnit(texture, textureUnit) {
				var impl = texture.impl;
				var textureTarget = impl._glTarget;
				var textureObject = impl._glTexture;
				var slot = this.targetToSlot[textureTarget];
				if (this.textureUnits[textureUnit][slot] !== textureObject) {
						this.activeTexture(textureUnit);
						this.gl.bindTexture(textureTarget, textureObject);
						this.textureUnits[textureUnit][slot] = textureObject;
				}
		}
		setTextureParameters(texture) {
				var gl = this.gl;
				var flags = texture.impl.dirtyParameterFlags;
				var target = texture.impl._glTarget;
				if (flags & TEXPROPERTY_MIN_FILTER) {
						var filter = texture._minFilter;
						if (!texture._mipmaps || texture._compressed && texture._levels.length === 1) {
								if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
										filter = FILTER_NEAREST;
								} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
										filter = FILTER_LINEAR;
								}
						}
						gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
				}
				if (flags & TEXPROPERTY_MAG_FILTER) {
						gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
				}
				if (flags & TEXPROPERTY_ADDRESS_U) {
						gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
				}
				if (flags & TEXPROPERTY_ADDRESS_V) {
						gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
				}
				if (flags & TEXPROPERTY_ADDRESS_W) {
						gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
				}
				if (flags & TEXPROPERTY_COMPARE_ON_READ) {
						gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
				}
				if (flags & TEXPROPERTY_COMPARE_FUNC) {
						gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
				}
				if (flags & TEXPROPERTY_ANISOTROPY) {
						var ext = this.extTextureFilterAnisotropic;
						if (ext) {
								gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, math.clamp(Math.round(texture._anisotropy), 1, this.maxAnisotropy));
						}
				}
		}
		setTexture(texture, textureUnit) {
				var impl = texture.impl;
				if (!impl._glTexture) {
						impl.initialize(this, texture);
				}
				if (impl.dirtyParameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
						this.activeTexture(textureUnit);
						this.bindTexture(texture);
						if (impl.dirtyParameterFlags) {
								this.setTextureParameters(texture);
								impl.dirtyParameterFlags = 0;
						}
						if (texture._needsUpload || texture._needsMipmapsUpload) {
								impl.upload(this, texture);
								texture._needsUpload = false;
								texture._needsMipmapsUpload = false;
						}
				} else {
						this.bindTextureOnUnit(texture, textureUnit);
				}
		}
		createVertexArray(vertexBuffers) {
				var key, vao;
				var useCache = vertexBuffers.length > 1;
				if (useCache) {
						key = '';
						for(var i = 0; i < vertexBuffers.length; i++){
								var vertexBuffer = vertexBuffers[i];
								key += vertexBuffer.id + vertexBuffer.format.renderingHash;
						}
						vao = this._vaoMap.get(key);
				}
				if (!vao) {
						var gl = this.gl;
						vao = gl.createVertexArray();
						gl.bindVertexArray(vao);
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
						for(var i1 = 0; i1 < vertexBuffers.length; i1++){
								var vertexBuffer1 = vertexBuffers[i1];
								gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer1.impl.bufferId);
								var elements = vertexBuffer1.format.elements;
								for(var j = 0; j < elements.length; j++){
										var e = elements[j];
										var loc = semanticToLocation[e.name];
										if (e.asInt) {
												gl.vertexAttribIPointer(loc, e.numComponents, this.glType[e.dataType], e.stride, e.offset);
										} else {
												gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
										}
										gl.enableVertexAttribArray(loc);
										if (vertexBuffer1.format.instancing) {
												gl.vertexAttribDivisor(loc, 1);
										}
								}
						}
						gl.bindVertexArray(null);
						gl.bindBuffer(gl.ARRAY_BUFFER, null);
						if (useCache) {
								this._vaoMap.set(key, vao);
						}
				}
				return vao;
		}
		unbindVertexArray() {
				if (this.boundVao) {
						this.boundVao = null;
						this.gl.bindVertexArray(null);
				}
		}
		setBuffers() {
				var gl = this.gl;
				var vao;
				if (this.vertexBuffers.length === 1) {
						var vertexBuffer = this.vertexBuffers[0];
						if (!vertexBuffer.impl.vao) {
								vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
						}
						vao = vertexBuffer.impl.vao;
				} else {
						vao = this.createVertexArray(this.vertexBuffers);
				}
				if (this.boundVao !== vao) {
						this.boundVao = vao;
						gl.bindVertexArray(vao);
				}
				this.clearVertexBuffer();
				var bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
		}
		draw(primitive, numInstances, keepBuffers) {
				var gl = this.gl;
				this.activateShader(this);
				if (!this.shaderValid) {
						return;
				}
				var sampler, samplerValue, texture, numTextures;
				var uniform, scopeId, uniformVersion, programVersion;
				var shader = this.shader;
				if (!shader) {
						return;
				}
				var samplers = shader.impl.samplers;
				var uniforms = shader.impl.uniforms;
				if (!keepBuffers) {
						this.setBuffers();
				}
				var textureUnit = 0;
				for(var i = 0, len = samplers.length; i < len; i++){
						sampler = samplers[i];
						samplerValue = sampler.scopeId.value;
						if (!samplerValue) {
								var samplerName = sampler.scopeId.name;
								if (samplerName === 'uSceneDepthMap') {
										samplerValue = getBuiltInTexture(this, 'white');
								}
								if (samplerName === 'uSceneColorMap') {
										samplerValue = getBuiltInTexture(this, 'pink');
								}
								if (!samplerValue) {
										samplerValue = getBuiltInTexture(this, 'pink');
								}
						}
						if (samplerValue instanceof Texture) {
								texture = samplerValue;
								this.setTexture(texture, textureUnit);
								if (sampler.slot !== textureUnit) {
										gl.uniform1i(sampler.locationId, textureUnit);
										sampler.slot = textureUnit;
								}
								textureUnit++;
						} else {
								sampler.array.length = 0;
								numTextures = samplerValue.length;
								for(var j = 0; j < numTextures; j++){
										texture = samplerValue[j];
										this.setTexture(texture, textureUnit);
										sampler.array[j] = textureUnit;
										textureUnit++;
								}
								gl.uniform1iv(sampler.locationId, sampler.array);
						}
				}
				for(var i1 = 0, len1 = uniforms.length; i1 < len1; i1++){
						uniform = uniforms[i1];
						scopeId = uniform.scopeId;
						uniformVersion = uniform.version;
						programVersion = scopeId.versionObject.version;
						if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
								uniformVersion.globalId = programVersion.globalId;
								uniformVersion.revision = programVersion.revision;
								if (scopeId.value !== null) {
										this.commitFunction[uniform.dataType](uniform, scopeId.value);
								}
						}
				}
				if (this.transformFeedbackBuffer) {
						gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
						gl.beginTransformFeedback(gl.POINTS);
				}
				var mode = this.glPrimitive[primitive.type];
				var count = primitive.count;
				if (primitive.indexed) {
						var indexBuffer = this.indexBuffer;
						var format = indexBuffer.impl.glFormat;
						var offset = primitive.base * indexBuffer.bytesPerIndex;
						if (numInstances > 0) {
								gl.drawElementsInstanced(mode, count, format, offset, numInstances);
						} else {
								gl.drawElements(mode, count, format, offset);
						}
				} else {
						var first = primitive.base;
						if (numInstances > 0) {
								gl.drawArraysInstanced(mode, first, count, numInstances);
						} else {
								gl.drawArrays(mode, first, count);
						}
				}
				if (this.transformFeedbackBuffer) {
						gl.endTransformFeedback();
						gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
				}
				this._drawCallsPerFrame++;
		}
		clear(options) {
				var defaultOptions = this.defaultClearOptions;
				options = options || defaultOptions;
				var _options_flags;
				var flags = (_options_flags = options.flags) != null ? _options_flags : defaultOptions.flags;
				if (flags !== 0) {
						var gl = this.gl;
						if (flags & CLEARFLAG_COLOR) {
								var _options_color;
								var color = (_options_color = options.color) != null ? _options_color : defaultOptions.color;
								var r = color[0];
								var g = color[1];
								var b = color[2];
								var a = color[3];
								var c = this.clearColor;
								if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
										this.gl.clearColor(r, g, b, a);
										this.clearColor.set(r, g, b, a);
								}
								this.setBlendState(BlendState.NOBLEND);
						}
						if (flags & CLEARFLAG_DEPTH) {
								var _options_depth;
								var depth = (_options_depth = options.depth) != null ? _options_depth : defaultOptions.depth;
								if (depth !== this.clearDepth) {
										this.gl.clearDepth(depth);
										this.clearDepth = depth;
								}
								this.setDepthState(DepthState.WRITEDEPTH);
						}
						if (flags & CLEARFLAG_STENCIL) {
								var _options_stencil;
								var stencil = (_options_stencil = options.stencil) != null ? _options_stencil : defaultOptions.stencil;
								if (stencil !== this.clearStencil) {
										this.gl.clearStencil(stencil);
										this.clearStencil = stencil;
								}
								gl.stencilMask(0xFF);
								this.stencilWriteMaskFront = 0xFF;
								this.stencilWriteMaskBack = 0xFF;
						}
						gl.clear(this.glClearFlag[flags]);
				}
		}
		submit() {
				this.gl.flush();
		}
		readPixels(x, y, w, h, pixels) {
				var gl = this.gl;
				gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		}
		readPixelsAsync(x, y, w, h, pixels) {
				var _this = this;
				return _async_to_generator$4(function*() {
						var _this_renderTarget_colorBuffer;
						var gl = _this.gl;
						var clientWaitAsync = (flags, interval_ms)=>{
								var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
								_this.submit();
								return new Promise((resolve, reject)=>{
										function test() {
												var res = gl.clientWaitSync(sync, flags, 0);
												if (res === gl.WAIT_FAILED) {
														gl.deleteSync(sync);
														reject(new Error('webgl clientWaitSync sync failed'));
												} else if (res === gl.TIMEOUT_EXPIRED) {
														setTimeout(test, interval_ms);
												} else {
														gl.deleteSync(sync);
														resolve();
												}
										}
										test();
								});
						};
						var impl = (_this_renderTarget_colorBuffer = _this.renderTarget.colorBuffer) == null ? void 0 : _this_renderTarget_colorBuffer.impl;
						var _impl__glFormat;
						var format = (_impl__glFormat = impl == null ? void 0 : impl._glFormat) != null ? _impl__glFormat : gl.RGBA;
						var _impl__glPixelType;
						var pixelType = (_impl__glPixelType = impl == null ? void 0 : impl._glPixelType) != null ? _impl__glPixelType : gl.UNSIGNED_BYTE;
						var buf = gl.createBuffer();
						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
						gl.bufferData(gl.PIXEL_PACK_BUFFER, pixels.byteLength, gl.STREAM_READ);
						gl.readPixels(x, y, w, h, format, pixelType, 0);
						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
						yield clientWaitAsync(0, 20);
						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
						gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, pixels);
						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
						gl.deleteBuffer(buf);
						return pixels;
				})();
		}
		readTextureAsync(texture, x, y, width, height, options) {
				var _options_face;
				var face = (_options_face = options.face) != null ? _options_face : 0;
				var _options_renderTarget;
				var renderTarget = (_options_renderTarget = options.renderTarget) != null ? _options_renderTarget : new RenderTarget({
						colorBuffer: texture,
						depth: false,
						face: face
				});
				var buffer = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, 1, texture._format));
				var _options_data;
				var data = (_options_data = options.data) != null ? _options_data : new (getPixelFormatArrayType(texture._format))(buffer);
				this.setRenderTarget(renderTarget);
				this.initRenderTarget(renderTarget);
				return new Promise((resolve, reject)=>{
						this.readPixelsAsync(x, y, width, height, data).then((data)=>{
								if (!options.renderTarget) {
										renderTarget.destroy();
								}
								resolve(data);
						}).catch(reject);
				});
		}
		setAlphaToCoverage(state) {
				if (this.alphaToCoverage !== state) {
						this.alphaToCoverage = state;
						if (state) {
								this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
						} else {
								this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
						}
				}
		}
		setTransformFeedbackBuffer(tf) {
				if (this.transformFeedbackBuffer !== tf) {
						this.transformFeedbackBuffer = tf;
						var gl = this.gl;
						if (tf) {
								if (!this.feedback) {
										this.feedback = gl.createTransformFeedback();
								}
								gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
						} else {
								gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
						}
				}
		}
		setRaster(on) {
				if (this.raster !== on) {
						this.raster = on;
						if (on) {
								this.gl.disable(this.gl.RASTERIZER_DISCARD);
						} else {
								this.gl.enable(this.gl.RASTERIZER_DISCARD);
						}
				}
		}
		setStencilTest(enable) {
				if (this.stencil !== enable) {
						var gl = this.gl;
						if (enable) {
								gl.enable(gl.STENCIL_TEST);
						} else {
								gl.disable(gl.STENCIL_TEST);
						}
						this.stencil = enable;
				}
		}
		setStencilFunc(func, ref, mask) {
				if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
						this.gl.stencilFunc(this.glComparison[func], ref, mask);
						this.stencilFuncFront = this.stencilFuncBack = func;
						this.stencilRefFront = this.stencilRefBack = ref;
						this.stencilMaskFront = this.stencilMaskBack = mask;
				}
		}
		setStencilFuncFront(func, ref, mask) {
				if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
						var gl = this.gl;
						gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
						this.stencilFuncFront = func;
						this.stencilRefFront = ref;
						this.stencilMaskFront = mask;
				}
		}
		setStencilFuncBack(func, ref, mask) {
				if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
						var gl = this.gl;
						gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
						this.stencilFuncBack = func;
						this.stencilRefBack = ref;
						this.stencilMaskBack = mask;
				}
		}
		setStencilOperation(fail, zfail, zpass, writeMask) {
				if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
						this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
						this.stencilFailFront = this.stencilFailBack = fail;
						this.stencilZfailFront = this.stencilZfailBack = zfail;
						this.stencilZpassFront = this.stencilZpassBack = zpass;
				}
				if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
						this.gl.stencilMask(writeMask);
						this.stencilWriteMaskFront = writeMask;
						this.stencilWriteMaskBack = writeMask;
				}
		}
		setStencilOperationFront(fail, zfail, zpass, writeMask) {
				if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
						this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
						this.stencilFailFront = fail;
						this.stencilZfailFront = zfail;
						this.stencilZpassFront = zpass;
				}
				if (this.stencilWriteMaskFront !== writeMask) {
						this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
						this.stencilWriteMaskFront = writeMask;
				}
		}
		setStencilOperationBack(fail, zfail, zpass, writeMask) {
				if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
						this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
						this.stencilFailBack = fail;
						this.stencilZfailBack = zfail;
						this.stencilZpassBack = zpass;
				}
				if (this.stencilWriteMaskBack !== writeMask) {
						this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
						this.stencilWriteMaskBack = writeMask;
				}
		}
		setBlendState(blendState) {
				var currentBlendState = this.blendState;
				if (!currentBlendState.equals(blendState)) {
						var gl = this.gl;
						var { blend, colorOp, alphaOp, colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor } = blendState;
						if (currentBlendState.blend !== blend) {
								if (blend) {
										gl.enable(gl.BLEND);
								} else {
										gl.disable(gl.BLEND);
								}
						}
						if (currentBlendState.colorOp !== colorOp || currentBlendState.alphaOp !== alphaOp) {
								var glBlendEquation = this.glBlendEquation;
								gl.blendEquationSeparate(glBlendEquation[colorOp], glBlendEquation[alphaOp]);
						}
						if (currentBlendState.colorSrcFactor !== colorSrcFactor || currentBlendState.colorDstFactor !== colorDstFactor || currentBlendState.alphaSrcFactor !== alphaSrcFactor || currentBlendState.alphaDstFactor !== alphaDstFactor) {
								gl.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor], this.glBlendFunctionColor[colorDstFactor], this.glBlendFunctionAlpha[alphaSrcFactor], this.glBlendFunctionAlpha[alphaDstFactor]);
						}
						if (currentBlendState.allWrite !== blendState.allWrite) {
								this.gl.colorMask(blendState.redWrite, blendState.greenWrite, blendState.blueWrite, blendState.alphaWrite);
						}
						currentBlendState.copy(blendState);
				}
		}
		setBlendColor(r, g, b, a) {
				var c = this.blendColor;
				if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
						this.gl.blendColor(r, g, b, a);
						c.set(r, g, b, a);
				}
		}
		setStencilState(stencilFront, stencilBack) {
				if (stencilFront || stencilBack) {
						this.setStencilTest(true);
						if (stencilFront === stencilBack) {
								this.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
								this.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
						} else {
								stencilFront != null ? stencilFront : stencilFront = StencilParameters.DEFAULT;
								this.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
								this.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
								stencilBack != null ? stencilBack : stencilBack = StencilParameters.DEFAULT;
								this.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
								this.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
						}
				} else {
						this.setStencilTest(false);
				}
		}
		setDepthState(depthState) {
				var currentDepthState = this.depthState;
				if (!currentDepthState.equals(depthState)) {
						var gl = this.gl;
						var write = depthState.write;
						if (currentDepthState.write !== write) {
								gl.depthMask(write);
						}
						var { func, test } = depthState;
						if (!test && write) {
								test = true;
								func = FUNC_ALWAYS;
						}
						if (currentDepthState.func !== func) {
								gl.depthFunc(this.glComparison[func]);
						}
						if (currentDepthState.test !== test) {
								if (test) {
										gl.enable(gl.DEPTH_TEST);
								} else {
										gl.disable(gl.DEPTH_TEST);
								}
						}
						var { depthBias, depthBiasSlope } = depthState;
						if (depthBias || depthBiasSlope) {
								if (!this.depthBiasEnabled) {
										this.depthBiasEnabled = true;
										this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
								}
								gl.polygonOffset(depthBiasSlope, depthBias);
						} else {
								if (this.depthBiasEnabled) {
										this.depthBiasEnabled = false;
										this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
								}
						}
						currentDepthState.copy(depthState);
				}
		}
		setCullMode(cullMode) {
				if (this.cullMode !== cullMode) {
						if (cullMode === CULLFACE_NONE) {
								this.gl.disable(this.gl.CULL_FACE);
						} else {
								if (this.cullMode === CULLFACE_NONE) {
										this.gl.enable(this.gl.CULL_FACE);
								}
								var mode = this.glCull[cullMode];
								if (this.cullFace !== mode) {
										this.gl.cullFace(mode);
										this.cullFace = mode;
								}
						}
						this.cullMode = cullMode;
				}
		}
		setShader(shader, asyncCompile) {
				if (asyncCompile === void 0) asyncCompile = false;
				if (shader !== this.shader) {
						this.shader = shader;
						this.shaderAsyncCompile = asyncCompile;
						this.shaderValid = undefined;
				}
		}
		activateShader(device) {
				var { shader } = this;
				var { impl } = shader;
				if (this.shaderValid === undefined) {
						if (shader.failed) {
								this.shaderValid = false;
						} else if (!shader.ready) {
								if (this.shaderAsyncCompile) {
										if (impl.isLinked(device)) {
												if (!impl.finalize(this, shader)) {
														shader.failed = true;
														this.shaderValid = false;
												}
										} else {
												this.shaderValid = false;
										}
								} else {
										if (!impl.finalize(this, shader)) {
												shader.failed = true;
												this.shaderValid = false;
										}
								}
						}
				}
				if (this.shaderValid === undefined) {
						this.gl.useProgram(impl.glProgram);
						this.shaderValid = true;
				}
		}
		clearVertexArrayObjectCache() {
				var gl = this.gl;
				this._vaoMap.forEach((item, key, mapObj)=>{
						gl.deleteVertexArray(item);
				});
				this._vaoMap.clear();
		}
		set fullscreen(fullscreen) {
				if (fullscreen) {
						var canvas = this.gl.canvas;
						canvas.requestFullscreen();
				} else {
						document.exitFullscreen();
				}
		}
		get fullscreen() {
				return !!document.fullscreenElement;
		}
		constructor(canvas, options = {}){
				super(canvas, options), this._defaultFramebuffer = null, this._defaultFramebufferChanged = false;
				options = this.initOptions;
				this.updateClientRect();
				this.initTextureUnits();
				this.contextLost = false;
				this._contextLostHandler = (event)=>{
						event.preventDefault();
						this.loseContext();
						this.fire('devicelost');
				};
				this._contextRestoredHandler = ()=>{
						this.restoreContext();
						this.fire('devicerestored');
				};
				var ua = typeof navigator !== 'undefined' && navigator.userAgent;
				this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));
				if (this.forceDisableMultisampling) {
						options.antialias = false;
				}
				if (platform.browserName === 'firefox') {
						var ua1 = typeof navigator !== 'undefined' ? navigator.userAgent : '';
						var match = ua1.match(/Firefox\/(\d+(\.\d+)*)/);
						var firefoxVersion = match ? match[1] : null;
						if (firefoxVersion) {
								var version = parseFloat(firefoxVersion);
								var disableAntialias = platform.name === 'windows' && (version >= 120 || version === 115) || platform.name === 'android' && version >= 132;
								if (disableAntialias) {
										options.antialias = false;
								}
						}
				}
				var _options_antialias;
				this.backBufferAntialias = (_options_antialias = options.antialias) != null ? _options_antialias : false;
				options.antialias = false;
				var _options_gl;
				var gl = (_options_gl = options.gl) != null ? _options_gl : canvas.getContext('webgl2', options);
				if (!gl) {
						throw new Error('WebGL not supported');
				}
				this.gl = gl;
				this.isWebGL2 = true;
				this._deviceType = DEVICETYPE_WEBGL2;
				this.updateBackbufferFormat(null);
				var isChrome = platform.browserName === 'chrome';
				var isSafari = platform.browserName === 'safari';
				var isMac = platform.browser && navigator.appVersion.indexOf('Mac') !== -1;
				this._tempEnableSafariTextureUnitWorkaround = isSafari;
				this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;
				canvas.addEventListener('webglcontextlost', this._contextLostHandler, false);
				canvas.addEventListener('webglcontextrestored', this._contextRestoredHandler, false);
				this.initializeExtensions();
				this.initializeCapabilities();
				this.initializeRenderState();
				this.initializeContextCaches();
				this.createBackbuffer(null);
				this.supportsImageBitmap = !isSafari && typeof ImageBitmap !== 'undefined';
				this._samplerTypes = new Set([
						gl.SAMPLER_2D,
						gl.SAMPLER_CUBE,
						gl.UNSIGNED_INT_SAMPLER_2D,
						gl.INT_SAMPLER_2D,
						gl.SAMPLER_2D_SHADOW,
						gl.SAMPLER_CUBE_SHADOW,
						gl.SAMPLER_3D,
						gl.INT_SAMPLER_3D,
						gl.UNSIGNED_INT_SAMPLER_3D,
						gl.SAMPLER_2D_ARRAY,
						gl.INT_SAMPLER_2D_ARRAY,
						gl.UNSIGNED_INT_SAMPLER_2D_ARRAY
				]);
				this.glAddress = [
						gl.REPEAT,
						gl.CLAMP_TO_EDGE,
						gl.MIRRORED_REPEAT
				];
				this.glBlendEquation = [
						gl.FUNC_ADD,
						gl.FUNC_SUBTRACT,
						gl.FUNC_REVERSE_SUBTRACT,
						gl.MIN,
						gl.MAX
				];
				this.glBlendFunctionColor = [
						gl.ZERO,
						gl.ONE,
						gl.SRC_COLOR,
						gl.ONE_MINUS_SRC_COLOR,
						gl.DST_COLOR,
						gl.ONE_MINUS_DST_COLOR,
						gl.SRC_ALPHA,
						gl.SRC_ALPHA_SATURATE,
						gl.ONE_MINUS_SRC_ALPHA,
						gl.DST_ALPHA,
						gl.ONE_MINUS_DST_ALPHA,
						gl.CONSTANT_COLOR,
						gl.ONE_MINUS_CONSTANT_COLOR
				];
				this.glBlendFunctionAlpha = [
						gl.ZERO,
						gl.ONE,
						gl.SRC_COLOR,
						gl.ONE_MINUS_SRC_COLOR,
						gl.DST_COLOR,
						gl.ONE_MINUS_DST_COLOR,
						gl.SRC_ALPHA,
						gl.SRC_ALPHA_SATURATE,
						gl.ONE_MINUS_SRC_ALPHA,
						gl.DST_ALPHA,
						gl.ONE_MINUS_DST_ALPHA,
						gl.CONSTANT_ALPHA,
						gl.ONE_MINUS_CONSTANT_ALPHA
				];
				this.glComparison = [
						gl.NEVER,
						gl.LESS,
						gl.EQUAL,
						gl.LEQUAL,
						gl.GREATER,
						gl.NOTEQUAL,
						gl.GEQUAL,
						gl.ALWAYS
				];
				this.glStencilOp = [
						gl.KEEP,
						gl.ZERO,
						gl.REPLACE,
						gl.INCR,
						gl.INCR_WRAP,
						gl.DECR,
						gl.DECR_WRAP,
						gl.INVERT
				];
				this.glClearFlag = [
						0,
						gl.COLOR_BUFFER_BIT,
						gl.DEPTH_BUFFER_BIT,
						gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
						gl.STENCIL_BUFFER_BIT,
						gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT,
						gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
						gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT
				];
				this.glCull = [
						0,
						gl.BACK,
						gl.FRONT,
						gl.FRONT_AND_BACK
				];
				this.glFilter = [
						gl.NEAREST,
						gl.LINEAR,
						gl.NEAREST_MIPMAP_NEAREST,
						gl.NEAREST_MIPMAP_LINEAR,
						gl.LINEAR_MIPMAP_NEAREST,
						gl.LINEAR_MIPMAP_LINEAR
				];
				this.glPrimitive = [
						gl.POINTS,
						gl.LINES,
						gl.LINE_LOOP,
						gl.LINE_STRIP,
						gl.TRIANGLES,
						gl.TRIANGLE_STRIP,
						gl.TRIANGLE_FAN
				];
				this.glType = [
						gl.BYTE,
						gl.UNSIGNED_BYTE,
						gl.SHORT,
						gl.UNSIGNED_SHORT,
						gl.INT,
						gl.UNSIGNED_INT,
						gl.FLOAT,
						gl.HALF_FLOAT
				];
				this.pcUniformType = {};
				this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
				this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
				this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
				this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
				this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
				this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
				this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
				this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
				this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
				this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
				this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
				this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
				this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
				this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
				this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
				this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
				this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
				this.pcUniformType[gl.UNSIGNED_INT] = UNIFORMTYPE_UINT;
				this.pcUniformType[gl.UNSIGNED_INT_VEC2] = UNIFORMTYPE_UVEC2;
				this.pcUniformType[gl.UNSIGNED_INT_VEC3] = UNIFORMTYPE_UVEC3;
				this.pcUniformType[gl.UNSIGNED_INT_VEC4] = UNIFORMTYPE_UVEC4;
				this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
				this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
				this.pcUniformType[gl.SAMPLER_2D_ARRAY] = UNIFORMTYPE_TEXTURE2D_ARRAY;
				this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
				this.pcUniformType[gl.INT_SAMPLER_2D] = UNIFORMTYPE_ITEXTURE2D;
				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURE2D;
				this.pcUniformType[gl.INT_SAMPLER_CUBE] = UNIFORMTYPE_ITEXTURECUBE;
				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURECUBE;
				this.pcUniformType[gl.INT_SAMPLER_3D] = UNIFORMTYPE_ITEXTURE3D;
				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_3D] = UNIFORMTYPE_UTEXTURE3D;
				this.pcUniformType[gl.INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_ITEXTURE2D_ARRAY;
				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_UTEXTURE2D_ARRAY;
				this.targetToSlot = {};
				this.targetToSlot[gl.TEXTURE_2D] = 0;
				this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
				this.targetToSlot[gl.TEXTURE_3D] = 2;
				var scopeX, scopeY, scopeZ, scopeW;
				var uniformValue;
				this.commitFunction = [];
				this.commitFunction[UNIFORMTYPE_BOOL] = function(uniform, value) {
						if (uniform.value !== value) {
								gl.uniform1i(uniform.locationId, value);
								uniform.value = value;
						}
				};
				this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];
				this.commitFunction[UNIFORMTYPE_FLOAT] = function(uniform, value) {
						if (uniform.value !== value) {
								gl.uniform1f(uniform.locationId, value);
								uniform.value = value;
						}
				};
				this.commitFunction[UNIFORMTYPE_VEC2] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
								gl.uniform2fv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
						}
				};
				this.commitFunction[UNIFORMTYPE_VEC3] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						scopeZ = value[2];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
								gl.uniform3fv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
								uniformValue[2] = scopeZ;
						}
				};
				this.commitFunction[UNIFORMTYPE_VEC4] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						scopeZ = value[2];
						scopeW = value[3];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
								gl.uniform4fv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
								uniformValue[2] = scopeZ;
								uniformValue[3] = scopeW;
						}
				};
				this.commitFunction[UNIFORMTYPE_IVEC2] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
								gl.uniform2iv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
						}
				};
				this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];
				this.commitFunction[UNIFORMTYPE_IVEC3] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						scopeZ = value[2];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
								gl.uniform3iv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
								uniformValue[2] = scopeZ;
						}
				};
				this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];
				this.commitFunction[UNIFORMTYPE_IVEC4] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						scopeZ = value[2];
						scopeW = value[3];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
								gl.uniform4iv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
								uniformValue[2] = scopeZ;
								uniformValue[3] = scopeW;
						}
				};
				this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];
				this.commitFunction[UNIFORMTYPE_MAT2] = function(uniform, value) {
						gl.uniformMatrix2fv(uniform.locationId, false, value);
				};
				this.commitFunction[UNIFORMTYPE_MAT3] = function(uniform, value) {
						gl.uniformMatrix3fv(uniform.locationId, false, value);
				};
				this.commitFunction[UNIFORMTYPE_MAT4] = function(uniform, value) {
						gl.uniformMatrix4fv(uniform.locationId, false, value);
				};
				this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function(uniform, value) {
						gl.uniform1fv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function(uniform, value) {
						gl.uniform2fv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function(uniform, value) {
						gl.uniform3fv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function(uniform, value) {
						gl.uniform4fv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_UINT] = function(uniform, value) {
						if (uniform.value !== value) {
								gl.uniform1ui(uniform.locationId, value);
								uniform.value = value;
						}
				};
				this.commitFunction[UNIFORMTYPE_UVEC2] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
								gl.uniform2uiv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
						}
				};
				this.commitFunction[UNIFORMTYPE_UVEC3] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						scopeZ = value[2];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
								gl.uniform3uiv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
								uniformValue[2] = scopeZ;
						}
				};
				this.commitFunction[UNIFORMTYPE_UVEC4] = function(uniform, value) {
						uniformValue = uniform.value;
						scopeX = value[0];
						scopeY = value[1];
						scopeZ = value[2];
						scopeW = value[3];
						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
								gl.uniform4uiv(uniform.locationId, value);
								uniformValue[0] = scopeX;
								uniformValue[1] = scopeY;
								uniformValue[2] = scopeZ;
								uniformValue[3] = scopeW;
						}
				};
				this.commitFunction[UNIFORMTYPE_INTARRAY] = function(uniform, value) {
						gl.uniform1iv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_UINTARRAY] = function(uniform, value) {
						gl.uniform1uiv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_BOOLARRAY] = this.commitFunction[UNIFORMTYPE_INTARRAY];
				this.commitFunction[UNIFORMTYPE_IVEC2ARRAY] = function(uniform, value) {
						gl.uniform2iv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_UVEC2ARRAY] = function(uniform, value) {
						gl.uniform2uiv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_BVEC2ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC2ARRAY];
				this.commitFunction[UNIFORMTYPE_IVEC3ARRAY] = function(uniform, value) {
						gl.uniform3iv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_UVEC3ARRAY] = function(uniform, value) {
						gl.uniform3uiv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_BVEC3ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC3ARRAY];
				this.commitFunction[UNIFORMTYPE_IVEC4ARRAY] = function(uniform, value) {
						gl.uniform4iv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_UVEC4ARRAY] = function(uniform, value) {
						gl.uniform4uiv(uniform.locationId, value);
				};
				this.commitFunction[UNIFORMTYPE_BVEC4ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC4ARRAY];
				this.commitFunction[UNIFORMTYPE_MAT4ARRAY] = function(uniform, value) {
						gl.uniformMatrix4fv(uniform.locationId, false, value);
				};
				this.constantTexSource = this.scope.resolve('source');
				this.postInit();
		}
}

class NullIndexBuffer {
		unlock(indexBuffer) {}
}

class NullRenderTarget {
		destroy(device) {}
		init(device, renderTarget) {}
		loseContext() {}
		resolve(device, target, color, depth) {}
}

class NullShader {
		destroy(shader) {}
		loseContext() {}
		restoreContext(device, shader) {}
}

class NullTexture {
		destroy(device) {}
		propertyChanged(flag) {}
		loseContext() {}
}

class NullVertexBuffer {
		destroy(device) {}
		unlock(vertexBuffer) {}
}

class NullGraphicsDevice extends GraphicsDevice {
		destroy() {
				super.destroy();
		}
		initDeviceCaps() {
				this.disableParticleSystem = true;
				this.precision = 'highp';
				this.maxPrecision = 'highp';
				this.maxSamples = 4;
				this.maxTextures = 16;
				this.maxTextureSize = 4096;
				this.maxCubeMapSize = 4096;
				this.maxVolumeSize = 4096;
				this.maxColorAttachments = 8;
				this.maxPixelRatio = 1;
				this.maxAnisotropy = 16;
				this.supportsUniformBuffers = false;
				this.supportsAreaLights = true;
				this.supportsGpuParticles = false;
				this.textureFloatRenderable = true;
				this.textureHalfFloatRenderable = true;
				this.supportsImageBitmap = false;
		}
		postInit() {
				super.postInit();
		}
		frameStart() {
				super.frameStart();
		}
		frameEnd() {
				super.frameEnd();
		}
		updateBegin() {}
		updateEnd() {}
		readPixels(x, y, w, h, pixels) {}
		createVertexBufferImpl(vertexBuffer, format) {
				return new NullVertexBuffer(vertexBuffer, format);
		}
		createIndexBufferImpl(indexBuffer) {
				return new NullIndexBuffer(indexBuffer);
		}
		createShaderImpl(shader) {
				return new NullShader(shader);
		}
		createTextureImpl(texture) {
				return new NullTexture(texture);
		}
		createRenderTargetImpl(renderTarget) {
				return new NullRenderTarget(renderTarget);
		}
		draw(primitive, numInstances, keepBuffers) {
		}
		setShader(shader, asyncCompile) {
		}
		setBlendState(blendState) {}
		setDepthState(depthState) {}
		setStencilState(stencilFront, stencilBack) {}
		setBlendColor(r, g, b, a) {}
		setCullMode(cullMode) {}
		setAlphaToCoverage(state) {}
		initializeContextCaches() {
				super.initializeContextCaches();
		}
		clear(options) {}
		setViewport(x, y, w, h) {}
		setScissor(x, y, w, h) {}
		copyRenderTarget(source, dest, color, depth) {
				return true;
		}
		constructor(canvas, options = {}){
				super(canvas, options);
				options = this.initOptions;
				this.isNull = true;
				this._deviceType = DEVICETYPE_NULL;
				this.samples = 1;
				this.backBuffer = new RenderTarget({
						name: 'Framebuffer',
						graphicsDevice: this,
						depth: this.initOptions.depth,
						stencil: this.supportsStencil,
						samples: this.samples
				});
				this.initDeviceCaps();
		}
}

function createGraphicsDevice(canvas, options) {
		if (options === void 0) options = {};
		var _options_deviceTypes;
		var deviceTypes = (_options_deviceTypes = options.deviceTypes) != null ? _options_deviceTypes : [];
		if (!deviceTypes.includes(DEVICETYPE_WEBGL2)) {
				deviceTypes.push(DEVICETYPE_WEBGL2);
		}
		if (!deviceTypes.includes(DEVICETYPE_NULL)) {
				deviceTypes.push(DEVICETYPE_NULL);
		}
		if (platform.browser && !!navigator.xr) {
				var _options;
				var _xrCompatible;
				(_xrCompatible = (_options = options).xrCompatible) != null ? _xrCompatible : _options.xrCompatible = true;
		}
		var deviceCreateFuncs = [];
		for(var i = 0; i < deviceTypes.length; i++){
				var _window_navigator, _window;
				var deviceType = deviceTypes[i];
				if (deviceType === DEVICETYPE_WEBGPU && ((_window = window) == null ? void 0 : (_window_navigator = _window.navigator) == null ? void 0 : _window_navigator.gpu)) {
						deviceCreateFuncs.push(()=>{
								var device = new WebgpuGraphicsDevice(canvas, options);
								return device.initWebGpu(options.glslangUrl, options.twgslUrl);
						});
				}
				if (deviceType === DEVICETYPE_WEBGL2) {
						deviceCreateFuncs.push(()=>{
								return new WebglGraphicsDevice(canvas, options);
						});
				}
				if (deviceType === DEVICETYPE_NULL) {
						deviceCreateFuncs.push(()=>{
								return new NullGraphicsDevice(canvas, options);
						});
				}
		}
		return new Promise((resolve, reject)=>{
				var attempt = 0;
				var next = ()=>{
						if (attempt >= deviceCreateFuncs.length) {
								reject(new Error('Failed to create a graphics device'));
						} else {
								Promise.resolve(deviceCreateFuncs[attempt++]()).then((device)=>{
										if (device) {
												resolve(device);
										} else {
												next();
										}
								}).catch((err)=>{
										console.log(err);
										next();
								});
						}
				};
				next();
		});
}

class ComputeParameter {
		constructor(){
				this.scopeId = null;
		}
}
class Compute {
		setParameter(name, value) {
				var param = this.parameters.get(name);
				if (!param) {
						param = new ComputeParameter();
						param.scopeId = this.device.scope.resolve(name);
						this.parameters.set(name, param);
				}
				param.value = value;
		}
		getParameter(name) {
				var _this_parameters_get;
				return (_this_parameters_get = this.parameters.get(name)) == null ? void 0 : _this_parameters_get.value;
		}
		deleteParameter(name) {
				this.parameters.delete(name);
		}
		applyParameters() {
				for (var [, param] of this.parameters){
						param.scopeId.setValue(param.value);
				}
		}
		setupDispatch(x, y, z) {
				this.countX = x;
				this.countY = y;
				this.countZ = z;
		}
		constructor(graphicsDevice, shader, name = 'Unnamed'){
				this.shader = null;
				this.parameters = new Map();
				this.countX = 1;
				this.device = graphicsDevice;
				this.shader = shader;
				this.name = name;
				if (graphicsDevice.supportsCompute) {
						this.impl = graphicsDevice.createComputeImpl(this);
				}
		}
}

var id$5 = 0;
class IndexBuffer {
		destroy() {
				var device = this.device;
				var idx = device.buffers.indexOf(this);
				if (idx !== -1) {
						device.buffers.splice(idx, 1);
				}
				if (this.device.indexBuffer === this) {
						this.device.indexBuffer = null;
				}
				if (this.impl.initialized) {
						this.impl.destroy(device);
						this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
				}
		}
		adjustVramSizeTracking(vram, size) {
				vram.ib += size;
		}
		loseContext() {
				this.impl.loseContext();
		}
		getFormat() {
				return this.format;
		}
		getNumIndices() {
				return this.numIndices;
		}
		lock() {
				return this.storage;
		}
		unlock() {
				this.impl.unlock(this);
		}
		setData(data) {
				if (data.byteLength !== this.numBytes) {
						return false;
				}
				this.storage = data;
				this.unlock();
				return true;
		}
		_lockTypedArray() {
				var lock = this.lock();
				var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
				return indices;
		}
		writeData(data, count) {
				var indices = this._lockTypedArray();
				if (data.length > count) {
						if (ArrayBuffer.isView(data)) {
								data = data.subarray(0, count);
								indices.set(data);
						} else {
								for(var i = 0; i < count; i++){
										indices[i] = data[i];
								}
						}
				} else {
						indices.set(data);
				}
				this.unlock();
		}
		readData(data) {
				var indices = this._lockTypedArray();
				var count = this.numIndices;
				if (ArrayBuffer.isView(data)) {
						data.set(indices);
				} else {
						data.length = 0;
						for(var i = 0; i < count; i++){
								data[i] = indices[i];
						}
				}
				return count;
		}
		constructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData, options){
				this.device = graphicsDevice;
				this.format = format;
				this.numIndices = numIndices;
				this.usage = usage;
				this.id = id$5++;
				this.impl = graphicsDevice.createIndexBufferImpl(this, options);
				var bytesPerIndex = typedArrayIndexFormatsByteSize[format];
				this.bytesPerIndex = bytesPerIndex;
				this.numBytes = this.numIndices * bytesPerIndex;
				if (initialData) {
						this.setData(initialData);
				} else {
						this.storage = new ArrayBuffer(this.numBytes);
				}
				this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
				this.device.buffers.push(this);
		}
}

class ColorAttachmentOps {
		constructor(){
				this.clearValue = new Color(0, 0, 0, 1);
				this.clearValueLinear = new Color(0, 0, 0, 1);
				this.clear = false;
				this.store = false;
				this.resolve = true;
				this.genMipmaps = false;
		}
}
class DepthStencilAttachmentOps {
		constructor(){
				this.clearDepthValue = 1;
				this.clearStencilValue = 0;
				this.clearDepth = false;
				this.clearStencil = false;
				this.storeDepth = false;
				this.resolveDepth = false;
				this.storeStencil = false;
		}
}
class RenderPass {
		get colorOps() {
				return this.colorArrayOps[0];
		}
		set name(value) {
				this._name = value;
		}
		get name() {
				if (!this._name) {
						this._name = this.constructor.name;
				}
				return this._name;
		}
		set scaleX(value) {
				this._options.scaleX = value;
		}
		get scaleX() {
				return this._options.scaleX;
		}
		set scaleY(value) {
				this._options.scaleY = value;
		}
		get scaleY() {
				return this._options.scaleY;
		}
		set options(value) {
				this._options = value;
				if (value) {
						var _this_scaleX;
						this.scaleX = (_this_scaleX = this.scaleX) != null ? _this_scaleX : 1;
						var _this_scaleY;
						this.scaleY = (_this_scaleY = this.scaleY) != null ? _this_scaleY : 1;
				}
		}
		get options() {
				return this._options;
		}
		init(renderTarget, options) {
				if (renderTarget === void 0) renderTarget = null;
				this.options = options;
				this.renderTarget = renderTarget;
				this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);
				this.allocateAttachments();
				this.postInit();
		}
		allocateAttachments() {
				var _rt__colorBuffers;
				var rt = this.renderTarget;
				this.depthStencilOps = new DepthStencilAttachmentOps();
				if (rt == null ? void 0 : rt.depthBuffer) {
						this.depthStencilOps.storeDepth = true;
				}
				var _rt__colorBuffers_length;
				var numColorOps = rt ? (_rt__colorBuffers_length = (_rt__colorBuffers = rt._colorBuffers) == null ? void 0 : _rt__colorBuffers.length) != null ? _rt__colorBuffers_length : 0 : 1;
				this.colorArrayOps.length = 0;
				for(var i = 0; i < numColorOps; i++){
						var _this_renderTarget__colorBuffers, _this_renderTarget, _this_renderTarget1;
						var colorOps = new ColorAttachmentOps();
						this.colorArrayOps[i] = colorOps;
						if (this.samples === 1) {
								colorOps.store = true;
								colorOps.resolve = false;
						}
						var colorBuffer = (_this_renderTarget = this.renderTarget) == null ? void 0 : (_this_renderTarget__colorBuffers = _this_renderTarget._colorBuffers) == null ? void 0 : _this_renderTarget__colorBuffers[i];
						if (((_this_renderTarget1 = this.renderTarget) == null ? void 0 : _this_renderTarget1.mipmaps) && (colorBuffer == null ? void 0 : colorBuffer.mipmaps)) {
								var intFormat = isIntegerPixelFormat(colorBuffer._format);
								colorOps.genMipmaps = !intFormat;
						}
				}
		}
		destroy() {}
		postInit() {}
		frameUpdate() {
				if (this._options && this.renderTarget) {
						var _this__options_resizeSource;
						var resizeSource = (_this__options_resizeSource = this._options.resizeSource) != null ? _this__options_resizeSource : this.device.backBuffer;
						var width = Math.floor(resizeSource.width * this.scaleX);
						var height = Math.floor(resizeSource.height * this.scaleY);
						this.renderTarget.resize(width, height);
				}
		}
		before() {}
		execute() {}
		after() {}
		onEnable() {}
		onDisable() {}
		set enabled(value) {
				if (this._enabled !== value) {
						this._enabled = value;
						if (value) {
								this.onEnable();
						} else {
								this.onDisable();
						}
				}
		}
		get enabled() {
				return this._enabled;
		}
		setClearColor(color) {
				var count = this.colorArrayOps.length;
				for(var i = 0; i < count; i++){
						var colorOps = this.colorArrayOps[i];
						if (color) {
								colorOps.clearValue.copy(color);
								colorOps.clearValueLinear.linear(color);
						}
						colorOps.clear = !!color;
				}
		}
		setClearDepth(depthValue) {
				if (depthValue) {
						this.depthStencilOps.clearDepthValue = depthValue;
				}
				this.depthStencilOps.clearDepth = depthValue !== undefined;
		}
		setClearStencil(stencilValue) {
				if (stencilValue) {
						this.depthStencilOps.clearStencilValue = stencilValue;
				}
				this.depthStencilOps.clearStencil = stencilValue !== undefined;
		}
		render() {
				if (this.enabled) {
						var device = this.device;
						var realPass = this.renderTarget !== undefined;
						this.before();
						if (this.executeEnabled) {
								if (realPass && !this._skipStart) {
										device.startRenderPass(this);
								}
								this.execute();
								if (realPass && !this._skipEnd) {
										device.endRenderPass(this);
								}
						}
						this.after();
						device.renderPassIndex++;
				}
		}
		constructor(graphicsDevice){
				this._enabled = true;
				this._skipStart = false;
				this._skipEnd = false;
				this.executeEnabled = true;
				this.samples = 0;
				this.colorArrayOps = [];
				this.requiresCubemaps = true;
				this.fullSizeClearRect = true;
				this.beforePasses = [];
				this.afterPasses = [];
				this.device = graphicsDevice;
		}
}

var id$4 = 0;
class StorageBuffer {
		destroy() {
				var device = this.device;
				var idx = device.buffers.indexOf(this);
				if (idx !== -1) {
						device.buffers.splice(idx, 1);
				}
				this.adjustVramSizeTracking(device._vram, -this.byteSize);
				this.impl.destroy(device);
		}
		adjustVramSizeTracking(vram, size) {
				vram.sb += size;
		}
		read(offset, size, data) {
				if (offset === void 0) offset = 0;
				if (size === void 0) size = this.byteSize;
				if (data === void 0) data = null;
				return this.impl.read(this.device, offset, size, data);
		}
		write(bufferOffset, data, dataOffset, size) {
				if (bufferOffset === void 0) bufferOffset = 0;
				if (dataOffset === void 0) dataOffset = 0;
				this.impl.write(this.device, bufferOffset, data, dataOffset, size);
		}
		clear(offset, size) {
				if (offset === void 0) offset = 0;
				if (size === void 0) size = this.byteSize;
				this.impl.clear(this.device, offset, size);
		}
		constructor(graphicsDevice, byteSize, bufferUsage = 0){
				this.id = id$4++;
				this.device = graphicsDevice;
				this.byteSize = byteSize;
				this.bufferUsage = bufferUsage;
				this.impl = graphicsDevice.createBufferImpl(BUFFERUSAGE_STORAGE | bufferUsage);
				this.impl.allocate(graphicsDevice, byteSize);
				this.device.buffers.push(this);
				this.adjustVramSizeTracking(graphicsDevice._vram, this.byteSize);
		}
}

class TransformFeedback {
		static createShader(graphicsDevice, vertexCode, name) {
				return new Shader(graphicsDevice, ShaderUtils.createDefinition(graphicsDevice, {
						name,
						vertexCode,
						useTransformFeedback: true
				}));
		}
		destroy() {
				this._outputBuffer.destroy();
		}
		process(shader, swap) {
				if (swap === void 0) swap = true;
				var device = this.device;
				var oldRt = device.getRenderTarget();
				device.setRenderTarget(null);
				device.updateBegin();
				device.setVertexBuffer(this._inputBuffer, 0);
				device.setRaster(false);
				device.setTransformFeedbackBuffer(this._outputBuffer);
				device.setShader(shader);
				device.draw({
						type: PRIMITIVE_POINTS,
						base: 0,
						count: this._inputBuffer.numVertices,
						indexed: false
				});
				device.setTransformFeedbackBuffer(null);
				device.setRaster(true);
				device.updateEnd();
				device.setRenderTarget(oldRt);
				if (swap) {
						var tmp = this._inputBuffer.impl.bufferId;
						this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
						this._outputBuffer.impl.bufferId = tmp;
						tmp = this._inputBuffer.impl.vao;
						this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
						this._outputBuffer.impl.vao = tmp;
				}
		}
		get inputBuffer() {
				return this._inputBuffer;
		}
		get outputBuffer() {
				return this._outputBuffer;
		}
		constructor(inputBuffer, usage = BUFFER_GPUDYNAMIC){
				this.device = inputBuffer.device;
				var gl = this.device.gl;
				this._inputBuffer = inputBuffer;
				if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
						gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
						gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
				}
				this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, {
						usage: usage,
						data: inputBuffer.storage
				});
		}
}

function set1(a) {
		this.array[this.index] = a;
}
function set2(a, b) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
}
function set3(a, b, c) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
}
function set4(a, b, c, d) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
		this.array[this.index + 3] = d;
}
function arraySet1(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
}
function arraySet2(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
}
function arraySet3(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
}
function arraySet4(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
		this.array[index + 3] = inputArray[inputIndex + 3];
}
function arrayGet1(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
}
function arrayGet2(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
}
function arrayGet3(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
}
function arrayGet4(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
		outputArray[outputIndex + 3] = this.array[offset + 3];
}
class VertexIteratorAccessor {
		get(offset) {
				return this.array[this.index + offset];
		}
		set(a, b, c, d) {}
		getToArray(offset, outputArray, outputIndex) {}
		setFromArray(index, inputArray, inputIndex) {}
		constructor(buffer, vertexElement, vertexFormat){
				this.index = 0;
				this.numComponents = vertexElement.numComponents;
				if (vertexFormat.interleaved) {
						this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
				} else {
						this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
				}
				this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;
				switch(vertexElement.numComponents){
						case 1:
								this.set = set1;
								this.getToArray = arrayGet1;
								this.setFromArray = arraySet1;
								break;
						case 2:
								this.set = set2;
								this.getToArray = arrayGet2;
								this.setFromArray = arraySet2;
								break;
						case 3:
								this.set = set3;
								this.getToArray = arrayGet3;
								this.setFromArray = arraySet3;
								break;
						case 4:
								this.set = set4;
								this.getToArray = arrayGet4;
								this.setFromArray = arraySet4;
								break;
				}
		}
}
class VertexIterator {
		next(count) {
				if (count === void 0) count = 1;
				var i = 0;
				var accessors = this.accessors;
				var numAccessors = this.accessors.length;
				while(i < numAccessors){
						var accessor = accessors[i++];
						accessor.index += count * accessor.stride;
				}
		}
		end() {
				this.vertexBuffer.unlock();
		}
		writeData(semantic, data, numVertices) {
				var element = this.element[semantic];
				if (element) {
						if (numVertices > this.vertexBuffer.numVertices) {
								numVertices = this.vertexBuffer.numVertices;
						}
						var numComponents = element.numComponents;
						if (this.vertexBuffer.getFormat().interleaved) {
								var index = 0;
								for(var i = 0; i < numVertices; i++){
										element.setFromArray(index, data, i * numComponents);
										index += element.stride;
								}
						} else {
								if (data.length > numVertices * numComponents) {
										var copyCount = numVertices * numComponents;
										if (ArrayBuffer.isView(data)) {
												data = data.subarray(0, copyCount);
												element.array.set(data);
										} else {
												for(var i1 = 0; i1 < copyCount; i1++){
														element.array[i1] = data[i1];
												}
										}
								} else {
										element.array.set(data);
								}
						}
				}
		}
		readData(semantic, data) {
				var element = this.element[semantic];
				var count = 0;
				if (element) {
						count = this.vertexBuffer.numVertices;
						var i;
						var numComponents = element.numComponents;
						if (this.vertexBuffer.getFormat().interleaved) {
								if (Array.isArray(data)) {
										data.length = 0;
								}
								element.index = 0;
								var offset = 0;
								for(i = 0; i < count; i++){
										element.getToArray(offset, data, i * numComponents);
										offset += element.stride;
								}
						} else {
								if (ArrayBuffer.isView(data)) {
										data.set(element.array);
								} else {
										data.length = 0;
										var copyCount = count * numComponents;
										for(i = 0; i < copyCount; i++){
												data[i] = element.array[i];
										}
								}
						}
				}
				return count;
		}
		constructor(vertexBuffer){
				this.vertexBuffer = vertexBuffer;
				this.vertexFormatSize = vertexBuffer.getFormat().size;
				this.buffer = this.vertexBuffer.lock();
				this.accessors = [];
				this.element = {};
				var vertexFormat = this.vertexBuffer.getFormat();
				for(var i = 0; i < vertexFormat.elements.length; i++){
						var vertexElement = vertexFormat.elements[i];
						this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
						this.element[vertexElement.name] = this.accessors[i];
				}
		}
}

var ACTION_MOUSE = 'mouse';
var ACTION_KEYBOARD = 'keyboard';
var ACTION_GAMEPAD = 'gamepad';
var AXIS_MOUSE_X = 'mousex';
var AXIS_MOUSE_Y = 'mousey';
var AXIS_PAD_L_X = 'padlx';
var AXIS_PAD_L_Y = 'padly';
var AXIS_PAD_R_X = 'padrx';
var AXIS_PAD_R_Y = 'padry';
var AXIS_KEY = 'key';
var EVENT_KEYDOWN = 'keydown';
var EVENT_KEYUP = 'keyup';
var EVENT_MOUSEDOWN = 'mousedown';
var EVENT_MOUSEMOVE = 'mousemove';
var EVENT_MOUSEUP = 'mouseup';
var EVENT_MOUSEWHEEL = 'mousewheel';
var EVENT_TOUCHSTART = 'touchstart';
var EVENT_TOUCHEND = 'touchend';
var EVENT_TOUCHMOVE = 'touchmove';
var EVENT_TOUCHCANCEL = 'touchcancel';
var EVENT_SELECT = 'select';
var EVENT_SELECTSTART = 'selectstart';
var EVENT_SELECTEND = 'selectend';
var KEY_BACKSPACE = 8;
var KEY_TAB = 9;
var KEY_RETURN = 13;
var KEY_ENTER = 13;
var KEY_SHIFT = 16;
var KEY_CONTROL = 17;
var KEY_ALT = 18;
var KEY_PAUSE = 19;
var KEY_CAPS_LOCK = 20;
var KEY_ESCAPE = 27;
var KEY_SPACE = 32;
var KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = 34;
var KEY_END = 35;
var KEY_HOME = 36;
var KEY_LEFT = 37;
var KEY_UP = 38;
var KEY_RIGHT = 39;
var KEY_DOWN = 40;
var KEY_PRINT_SCREEN = 44;
var KEY_INSERT = 45;
var KEY_DELETE = 46;
var KEY_0 = 48;
var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;
var KEY_4 = 52;
var KEY_5 = 53;
var KEY_6 = 54;
var KEY_7 = 55;
var KEY_8 = 56;
var KEY_9 = 57;
var KEY_SEMICOLON = 59;
var KEY_EQUAL = 61;
var KEY_A = 65;
var KEY_B = 66;
var KEY_C = 67;
var KEY_D = 68;
var KEY_E = 69;
var KEY_F = 70;
var KEY_G = 71;
var KEY_H = 72;
var KEY_I = 73;
var KEY_J = 74;
var KEY_K = 75;
var KEY_L = 76;
var KEY_M = 77;
var KEY_N = 78;
var KEY_O = 79;
var KEY_P = 80;
var KEY_Q = 81;
var KEY_R = 82;
var KEY_S = 83;
var KEY_T = 84;
var KEY_U = 85;
var KEY_V = 86;
var KEY_W = 87;
var KEY_X = 88;
var KEY_Y = 89;
var KEY_Z = 90;
var KEY_WINDOWS = 91;
var KEY_CONTEXT_MENU = 93;
var KEY_NUMPAD_0 = 96;
var KEY_NUMPAD_1 = 97;
var KEY_NUMPAD_2 = 98;
var KEY_NUMPAD_3 = 99;
var KEY_NUMPAD_4 = 100;
var KEY_NUMPAD_5 = 101;
var KEY_NUMPAD_6 = 102;
var KEY_NUMPAD_7 = 103;
var KEY_NUMPAD_8 = 104;
var KEY_NUMPAD_9 = 105;
var KEY_MULTIPLY = 106;
var KEY_ADD = 107;
var KEY_SEPARATOR = 108;
var KEY_SUBTRACT = 109;
var KEY_DECIMAL = 110;
var KEY_DIVIDE = 111;
var KEY_F1 = 112;
var KEY_F2 = 113;
var KEY_F3 = 114;
var KEY_F4 = 115;
var KEY_F5 = 116;
var KEY_F6 = 117;
var KEY_F7 = 118;
var KEY_F8 = 119;
var KEY_F9 = 120;
var KEY_F10 = 121;
var KEY_F11 = 122;
var KEY_F12 = 123;
var KEY_COMMA = 188;
var KEY_PERIOD = 190;
var KEY_SLASH = 191;
var KEY_OPEN_BRACKET = 219;
var KEY_BACK_SLASH = 220;
var KEY_CLOSE_BRACKET = 221;
var KEY_META = 224;
var MOUSEBUTTON_NONE = -1;
var MOUSEBUTTON_LEFT = 0;
var MOUSEBUTTON_MIDDLE = 1;
var MOUSEBUTTON_RIGHT = 2;
var PAD_1 = 0;
var PAD_2 = 1;
var PAD_3 = 2;
var PAD_4 = 3;
var PAD_FACE_1 = 0;
var PAD_FACE_2 = 1;
var PAD_FACE_3 = 2;
var PAD_FACE_4 = 3;
var PAD_L_SHOULDER_1 = 4;
var PAD_R_SHOULDER_1 = 5;
var PAD_L_SHOULDER_2 = 6;
var PAD_R_SHOULDER_2 = 7;
var PAD_SELECT = 8;
var PAD_START = 9;
var PAD_L_STICK_BUTTON = 10;
var PAD_R_STICK_BUTTON = 11;
var PAD_UP = 12;
var PAD_DOWN = 13;
var PAD_LEFT = 14;
var PAD_RIGHT = 15;
var PAD_VENDOR = 16;
var PAD_L_STICK_X = 0;
var PAD_L_STICK_Y = 1;
var PAD_R_STICK_X = 2;
var PAD_R_STICK_Y = 3;
var EVENT_GAMEPADCONNECTED = 'gamepadconnected';
var EVENT_GAMEPADDISCONNECTED = 'gamepaddisconnected';
var XRPAD_TOUCHPAD_X = 0;
var XRPAD_TOUCHPAD_Y = 1;
var XRPAD_STICK_X = 2;
var XRPAD_STICK_Y = 3;
var XRPAD_TOUCHPAD_BUTTON = 2;
var XRPAD_TRIGGER = 0;
var XRPAD_SQUEEZE = 1;
var XRPAD_STICK_BUTTON = 3;
var XRPAD_A = 4;
var XRPAD_B = 5;

class KeyboardEvent {
		constructor(keyboard, event){
				this.key = null;
				this.element = null;
				this.event = null;
				if (event) {
						this.key = event.keyCode;
						this.element = event.target;
						this.event = event;
				}
		}
}

var _keyboardEvent = new KeyboardEvent();
function makeKeyboardEvent(event) {
		_keyboardEvent.key = event.keyCode;
		_keyboardEvent.element = event.target;
		_keyboardEvent.event = event;
		return _keyboardEvent;
}
function toKeyCode(s) {
		if (typeof s === 'string') {
				return s.toUpperCase().charCodeAt(0);
		}
		return s;
}
var _keyCodeToKeyIdentifier = {
		'9': 'Tab',
		'13': 'Enter',
		'16': 'Shift',
		'17': 'Control',
		'18': 'Alt',
		'27': 'Escape',
		'37': 'Left',
		'38': 'Up',
		'39': 'Right',
		'40': 'Down',
		'46': 'Delete',
		'91': 'Win'
};
class Keyboard extends EventHandler {
		attach(element) {
				if (this._element) {
						this.detach();
				}
				this._element = element;
				this._element.addEventListener('keydown', this._keyDownHandler, false);
				this._element.addEventListener('keypress', this._keyPressHandler, false);
				this._element.addEventListener('keyup', this._keyUpHandler, false);
				document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
				window.addEventListener('blur', this._windowBlurHandler, false);
		}
		detach() {
				if (!this._element) {
						return;
				}
				this._element.removeEventListener('keydown', this._keyDownHandler);
				this._element.removeEventListener('keypress', this._keyPressHandler);
				this._element.removeEventListener('keyup', this._keyUpHandler);
				this._element = null;
				document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
				window.removeEventListener('blur', this._windowBlurHandler, false);
		}
		toKeyIdentifier(keyCode) {
				keyCode = toKeyCode(keyCode);
				var id = _keyCodeToKeyIdentifier[keyCode.toString()];
				if (id) {
						return id;
				}
				var hex = keyCode.toString(16).toUpperCase();
				var length = hex.length;
				for(var count = 0; count < 4 - length; count++){
						hex = "0" + hex;
				}
				return "U+" + hex;
		}
		_handleKeyDown(event) {
				var code = event.keyCode || event.charCode;
				if (code === undefined) return;
				var id = this.toKeyIdentifier(code);
				this._keymap[id] = true;
				this.fire('keydown', makeKeyboardEvent(event));
				if (this.preventDefault) {
						event.preventDefault();
				}
				if (this.stopPropagation) {
						event.stopPropagation();
				}
		}
		_handleKeyUp(event) {
				var code = event.keyCode || event.charCode;
				if (code === undefined) return;
				var id = this.toKeyIdentifier(code);
				delete this._keymap[id];
				this.fire('keyup', makeKeyboardEvent(event));
				if (this.preventDefault) {
						event.preventDefault();
				}
				if (this.stopPropagation) {
						event.stopPropagation();
				}
		}
		_handleKeyPress(event) {
				this.fire('keypress', makeKeyboardEvent(event));
				if (this.preventDefault) {
						event.preventDefault();
				}
				if (this.stopPropagation) {
						event.stopPropagation();
				}
		}
		_handleVisibilityChange() {
				if (document.visibilityState === 'hidden') {
						this._handleWindowBlur();
				}
		}
		_handleWindowBlur() {
				this._keymap = {};
				this._lastmap = {};
		}
		update() {
				for(var prop in this._lastmap){
						delete this._lastmap[prop];
				}
				for(var prop1 in this._keymap){
						if (this._keymap.hasOwnProperty(prop1)) {
								this._lastmap[prop1] = this._keymap[prop1];
						}
				}
		}
		isPressed(key) {
				var keyCode = toKeyCode(key);
				var id = this.toKeyIdentifier(keyCode);
				return !!this._keymap[id];
		}
		wasPressed(key) {
				var keyCode = toKeyCode(key);
				var id = this.toKeyIdentifier(keyCode);
				return !!this._keymap[id] && !!!this._lastmap[id];
		}
		wasReleased(key) {
				var keyCode = toKeyCode(key);
				var id = this.toKeyIdentifier(keyCode);
				return !!!this._keymap[id] && !!this._lastmap[id];
		}
		constructor(element, options = {}){
				super(), this._element = null, this._keymap = {}, this._lastmap = {};
				this._keyDownHandler = this._handleKeyDown.bind(this);
				this._keyUpHandler = this._handleKeyUp.bind(this);
				this._keyPressHandler = this._handleKeyPress.bind(this);
				this._visibilityChangeHandler = this._handleVisibilityChange.bind(this);
				this._windowBlurHandler = this._handleWindowBlur.bind(this);
				if (element) {
						this.attach(element);
				}
				this.preventDefault = options.preventDefault || false;
				this.stopPropagation = options.stopPropagation || false;
		}
}
Keyboard.EVENT_KEYDOWN = 'keydown';
Keyboard.EVENT_KEYUP = 'keyup';

function isMousePointerLocked() {
		return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
}
class MouseEvent {
		constructor(mouse, event){
				this.x = 0;
				this.y = 0;
				this.dx = 0;
				this.dy = 0;
				this.button = MOUSEBUTTON_NONE;
				this.wheelDelta = 0;
				this.ctrlKey = false;
				this.altKey = false;
				this.shiftKey = false;
				this.metaKey = false;
				var coords = {
						x: 0,
						y: 0
				};
				if (event) {
						if (event instanceof MouseEvent) {
								throw Error('Expected MouseEvent');
						}
						coords = mouse._getTargetCoords(event);
				} else {
						event = {};
				}
				if (coords) {
						this.x = coords.x;
						this.y = coords.y;
				} else if (isMousePointerLocked()) {
						this.x = 0;
						this.y = 0;
				} else {
						return;
				}
				if (event.type === 'wheel') {
						if (event.deltaY > 0) {
								this.wheelDelta = 1;
						} else if (event.deltaY < 0) {
								this.wheelDelta = -1;
						}
				}
				if (isMousePointerLocked()) {
						this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
						this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
				} else {
						this.dx = this.x - mouse._lastX;
						this.dy = this.y - mouse._lastY;
				}
				if (event.type === 'mousedown' || event.type === 'mouseup') {
						this.button = event.button;
				}
				this.buttons = mouse._buttons.slice(0);
				this.element = event.target;
				var _event_ctrlKey;
				this.ctrlKey = (_event_ctrlKey = event.ctrlKey) != null ? _event_ctrlKey : false;
				var _event_altKey;
				this.altKey = (_event_altKey = event.altKey) != null ? _event_altKey : false;
				var _event_shiftKey;
				this.shiftKey = (_event_shiftKey = event.shiftKey) != null ? _event_shiftKey : false;
				var _event_metaKey;
				this.metaKey = (_event_metaKey = event.metaKey) != null ? _event_metaKey : false;
				this.event = event;
		}
}

class Mouse extends EventHandler {
		static isPointerLocked() {
				return isMousePointerLocked();
		}
		attach(element) {
				this._target = element;
				if (this._attached) return;
				this._attached = true;
				var passiveOptions = {
						passive: false
				};
				var options = platform.passiveEvents ? passiveOptions : false;
				window.addEventListener('mouseup', this._upHandler, options);
				window.addEventListener('mousedown', this._downHandler, options);
				window.addEventListener('mousemove', this._moveHandler, options);
				window.addEventListener('wheel', this._wheelHandler, options);
		}
		detach() {
				if (!this._attached) return;
				this._attached = false;
				this._target = null;
				var passiveOptions = {
						passive: false
				};
				var options = platform.passiveEvents ? passiveOptions : false;
				window.removeEventListener('mouseup', this._upHandler, options);
				window.removeEventListener('mousedown', this._downHandler, options);
				window.removeEventListener('mousemove', this._moveHandler, options);
				window.removeEventListener('wheel', this._wheelHandler, options);
		}
		disableContextMenu() {
				if (!this._target) return;
				this._target.addEventListener('contextmenu', this._contextMenuHandler);
		}
		enableContextMenu() {
				if (!this._target) return;
				this._target.removeEventListener('contextmenu', this._contextMenuHandler);
		}
		enablePointerLock(success, error) {
				if (!document.body.requestPointerLock) {
						if (error) {
								error();
						}
						return;
				}
				var s = ()=>{
						success();
						document.removeEventListener('pointerlockchange', s);
				};
				var e = ()=>{
						error();
						document.removeEventListener('pointerlockerror', e);
				};
				if (success) {
						document.addEventListener('pointerlockchange', s, false);
				}
				if (error) {
						document.addEventListener('pointerlockerror', e, false);
				}
				document.body.requestPointerLock();
		}
		disablePointerLock(success) {
				if (!document.exitPointerLock) {
						return;
				}
				var s = ()=>{
						success();
						document.removeEventListener('pointerlockchange', s);
				};
				if (success) {
						document.addEventListener('pointerlockchange', s, false);
				}
				document.exitPointerLock();
		}
		update() {
				this._lastbuttons[0] = this._buttons[0];
				this._lastbuttons[1] = this._buttons[1];
				this._lastbuttons[2] = this._buttons[2];
		}
		isPressed(button) {
				return this._buttons[button];
		}
		wasPressed(button) {
				return this._buttons[button] && !this._lastbuttons[button];
		}
		wasReleased(button) {
				return !this._buttons[button] && this._lastbuttons[button];
		}
		_handleUp(event) {
				this._buttons[event.button] = false;
				var e = new MouseEvent(this, event);
				if (!e.event) return;
				this.fire(EVENT_MOUSEUP, e);
		}
		_handleDown(event) {
				this._buttons[event.button] = true;
				var e = new MouseEvent(this, event);
				if (!e.event) return;
				this.fire(EVENT_MOUSEDOWN, e);
		}
		_handleMove(event) {
				var e = new MouseEvent(this, event);
				if (!e.event) return;
				this.fire(EVENT_MOUSEMOVE, e);
				this._lastX = e.x;
				this._lastY = e.y;
		}
		_handleWheel(event) {
				var e = new MouseEvent(this, event);
				if (!e.event) return;
				this.fire(EVENT_MOUSEWHEEL, e);
		}
		_getTargetCoords(event) {
				var rect = this._target.getBoundingClientRect();
				var left = Math.floor(rect.left);
				var top = Math.floor(rect.top);
				if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
						return null;
				}
				return {
						x: event.clientX - left,
						y: event.clientY - top
				};
		}
		constructor(element){
				super(), this._lastX = 0, this._lastY = 0, this._buttons = [
						false,
						false,
						false
				], this._lastbuttons = [
						false,
						false,
						false
				], this._target = null, this._attached = false;
				this._upHandler = this._handleUp.bind(this);
				this._downHandler = this._handleDown.bind(this);
				this._moveHandler = this._handleMove.bind(this);
				this._wheelHandler = this._handleWheel.bind(this);
				this._contextMenuHandler = (event)=>{
						event.preventDefault();
				};
				this.attach(element);
		}
}
Mouse.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
Mouse.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
Mouse.EVENT_MOUSEUP = EVENT_MOUSEUP;
Mouse.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;

class Controller {
		attach(element) {
				this._element = element;
				if (this._keyboard) {
						this._keyboard.attach(element);
				}
				if (this._mouse) {
						this._mouse.attach(element);
				}
		}
		detach() {
				if (this._keyboard) {
						this._keyboard.detach();
				}
				if (this._mouse) {
						this._mouse.detach();
				}
				this._element = null;
		}
		disableContextMenu() {
				if (!this._mouse) {
						this._enableMouse();
				}
				this._mouse.disableContextMenu();
		}
		enableContextMenu() {
				if (!this._mouse) {
						this._enableMouse();
				}
				this._mouse.enableContextMenu();
		}
		update(dt) {
				if (this._keyboard) {
						this._keyboard.update();
				}
				if (this._mouse) {
						this._mouse.update();
				}
				if (this._gamepads) {
						this._gamepads.update();
				}
				this._axesValues = {};
				for(var key in this._axes){
						this._axesValues[key] = [];
				}
		}
		appendAction(action_name, action) {
				this._actions[action_name] = this._actions[action_name] || [];
				this._actions[action_name].push(action);
		}
		registerKeys(action, keys) {
				if (!this._keyboard) {
						this._enableKeyboard();
				}
				if (this._actions[action]) {
						throw new Error("Action: " + action + " already registered");
				}
				if (keys === undefined) {
						throw new Error('Invalid button');
				}
				if (!keys.length) {
						keys = [
								keys
						];
				}
				this.appendAction(action, {
						type: ACTION_KEYBOARD,
						keys
				});
		}
		registerMouse(action, button) {
				if (!this._mouse) {
						this._enableMouse();
				}
				if (button === undefined) {
						throw new Error('Invalid button');
				}
				this.appendAction(action, {
						type: ACTION_MOUSE,
						button
				});
		}
		registerPadButton(action, pad, button) {
				if (button === undefined) {
						throw new Error('Invalid button');
				}
				this.appendAction(action, {
						type: ACTION_GAMEPAD,
						button,
						pad
				});
		}
		registerAxis(options) {
				var name = options.name;
				if (!this._axes[name]) {
						this._axes[name] = [];
				}
				var i = this._axes[name].push(name);
				options = options || {};
				options.pad = options.pad || PAD_1;
				var bind = function bind(controller, source, value, key) {
						switch(source){
								case 'mousex':
										controller._mouse.on(EVENT_MOUSEMOVE, (e)=>{
												controller._axesValues[name][i] = e.dx / 10;
										});
										break;
								case 'mousey':
										controller._mouse.on(EVENT_MOUSEMOVE, (e)=>{
												controller._axesValues[name][i] = e.dy / 10;
										});
										break;
								case 'key':
										controller._axes[name].push(()=>{
												return controller._keyboard.isPressed(key) ? value : 0;
										});
										break;
								case 'padrx':
										controller._axes[name].push(()=>{
												return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
										});
										break;
								case 'padry':
										controller._axes[name].push(()=>{
												return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
										});
										break;
								case 'padlx':
										controller._axes[name].push(()=>{
												return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
										});
										break;
								case 'padly':
										controller._axes[name].push(()=>{
												return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
										});
										break;
								default:
										throw new Error('Unknown axis');
						}
				};
				bind(this, options.positive, 1, options.positiveKey);
				if (options.negativeKey || options.negative !== options.positive) {
						bind(this, options.negative, -1, options.negativeKey);
				}
		}
		isPressed(actionName) {
				if (!this._actions[actionName]) {
						return false;
				}
				var length = this._actions[actionName].length;
				for(var index = 0; index < length; ++index){
						var action = this._actions[actionName][index];
						switch(action.type){
								case ACTION_KEYBOARD:
										if (this._keyboard) {
												var len = action.keys.length;
												for(var i = 0; i < len; i++){
														if (this._keyboard.isPressed(action.keys[i])) {
																return true;
														}
												}
										}
										break;
								case ACTION_MOUSE:
										if (this._mouse && this._mouse.isPressed(action.button)) {
												return true;
										}
										break;
								case ACTION_GAMEPAD:
										if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
												return true;
										}
										break;
						}
				}
				return false;
		}
		wasPressed(actionName) {
				if (!this._actions[actionName]) {
						return false;
				}
				var length = this._actions[actionName].length;
				for(var index = 0; index < length; ++index){
						var action = this._actions[actionName][index];
						switch(action.type){
								case ACTION_KEYBOARD:
										if (this._keyboard) {
												var len = action.keys.length;
												for(var i = 0; i < len; i++){
														if (this._keyboard.wasPressed(action.keys[i])) {
																return true;
														}
												}
										}
										break;
								case ACTION_MOUSE:
										if (this._mouse && this._mouse.wasPressed(action.button)) {
												return true;
										}
										break;
								case ACTION_GAMEPAD:
										if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
												return true;
										}
										break;
						}
				}
				return false;
		}
		getAxis(name) {
				var value = 0;
				if (this._axes[name]) {
						var len = this._axes[name].length;
						for(var i = 0; i < len; i++){
								if (typeof this._axes[name][i] === 'function') {
										var v = this._axes[name][i]();
										if (Math.abs(v) > Math.abs(value)) {
												value = v;
										}
								} else if (this._axesValues[name]) {
										if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
												value = this._axesValues[name][i];
										}
								}
						}
				}
				return value;
		}
		_enableMouse() {
				this._mouse = new Mouse();
				if (!this._element) {
						throw new Error('Controller must be attached to an Element');
				}
				this._mouse.attach(this._element);
		}
		_enableKeyboard() {
				this._keyboard = new Keyboard();
				if (!this._element) {
						throw new Error('Controller must be attached to an Element');
				}
				this._keyboard.attach(this._element);
		}
		constructor(element, options = {}){
				this._element = null;
				this._actions = {};
				this._axes = {};
				this._axesValues = {};
				this._keyboard = options.keyboard || null;
				this._mouse = options.mouse || null;
				this._gamepads = options.gamepads || null;
				if (element) {
						this.attach(element);
				}
		}
}

function asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, key, arg) {
		try {
				var info = gen[key](arg);
				var value = info.value;
		} catch (error) {
				reject(error);
				return;
		}
		if (info.done) {
				resolve(value);
		} else {
				Promise.resolve(value).then(_next, _throw);
		}
}
function _async_to_generator$3(fn) {
		return function() {
				var self = this, args = arguments;
				return new Promise(function(resolve, reject) {
						var gen = fn.apply(self, args);
						function _next(value) {
								asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "next", value);
						}
						function _throw(err) {
								asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "throw", err);
						}
						_next(undefined);
				});
		};
}
var dummyArray = Object.freeze([]);
var getGamepads = function getGamepads() {
		return dummyArray;
};
if (typeof navigator !== 'undefined') {
		getGamepads = (navigator.getGamepads || navigator.webkitGetGamepads || getGamepads).bind(navigator);
}
var MAPS_INDEXES = {
		buttons: {
				PAD_FACE_1,
				PAD_FACE_2,
				PAD_FACE_3,
				PAD_FACE_4,
				PAD_L_SHOULDER_1,
				PAD_R_SHOULDER_1,
				PAD_L_SHOULDER_2,
				PAD_R_SHOULDER_2,
				PAD_SELECT,
				PAD_START,
				PAD_L_STICK_BUTTON,
				PAD_R_STICK_BUTTON,
				PAD_UP,
				PAD_DOWN,
				PAD_LEFT,
				PAD_RIGHT,
				PAD_VENDOR,
				XRPAD_TRIGGER,
				XRPAD_SQUEEZE,
				XRPAD_TOUCHPAD_BUTTON,
				XRPAD_STICK_BUTTON,
				XRPAD_A,
				XRPAD_B
		},
		axes: {
				PAD_L_STICK_X,
				PAD_L_STICK_Y,
				PAD_R_STICK_X,
				PAD_R_STICK_Y,
				XRPAD_TOUCHPAD_X,
				XRPAD_TOUCHPAD_Y,
				XRPAD_STICK_X,
				XRPAD_STICK_Y
		}
};
var MAPS = {
		DEFAULT: {
				buttons: [
						'PAD_FACE_1',
						'PAD_FACE_2',
						'PAD_FACE_3',
						'PAD_FACE_4',
						'PAD_L_SHOULDER_1',
						'PAD_R_SHOULDER_1',
						'PAD_L_SHOULDER_2',
						'PAD_R_SHOULDER_2',
						'PAD_SELECT',
						'PAD_START',
						'PAD_L_STICK_BUTTON',
						'PAD_R_STICK_BUTTON',
						'PAD_UP',
						'PAD_DOWN',
						'PAD_LEFT',
						'PAD_RIGHT',
						'PAD_VENDOR'
				],
				axes: [
						'PAD_L_STICK_X',
						'PAD_L_STICK_Y',
						'PAD_R_STICK_X',
						'PAD_R_STICK_Y'
				]
		},
		DEFAULT_DUAL: {
				buttons: [
						'PAD_FACE_1',
						'PAD_FACE_2',
						'PAD_FACE_3',
						'PAD_FACE_4',
						'PAD_L_SHOULDER_1',
						'PAD_R_SHOULDER_1',
						'PAD_L_SHOULDER_2',
						'PAD_R_SHOULDER_2',
						'PAD_SELECT',
						'PAD_START',
						'PAD_L_STICK_BUTTON',
						'PAD_R_STICK_BUTTON',
						'PAD_VENDOR'
				],
				axes: [
						'PAD_L_STICK_X',
						'PAD_L_STICK_Y',
						'PAD_R_STICK_X',
						'PAD_R_STICK_Y'
				],
				synthesizedButtons: {
						PAD_UP: {
								axis: 0,
								min: 0,
								max: 1
						},
						PAD_DOWN: {
								axis: 0,
								min: -1,
								max: 0
						},
						PAD_LEFT: {
								axis: 0,
								min: -1,
								max: 0
						},
						PAD_RIGHT: {
								axis: 0,
								min: 0,
								max: 1
						}
				}
		},
		PS3: {
				buttons: [
						'PAD_FACE_1',
						'PAD_FACE_2',
						'PAD_FACE_4',
						'PAD_FACE_3',
						'PAD_L_SHOULDER_1',
						'PAD_R_SHOULDER_1',
						'PAD_L_SHOULDER_2',
						'PAD_R_SHOULDER_2',
						'PAD_SELECT',
						'PAD_START',
						'PAD_L_STICK_BUTTON',
						'PAD_R_STICK_BUTTON',
						'PAD_UP',
						'PAD_DOWN',
						'PAD_LEFT',
						'PAD_RIGHT',
						'PAD_VENDOR'
				],
				axes: [
						'PAD_L_STICK_X',
						'PAD_L_STICK_Y',
						'PAD_R_STICK_X',
						'PAD_R_STICK_Y'
				],
				mapping: 'standard'
		},
		DEFAULT_XR: {
				buttons: [
						'XRPAD_TRIGGER',
						'XRPAD_SQUEEZE',
						'XRPAD_TOUCHPAD_BUTTON',
						'XRPAD_STICK_BUTTON',
						'XRPAD_A',
						'XRPAD_B'
				],
				axes: [
						'XRPAD_TOUCHPAD_X',
						'XRPAD_TOUCHPAD_Y',
						'XRPAD_STICK_X',
						'XRPAD_STICK_Y'
				],
				mapping: 'xr-standard'
		}
};
var PRODUCT_CODES = {
		'Product: 0268': 'PS3'
};
var custom_maps = {};
function getMap(pad) {
		var custom = custom_maps[pad.id];
		if (custom) {
				return custom;
		}
		for(var code in PRODUCT_CODES){
				if (pad.id.indexOf(code) !== -1) {
						var product = PRODUCT_CODES[code];
						if (!pad.mapping) {
								var raw = MAPS["RAW_" + product];
								if (raw) {
										return raw;
								}
						}
						return MAPS[product];
				}
		}
		if (pad.mapping === 'xr-standard') {
				return MAPS.DEFAULT_XR;
		}
		var defaultmap = MAPS.DEFAULT;
		var map = pad.buttons.length < defaultmap.buttons.length ? MAPS.DEFAULT_DUAL : defaultmap;
		map.mapping = pad.mapping;
		return map;
}
var deadZone = 0.25;
function sleep(ms) {
		return new Promise((resolve)=>{
				setTimeout(resolve, ms);
		});
}
class GamePadButton {
		update(button) {
				var { value, pressed } = button;
				var _button_touched;
				var touched = (_button_touched = button.touched) != null ? _button_touched : value > 0;
				this.wasPressed = !this.pressed && pressed;
				this.wasReleased = this.pressed && !pressed;
				this.wasTouched = !this.touched && touched;
				this.value = value;
				this.pressed = pressed;
				this.touched = touched;
		}
		constructor(current, previous){
				this.value = 0;
				this.pressed = false;
				this.touched = false;
				this.wasPressed = false;
				this.wasReleased = false;
				this.wasTouched = false;
				if (typeof current === 'number') {
						this.value = current;
						this.pressed = current === 1;
						this.touched = current > 0;
				} else {
						this.value = current.value;
						this.pressed = current.pressed;
						var _current_touched;
						this.touched = (_current_touched = current.touched) != null ? _current_touched : current.value > 0;
				}
				if (previous) {
						if (typeof previous === 'number') {
								this.wasPressed = previous !== 1 && this.pressed;
								this.wasReleased = previous === 1 && !this.pressed;
								this.wasTouched = previous === 0 && this.touched;
						} else {
								this.wasPressed = !previous.pressed && this.pressed;
								this.wasReleased = previous.pressed && !this.pressed;
								var _previous_touched;
								this.wasTouched = !((_previous_touched = previous.touched) != null ? _previous_touched : previous.value > 0) && this.touched;
						}
				}
		}
}
var dummyButton = Object.freeze(new GamePadButton(0));
class GamePad {
		get connected() {
				return this.pad.connected;
		}
		_compileMapping() {
				var { axes, buttons } = this._compiledMapping;
				var axesIndexes = MAPS_INDEXES.axes;
				var buttonsIndexes = MAPS_INDEXES.buttons;
				axes.length = 0;
				buttons.length = 0;
				var axesMap = this.map.axes;
				if (axesMap) {
						this.map.axes.forEach((axis, i)=>{
								axes[axesIndexes[axis]] = ()=>this.pad.axes[i] || 0;
						});
				}
				for(var i = 0, l = axes.length; i < l; i++){
						if (!axes[i]) {
								axes[i] = ()=>0;
						}
				}
				var buttonsMap = this.map.buttons;
				if (buttonsMap) {
						buttonsMap.forEach((button, i)=>{
								buttons[buttonsIndexes[button]] = ()=>this._buttons[i] || dummyButton;
						});
				}
				var synthesizedButtonsMap = this.map.synthesizedButtons;
				if (synthesizedButtonsMap) {
						Object.entries(synthesizedButtonsMap).forEach((button)=>{
								var { axis, max, min } = button[1];
								buttons[buttonsIndexes[button[0]]] = ()=>{
										var _this__axes_axis, _this__previousAxes_axis;
										return new GamePadButton(Math.abs(math.clamp((_this__axes_axis = this._axes[axis]) != null ? _this__axes_axis : 0, min, max)), Math.abs(math.clamp((_this__previousAxes_axis = this._previousAxes[axis]) != null ? _this__previousAxes_axis : 0, min, max)));
								};
						});
				}
				for(var i1 = 0, l1 = buttons.length; i1 < l1; i1++){
						if (!buttons[i1]) {
								buttons[i1] = ()=>dummyButton;
						}
				}
		}
		update(gamepad) {
				this.pad = gamepad;
				var previousAxes = this._previousAxes;
				var axes = this._axes;
				previousAxes.length = 0;
				previousAxes.push(...axes);
				axes.length = 0;
				axes.push(...gamepad.axes);
				var buttons = this._buttons;
				for(var i = 0, l = buttons.length; i < l; i++){
						buttons[i].update(gamepad.buttons[i]);
				}
				return this;
		}
		updateMap(map) {
				map.mapping = 'custom';
				custom_maps[this.id] = map;
				this.map = map;
				this.mapping = 'custom';
				this._compileMapping();
		}
		resetMap() {
				if (custom_maps[this.id]) {
						delete custom_maps[this.id];
						var map = getMap(this.pad);
						this.map = map;
						this.mapping = map.mapping;
						this._compileMapping();
				}
		}
		get axes() {
				return this._compiledMapping.axes.map((a)=>a());
		}
		get buttons() {
				return this._compiledMapping.buttons.map((b)=>b());
		}
		pulse(intensity, duration, options) {
				var _this = this;
				return _async_to_generator$3(function*() {
						var actuators = _this.pad.vibrationActuator ? [
								_this.pad.vibrationActuator
						] : _this.pad.hapticActuators || dummyArray;
						if (actuators.length) {
								var _options_startDelay;
								var startDelay = (_options_startDelay = options == null ? void 0 : options.startDelay) != null ? _options_startDelay : 0;
								var _options_strongMagnitude;
								var strongMagnitude = (_options_strongMagnitude = options == null ? void 0 : options.strongMagnitude) != null ? _options_strongMagnitude : intensity;
								var _options_weakMagnitude;
								var weakMagnitude = (_options_weakMagnitude = options == null ? void 0 : options.weakMagnitude) != null ? _options_weakMagnitude : intensity;
								var results = yield Promise.all(actuators.map(/*#__PURE__*/ _async_to_generator$3(function*(actuator) {
										if (!actuator) {
												return true;
										}
										if (actuator.playEffect) {
												return actuator.playEffect(actuator.type, {
														duration,
														startDelay,
														strongMagnitude,
														weakMagnitude
												});
										} else if (actuator.pulse) {
												yield sleep(startDelay);
												return actuator.pulse(intensity, duration);
										}
										return false;
								})));
								return results.some((r)=>r === true || r === 'complete');
						}
						return false;
				})();
		}
		getButton(index) {
				var button = this._compiledMapping.buttons[index];
				return button ? button() : dummyButton;
		}
		isPressed(button) {
				return this.getButton(button).pressed;
		}
		wasPressed(button) {
				return this.getButton(button).wasPressed;
		}
		wasReleased(button) {
				return this.getButton(button).wasReleased;
		}
		isTouched(button) {
				return this.getButton(button).touched;
		}
		wasTouched(button) {
				return this.getButton(button).wasTouched;
		}
		getValue(button) {
				return this.getButton(button).value;
		}
		getAxis(axis) {
				var a = this.axes[axis];
				return a && Math.abs(a) > deadZone ? a : 0;
		}
		constructor(gamepad, map){
				this._compiledMapping = {
						buttons: [],
						axes: []
				};
				this.id = gamepad.id;
				this.index = gamepad.index;
				this._buttons = gamepad.buttons.map((b)=>new GamePadButton(b));
				this._axes = [
						...gamepad.axes
				];
				this._previousAxes = [
						...gamepad.axes
				];
				this.mapping = map.mapping;
				this.map = map;
				this.hand = gamepad.hand || 'none';
				this.pad = gamepad;
				this._compileMapping();
		}
}
class GamePads extends EventHandler {
		set deadZone(value) {
				deadZone = value;
		}
		get deadZone() {
				return deadZone;
		}
		get previous() {
				var current = this.current;
				for(var i = 0, l = current.length; i < l; i++){
						var buttons = current[i]._buttons;
						if (!this._previous[i]) {
								this._previous[i] = [];
						}
						for(var j = 0, m = buttons.length; j < m; j++){
								var button = buttons[i];
								this.previous[i][j] = button ? !button.wasPressed && button.pressed || button.wasReleased : false;
						}
				}
				this._previous.length = this.current.length;
				return this._previous;
		}
		_ongamepadconnected(event) {
				var pad = new GamePad(event.gamepad, this.getMap(event.gamepad));
				var current = this.current;
				var padIndex = current.findIndex((gp)=>gp.index === pad.index);
				while(padIndex !== -1){
						current.splice(padIndex, 1);
						padIndex = current.findIndex((gp)=>gp.index === pad.index);
				}
				current.push(pad);
				this.fire(EVENT_GAMEPADCONNECTED, pad);
		}
		_ongamepaddisconnected(event) {
				var current = this.current;
				var padIndex = current.findIndex((gp)=>gp.index === event.gamepad.index);
				if (padIndex !== -1) {
						this.fire(EVENT_GAMEPADDISCONNECTED, current[padIndex]);
						current.splice(padIndex, 1);
				}
		}
		update() {
				this.poll();
		}
		poll(pads) {
				if (pads === void 0) pads = [];
				if (pads.length > 0) {
						pads.length = 0;
				}
				var padDevices = getGamepads();
				for(var i = 0, len = padDevices.length; i < len; i++){
						if (padDevices[i]) {
								var pad = this.findByIndex(padDevices[i].index);
								if (pad) {
										pads.push(pad.update(padDevices[i]));
								} else {
										var nPad = new GamePad(padDevices[i], this.getMap(padDevices[i]));
										this.current.push(nPad);
										pads.push(nPad);
								}
						}
				}
				return pads;
		}
		destroy() {
				window.removeEventListener('gamepadconnected', this._ongamepadconnectedHandler, false);
				window.removeEventListener('gamepaddisconnected', this._ongamepaddisconnectedHandler, false);
		}
		getMap(pad) {
				return getMap(pad);
		}
		isPressed(orderIndex, button) {
				var _this_current_orderIndex;
				return ((_this_current_orderIndex = this.current[orderIndex]) == null ? void 0 : _this_current_orderIndex.isPressed(button)) || false;
		}
		wasPressed(orderIndex, button) {
				var _this_current_orderIndex;
				return ((_this_current_orderIndex = this.current[orderIndex]) == null ? void 0 : _this_current_orderIndex.wasPressed(button)) || false;
		}
		wasReleased(orderIndex, button) {
				var _this_current_orderIndex;
				return ((_this_current_orderIndex = this.current[orderIndex]) == null ? void 0 : _this_current_orderIndex.wasReleased(button)) || false;
		}
		getAxis(orderIndex, axis) {
				var _this_current_orderIndex;
				return ((_this_current_orderIndex = this.current[orderIndex]) == null ? void 0 : _this_current_orderIndex.getAxis(axis)) || 0;
		}
		pulse(orderIndex, intensity, duration, options) {
				var pad = this.current[orderIndex];
				return pad ? pad.pulse(intensity, duration, options) : Promise.resolve(false);
		}
		pulseAll(intensity, duration, options) {
				return Promise.all(this.current.map((pad)=>pad.pulse(intensity, duration, options)));
		}
		findById(id) {
				return this.current.find((gp)=>gp && gp.id === id) || null;
		}
		findByIndex(index) {
				return this.current.find((gp)=>gp && gp.index === index) || null;
		}
		constructor(){
				super();
				this.gamepadsSupported = platform.gamepads;
				this.current = [];
				this._previous = [];
				this._ongamepadconnectedHandler = this._ongamepadconnected.bind(this);
				this._ongamepaddisconnectedHandler = this._ongamepaddisconnected.bind(this);
				window.addEventListener('gamepadconnected', this._ongamepadconnectedHandler, false);
				window.addEventListener('gamepaddisconnected', this._ongamepaddisconnectedHandler, false);
				this.poll();
		}
}
GamePads.EVENT_GAMEPADCONNECTED = 'gamepadconnected';
GamePads.EVENT_GAMEPADDISCONNECTED = 'gamepaddisconnected';

function getTouchTargetCoords(touch) {
		var totalOffsetX = 0;
		var totalOffsetY = 0;
		var target = touch.target;
		while(!(target instanceof HTMLElement) && target){
				target = target.parentNode;
		}
		while(target){
				totalOffsetX += target.offsetLeft - target.scrollLeft;
				totalOffsetY += target.offsetTop - target.scrollTop;
				target = target.offsetParent;
		}
		return {
				x: touch.pageX - totalOffsetX,
				y: touch.pageY - totalOffsetY
		};
}
class Touch {
		constructor(touch){
				var coords = getTouchTargetCoords(touch);
				this.id = touch.identifier;
				this.x = coords.x;
				this.y = coords.y;
				this.target = touch.target;
				this.touch = touch;
		}
}
class TouchEvent {
		getTouchById(id, list) {
				return list.find((touch)=>touch.id === id) || null;
		}
		constructor(device, event){
				this.touches = [];
				this.changedTouches = [];
				this.element = event.target;
				this.event = event;
				this.touches = Array.from(event.touches).map((touch)=>new Touch(touch));
				this.changedTouches = Array.from(event.changedTouches).map((touch)=>new Touch(touch));
		}
}

class TouchDevice extends EventHandler {
		attach(element) {
				if (this._element) {
						this.detach();
				}
				this._element = element;
				this._element.addEventListener('touchstart', this._startHandler, false);
				this._element.addEventListener('touchend', this._endHandler, false);
				this._element.addEventListener('touchmove', this._moveHandler, false);
				this._element.addEventListener('touchcancel', this._cancelHandler, false);
		}
		detach() {
				if (this._element) {
						this._element.removeEventListener('touchstart', this._startHandler, false);
						this._element.removeEventListener('touchend', this._endHandler, false);
						this._element.removeEventListener('touchmove', this._moveHandler, false);
						this._element.removeEventListener('touchcancel', this._cancelHandler, false);
				}
				this._element = null;
		}
		_handleTouchStart(e) {
				this.fire('touchstart', new TouchEvent(this, e));
		}
		_handleTouchEnd(e) {
				this.fire('touchend', new TouchEvent(this, e));
		}
		_handleTouchMove(e) {
				e.preventDefault();
				this.fire('touchmove', new TouchEvent(this, e));
		}
		_handleTouchCancel(e) {
				this.fire('touchcancel', new TouchEvent(this, e));
		}
		constructor(element){
				super();
				this._element = null;
				this._startHandler = this._handleTouchStart.bind(this);
				this._endHandler = this._handleTouchEnd.bind(this);
				this._moveHandler = this._handleTouchMove.bind(this);
				this._cancelHandler = this._handleTouchCancel.bind(this);
				this.attach(element);
		}
}

class Http {
		get(url, options, callback) {
				if (typeof options === 'function') {
						callback = options;
						options = {};
				}
				return this.request('GET', url, options, callback);
		}
		post(url, data, options, callback) {
				if (typeof options === 'function') {
						callback = options;
						options = {};
				}
				options.postdata = data;
				return this.request('POST', url, options, callback);
		}
		put(url, data, options, callback) {
				if (typeof options === 'function') {
						callback = options;
						options = {};
				}
				options.postdata = data;
				return this.request('PUT', url, options, callback);
		}
		del(url, options, callback) {
				if (typeof options === 'function') {
						callback = options;
						options = {};
				}
				return this.request('DELETE', url, options, callback);
		}
		request(method, url, options, callback) {
				var uri, query, postdata;
				var errored = false;
				if (typeof options === 'function') {
						callback = options;
						options = {};
				}
				if (options.retry) {
						options = Object.assign({
								retries: 0,
								maxRetries: 5
						}, options);
				}
				options.callback = callback;
				if (options.async == null) {
						options.async = true;
				}
				if (options.headers == null) {
						options.headers = {};
				}
				if (options.postdata != null) {
						if (options.postdata instanceof Document) {
								postdata = options.postdata;
						} else if (options.postdata instanceof FormData) {
								postdata = options.postdata;
						} else if (options.postdata instanceof Object) {
								var contentType = options.headers['Content-Type'];
								if (contentType === undefined) {
										options.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;
										contentType = options.headers['Content-Type'];
								}
								switch(contentType){
										case Http.ContentType.FORM_URLENCODED:
												{
														postdata = '';
														var bFirstItem = true;
														for(var key in options.postdata){
																if (options.postdata.hasOwnProperty(key)) {
																		if (bFirstItem) {
																				bFirstItem = false;
																		} else {
																				postdata += '&';
																		}
																		var encodedKey = encodeURIComponent(key);
																		var encodedValue = encodeURIComponent(options.postdata[key]);
																		postdata += encodedKey + "=" + encodedValue;
																}
														}
														break;
												}
										default:
										case Http.ContentType.JSON:
												if (contentType == null) {
														options.headers['Content-Type'] = Http.ContentType.JSON;
												}
												postdata = JSON.stringify(options.postdata);
												break;
								}
						} else {
								postdata = options.postdata;
						}
				}
				if (options.cache === false) {
						var timestamp = now();
						uri = new URI(url);
						if (!uri.query) {
								uri.query = "ts=" + timestamp;
						} else {
								uri.query = uri.query + "&ts=" + timestamp;
						}
						url = uri.toString();
				}
				if (options.query) {
						uri = new URI(url);
						query = extend(uri.getQuery(), options.query);
						uri.setQuery(query);
						url = uri.toString();
				}
				var xhr = new XMLHttpRequest();
				xhr.open(method, url, options.async);
				xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
				xhr.responseType = options.responseType || this._guessResponseType(url);
				for(var header in options.headers){
						if (options.headers.hasOwnProperty(header)) {
								xhr.setRequestHeader(header, options.headers[header]);
						}
				}
				xhr.onreadystatechange = ()=>{
						this._onReadyStateChange(method, url, options, xhr);
				};
				xhr.onerror = ()=>{
						this._onError(method, url, options, xhr);
						errored = true;
				};
				try {
						xhr.send(postdata);
				} catch (e) {
						if (!errored) {
								options.error(xhr.status, xhr, e);
						}
				}
				return xhr;
		}
		_guessResponseType(url) {
				var uri = new URI(url);
				var ext = path.getExtension(uri.path).toLowerCase();
				if (Http.binaryExtensions.indexOf(ext) >= 0) {
						return Http.ResponseType.ARRAY_BUFFER;
				} else if (ext === '.json') {
						return Http.ResponseType.JSON;
				} else if (ext === '.xml') {
						return Http.ResponseType.DOCUMENT;
				}
				return Http.ResponseType.TEXT;
		}
		_isBinaryContentType(contentType) {
				var binTypes = [
						Http.ContentType.BASIS,
						Http.ContentType.BIN,
						Http.ContentType.DDS,
						Http.ContentType.GLB,
						Http.ContentType.MP3,
						Http.ContentType.MP4,
						Http.ContentType.OGG,
						Http.ContentType.OPUS,
						Http.ContentType.WAV
				];
				if (binTypes.indexOf(contentType) >= 0) {
						return true;
				}
				return false;
		}
		_isBinaryResponseType(responseType) {
				return responseType === Http.ResponseType.ARRAY_BUFFER || responseType === Http.ResponseType.BLOB || responseType === Http.ResponseType.JSON;
		}
		_onReadyStateChange(method, url, options, xhr) {
				if (xhr.readyState === 4) {
						switch(xhr.status){
								case 0:
										{
												if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
														this._onSuccess(method, url, options, xhr);
												} else {
														this._onError(method, url, options, xhr);
												}
												break;
										}
								case 200:
								case 201:
								case 206:
								case 304:
										{
												this._onSuccess(method, url, options, xhr);
												break;
										}
								default:
										{
												this._onError(method, url, options, xhr);
												break;
										}
						}
				}
		}
		_onSuccess(method, url, options, xhr) {
				var response;
				var contentType;
				var header = xhr.getResponseHeader('Content-Type');
				if (header) {
						var parts = header.split(';');
						contentType = parts[0].trim();
				}
				try {
						if (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {
								response = xhr.response;
						} else if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {
								response = JSON.parse(xhr.responseText);
						} else if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
								response = xhr.responseXML;
						} else {
								response = xhr.responseText;
						}
						options.callback(null, response);
				} catch (err) {
						options.callback(err);
				}
		}
		_onError(method, url, options, xhr) {
				if (options.retrying) {
						return;
				}
				if (options.retry && options.retries < options.maxRetries) {
						options.retries++;
						options.retrying = true;
						var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
						console.log(method + ": " + url + " - Error " + xhr.status + ". Retrying in " + retryDelay + " ms");
						setTimeout(()=>{
								options.retrying = false;
								this.request(method, url, options, options.callback);
						}, retryDelay);
				} else {
						options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
				}
		}
}
Http.ContentType = {
		AAC: 'audio/aac',
		BASIS: 'image/basis',
		BIN: 'application/octet-stream',
		DDS: 'image/dds',
		FORM_URLENCODED: 'application/x-www-form-urlencoded',
		GIF: 'image/gif',
		GLB: 'model/gltf-binary',
		JPEG: 'image/jpeg',
		JSON: 'application/json',
		MP3: 'audio/mpeg',
		MP4: 'audio/mp4',
		OGG: 'audio/ogg',
		OPUS: 'audio/ogg; codecs="opus"',
		PNG: 'image/png',
		TEXT: 'text/plain',
		WAV: 'audio/x-wav',
		XML: 'application/xml'
};
Http.ResponseType = {
		TEXT: 'text',
		ARRAY_BUFFER: 'arraybuffer',
		BLOB: 'blob',
		DOCUMENT: 'document',
		JSON: 'json'
};
Http.binaryExtensions = [
		'.model',
		'.wav',
		'.ogg',
		'.mp3',
		'.mp4',
		'.m4a',
		'.aac',
		'.dds',
		'.basis',
		'.glb',
		'.opus'
];
Http.retryDelay = 100;
var http = new Http();

function hasAudioContext() {
		return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
}

class Channel {
		getVolume() {
				return this.volume;
		}
		getLoop() {
				return this.loop;
		}
		setLoop(loop) {
				this.loop = loop;
				if (this.source) {
						this.source.loop = loop;
				}
		}
		getPitch() {
				return this.pitch;
		}
		onManagerVolumeChange() {
				this.setVolume(this.getVolume());
		}
		onManagerSuspend() {
				if (this.isPlaying() && !this.suspended) {
						this.suspended = true;
						this.pause();
				}
		}
		onManagerResume() {
				if (this.suspended) {
						this.suspended = false;
						this.unpause();
				}
		}
		play() {
				if (this.source) {
						throw new Error('Call stop() before calling play()');
				}
				this._createSource();
				if (!this.source) {
						return;
				}
				this.startTime = this.manager.context.currentTime;
				this.source.start(0, this.startOffset % this.source.buffer.duration);
				this.setVolume(this.volume);
				this.setLoop(this.loop);
				this.setPitch(this.pitch);
				this.manager.on('volumechange', this.onManagerVolumeChange, this);
				this.manager.on('suspend', this.onManagerSuspend, this);
				this.manager.on('resume', this.onManagerResume, this);
				if (this.manager.suspended) {
						this.onManagerSuspend();
				}
		}
		pause() {
				if (this.source) {
						this.paused = true;
						this.startOffset += this.manager.context.currentTime - this.startTime;
						this.source.stop(0);
						this.source = null;
				}
		}
		unpause() {
				if (this.source || !this.paused) {
						console.warn('Call pause() before unpausing.');
						return;
				}
				this._createSource();
				if (!this.source) {
						return;
				}
				this.startTime = this.manager.context.currentTime;
				this.source.start(0, this.startOffset % this.source.buffer.duration);
				this.setVolume(this.volume);
				this.setLoop(this.loop);
				this.setPitch(this.pitch);
				this.paused = false;
		}
		stop() {
				if (this.source) {
						this.source.stop(0);
						this.source = null;
				}
				this.manager.off('volumechange', this.onManagerVolumeChange, this);
				this.manager.off('suspend', this.onManagerSuspend, this);
				this.manager.off('resume', this.onManagerResume, this);
		}
		setVolume(volume) {
				volume = math.clamp(volume, 0, 1);
				this.volume = volume;
				if (this.gain) {
						this.gain.gain.value = volume * this.manager.volume;
				}
		}
		setPitch(pitch) {
				this.pitch = pitch;
				if (this.source) {
						this.source.playbackRate.value = pitch;
				}
		}
		isPlaying() {
				return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
		}
		getDuration() {
				return this.source ? this.source.buffer.duration : 0;
		}
		_createSource() {
				var context = this.manager.context;
				if (this.sound.buffer) {
						this.source = context.createBufferSource();
						this.source.buffer = this.sound.buffer;
						this.source.connect(this.gain);
						this.gain.connect(context.destination);
						if (!this.loop) {
								this.source.onended = this.pause.bind(this);
						}
				}
		}
		constructor(manager, sound, options = {}){
				var _options_volume;
				this.volume = (_options_volume = options.volume) != null ? _options_volume : 1;
				var _options_loop;
				this.loop = (_options_loop = options.loop) != null ? _options_loop : false;
				var _options_pitch;
				this.pitch = (_options_pitch = options.pitch) != null ? _options_pitch : 1;
				this.sound = sound;
				this.paused = false;
				this.suspended = false;
				this.manager = manager;
				this.source = null;
				if (hasAudioContext()) {
						this.startTime = 0;
						this.startOffset = 0;
						var context = manager.context;
						this.gain = context.createGain();
				} else if (sound.audio) {
						this.source = sound.audio.cloneNode(false);
						this.source.pause();
				}
		}
}
if (!hasAudioContext()) {
		Object.assign(Channel.prototype, {
				play: function play() {
						if (this.source) {
								this.paused = false;
								this.setVolume(this.volume);
								this.setLoop(this.loop);
								this.setPitch(this.pitch);
								this.source.play();
						}
						this.manager.on('volumechange', this.onManagerVolumeChange, this);
						this.manager.on('suspend', this.onManagerSuspend, this);
						this.manager.on('resume', this.onManagerResume, this);
						if (this.manager.suspended) {
								this.onManagerSuspend();
						}
				},
				pause: function pause() {
						if (this.source) {
								this.paused = true;
								this.source.pause();
						}
				},
				unpause: function unpause() {
						if (this.source) {
								this.paused = false;
								this.source.play();
						}
				},
				stop: function stop() {
						if (this.source) {
								this.source.pause();
						}
						this.manager.off('volumechange', this.onManagerVolumeChange, this);
						this.manager.off('suspend', this.onManagerSuspend, this);
						this.manager.off('resume', this.onManagerResume, this);
				},
				setVolume: function setVolume(volume) {
						volume = math.clamp(volume, 0, 1);
						this.volume = volume;
						if (this.source) {
								this.source.volume = volume * this.manager.volume;
						}
				},
				setPitch: function setPitch(pitch) {
						this.pitch = pitch;
						if (this.source) {
								this.source.playbackRate = pitch;
						}
				},
				getDuration: function getDuration() {
						return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
				},
				isPlaying: function isPlaying() {
						return !this.source.paused;
				}
		});
}

var MAX_DISTANCE$1 = 10000;
class Channel3d extends Channel {
		getPosition() {
				return this.position;
		}
		setPosition(position) {
				this.position.copy(position);
				var panner = this.panner;
				if ('positionX' in panner) {
						panner.positionX.value = position.x;
						panner.positionY.value = position.y;
						panner.positionZ.value = position.z;
				} else if (panner.setPosition) {
						panner.setPosition(position.x, position.y, position.z);
				}
		}
		getVelocity() {
				return this.velocity;
		}
		setVelocity(velocity) {
				this.velocity.copy(velocity);
		}
		getMaxDistance() {
				return this.panner.maxDistance;
		}
		setMaxDistance(max) {
				this.panner.maxDistance = max;
		}
		getMinDistance() {
				return this.panner.refDistance;
		}
		setMinDistance(min) {
				this.panner.refDistance = min;
		}
		getRollOffFactor() {
				return this.panner.rolloffFactor;
		}
		setRollOffFactor(factor) {
				this.panner.rolloffFactor = factor;
		}
		getDistanceModel() {
				return this.panner.distanceModel;
		}
		setDistanceModel(distanceModel) {
				this.panner.distanceModel = distanceModel;
		}
		_createSource() {
				var context = this.manager.context;
				this.source = context.createBufferSource();
				this.source.buffer = this.sound.buffer;
				this.source.connect(this.panner);
				this.panner.connect(this.gain);
				this.gain.connect(context.destination);
				if (!this.loop) {
						this.source.onended = this.pause.bind(this);
				}
		}
		constructor(manager, sound, options){
				super(manager, sound, options);
				this.position = new Vec3();
				this.velocity = new Vec3();
				if (hasAudioContext()) {
						this.panner = manager.context.createPanner();
				} else {
						this.maxDistance = MAX_DISTANCE$1;
						this.minDistance = 1;
						this.rollOffFactor = 1;
						this.distanceModel = DISTANCE_INVERSE;
				}
		}
}
if (!hasAudioContext()) {
		var offset$1 = new Vec3();
		var fallOff$1 = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
				offset$1 = offset$1.sub2(posOne, posTwo);
				var distance = offset$1.length();
				if (distance < refDistance) {
						return 1;
				} else if (distance > maxDistance) {
						return 0;
				}
				var result = 0;
				if (distanceModel === DISTANCE_LINEAR) {
						result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
				} else if (distanceModel === DISTANCE_INVERSE) {
						result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
				} else if (distanceModel === DISTANCE_EXPONENTIAL) {
						result = Math.pow(distance / refDistance, -rolloffFactor);
				}
				return math.clamp(result, 0, 1);
		};
		Object.assign(Channel3d.prototype, {
				setPosition: function setPosition(position) {
						this.position.copy(position);
						if (this.source) {
								var listener = this.manager.listener;
								var lpos = listener.getPosition();
								var factor = fallOff$1(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
								var v = this.getVolume();
								this.source.volume = v * factor;
						}
				},
				getMaxDistance: function getMaxDistance() {
						return this.maxDistance;
				},
				setMaxDistance: function setMaxDistance(max) {
						this.maxDistance = max;
				},
				getMinDistance: function getMinDistance() {
						return this.minDistance;
				},
				setMinDistance: function setMinDistance(min) {
						this.minDistance = min;
				},
				getRollOffFactor: function getRollOffFactor() {
						return this.rollOffFactor;
				},
				setRollOffFactor: function setRollOffFactor(factor) {
						this.rollOffFactor = factor;
				},
				getDistanceModel: function getDistanceModel() {
						return this.distanceModel;
				},
				setDistanceModel: function setDistanceModel(distanceModel) {
						this.distanceModel = distanceModel;
				}
		});
}

class Listener {
		getPosition() {
				return this.position;
		}
		setPosition(position) {
				this.position.copy(position);
				var listener = this.listener;
				if (listener) {
						if ('positionX' in listener) {
								listener.positionX.value = position.x;
								listener.positionY.value = position.y;
								listener.positionZ.value = position.z;
						} else if (listener.setPosition) {
								listener.setPosition(position.x, position.y, position.z);
						}
				}
		}
		setOrientation(orientation) {
				this.orientation.copy(orientation);
				var listener = this.listener;
				if (listener) {
						var m = orientation.data;
						if ('forwardX' in listener) {
								listener.forwardX.value = -m[8];
								listener.forwardY.value = -m[9];
								listener.forwardZ.value = -m[10];
								listener.upX.value = m[4];
								listener.upY.value = m[5];
								listener.upZ.value = m[6];
						} else if (listener.setOrientation) {
								listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
						}
				}
		}
		getOrientation() {
				return this.orientation;
		}
		get listener() {
				var context = this._manager.context;
				return context ? context.listener : null;
		}
		constructor(manager){
				this.position = new Vec3();
				this.orientation = new Mat4();
				this._manager = manager;
		}
}

var CONTEXT_STATE_RUNNING = 'running';
var USER_INPUT_EVENTS = [
		'click',
		'touchstart',
		'mousedown'
];
class SoundManager extends EventHandler {
		set volume(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				this.fire('volumechange', volume);
		}
		get volume() {
				return this._volume;
		}
		get suspended() {
				return this._userSuspended;
		}
		get context() {
				if (!this._context && this.AudioContext) {
						this._context = new this.AudioContext();
						if (this._context.state !== CONTEXT_STATE_RUNNING) {
								this._registerUnlockListeners();
						}
				}
				return this._context;
		}
		suspend() {
				if (!this._userSuspended) {
						this._userSuspended = true;
						if (this._context && this._context.state === CONTEXT_STATE_RUNNING) {
								this._suspend();
						}
				}
		}
		resume() {
				if (this._userSuspended) {
						this._userSuspended = false;
						if (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {
								this._resume();
						}
				}
		}
		destroy() {
				this.fire('destroy');
				if (this._context) {
						var _this__context;
						this._removeUnlockListeners();
						(_this__context = this._context) == null ? void 0 : _this__context.close();
						this._context = null;
				}
		}
		playSound(sound, options) {
				if (options === void 0) options = {};
				var channel = null;
				if (Channel) {
						channel = new Channel(this, sound, options);
						channel.play();
				}
				return channel;
		}
		playSound3d(sound, position, options) {
				if (options === void 0) options = {};
				var channel = null;
				if (Channel3d) {
						channel = new Channel3d(this, sound, options);
						channel.setPosition(position);
						if (options.volume) {
								channel.setVolume(options.volume);
						}
						if (options.loop) {
								channel.setLoop(options.loop);
						}
						if (options.maxDistance) {
								channel.setMaxDistance(options.maxDistance);
						}
						if (options.minDistance) {
								channel.setMinDistance(options.minDistance);
						}
						if (options.rollOffFactor) {
								channel.setRollOffFactor(options.rollOffFactor);
						}
						if (options.distanceModel) {
								channel.setDistanceModel(options.distanceModel);
						}
						channel.play();
				}
				return channel;
		}
		_resume() {
				this._context.resume().then(()=>{
						var source = this._context.createBufferSource();
						source.buffer = this._context.createBuffer(1, 1, this._context.sampleRate);
						source.connect(this._context.destination);
						source.start(0);
						source.onended = (event)=>{
								source.disconnect(0);
								this.fire('resume');
						};
				}, (e)=>{}).catch((e)=>{});
		}
		_suspend() {
				this._context.suspend().then(()=>{
						this.fire('suspend');
				}, (e)=>{}).catch((e)=>{});
		}
		_unlockHandler() {
				this._removeUnlockListeners();
				if (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {
						this._resume();
				}
		}
		_registerUnlockListeners() {
				USER_INPUT_EVENTS.forEach((eventName)=>{
						window.addEventListener(eventName, this._unlockHandlerFunc, false);
				});
		}
		_removeUnlockListeners() {
				USER_INPUT_EVENTS.forEach((eventName)=>{
						window.removeEventListener(eventName, this._unlockHandlerFunc, false);
				});
		}
		constructor(){
				super();
				this._context = null;
				this.AudioContext = typeof AudioContext !== 'undefined' && AudioContext || typeof webkitAudioContext !== 'undefined' && webkitAudioContext;
				if (!this.AudioContext) ;
				this._unlockHandlerFunc = this._unlockHandler.bind(this);
				this._userSuspended = false;
				this.listener = new Listener(this);
				this._volume = 1;
		}
}

class Sound {
		get duration() {
				var duration = 0;
				if (this.buffer) {
						duration = this.buffer.duration;
				} else if (this.audio) {
						duration = this.audio.duration;
				}
				return duration || 0;
		}
		constructor(resource){
				if (resource instanceof Audio) {
						this.audio = resource;
				} else {
						this.buffer = resource;
				}
		}
}

var STATE_PLAYING = 0;
var STATE_PAUSED = 1;
var STATE_STOPPED = 2;
function capTime(time, duration) {
		return time % duration || 0;
}
class SoundInstance extends EventHandler {
		set currentTime(value) {
				if (value < 0) return;
				if (this._state === STATE_PLAYING) {
						var suspend = this._suspendInstanceEvents;
						this._suspendInstanceEvents = true;
						this.stop();
						this._startOffset = value;
						this.play();
						this._suspendInstanceEvents = suspend;
				} else {
						this._startOffset = value;
						this._currentTime = value;
				}
		}
		get currentTime() {
				if (this._startOffset !== null) {
						return this._startOffset;
				}
				if (this._state === STATE_PAUSED) {
						return this._currentTime;
				}
				if (this._state === STATE_STOPPED || !this.source) {
						return 0;
				}
				this._updateCurrentTime();
				return this._currentTime;
		}
		set duration(value) {
				this._duration = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();
				if (isPlaying) {
						this.play();
				}
		}
		get duration() {
				if (!this._sound) {
						return 0;
				}
				if (this._duration) {
						return capTime(this._duration, this._sound.duration);
				}
				return this._sound.duration;
		}
		get isPaused() {
				return this._state === STATE_PAUSED;
		}
		get isPlaying() {
				return this._state === STATE_PLAYING;
		}
		get isStopped() {
				return this._state === STATE_STOPPED;
		}
		get isSuspended() {
				return this._suspended;
		}
		set loop(value) {
				this._loop = !!value;
				if (this.source) {
						this.source.loop = this._loop;
				}
		}
		get loop() {
				return this._loop;
		}
		set pitch(pitch) {
				this._currentOffset = this.currentTime;
				this._startedAt = this._manager.context.currentTime;
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
						this.source.playbackRate.value = this._pitch;
				}
		}
		get pitch() {
				return this._pitch;
		}
		set sound(value) {
				this._sound = value;
				if (this._state !== STATE_STOPPED) {
						this.stop();
				} else {
						this._createSource();
				}
		}
		get sound() {
				return this._sound;
		}
		set startTime(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();
				if (isPlaying) {
						this.play();
				}
		}
		get startTime() {
				return this._startTime;
		}
		set volume(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.gain) {
						this.gain.gain.value = volume * this._manager.volume;
				}
		}
		get volume() {
				return this._volume;
		}
		_onPlay() {
				this.fire('play');
				if (this._onPlayCallback) {
						this._onPlayCallback(this);
				}
		}
		_onPause() {
				this.fire('pause');
				if (this._onPauseCallback) {
						this._onPauseCallback(this);
				}
		}
		_onResume() {
				this.fire('resume');
				if (this._onResumeCallback) {
						this._onResumeCallback(this);
				}
		}
		_onStop() {
				this.fire('stop');
				if (this._onStopCallback) {
						this._onStopCallback(this);
				}
		}
		_onEnded() {
				if (this._suspendEndEvent > 0) {
						this._suspendEndEvent--;
						return;
				}
				this.fire('end');
				if (this._onEndCallback) {
						this._onEndCallback(this);
				}
				this.stop();
		}
		_onManagerVolumeChange() {
				this.volume = this._volume;
		}
		_onManagerSuspend() {
				if (this._state === STATE_PLAYING && !this._suspended) {
						this._suspended = true;
						this.pause();
				}
		}
		_onManagerResume() {
				if (this._suspended) {
						this._suspended = false;
						this.resume();
				}
		}
		_initializeNodes() {
				this.gain = this._manager.context.createGain();
				this._inputNode = this.gain;
				this._connectorNode = this.gain;
				this._connectorNode.connect(this._manager.context.destination);
		}
		play() {
				if (this._state !== STATE_STOPPED) {
						this.stop();
				}
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				if (this._waitingContextSuspension) {
						return false;
				}
				if (this._manager.suspended) {
						this._manager.once('resume', this._playAudioImmediate, this);
						this._waitingContextSuspension = true;
						return false;
				}
				this._playAudioImmediate();
				return true;
		}
		_playAudioImmediate() {
				this._waitingContextSuspension = false;
				if (this._state !== STATE_PLAYING) {
						return;
				}
				if (!this.source) {
						this._createSource();
				}
				var offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
				if (this._duration) {
						this.source.start(0, offset, this._duration);
				} else {
						this.source.start(0, offset);
				}
				this._startedAt = this._manager.context.currentTime;
				this._currentTime = 0;
				this._currentOffset = offset;
				this.volume = this._volume;
				this.loop = this._loop;
				this.pitch = this._pitch;
				this._manager.on('volumechange', this._onManagerVolumeChange, this);
				this._manager.on('suspend', this._onManagerSuspend, this);
				this._manager.on('resume', this._onManagerResume, this);
				this._manager.on('destroy', this._onManagerDestroy, this);
				if (!this._suspendInstanceEvents) {
						this._onPlay();
				}
		}
		pause() {
				this._playWhenLoaded = false;
				if (this._state !== STATE_PLAYING) {
						return false;
				}
				this._state = STATE_PAUSED;
				if (this._waitingContextSuspension) {
						return true;
				}
				this._updateCurrentTime();
				this._suspendEndEvent++;
				this.source.stop(0);
				this.source = null;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) {
						this._onPause();
				}
				return true;
		}
		resume() {
				if (this._state !== STATE_PAUSED) {
						return false;
				}
				var offset = this.currentTime;
				this._state = STATE_PLAYING;
				if (this._waitingContextSuspension) {
						return true;
				}
				if (!this.source) {
						this._createSource();
				}
				if (this._startOffset !== null) {
						offset = capTime(this._startOffset, this.duration);
						offset = capTime(this._startTime + offset, this._sound.duration);
						this._startOffset = null;
				}
				if (this._duration) {
						this.source.start(0, offset, this._duration);
				} else {
						this.source.start(0, offset);
				}
				this._startedAt = this._manager.context.currentTime;
				this._currentOffset = offset;
				this.volume = this._volume;
				this.loop = this._loop;
				this.pitch = this._pitch;
				this._playWhenLoaded = false;
				if (!this._suspendInstanceEvents) {
						this._onResume();
				}
				return true;
		}
		stop() {
				this._playWhenLoaded = false;
				if (this._state === STATE_STOPPED) {
						return false;
				}
				var wasPlaying = this._state === STATE_PLAYING;
				this._state = STATE_STOPPED;
				if (this._waitingContextSuspension) {
						return true;
				}
				this._manager.off('volumechange', this._onManagerVolumeChange, this);
				this._manager.off('suspend', this._onManagerSuspend, this);
				this._manager.off('resume', this._onManagerResume, this);
				this._manager.off('destroy', this._onManagerDestroy, this);
				this._startedAt = 0;
				this._currentTime = 0;
				this._currentOffset = 0;
				this._startOffset = null;
				this._suspendEndEvent++;
				if (wasPlaying && this.source) {
						this.source.stop(0);
				}
				this.source = null;
				if (!this._suspendInstanceEvents) {
						this._onStop();
				}
				return true;
		}
		setExternalNodes(firstNode, lastNode) {
				if (!firstNode) {
						console.error('The firstNode must be a valid Audio Node');
						return;
				}
				if (!lastNode) {
						lastNode = firstNode;
				}
				var speakers = this._manager.context.destination;
				if (this._firstNode !== firstNode) {
						if (this._firstNode) {
								this._connectorNode.disconnect(this._firstNode);
						} else {
								this._connectorNode.disconnect(speakers);
						}
						this._firstNode = firstNode;
						this._connectorNode.connect(firstNode);
				}
				if (this._lastNode !== lastNode) {
						if (this._lastNode) {
								this._lastNode.disconnect(speakers);
						}
						this._lastNode = lastNode;
						this._lastNode.connect(speakers);
				}
		}
		clearExternalNodes() {
				var speakers = this._manager.context.destination;
				if (this._firstNode) {
						this._connectorNode.disconnect(this._firstNode);
						this._firstNode = null;
				}
				if (this._lastNode) {
						this._lastNode.disconnect(speakers);
						this._lastNode = null;
				}
				this._connectorNode.connect(speakers);
		}
		getExternalNodes() {
				return [
						this._firstNode,
						this._lastNode
				];
		}
		_createSource() {
				if (!this._sound) {
						return null;
				}
				var context = this._manager.context;
				if (this._sound.buffer) {
						this.source = context.createBufferSource();
						this.source.buffer = this._sound.buffer;
						this.source.connect(this._inputNode);
						this.source.onended = this._endedHandler;
						this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
						if (this._duration) {
								this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
						}
				}
				return this.source;
		}
		_updateCurrentTime() {
				this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
		}
		_onManagerDestroy() {
				if (this.source && this._state === STATE_PLAYING) {
						this.source.stop(0);
						this.source = null;
				}
		}
		constructor(manager, sound, options){
				super(), this.source = null;
				this._manager = manager;
				this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
				this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
				this._loop = !!(options.loop !== undefined ? options.loop : false);
				this._sound = sound;
				this._state = STATE_STOPPED;
				this._suspended = false;
				this._suspendEndEvent = 0;
				this._suspendInstanceEvents = false;
				this._playWhenLoaded = true;
				this._startTime = Math.max(0, Number(options.startTime) || 0);
				this._duration = Math.max(0, Number(options.duration) || 0);
				this._startOffset = null;
				this._onPlayCallback = options.onPlay;
				this._onPauseCallback = options.onPause;
				this._onResumeCallback = options.onResume;
				this._onStopCallback = options.onStop;
				this._onEndCallback = options.onEnd;
				if (hasAudioContext()) {
						this._startedAt = 0;
						this._currentTime = 0;
						this._currentOffset = 0;
						this._inputNode = null;
						this._connectorNode = null;
						this._firstNode = null;
						this._lastNode = null;
						this._waitingContextSuspension = false;
						this._initializeNodes();
						this._endedHandler = this._onEnded.bind(this);
				} else {
						this._isReady = false;
						this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
						this._timeUpdateHandler = this._onTimeUpdate.bind(this);
						this._endedHandler = this._onEnded.bind(this);
						this._createSource();
				}
		}
}
SoundInstance.EVENT_PLAY = 'play';
SoundInstance.EVENT_PAUSE = 'pause';
SoundInstance.EVENT_RESUME = 'resume';
SoundInstance.EVENT_STOP = 'stop';
SoundInstance.EVENT_END = 'end';
if (!hasAudioContext()) {
		Object.assign(SoundInstance.prototype, {
				play: function play() {
						if (this._state !== STATE_STOPPED) {
								this.stop();
						}
						if (!this.source) {
								if (!this._createSource()) {
										return false;
								}
						}
						this.volume = this._volume;
						this.pitch = this._pitch;
						this.loop = this._loop;
						this.source.play();
						this._state = STATE_PLAYING;
						this._playWhenLoaded = false;
						this._manager.on('volumechange', this._onManagerVolumeChange, this);
						this._manager.on('suspend', this._onManagerSuspend, this);
						this._manager.on('resume', this._onManagerResume, this);
						this._manager.on('destroy', this._onManagerDestroy, this);
						if (this._manager.suspended) {
								this._onManagerSuspend();
						}
						if (!this._suspendInstanceEvents) {
								this._onPlay();
						}
						return true;
				},
				pause: function pause() {
						if (!this.source || this._state !== STATE_PLAYING) {
								return false;
						}
						this._suspendEndEvent++;
						this.source.pause();
						this._playWhenLoaded = false;
						this._state = STATE_PAUSED;
						this._startOffset = null;
						if (!this._suspendInstanceEvents) {
								this._onPause();
						}
						return true;
				},
				resume: function resume() {
						if (!this.source || this._state !== STATE_PAUSED) {
								return false;
						}
						this._state = STATE_PLAYING;
						this._playWhenLoaded = false;
						if (this.source.paused) {
								this.source.play();
								if (!this._suspendInstanceEvents) {
										this._onResume();
								}
						}
						return true;
				},
				stop: function stop() {
						if (!this.source || this._state === STATE_STOPPED) {
								return false;
						}
						this._manager.off('volumechange', this._onManagerVolumeChange, this);
						this._manager.off('suspend', this._onManagerSuspend, this);
						this._manager.off('resume', this._onManagerResume, this);
						this._manager.off('destroy', this._onManagerDestroy, this);
						this._suspendEndEvent++;
						this.source.pause();
						this._playWhenLoaded = false;
						this._state = STATE_STOPPED;
						this._startOffset = null;
						if (!this._suspendInstanceEvents) {
								this._onStop();
						}
						return true;
				},
				setExternalNodes: function setExternalNodes() {},
				clearExternalNodes: function clearExternalNodes() {},
				getExternalNodes: function getExternalNodes() {
						return [
								null,
								null
						];
				},
				_onLoadedMetadata: function _onLoadedMetadata() {
						this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
						this._isReady = true;
						var offset = capTime(this._startOffset, this.duration);
						offset = capTime(this._startTime + offset, this._sound.duration);
						this._startOffset = null;
						this.source.currentTime = offset;
				},
				_createSource: function _createSource() {
						if (this._sound && this._sound.audio) {
								this._isReady = false;
								this.source = this._sound.audio.cloneNode(true);
								this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
								this.source.addEventListener('timeupdate', this._timeUpdateHandler);
								this.source.onended = this._endedHandler;
						}
						return this.source;
				},
				_onTimeUpdate: function _onTimeUpdate() {
						if (!this._duration) {
								return;
						}
						if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
								if (this.loop) {
										this.source.currentTime = capTime(this._startTime, this.source.duration);
								} else {
										this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
										this.source.pause();
										this._onEnded();
								}
						}
				},
				_onManagerDestroy: function _onManagerDestroy() {
						if (this.source) {
								this.source.pause();
						}
				}
		});
		Object.defineProperty(SoundInstance.prototype, 'volume', {
				get: function get() {
						return this._volume;
				},
				set: function set(volume) {
						volume = math.clamp(volume, 0, 1);
						this._volume = volume;
						if (this.source) {
								this.source.volume = volume * this._manager.volume;
						}
				}
		});
		Object.defineProperty(SoundInstance.prototype, 'pitch', {
				get: function get() {
						return this._pitch;
				},
				set: function set(pitch) {
						this._pitch = Math.max(Number(pitch) || 0, 0.01);
						if (this.source) {
								this.source.playbackRate = this._pitch;
						}
				}
		});
		Object.defineProperty(SoundInstance.prototype, 'sound', {
				get: function get() {
						return this._sound;
				},
				set: function set(value) {
						this.stop();
						this._sound = value;
				}
		});
		Object.defineProperty(SoundInstance.prototype, 'currentTime', {
				get: function get() {
						if (this._startOffset !== null) {
								return this._startOffset;
						}
						if (this._state === STATE_STOPPED || !this.source) {
								return 0;
						}
						return this.source.currentTime - this._startTime;
				},
				set: function set(value) {
						if (value < 0) return;
						this._startOffset = value;
						if (this.source && this._isReady) {
								this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
								this._startOffset = null;
						}
				}
		});
}

var MAX_DISTANCE = 10000;
class SoundInstance3d extends SoundInstance {
		_initializeNodes() {
				this.gain = this._manager.context.createGain();
				this.panner = this._manager.context.createPanner();
				this.panner.connect(this.gain);
				this._inputNode = this.panner;
				this._connectorNode = this.gain;
				this._connectorNode.connect(this._manager.context.destination);
		}
		set position(value) {
				this._position.copy(value);
				var panner = this.panner;
				if ('positionX' in panner) {
						panner.positionX.value = value.x;
						panner.positionY.value = value.y;
						panner.positionZ.value = value.z;
				} else if (panner.setPosition) {
						panner.setPosition(value.x, value.y, value.z);
				}
		}
		get position() {
				return this._position;
		}
		set velocity(velocity) {
				this._velocity.copy(velocity);
		}
		get velocity() {
				return this._velocity;
		}
		set maxDistance(value) {
				this.panner.maxDistance = value;
		}
		get maxDistance() {
				return this.panner.maxDistance;
		}
		set refDistance(value) {
				this.panner.refDistance = value;
		}
		get refDistance() {
				return this.panner.refDistance;
		}
		set rollOffFactor(value) {
				this.panner.rolloffFactor = value;
		}
		get rollOffFactor() {
				return this.panner.rolloffFactor;
		}
		set distanceModel(value) {
				this.panner.distanceModel = value;
		}
		get distanceModel() {
				return this.panner.distanceModel;
		}
		constructor(manager, sound, options = {}){
				super(manager, sound, options), this._position = new Vec3(), this._velocity = new Vec3();
				if (options.position) {
						this.position = options.position;
				}
				this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
				this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
				this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
				this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
		}
}
if (!hasAudioContext()) {
		var offset = new Vec3();
		var fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
				offset = offset.sub2(posOne, posTwo);
				var distance = offset.length();
				if (distance < refDistance) {
						return 1;
				} else if (distance > maxDistance) {
						return 0;
				}
				var result = 0;
				if (distanceModel === DISTANCE_LINEAR) {
						result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
				} else if (distanceModel === DISTANCE_INVERSE) {
						result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
				} else if (distanceModel === DISTANCE_EXPONENTIAL) {
						result = Math.pow(distance / refDistance, -rollOffFactor);
				}
				return math.clamp(result, 0, 1);
		};
		Object.defineProperty(SoundInstance3d.prototype, 'position', {
				get: function get() {
						return this._position;
				},
				set: function set(position) {
						this._position.copy(position);
						if (this.source) {
								var listener = this._manager.listener;
								var lpos = listener.getPosition();
								var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
								var v = this.volume;
								this.source.volume = v * factor * this._manager.volume;
						}
				}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
				get: function get() {
						return this._maxDistance;
				},
				set: function set(value) {
						this._maxDistance = value;
				}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
				get: function get() {
						return this._refDistance;
				},
				set: function set(value) {
						this._refDistance = value;
				}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
				get: function get() {
						return this._rollOffFactor;
				},
				set: function set(value) {
						this._rollOffFactor = value;
				}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
				get: function get() {
						return this._distanceModel;
				},
				set: function set(value) {
						this._distanceModel = value;
				}
		});
}

var BLEND_SUBTRACTIVE = 0;
var BLEND_ADDITIVE = 1;
var BLEND_NORMAL = 2;
var BLEND_NONE = 3;
var BLEND_PREMULTIPLIED = 4;
var BLEND_MULTIPLICATIVE = 5;
var BLEND_ADDITIVEALPHA = 6;
var BLEND_MULTIPLICATIVE2X = 7;
var BLEND_SCREEN = 8;
var BLEND_MIN = 9;
var BLEND_MAX = 10;
var blendNames = {
		[BLEND_SUBTRACTIVE]: 'SUBTRACTIVE',
		[BLEND_ADDITIVE]: 'ADDITIVE',
		[BLEND_NORMAL]: 'NORMAL',
		[BLEND_NONE]: 'NONE',
		[BLEND_PREMULTIPLIED]: 'PREMULTIPLIED',
		[BLEND_MULTIPLICATIVE]: 'MULTIPLICATIVE',
		[BLEND_ADDITIVEALPHA]: 'ADDITIVEALPHA',
		[BLEND_MULTIPLICATIVE2X]: 'MULTIPLICATIVE2X',
		[BLEND_SCREEN]: 'SCREEN',
		[BLEND_MIN]: 'MIN',
		[BLEND_MAX]: 'MAX'
};
var FOG_NONE = 'none';
var FOG_LINEAR = 'linear';
var FOG_EXP = 'exp';
var FOG_EXP2 = 'exp2';
var FRESNEL_NONE = 0;
var FRESNEL_SCHLICK = 2;
var fresnelNames = {
		[FRESNEL_NONE]: 'NONE',
		[FRESNEL_SCHLICK]: 'SCHLICK'
};
var LAYER_HUD = 0;
var LAYER_GIZMO = 1;
var LAYER_WORLD = 15;
var LAYERID_WORLD = 0;
var LAYERID_DEPTH = 1;
var LAYERID_SKYBOX = 2;
var LAYERID_IMMEDIATE = 3;
var LAYERID_UI = 4;
var LIGHTTYPE_DIRECTIONAL = 0;
var LIGHTTYPE_OMNI = 1;
var LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
var LIGHTTYPE_SPOT = 2;
var LIGHTTYPE_COUNT = 3;
var lightTypeNames = {
		[LIGHTTYPE_DIRECTIONAL]: 'DIRECTIONAL',
		[LIGHTTYPE_OMNI]: 'OMNI',
		[LIGHTTYPE_SPOT]: 'SPOT'
};
var LIGHTSHAPE_PUNCTUAL = 0;
var LIGHTSHAPE_RECT = 1;
var LIGHTSHAPE_DISK = 2;
var LIGHTSHAPE_SPHERE = 3;
var lightShapeNames = {
		[LIGHTSHAPE_PUNCTUAL]: 'PUNCTUAL',
		[LIGHTSHAPE_RECT]: 'RECT',
		[LIGHTSHAPE_DISK]: 'DISK',
		[LIGHTSHAPE_SPHERE]: 'SPHERE'
};
var LIGHTFALLOFF_LINEAR = 0;
var LIGHTFALLOFF_INVERSESQUARED = 1;
var lightFalloffNames = {
		[LIGHTFALLOFF_LINEAR]: 'LINEAR',
		[LIGHTFALLOFF_INVERSESQUARED]: 'INVERSESQUARED'
};
var SHADOW_PCF3_32F = 0;
var SHADOW_PCF3 = 0;
var SHADOW_VSM_16F = 2;
var SHADOW_VSM16 = 2;
var SHADOW_VSM_32F = 3;
var SHADOW_VSM32 = 3;
var SHADOW_PCF5_32F = 4;
var SHADOW_PCF5 = 4;
var SHADOW_PCF1_32F = 5;
var SHADOW_PCF1 = 5;
var SHADOW_PCSS_32F = 6;
var SHADOW_PCF1_16F = 7;
var SHADOW_PCF3_16F = 8;
var SHADOW_PCF5_16F = 9;
var shadowTypeInfo = new Map([
		[
				SHADOW_PCF1_32F,
				{
						name: 'PCF1_32F',
						kind: 'PCF1',
						format: PIXELFORMAT_DEPTH,
						pcf: true
				}
		],
		[
				SHADOW_PCF3_32F,
				{
						name: 'PCF3_32F',
						kind: 'PCF3',
						format: PIXELFORMAT_DEPTH,
						pcf: true
				}
		],
		[
				SHADOW_PCF5_32F,
				{
						name: 'PCF5_32F',
						kind: 'PCF5',
						format: PIXELFORMAT_DEPTH,
						pcf: true
				}
		],
		[
				SHADOW_PCF1_16F,
				{
						name: 'PCF1_16F',
						kind: 'PCF1',
						format: PIXELFORMAT_DEPTH16,
						pcf: true
				}
		],
		[
				SHADOW_PCF3_16F,
				{
						name: 'PCF3_16F',
						kind: 'PCF3',
						format: PIXELFORMAT_DEPTH16,
						pcf: true
				}
		],
		[
				SHADOW_PCF5_16F,
				{
						name: 'PCF5_16F',
						kind: 'PCF5',
						format: PIXELFORMAT_DEPTH16,
						pcf: true
				}
		],
		[
				SHADOW_VSM_16F,
				{
						name: 'VSM_16F',
						kind: 'VSM',
						format: PIXELFORMAT_RGBA16F,
						vsm: true
				}
		],
		[
				SHADOW_VSM_32F,
				{
						name: 'VSM_32F',
						kind: 'VSM',
						format: PIXELFORMAT_RGBA32F,
						vsm: true
				}
		],
		[
				SHADOW_PCSS_32F,
				{
						name: 'PCSS_32F',
						kind: 'PCSS',
						format: PIXELFORMAT_R32F,
						pcss: true
				}
		]
]);
var BLUR_BOX = 0;
var BLUR_GAUSSIAN = 1;
var PARTICLESORT_NONE = 0;
var PARTICLESORT_DISTANCE = 1;
var PARTICLESORT_NEWER_FIRST = 2;
var PARTICLESORT_OLDER_FIRST = 3;
var PARTICLEMODE_GPU = 0;
var PARTICLEMODE_CPU = 1;
var EMITTERSHAPE_BOX = 0;
var EMITTERSHAPE_SPHERE = 1;
var PARTICLEORIENTATION_SCREEN = 0;
var PARTICLEORIENTATION_WORLD = 1;
var PARTICLEORIENTATION_EMITTER = 2;
var PROJECTION_PERSPECTIVE = 0;
var PROJECTION_ORTHOGRAPHIC = 1;
var RENDERSTYLE_SOLID = 0;
var RENDERSTYLE_WIREFRAME = 1;
var RENDERSTYLE_POINTS = 2;
var CUBEPROJ_NONE = 0;
var CUBEPROJ_BOX = 1;
var cubemaProjectionNames = {
		[CUBEPROJ_NONE]: 'NONE',
		[CUBEPROJ_BOX]: 'BOX'
};
var DETAILMODE_MUL = 'mul';
var DETAILMODE_ADD = 'add';
var DETAILMODE_SCREEN = 'screen';
var DETAILMODE_OVERLAY = 'overlay';
var DETAILMODE_MIN = 'min';
var DETAILMODE_MAX = 'max';
var GAMMA_NONE = 0;
var GAMMA_SRGB = 1;
var gammaNames = {
		[GAMMA_NONE]: 'NONE',
		[GAMMA_SRGB]: 'SRGB'
};
var TONEMAP_LINEAR = 0;
var TONEMAP_FILMIC = 1;
var TONEMAP_HEJL = 2;
var TONEMAP_ACES = 3;
var TONEMAP_ACES2 = 4;
var TONEMAP_NEUTRAL = 5;
var TONEMAP_NONE = 6;
var tonemapNames = [
		'LINEAR',
		'FILMIC',
		'HEJL',
		'ACES',
		'ACES2',
		'NEUTRAL',
		'NONE'
];
var SPECOCC_NONE = 0;
var SPECOCC_AO = 1;
var SPECOCC_GLOSSDEPENDENT = 2;
var specularOcclusionNames = {
		[SPECOCC_NONE]: 'NONE',
		[SPECOCC_AO]: 'AO',
		[SPECOCC_GLOSSDEPENDENT]: 'GLOSSDEPENDENT'
};
var REFLECTIONSRC_NONE = 'none';
var REFLECTIONSRC_ENVATLAS = 'envAtlas';
var REFLECTIONSRC_ENVATLASHQ = 'envAtlasHQ';
var REFLECTIONSRC_CUBEMAP = 'cubeMap';
var REFLECTIONSRC_SPHEREMAP = 'sphereMap';
var reflectionSrcNames = {
		[REFLECTIONSRC_NONE]: 'NONE',
		[REFLECTIONSRC_ENVATLAS]: 'ENVATLAS',
		[REFLECTIONSRC_ENVATLASHQ]: 'ENVATLASHQ',
		[REFLECTIONSRC_CUBEMAP]: 'CUBEMAP',
		[REFLECTIONSRC_SPHEREMAP]: 'SPHEREMAP'
};
var AMBIENTSRC_AMBIENTSH = 'ambientSH';
var AMBIENTSRC_ENVALATLAS = 'envAtlas';
var AMBIENTSRC_CONSTANT = 'constant';
var ambientSrcNames = {
		[AMBIENTSRC_AMBIENTSH]: 'AMBIENTSH',
		[AMBIENTSRC_ENVALATLAS]: 'ENVALATLAS',
		[AMBIENTSRC_CONSTANT]: 'CONSTANT'
};
var SHADERDEF_NOSHADOW = 1;
var SHADERDEF_SKIN = 2;
var SHADERDEF_UV0 = 4;
var SHADERDEF_UV1 = 8;
var SHADERDEF_VCOLOR = 16;
var SHADERDEF_INSTANCING = 32;
var SHADERDEF_LM = 64;
var SHADERDEF_DIRLM = 128;
var SHADERDEF_SCREENSPACE = 256;
var SHADERDEF_TANGENTS = 512;
var SHADERDEF_MORPH_POSITION = 1024;
var SHADERDEF_MORPH_NORMAL = 2048;
var SHADERDEF_LMAMBIENT = 4096;
var SHADERDEF_MORPH_TEXTURE_BASED_INT = 8192;
var SHADERDEF_BATCH = 16384;
var SHADOWUPDATE_NONE = 0;
var SHADOWUPDATE_THISFRAME = 1;
var SHADOWUPDATE_REALTIME = 2;
var MASK_AFFECT_DYNAMIC = 1;
var MASK_AFFECT_LIGHTMAPPED = 2;
var MASK_BAKE = 4;
var SHADER_FORWARD = 0;
var SHADER_PREPASS = 1;
var SHADER_DEPTH = 2;
var SHADER_PICK = 3;
var SHADER_SHADOW = 4;
var SHADERPASS_FORWARD = 'forward';
var SHADERPASS_ALBEDO = 'debug_albedo';
var SHADERPASS_WORLDNORMAL = 'debug_world_normal';
var SHADERPASS_OPACITY = 'debug_opacity';
var SHADERPASS_SPECULARITY = 'debug_specularity';
var SHADERPASS_GLOSS = 'debug_gloss';
var SHADERPASS_METALNESS = 'debug_metalness';
var SHADERPASS_AO = 'debug_ao';
var SHADERPASS_EMISSION = 'debug_emission';
var SHADERPASS_LIGHTING = 'debug_lighting';
var SHADERPASS_UV0 = 'debug_uv0';
var SPRITE_RENDERMODE_SIMPLE = 0;
var SPRITE_RENDERMODE_SLICED = 1;
var SPRITE_RENDERMODE_TILED = 2;
var spriteRenderModeNames = {
		[SPRITE_RENDERMODE_SIMPLE]: 'SIMPLE',
		[SPRITE_RENDERMODE_SLICED]: 'SLICED',
		[SPRITE_RENDERMODE_TILED]: 'TILED'
};
var BAKE_COLOR = 0;
var BAKE_COLORDIR = 1;
var VIEW_CENTER = 0;
var VIEW_LEFT = 1;
var VIEW_RIGHT = 2;
var SORTMODE_NONE = 0;
var SORTMODE_MANUAL = 1;
var SORTMODE_MATERIALMESH = 2;
var SORTMODE_BACK2FRONT = 3;
var SORTMODE_FRONT2BACK = 4;
var SORTMODE_CUSTOM = 5;
var ASPECT_AUTO = 0;
var ASPECT_MANUAL = 1;
var ORIENTATION_HORIZONTAL = 0;
var ORIENTATION_VERTICAL = 1;
var SKYTYPE_INFINITE = 'infinite';
var SKYTYPE_BOX = 'box';
var SKYTYPE_DOME = 'dome';
var DITHER_NONE = 'none';
var DITHER_BAYER8 = 'bayer8';
var DITHER_BLUENOISE = 'bluenoise';
var DITHER_IGNNOISE = 'ignnoise';
var EVENT_PRERENDER = 'prerender';
var EVENT_POSTRENDER = 'postrender';
var EVENT_PRERENDER_LAYER = 'prerender:layer';
var EVENT_POSTRENDER_LAYER = 'postrender:layer';
var EVENT_PRECULL = 'precull';
var EVENT_POSTCULL = 'postcull';

class ShaderProcessorOptions {
		hasUniform(name) {
				for(var i = 0; i < this.uniformFormats.length; i++){
						var uniformFormat = this.uniformFormats[i];
						if (uniformFormat == null ? void 0 : uniformFormat.get(name)) {
								return true;
						}
				}
				return false;
		}
		hasTexture(name) {
				for(var i = 0; i < this.bindGroupFormats.length; i++){
						var groupFormat = this.bindGroupFormats[i];
						if (groupFormat == null ? void 0 : groupFormat.getTexture(name)) {
								return true;
						}
				}
				return false;
		}
		getVertexElement(semantic) {
				var _this_vertexFormat;
				return (_this_vertexFormat = this.vertexFormat) == null ? void 0 : _this_vertexFormat.elements.find((element)=>element.name === semantic);
		}
		generateKey(device) {
				var key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
				if (device.isWebGPU) {
						var _this_vertexFormat;
						key += (_this_vertexFormat = this.vertexFormat) == null ? void 0 : _this_vertexFormat.shaderProcessingHashString;
				}
				return key;
		}
		constructor(viewUniformFormat, viewBindGroupFormat, vertexFormat){
				this.uniformFormats = [];
				this.bindGroupFormats = [];
				this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
				this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
				this.vertexFormat = vertexFormat;
		}
}

var alphaTestPS = "\nuniform float alpha_ref;\nvoid alphaTest(float a) {\n	if (a < alpha_ref) discard;\n}\n";

var ambientPS = '\n#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH\n	uniform vec3 ambientSH[9];\n#endif\n#if LIT_AMBIENT_SOURCE == ENVALATLAS\n	#include "envAtlasPS"\n	#ifndef ENV_ATLAS\n	#define ENV_ATLAS\n	uniform sampler2D texture_envAtlas;\n	#endif\n#endif\nvoid addAmbient(vec3 worldNormal) {\n	#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH\n		vec3 n = cubeMapRotate(worldNormal);\n		vec3 color =\n			ambientSH[0] +\n			ambientSH[1] * n.x +\n			ambientSH[2] * n.y +\n			ambientSH[3] * n.z +\n			ambientSH[4] * n.x * n.z +\n			ambientSH[5] * n.z * n.y +\n			ambientSH[6] * n.y * n.x +\n			ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n			ambientSH[8] * (n.x * n.x - n.y * n.y);\n		dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n	#endif\n	#if LIT_AMBIENT_SOURCE == ENVALATLAS\n		vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));\n		vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n		vec4 raw = texture2D(texture_envAtlas, uv);\n		vec3 linear = {ambientDecode}(raw);\n		dDiffuseLight += processEnvironment(linear);\n	#endif\n	#if LIT_AMBIENT_SOURCE == CONSTANT\n		dDiffuseLight += light_globalAmbient;\n	#endif\n}\n';

var aoPS = "\n#ifdef MAPTEXTURE\n	#define AO_INTENSITY\n#endif\n#ifdef MAPVERTEX\n	#define AO_INTENSITY\n#endif\n#ifdef AO_INTENSITY\n	uniform float material_aoIntensity;\n#endif\nvoid getAO() {\n	dAo = 1.0;\n	#ifdef MAPTEXTURE\n		float aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n		dAo *= addAoDetail(aoBase);\n	#endif\n	#ifdef MAPVERTEX\n		dAo *= saturate(vVertexColor.$VC);\n	#endif\n	#ifdef AO_INTENSITY\n		dAo = mix(1.0, dAo, material_aoIntensity);\n	#endif\n}\n";

var aoDetailMapPS = "\nfloat addAoDetail(float ao) {\n#ifdef MAPTEXTURE\n	float aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	return detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;\n#else\n	return ao;\n#endif\n}\n";

var aoDiffuseOccPS = "\nvoid occludeDiffuse(float ao) {\n	dDiffuseLight *= ao;\n}\n";

var aoSpecOccPS = "\n#if LIT_OCCLUDE_SPECULAR != NONE\n	#ifdef LIT_OCCLUDE_SPECULAR_FLOAT\n		uniform float material_occludeSpecularIntensity;\n	#endif\n#endif\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n	#if LIT_OCCLUDE_SPECULAR == AO\n		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT\n			float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);\n		#else\n			float specOcc = ao;\n		#endif\n	#endif\n	#if LIT_OCCLUDE_SPECULAR == GLOSSDEPENDENT\n		float specPow = exp2(gloss * 11.0);\n		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT\n			specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n		#endif\n	#endif\n	#if LIT_OCCLUDE_SPECULAR != NONE\n		dSpecularLight *= specOcc;\n		dReflection *= specOcc;\n		#ifdef LIT_SHEEN\n			sSpecularLight *= specOcc;\n			sReflection *= specOcc;\n		#endif\n	#endif\n}\n";

var basePS = "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n	return x*x;\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n	return clamp(x, vec3(0.0), vec3(1.0));\n}\n";

var baseNineSlicedPS = "\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

var baseNineSlicedTiledPS = "\n#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

var bayerPS = "\nfloat bayer2(vec2 p) {\n	return mod(2.0 * p.y + p.x + 1.0, 4.0);\n}\nfloat bayer4(vec2 p) {\n	vec2 p1 = mod(p, 2.0);\n	vec2 p2 = floor(0.5 * mod(p, 4.0));\n	return 4.0 * bayer2(p1) + bayer2(p2);\n}\nfloat bayer8(vec2 p) {\n	vec2 p1 = mod(p, 2.0);\n	vec2 p2 = floor(0.5 * mod(p, 4.0));\n	vec2 p4 = floor(0.25 * mod(p, 8.0));\n	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);\n}\n";

var blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\nvoid main(void) {\n	vec3 moments = vec3(0.0);\n	vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n	for (int i=0; i<SAMPLES; i++) {\n		vec4 c = texture2D(source, uv + pixelOffset * float(i));\n		#ifdef GAUSS\n		moments += c.xyz * weight[i];\n		#else\n		moments += c.xyz;\n		#endif\n	}\n	#ifndef GAUSS\n	moments /= float(SAMPLES);\n	#endif\n	gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n}\n";

var clearCoatPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\nvoid getClearCoat() {\n	ccSpecularity = 1.0;\n	#ifdef MAPFLOAT\n	ccSpecularity *= material_clearCoat;\n	#endif\n	#ifdef MAPTEXTURE\n	ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	ccSpecularity *= saturate(vVertexColor.$VC);\n	#endif\n}\n";

var clearCoatGlossPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoatGloss;\n#endif\nvoid getClearCoatGlossiness() {\n	ccGlossiness = 1.0;\n	#ifdef MAPFLOAT\n	ccGlossiness *= material_clearCoatGloss;\n	#endif\n	#ifdef MAPTEXTURE\n	ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	ccGlossiness *= saturate(vVertexColor.$VC);\n	#endif\n	#ifdef MAPINVERT\n	ccGlossiness = 1.0 - ccGlossiness;\n	#endif\n	ccGlossiness += 0.0000001;\n}\n";

var clearCoatNormalPS = "\n#ifdef MAPTEXTURE\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n#ifdef MAPTEXTURE\n	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n	ccNormalW = normalize(dTBN * normalMap);\n#else\n	ccNormalW = dVertexNormalW;\n#endif\n}\n";

var clusteredLightUtilsPS = "\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n	vec3 vAbs = abs(dir);\n	float ma;\n	vec2 uv;\n	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n		ma = 0.5 / vAbs.z;\n		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n		tileOffset.x = 2.0;\n		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n	} else if(vAbs.y >= vAbs.x) {\n		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n		ma = 0.5 / vAbs.y;\n		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n		tileOffset.x = 1.0;\n		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n	} else {\n		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n		ma = 0.5 / vAbs.x;\n		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n		tileOffset.x = 0.0;\n		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n	}\n	return uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n	float faceIndex;\n	vec2 tileOffset;\n	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n	float atlasFaceSize = omniAtlasViewport.z;\n	float tileSize = shadowTextureResolution * atlasFaceSize;\n	float offset = shadowEdgePixels / tileSize;\n	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n	uv *= atlasFaceSize;\n	uv += tileOffset * atlasFaceSize;\n	uv += omniAtlasViewport.xy;\n	return uv;\n}\n";

var clusteredLightCookiesPS = "\nvec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, vec4 cookieChannel) {\n	vec4 pixel = mix(vec4(1.0), texture2DLod(tex, uv, 0.0), intensity);\n	bool isRgb = dot(cookieChannel.rgb, vec3(1.0)) == 3.0;\n	return isRgb ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, vec4 cookieChannel) {\n	vec4 projPos = transform * vec4(worldPosition, 1.0);\n	return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, cookieChannel);\n}\nvec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n	return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, cookieChannel);\n}\n";

var clusteredLightShadowsPS = "\nvec3 _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n	vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n	projPos.xyz /= projPos.w;\n	return projPos.xyz;\n}\nvec3 getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {\n	vec3 wPos = vPositionW + normal * shadowParams.y;\n	return _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n	float distScale = length(lightDir);\n	vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n	vec3 dir = wPos - lightPos;\n	return dir;\n}\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\nfloat getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n	float shadowTextureResolution = shadowParams.x;\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	return textureShadow(shadowMap, vec3(uv, shadowZ));\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\nfloat getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n	float shadowTextureResolution = shadowParams.x;\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	vec3 shadowCoord = vec3(uv, shadowZ);\n	return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\nfloat getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n	float shadowTextureResolution = shadowParams.x;\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	vec3 shadowCoord = vec3(uv, shadowZ);\n	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\nfloat getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\nfloat getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\nfloat getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n";

var clusteredLightPS = '\n#include "lightBufferDefinesPS"\n#include "clusteredLightUtilsPS"\n#ifdef CLUSTER_COOKIES\n	#include "clusteredLightCookiesPS"\n#endif\n#ifdef CLUSTER_SHADOWS\n	#include "clusteredLightShadowsPS"\n#endif\nuniform highp sampler2D clusterWorldTexture;\nuniform highp sampler2D lightsTexture;\n#ifdef CLUSTER_SHADOWS\n	uniform sampler2DShadow shadowAtlasTexture;\n#endif\n#ifdef CLUSTER_COOKIES\n	uniform sampler2D cookieAtlasTexture;\n#endif\nuniform int clusterMaxCells;\nuniform float clusterSkip;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 shadowAtlasParams;\nstruct ClusterLightData {\n	uint flags;\n	vec3 halfWidth;\n	bool isSpot;\n	vec3 halfHeight;\n	int lightIndex;\n	vec3 position;\n	uint shape;\n	vec3 direction;\n	bool falloffModeLinear;\n	vec3 color;\n	float shadowIntensity;\n	vec3 omniAtlasViewport;\n	float range;\n	vec4 cookieChannelMask;\n	float biasesData;\n	float shadowBias;\n	float shadowNormalBias;\n	float anglesData;\n	float innerConeAngleCos;\n	float outerConeAngleCos;\n	float cookieIntensity;\n	bool isDynamic;\n	bool isLightmapped;\n};\nmat4 lightProjectionMatrix;\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {\n	return texelFetch(lightsTexture, ivec2(index, clusterLightData.lightIndex), 0);\n}\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n	clusterLightData.lightIndex = int(lightIndex);\n	vec4 halfData = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_COLOR_ANGLES_BIAS);\n	clusterLightData.anglesData = halfData.z;\n	clusterLightData.biasesData = halfData.w;\n	vec2 colorRG = unpackHalf2x16(floatBitsToUint(halfData.x));\n	vec2 colorB_ = unpackHalf2x16(floatBitsToUint(halfData.y));\n	clusterLightData.color = vec3(colorRG, colorB_.x);\n	vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_POSITION_RANGE);\n	clusterLightData.position = lightPosRange.xyz;\n	clusterLightData.range = lightPosRange.w;\n	vec4 lightDir_Flags = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_DIRECTION_FLAGS);\n	clusterLightData.direction = lightDir_Flags.xyz;\n	clusterLightData.flags = floatBitsToUint(lightDir_Flags.w);\n	clusterLightData.isSpot = (clusterLightData.flags & (1u << 30u)) != 0u;\n	clusterLightData.shape = (clusterLightData.flags >> 28u) & 0x3u;\n	clusterLightData.falloffModeLinear = (clusterLightData.flags & (1u << 27u)) == 0u;\n	clusterLightData.shadowIntensity = float((clusterLightData.flags >> 0u) & 0xFFu) / 255.0;\n	clusterLightData.cookieIntensity = float((clusterLightData.flags >> 8u) & 0xFFu) / 255.0;\n	clusterLightData.isDynamic = (clusterLightData.flags & (1u << 22u)) != 0u;\n	clusterLightData.isLightmapped = (clusterLightData.flags & (1u << 21u)) != 0u;\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n	vec2 angles = unpackHalf2x16(floatBitsToUint(clusterLightData.anglesData));\n	clusterLightData.innerConeAngleCos = angles.x;\n	clusterLightData.outerConeAngleCos = angles.y;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n	clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_0).xyz;\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n	clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_AREA_DATA_WIDTH).xyz;\n	clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_AREA_DATA_HEIGHT).xyz;\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n	\n	vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_0);\n	vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_1);\n	vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_2);\n	vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_3);\n	lightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n	\n	vec2 biases = unpackHalf2x16(floatBitsToUint(clusterLightData.biasesData));\n	clusterLightData.shadowBias = biases.x;\n	clusterLightData.shadowNormalBias = biases.y;\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n	uint cookieFlags = (clusterLightData.flags >> 23u) & 0x0Fu;\n	clusterLightData.cookieChannelMask = vec4(uvec4(cookieFlags) & uvec4(1u, 2u, 4u, 8u));\n	clusterLightData.cookieChannelMask = step(1.0, clusterLightData.cookieChannelMask);\n}\nvoid evaluateLight(\n	ClusterLightData light, \n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir,\n#if defined(LIT_CLEARCOAT)\n	vec3 clearcoatReflectionDir,\n#endif\n	float gloss, \n	vec3 specularity, \n	vec3 geometricNormal, \n	mat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel,\n#endif\n	vec3 clearcoat_worldNormal,\n	float clearcoat_gloss,\n	float sheen_gloss,\n	float iridescence_intensity\n) {\n	vec3 cookieAttenuation = vec3(1.0);\n	float diffuseAttenuation = 1.0;\n	float falloffAttenuation = 1.0;\n	vec3 lightDirW;\n	vec3 lightDirNormW;\n	evalOmniLight(light.position, lightDirW, lightDirNormW);\n	#ifdef CLUSTER_AREALIGHTS\n	if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {\n		decodeClusterLightAreaData(light);\n		if (light.shape == {LIGHTSHAPE_RECT}) {\n			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n		} else if (light.shape == {LIGHTSHAPE_DISK}) {\n			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n		} else {\n			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n		}\n		falloffAttenuation = getFalloffWindow(light.range, lightDirW);\n	} else\n	#endif\n	{\n		if (light.falloffModeLinear)\n			falloffAttenuation = getFalloffLinear(light.range, lightDirW);\n		else\n			falloffAttenuation = getFalloffInvSquared(light.range, lightDirW);\n	}\n	if (falloffAttenuation > 0.00001) {\n		#ifdef CLUSTER_AREALIGHTS\n		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {\n			if (light.shape == {LIGHTSHAPE_RECT}) {\n				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;\n			} else if (light.shape == {LIGHTSHAPE_DISK}) {\n				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;\n			} else {\n				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;\n			}\n		} else\n		#endif\n		{\n			falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, lightDirNormW); \n		}\n		if (light.isSpot) {\n			decodeClusterLightSpot(light);\n			falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, lightDirNormW);\n		}\n		#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n		if (falloffAttenuation > 0.00001) {\n			if (light.shadowIntensity > 0.0 || light.cookieIntensity > 0.0) {\n				if (light.isSpot) {\n					decodeClusterLightProjectionMatrixData(light);\n				} else {\n					decodeClusterLightOmniAtlasViewport(light);\n				}\n				float shadowTextureResolution = shadowAtlasParams.x;\n				float shadowEdgePixels = shadowAtlasParams.y;\n				#ifdef CLUSTER_COOKIES\n				if (light.cookieIntensity > 0.0) {\n					decodeClusterLightCookieData(light);\n					if (light.isSpot) {\n						cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, light.cookieChannelMask);\n					} else {\n						cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), lightDirW, light.cookieIntensity, light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n					}\n				}\n				#endif\n				#ifdef CLUSTER_SHADOWS\n				if (light.shadowIntensity > 0.0) {\n					decodeClusterLightShadowData(light);\n					vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n					if (light.isSpot) {\n						vec3 shadowCoord = getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);\n						\n						#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n							float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n							float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n							float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)\n							float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#endif\n						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n					} else {\n						vec3 dir = normalOffsetPointShadow(shadowParams, light.position, lightDirW, lightDirNormW, geometricNormal);\n						#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n							float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n							float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n							float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n						#endif\n						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n					}\n				}\n				#endif\n			}\n		}\n		#endif\n		#ifdef CLUSTER_AREALIGHTS\n		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {\n			{\n				vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;\n				#if defined(LIT_SPECULAR)\n					areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n				#endif\n				dDiffuseLight += areaDiffuse;\n			}\n			#ifdef LIT_SPECULAR\n				float areaLightSpecular;\n				if (light.shape == {LIGHTSHAPE_RECT}) {\n					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);\n				} else if (light.shape == {LIGHTSHAPE_DISK}) {\n					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);\n				} else {\n					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);\n				}\n				dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;\n				#ifdef LIT_CLEARCOAT\n					float areaLightSpecularCC;\n					if (light.shape == {LIGHTSHAPE_RECT}) {\n						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);\n					} else if (light.shape == {LIGHTSHAPE_DISK}) {\n						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);\n					} else {\n						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);\n					}\n					ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;\n				#endif\n			#endif\n		} else\n		#endif\n		{\n			{\n				vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;\n				#if defined(CLUSTER_AREALIGHTS)\n				#if defined(LIT_SPECULAR)\n					punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);\n				#endif\n				#endif\n				dDiffuseLight += punctualDiffuse;\n			}\n   \n			#ifdef LIT_SPECULAR\n				vec3 halfDir = normalize(-lightDirNormW + viewDir);\n				\n				#ifdef LIT_SPECULAR_FRESNEL\n					dSpecularLight += \n						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * \n						getFresnel(\n							dot(viewDir, halfDir), \n							gloss, \n							specularity\n						#if defined(LIT_IRIDESCENCE)\n							, iridescenceFresnel,\n							iridescence_intensity\n						#endif\n							);\n				#else\n					dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;\n				#endif\n				#ifdef LIT_CLEARCOAT\n					#ifdef LIT_SPECULAR_FRESNEL\n						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));\n					#else\n						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; \n					#endif\n				#endif\n				#ifdef LIT_SHEEN\n					sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, lightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;\n				#endif\n			#endif\n		}\n	}\n	dAtten = falloffAttenuation;\n	dLightDirNormW = lightDirNormW;\n}\nvoid evaluateClusterLight(\n	float lightIndex, \n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n	vec3 clearcoatReflectionDir,\n#endif\n	float gloss, \n	vec3 specularity, \n	vec3 geometricNormal, \n	mat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel,\n#endif\n	vec3 clearcoat_worldNormal,\n	float clearcoat_gloss,\n	float sheen_gloss,\n	float iridescence_intensity\n) {\n	ClusterLightData clusterLightData;\n	decodeClusterLightCore(clusterLightData, lightIndex);\n	#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n		bool acceptLightMask = clusterLightData.isDynamic;\n	#else\n		bool acceptLightMask = clusterLightData.isLightmapped;\n	#endif\n	if (acceptLightMask)\n		evaluateLight(\n			clusterLightData, \n			worldNormal, \n			viewDir, \n			reflectionDir, \n#if defined(LIT_CLEARCOAT)\n			clearcoatReflectionDir, \n#endif\n			gloss, \n			specularity, \n			geometricNormal, \n			tbn, \n#if defined(LIT_IRIDESCENCE)\n			iridescenceFresnel,\n#endif\n			clearcoat_worldNormal,\n			clearcoat_gloss,\n			sheen_gloss,\n			iridescence_intensity\n		);\n}\nvoid addClusteredLights(\n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n	vec3 clearcoatReflectionDir,\n#endif\n	float gloss, \n	vec3 specularity, \n	vec3 geometricNormal, \n	mat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel,\n#endif\n	vec3 clearcoat_worldNormal,\n	float clearcoat_gloss,\n	float sheen_gloss,\n	float iridescence_intensity\n) {\n	if (clusterSkip > 0.5)\n		return;\n	vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n	if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n		float cellIndex = dot(clusterCellsDot, cellCoords);\n		float clusterV = floor(cellIndex * clusterTextureSize.y);\n		float clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n		for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {\n			float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;\n			if (lightIndex <= 0.0)\n					return;\n			evaluateClusterLight(\n				lightIndex * 255.0, \n				worldNormal, \n				viewDir, \n				reflectionDir,\n#if defined(LIT_CLEARCOAT)\n				clearcoatReflectionDir,\n#endif\n				gloss, \n				specularity, \n				geometricNormal, \n				tbn, \n#if defined(LIT_IRIDESCENCE)\n				iridescenceFresnel,\n#endif\n				clearcoat_worldNormal,\n				clearcoat_gloss,\n				sheen_gloss,\n				iridescence_intensity\n			); \n		}\n	}\n}\n';

var combinePS = "\nvec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {\n	vec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n	ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;\n#else\n	ret += albedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n	ret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n	ret += dReflection.rgb * dReflection.a;\n#endif\n#ifdef LIT_SHEEN\n	float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n	ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n	float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;\n	ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n#endif\n	return ret;\n}\n";

var cookiePS = "\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	projPos.xy += cookieOffset;\n	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n	return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	projPos.xy += cookieOffset;\n	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n	return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n	return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

var cubeMapProjectPS = "\n#if LIT_CUBEMAP_PROJECTION == BOX\n	uniform vec3 envBoxMin;\n	uniform vec3 envBoxMax;\n#endif\nvec3 cubeMapProject(vec3 nrdir) {\n	#if LIT_CUBEMAP_PROJECTION == NONE\n		return cubeMapRotate(nrdir);\n	#endif\n	#if LIT_CUBEMAP_PROJECTION == BOX\n		nrdir = cubeMapRotate(nrdir);\n		vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n		vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n		vec3 rbminmax;\n		rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n		rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n		rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n		float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n		vec3 posonbox = vPositionW + nrdir * fa;\n		vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n		return normalize(posonbox - envBoxPos);\n	#endif\n}\n";

var cubeMapRotatePS = "\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n	return refDir * cubeMapRotationMatrix;\n#else\n	return refDir;\n#endif\n}\n";

var debugOutputPS = "\n#ifdef DEBUG_ALBEDO_PASS\ngl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);\n#endif\n#ifdef DEBUG_UV0_PASS\ngl_FragColor = vec4(litArgs_albedo , 1.0);\n#endif\n#ifdef DEBUG_WORLD_NORMAL_PASS\ngl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);\n#endif\n#ifdef DEBUG_OPACITY_PASS\ngl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);\n#endif\n#ifdef DEBUG_SPECULARITY_PASS\ngl_FragColor = vec4(litArgs_specularity, 1.0);\n#endif\n#ifdef DEBUG_GLOSS_PASS\ngl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);\n#endif\n#ifdef DEBUG_METALNESS_PASS\ngl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);\n#endif\n#ifdef DEBUG_AO_PASS\ngl_FragColor = vec4(vec3(litArgs_ao) , 1.0);\n#endif\n#ifdef DEBUG_EMISSION_PASS\ngl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);\n#endif\n";

var debugProcessFrontendPS = "\n#ifdef DEBUG_LIGHTING_PASS\nlitArgs_albedo = vec3(0.5);\n#endif\n#ifdef DEBUG_UV0_PASS\n#ifdef VARYING_VUV0\nlitArgs_albedo = vec3(vUv0, 0);\n#else\nlitArgs_albedo = vec3(0);\n#endif\n#endif\n";

var decodePS$1 = "\n#ifndef _DECODE_INCLUDED_\n#define _DECODE_INCLUDED_\nvec3 decodeLinear(vec4 raw) {\n	return raw.rgb;\n}\nfloat decodeGamma(float raw) {\n	return pow(raw, 2.2);\n}\nvec3 decodeGamma(vec3 raw) {\n	return pow(raw, vec3(2.2));\n}\nvec3 decodeGamma(vec4 raw) {\n	return pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n	vec3 color = (8.0 * raw.a) * raw.rgb;\n	return color * color;\n}\nvec3 decodeRGBP(vec4 raw) {\n	vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n	return color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n	if (raw.a == 0.0) {\n		return vec3(0.0, 0.0, 0.0);\n	} else {\n		return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n	}\n}\nvec4 passThrough(vec4 raw) {\n	return raw;\n}\n#endif\n";

var detailModesPS = "\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n	return c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n	return c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n	return 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n	return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n	return min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n	return max(c1, c2);\n}\n";

var diffusePS = "\nuniform vec3 material_diffuse;\nvoid getAlbedo() {\n	dAlbedo = material_diffuse.rgb;\n#ifdef MAPTEXTURE\n	vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n	dAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n#ifdef MAPVERTEX\n	dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}\n";

var diffuseDetailMapPS = "\nvec3 addAlbedoDetail(vec3 albedo) {\n#ifdef MAPTEXTURE\n	vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n	return detailMode_$DETAILMODE(albedo, albedoDetail);\n#else\n	return albedo;\n#endif\n}\n";

var emissivePS = "\nuniform vec3 material_emissive;\nuniform float material_emissiveIntensity;\nvoid getEmission() {\n	dEmission = material_emissive * material_emissiveIntensity;\n	#ifdef MAPTEXTURE\n	dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n	#endif\n}\n";

var encodePS$1 = "\nvec4 encodeLinear(vec3 source) {\n	return vec4(source, 1.0);\n}\nvec4 encodeGamma(vec3 source) {\n	return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec4 encodeRGBM(vec3 source) {\n	vec4 result;\n	result.rgb = pow(source.rgb, vec3(0.5));\n	result.rgb *= 1.0 / 8.0;\n	result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n	result.a = ceil(result.a * 255.0) / 255.0;\n	result.rgb /= result.a;\n	return result;\n}\nvec4 encodeRGBP(vec3 source) {\n	vec3 gamma = pow(source, vec3(0.5));\n	float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n	float v = 1.0 - ((maxVal - 1.0) / 7.0);\n	v = ceil(v * 255.0) / 255.0;\n	return vec4(gamma / (-v * 7.0 + 8.0), v);	\n}\nvec4 encodeRGBE(vec3 source) {\n	float maxVal = max(source.x, max(source.y, source.z));\n	if (maxVal < 1e-32) {\n		return vec4(0, 0, 0, 0);\n	} else {\n		float e = ceil(log2(maxVal));\n		return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n	}\n}\n";

var endPS = "\n	gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);\n	gl_FragColor.rgb += litArgs_emission;\n	gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n	gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n	gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n";

var envAtlasPS$1 = "\n#ifndef _ENVATLAS_INCLUDED_\n#define _ENVATLAS_INCLUDED_\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n	return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n				mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n	float t = 1.0 / exp2(level);\n	return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapShinyUv(vec2 uv, float level) {\n	float t = 1.0 / exp2(level);\n	return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n#endif\n";

var envProcPS$1 = "\n#ifdef LIT_SKYBOX_INTENSITY\n	uniform float skyboxIntensity;\n#endif\nvec3 processEnvironment(vec3 color) {\n	#ifdef LIT_SKYBOX_INTENSITY\n		return color * skyboxIntensity;\n	#else\n		return color;\n	#endif\n}\n";

var falloffInvSquaredPS = "\nfloat getFalloffWindow(float lightRadius, vec3 lightDir) {\n	float sqrDist = dot(lightDir, lightDir);\n	float invRadius = 1.0 / lightRadius;\n	return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius, vec3 lightDir) {\n	float sqrDist = dot(lightDir, lightDir);\n	float falloff = 1.0 / (sqrDist + 1.0);\n	float invRadius = 1.0 / lightRadius;\n	falloff *= 16.0;\n	falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n	return falloff;\n}\n";

var falloffLinearPS = "\nfloat getFalloffLinear(float lightRadius, vec3 lightDir) {\n	float d = length(lightDir);\n	return max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

var floatAsUintPS = "\n#ifndef FLOAT_AS_UINT\n#define FLOAT_AS_UINT\nvec4 float2uint(float value) {\n	uint intBits = floatBitsToUint(value);\n	return vec4(\n		float((intBits >> 24u) & 0xFFu) / 255.0,\n		float((intBits >> 16u) & 0xFFu) / 255.0,\n		float((intBits >> 8u) & 0xFFu) / 255.0,\n		float(intBits & 0xFFu) / 255.0\n	);\n}\nfloat uint2float(vec4 value) {\n	uint intBits = \n		(uint(value.r * 255.0) << 24u) |\n		(uint(value.g * 255.0) << 16u) |\n		(uint(value.b * 255.0) << 8u) |\n		uint(value.a * 255.0);\n	return uintBitsToFloat(intBits);\n}\n#endif\n";

var fogPS$1 = "\nfloat dBlendModeFogFactor = 1.0;\n#if (FOG != NONE)\n	uniform vec3 fog_color;\n	#if (FOG == LINEAR)\n		uniform float fog_start;\n		uniform float fog_end;\n	#else\n		uniform float fog_density;\n	#endif\n#endif\nfloat getFogFactor() {\n	float depth = gl_FragCoord.z / gl_FragCoord.w;\n	float fogFactor = 0.0;\n	#if (FOG == LINEAR)\n		fogFactor = (fog_end - depth) / (fog_end - fog_start);\n	#elif (FOG == EXP)\n		fogFactor = exp(-depth * fog_density);\n	#elif (FOG == EXP2)\n		fogFactor = exp(-depth * depth * fog_density * fog_density);\n	#endif\n	return clamp(fogFactor, 0.0, 1.0);\n}\nvec3 addFog(vec3 color) {\n	#if (FOG != NONE)\n		return mix(fog_color * dBlendModeFogFactor, color, getFogFactor());\n	#endif\n	return color;\n}\n";

var fresnelSchlickPS = "\nvec3 getFresnel(\n		float cosTheta, \n		float gloss, \n		vec3 specularity\n#if defined(LIT_IRIDESCENCE)\n		, vec3 iridescenceFresnel, \n		float iridescenceIntensity\n#endif\n	) {\n	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n	float glossSq = gloss * gloss;\n	vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;\n#if defined(LIT_IRIDESCENCE)\n	return mix(ret, iridescenceFresnel, iridescenceIntensity);\n#else\n	return ret;\n#endif	\n}\nfloat getFresnelCC(float cosTheta) {\n	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n	return 0.04 + (1.0 - 0.04) * fresnel;\n}\n";

var fullscreenQuadPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n	gl_FragColor = texture2D(source, vUv0);\n}\n";

var fullscreenQuadVS = "\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n	gl_Position = vec4(vertex_position, 0.5, 1.0);\n	vUv0 = vertex_position.xy*0.5+0.5;\n}\n";

var gammaPS$1 = '\n#include "decodePS"\n#if (GAMMA == SRGB)\n	float gammaCorrectInput(float color) {\n		return decodeGamma(color);\n	}\n	vec3 gammaCorrectInput(vec3 color) {\n		return decodeGamma(color);\n	}\n	vec4 gammaCorrectInput(vec4 color) {\n		return vec4(decodeGamma(color.xyz), color.w);\n	}\n	vec3 gammaCorrectOutput(vec3 color) {\n		return pow(color + 0.0000001, vec3(1.0 / 2.2));\n	}\n#else\n	float gammaCorrectInput(float color) {\n		return color;\n	}\n	vec3 gammaCorrectInput(vec3 color) {\n		return color;\n	}\n	vec4 gammaCorrectInput(vec4 color) {\n		return color;\n	}\n	vec3 gammaCorrectOutput(vec3 color) {\n		return color;\n	}\n#endif\n';

var glossPS = "\n#ifdef MAPFLOAT\nuniform float material_gloss;\n#endif\nvoid getGlossiness() {\n	dGlossiness = 1.0;\n	#ifdef MAPFLOAT\n	dGlossiness *= material_gloss;\n	#endif\n	#ifdef MAPTEXTURE\n	dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	dGlossiness *= saturate(vVertexColor.$VC);\n	#endif\n	#ifdef MAPINVERT\n	dGlossiness = 1.0 - dGlossiness;\n	#endif\n	dGlossiness += 0.0000001;\n}\n";

var gsplatCenterVS = "\nuniform mat4 matrix_model;\nuniform mat4 matrix_view;\nuniform mat4 matrix_projection;\nbool initCenter(vec3 modelCenter, out SplatCenter center) {\n	mat4 modelView = matrix_view * matrix_model;\n	vec4 centerView = modelView * vec4(modelCenter, 1.0);\n	if (centerView.z > 0.0) {\n		return false;\n	}\n	vec4 centerProj = matrix_projection * centerView;\n	centerProj.z = clamp(centerProj.z, -abs(centerProj.w), abs(centerProj.w));\n	center.view = centerView.xyz / centerView.w;\n	center.proj = centerProj;\n	center.projMat00 = matrix_projection[0][0];\n	center.modelView = modelView;\n	return true;\n}\n";

var gsplatColorVS = "\nuniform mediump sampler2D splatColor;\nvec4 readColor(in SplatSource source) {\n	return texelFetch(splatColor, source.uv, 0);\n}\n";

var gsplatCommonVS = '\nstruct SplatSource {\n	uint order;\n	uint id;\n	ivec2 uv;\n	vec2 cornerUV;\n};\nstruct SplatCenter {\n	vec3 view;\n	vec4 proj;\n	mat4 modelView;\n	float projMat00;\n};\nstruct SplatCorner {\n	vec2 offset;\n	vec2 uv;\n};\n#if SH_BANDS > 0\n	#if SH_BANDS == 1\n		#define SH_COEFFS 3\n	#elif SH_BANDS == 2\n		#define SH_COEFFS 8\n	#elif SH_BANDS == 3\n		#define SH_COEFFS 15\n	#endif\n#endif\n#if GSPLAT_COMPRESSED_DATA == true\n	#include "gsplatCompressedDataVS"\n	#include "gsplatCompressedSHVS"\n#else\n	#include "gsplatDataVS"\n	#include "gsplatColorVS"\n	#include "gsplatSHVS"\n#endif\n#include "gsplatSourceVS"\n#include "gsplatCenterVS"\n#include "gsplatCornerVS"\n#include "gsplatOutputVS"\nvoid clipCorner(inout SplatCorner corner, float alpha) {\n	float clip = min(1.0, sqrt(-log(1.0 / 255.0 / alpha)) / 2.0);\n	corner.offset *= clip;\n	corner.uv *= clip;\n}\n#if SH_BANDS > 0\n#define SH_C1 0.4886025119029199f\n#if SH_BANDS > 1\n	#define SH_C2_0 1.0925484305920792f\n	#define SH_C2_1 -1.0925484305920792f\n	#define SH_C2_2 0.31539156525252005f\n	#define SH_C2_3 -1.0925484305920792f\n	#define SH_C2_4 0.5462742152960396f\n#endif\n#if SH_BANDS > 2\n	#define SH_C3_0 -0.5900435899266435f\n	#define SH_C3_1 2.890611442640554f\n	#define SH_C3_2 -0.4570457994644658f\n	#define SH_C3_3 0.3731763325901154f\n	#define SH_C3_4 -0.4570457994644658f\n	#define SH_C3_5 1.445305721320277f\n	#define SH_C3_6 -0.5900435899266435f\n#endif\nvec3 evalSH(in SplatSource source, in vec3 dir) {\n	vec3 sh[SH_COEFFS];\n	float scale;\n	readSHData(source, sh, scale);\n	float x = dir.x;\n	float y = dir.y;\n	float z = dir.z;\n	vec3 result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);\n#if SH_BANDS > 1\n	float xx = x * x;\n	float yy = y * y;\n	float zz = z * z;\n	float xy = x * y;\n	float yz = y * z;\n	float xz = x * z;\n	result +=\n		sh[3] * (SH_C2_0 * xy) *  +\n		sh[4] * (SH_C2_1 * yz) +\n		sh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +\n		sh[6] * (SH_C2_3 * xz) +\n		sh[7] * (SH_C2_4 * (xx - yy));\n#endif\n#if SH_BANDS > 2\n	result +=\n		sh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +\n		sh[9]  * (SH_C3_1 * xy * z) +\n		sh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +\n		sh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\n		sh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +\n		sh[13] * (SH_C3_5 * z * (xx - yy)) +\n		sh[14] * (SH_C3_6 * x * (xx - 3.0 * yy));\n#endif\n	return result * scale;\n}\n#endif\n';

var gsplatCompressedDataVS = "\nuniform highp usampler2D packedTexture;\nuniform highp sampler2D chunkTexture;\nvec4 chunkDataA;\nvec4 chunkDataB;\nvec4 chunkDataC;\nvec4 chunkDataD;\nvec4 chunkDataE;\nuvec4 packedData;\nvec3 unpack111011(uint bits) {\n	return vec3(\n		float(bits >> 21u) / 2047.0,\n		float((bits >> 11u) & 0x3ffu) / 1023.0,\n		float(bits & 0x7ffu) / 2047.0\n	);\n}\nvec4 unpack8888(uint bits) {\n	return vec4(\n		float(bits >> 24u) / 255.0,\n		float((bits >> 16u) & 0xffu) / 255.0,\n		float((bits >> 8u) & 0xffu) / 255.0,\n		float(bits & 0xffu) / 255.0\n	);\n}\nconst float norm = 1.0 / (sqrt(2.0) * 0.5);\nvec4 unpackRotation(uint bits) {\n	float a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n	float b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n	float c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;\n	float m = sqrt(1.0 - (a * a + b * b + c * c));\n	uint mode = bits >> 30u;\n	if (mode == 0u) return vec4(m, a, b, c);\n	if (mode == 1u) return vec4(a, m, b, c);\n	if (mode == 2u) return vec4(a, b, m, c);\n	return vec4(a, b, c, m);\n}\nmat3 quatToMat3(vec4 R) {\n	float x = R.x;\n	float y = R.y;\n	float z = R.z;\n	float w = R.w;\n	return mat3(\n		1.0 - 2.0 * (z * z + w * w),\n			  2.0 * (y * z + x * w),\n			  2.0 * (y * w - x * z),\n			  2.0 * (y * z - x * w),\n		1.0 - 2.0 * (y * y + w * w),\n			  2.0 * (z * w + x * y),\n			  2.0 * (y * w + x * z),\n			  2.0 * (z * w - x * y),\n		1.0 - 2.0 * (y * y + z * z)\n	);\n}\nvec3 readCenter(SplatSource source) {\n	uint w = uint(textureSize(chunkTexture, 0).x) / 5u;\n	uint chunkId = source.id / 256u;\n	ivec2 chunkUV = ivec2((chunkId % w) * 5u, chunkId / w);\n	chunkDataA = texelFetch(chunkTexture, chunkUV, 0);\n	chunkDataB = texelFetch(chunkTexture, chunkUV + ivec2(1, 0), 0);\n	chunkDataC = texelFetch(chunkTexture, chunkUV + ivec2(2, 0), 0);\n	chunkDataD = texelFetch(chunkTexture, chunkUV + ivec2(3, 0), 0);\n	chunkDataE = texelFetch(chunkTexture, chunkUV + ivec2(4, 0), 0);\n	packedData = texelFetch(packedTexture, source.uv, 0);\n	return mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));\n}\nvec4 readColor(in SplatSource source) {\n	vec4 r = unpack8888(packedData.w);\n	return vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);\n}\nvec4 getRotation() {\n	return unpackRotation(packedData.y);\n}\nvec3 getScale() {\n	return exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n	mat3 rot = quatToMat3(getRotation());\n	vec3 scale = getScale();\n	mat3 M = transpose(mat3(\n		scale.x * rot[0],\n		scale.y * rot[1],\n		scale.z * rot[2]\n	));\n	covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n	covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";

var gsplatCompressedSHVS = "\n#if SH_BANDS > 0\nuniform highp usampler2D shTexture0;\nuniform highp usampler2D shTexture1;\nuniform highp usampler2D shTexture2;\nvec4 unpack8888s(in uint bits) {\n	return vec4((uvec4(bits) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu) * (8.0 / 255.0) - 4.0;\n}\nvoid readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n	uvec4 shData0 = texelFetch(shTexture0, source.uv, 0);\n	uvec4 shData1 = texelFetch(shTexture1, source.uv, 0);\n	uvec4 shData2 = texelFetch(shTexture2, source.uv, 0);\n	vec4 r0 = unpack8888s(shData0.x);\n	vec4 r1 = unpack8888s(shData0.y);\n	vec4 r2 = unpack8888s(shData0.z);\n	vec4 r3 = unpack8888s(shData0.w);\n	vec4 g0 = unpack8888s(shData1.x);\n	vec4 g1 = unpack8888s(shData1.y);\n	vec4 g2 = unpack8888s(shData1.z);\n	vec4 g3 = unpack8888s(shData1.w);\n	vec4 b0 = unpack8888s(shData2.x);\n	vec4 b1 = unpack8888s(shData2.y);\n	vec4 b2 = unpack8888s(shData2.z);\n	vec4 b3 = unpack8888s(shData2.w);\n	sh[0] =  vec3(r0.x, g0.x, b0.x);\n	sh[1] =  vec3(r0.y, g0.y, b0.y);\n	sh[2] =  vec3(r0.z, g0.z, b0.z);\n	sh[3] =  vec3(r0.w, g0.w, b0.w);\n	sh[4] =  vec3(r1.x, g1.x, b1.x);\n	sh[5] =  vec3(r1.y, g1.y, b1.y);\n	sh[6] =  vec3(r1.z, g1.z, b1.z);\n	sh[7] =  vec3(r1.w, g1.w, b1.w);\n	sh[8] =  vec3(r2.x, g2.x, b2.x);\n	sh[9] =  vec3(r2.y, g2.y, b2.y);\n	sh[10] = vec3(r2.z, g2.z, b2.z);\n	sh[11] = vec3(r2.w, g2.w, b2.w);\n	sh[12] = vec3(r3.x, g3.x, b3.x);\n	sh[13] = vec3(r3.y, g3.y, b3.y);\n	sh[14] = vec3(r3.z, g3.z, b3.z);\n	scale = 1.0;\n}\n#endif\n";

var gsplatCornerVS = "\nuniform vec2 viewport;\nuniform vec4 camera_params;\nbool initCorner(SplatSource source, SplatCenter center, out SplatCorner corner) {\n	vec3 covA, covB;\n	readCovariance(source, covA, covB);\n	mat3 Vrk = mat3(\n		covA.x, covA.y, covA.z, \n		covA.y, covB.x, covB.y,\n		covA.z, covB.y, covB.z\n	);\n	float focal = viewport.x * center.projMat00;\n	vec3 v = camera_params.w == 1.0 ? vec3(0.0, 0.0, 1.0) : center.view.xyz;\n	float J1 = focal / v.z;\n	vec2 J2 = -J1 / v.z * v.xy;\n	mat3 J = mat3(\n		J1, 0.0, J2.x, \n		0.0, J1, J2.y, \n		0.0, 0.0, 0.0\n	);\n	mat3 W = transpose(mat3(center.modelView));\n	mat3 T = W * J;\n	mat3 cov = transpose(T) * Vrk * T;\n	float diagonal1 = cov[0][0] + 0.3;\n	float offDiagonal = cov[0][1];\n	float diagonal2 = cov[1][1] + 0.3;\n	float mid = 0.5 * (diagonal1 + diagonal2);\n	float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n	float lambda1 = mid + radius;\n	float lambda2 = max(mid - radius, 0.1);\n	float l1 = 2.0 * min(sqrt(2.0 * lambda1), 1024.0);\n	float l2 = 2.0 * min(sqrt(2.0 * lambda2), 1024.0);\n	if (l1 < 2.0 && l2 < 2.0) {\n		return false;\n	}\n	vec2 c = center.proj.ww / viewport;\n	if (any(greaterThan(abs(center.proj.xy) - vec2(max(l1, l2)) * c, center.proj.ww))) {\n		return false;\n	}\n	vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n	vec2 v1 = l1 * diagonalVector;\n	vec2 v2 = l2 * vec2(diagonalVector.y, -diagonalVector.x);\n	corner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) * c;\n	corner.uv = source.cornerUV;\n	return true;\n}\n";

var gsplatDataVS = "\nuniform highp usampler2D transformA;\nuniform highp sampler2D transformB;\nuint tAw;\nvec3 readCenter(SplatSource source) {\n	uvec4 tA = texelFetch(transformA, source.uv, 0);\n	tAw = tA.w;\n	return uintBitsToFloat(tA.xyz);\n}\nmat3 quatToMat3(vec4 R) {\n	float x = R.w;\n	float y = R.x;\n	float z = R.y;\n	float w = R.z;\n	return mat3(\n		1.0 - 2.0 * (z * z + w * w),\n			  2.0 * (y * z + x * w),\n			  2.0 * (y * w - x * z),\n			  2.0 * (y * z - x * w),\n		1.0 - 2.0 * (y * y + w * w),\n			  2.0 * (z * w + x * y),\n			  2.0 * (y * w + x * z),\n			  2.0 * (z * w - x * y),\n		1.0 - 2.0 * (y * y + z * z)\n	);\n}\nvec4 unpackRotation(vec3 packed) {\n	return vec4(packed.xyz, sqrt(1.0 - dot(packed, packed)));\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n	vec4 tB = texelFetch(transformB, source.uv, 0);\n	mat3 rot = quatToMat3(unpackRotation(vec3(unpackHalf2x16(tAw), tB.w)));\n	vec3 scale = tB.xyz;\n	\n	mat3 M = transpose(mat3(\n		scale.x * rot[0],\n		scale.y * rot[1],\n		scale.z * rot[2]\n	));\n	covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n	covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";

var gsplatOutputVS = '\n#include "tonemappingPS"\n#include "decodePS"\n#include "gammaPS"\nvec3 prepareOutputFromGamma(vec3 gammaColor) {\n	#if TONEMAP == NONE\n		#if GAMMA == NONE\n			return decodeGamma(gammaColor);\n		#else\n			return gammaColor;\n		#endif\n	#else\n		return gammaCorrectOutput(toneMap(decodeGamma(gammaColor)));\n	#endif\n}\n';

var gsplatPS = '\n#ifndef DITHER_NONE\n	#include "bayerPS"\n	#include "opacityDitherPS"\n	varying float id;\n#endif\n#ifdef PICK_PASS\n	#include "pickPS"\n#endif\n#if defined(SHADOW_PASS) || defined(PICK_PASS)\n	uniform float alphaClip;\n#endif\nvarying mediump vec2 gaussianUV;\nvarying mediump vec4 gaussianColor;\nvoid main(void) {\n	mediump float A = dot(gaussianUV, gaussianUV);\n	if (A > 1.0) {\n		discard;\n	}\n	mediump float alpha = exp(-A * 4.0) * gaussianColor.a;\n	#ifdef PICK_PASS\n		if (alpha < alphaClip) {\n			discard;\n		}\n		gl_FragColor = getPickOutput();\n	#elif SHADOW_PASS\n		if (alpha < alphaClip) {\n			discard;\n		}\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	#else\n		if (alpha < 1.0 / 255.0) {\n			discard;\n		}\n		#ifndef DITHER_NONE\n			opacityDither(alpha, id * 0.013);\n		#endif\n		gl_FragColor = vec4(gaussianColor.xyz * alpha, alpha);\n	#endif\n}\n';

var gsplatSHVS = "\n#if SH_BANDS > 0\nvec3 unpack111011s(uint bits) {\n	return vec3((uvec3(bits) >> uvec3(21u, 11u, 0u)) & uvec3(0x7ffu, 0x3ffu, 0x7ffu)) / vec3(2047.0, 1023.0, 2047.0) * 2.0 - 1.0;\n}\nvoid fetchScale(in uvec4 t, out float scale, out vec3 a, out vec3 b, out vec3 c) {\n	scale = uintBitsToFloat(t.x);\n	a = unpack111011s(t.y);\n	b = unpack111011s(t.z);\n	c = unpack111011s(t.w);\n}\nvoid fetch(in uvec4 t, out vec3 a, out vec3 b, out vec3 c, out vec3 d) {\n	a = unpack111011s(t.x);\n	b = unpack111011s(t.y);\n	c = unpack111011s(t.z);\n	d = unpack111011s(t.w);\n}\nvoid fetch(in uint t, out vec3 a) {\n	a = unpack111011s(t);\n}\n#if SH_BANDS == 1\n	uniform highp usampler2D splatSH_1to3;\n	void readSHData(in SplatSource source, out vec3 sh[3], out float scale) {\n		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n	}\n#elif SH_BANDS == 2\n	uniform highp usampler2D splatSH_1to3;\n	uniform highp usampler2D splatSH_4to7;\n	uniform highp usampler2D splatSH_8to11;\n	void readSHData(in SplatSource source, out vec3 sh[8], out float scale) {\n		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n		fetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);\n		fetch(texelFetch(splatSH_8to11, source.uv, 0).x, sh[7]);\n	}\n#else\n	uniform highp usampler2D splatSH_1to3;\n	uniform highp usampler2D splatSH_4to7;\n	uniform highp usampler2D splatSH_8to11;\n	uniform highp usampler2D splatSH_12to15;\n	void readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n		fetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);\n		fetch(texelFetch(splatSH_8to11, source.uv, 0), sh[7], sh[8], sh[9], sh[10]);\n		fetch(texelFetch(splatSH_12to15, source.uv, 0), sh[11], sh[12], sh[13], sh[14]);\n	}\n#endif\n#endif\n";

var gsplatSourceVS = "\nattribute vec3 vertex_position;\nattribute uint vertex_id_attrib;\nuniform uint numSplats;\nuniform highp usampler2D splatOrder;\nbool initSource(out SplatSource source) {\n	uint w = uint(textureSize(splatOrder, 0).x);\n	source.order = vertex_id_attrib + uint(vertex_position.z);\n	if (source.order >= numSplats) {\n		return false;\n	}\n	ivec2 orderUV = ivec2(source.order % w, source.order / w);\n	source.id = texelFetch(splatOrder, orderUV, 0).r;\n	source.uv = ivec2(source.id % w, source.id / w);\n	source.cornerUV = vertex_position.xy;\n	return true;\n}\n";

var gsplatVS = '\n#include "gsplatCommonVS"\nvarying mediump vec2 gaussianUV;\nvarying mediump vec4 gaussianColor;\n#ifndef DITHER_NONE\n	varying float id;\n#endif\nmediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);\nvoid main(void) {\n	SplatSource source;\n	if (!initSource(source)) {\n		gl_Position = discardVec;\n		return;\n	}\n	vec3 modelCenter = readCenter(source);\n	SplatCenter center;\n	if (!initCenter(modelCenter, center)) {\n		gl_Position = discardVec;\n		return;\n	}\n	SplatCorner corner;\n	if (!initCorner(source, center, corner)) {\n		gl_Position = discardVec;\n		return;\n	}\n	vec4 clr = readColor(source);\n	#if SH_BANDS > 0\n		vec3 dir = normalize(center.view * mat3(center.modelView));\n		clr.xyz += evalSH(source, dir);\n	#endif\n	clipCorner(corner, clr.w);\n	gl_Position = center.proj + vec4(corner.offset, 0, 0);\n	gaussianUV = corner.uv;\n	gaussianColor = vec4(prepareOutputFromGamma(max(clr.xyz, 0.0)), clr.w);\n	#ifndef DITHER_NONE\n		id = float(source.id);\n	#endif\n}\n';

var immediateLinePS$1 = '\n		#include "gammaPS"\n		varying vec4 color;\n		void main(void) {\n			gl_FragColor = vec4(gammaCorrectOutput(decodeGamma(color.rgb)), color.a);\n		}\n';

var immediateLineVS$1 = "\n	attribute vec4 vertex_position;\n	attribute vec4 vertex_color;\n	uniform mat4 matrix_model;\n	uniform mat4 matrix_viewProjection;\n	varying vec4 color;\n	void main(void) {\n		color = vertex_color;\n		gl_Position = matrix_viewProjection * matrix_model * vertex_position;\n	}\n";

var iridescenceDiffractionPS = "\nuniform float material_iridescenceRefractionIndex;\n#ifndef PI\n#define PI 3.14159265\n#endif\nfloat iridescence_iorToFresnel(float transmittedIor, float incidentIor) {\n	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);\n}\nvec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {\n	return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));\n}\nvec3 iridescence_fresnelToIor(vec3 f0) {\n	vec3 sqrtF0 = sqrt(f0);\n	return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\nvec3 iridescence_sensitivity(float opd, vec3 shift) {\n	float phase = 2.0 * PI * opd * 1.0e-9;\n	const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n	const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n	const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n	vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);\n	xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));\n	xyz /= vec3(1.0685e-07);\n	const mat3 XYZ_TO_REC709 = mat3(\n		3.2404542, -0.9692660,  0.0556434,\n	   -1.5371385,  1.8760108, -0.2040259,\n	   -0.4985314,  0.0415560,  1.0572252\n	);\n	return XYZ_TO_REC709 * xyz;\n}\nfloat iridescence_fresnel(float cosTheta, float f0) {\n	float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n	float x2 = x * x;\n	float x5 = x * x2 * x2;\n	return f0 + (1.0 - f0) * x5;\n} \nvec3 iridescence_fresnel(float cosTheta, vec3 f0) {\n	float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n	float x2 = x * x;\n	float x5 = x * x2 * x2; \n	return f0 + (vec3(1.0) - f0) * x5;\n}\nvec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {\n	float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));\n	float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));\n	float cosTheta2Sq = 1.0 - sinTheta2Sq;\n	if (cosTheta2Sq < 0.0) {\n		return vec3(1.0);\n	}\n	float cosTheta2 = sqrt(cosTheta2Sq);\n	float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);\n	float r12 = iridescence_fresnel(cosTheta, r0);\n	float r21 = r12;\n	float t121 = 1.0 - r12;\n	float phi12 = iridescenceIor < outsideIor ? PI : 0.0;\n	float phi21 = PI - phi12;\n	vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));\n	vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);\n	vec3 r23 = iridescence_fresnel(cosTheta2, r1);\n	vec3 phi23 = vec3(0.0);\n	if (baseIor[0] < iridescenceIor) phi23[0] = PI;\n	if (baseIor[1] < iridescenceIor) phi23[1] = PI;\n	if (baseIor[2] < iridescenceIor) phi23[2] = PI;\n	float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;\n	vec3 phi = vec3(phi21) + phi23; \n	vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);\n	vec3 r123 = sqrt(r123Sq);\n	vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);\n	vec3 c0 = r12 + rs;\n	vec3 i = c0;\n	vec3 cm = rs - t121;\n	for (int m = 1; m <= 2; m++) {\n		cm *= r123;\n		vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);\n		i += cm * sm;\n	}\n	return max(i, vec3(0.0));\n}\nvec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {\n	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);\n}\n";

var iridescencePS = "\n#ifdef MAPFLOAT\nuniform float material_iridescence;\n#endif\nvoid getIridescence() {\n	float iridescence = 1.0;\n	#ifdef MAPFLOAT\n	iridescence *= material_iridescence;\n	#endif\n	#ifdef MAPTEXTURE\n	iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	dIridescence = iridescence; \n}\n";

var iridescenceThicknessPS = "\nuniform float material_iridescenceThicknessMax;\n#ifdef MAPTEXTURE\nuniform float material_iridescenceThicknessMin;\n#endif\nvoid getIridescenceThickness() {\n	#ifdef MAPTEXTURE\n	float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);\n	#else\n	float iridescenceThickness = material_iridescenceThicknessMax;\n	#endif\n	dIridescenceThickness = iridescenceThickness; \n}\n";

var iorPS = "\n#ifdef MAPFLOAT\nuniform float material_refractionIndex;\n#endif\nvoid getIor() {\n#ifdef MAPFLOAT\n	dIor = material_refractionIndex;\n#else\n	dIor = 1.0 / 1.5;\n#endif\n}\n";

var lightDeclarationPS = "\n#if defined(LIGHT{i})\n	uniform vec3 light{i}_color;\n	#if LIGHT{i}TYPE == DIRECTIONAL\n		uniform vec3 light{i}_direction;\n	#else\n		#define LIT_CODE_LIGHTS_POINT\n		uniform vec3 light{i}_position;\n		uniform float light{i}_radius;\n		#if LIGHT{i}TYPE == SPOT\n			#define LIT_CODE_LIGHTS_SPOT\n			uniform vec3 light{i}_direction;\n			uniform float light{i}_innerConeAngle;\n			uniform float light{i}_outerConeAngle;\n		#endif\n	#endif\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#define LIT_CODE_FALLOFF_SQUARED\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			uniform vec3 light{i}_position;\n		#endif\n		uniform vec3 light{i}_halfWidth;\n		uniform vec3 light{i}_halfHeight;\n	#else\n		#if LIGHT{i}FALLOFF == LINEAR\n			#define LIT_CODE_FALLOFF_LINEAR\n		#endif\n		#if LIGHT{i}FALLOFF == INVERSESQUARED\n			#define LIT_CODE_FALLOFF_SQUARED\n		#endif\n	#endif\n	#if defined(LIGHT{i}CASTSHADOW)\n		uniform mat4 light{i}_shadowMatrix;\n		uniform float light{i}_shadowIntensity;\n		uniform vec4 light{i}_shadowParams;\n		#if LIGHT{i}SHADOWTYPE == PCSS_32F\n			uniform float light{i}_shadowSearchArea;\n			uniform vec4 light{i}_cameraParams;\n			#if LIGHT{i}TYPE == DIRECTIONAL\n				uniform vec4 light{i}_softShadowParams;\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			uniform mat4 light{i}_shadowMatrixPalette[4];\n			uniform vec4 light{i}_shadowCascadeDistances;\n			uniform int light{i}_shadowCascadeCount;\n			uniform float light{i}_shadowCascadeBlend;\n		#endif\n		#if LIGHT{i}TYPE == OMNI\n			#if defined(LIGHT{i}SHADOW_PCF)\n				uniform samplerCubeShadow light{i}_shadowMap;\n			#else\n				uniform samplerCube light{i}_shadowMap;\n			#endif\n		#else\n			#if defined(LIGHT{i}SHADOW_PCF)\n				uniform sampler2DShadow light{i}_shadowMap;\n			#else\n				uniform sampler2D light{i}_shadowMap;\n			#endif\n		#endif\n	#endif\n	#if defined(LIGHT{i}COOKIE)\n		#define LIT_CODE_COOKIE\n		#if LIGHT{i}TYPE == OMNI\n			uniform samplerCube light{i}_cookie;\n			uniform float light{i}_cookieIntensity;\n			#if !defined(LIGHT{i}CASTSHADOW)\n				uniform mat4 light{i}_shadowMatrix;\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == SPOT\n			uniform sampler2D light{i}_cookie;\n			uniform float light{i}_cookieIntensity;\n			#if !defined(LIGHT{i}CASTSHADOW)\n				uniform mat4 light{i}_shadowMatrix;\n			#endif\n			#if defined(LIGHT{i}COOKIE_TRANSFORM)\n				uniform vec4 light{i}_cookieMatrix;\n				uniform vec2 light{i}_cookieOffset;\n			#endif\n		#endif\n	#endif\n#endif\n";

var lightDiffuseLambertPS = "\nfloat getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm) {\n	return max(dot(worldNormal, -lightDirNorm), 0.0);\n}\n";

var lightDirPointPS = "\nvoid evalOmniLight(vec3 lightPosW, out vec3 lightDirW, out vec3 lightDirNormW) {\n	lightDirW = vPositionW - lightPosW;\n	lightDirNormW = normalize(lightDirW);\n}\n";

var lightEvaluationPS = "\n#if defined(LIGHT{i})\n	evaluateLight{i}();\n#endif\n";

var lightFunctionLightPS = "\n#if defined(LIGHT{i})\nvoid evaluateLight{i}() {\n	vec3 lightColor = light{i}_color;\n	#if LIGHT{i}TYPE == DIRECTIONAL && !defined(LIT_SHADOW_CATCHER)\n		if (all(equal(lightColor, vec3(0.0)))) {\n			return;\n		}\n	#endif\n	#if LIGHT{i}TYPE == DIRECTIONAL\n		dLightDirNormW = light{i}_direction;\n		dAtten = 1.0;\n	#else\n		\n		vec3 lightDirW;\n		evalOmniLight(light{i}_position, lightDirW, dLightDirNormW);\n		#if defined(LIGHT{i}COOKIE)\n			#if LIGHT{i}TYPE == SPOT\n				#ifdef LIGHT{i}COOKIE_FALLOFF\n					#ifdef LIGHT{i}COOKIE_TRANSFORM\n						vec3 cookieAttenuation = getCookie2DXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n					#else\n						vec3 cookieAttenuation = getCookie2D(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n					#endif\n				#else\n					#ifdef LIGHT{i}COOKIE_TRANSFORM\n						vec3 cookieAttenuation = getCookie2DClipXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n					#else\n						vec3 cookieAttenuation = getCookie2DClip(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n					#endif\n				#endif\n			#endif\n			#if LIGHT{i}TYPE == OMNI\n				vec3 cookieAttenuation = getCookieCube(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n			#endif\n			lightColor *= cookieAttenuation;\n		#endif\n		#if LIGHT{i}SHAPE == PUNCTUAL\n			#if LIGHT{i}FALLOFF == LINEAR\n				dAtten = getFalloffLinear(light{i}_radius, lightDirW);\n			#else\n				dAtten = getFalloffInvSquared(light{i}_radius, lightDirW);\n			#endif\n		#else\n			dAtten = getFalloffWindow(light{i}_radius, lightDirW);\n		#endif\n		#if LIGHT{i}TYPE == SPOT\n			#if !defined(LIGHT{i}COOKIE) || defined(LIGHT{i}COOKIE_FALLOFF)\n				dAtten *= getSpotEffect(light{i}_direction, light{i}_innerConeAngle, light{i}_outerConeAngle, dLightDirNormW);\n			#endif\n		#endif\n	#endif\n	if (dAtten < 0.00001) {\n		return;\n	}\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#if LIGHT{i}SHAPE == RECT\n			calcRectLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n		#elif LIGHT{i}SHAPE == DISK\n			calcDiskLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n		#elif LIGHT{i}SHAPE == SPHERE\n			calcSphereLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n		#endif\n	#endif\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			float attenDiffuse = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirNormW);\n		#else\n			#if LIGHT{i}SHAPE == RECT\n				float attenDiffuse = getRectLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n			#elif LIGHT{i}SHAPE == DISK\n				float attenDiffuse = getDiskLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n			#elif LIGHT{i}SHAPE == SPHERE\n				float attenDiffuse = getSphereLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n			#endif\n		#endif\n	#else\n		dAtten *= getLightDiffuse(litArgs_worldNormal, vec3(0.0), dLightDirNormW);\n	#endif\n	#ifdef LIGHT{i}CASTSHADOW\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			float shadow = getShadow{i}(vec3(0.0));\n		#else\n			float shadow = getShadow{i}(lightDirW);\n		#endif\n		shadow = mix(1.0, shadow, light{i}_shadowIntensity);\n		dAtten *= shadow;\n		#if defined(LIT_SHADOW_CATCHER) && LIGHT{i}TYPE == DIRECTIONAL\n			dShadowCatcher *= shadow;\n		#endif			\n	#endif\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#ifdef LIT_SPECULAR\n			dDiffuseLight += ((attenDiffuse * dAtten) * lightColor) * (1.0 - dLTCSpecFres);\n		#else\n			dDiffuseLight += (attenDiffuse * dAtten) * lightColor;\n		#endif						\n	#else\n		#if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)\n			dDiffuseLight += (dAtten * lightColor) * (1.0 - litArgs_specularity);\n		#else\n			dDiffuseLight += dAtten * lightColor;\n		#endif\n	#endif\n	#ifdef LIGHT{i}AFFECT_SPECULARITY\n		#if LIGHT{i}SHAPE != PUNCTUAL\n			#ifdef LIT_CLEARCOAT\n				#if LIGHT{i}SHAPE == RECT\n					ccSpecularLight += ccLTCSpecFres * getRectLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == DISK\n					ccSpecularLight += ccLTCSpecFres * getDiskLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == SPHERE\n					ccSpecularLight += ccLTCSpecFres * getSphereLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n				#endif\n			#endif\n			#ifdef LIT_SPECULAR\n				#if LIGHT{i}SHAPE == RECT\n					dSpecularLight += dLTCSpecFres * getRectLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == DISK\n					dSpecularLight += dLTCSpecFres * getDiskLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == SPHERE\n					dSpecularLight += dLTCSpecFres * getSphereLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n				#endif\n			#endif\n		#else\n			#if LIGHT{i}TYPE == DIRECTIONAL && LIT_FRESNEL_MODEL != NONE\n				#define LIGHT{i}FRESNEL\n			#endif\n			#ifdef LIT_SPECULAR\n				vec3 halfDirW = normalize(-dLightDirNormW + dViewDirW);\n			#endif\n			#ifdef LIT_CLEARCOAT\n				vec3 lightspecularCC = getLightSpecular(halfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * lightColor;\n				#ifdef LIGHT{i}FRESNEL\n					lightspecularCC *= getFresnelCC(dot(dViewDirW, halfDirW));\n				#endif\n				ccSpecularLight += lightspecularCC;\n			#endif\n			#ifdef LIT_SHEEN\n				sSpecularLight += getLightSpecularSheen(halfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * lightColor;\n			#endif\n			#ifdef LIT_SPECULAR\n				vec3 lightSpecular = getLightSpecular(halfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * lightColor;\n				#ifdef LIGHT{i}FRESNEL\n					#if defined(LIT_IRIDESCENCE)\n						lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity, iridescenceFresnel, litArgs_iridescence_intensity);\n					#else\n						lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity);\n					#endif\n				#else\n					lightSpecular *= litArgs_specularity;\n				#endif\n				\n				dSpecularLight += lightSpecular;\n			#endif\n		#endif\n	#endif\n}\n#endif\n";

var lightFunctionShadowPS = "\n#ifdef LIGHT{i}CASTSHADOW\n	vec3 getShadowSampleCoord{i}(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n		vec3 surfacePosition = worldPosition;\n		#ifdef LIGHT{i}_SHADOW_SAMPLE_POINT\n			#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n				float distScale = length(lightDir);\n				surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n				lightDir = surfacePosition - lightPos;\n				return lightDir;\n			#endif\n		#else\n			#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n					surfacePosition = surfacePosition + normal * shadowParams.y;\n				#endif\n			#else\n				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n					#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n						float distScale = 1.0;\n					#else\n						float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n					#endif\n					surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n				#endif\n			#endif\n			vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n			#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n				positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n			#else\n				#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n					positionInShadowSpace.xyz /= positionInShadowSpace.w;\n				#else\n					positionInShadowSpace.xy /= positionInShadowSpace.w;\n					positionInShadowSpace.z = length(lightDir) * shadowParams.w;\n				#endif\n			#endif\n			surfacePosition = positionInShadowSpace.xyz;\n		#endif\n		return surfacePosition;\n	}\n	float getShadow{i}(vec3 lightDirW) {\n		#ifdef LIGHT{i}_SHADOW_CASCADES\n			int cascadeIndex = getShadowCascadeIndex(light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount);\n			#ifdef LIGHT{i}_SHADOW_CASCADE_BLEND\n				cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount, light{i}_shadowCascadeBlend);\n			#endif\n			mat4 shadowMatrix = light{i}_shadowMatrixPalette[cascadeIndex];\n		#else\n			mat4 shadowMatrix = light{i}_shadowMatrix;\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, vec3(0.0), lightDirW, dLightDirNormW, dVertexNormalW);\n		#else\n			vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, light{i}_position, lightDirW, dLightDirNormW, dVertexNormalW);\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			shadowCoord = fadeShadow(shadowCoord, light{i}_shadowCascadeDistances);\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			#if LIGHT{i}SHADOWTYPE == VSM_16F\n				return getShadowVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == VSM_32F\n				return getShadowVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCSS_32F\n				#if LIGHT{i}SHAPE != PUNCTUAL\n					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n					return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n				#else\n					return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, light{i}_softShadowParams, lightDirW);\n				#endif\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n				return getShadowPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n				return getShadowPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n				return getShadowPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == SPOT\n			#if LIGHT{i}SHADOWTYPE == VSM_16F\n				return getShadowSpotVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == VSM_32F\n				return getShadowSpotVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCSS_32F\n				#if LIGHT{i}SHAPE != PUNCTUAL\n					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n				#else\n					vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);\n				#endif\n				return getShadowSpotPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n				return getShadowSpotPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n				return getShadowSpotPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n				return getShadowSpotPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == OMNI\n			#if LIGHT{i}SHADOWTYPE == PCSS_32F\n				#if LIGHT{i}SHAPE != PUNCTUAL\n					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n				#else\n					vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);\n				#endif\n				return getShadowOmniPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n				return getShadowOmniPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n				return getShadowOmniPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);\n			#endif\n		#endif\n	}\n#endif\n";

var lightingPS = '\n#ifdef LIT_CLUSTERED_LIGHTS\n	#define LIT_CODE_FALLOFF_LINEAR\n	#define LIT_CODE_FALLOFF_SQUARED\n	#define LIT_CODE_LIGHTS_POINT\n	#define LIT_CODE_LIGHTS_SPOT\n#endif\n#ifdef AREA_LIGHTS\n	uniform highp sampler2D areaLightsLutTex1;\n	uniform highp sampler2D areaLightsLutTex2;\n#endif\n#ifdef LIT_LIGHTING\n	#include "lightDiffuseLambertPS"\n	#if defined(AREA_LIGHTS) || defined(LIT_CLUSTERED_AREA_LIGHTS)\n		#include "ltcPS"\n	#endif\n#endif\n#ifdef SHADOW_DIRECTIONAL\n	#include "shadowCascadesPS"\n#endif\n#if defined(SHADOW_KIND_PCF1)\n	#include "shadowPCF1PS"\n#endif\n#if defined(SHADOW_KIND_PCF3)\n	#include "shadowPCF3PS"\n#endif\n#if defined(SHADOW_KIND_PCF5)\n	#include "shadowPCF5PS"\n#endif\n#if defined(SHADOW_KIND_PCSS)\n	#include "linearizeDepthPS"\n	#include "shadowPCSSPS"\n	#include "shadowSoftPS"\n#endif\n#if defined(SHADOW_KIND_VSM)\n	#include "shadowEVSMPS"\n#endif\n#ifdef LIT_CODE_FALLOFF_LINEAR\n	#include "falloffLinearPS"\n#endif\n#ifdef LIT_CODE_FALLOFF_SQUARED\n	#include "falloffInvSquaredPS"\n#endif\n#ifdef LIT_CODE_LIGHTS_POINT\n	#include "lightDirPointPS"\n#endif\n#ifdef LIT_CODE_LIGHTS_SPOT\n	#include "spotPS"\n#endif\n#ifdef LIT_CODE_COOKIE\n	#include "cookiePS"\n#endif\n#ifdef LIT_CLUSTERED_LIGHTS\n	#include "clusteredLightPS"\n#endif\n#include "lightFunctionShadowPS, LIGHT_COUNT"\n#include "lightFunctionLightPS, LIGHT_COUNT"\n';

var lightmapAddPS = "\nvoid addLightMap(\n	vec3 lightmap, \n	vec3 dir, \n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir, \n	float gloss, \n	vec3 specularity, \n	vec3 vertexNormal, \n	mat3 tbn\n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel, \n	float iridescenceIntensity\n#endif\n) {\n	#if defined(LIT_SPECULAR) && defined(LIT_DIR_LIGHTMAP)\n		if (dot(dir, dir) < 0.0001) {\n				dDiffuseLight += lightmap;\n		} else {\n			float vlight = saturate(dot(dir, -vertexNormal));\n			float flight = saturate(dot(dir, -worldNormal));\n			float nlight = (flight / max(vlight, 0.01)) * 0.5;\n			dDiffuseLight += lightmap * nlight * 2.0;\n			vec3 halfDir = normalize(-dir + viewDir);\n			vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);\n			#ifdef LIT_SPECULAR_FRESNEL\n				specularLight *= \n					getFresnel(dot(viewDir, halfDir), \n					gloss, \n					specularity\n				#if defined(LIT_IRIDESCENCE)\n					, iridescenceFresnel,\n					iridescenceIntensity\n				#endif\n					);\n			#endif\n			dSpecularLight += specularLight;\n		}\n	#else\n		dDiffuseLight += lightmap;\n	#endif\n}\n";

var lightmapDirPS = "\nuniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid getLightMap() {\n	dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n	vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;\n	float dirDot = dot(dir, dir);\n	dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n}\n";

var lightmapSinglePS = "\nvoid getLightMap() {\n	dLightmap = vec3(1.0);\n	#ifdef MAPTEXTURE\n	dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	dLightmap *= saturate(vVertexColor.$VC);\n	#endif\n}\n";

var lightSpecularAnisoGGXPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {\n	float PI = 3.141592653589793;\n	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n	float anisotropy = material_anisotropy * roughness;\n \n	float at = max((roughness + anisotropy), roughness / 4.0);\n	float ab = max((roughness - anisotropy), roughness / 4.0);\n	float NoH = dot(worldNormal, h);\n	float ToH = dot(tbn[0], h);\n	float BoH = dot(tbn[1], h);\n	float a2 = at * ab;\n	vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n	float v2 = dot(v, v);\n	float w2 = a2 / v2;\n	float D = a2 * w2 * w2 * (1.0 / PI);\n	float ToV = dot(tbn[0], viewDir);\n	float BoV = dot(tbn[1], viewDir);\n	float ToL = dot(tbn[0], -lightDirNorm);\n	float BoL = dot(tbn[1], -lightDirNorm);\n	float NoV = dot(worldNormal, viewDir);\n	float NoL = dot(worldNormal, -lightDirNorm);\n	float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n	float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n	float G = 0.5 / (lambdaV + lambdaL);\n	return D * G;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);\n}\n";

var lightSpecularBlinnPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {\n	float nh = max( dot( h, worldNormal ), 0.0 );\n	float specPow = exp2(gloss * 11.0);\n	specPow = max(specPow, 0.0001);\n	return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n	return calcLightSpecular(gloss, worldNormal, h);\n}\n";

var lightSheenPS = "\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n	const float PI = 3.141592653589793;\n	float invR = 1.0 / (roughness * roughness);\n	float cos2h = max(dot(normal, h), 0.0);\n	cos2h *= cos2h;\n	float sin2h = max(1.0 - cos2h, 0.0078125);\n	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\nfloat sheenV(vec3 normal, vec3 viewDir, vec3 light) {\n	float NoV = max(dot(normal, viewDir), 0.000001);\n	float NoL = max(dot(normal, light), 0.000001);\n	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\nfloat getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {\n	float D = sheenD(worldNormal, h, sheenGloss);\n	float V = sheenV(worldNormal, viewDir, -lightDirNorm);\n	return D * V;\n}\n";

var linearizeDepthPS = "\n#ifndef LINEARIZE_DEPTH\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z, vec4 cameraParams) {\n	if (cameraParams.w == 0.0)\n		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));\n	else\n		return cameraParams.z + z * (cameraParams.y - cameraParams.z);\n}\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nfloat linearizeDepth(float z) {\n	return linearizeDepth(z, camera_params);\n}\n#endif\n";

var litForwardBackendPS = '\nvoid evaluateBackend() {\n	#ifdef LIT_SSAO\n		litArgs_ao *= texture2DLod(ssaoTexture, gl_FragCoord.xy * ssaoTextureSizeInv, 0.0).r;\n	#endif\n	#ifdef LIT_NEEDS_NORMAL\n		#ifdef LIT_SPECULAR\n			getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);\n		#endif\n		#ifdef LIT_CLEARCOAT\n			ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));\n		#endif\n	#endif\n	#ifdef LIT_SPECULAR_OR_REFLECTION\n		#ifdef LIT_METALNESS\n			float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;\n			litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);\n			litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);\n		#endif\n		#ifdef LIT_IRIDESCENCE\n			vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);\n		#endif\n	#endif\n	#ifdef LIT_ADD_AMBIENT\n		addAmbient(litArgs_worldNormal);\n		#ifdef LIT_SPECULAR\n			dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);\n		#endif\n		#ifdef LIT_SEPARATE_AMBIENT\n			vec3 dAmbientLight = dDiffuseLight;\n			dDiffuseLight = vec3(0);\n		#endif\n	#endif\n	#ifndef LIT_OLD_AMBIENT\n		dDiffuseLight *= material_ambient;\n	#endif\n	#ifdef LIT_AO\n		#ifndef LIT_OCCLUDE_DIRECT\n			occludeDiffuse(litArgs_ao);\n		#endif\n	#endif\n	#ifdef LIT_LIGHTMAP\n		addLightMap(\n			litArgs_lightmap, \n			litArgs_lightmapDir, \n			litArgs_worldNormal, \n			dViewDirW, \n			dReflDirW, \n			litArgs_gloss, \n			litArgs_specularity, \n			dVertexNormalW,\n			dTBN\n		#if defined(LIT_IRIDESCENCE)\n			, iridescenceFresnel,\n			litArgs_iridescence_intensity\n		#endif\n		);\n	#endif\n	#ifdef LIT_LIGHTING || LIT_REFLECTIONS\n		#ifdef LIT_REFLECTIONS\n			#ifdef LIT_CLEARCOAT\n				addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);\n			\n				#ifdef LIT_SPECULAR_FRESNEL\n					ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));\n					ccReflection.rgb *= ccFresnel;\n				#else\n					ccFresnel = 0.0;\n				#endif\n			#endif\n			#ifdef LIT_SPECULARITY_FACTOR\n				ccReflection.rgb *= litArgs_specularityFactor;\n			#endif\n			#ifdef LIT_SHEEN\n				addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);\n			#endif\n			addReflection(dReflDirW, litArgs_gloss);\n			#ifdef LIT_FRESNEL_MODEL\n				dReflection.rgb *= getFresnel(\n					dot(dViewDirW, litArgs_worldNormal), \n					litArgs_gloss, \n					litArgs_specularity\n				#if defined(LIT_IRIDESCENCE)\n					, iridescenceFresnel,\n					litArgs_iridescence_intensity\n				#endif\n					);\n			#else\n				dReflection.rgb *= litArgs_specularity;\n			#endif\n			#ifdef LIT_SPECULARITY_FACTOR\n				dReflection.rgb *= litArgs_specularityFactor;\n			#endif\n		#endif\n		#ifdef AREA_LIGHTS\n			dSpecularLight *= litArgs_specularity;\n			#ifdef LIT_SPECULAR\n				calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);\n			#endif\n		#endif\n		\n		#include "lightEvaluationPS, LIGHT_COUNT"\n		#ifdef LIT_CLUSTERED_LIGHTS\n			addClusteredLights(litArgs_worldNormal, dViewDirW, dReflDirW,\n				#if defined(LIT_CLEARCOAT)\n						ccReflDirW,\n				#endif\n						litArgs_gloss, litArgs_specularity, dVertexNormalW, dTBN, \n				#if defined(LIT_IRIDESCENCE)\n						iridescenceFresnel,\n				#endif\n						litArgs_clearcoat_worldNormal, litArgs_clearcoat_gloss, litArgs_sheen_gloss, litArgs_iridescence_intensity\n			);\n		#endif\n		#ifdef AREA_LIGHTS\n			#ifdef LIT_CLEARCOAT\n				litArgs_clearcoat_specularity = 1.0;\n			#endif\n			#ifdef LIT_SPECULAR\n				litArgs_specularity = vec3(1);\n			#endif\n		#endif\n		#ifdef LIT_REFRACTION\n			addRefraction(\n				litArgs_worldNormal, \n				dViewDirW, \n				litArgs_thickness, \n				litArgs_gloss, \n				litArgs_specularity, \n				litArgs_albedo, \n				litArgs_transmission,\n				litArgs_ior,\n				litArgs_dispersion\n				#if defined(LIT_IRIDESCENCE)\n					, iridescenceFresnel, \n					litArgs_iridescence_intensity\n				#endif\n			);\n		#endif\n	#endif\n	#ifdef LIT_AO\n		#ifdef LIT_OCCLUDE_DIRECT\n			occludeDiffuse(litArgs_ao);\n		#endif\n		#if LIT_OCCLUDE_SPECULAR != NONE\n			occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);\n		#endif\n	#endif\n	#ifdef LIT_SPECULARITY_FACTOR\n		dSpecularLight *= litArgs_specularityFactor;\n	#endif\n	#if !defined(LIT_OPACITY_FADES_SPECULAR)\n		#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED\n			float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));\n			#ifdef LIT_CLEARCOAT\n				specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n			#endif\n			litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);\n		#endif\n		litArgs_opacity *= material_alphaFade;\n	#endif\n	#include "endPS"\n	#include "outputAlphaPS"\n	#ifdef LIT_MSDF\n		gl_FragColor = applyMsdf(gl_FragColor);\n	#endif\n	#include "outputPS"\n	#include "debugOutputPS"\n	#ifdef LIT_SHADOW_CATCHER\n		gl_FragColor.rgb = vec3(dShadowCatcher);\n	#endif\n}\n';

var litForwardDeclarationPS = '\nvec3 sReflection;\nvec3 dVertexNormalW;\nvec3 dTangentW;\nvec3 dBinormalW;\nvec3 dViewDirW;\nvec3 dReflDirW;\nvec3 ccReflDirW;\nvec3 dLightDirNormW;\nfloat dAtten;\nmat3 dTBN;\nvec4 dReflection;\nvec3 dDiffuseLight;\nvec3 dSpecularLight;\nfloat ccFresnel;\nvec3 ccReflection;\nvec3 ccSpecularLight;\nfloat ccSpecularityNoFres;\nvec3 sSpecularLight;\n#ifdef LIT_DISPERSION\n	uniform float material_dispersion;\n#endif\n#ifndef LIT_OPACITY_FADES_SPECULAR\n	uniform float material_alphaFade;\n#endif\n#ifdef LIT_SSAO\n	uniform sampler2D ssaoTexture;\n	uniform vec2 ssaoTextureSizeInv;\n#endif\n#ifdef LIT_SHADOW_CATCHER\n	float dShadowCatcher = 1.0;\n#endif\n#include "lightDeclarationPS, LIGHT_COUNT"\n#ifdef LIT_SPECULAR\n	#if LIT_FRESNEL_MODEL == NONE && !defined(LIT_REFLECTIONS) && !defined(LIT_DIFFUSE_MAP) \n		#define LIT_OLD_AMBIENT\n	#endif\n#endif\n';

var litForwardMainPS = '\nvoid main(void) {\n	dReflection = vec4(0);\n	#ifdef LIT_CLEARCOAT\n		ccSpecularLight = vec3(0);\n		ccReflection = vec3(0);\n	#endif\n	#if LIT_NONE_SLICE_MODE == SLICED\n		#include "startNineSlicedPS"\n	#elif LIT_NONE_SLICE_MODE == TILED\n		#include "startNineSlicedTiledPS"\n	#endif\n	#ifdef LIT_NEEDS_NORMAL\n		dVertexNormalW = normalize(vNormalW);\n		#ifdef LIT_TANGENTS\n			#if defined(LIT_HEIGHTS) || defined(LIT_USE_NORMALS)\n				dTangentW = vTangentW;\n				dBinormalW = vBinormalW;\n			#endif\n		#endif\n		getViewDir();\n		#ifdef LIT_TBN\n			getTBN(dTangentW, dBinormalW, dVertexNormalW);\n			#ifdef LIT_TWO_SIDED_LIGHTING\n				handleTwoSidedLighting();\n			#endif\n		#endif\n	#endif\n	evaluateFrontend();\n	#include "debugProcessFrontendPS"\n	evaluateBackend();\n}\n';

var litForwardPostCodePS = '\n#ifdef LIT_NEEDS_NORMAL\n	#include "cubeMapRotatePS"\n	#include "cubeMapProjectPS"\n	#include "envProcPS"\n#endif\n#if defined(LIT_LIGHTING) && defined(LIT_SPECULAR)\n	#define LIT_SPECULAR_OR_REFLECTION\n#elif defined(LIT_REFLECTIONS)\n	#define LIT_SPECULAR_OR_REFLECTION\n#endif\n#ifdef LIT_SPECULAR_OR_REFLECTION\n	#ifdef LIT_METALNESS\n		#include "metalnessModulatePS"\n	#endif\n	#if LIT_FRESNEL_MODEL == SCHLICK\n		#include "fresnelSchlickPS"\n	#endif\n	#ifdef LIT_IRIDESCENCE\n		#include "iridescenceDiffractionPS"\n	#endif\n#endif\n#ifdef LIT_AO\n	#include "aoDiffuseOccPS"\n	#include "aoSpecOccPS"\n#endif\n#if LIT_REFLECTION_SOURCE == ENVATLASHQ\n	#include "envAtlasPS"\n	#include "reflectionEnvHQPS"\n#elif LIT_REFLECTION_SOURCE == ENVATLAS\n	#include "envAtlasPS"\n	#include "reflectionEnvPS"\n#elif LIT_REFLECTION_SOURCE == CUBEMAP\n	#include "reflectionCubePS"\n#elif LIT_REFLECTION_SOURCE == SPHEREMAP\n	#include "reflectionSpherePS"\n#endif\n#ifdef LIT_REFLECTIONS\n	#ifdef LIT_CLEARCOAT\n		#include "reflectionCCPS"\n	#endif\n	#ifdef LIT_SHEEN\n		#include "reflectionSheenPS"\n	#endif\n#endif\n#ifdef LIT_REFRACTION\n	#if defined(LIT_DYNAMIC_REFRACTION)\n		#include "refractionDynamicPS"\n	#elif defined(LIT_REFLECTIONS)\n		#include "refractionCubePS"\n	#endif\n#endif\n#ifdef LIT_SHEEN\n	#include "lightSheenPS"\n#endif\n#ifdef LIT_GGX_SPECULAR\n	uniform float material_anisotropy;\n#endif\nuniform vec3 material_ambient;\n#ifdef LIT_SPECULAR\n	#ifdef LIT_LIGHTING\n		#ifdef LIT_GGX_SPECULAR\n			#include "lightSpecularAnisoGGXPS"\n		#else\n			#include "lightSpecularBlinnPS"\n		#endif\n	#endif\n#endif\n#include "combinePS"\n#ifdef LIT_LIGHTMAP\n	#include "lightmapAddPS"\n#endif\n#ifdef LIT_ADD_AMBIENT\n	#include "ambientPS"\n#endif\n#ifdef LIT_MSDF\n	#include "msdfPS"\n#endif\n#ifdef LIT_NEEDS_NORMAL\n	#include "viewDirPS"\n	#ifdef LIT_SPECULAR\n		#ifdef LIT_GGX_SPECULAR\n			#include "reflDirAnisoPS"\n		#else\n			#include "reflDirPS"\n		#endif\n	#endif\n#endif\n#include "lightingPS"\n';

var litForwardPreCodePS = '\n#include "basePS"\n#include "sphericalPS"\n#include "decodePS"\n#include "gammaPS"\n#include "tonemappingPS"\n#include "fogPS"\n#if LIT_NONE_SLICE_MODE == SLICED\n	#include "baseNineSlicedPS"\n#elif LIT_NONE_SLICE_MODE == TILED\n	#include "baseNineSlicedTiledPS"\n#endif\n#ifdef LIT_TBN\n	#include "TBNPS"\n	#ifdef LIT_TWO_SIDED_LIGHTING\n		#include "twoSidedLightingPS"\n	#endif\n#endif\n';

var litMainVS = '\n#ifdef VERTEX_COLOR\n	attribute vec4 vertex_color;\n#endif\n#ifdef NINESLICED\n	varying vec2 vMask;\n	varying vec2 vTiledUv;\n	uniform mediump vec4 innerOffset;\n	uniform mediump vec2 outerScale;\n	uniform mediump vec4 atlasRect;\n#endif\nvec3 dPositionW;\nmat4 dModelMatrix;\n#include "transformCoreVS"\n#ifdef UV0\n	attribute vec2 vertex_texCoord0;\n	#include "uv0VS"\n#endif\n#ifdef UV1\n	attribute vec2 vertex_texCoord1;\n	#include "uv1VS"\n#endif\n#ifdef LINEAR_DEPTH\n	#ifndef VIEWMATRIX\n	#define VIEWMATRIX\n		uniform mat4 matrix_view;\n	#endif\n#endif\n#include "transformVS"\n#ifdef NORMALS\n	#include "normalCoreVS"\n	#include "normalVS"\n#endif\n#ifdef TANGENTS\n	attribute vec4 vertex_tangent;\n	#include "tangentBinormalVS"\n#endif\n#include "uvTransformUniformsPS, UV_TRANSFORMS_COUNT"\n#ifdef MSDF\n	#include "msdfVS"\n#endif\nvoid main(void) {\n	gl_Position = getPosition();\n	vPositionW = getWorldPosition();\n	#ifdef NORMALS\n		vNormalW = getNormal();\n	#endif\n	#ifdef TANGENTS\n		vTangentW = getTangent();\n		vBinormalW = getBinormal();\n	#elif defined(GGX_SPECULAR)\n		vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n	#endif\n	#ifdef UV0\n		vec2 uv0 = getUv0();\n		#ifdef UV0_UNMODIFIED\n			vUv0 = uv0;\n		#endif\n	#endif\n	#ifdef UV1\n		vec2 uv1 = getUv1();\n		#ifdef UV1_UNMODIFIED\n			vUv1 = uv1;\n		#endif\n	#endif\n	#include "uvTransformPS, UV_TRANSFORMS_COUNT"\n	#ifdef VERTEX_COLOR\n		vVertexColor = vertex_color;\n	#endif\n	#ifdef LINEAR_DEPTH\n		vLinearDepth = -(matrix_view * vec4(vPositionW, 1.0)).z;\n	#endif\n	#ifdef MSDF\n		unpackMsdfParams();\n	#endif\n}\n';

var litOtherMainPS = '\n#ifdef PICK_PASS\n	#include "pickPS"\n#endif\n#ifdef PREPASS_PASS\n	#include "floatAsUintPS"\n#endif\nvoid main(void) {\n	evaluateFrontend();\n	#ifdef PICK_PASS\n		gl_FragColor = getPickOutput();\n	#endif\n	#ifdef DEPTH_PASS\n		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n	#endif\n	#ifdef PREPASS_PASS\n		#if defined(CAPS_TEXTURE_FLOAT_RENDERABLE)\n			gl_FragColor = vec4(vLinearDepth, 1.0, 1.0, 1.0);\n		#else\n			gl_FragColor = float2uint(vLinearDepth);\n		#endif\n	#endif\n}\n';

var litShaderArgsPS = "\nvec3 litArgs_albedo;\nfloat litArgs_opacity;\nvec3 litArgs_emission;\nvec3 litArgs_worldNormal;\nfloat litArgs_ao;\nvec3 litArgs_lightmap;\nvec3 litArgs_lightmapDir;\nfloat litArgs_metalness;\nvec3 litArgs_specularity;\nfloat litArgs_specularityFactor;\nfloat litArgs_gloss;\nfloat litArgs_sheen_gloss;\nvec3 litArgs_sheen_specularity;\nfloat litArgs_transmission;\nfloat litArgs_thickness;\nfloat litArgs_ior;\nfloat litArgs_dispersion;\nfloat litArgs_iridescence_intensity;\nfloat litArgs_iridescence_thickness;\nvec3 litArgs_clearcoat_worldNormal;\nfloat litArgs_clearcoat_specularity;\nfloat litArgs_clearcoat_gloss;\n";

var litShadowMainPS = '\n#if LIGHT_TYPE != DIRECTIONAL\n	uniform vec3 view_position;\n	uniform float light_radius;\n#endif\n#if SHADOW_TYPE == PCSS_32F\n	#include "linearizeDepthPS"\n#endif\nvoid main(void) {\n	evaluateFrontend();\n	#ifdef PERSPECTIVE_DEPTH\n		float depth = gl_FragCoord.z;\n		#if SHADOW_TYPE == PCSS_32F\n			#if LIGHT_TYPE != DIRECTIONAL\n				depth = linearizeDepth(depth, camera_params);\n			#endif\n		#endif\n	#else\n		float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n		#define MODIFIED_DEPTH\n	#endif\n	#if SHADOW_TYPE == VSM_16F || SHADOW_TYPE == VSM_32F\n		#if SHADOW_TYPE == VSM_32F\n			float exponent = 15.0;\n		#else\n			float exponent = 5.54;\n		#endif\n		depth = 2.0 * depth - 1.0;\n		depth =  exp(exponent * depth);\n		gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n	#else\n		#if SHADOW_TYPE == PCSS_32F\n			gl_FragColor.r = depth;\n		#else\n			#ifdef MODIFIED_DEPTH\n				gl_FragDepth = depth;\n			#endif\n			gl_FragColor = vec4(1.0);\n		#endif\n	#endif\n}\n';

var ltcPS = "\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n	vec3 coord0;\n	vec3 coord1;\n	vec3 coord2;\n	vec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n	vec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n	vec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n	\n	vec3 lightNormal = cross( v1, v2 );\n	float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 =  factor * cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords.coord0 - P );\n	coords[ 1 ] = mat * ( rectCoords.coord1 - P );\n	coords[ 2 ] = mat * ( rectCoords.coord2 - P );\n	coords[ 3 ] = mat * ( rectCoords.coord3 - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n	Coords coords;\n	coords.coord0 = lightPos + halfWidth - halfHeight;\n	coords.coord1 = lightPos - halfWidth - halfHeight;\n	coords.coord2 = lightPos - halfWidth + halfHeight;\n	coords.coord3 = lightPos + halfWidth + halfHeight;\n	return coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n	dSphereRadius = max(length(halfWidth), length(halfHeight));\n	vec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n	vec3 w = normalize(cross(f, halfHeight));\n	vec3 h = normalize(cross(f, w));\n	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)\n{\n	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n	return LTC_Uv( worldNormal, viewDir, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)\n{\n	vec4 t2 = texture2DLod(areaLightsLutTex2, uv, 0.0);\n	return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;\n}\nvoid calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)\n{\n	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);\n	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); \n#ifdef LIT_CLEARCOAT\n	ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);\n	ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n	calcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n	float pi = 3.14159;\n	Coefficient.xyz /= Coefficient.w;\n	Coefficient.yz /= 3.0;\n	float A = Coefficient.w;\n	float B = Coefficient.z;\n	float C = Coefficient.y;\n	float D = Coefficient.x;\n	vec3 Delta = vec3(\n		-Coefficient.z * Coefficient.z + Coefficient.y,\n		-Coefficient.y * Coefficient.z + Coefficient.x,\n		dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n	);\n	float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n	vec3 RootsA, RootsD;\n	vec2 xlc, xsc;\n	{\n		float A_a = 1.0;\n		float C_a = Delta.x;\n		float D_a = -2.0 * B * Delta.x + Delta.y;\n		float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n		float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n		float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n		float xl;\n		if ((x_1a + x_3a) > 2.0 * B)\n			xl = x_1a;\n		else\n			xl = x_3a;\n		xlc = vec2(xl - B, A);\n	}\n	{\n		float A_d = D;\n		float C_d = Delta.z;\n		float D_d = -D * Delta.y + 2.0 * C * Delta.z;\n		float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n		float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n		float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n		float xs;\n		if (x_1d + x_3d < 2.0 * C)\n			xs = x_1d;\n		else\n			xs = x_3d;\n		xsc = vec2(-D, xs + C);\n	}\n	float E =  xlc.y * xsc.y;\n	float F = -xlc.x * xsc.y - xlc.y * xsc.x;\n	float G =  xlc.x * xsc.x;\n	vec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n	vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n	if (Root.x < Root.y && Root.x < Root.z)\n		Root.xyz = Root.yxz;\n	else if (Root.z < Root.x && Root.z < Root.y)\n		Root.xyz = Root.xzy;\n	return Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n	vec3 T1, T2;\n	T1 = normalize(V - N * dot(V, N));\n	T2 = cross(N, T1);\n	mat3 R = transposeMat3( mat3( T1, T2, N ) );\n	vec3 L_[ 3 ];\n	L_[ 0 ] = R * ( points.coord0 - P );\n	L_[ 1 ] = R * ( points.coord1 - P );\n	L_[ 2 ] = R * ( points.coord2 - P );\n	vec3 Lo_i = vec3(0);\n	vec3 C  = 0.5 * (L_[0] + L_[2]);\n	vec3 V1 = 0.5 * (L_[1] - L_[2]);\n	vec3 V2 = 0.5 * (L_[1] - L_[0]);\n	C  = Minv * C;\n	V1 = Minv * V1;\n	V2 = Minv * V2;\n	float a, b;\n	float d11 = dot(V1, V1);\n	float d22 = dot(V2, V2);\n	float d12 = dot(V1, V2);\n	if (abs(d12) / sqrt(d11 * d22) > 0.0001)\n	{\n		float tr = d11 + d22;\n		float det = -d12 * d12 + d11 * d22;\n		det = sqrt(det);\n		float u = 0.5 * sqrt(tr - 2.0 * det);\n		float v = 0.5 * sqrt(tr + 2.0 * det);\n		float e_max = (u + v) * (u + v);\n		float e_min = (u - v) * (u - v);\n		vec3 V1_, V2_;\n		if (d11 > d22)\n		{\n			V1_ = d12 * V1 + (e_max - d11) * V2;\n			V2_ = d12 * V1 + (e_min - d11) * V2;\n		}\n		else\n		{\n			V1_ = d12*V2 + (e_max - d22)*V1;\n			V2_ = d12*V2 + (e_min - d22)*V1;\n		}\n		a = 1.0 / e_max;\n		b = 1.0 / e_min;\n		V1 = normalize(V1_);\n		V2 = normalize(V2_);\n	}\n	else\n	{\n		a = 1.0 / dot(V1, V1);\n		b = 1.0 / dot(V2, V2);\n		V1 *= sqrt(a);\n		V2 *= sqrt(b);\n	}\n	vec3 V3 = normalize(cross(V1, V2));\n	if (dot(C, V3) < 0.0)\n		V3 *= -1.0;\n	float L  = dot(V3, C);\n	float x0 = dot(V1, C) / L;\n	float y0 = dot(V2, C) / L;\n	float E1 = inversesqrt(a);\n	float E2 = inversesqrt(b);\n	a *= L * L;\n	b *= L * L;\n	float c0 = a * b;\n	float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n	float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n	float c3 = 1.0;\n	vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n	float e1 = roots.x;\n	float e2 = roots.y;\n	float e3 = roots.z;\n	vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n	mat3 rotate = mat3(V1, V2, V3);\n	avgDir = rotate * avgDir;\n	avgDir = normalize(avgDir);\n	float L1 = sqrt(-e2 / e3);\n	float L2 = sqrt(-e2 / e1);\n	float formFactor = max(0.0, L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));\n	\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n	uv = uv*LUT_SCALE + LUT_BIAS;\n	float scale = texture2DLod(areaLightsLutTex2, uv, 0.0).w;\n	return formFactor*scale;\n}\nfloat getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n	float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);\n	return getLightDiffuse(worldNormal, viewDir, lightDirNorm) * falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n	vec4 t1 = texture2DLod(areaLightsLutTex1, uv, 0.0);\n	return mat3(\n		vec3( t1.x, 0, t1.y ),\n		vec3(	0, 1,	0 ),\n		vec3( t1.z, 0, t1.w )\n	);\n}\nfloat calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n	mat3 mInv = getLTCLightInvMat(uv);\n	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {\n	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n	mat3 mInv = getLTCLightInvMat(uv);\n	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {\n	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {\n	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n";

var metalnessPS = "\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\nvoid getMetalness() {\n	float metalness = 1.0;\n	#ifdef MAPFLOAT\n	metalness *= material_metalness;\n	#endif\n	#ifdef MAPTEXTURE\n	metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	metalness *= saturate(vVertexColor.$VC);\n	#endif\n	dMetalness = metalness;\n}\n";

var msdfPS = "\nuniform sampler2D texture_msdfMap;\nfloat median(float r, float g, float b) {\n	return max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n	return (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\n#ifndef LIT_MSDF_TEXT_ATTRIBUTE\n	uniform vec4 outline_color;\n	uniform float outline_thickness;\n	uniform vec4 shadow_color;\n	uniform vec2 shadow_offset;\n#else\n	varying vec4 outline_color;\n	varying float outline_thickness;\n	varying vec4 shadow_color;\n	varying vec2 shadow_offset;\n#endif\nvec4 applyMsdf(vec4 color) {\n	color.rgb = gammaCorrectInput(color.rgb);\n	vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n	vec2 uvShdw = vUv0 - shadow_offset;\n	vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n	float sigDist = median(tsample.r, tsample.g, tsample.b);\n	float sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n	float smoothingMax = 0.2;\n	vec2 w = fwidth(vUv0);\n	float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n	float mapMin = 0.05;\n	float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n	float sigDistInner = map(mapMin, mapMax, sigDist);\n	float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n	float center = 0.5;\n	float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n	float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n	float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n	vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n	tcolor = mix(tcolor, color, inside);\n	vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n	tcolor = mix(scolor, tcolor, outline);\n	tcolor.rgb = gammaCorrectOutput(tcolor.rgb);\n	\n	return tcolor;\n}\n";

var metalnessModulatePS = "\nvec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {\n	vec3 dielectricF0 = f0 * specularity;\n	return mix(dielectricF0, albedo, metalness);\n}\nvec3 getAlbedoModulate(in vec3 albedo, in float metalness) {\n	return albedo * (1.0 - metalness);\n}\n";

var morphEvaluationPS$1 = "\n	color.xyz += morphFactor[{i}] * texture2DLod(morphBlendTex{i}, uv0, 0.0).xyz;\n";

var morphDeclarationPS$1 = "\n	uniform highp sampler2D morphBlendTex{i};\n";

var morphPS$1 = '\n	varying vec2 uv0;\n	#include "morphDeclarationPS, MORPH_TEXTURE_COUNT"\n	#if MORPH_TEXTURE_COUNT > 0\n		uniform highp float morphFactor[{MORPH_TEXTURE_COUNT}];\n	#endif\n	#ifdef MORPH_INT\n		uniform vec3 aabbSize;\n		uniform vec3 aabbMin;\n	#endif\n	void main (void) {\n		highp vec4 color = vec4(0, 0, 0, 1);\n		#include "morphEvaluationPS, MORPH_TEXTURE_COUNT"\n		#ifdef MORPH_INT\n			color.xyz = (color.xyz - aabbMin) / aabbSize * 65535.0;\n			gl_FragColor = uvec4(color);\n		#else\n			gl_FragColor = color;\n		#endif\n	}\n';

var morphVS$1 = "\n	attribute vec2 vertex_position;\n	varying vec2 uv0;\n	void main(void) {\n		gl_Position = vec4(vertex_position, 0.5, 1.0);\n		uv0 = vertex_position.xy * 0.5 + 0.5;\n	}\n";

var msdfVS = "\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\nvoid unpackMsdfParams() {\n	vec3 little = mod(vertex_outlineParameters, 256.);\n	vec3 big = (vertex_outlineParameters - little) / 256.;\n	outline_color.rb = little.xy / 255.;\n	outline_color.ga = big.xy / 255.;\n	outline_thickness = little.z / 255. * 0.2;\n	little = mod(vertex_shadowParameters, 256.);\n	big = (vertex_shadowParameters - little) / 256.;\n	shadow_color.rb = little.xy / 255.;\n	shadow_color.ga = big.xy / 255.;\n	shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;\n}\n";

var normalVS = "\nmat3 dNormalMatrix;\nvec3 getNormal() {\n	dNormalMatrix = getNormalMatrix(dModelMatrix);\n	vec3 localNormal = getLocalNormal(vertex_normal);\n	return normalize(dNormalMatrix * localNormal);\n}\n";

var normalCoreVS = "\nattribute vec3 vertex_normal;\n#ifdef MORPHING_NORMAL\n	#ifdef MORPHING_INT\n		uniform highp usampler2D morphNormalTex;\n	#else\n		uniform highp sampler2D morphNormalTex;\n	#endif\n#endif\nvec3 getLocalNormal(vec3 vertexNormal) {\n	vec3 localNormal = vertex_normal;\n	#ifdef MORPHING_NORMAL\n		ivec2 morphUV = getTextureMorphCoords();\n		#ifdef MORPHING_INT\n			vec3 morphNormal = vec3(texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz) / 65535.0 * 2.0 - 1.0;\n		#else\n			vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;\n		#endif\n		localNormal += morphNormal;\n	#endif\n	return localNormal;\n}\n#ifdef SKIN\n	mat3 getNormalMatrix(mat4 modelMatrix) {\n		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	}\n#elif defined(INSTANCING)\n	mat3 getNormalMatrix(mat4 modelMatrix) {\n		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	}\n#else\n	mat3 getNormalMatrix(mat4 modelMatrix) {\n		return matrix_normal;\n	}\n#endif\n";

var normalDetailMapPS = "\n#ifdef MAPTEXTURE\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n	n1 += vec3(0, 0, 1);\n	n2 *= vec3(-1, -1, 1);\n	return n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n#ifdef MAPTEXTURE\n	vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n	normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n	return blendNormals(normalMap, normalDetailMap);\n#else\n	return normalMap;\n#endif\n}\n";

var normalMapPS = "\n#ifdef MAPTEXTURE\nuniform float material_bumpiness;\n#endif\nvoid getNormal() {\n#ifdef MAPTEXTURE\n	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n	dNormalW = normalize(dTBN * addNormalDetail(normalMap));\n#else\n	dNormalW = dVertexNormalW;\n#endif\n}\n";

var normalXYPS = "\nvec3 unpackNormal(vec4 nmap) {\n	vec3 normal;\n	normal.xy = nmap.wy * 2.0 - 1.0;\n	normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n	return normal;\n}\n";

var normalXYZPS = "\nvec3 unpackNormal(vec4 nmap) {\n	return nmap.xyz * 2.0 - 1.0;\n}\n";

var opacityPS = "\nuniform float material_opacity;\nvoid getOpacity() {\n	dAlpha = material_opacity;\n	#ifdef MAPTEXTURE\n	dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n	#endif\n}\n";

var opacityDitherPS = "\nuniform vec4 blueNoiseJitter;\n#ifdef DITHER_BLUENOISE\n	uniform sampler2D blueNoiseTex32;\n#endif\nvoid opacityDither(float alpha, float id) {\n	#ifdef DITHER_BAYER8\n		float noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;\n	#else\n		#ifdef DITHER_BLUENOISE\n			vec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);\n			float noise = texture2DLod(blueNoiseTex32, uv, 0.0).y;\n		#endif\n		#ifdef DITHER_IGNNOISE\n			vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n			float noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));\n		#endif\n	#endif\n	noise = pow(noise, 2.2);\n	if (alpha < noise)\n		discard;\n}\n";

var outputPS = "\n";

var outputAlphaPS = "\n#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == ADDITIVEALPHA || defined(LIT_ALPHA_TO_COVERAGE)\n	gl_FragColor.a = litArgs_opacity;\n#elif LIT_BLEND_TYPE == PREMULTIPLIED\n	gl_FragColor.rgb *= litArgs_opacity;\n	gl_FragColor.a = litArgs_opacity;\n#else\n	gl_FragColor.a = 1.0;\n#endif\n";

var outputTex2DPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n	gl_FragColor = texture2D(source, vUv0);\n}\n";

var sheenPS = "\nuniform vec3 material_sheen;\nvoid getSheen() {\n	vec3 sheenColor = material_sheen;\n	#ifdef MAPTEXTURE\n	sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	sheenColor *= saturate(vVertexColor.$VC);\n	#endif\n	sSpecularity = sheenColor;\n}\n";

var sheenGlossPS = "\nuniform float material_sheenGloss;\nvoid getSheenGlossiness() {\n	float sheenGlossiness = material_sheenGloss;\n	#ifdef MAPTEXTURE\n	sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	sheenGlossiness *= saturate(vVertexColor.$VC);\n	#endif\n	#ifdef MAPINVERT\n	sheenGlossiness = 1.0 - sheenGlossiness;\n	#endif\n	sheenGlossiness += 0.0000001;\n	sGlossiness = sheenGlossiness;\n}\n";

var parallaxPS = "\nuniform float material_heightMapFactor;\nvoid getParallax() {\n	float parallaxScale = material_heightMapFactor;\n	float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	height = height * parallaxScale - parallaxScale*0.5;\n	vec3 viewDirT = dViewDirW * dTBN;\n	viewDirT.z += 0.42;\n	dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

var particlePS = "\nvarying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvoid main(void) {\n	vec4 tex  = texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n	vec4 ramp = texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n	ramp.rgb *= colorMult;\n	ramp.a += texCoordsAlphaLife.z;\n	vec3 rgb = tex.rgb * ramp.rgb;\n	float a  = tex.a * ramp.a;\n";

var particleVS = "\nvec3 unpack3NFloats(float src) {\n	float r = fract(src);\n	float g = fract(src * 256.0);\n	float b = fract(src * 65536.0);\n	return vec3(r, g, b);\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {\n	return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n	vec4 a = texture2D(tex,tc);\n	vec4 b = texture2D(tex,tc + graphSampleSize);\n	float c = fract(tc.x*graphNumSamples);\n	vec3 unpackedA = unpack3NFloats(a.w);\n	vec3 unpackedB = unpack3NFloats(b.w);\n	w = mix(unpackedA, unpackedB, c);\n	return mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n	float c = cos(pRotation);\n	float s = sin(pRotation);\n	mat2 m = mat2(c, -s, s, c);\n	rotMatrix = m;\n	return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n	#ifdef SCREEN_SPACE\n		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n	#else\n		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n	#endif\n	return pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n	return pos;\n}\nvec2 safeNormalize(vec2 v) {\n	float l = length(v);\n	return (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n	vec3 meshLocalPos = particle_vertexData.xyz;\n	float id = floor(particle_vertexData.w);\n	float rndFactor = fract(sin(id + 1.0 + seed));\n	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n	float uv = id / numParticlesPot;\n	readInput(uv);\n#ifdef LOCAL_SPACE\n	inVel = mat3(matrix_model) * inVel;\n#endif\n	vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n	float particleLifetime = lifetime;\n	if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n	vec2 quadXY = meshLocalPos.xy;\n	float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n	vec3 paramDiv;\n	vec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n	float scale = params.y;\n	float scaleDiv = paramDiv.x;\n	float alphaDiv = paramDiv.z;\n	scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n	texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n	vec3 particlePos = inPos;\n	vec3 particlePosMoved = vec3(0.0);\n	mat2 rotMatrix;\n";

var particleAnimFrameClampVS = "\n	float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

var particleAnimFrameLoopVS = "\n	float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

var particleAnimTexVS = "\n	float animationIndex;\n	if (animTexIndexParams.y == 1.0) {\n		animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n	} else {\n		animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n	}\n	float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n	float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n	atlasX = fract(atlasX);\n	texCoordsAlphaLife.xy *= animTexTilesParams.xy;\n	texCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

var particleInputFloatPS = "\nvoid readInput(float uv) {\n	vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n	inPos = tex.xyz;\n	inVel = tex2.xyz;\n	inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n	inShow = tex.w >= 0.0;\n	inLife = tex2.w;\n}\n";

var particleInputRgba8PS = "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n	return rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n	vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n	vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n	vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n	inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n	inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n	inVel = tex2.xyz;\n	inVel = (inVel - vec3(0.5)) * maxVel;\n	inAngle = decodeFloatRG(tex1.ba) * PI2;\n	inShow = tex2.a > 0.5;\n	inLife = decodeFloatRGBA(tex3);\n	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n	float maxPosLife = lifetime+1.0;\n	inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

var particleOutputFloatPS = "\nvoid writeOutput() {\n	if (gl_FragCoord.y<1.0) {\n		gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n	} else {\n		gl_FragColor = vec4(outVel, outLife);\n	}\n}\n";

var particleOutputRgba8PS = "\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n	vec2 enc = vec2(1.0, 255.0) * v;\n	enc = fract(enc);\n	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n	return enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n	vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n	enc = fract(enc);\n	enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n	return enc;\n}\nvoid writeOutput() {\n	outPos = outPos * outBoundsMul + outBoundsAdd;\n	outAngle = fract(outAngle / PI2);\n	outVel = (outVel / maxVel) + vec3(0.5);\n	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n	float maxPosLife = lifetime+1.0;\n	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n	if (gl_FragCoord.y < 1.0) {\n		gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n	} else if (gl_FragCoord.y < 2.0) {\n		gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n	} else if (gl_FragCoord.y < 3.0) {\n		gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n	} else {\n		gl_FragColor = encodeFloatRGBA(outLife);\n	}\n}\n";

var particleUpdaterAABBPS = "\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n	vec3 pos = inBounds - vec3(0.5);\n	vec3 posAbs = abs(pos);\n	vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n	vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n	pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n	pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n	pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n	return emitterPos + spawnBounds * pos;\n#else\n	return spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n	localVelocity -= vec3(0, 0, initialVelocity);\n}\n";

var particleUpdaterEndPS = "\n	writeOutput();\n}\n";

var particleUpdaterInitPS = "\nvarying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix;\nuniform mat3 emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 frameRandom;\nuniform vec3 localVelocityDivMult;\nuniform vec3 velocityDivMult;\nuniform float delta;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float numParticles;\nuniform float rotSpeedDivMult;\nuniform float radialSpeedDivMult;\nuniform float seed;\nuniform float startAngle;\nuniform float startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

var particleUpdaterNoRespawnPS = "\n	if (outLife >= lifetime) {\n		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n		visMode = -1.0;\n	}\n";

var particleUpdaterOnStopPS = "\n	visMode = outLife < 0.0? -1.0: visMode;\n";

var particleUpdaterRespawnPS = "\n	if (outLife >= lifetime) {\n		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n		visMode = 1.0;\n	}\n	visMode = outLife < 0.0? 1.0: visMode;\n";

var particleUpdaterSpherePS = "\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n	float rnd4 = fract(rndFactor * 1000.0);\n	vec3 norm = normalize(inBounds.xyz - vec3(0.5));\n	float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n	return emitterPos + norm * r * spawnBoundsSphere;\n#else\n	return norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n	localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

var particleUpdaterStartPS = "\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n	float r = fract(src);\n	float g = fract(src * 256.0);\n	float b = fract(src * 65536.0);\n	return vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n	vec4 a = texture2D(tex, tc);\n	vec4 b = texture2D(tex, tc + graphSampleSize);\n	float c = fract(tc.x * graphNumSamples);\n	vec3 unpackedA = unpack3NFloats(a.w);\n	vec3 unpackedB = unpack3NFloats(b.w);\n	w = mix(unpackedA, unpackedB, c);\n	return mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n	vec4 p4 = fract(vec4(p) * HASHSCALE4);\n	p4 += dot(p4, p4.wzxy+19.19);\n	return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n	if (gl_FragCoord.x > numParticles) discard;\n	readInput(vUv0.x);\n	visMode = inShow? 1.0 : -1.0;\n	vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n	float particleRate = rate + rateDiv * rndFactor.x;\n	outLife = inLife + delta;\n	float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n	vec3 localVelocityDiv;\n	vec3 velocityDiv;\n	vec3 paramDiv;\n	vec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);\n	vec3 velocity =	  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);\n	vec3 params =		tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n	float rotSpeed = params.x;\n	float rotSpeedDiv = paramDiv.y;\n	vec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);\n	float radialSpeed = radialParams.x;\n	float radialSpeedDiv = radialParams.y;\n	bool respawn = inLife <= 0.0 || outLife >= lifetime;\n	inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n	inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n	vec3 radialVel = inPos - emitterPos;\n#else\n	vec3 radialVel = inPos;\n#endif\n	radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n	radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n	localVelocity +=	(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n	velocity +=		 (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n	rotSpeed +=		 (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n	addInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n	outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n	outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n	outPos = inPos + outVel * delta;\n	outAngle = inAngle + rotSpeed * delta;\n";

var particle_billboardVS = "\n	quadXY = rotate(quadXY, inAngle, rotMatrix);\n	vec3 localPos = billboard(particlePos, quadXY);\n";

var particle_blendAddPS = "\n	dBlendModeFogFactor = 0.0;\n	rgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n	if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

var particle_blendMultiplyPS = "\n	rgb = mix(vec3(1.0), rgb, vec3(a));\n	if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

var particle_blendNormalPS = "\n	if (a < 0.01) discard;\n";

var particle_cpuVS = "\nattribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\nattribute vec2 particle_vertexData5;\n#else\nattribute vec4 particle_vertexData5;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\n#ifdef PARTICLE_GPU\n	uniform highp sampler2D internalTex0;\n	uniform highp sampler2D internalTex1;\n	uniform highp sampler2D internalTex2;\n#endif\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n	float c = cos(pRotation);\n	float s = sin(pRotation);\n	mat2 m = mat2(c, -s, s, c);\n	rotMatrix = m;\n	return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n	vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n	return pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n	return pos;\n}\nvoid main(void)\n{\n	vec3 particlePos = particle_vertexData.xyz;\n	vec3 inPos = particlePos;\n	vec3 vertPos = particle_vertexData3.xyz;\n	vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n	float id = floor(particle_vertexData4);\n	float rndFactor = fract(sin(id + 1.0 + seed));\n	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n	inVel = mat3(matrix_model) * inVel;\n#endif\n	vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n	vec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n	texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n	mat2 rotMatrix;\n	float inAngle = particle_vertexData2.x;\n	vec3 particlePosMoved = vec3(0.0);\n	vec3 meshLocalPos = particle_vertexData3.xyz;\n";

var particle_cpu_endVS = "\n	localPos *= particle_vertexData2.y * emitterScale;\n	localPos += particlePos;\n	gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

var particle_customFaceVS = "\n	quadXY = rotate(quadXY, inAngle, rotMatrix);\n	vec3 localPos = customFace(particlePos, quadXY);\n";

var particle_endPS = "\n	rgb = addFog(rgb);\n	rgb = toneMap(rgb);\n	rgb = gammaCorrectOutput(rgb);\n	gl_FragColor = vec4(rgb, a);\n}\n";

var particle_endVS = "\n	localPos *= scale * emitterScale;\n	localPos += particlePos;\n	#ifdef SCREEN_SPACE\n	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n	#else\n	gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n	#endif\n";

var particle_halflambertPS = "\n	vec3 negNormal = normal*0.5+0.5;\n	vec3 posNormal = -normal*0.5+0.5;\n	negNormal *= negNormal;\n	posNormal *= posNormal;\n";

var particle_initVS = "\nattribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles;\nuniform float numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float deltaRandomnessStatic;\nuniform float scaleDivMult;\nuniform float alphaDivMult;\nuniform float seed;\nuniform float delta;\nuniform sampler2D particleTexOUT;\nuniform sampler2D particleTexIN;\n#ifdef PARTICLE_GPU\n	uniform highp sampler2D internalTex0;\n	uniform highp sampler2D internalTex1;\n	uniform highp sampler2D internalTex2;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

var particle_lambertPS = "\n	vec3 negNormal = max(normal, vec3(0.0));\n	vec3 posNormal = max(-normal, vec3(0.0));\n";

var particle_lightingPS = "\n	vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n						negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n						negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n	rgb *= light;\n";

var particle_localShiftVS = "\n	particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

var particle_meshVS = "\n	vec3 localPos = meshLocalPos;\n	localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n	localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n	billboard(particlePos, quadXY);\n";

var particle_normalVS = "\n	Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

var particle_normalMapPS = "\n	vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n	vec3 normal = ParticleMat * normalMap;\n";

var particle_pointAlongVS = "\n	inAngle = atan(velocityV.x, velocityV.y);\n";

var particle_softPS = "\n	float depth = getLinearScreenDepth();\n	float particleDepth = vDepth;\n	float depthDiff = saturate(abs(particleDepth - depth) * softening);\n	a *= depthDiff;\n";

var particle_softVS = "\n	vDepth = getLinearDepth(localPos);\n";

var particle_stretchVS = "\n	vec3 moveDir = inVel * stretch;\n	vec3 posPrev = particlePos - moveDir;\n	posPrev += particlePosMoved;\n	vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n	float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n	particlePos = mix(particlePos, posPrev, interpolation);\n";

var particle_TBNVS = "\n	mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n	ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

var particle_wrapVS = "\n	vec3 origParticlePos = particlePos;\n	particlePos -= matrix_model[3].xyz;\n	particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n	particlePos += matrix_model[3].xyz;\n	particlePosMoved = particlePos - origParticlePos;\n";

var pickPS = "\nuniform uint meshInstanceId;\nvec4 getPickOutput() {\n	const vec4 inv = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n	const uvec4 shifts = uvec4(16, 8, 0, 24);\n	uvec4 col = (uvec4(meshInstanceId) >> shifts) & uvec4(0xff);\n	return vec4(col) * inv;\n}\n";

var reflDirPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n	dReflDirW = normalize(-reflect(viewDir, worldNormal));\n}\n";

var reflDirAnisoPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n	float roughness = sqrt(1.0 - min(gloss, 1.0));\n	float anisotropy = material_anisotropy * roughness;\n	vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];\n	vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);\n	vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n	vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));\n	dReflDirW = reflect(-viewDir, bentNormal);\n}\n";

var reflectionCCPS = "\n#ifdef LIT_CLEARCOAT\nvoid addReflectionCC(vec3 reflDir, float gloss) {\n	ccReflection += calcReflection(reflDir, gloss);\n}\n#endif\n";

var reflectionCubePS = "\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 lookupVec = cubeMapProject(reflDir);\n	lookupVec.x *= -1.0;\n	return {reflectionDecode}(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

var reflectionEnvHQPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n	vec2 uv = toSphericalUv(dir);\n	float level = saturate(1.0 - gloss) * 5.0;\n	float ilevel = floor(level);\n	float flevel = level - ilevel;\n	vec3 sharp = {reflectionCubemapDecode}(textureCube(texture_cubeMap, dir));\n	vec3 roughA = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n	vec3 roughB = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

var reflectionEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n	vec2 dx = dFdx(uv);\n	vec2 dy = dFdy(uv);\n	vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n	vec2 dx2 = dFdx(uv2);\n	vec2 dy2 = dFdy(uv2);\n	float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n	return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n	vec2 uv = toSphericalUv(dir);\n	float level = saturate(1.0 - gloss) * 5.0;\n	float ilevel = floor(level);\n	float level2 = shinyMipLevel(uv * atlasSize);\n	float ilevel2 = floor(level2);\n	vec2 uv0, uv1;\n	float weight;\n	if (ilevel == 0.0) {\n		uv0 = mapShinyUv(uv, ilevel2);\n		uv1 = mapShinyUv(uv, ilevel2 + 1.0);\n		weight = level2 - ilevel2;\n	} else {\n		uv0 = uv1 = mapRoughnessUv(uv, ilevel);\n		weight = 0.0;\n	}\n	vec3 linearA = {reflectionDecode}(texture2D(texture_envAtlas, uv0));\n	vec3 linearB = {reflectionDecode}(texture2D(texture_envAtlas, uv1));\n	vec3 linear0 = mix(linearA, linearB, weight);\n	vec3 linear1 = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n	return processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

var reflectionSpherePS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;\n	float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n	vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n	return {reflectionDecode}(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

var reflectionSheenPS = "\nvoid addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {\n	float NoV = dot(worldNormal, viewDir);\n	float alphaG = gloss * gloss;\n	float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;\n	float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;\n	float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );\n	sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);\n}\n";

var refractionCubePS = "\nvec3 refract2(vec3 viewVec, vec3 normal, float IOR) {\n	float vn = dot(viewVec, normal);\n	float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n	vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;\n	return refrVec;\n}\nvoid addRefraction(\n	vec3 worldNormal, \n	vec3 viewDir, \n	float thickness, \n	float gloss, \n	vec3 specularity, \n	vec3 albedo, \n	float transmission,\n	float refractionIndex,\n	float dispersion\n#if defined(LIT_IRIDESCENCE)\n	, vec3 iridescenceFresnel,\n	float iridescenceIntensity\n#endif \n) {\n	vec4 tmpRefl = dReflection;\n	vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);\n	dReflection = vec4(0);\n	addReflection(reflectionDir, gloss);\n	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);\n	dReflection = tmpRefl;\n}\n";

var refractionDynamicPS = "\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\nvec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {\n	vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n	vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n	vec2 uv = getGrabScreenPos(projectionPoint);\n	float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n	float refractionLod = log2(uScreenSize.x) * iorToRoughness;\n	vec3 refraction = texture2DLod(uSceneColorMap, uv, refractionLod).rgb;\n	return refraction;\n}\nvoid addRefraction(\n	vec3 worldNormal, \n	vec3 viewDir, \n	float thickness, \n	float gloss, \n	vec3 specularity, \n	vec3 albedo, \n	float transmission,\n	float refractionIndex,\n	float dispersion\n#if defined(LIT_IRIDESCENCE)\n	, vec3 iridescenceFresnel,\n	float iridescenceIntensity\n#endif\n) {\n	vec3 modelScale;\n	modelScale.x = length(vec3(matrix_model[0].xyz));\n	modelScale.y = length(vec3(matrix_model[1].xyz));\n	modelScale.z = length(vec3(matrix_model[2].xyz));\n	vec3 scale = thickness * modelScale;\n	vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;\n	vec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);\n	#ifdef LIT_DISPERSION\n		float halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;\n		float refractionIndexR = refractionIndex - halfSpread;\n		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;\n		refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;\n		float refractionIndexB = refractionIndex + halfSpread;\n		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;\n		refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;\n	#endif\n	vec3 transmittance;\n	if (material_invAttenuationDistance != 0.0)\n	{\n		vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n		transmittance = exp(-attenuation * length(refractionVector));\n	}\n	else\n	{\n		transmittance = refraction;\n	}\n	vec3 fresnel = vec3(1.0) - \n		getFresnel(\n			dot(viewDir, worldNormal), \n			gloss, \n			specularity\n		#if defined(LIT_IRIDESCENCE)\n			, iridescenceFresnel,\n			iridescenceIntensity\n		#endif\n		);\n	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n";

var reprojectPS$1 = '\nvarying vec2 vUv0;\n#ifdef CUBEMAP_SOURCE\n	uniform samplerCube sourceCube;\n#else\n	uniform sampler2D sourceTex;\n#endif\n#ifdef USE_SAMPLES_TEX\n	uniform sampler2D samplesTex;\n	uniform vec2 samplesTexInverseSize;\n#endif\nuniform vec3 params;\nfloat targetFace() { return params.x; }\nfloat targetTotalPixels() { return params.y; }\nfloat sourceTotalPixels() { return params.z; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\n#include "decodePS"\n#include "encodePS"\nvec3 modifySeams(vec3 dir, float scale) {\n	vec3 adir = abs(dir);\n	float M = max(max(adir.x, adir.y), adir.z);\n	return dir / M * vec3(\n		adir.x == M ? 1.0 : scale,\n		adir.y == M ? 1.0 : scale,\n		adir.z == M ? 1.0 : scale\n	);\n}\nvec2 toSpherical(vec3 dir) {\n	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n	return vec3(cos(uv.y) * sin(uv.x),\n				sin(uv.y),\n				cos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n	return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nfloat signNotZero(float k){\n	return(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n	return vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n	vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n	if (v.y < 0.0) {\n		v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n	}\n	return normalize(v);\n}\nvec3 getDirectionOctahedral() {\n	return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n	vec2 result = v.xz * (1.0 / l1norm);\n	if (v.y < 0.0) {\n		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n	}\n	return result;\n}\n#ifdef CUBEMAP_SOURCE\n	vec4 sampleCubemap(vec3 dir) {\n		return textureCube(sourceCube, modifySeams(dir, 1.0));\n	}\n	vec4 sampleCubemap(vec2 sph) {\n		return sampleCubemap(fromSpherical(sph));\n	}\n	vec4 sampleCubemap(vec3 dir, float mipLevel) {\n		return textureCubeLod(sourceCube, modifySeams(dir, 1.0), mipLevel);\n	}\n	vec4 sampleCubemap(vec2 sph, float mipLevel) {\n		return sampleCubemap(fromSpherical(sph), mipLevel);\n	}\n#else\n	vec4 sampleEquirect(vec2 sph) {\n		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n	}\n	vec4 sampleEquirect(vec3 dir) {\n		return sampleEquirect(toSpherical(dir));\n	}\n	vec4 sampleEquirect(vec2 sph, float mipLevel) {\n		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n		return texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n	}\n	vec4 sampleEquirect(vec3 dir, float mipLevel) {\n		return sampleEquirect(toSpherical(dir), mipLevel);\n	}\n	vec4 sampleOctahedral(vec3 dir) {\n		vec2 uv = octEncode(dir) * 0.5 + 0.5;\n		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n	}\n	vec4 sampleOctahedral(vec2 sph) {\n		return sampleOctahedral(fromSpherical(sph));\n	}\n	vec4 sampleOctahedral(vec3 dir, float mipLevel) {\n		vec2 uv = octEncode(dir) * 0.5 + 0.5;\n		return texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n	}\n	vec4 sampleOctahedral(vec2 sph, float mipLevel) {\n		return sampleOctahedral(fromSpherical(sph), mipLevel);\n	}\n#endif\nvec3 getDirectionCubemap() {\n	vec2 st = vUv0 * 2.0 - 1.0;\n	float face = targetFace();\n	vec3 vec;\n	if (face == 0.0) {\n		vec = vec3(1, -st.y, -st.x);\n	} else if (face == 1.0) {\n		vec = vec3(-1, -st.y, st.x);\n	} else if (face == 2.0) {\n		vec = vec3(st.x, 1, st.y);\n	} else if (face == 3.0) {\n		vec = vec3(st.x, -1, -st.y);\n	} else if (face == 4.0) {\n		vec = vec3(st.x, -st.y, 1);\n	} else {\n		vec = vec3(-st.x, -st.y, -1);\n	}\n	return normalize(modifySeams(vec, 1.0));\n}\nmat3 matrixFromVector(vec3 n) {\n	float a = 1.0 / (1.0 + n.z);\n	float b = -n.x * n.y * a;\n	vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n	vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n	return mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n	vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n	vec3 x = normalize(cross(up, n));\n	vec3 y = cross(n, x);\n	return mat3(x, y, n);\n}\nvec4 reproject() {\n	if ({NUM_SAMPLES} <= 1) {\n		return {ENCODE_FUNC}({DECODE_FUNC}({SOURCE_FUNC}({TARGET_FUNC}())));\n	} else {\n		vec3 t = {TARGET_FUNC}();\n		vec3 tu = dFdx(t);\n		vec3 tv = dFdy(t);\n		vec3 result = vec3(0.0);\n		for (float u = 0.0; u < {NUM_SAMPLES_SQRT}; ++u) {\n			for (float v = 0.0; v < {NUM_SAMPLES_SQRT}; ++v) {\n				result += {DECODE_FUNC}({SOURCE_FUNC}(normalize(t +\n															tu * (u / {NUM_SAMPLES_SQRT} - 0.5) +\n															tv * (v / {NUM_SAMPLES_SQRT} - 0.5))));\n			}\n		}\n		return {ENCODE_FUNC}(result / ({NUM_SAMPLES_SQRT} * {NUM_SAMPLES_SQRT}));\n	}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n#ifdef USE_SAMPLES_TEX\n	void unpackSample(int i, out vec3 L, out float mipLevel) {\n		float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n		float v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n		vec4 raw;\n		raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n		raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n		raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n		raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n		L.xyz = raw.xyz * 2.0 - 1.0;\n		mipLevel = raw.w * 8.0;\n	}\n	vec4 prefilterSamples() {\n		mat3 vecSpace = matrixFromVectorSlow({TARGET_FUNC}());\n		vec3 L;\n		float mipLevel;\n		vec3 result = vec3(0.0);\n		float totalWeight = 0.0;\n		for (int i = 0; i < {NUM_SAMPLES}; ++i) {\n			unpackSample(i, L, mipLevel);\n			result += {DECODE_FUNC}({SOURCE_FUNC}(vecSpace * L, mipLevel)) * L.z;\n			totalWeight += L.z;\n		}\n		return {ENCODE_FUNC}(result / totalWeight);\n	}\n	vec4 prefilterSamplesUnweighted() {\n		mat3 vecSpace = matrixFromVectorSlow({TARGET_FUNC}());\n		vec3 L;\n		float mipLevel;\n		vec3 result = vec3(0.0);\n		float totalWeight = 0.0;\n		for (int i = 0; i < {NUM_SAMPLES}; ++i) {\n			unpackSample(i, L, mipLevel);\n			result += {DECODE_FUNC}({SOURCE_FUNC}(vecSpace * L, mipLevel));\n		}\n		return {ENCODE_FUNC}(result / float({NUM_SAMPLES}));\n	}\n#endif\nvoid main(void) {\n	gl_FragColor = {PROCESS_FUNC}();\n}\n';

var reprojectVS$1 = "\nattribute vec2 vertex_position;\nuniform vec4 uvMod;\nvarying vec2 vUv0;\nvoid main(void) {\n	gl_Position = vec4(vertex_position, 0.5, 1.0);\n	vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);\n}\n";

var sampleCatmullRomPS = "\nvec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {\n	vec2 samplePos = uv * texSize;\n	vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n	vec2 f = samplePos - texPos1;\n	vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n	vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n	vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n	vec2 w3 = f * f * (-0.5 + 0.5 * f);\n	vec2 w12 = w1 + w2;\n	vec2 offset12 = w2 / (w1 + w2);\n	vec2 texPos0 = (texPos1 - 1.0) / texSize;\n	vec2 texPos3 = (texPos1 + 2.0) / texSize;\n	vec2 texPos12 = (texPos1 + offset12) / texSize;\n	vec4 result = vec4(0.0);\n	result += texture2DLod(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;\n	result += texture2DLod(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;\n	result += texture2DLod(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;\n	result += texture2DLod(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;\n	result += texture2DLod(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;\n	result += texture2DLod(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;\n	result += texture2DLod(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;\n	result += texture2DLod(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;\n	result += texture2DLod(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;\n	return result;\n}\n";

var screenDepthPS = "\nuniform highp sampler2D uSceneDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef LINEARIZE_DEPTH\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z) {\n	if (camera_params.w == 0.0)\n		return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n	else\n		return camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#endif\nfloat delinearizeDepth(float linearDepth) {\n	if (camera_params.w == 0.0) {\n		return (camera_params.y * (camera_params.z - linearDepth)) / (linearDepth * (camera_params.z - camera_params.y));\n	} else {\n		return (linearDepth - camera_params.z) / (camera_params.y - camera_params.z);\n	}\n}\nfloat getLinearScreenDepth(vec2 uv) {\n	#ifdef SCENE_DEPTHMAP_LINEAR\n		#ifdef SCENE_DEPTHMAP_FLOAT\n			return texture2D(uSceneDepthMap, uv).r;\n		#else\n			ivec2 textureSize = textureSize(uSceneDepthMap, 0);\n			ivec2 texel = ivec2(uv * vec2(textureSize));\n			vec4 data = texelFetch(uSceneDepthMap, texel, 0);\n			uint intBits = \n				(uint(data.r * 255.0) << 24u) |\n				(uint(data.g * 255.0) << 16u) |\n				(uint(data.b * 255.0) << 8u) |\n				uint(data.a * 255.0);\n			return uintBitsToFloat(intBits);\n		#endif\n	#else\n		return linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n	#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n	vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n	return getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n	return -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

var shadowCascadesPS = "\nint getShadowCascadeIndex(vec4 shadowCascadeDistances, int shadowCascadeCount) {\n	float depth = 1.0 / gl_FragCoord.w;\n	vec4 comparisons = step(shadowCascadeDistances, vec4(depth));\n	int cascadeIndex = int(dot(comparisons, vec4(1.0)));\n	return min(cascadeIndex, shadowCascadeCount - 1);\n}\nint ditherShadowCascadeIndex(int cascadeIndex, vec4 shadowCascadeDistances, int shadowCascadeCount, float blendFactor) {\n \n	if (cascadeIndex < shadowCascadeCount - 1) {\n		float currentRangeEnd = shadowCascadeDistances[cascadeIndex];\n		float transitionStart = blendFactor * currentRangeEnd;\n		float depth = 1.0 / gl_FragCoord.w;\n		if (depth > transitionStart) {\n			float transitionFactor = smoothstep(transitionStart, currentRangeEnd, depth);\n			float dither = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n			if (dither < transitionFactor) {\n				cascadeIndex += 1;\n			}\n		}\n	}\n	return cascadeIndex;\n}\nvec3 fadeShadow(vec3 shadowCoord, vec4 shadowCascadeDistances) {				  \n	float depth = 1.0 / gl_FragCoord.w;\n	if (depth > shadowCascadeDistances.w) {\n		shadowCoord.z = -9999999.0;\n	}\n	return shadowCoord;\n}\n";

var shadowEVSMPS = "\nfloat linstep(float a, float b, float v) {\n	return saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, minVariance);\n	float d = mean - moments.x;\n	float pMax = variance / (variance + (d * d));\n	pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n	return (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n	Z = 2.0 * Z - 1.0;\n	float warpedDepth = exp(exponent * Z);\n	moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n	float VSMBias = vsmBias;\n	float depthScale = VSMBias * exponent * warpedDepth;\n	float minVariance1 = depthScale * depthScale;\n	return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\nfloat VSM16(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n	vec3 moments = texture2DLod(tex, texCoords, 0.0).xyz;\n	return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM16(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent) {\n	return VSM16(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM16(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n	return VSM16(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\nfloat VSM32(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n	#ifdef CAPS_TEXTURE_FLOAT_FILTERABLE\n		vec3 moments = texture2DLod(tex, texCoords, 0.0).xyz;\n	#else\n		float pixelSize = 1.0 / resolution;\n		texCoords -= vec2(pixelSize);\n		vec3 s00 = texture2DLod(tex, texCoords, 0.0).xyz;\n		vec3 s10 = texture2DLod(tex, texCoords + vec2(pixelSize, 0), 0.0).xyz;\n		vec3 s01 = texture2DLod(tex, texCoords + vec2(0, pixelSize), 0.0).xyz;\n		vec3 s11 = texture2DLod(tex, texCoords + vec2(pixelSize), 0.0).xyz;\n		vec2 fr = fract(texCoords * resolution);\n		vec3 h0 = mix(s00, s10, fr.x);\n		vec3 h1 = mix(s01, s11, fr.x);\n		vec3 moments = mix(h0, h1, fr.y);\n	#endif\n	return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM32(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent) {\n	return VSM32(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM32(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n	return VSM32(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

var shadowPCF1PS = "\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\n#ifndef WEBGPU\nfloat getShadowOmniPCF1x1(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	return texture(shadowMap, vec4(lightDir, shadowZ));\n}\n#endif\n";

var shadowPCF3PS = "\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n	float z = shadowCoord.z;\n	vec2 uv = shadowCoord.xy * shadowParams.x;\n	float shadowMapSizeInv = 1.0 / shadowParams.x;\n	vec2 base_uv = floor(uv + 0.5);\n	float s = (uv.x + 0.5 - base_uv.x);\n	float t = (uv.y + 0.5 - base_uv.y);\n	base_uv -= vec2(0.5);\n	base_uv *= shadowMapSizeInv;\n	float sum = 0.0;\n	float uw0 = (3.0 - 2.0 * s);\n	float uw1 = (1.0 + 2.0 * s);\n	float u0 = (2.0 - s) / uw0 - 1.0;\n	float u1 = s / uw1 + 1.0;\n	float vw0 = (3.0 - 2.0 * t);\n	float vw1 = (1.0 + 2.0 * t);\n	float v0 = (2.0 - t) / vw0 - 1.0;\n	float v1 = t / vw1 + 1.0;\n	u0 = u0 * shadowMapSizeInv + base_uv.x;\n	v0 = v0 * shadowMapSizeInv + base_uv.y;\n	u1 = u1 * shadowMapSizeInv + base_uv.x;\n	v1 = v1 * shadowMapSizeInv + base_uv.y;\n	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n	sum *= 1.0f / 16.0;\n	return sum;\n}\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n#ifndef WEBGPU\nfloat getShadowOmniPCF3x3(samplerCubeShadow shadowMap, vec4 shadowParams, vec3 dir) {\n	\n	float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n	float z = 1.0 / float(textureSize(shadowMap, 0));\n	vec3 tc = normalize(dir);\n	mediump vec4 shadows;\n	shadows.x = texture(shadowMap, vec4(tc + vec3( z, z, z), shadowZ));\n	shadows.y = texture(shadowMap, vec4(tc + vec3(-z,-z, z), shadowZ));\n	shadows.z = texture(shadowMap, vec4(tc + vec3(-z, z,-z), shadowZ));\n	shadows.w = texture(shadowMap, vec4(tc + vec3( z,-z,-z), shadowZ));\n	return dot(shadows, vec4(0.25));\n}\nfloat getShadowOmniPCF3x3(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n	return getShadowOmniPCF3x3(shadowMap, shadowParams, lightDir);\n}\n#endif\n";

var shadowPCF5PS = "\nfloat _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n	float z = shadowCoord.z;\n	vec2 uv = shadowCoord.xy * shadowParams.x;\n	float shadowMapSizeInv = 1.0 / shadowParams.x;\n	vec2 base_uv = floor(uv + 0.5);\n	float s = (uv.x + 0.5 - base_uv.x);\n	float t = (uv.y + 0.5 - base_uv.y);\n	base_uv -= vec2(0.5);\n	base_uv *= shadowMapSizeInv;\n	float uw0 = (4.0 - 3.0 * s);\n	float uw1 = 7.0;\n	float uw2 = (1.0 + 3.0 * s);\n	float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n	float u1 = (3.0 + s) / uw1;\n	float u2 = s / uw2 + 2.0;\n	float vw0 = (4.0 - 3.0 * t);\n	float vw1 = 7.0;\n	float vw2 = (1.0 + 3.0 * t);\n	float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n	float v1 = (3.0 + t) / vw1;\n	float v2 = t / vw2 + 2.0;\n	float sum = 0.0;\n	u0 = u0 * shadowMapSizeInv + base_uv.x;\n	v0 = v0 * shadowMapSizeInv + base_uv.y;\n	u1 = u1 * shadowMapSizeInv + base_uv.x;\n	v1 = v1 * shadowMapSizeInv + base_uv.y;\n	u2 = u2 * shadowMapSizeInv + base_uv.x;\n	v2 = v2 * shadowMapSizeInv + base_uv.y;\n	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n	sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));\n	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n	sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));\n	sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));\n	sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));\n	sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));\n	sum *= 1.0f / 144.0;\n	sum = saturate(sum);\n	return sum;\n}\nfloat getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n";

var shadowPCSSPS = "\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n	const float GoldenAngle = 2.4;\n	float theta = float(sampleIndex) * GoldenAngle + phi;\n	float sine = sin(theta);\n	float cosine = cos(theta);\n	return vec2(r * cosine, r * sine);\n}\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n	const float GoldenAngle = 2.4;\n	float theta = float(sampleIndex) * GoldenAngle + phi;\n	float weight = float(sampleIndex) / count;\n	return vec3(cos(theta) * r, weight, sin(theta) * r);\n}\nfloat noise(vec2 screenPos) {\n	const float PHI = 1.61803398874989484820459;\n	return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);\n}\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n	float z = depth * 2.0 - 1.0;\n	vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n	vec4 viewSpace = invProjection * clipSpace;\n	return viewSpace.z;\n}\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z, vec4 cameraParams) {\n	float blockers = 0.0;\n	float averageBlocker = 0.0;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		vec2 offset = sampleCoords[i] * searchSize;\n		vec2 sampleUV = shadowCoords + offset;\n		float blocker = texture2DLod(shadowMap, sampleUV, 0.0).r;\n		float isBlocking = step(blocker, z);\n		blockers += isBlocking;\n		averageBlocker += blocker * isBlocking;\n	}\n	if (blockers > 0.0)\n		return averageBlocker / blockers;\n	return -1.0;\n}\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n	float receiverDepth = linearizeDepth(shadowCoords.z, cameraParams);\n	vec2 samplePoints[PCSS_SAMPLE_COUNT];\n	const float PI = 3.141592653589793;\n	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		float pcssPresample = pcssDiskSamples[i];\n		samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n	}\n	float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth, cameraParams);\n	if (averageBlocker == -1.0) {\n		return 1.0;\n	} else {\n		float depthDifference = (receiverDepth - averageBlocker) / 3.0;\n		vec2 filterRadius = depthDifference * shadowSearchArea;\n		float shadow = 0.0;\n		for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n		{\n			vec2 sampleUV = samplePoints[i] * filterRadius;\n			sampleUV = shadowCoords.xy + sampleUV;\n			float depth = texture2DLod(shadowMap, sampleUV, 0.0).r;\n			shadow += step(receiverDepth, depth);\n		}\n		return shadow / float(PCSS_SAMPLE_COUNT);\n	} \n}\n#ifndef WEBGPU\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n	float blockers = 0.0;\n	float averageBlocker = 0.0;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n		sampleDir = normalize(sampleDir);\n		float blocker = textureCubeLod(shadowMap, sampleDir, 0.0).r;\n		float isBlocking = step(blocker, z);\n		blockers += isBlocking;\n		averageBlocker += blocker * isBlocking;\n	}\n	if (blockers > 0.0)\n		return averageBlocker / blockers;\n	return -1.0;\n}\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n	\n	vec3 samplePoints[PCSS_SAMPLE_COUNT];\n	const float PI = 3.141592653589793;\n	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		float r = pcssSphereSamples[i];\n		samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n	}\n	float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n	vec3 lightDirNorm = normalize(lightDir);\n	\n	float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n	if (averageBlocker == -1.0) {\n		return 1.0;\n	} else {\n		float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n		float shadow = 0.0;\n		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n		{\n			vec3 offset = samplePoints[i] * filterRadius;\n			vec3 sampleDir = lightDirNorm + offset;\n			sampleDir = normalize(sampleDir);\n			float depth = textureCubeLod(shadowMap, sampleDir, 0.0).r;\n			shadow += step(receiverDepth, depth);\n		}\n		return shadow / float(PCSS_SAMPLE_COUNT);\n	}\n}\nfloat getShadowOmniPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n	return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\n#endif\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n";

var shadowSoftPS = "\nhighp float fractSinRand( const in vec2 uv ) {\n	const float PI = 3.141592653589793;\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);\n	return fract(sin(sn) * c);\n}\nstruct VogelDiskData {\n	float invNumSamples;\n	float initialAngle;\n	float currentPointId;\n};\nvoid prepareDiskConstants(out VogelDiskData data, int sampleCount, int numRings, float randomSeed) {\n	const float pi2 = 6.28318530718;\n	data.invNumSamples = 1.0 / float(sampleCount);\n	data.initialAngle = randomSeed * pi2;\n	data.currentPointId = 0.0;\n}\n#define GOLDEN_ANGLE 2.399963\nvec2 generateDiskSample(inout VogelDiskData data) {\n	float r = sqrt((data.currentPointId + 0.5) * data.invNumSamples);\n	float theta = data.currentPointId * GOLDEN_ANGLE + data.initialAngle;\n	vec2 offset = vec2(cos(theta), sin(theta)) * pow(r, 1.33);\n	data.currentPointId += 1.0;\n	return offset;\n}\nvoid PCSSFindBlocker(TEXTURE_ACCEPT(shadowMap), out float avgBlockerDepth, out int numBlockers,\n	vec2 shadowCoords, float z, int shadowBlockerSamples, float penumbraSize, float invShadowMapSize, float randomSeed) {\n	VogelDiskData diskData;\n	prepareDiskConstants(diskData, shadowBlockerSamples, 11, randomSeed);\n	float searchWidth = penumbraSize * invShadowMapSize;\n	float blockerSum = 0.0;\n	numBlockers = 0;\n	for( int i = 0; i < shadowBlockerSamples; ++i ) {\n		vec2 diskUV = generateDiskSample(diskData);\n		vec2 sampleUV = shadowCoords + diskUV * searchWidth;\n		float shadowMapDepth = texture2DLod(shadowMap, sampleUV, 0.0).r;\n		if ( shadowMapDepth < z ) {\n			blockerSum += shadowMapDepth;\n			numBlockers++;\n		}\n	}\n	avgBlockerDepth = blockerSum / float(numBlockers);\n}\nfloat PCSSFilter(TEXTURE_ACCEPT(shadowMap), vec2 uv, float receiverDepth, int shadowSamples, float filterRadius, float randomSeed) {\n	VogelDiskData diskData;\n	prepareDiskConstants(diskData, shadowSamples, 11, randomSeed);\n	float sum = 0.0;\n	for (int i = 0; i < shadowSamples; i++) {\n		vec2 offsetUV = generateDiskSample(diskData) * filterRadius;\n		float depth = texture2DLod(shadowMap, uv + offsetUV, 0.0).r;\n		sum += step(receiverDepth, depth);\n	}\n	return sum / float(shadowSamples);\n}\nfloat getPenumbra(float dblocker, float dreceiver, float penumbraSize, float penumbraFalloff) {\n	float dist = dreceiver - dblocker;\n	float penumbra = 1.0 - pow(1.0 - dist, penumbraFalloff);\n	return penumbra * penumbraSize;\n}\nfloat PCSSDirectional(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec4 softShadowParams) {\n	float receiverDepth = shadowCoords.z;\n	float randomSeed = fractSinRand(gl_FragCoord.xy);\n	int shadowSamples = int(softShadowParams.x);\n	int shadowBlockerSamples = int(softShadowParams.y);\n	float penumbraSize = softShadowParams.z;\n	float penumbraFalloff = softShadowParams.w;\n	int shadowMapSize = textureSize(shadowMap, 0).x;\n	float invShadowMapSize = 1.0 / float(shadowMapSize);\n	invShadowMapSize *= float(shadowMapSize) / 2048.0;\n	float penumbra;\n	if (shadowBlockerSamples > 0) {\n		float avgBlockerDepth = 0.0;\n		int numBlockers = 0;\n		PCSSFindBlocker(TEXTURE_PASS(shadowMap), avgBlockerDepth, numBlockers, shadowCoords.xy, receiverDepth, shadowBlockerSamples, penumbraSize, invShadowMapSize, randomSeed);\n		if (numBlockers < 1)\n			return 1.0f;\n		penumbra = getPenumbra(avgBlockerDepth, shadowCoords.z, penumbraSize, penumbraFalloff);\n	} else {\n		penumbra = penumbraSize;\n	}\n	float filterRadius = penumbra * invShadowMapSize;\n	return PCSSFilter(TEXTURE_PASS(shadowMap), shadowCoords.xy, receiverDepth, shadowSamples, filterRadius, randomSeed);\n}\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec4 softShadowParams, vec3 lightDir) {\n	return PCSSDirectional(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, softShadowParams);\n}\n";

var skinBatchVS = "\nattribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n	float j = i * 3.0;\n	float dx = texture_poseMapSize.z;\n	float dy = texture_poseMapSize.w;\n	float y = floor(j * dx);\n	float x = j - (y * texture_poseMapSize.x);\n	y = dy * (y + 0.5);\n	vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n	vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n	vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n	return mat4(\n		v1.x, v2.x, v3.x, 0,\n		v1.y, v2.y, v3.y, 0,\n		v1.z, v2.z, v3.z, 0,\n		v1.w, v2.w, v3.w, 1\n	);\n}\n";

var skinVS = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {\n	float i = float(index);\n	float j = i * 3.0;\n	float dx = texture_poseMapSize.z;\n	float dy = texture_poseMapSize.w;\n	\n	float y = floor(j * dx);\n	float x = j - (y * texture_poseMapSize.x);\n	y = dy * (y + 0.5);\n	v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n	v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n	v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n	vec4 a1, a2, a3;\n	getBoneMatrix(indices.x, a1, a2, a3);\n	vec4 b1, b2, b3;\n	getBoneMatrix(indices.y, b1, b2, b3);\n	vec4 c1, c2, c3;\n	getBoneMatrix(indices.z, c1, c2, c3);\n	vec4 d1, d2, d3;\n	getBoneMatrix(indices.w, d1, d2, d3);\n	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n	float one = dot(weights, vec4(1.0));\n	return mat4(\n		v1.x, v2.x, v3.x, 0,\n		v1.y, v2.y, v3.y, 0,\n		v1.z, v2.z, v3.z, 0,\n		v1.w, v2.w, v3.w, one\n	);\n}\n";

var skyboxPS$1 = '\n	#define LIT_SKYBOX_INTENSITY\n	#include "envProcPS"\n	#include "gammaPS"\n	#include "tonemappingPS"\n	varying vec3 vViewDir;\n	uniform float skyboxHighlightMultiplier;\n	#ifdef SKY_CUBEMAP\n		uniform samplerCube texture_cubeMap;\n		#ifdef SKYMESH\n			varying vec3 vWorldPos;\n			uniform mat3 cubeMapRotationMatrix;\n			uniform vec3 projectedSkydomeCenter;\n		#endif\n	#else\n		#include "sphericalPS"\n		#include "envAtlasPS"\n		uniform sampler2D texture_envAtlas;\n		uniform float mipLevel;\n	#endif\n	void main(void) {\n		#ifdef SKY_CUBEMAP\n			#ifdef SKYMESH\n				vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);\n				vec3 dir = envDir * cubeMapRotationMatrix;\n			#else\n				vec3 dir = vViewDir;\n			#endif\n			dir.x *= -1.0;\n			vec3 linear = {SKYBOX_DECODE_FNC}(textureCube(texture_cubeMap, dir));\n		#else\n			vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n			vec2 uv = toSphericalUv(normalize(dir));\n			vec3 linear = {SKYBOX_DECODE_FNC}(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n		#endif\n		if (any(greaterThanEqual(linear, vec3(64.0)))) {\n			linear *= skyboxHighlightMultiplier;\n		}\n		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n	}\n';

var skyboxVS$1 = "\nattribute vec4 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\n#ifdef SKYMESH\n	uniform mat4 matrix_model;\n	varying vec3 vWorldPos;\n#endif\nvoid main(void) {\n	mat4 view = matrix_view;\n	#ifdef SKYMESH\n		vec4 worldPos = matrix_model * aPosition;\n		vWorldPos = worldPos.xyz;\n		gl_Position = matrix_projectionSkybox * (view * worldPos);\n	#else\n		view[3][0] = view[3][1] = view[3][2] = 0.0;\n		gl_Position = matrix_projectionSkybox * (view * aPosition);\n		vViewDir = aPosition.xyz * cubeMapRotationMatrix;\n	#endif\n	gl_Position.z = gl_Position.w - 1.0e-7;\n}\n";

var specularPS = "\n#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\nvoid getSpecularity() {\n	vec3 specularColor = vec3(1,1,1);\n	#ifdef MAPCOLOR\n	specularColor *= material_specular;\n	#endif\n	#ifdef MAPTEXTURE\n	specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	specularColor *= saturate(vVertexColor.$VC);\n	#endif\n	dSpecularity = specularColor;\n}\n";

var sphericalPS$1 = "\nvec2 toSpherical(vec3 dir) {\n	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n	const float PI = 3.141592653589793;\n	vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n	return vec2(uv.x, 1.0 - uv.y);\n}\n";

var specularityFactorPS = "\n#ifdef MAPFLOAT\nuniform float material_specularityFactor;\n#endif\nvoid getSpecularityFactor() {\n	float specularityFactor = 1.0;\n	#ifdef MAPFLOAT\n	specularityFactor *= material_specularityFactor;\n	#endif\n	#ifdef MAPTEXTURE\n	specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	specularityFactor *= saturate(vVertexColor.$VC);\n	#endif\n	dSpecularityFactor = specularityFactor;\n}\n";

var spotPS = "\nfloat getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {\n	float cosAngle = dot(lightDirNorm, lightSpotDir);\n	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

var startNineSlicedPS = "\n	nineSlicedUv = vUv0;\n	nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

var startNineSlicedTiledPS = "\n	vec2 tileMask = step(vMask, vec2(0.99999));\n	vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n	vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n	vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n	nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n	nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n	\n";

var tangentBinormalVS = "\nvec3 getTangent() {\n	return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n	return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n";

var TBNPS = "\n#ifdef LIT_TANGENTS\n	#define TBN_TANGENTS\n#else\n	#if defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)\n		#define TBN_DERIVATIVES\n	#endif\n#endif\n#if defined(TBN_DERIVATIVES)\n	uniform float tbnBasis;\n#endif\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n	#ifdef TBN_TANGENTS\n		dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));\n	#elif defined(TBN_DERIVATIVES)\n		vec2 uv = {lightingUv};\n		vec3 dp1 = dFdx( vPositionW );\n		vec3 dp2 = dFdy( vPositionW );\n		vec2 duv1 = dFdx( uv );\n		vec2 duv2 = dFdy( uv );\n		vec3 dp2perp = cross( dp2, normal );\n		vec3 dp1perp = cross( normal, dp1 );\n		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n		float denom = max( dot(T,T), dot(B,B) );\n		float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n		dTBN = mat3(T * invmax, -B * invmax, normal );\n	#else\n		vec3 B = cross(normal, vObjectSpaceUpW);\n		vec3 T = cross(normal, B);\n		if (dot(B,B)==0.0)\n		{\n			float major=max(max(normal.x, normal.y), normal.z);\n			if (normal.x == major)\n			{\n				B = cross(normal, vec3(0,1,0));\n				T = cross(normal, B);\n			}\n			else if (normal.y == major)\n			{\n				B = cross(normal, vec3(0,0,1));\n				T = cross(normal, B);\n			}\n			else if (normal.z == major)\n			{\n				B = cross(normal, vec3(1,0,0));\n				T = cross(normal, B);\n			}\n		}\n		dTBN = mat3(normalize(T), normalize(B), normalize(normal));\n	#endif\n}\n";

var thicknessPS = "\n#ifdef MAPFLOAT\nuniform float material_thickness;\n#endif\nvoid getThickness() {\n	dThickness = 1.0;\n	#ifdef MAPFLOAT\n	dThickness *= material_thickness;\n	#endif\n	#ifdef MAPTEXTURE\n	dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	dThickness *= saturate(vVertexColor.$VC);\n	#endif\n}\n";

var tonemappingPS$1 = '\n#if (TONEMAP == NONE)\n	#include "tonemappingNonePS"\n#elif TONEMAP == FILMIC\n	#include "tonemappingFilmicPS"\n#elif TONEMAP == LINEAR\n	#include "tonemappingLinearPS"\n#elif TONEMAP == HEJL\n	#include "tonemappingHejlPS"\n#elif TONEMAP == ACES\n	#include "tonemappingAcesPS"\n#elif TONEMAP == ACES2\n	#include "tonemappingAces2PS"\n#elif TONEMAP == NEUTRAL\n	#include "tonemappingNeutralPS"\n#endif\n';

var tonemappingAcesPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	float tA = 2.51;\n	float tB = 0.03;\n	float tC = 2.43;\n	float tD = 0.59;\n	float tE = 0.14;\n	vec3 x = color * exposure;\n	return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

var tonemappingAces2PS$1 = "\nuniform float exposure;\nconst mat3 ACESInputMat = mat3(\n	0.59719, 0.35458, 0.04823,\n	0.07600, 0.90834, 0.01566,\n	0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n	 1.60475, -0.53108, -0.07367,\n	-0.10208,  1.10813, -0.00605,\n	-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n	vec3 a = v * (v + 0.0245786) - 0.000090537;\n	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n	return a / b;\n}\nvec3 toneMap(vec3 color) {\n	color *= exposure / 0.6;\n	color = color * ACESInputMat;\n	color = RRTAndODTFit(color);\n	color = color * ACESOutputMat;\n	color = clamp(color, 0.0, 1.0);\n	return color;\n}\n";

var tonemappingFilmicPS$1 = "\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n	color = uncharted2Tonemap(color * exposure);\n	vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n	color = color * whiteScale;\n	return color;\n}\n";

var tonemappingHejlPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	color *= exposure;\n	const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n	const float Scl = 1.25;\n	vec3 h = max( vec3(0.0), color - vec3(0.004) );\n	return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

var tonemappingLinearPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	return color * exposure;\n}\n";

var tonemappingNeutralPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	color *= exposure;\n	float startCompression = 0.8 - 0.04;\n	float desaturation = 0.15;\n	float x = min(color.r, min(color.g, color.b));\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max(color.r, max(color.g, color.b));\n	if (peak < startCompression) return color;\n	float d = 1. - startCompression;\n	float newPeak = 1. - d * d / (peak + d - startCompression);\n	color *= newPeak / peak;\n	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n	return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n";

var tonemappingNonePS$1 = "\nvec3 toneMap(vec3 color) {\n	return color;\n}\n";

var transformVS = "\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\nvec4 evalWorldPosition(vec3 vertexPosition, mat4 modelMatrix) {\n	vec3 localPos = getLocalPosition(vertexPosition);\n	#ifdef NINESLICED\n		localPos.xz *= outerScale;\n		vec2 positiveUnitOffset = clamp(vertexPosition.xz, vec2(0.0), vec2(1.0));\n		vec2 negativeUnitOffset = clamp(-vertexPosition.xz, vec2(0.0), vec2(1.0));\n		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n		localPos.xz *= -0.5;\n		localPos = localPos.xzy;\n	#endif\n	vec4 posW = modelMatrix * vec4(localPos, 1.0);\n	#ifdef SCREENSPACE\n		posW.zw = vec2(0.0, 1.0);\n	#endif\n	return posW;\n}\nvec4 getPosition() {\n	dModelMatrix = getModelMatrix();\n	vec4 posW = evalWorldPosition(vertex_position.xyz, dModelMatrix);\n	dPositionW = posW.xyz;\n	vec4 screenPos;\n	#ifdef UV1LAYOUT\n	screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n		#ifdef WEBGPU\n		screenPos.y *= -1.0;\n		#endif\n	#else\n	#ifdef SCREENSPACE\n	screenPos = posW;\n	screenPos.y *= projectionFlipY;\n	#else\n	screenPos = matrix_viewProjection * posW;\n	#endif\n	#ifdef PIXELSNAP\n	screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n	screenPos.xy *= uScreenSize.xy;\n	screenPos.xy = floor(screenPos.xy);\n	screenPos.xy *= uScreenSize.zw;\n	screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n	#endif\n	#endif\n	return screenPos;\n}\nvec3 getWorldPosition() {\n	return dPositionW;\n}\n";

var transformCoreVS = '\nattribute vec4 vertex_position;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n#ifdef MORPHING\n	uniform vec2 morph_tex_params;\n	attribute uint morph_vertex_id;\n	ivec2 getTextureMorphCoords() {\n		ivec2 textureSize = ivec2(morph_tex_params);\n		int morphGridV = int(morph_vertex_id) / textureSize.x;\n		int morphGridU = int(morph_vertex_id) - (morphGridV * textureSize.x);\n		#ifdef WEBGPU\n			morphGridV = textureSize.y - morphGridV - 1;\n		#endif\n		return ivec2(morphGridU, morphGridV);\n	}\n	#ifdef MORPHING_POSITION\n		#ifdef MORPHING_INT\n			uniform vec3 aabbSize;\n			uniform vec3 aabbMin;\n			uniform usampler2D morphPositionTex;\n		#else\n			uniform highp sampler2D morphPositionTex;\n		#endif\n	#endif\n#endif\n#ifdef defined(BATCH)\n	#include "skinBatchVS"\n	mat4 getModelMatrix() {\n		return getBoneMatrix(vertex_boneIndices);\n	}\n#elif defined(SKIN)\n	#include "skinVS"\n	mat4 getModelMatrix() {\n		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n	}\n#elif defined(INSTANCING)\n	#include "transformInstancingVS"\n#else\n	mat4 getModelMatrix() {\n		return matrix_model;\n	}\n#endif\nvec3 getLocalPosition(vec3 vertexPosition) {\n	vec3 localPos = vertexPosition;\n	#ifdef MORPHING_POSITION\n		ivec2 morphUV = getTextureMorphCoords();\n		#ifdef MORPHING_INT\n			vec3 morphPos = vec3(texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz) / 65535.0 * aabbSize + aabbMin;\n		#else\n			vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;\n		#endif\n		localPos += morphPos;\n	#endif\n	return localPos;\n}\n';

var transformInstancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\nmat4 getModelMatrix() {\n	return matrix_model * mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n}\n";

var transmissionPS = "\n#ifdef MAPFLOAT\nuniform float material_refraction;\n#endif\nvoid getRefraction() {\n	float refraction = 1.0;\n	#ifdef MAPFLOAT\n	refraction = material_refraction;\n	#endif\n	#ifdef MAPTEXTURE\n	refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n	#endif\n	#ifdef MAPVERTEX\n	refraction *= saturate(vVertexColor.$VC);\n	#endif\n	dTransmission = refraction;\n}\n";

var twoSidedLightingPS = "\nuniform float twoSidedLightingNegScaleFactor;\nvoid handleTwoSidedLighting() {\n	dTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;\n}\n";

var uv0VS = "\n#ifdef NINESLICED\nvec2 getUv0() {\n	vec2 uv = vertex_position.xz;\n	vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n	vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n	uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n	uv = uv * -0.5 + 0.5;\n	uv = uv * atlasRect.zw + atlasRect.xy;\n	vMask = vertex_texCoord0.xy;\n	return uv;\n}\n#else\nvec2 getUv0() {\n	return vertex_texCoord0;\n}\n#endif\n";

var uv1VS = "\nvec2 getUv1() {\n	return vertex_texCoord1;\n}\n";

var uvTransformPS = "\nvUV{TRANSFORM_UV_{i}}_{TRANSFORM_ID_{i}} = vec2(\n	dot(vec3(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}0),\n	dot(vec3(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}1)\n);\n";

var uvTransformUniformsPS = "\n	uniform vec3 {TRANSFORM_NAME_{i}}0;\n	uniform vec3 {TRANSFORM_NAME_{i}}1;\n";

var viewDirPS = "\nvoid getViewDir() {\n	dViewDirW = normalize(view_position - vPositionW);\n}\n";

var shaderChunks = {
		alphaTestPS,
		ambientPS,
		aoPS,
		aoDetailMapPS,
		aoDiffuseOccPS,
		aoSpecOccPS,
		basePS,
		baseNineSlicedPS,
		baseNineSlicedTiledPS,
		bayerPS,
		blurVSMPS,
		clearCoatPS,
		clearCoatGlossPS,
		clearCoatNormalPS,
		clusteredLightCookiesPS,
		clusteredLightShadowsPS,
		clusteredLightUtilsPS,
		clusteredLightPS,
		combinePS,
		cookiePS,
		cubeMapProjectPS,
		cubeMapRotatePS,
		debugOutputPS,
		debugProcessFrontendPS,
		detailModesPS,
		diffusePS,
		diffuseDetailMapPS,
		decodePS: decodePS$1,
		emissivePS,
		encodePS: encodePS$1,
		endPS,
		envAtlasPS: envAtlasPS$1,
		envProcPS: envProcPS$1,
		falloffInvSquaredPS,
		falloffLinearPS,
		floatAsUintPS,
		fogPS: fogPS$1,
		fresnelSchlickPS,
		fullscreenQuadPS,
		fullscreenQuadVS,
		gammaPS: gammaPS$1,
		gles3PS,
		gles3VS,
		glossPS,
		gsplatCenterVS,
		gsplatCornerVS,
		gsplatColorVS,
		gsplatCommonVS,
		gsplatCompressedDataVS,
		gsplatCompressedSHVS,
		gsplatDataVS,
		gsplatOutputVS,
		gsplatPS,
		gsplatSHVS,
		gsplatSourceVS,
		gsplatVS,
		immediateLinePS: immediateLinePS$1,
		immediateLineVS: immediateLineVS$1,
		iridescenceDiffractionPS,
		iridescencePS,
		iridescenceThicknessPS,
		iorPS,
		lightBufferDefinesPS: '',
		lightDeclarationPS,
		lightDiffuseLambertPS,
		lightDirPointPS,
		lightEvaluationPS,
		lightFunctionLightPS,
		lightFunctionShadowPS,
		lightingPS,
		lightmapAddPS,
		lightmapDirPS,
		lightmapSinglePS,
		lightSpecularAnisoGGXPS,
		lightSpecularBlinnPS,
		lightSheenPS,
		linearizeDepthPS,
		litForwardBackendPS,
		litForwardDeclarationPS,
		litForwardMainPS,
		litForwardPostCodePS,
		litForwardPreCodePS,
		litMainVS,
		litOtherMainPS,
		litShaderArgsPS,
		litShadowMainPS,
		ltcPS,
		metalnessPS,
		metalnessModulatePS,
		morphEvaluationPS: morphEvaluationPS$1,
		morphDeclarationPS: morphDeclarationPS$1,
		morphPS: morphPS$1,
		morphVS: morphVS$1,
		msdfPS,
		msdfVS,
		normalVS,
		normalCoreVS,
		normalDetailMapPS,
		normalMapPS,
		normalXYPS,
		normalXYZPS,
		opacityPS,
		opacityDitherPS,
		outputPS,
		outputAlphaPS,
		outputTex2DPS,
		sheenPS,
		sheenGlossPS,
		parallaxPS,
		particlePS,
		particleVS,
		particleAnimFrameClampVS,
		particleAnimFrameLoopVS,
		particleAnimTexVS,
		particleInputFloatPS,
		particleInputRgba8PS,
		particleOutputFloatPS,
		particleOutputRgba8PS,
		particleUpdaterAABBPS,
		particleUpdaterEndPS,
		particleUpdaterInitPS,
		particleUpdaterNoRespawnPS,
		particleUpdaterOnStopPS,
		particleUpdaterRespawnPS,
		particleUpdaterSpherePS,
		particleUpdaterStartPS,
		particle_billboardVS,
		particle_blendAddPS,
		particle_blendMultiplyPS,
		particle_blendNormalPS,
		particle_cpuVS,
		particle_cpu_endVS,
		particle_customFaceVS,
		particle_endPS,
		particle_endVS,
		particle_halflambertPS,
		particle_initVS,
		particle_lambertPS,
		particle_lightingPS,
		particle_localShiftVS,
		particle_meshVS,
		particle_normalVS,
		particle_normalMapPS,
		particle_pointAlongVS,
		particle_softPS,
		particle_softVS,
		particle_stretchVS,
		particle_TBNVS,
		particle_wrapVS,
		pickPS,
		reflDirPS,
		reflDirAnisoPS,
		reflectionCCPS,
		reflectionCubePS,
		reflectionEnvHQPS,
		reflectionEnvPS,
		reflectionSpherePS,
		reflectionSheenPS,
		refractionCubePS,
		refractionDynamicPS,
		reprojectPS: reprojectPS$1,
		reprojectVS: reprojectVS$1,
		sampleCatmullRomPS,
		screenDepthPS,
		shadowCascadesPS,
		shadowEVSMPS,
		shadowPCF1PS,
		shadowPCF3PS,
		shadowPCF5PS,
		shadowPCSSPS,
		shadowSoftPS,
		skinBatchVS,
		skinVS,
		skyboxPS: skyboxPS$1,
		skyboxVS: skyboxVS$1,
		specularPS,
		sphericalPS: sphericalPS$1,
		specularityFactorPS,
		spotPS,
		startNineSlicedPS,
		startNineSlicedTiledPS,
		tangentBinormalVS,
		TBNPS,
		thicknessPS,
		tonemappingPS: tonemappingPS$1,
		tonemappingAcesPS: tonemappingAcesPS$1,
		tonemappingAces2PS: tonemappingAces2PS$1,
		tonemappingFilmicPS: tonemappingFilmicPS$1,
		tonemappingHejlPS: tonemappingHejlPS$1,
		tonemappingLinearPS: tonemappingLinearPS$1,
		tonemappingNeutralPS: tonemappingNeutralPS$1,
		tonemappingNonePS: tonemappingNonePS$1,
		transformVS,
		transformCoreVS,
		transformInstancingVS,
		transmissionPS,
		twoSidedLightingPS,
		uv0VS,
		uv1VS,
		uvTransformPS,
		uvTransformUniformsPS,
		viewDirPS,
		webgpuPS,
		webgpuVS
};

var programLibraryDeviceCache = new DeviceCache();
function getProgramLibrary(device) {
		var library = programLibraryDeviceCache.get(device);
		return library;
}
function setProgramLibrary(device, library) {
		programLibraryDeviceCache.get(device, ()=>{
				return library;
		});
}

class ShaderGenerator {
		static definesHash(defines) {
				var sortedArray = Array.from(defines).sort((a, b)=>a[0] > b[0] ? 1 : -1);
				return hashCode(JSON.stringify(sortedArray));
		}
}

var shaderPassDeviceCache = new DeviceCache();
class ShaderPassInfo {
		buildShaderDefines() {
				var keyword;
				if (this.isShadow) {
						keyword = 'SHADOW';
				} else if (this.isForward) {
						keyword = 'FORWARD';
				} else if (this.index === SHADER_DEPTH) {
						keyword = 'DEPTH';
				} else if (this.index === SHADER_PICK) {
						keyword = 'PICK';
				}
				this.defines.set("" + keyword + "_PASS", '');
				this.defines.set("" + this.name.toUpperCase() + "_PASS", '');
		}
		constructor(name, index, options = {}){
				this.defines = new Map();
				this.name = name;
				this.index = index;
				Object.assign(this, options);
				this.buildShaderDefines();
		}
}
class ShaderPass {
		static get(device) {
				return shaderPassDeviceCache.get(device, ()=>{
						return new ShaderPass();
				});
		}
		allocate(name, options) {
				var info = this.passesNamed.get(name);
				if (info === undefined) {
						info = new ShaderPassInfo(name, this.nextIndex, options);
						this.passesNamed.set(info.name, info);
						this.passesIndexed[info.index] = info;
						this.nextIndex++;
				}
				return info;
		}
		getByIndex(index) {
				var info = this.passesIndexed[index];
				return info;
		}
		getByName(name) {
				return this.passesNamed.get(name);
		}
		constructor(){
				this.passesNamed = new Map();
				this.passesIndexed = [];
				this.nextIndex = 0;
				var add = (name, index, options)=>{
						this.allocate(name, options);
				};
				add('forward', SHADER_FORWARD, {
						isForward: true
				});
				add('prepass');
				add('depth');
				add('pick');
				add('shadow');
		}
}

function _extends$i() {
		_extends$i = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$i.apply(this, arguments);
}
function createShader(device, vsName, fsName, useTransformFeedback, shaderDefinitionOptions) {
		if (useTransformFeedback === void 0) useTransformFeedback = false;
		if (shaderDefinitionOptions === void 0) shaderDefinitionOptions = {};
		if (typeof useTransformFeedback === 'boolean') {
				shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
		} else if (typeof useTransformFeedback === 'object') {
				shaderDefinitionOptions = _extends$i({}, shaderDefinitionOptions, useTransformFeedback);
		}
		return new Shader(device, ShaderUtils.createDefinition(device, _extends$i({}, shaderDefinitionOptions, {
				name: vsName + "_" + fsName,
				vertexCode: shaderChunks[vsName],
				fragmentCode: shaderChunks[fsName]
		})));
}
function createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback, shaderDefinitionOptions) {
		if (useTransformFeedback === void 0) useTransformFeedback = false;
		if (shaderDefinitionOptions === void 0) shaderDefinitionOptions = {};
		if (typeof useTransformFeedback === 'boolean') {
				shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
		} else if (typeof useTransformFeedback === 'object') {
				shaderDefinitionOptions = _extends$i({}, shaderDefinitionOptions, useTransformFeedback);
		}
		var programLibrary = getProgramLibrary(device);
		var shader = programLibrary.getCachedShader(uniqueName);
		if (!shader) {
				shader = new Shader(device, ShaderUtils.createDefinition(device, _extends$i({}, shaderDefinitionOptions, {
						name: uniqueName,
						vertexCode: vsCode,
						fragmentCode: fsCode,
						attributes: attributes
				})));
				programLibrary.setCachedShader(uniqueName, shader);
		}
		return shader;
}
class ShaderGeneratorPassThrough extends ShaderGenerator {
		generateKey(options) {
				return this.key;
		}
		createShaderDefinition(device, options) {
				return this.shaderDefinition;
		}
		constructor(key, shaderDefinition){
				super();
				this.key = key;
				this.shaderDefinition = shaderDefinition;
		}
}
function processShader(shader, processingOptions) {
		var shaderDefinition = shader.definition;
		var _shaderDefinition_name;
		var name = (_shaderDefinition_name = shaderDefinition.name) != null ? _shaderDefinition_name : 'shader';
		var key = name + "-id-" + shader.id;
		var materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);
		var libraryModuleName = 'shader';
		var library = getProgramLibrary(shader.device);
		library.register(libraryModuleName, materialGenerator);
		var variant = library.getProgram(libraryModuleName, {}, processingOptions);
		library.unregister(libraryModuleName);
		return variant;
}
var getCoreDefines = (material, params)=>{
		var defines = new Map(material.defines);
		params.cameraShaderParams.defines.forEach((value, key)=>defines.set(key, value));
		var shaderPassInfo = ShaderPass.get(params.device).getByIndex(params.pass);
		shaderPassInfo.defines.forEach((value, key)=>defines.set(key, value));
		return defines;
};

var _quadPrimitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
};
var _tempViewport = new Vec4();
var _tempScissor = new Vec4();
var _dynamicBindGroup$1 = new DynamicBindGroup();
class QuadRender {
		destroy() {
				var _this_uniformBuffer, _this_bindGroup;
				(_this_uniformBuffer = this.uniformBuffer) == null ? void 0 : _this_uniformBuffer.destroy();
				this.uniformBuffer = null;
				(_this_bindGroup = this.bindGroup) == null ? void 0 : _this_bindGroup.destroy();
				this.bindGroup = null;
		}
		render(viewport, scissor) {
				var device = this.shader.device;
				if (viewport) {
						_tempViewport.set(device.vx, device.vy, device.vw, device.vh);
						_tempScissor.set(device.sx, device.sy, device.sw, device.sh);
						scissor = scissor != null ? scissor : viewport;
						device.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
						device.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);
				}
				device.setVertexBuffer(device.quadVertexBuffer, 0);
				var shader = this.shader;
				device.setShader(shader);
				if (device.supportsUniformBuffers) {
						device.setBindGroup(BINDGROUP_VIEW, device.emptyBindGroup);
						var bindGroup = this.bindGroup;
						bindGroup.update();
						device.setBindGroup(BINDGROUP_MESH, bindGroup);
						var uniformBuffer = this.uniformBuffer;
						if (uniformBuffer) {
								uniformBuffer.update(_dynamicBindGroup$1);
								device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup$1.bindGroup, _dynamicBindGroup$1.offsets);
						} else {
								device.setBindGroup(BINDGROUP_MESH_UB, device.emptyBindGroup);
						}
				}
				device.draw(_quadPrimitive);
				if (viewport) {
						device.setViewport(_tempViewport.x, _tempViewport.y, _tempViewport.z, _tempViewport.w);
						device.setScissor(_tempScissor.x, _tempScissor.y, _tempScissor.z, _tempScissor.w);
				}
		}
		constructor(shader){
				var device = shader.device;
				this.shader = shader;
				if (device.supportsUniformBuffers) {
						var processingOptions = new ShaderProcessorOptions();
						this.shader = processShader(shader, processingOptions);
						var ubFormat = this.shader.meshUniformBufferFormat;
						if (ubFormat) {
								this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
						}
						var bindGroupFormat = this.shader.meshBindGroupFormat;
						this.bindGroup = new BindGroup(device, bindGroupFormat);
				}
		}
}

class RenderPassQuad extends RenderPass {
		execute() {
				var { device } = this;
				device.setCullMode(CULLFACE_NONE);
				device.setDepthState(DepthState.NODEPTH);
				device.setStencilState(null, null);
				this.quad.render(this.rect, this.scissorRect);
		}
		constructor(device, quad, rect, scissorRect){
				super(device);
				this.quad = quad;
				this.rect = rect;
				this.scissorRect = scissorRect;
		}
}

var _tempRect = new Vec4();
function drawQuadWithShader(device, target, shader, rect, scissorRect) {
		var quad = new QuadRender(shader);
		if (!rect) {
				rect = _tempRect;
				rect.x = 0;
				rect.y = 0;
				rect.z = target ? target.width : device.width;
				rect.w = target ? target.height : device.height;
		}
		var renderPass = new RenderPassQuad(device, quad, rect, scissorRect);
		renderPass.init(target);
		renderPass.colorOps.clear = false;
		renderPass.depthStencilOps.clearDepth = false;
		if (device.isWebGPU && target === null && device.samples > 1) {
				renderPass.colorOps.store = true;
		}
		renderPass.render();
		quad.destroy();
}

class Batch {
		destroy(scene, layers) {
				if (this.meshInstance) {
						this.removeFromLayers(scene, layers);
						this.meshInstance.destroy();
						this.meshInstance = null;
				}
		}
		addToLayers(scene, layers) {
				for(var i = 0; i < layers.length; i++){
						var layer = scene.layers.getLayerById(layers[i]);
						if (layer) {
								layer.addMeshInstances([
										this.meshInstance
								]);
						}
				}
		}
		removeFromLayers(scene, layers) {
				for(var i = 0; i < layers.length; i++){
						var layer = scene.layers.getLayerById(layers[i]);
						if (layer) {
								layer.removeMeshInstances([
										this.meshInstance
								]);
						}
				}
		}
		updateBoundingBox() {
				this._aabb.copy(this.origMeshInstances[0].aabb);
				for(var i = 1; i < this.origMeshInstances.length; i++){
						this._aabb.add(this.origMeshInstances[i].aabb);
				}
				this.meshInstance.aabb = this._aabb;
				this.meshInstance._aabbVer = 0;
		}
		get model() {
				return undefined;
		}
		constructor(meshInstances, dynamic, batchGroupId){
				this._aabb = new BoundingBox();
				this.meshInstance = null;
				this.origMeshInstances = meshInstances;
				this.dynamic = dynamic;
				this.batchGroupId = batchGroupId;
		}
}

class BatchGroup {
		constructor(id, name, dynamic, maxAabbSize, layers = [
				LAYERID_WORLD
		]){
				this._ui = false;
				this._sprite = false;
				this._obj = {
						model: [],
						element: [],
						sprite: [],
						render: []
				};
				this.id = id;
				this.name = name;
				this.dynamic = dynamic;
				this.maxAabbSize = maxAabbSize;
				this.layers = layers;
		}
}
BatchGroup.MODEL = 'model';
BatchGroup.ELEMENT = 'element';
BatchGroup.SPRITE = 'sprite';
BatchGroup.RENDER = 'render';

var _invMatrix = new Mat4();
class SkinInstance {
		set rootBone(rootBone) {
				this._rootBone = rootBone;
		}
		get rootBone() {
				return this._rootBone;
		}
		init(device, numBones) {
				var numPixels = numBones * 3;
				var width = Math.ceil(Math.sqrt(numPixels));
				width = math.roundUp(width, 3);
				var height = Math.ceil(numPixels / width);
				this.boneTexture = new Texture(device, {
						width: width,
						height: height,
						format: PIXELFORMAT_RGBA32F,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						name: 'skin'
				});
				this.boneTextureSize = [
						width,
						height,
						1.0 / width,
						1.0 / height
				];
				this.matrixPalette = this.boneTexture.lock({
						mode: TEXTURELOCK_READ
				});
				this.boneTexture.unlock();
		}
		destroy() {
				if (this.boneTexture) {
						this.boneTexture.destroy();
						this.boneTexture = null;
				}
		}
		resolve(rootBone, entity) {
				this.rootBone = rootBone;
				var skin = this.skin;
				var bones = [];
				for(var j = 0; j < skin.boneNames.length; j++){
						var boneName = skin.boneNames[j];
						var bone = rootBone.findByName(boneName);
						if (!bone) {
								bone = entity;
						}
						bones.push(bone);
				}
				this.bones = bones;
		}
		initSkin(skin) {
				this.skin = skin;
				this.bones = [];
				var numBones = skin.inverseBindPose.length;
				this.init(skin.device, numBones);
				this.matrices = [];
				for(var i = 0; i < numBones; i++){
						this.matrices[i] = new Mat4();
				}
		}
		uploadBones(device) {
				this.boneTexture.upload();
		}
		_updateMatrices(rootNode, skinUpdateIndex) {
				if (this._skinUpdateIndex !== skinUpdateIndex) {
						this._skinUpdateIndex = skinUpdateIndex;
						_invMatrix.copy(rootNode.getWorldTransform()).invert();
						for(var i = this.bones.length - 1; i >= 0; i--){
								this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
								this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
						}
				}
		}
		updateMatrices(rootNode, skinUpdateIndex) {
				if (this._updateBeforeCull) {
						this._updateMatrices(rootNode, skinUpdateIndex);
				}
		}
		updateMatrixPalette(rootNode, skinUpdateIndex) {
				this._updateMatrices(rootNode, skinUpdateIndex);
				var mp = this.matrixPalette;
				var count = this.bones.length;
				for(var i = 0; i < count; i++){
						var pe = this.matrices[i].data;
						var base = i * 12;
						mp[base] = pe[0];
						mp[base + 1] = pe[4];
						mp[base + 2] = pe[8];
						mp[base + 3] = pe[12];
						mp[base + 4] = pe[1];
						mp[base + 5] = pe[5];
						mp[base + 6] = pe[9];
						mp[base + 7] = pe[13];
						mp[base + 8] = pe[2];
						mp[base + 9] = pe[6];
						mp[base + 10] = pe[10];
						mp[base + 11] = pe[14];
				}
				this.uploadBones(this.skin.device);
		}
		constructor(skin){
				this._dirty = true;
				this._rootBone = null;
				this._skinUpdateIndex = -1;
				this._updateBeforeCull = true;
				if (skin) {
						this.initSkin(skin);
				}
		}
}

class SkinBatchInstance extends SkinInstance {
		updateMatrices(rootNode, skinUpdateIndex) {}
		updateMatrixPalette(rootNode, skinUpdateIndex) {
				var mp = this.matrixPalette;
				var count = this.bones.length;
				for(var i = 0; i < count; i++){
						var pe = this.bones[i].getWorldTransform().data;
						var base = i * 12;
						mp[base] = pe[0];
						mp[base + 1] = pe[4];
						mp[base + 2] = pe[8];
						mp[base + 3] = pe[12];
						mp[base + 4] = pe[1];
						mp[base + 5] = pe[5];
						mp[base + 6] = pe[9];
						mp[base + 7] = pe[13];
						mp[base + 8] = pe[2];
						mp[base + 9] = pe[6];
						mp[base + 10] = pe[10];
						mp[base + 11] = pe[14];
				}
				this.uploadBones(this.device);
		}
		constructor(device, nodes, rootNode){
				super();
				var numBones = nodes.length;
				this.init(device, numBones);
				this.device = device;
				this.rootNode = rootNode;
				this.bones = nodes;
		}
}

var id$3 = 0;
class GeometryData {
		initDefaults() {
				this.recreate = false;
				this.verticesUsage = BUFFER_STATIC;
				this.indicesUsage = BUFFER_STATIC;
				this.maxVertices = 0;
				this.maxIndices = 0;
				this.vertexCount = 0;
				this.indexCount = 0;
				this.vertexStreamsUpdated = false;
				this.indexStreamUpdated = false;
				this.vertexStreamDictionary = {};
				this.indices = null;
		}
		_changeVertexCount(count, semantic) {
				if (!this.vertexCount) {
						this.vertexCount = count;
				}
		}
		constructor(){
				this.initDefaults();
		}
}
GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
GeometryData.DEFAULT_COMPONENTS_UV = 2;
GeometryData.DEFAULT_COMPONENTS_COLORS = 4;
class GeometryVertexStream {
		constructor(data, componentCount, dataType, dataTypeNormalize, asInt){
				this.data = data;
				this.componentCount = componentCount;
				this.dataType = dataType;
				this.dataTypeNormalize = dataTypeNormalize;
				this.asInt = asInt;
		}
}
class Mesh extends RefCountedObject {
		static fromGeometry(graphicsDevice, geometry, options) {
				if (options === void 0) options = {};
				var mesh = new Mesh(graphicsDevice, options);
				var { positions, normals, tangents, colors, uvs, uvs1, blendIndices, blendWeights, indices } = geometry;
				if (positions) {
						mesh.setPositions(positions);
				}
				if (normals) {
						mesh.setNormals(normals);
				}
				if (tangents) {
						mesh.setVertexStream(SEMANTIC_TANGENT, tangents, 4);
				}
				if (colors) {
						mesh.setColors32(colors);
				}
				if (uvs) {
						mesh.setUvs(0, uvs);
				}
				if (uvs1) {
						mesh.setUvs(1, uvs1);
				}
				if (blendIndices) {
						mesh.setVertexStream(SEMANTIC_BLENDINDICES, blendIndices, 4, blendIndices.length / 4, TYPE_UINT8);
				}
				if (blendWeights) {
						mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, blendWeights, 4);
				}
				if (indices) {
						mesh.setIndices(indices);
				}
				mesh.update();
				return mesh;
		}
		set morph(morph) {
				if (morph !== this._morph) {
						if (this._morph) {
								this._morph.decRefCount();
						}
						this._morph = morph;
						if (morph) {
								morph.incRefCount();
						}
				}
		}
		get morph() {
				return this._morph;
		}
		set aabb(aabb) {
				this._aabb = aabb;
				this._aabbVer++;
		}
		get aabb() {
				return this._aabb;
		}
		destroy() {
				var morph = this.morph;
				if (morph) {
						this.morph = null;
						if (morph.refCount < 1) {
								morph.destroy();
						}
				}
				if (this.vertexBuffer) {
						this.vertexBuffer.destroy();
						this.vertexBuffer = null;
				}
				for(var j = 0; j < this.indexBuffer.length; j++){
						this._destroyIndexBuffer(j);
				}
				this.indexBuffer.length = 0;
				this._geometryData = null;
		}
		_destroyIndexBuffer(index) {
				if (this.indexBuffer[index]) {
						this.indexBuffer[index].destroy();
						this.indexBuffer[index] = null;
				}
		}
		_initBoneAabbs(morphTargets) {
				this.boneAabb = [];
				this.boneUsed = [];
				var x, y, z;
				var bMax, bMin;
				var boneMin = [];
				var boneMax = [];
				var boneUsed = this.boneUsed;
				var numBones = this.skin.boneNames.length;
				var maxMorphX, maxMorphY, maxMorphZ;
				for(var i = 0; i < numBones; i++){
						boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
						boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
				}
				var iterator = new VertexIterator(this.vertexBuffer);
				var posElement = iterator.element[SEMANTIC_POSITION];
				var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
				var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
				var numVerts = this.vertexBuffer.numVertices;
				for(var j = 0; j < numVerts; j++){
						for(var k = 0; k < 4; k++){
								var boneWeight = weightsElement.array[weightsElement.index + k];
								if (boneWeight > 0) {
										var boneIndex = indicesElement.array[indicesElement.index + k];
										boneUsed[boneIndex] = true;
										x = posElement.array[posElement.index];
										y = posElement.array[posElement.index + 1];
										z = posElement.array[posElement.index + 2];
										bMax = boneMax[boneIndex];
										bMin = boneMin[boneIndex];
										if (bMin.x > x) bMin.x = x;
										if (bMin.y > y) bMin.y = y;
										if (bMin.z > z) bMin.z = z;
										if (bMax.x < x) bMax.x = x;
										if (bMax.y < y) bMax.y = y;
										if (bMax.z < z) bMax.z = z;
										if (morphTargets) {
												var minMorphX = maxMorphX = x;
												var minMorphY = maxMorphY = y;
												var minMorphZ = maxMorphZ = z;
												for(var l = 0; l < morphTargets.length; l++){
														var target = morphTargets[l];
														var dx = target.deltaPositions[j * 3];
														var dy = target.deltaPositions[j * 3 + 1];
														var dz = target.deltaPositions[j * 3 + 2];
														if (dx < 0) {
																minMorphX += dx;
														} else {
																maxMorphX += dx;
														}
														if (dy < 0) {
																minMorphY += dy;
														} else {
																maxMorphY += dy;
														}
														if (dz < 0) {
																minMorphZ += dz;
														} else {
																maxMorphZ += dz;
														}
												}
												if (bMin.x > minMorphX) bMin.x = minMorphX;
												if (bMin.y > minMorphY) bMin.y = minMorphY;
												if (bMin.z > minMorphZ) bMin.z = minMorphZ;
												if (bMax.x < maxMorphX) bMax.x = maxMorphX;
												if (bMax.y < maxMorphY) bMax.y = maxMorphY;
												if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
										}
								}
						}
						iterator.next();
				}
				var positionElement = this.vertexBuffer.getFormat().elements.find((e)=>e.name === SEMANTIC_POSITION);
				if (positionElement && positionElement.normalize) {
						var func = (()=>{
								switch(positionElement.dataType){
										case TYPE_INT8:
												return (x)=>Math.max(x / 127.0, -1);
										case TYPE_UINT8:
												return (x)=>x / 255.0;
										case TYPE_INT16:
												return (x)=>Math.max(x / 32767.0, -1);
										case TYPE_UINT16:
												return (x)=>x / 65535.0;
										default:
												return (x)=>x;
								}
						})();
						for(var i1 = 0; i1 < numBones; i1++){
								if (boneUsed[i1]) {
										var min = boneMin[i1];
										var max = boneMax[i1];
										min.set(func(min.x), func(min.y), func(min.z));
										max.set(func(max.x), func(max.y), func(max.z));
								}
						}
				}
				for(var i2 = 0; i2 < numBones; i2++){
						var aabb = new BoundingBox();
						aabb.setMinMax(boneMin[i2], boneMax[i2]);
						this.boneAabb.push(aabb);
				}
		}
		_initGeometryData() {
				if (!this._geometryData) {
						this._geometryData = new GeometryData();
						if (this.vertexBuffer) {
								this._geometryData.vertexCount = this.vertexBuffer.numVertices;
								this._geometryData.maxVertices = this.vertexBuffer.numVertices;
						}
						if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
								this._geometryData.indexCount = this.indexBuffer[0].numIndices;
								this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
						}
				}
		}
		clear(verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
				if (maxVertices === void 0) maxVertices = 0;
				if (maxIndices === void 0) maxIndices = 0;
				this._initGeometryData();
				this._geometryData.initDefaults();
				this._geometryData.recreate = true;
				this._geometryData.maxVertices = maxVertices;
				this._geometryData.maxIndices = maxIndices;
				this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
				this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		}
		setVertexStream(semantic, data, componentCount, numVertices, dataType, dataTypeNormalize, asInt) {
				if (dataType === void 0) dataType = TYPE_FLOAT32;
				if (dataTypeNormalize === void 0) dataTypeNormalize = false;
				if (asInt === void 0) asInt = false;
				this._initGeometryData();
				var vertexCount = numVertices || data.length / componentCount;
				this._geometryData._changeVertexCount(vertexCount, semantic);
				this._geometryData.vertexStreamsUpdated = true;
				this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize, asInt);
		}
		getVertexStream(semantic, data) {
				var count = 0;
				var done = false;
				if (this._geometryData) {
						var stream = this._geometryData.vertexStreamDictionary[semantic];
						if (stream) {
								done = true;
								count = this._geometryData.vertexCount;
								if (ArrayBuffer.isView(data)) {
										data.set(stream.data);
								} else {
										data.length = 0;
										data.push(stream.data);
								}
						}
				}
				if (!done) {
						if (this.vertexBuffer) {
								var iterator = new VertexIterator(this.vertexBuffer);
								count = iterator.readData(semantic, data);
						}
				}
				return count;
		}
		setPositions(positions, componentCount, numVertices) {
				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION;
				this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
		}
		setNormals(normals, componentCount, numVertices) {
				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL;
				this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
		}
		setUvs(channel, uvs, componentCount, numVertices) {
				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_UV;
				this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
		}
		setColors(colors, componentCount, numVertices) {
				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS;
				this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
		}
		setColors32(colors, numVertices) {
				this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
		}
		setIndices(indices, numIndices) {
				this._initGeometryData();
				this._geometryData.indexStreamUpdated = true;
				this._geometryData.indices = indices;
				this._geometryData.indexCount = numIndices || indices.length;
		}
		getPositions(positions) {
				return this.getVertexStream(SEMANTIC_POSITION, positions);
		}
		getNormals(normals) {
				return this.getVertexStream(SEMANTIC_NORMAL, normals);
		}
		getUvs(channel, uvs) {
				return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
		}
		getColors(colors) {
				return this.getVertexStream(SEMANTIC_COLOR, colors);
		}
		getIndices(indices) {
				var count = 0;
				if (this._geometryData && this._geometryData.indices) {
						var streamIndices = this._geometryData.indices;
						count = this._geometryData.indexCount;
						if (ArrayBuffer.isView(indices)) {
								indices.set(streamIndices);
						} else {
								indices.length = 0;
								for(var i = 0, il = streamIndices.length; i < il; i++){
										indices.push(streamIndices[i]);
								}
						}
				} else {
						if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
								var indexBuffer = this.indexBuffer[0];
								count = indexBuffer.readData(indices);
						}
				}
				return count;
		}
		update(primitiveType, updateBoundingBox) {
				if (primitiveType === void 0) primitiveType = PRIMITIVE_TRIANGLES;
				if (updateBoundingBox === void 0) updateBoundingBox = true;
				if (this._geometryData) {
						if (updateBoundingBox) {
								var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
								if (stream) {
										if (stream.componentCount === 3) {
												this._aabb.compute(stream.data, this._geometryData.vertexCount);
												this._aabbVer++;
										}
								}
						}
						var destroyVB = this._geometryData.recreate;
						if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
								destroyVB = true;
								this._geometryData.maxVertices = this._geometryData.vertexCount;
						}
						if (destroyVB) {
								if (this.vertexBuffer) {
										this.vertexBuffer.destroy();
										this.vertexBuffer = null;
								}
						}
						var destroyIB = this._geometryData.recreate;
						if (this._geometryData.indexCount > this._geometryData.maxIndices) {
								destroyIB = true;
								this._geometryData.maxIndices = this._geometryData.indexCount;
						}
						if (destroyIB) {
								if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
										this.indexBuffer[0].destroy();
										this.indexBuffer[0] = null;
								}
						}
						if (this._geometryData.vertexStreamsUpdated) {
								this._updateVertexBuffer();
						}
						if (this._geometryData.indexStreamUpdated) {
								this._updateIndexBuffer();
						}
						this.primitive[0].type = primitiveType;
						if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
								if (this._geometryData.indexStreamUpdated) {
										this.primitive[0].count = this._geometryData.indexCount;
										this.primitive[0].indexed = true;
								}
						} else {
								if (this._geometryData.vertexStreamsUpdated) {
										this.primitive[0].count = this._geometryData.vertexCount;
										this.primitive[0].indexed = false;
								}
						}
						this._geometryData.vertexCount = 0;
						this._geometryData.indexCount = 0;
						this._geometryData.vertexStreamsUpdated = false;
						this._geometryData.indexStreamUpdated = false;
						this._geometryData.recreate = false;
						this.updateRenderStates();
				}
		}
		_buildVertexFormat(vertexCount) {
				var vertexDesc = [];
				for(var semantic in this._geometryData.vertexStreamDictionary){
						var stream = this._geometryData.vertexStreamDictionary[semantic];
						vertexDesc.push({
								semantic: semantic,
								components: stream.componentCount,
								type: stream.dataType,
								normalize: stream.dataTypeNormalize,
								asInt: stream.asInt
						});
				}
				return new VertexFormat(this.device, vertexDesc, vertexCount);
		}
		_updateVertexBuffer() {
				if (!this.vertexBuffer) {
						var allocateVertexCount = this._geometryData.maxVertices;
						var format = this._buildVertexFormat(allocateVertexCount);
						this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, {
								usage: this._geometryData.verticesUsage,
								storage: this._storageVertex
						});
				}
				var iterator = new VertexIterator(this.vertexBuffer);
				var numVertices = this._geometryData.vertexCount;
				for(var semantic in this._geometryData.vertexStreamDictionary){
						var stream = this._geometryData.vertexStreamDictionary[semantic];
						iterator.writeData(semantic, stream.data, numVertices);
						delete this._geometryData.vertexStreamDictionary[semantic];
				}
				iterator.end();
		}
		_updateIndexBuffer() {
				if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
						var maxVertices = this._geometryData.maxVertices;
						var createFormat = maxVertices > 0xffff || maxVertices === 0 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
						var options = this._storageIndex ? {
								storage: true
						} : undefined;
						this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage, undefined, options);
				}
				var srcIndices = this._geometryData.indices;
				if (srcIndices) {
						var indexBuffer = this.indexBuffer[0];
						indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
						this._geometryData.indices = null;
				}
		}
		prepareRenderState(renderStyle) {
				if (renderStyle === RENDERSTYLE_WIREFRAME) {
						this.generateWireframe();
				} else if (renderStyle === RENDERSTYLE_POINTS) {
						this.primitive[RENDERSTYLE_POINTS] = {
								type: PRIMITIVE_POINTS,
								base: 0,
								count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
								indexed: false
						};
				}
		}
		updateRenderStates() {
				if (this.primitive[RENDERSTYLE_POINTS]) {
						this.prepareRenderState(RENDERSTYLE_POINTS);
				}
				if (this.primitive[RENDERSTYLE_WIREFRAME]) {
						this.prepareRenderState(RENDERSTYLE_WIREFRAME);
				}
		}
		generateWireframe() {
				this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);
				var numVertices = this.vertexBuffer.numVertices;
				var lines = [];
				var format;
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
						var offsets = [
								[
										0,
										1
								],
								[
										1,
										2
								],
								[
										2,
										0
								]
						];
						var base = this.primitive[RENDERSTYLE_SOLID].base;
						var count = this.primitive[RENDERSTYLE_SOLID].count;
						var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
						var srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
						var seen = new Set();
						for(var j = base; j < base + count; j += 3){
								for(var k = 0; k < 3; k++){
										var i1 = srcIndices[j + offsets[k][0]];
										var i2 = srcIndices[j + offsets[k][1]];
										var hash = i1 > i2 ? i2 * numVertices + i1 : i1 * numVertices + i2;
										if (!seen.has(hash)) {
												seen.add(hash);
												lines.push(i1, i2);
										}
								}
						}
						format = indexBuffer.format;
				} else {
						for(var i = 0; i < numVertices; i += 3){
								lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
						}
						format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
				}
				var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
				var dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
				dstIndices.set(lines);
				wireBuffer.unlock();
				this.primitive[RENDERSTYLE_WIREFRAME] = {
						type: PRIMITIVE_LINES,
						base: 0,
						count: lines.length,
						indexed: true
				};
				this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
		}
		constructor(graphicsDevice, options){
				super(), this.indexBuffer = [
						null
				], this.vertexBuffer = null, this.primitive = [
						{
								type: 0,
								base: 0,
								count: 0
						}
				], this.skin = null, this.boneAabb = null, this._aabbVer = 0, this._aabb = new BoundingBox(), this._geometryData = null, this._morph = null, this._storageIndex = false, this._storageVertex = false;
				this.id = id$3++;
				this.device = graphicsDevice;
				this._storageIndex = (options == null ? void 0 : options.storageIndex) || false;
				this._storageVertex = (options == null ? void 0 : options.storageVertex) || false;
		}
}

var defaultMaterialDeviceCache = new DeviceCache();
function getDefaultMaterial(device) {
		var material = defaultMaterialDeviceCache.get(device);
		return material;
}
function setDefaultMaterial(device, material) {
		defaultMaterialDeviceCache.get(device, ()=>{
				return material;
		});
}

class RefCountedCache {
		destroy() {
				this.cache.forEach((refCount, object)=>{
						object.destroy();
				});
				this.cache.clear();
		}
		incRef(object) {
				var refCount = (this.cache.get(object) || 0) + 1;
				this.cache.set(object, refCount);
		}
		decRef(object) {
				if (object) {
						var refCount = this.cache.get(object);
						if (refCount) {
								refCount--;
								if (refCount === 0) {
										this.cache.delete(object);
										object.destroy();
								} else {
										this.cache.set(object, refCount);
								}
						}
				}
		}
		constructor(){
				this.cache = new Map();
		}
}

class LightmapCache {
		static incRef(texture) {
				this.cache.incRef(texture);
		}
		static decRef(texture) {
				this.cache.decRef(texture);
		}
		static destroy() {
				this.cache.destroy();
		}
}
LightmapCache.cache = new RefCountedCache();

var id$2 = 0;
var _tmpAabb = new BoundingBox();
var _tempBoneAabb = new BoundingBox();
var _tempSphere = new BoundingSphere();
var _meshSet = new Set();
var lookupHashes = new Uint32Array(4);
class InstancingData {
		destroy() {
				if (this._destroyVertexBuffer) {
						var _this_vertexBuffer;
						(_this_vertexBuffer = this.vertexBuffer) == null ? void 0 : _this_vertexBuffer.destroy();
				}
				this.vertexBuffer = null;
		}
		constructor(numObjects){
				this.vertexBuffer = null;
				this._destroyVertexBuffer = false;
				this.count = numObjects;
		}
}
class ShaderInstance {
		getBindGroup(device) {
				if (!this.bindGroup) {
						var shader = this.shader;
						var bindGroupFormat = shader.meshBindGroupFormat;
						this.bindGroup = new BindGroup(device, bindGroupFormat);
				}
				return this.bindGroup;
		}
		getUniformBuffer(device) {
				if (!this.uniformBuffer) {
						var shader = this.shader;
						var ubFormat = shader.meshUniformBufferFormat;
						this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
				}
				return this.uniformBuffer;
		}
		destroy() {
				var _this_bindGroup, _this_uniformBuffer;
				(_this_bindGroup = this.bindGroup) == null ? void 0 : _this_bindGroup.destroy();
				this.bindGroup = null;
				(_this_uniformBuffer = this.uniformBuffer) == null ? void 0 : _this_uniformBuffer.destroy();
				this.uniformBuffer = null;
		}
		constructor(){
				this.bindGroup = null;
				this.uniformBuffer = null;
		}
}
class MeshInstance {
		set drawBucket(bucket) {
				this._drawBucket = Math.floor(bucket) & 0xff;
				this.updateKey();
		}
		get drawBucket() {
				return this._drawBucket;
		}
		set renderStyle(renderStyle) {
				this._renderStyle = renderStyle;
				this.mesh.prepareRenderState(renderStyle);
		}
		get renderStyle() {
				return this._renderStyle;
		}
		set mesh(mesh) {
				if (mesh === this._mesh) {
						return;
				}
				if (this._mesh) {
						this._mesh.decRefCount();
				}
				this._mesh = mesh;
				if (mesh) {
						mesh.incRefCount();
				}
		}
		get mesh() {
				return this._mesh;
		}
		set aabb(aabb) {
				this._aabb = aabb;
		}
		get aabb() {
				if (!this._updateAabb) {
						return this._aabb;
				}
				if (this._updateAabbFunc) {
						return this._updateAabbFunc(this._aabb);
				}
				var localAabb = this._customAabb;
				var toWorldSpace = !!localAabb;
				if (!localAabb) {
						localAabb = _tmpAabb;
						if (this.skinInstance) {
								if (!this.mesh.boneAabb) {
										var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
										this.mesh._initBoneAabbs(morphTargets);
								}
								var boneUsed = this.mesh.boneUsed;
								var first = true;
								for(var i = 0; i < this.mesh.boneAabb.length; i++){
										if (boneUsed[i]) {
												_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
												if (first) {
														first = false;
														localAabb.center.copy(_tempBoneAabb.center);
														localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
												} else {
														localAabb.add(_tempBoneAabb);
												}
										}
								}
								toWorldSpace = true;
						} else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {
								if (this.mesh) {
										localAabb.center.copy(this.mesh.aabb.center);
										localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
								} else {
										localAabb.center.set(0, 0, 0);
										localAabb.halfExtents.set(0, 0, 0);
								}
								if (this.mesh && this.mesh.morph) {
										var morphAabb = this.mesh.morph.aabb;
										localAabb._expand(morphAabb.getMin(), morphAabb.getMax());
								}
								toWorldSpace = true;
								this._aabbVer = this.node._aabbVer;
								this._aabbMeshVer = this.mesh._aabbVer;
						}
				}
				if (toWorldSpace) {
						this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
				}
				return this._aabb;
		}
		clearShaders() {
				this._shaderCache.forEach((shaderInstance)=>{
						shaderInstance.destroy();
				});
				this._shaderCache.clear();
		}
		getShaderInstance(shaderPass, lightHash, scene, cameraShaderParams, viewUniformFormat, viewBindGroupFormat, sortedLights) {
				var shaderDefs = this._shaderDefs;
				lookupHashes[0] = shaderPass;
				lookupHashes[1] = lightHash;
				lookupHashes[2] = shaderDefs;
				lookupHashes[3] = cameraShaderParams.hash;
				var hash = hash32Fnv1a(lookupHashes);
				var shaderInstance = this._shaderCache.get(hash);
				if (!shaderInstance) {
						var mat = this._material;
						shaderInstance = new ShaderInstance();
						shaderInstance.shader = mat.variants.get(hash);
						shaderInstance.hashes = new Uint32Array(lookupHashes);
						if (!shaderInstance.shader) {
								var _this_mesh_vertexBuffer;
								var shader = mat.getShaderVariant({
										device: this.mesh.device,
										scene: scene,
										objDefs: shaderDefs,
										cameraShaderParams: cameraShaderParams,
										pass: shaderPass,
										sortedLights: sortedLights,
										viewUniformFormat: viewUniformFormat,
										viewBindGroupFormat: viewBindGroupFormat,
										vertexFormat: (_this_mesh_vertexBuffer = this.mesh.vertexBuffer) == null ? void 0 : _this_mesh_vertexBuffer.format
								});
								mat.variants.set(hash, shader);
								shaderInstance.shader = shader;
						}
						this._shaderCache.set(hash, shaderInstance);
				}
				return shaderInstance;
		}
		set material(material) {
				this.clearShaders();
				var prevMat = this._material;
				if (prevMat) {
						prevMat.removeMeshInstanceRef(this);
				}
				this._material = material;
				if (material) {
						material.addMeshInstanceRef(this);
						this.transparent = material.transparent;
						this.updateKey();
				}
		}
		get material() {
				return this._material;
		}
		_updateShaderDefs(shaderDefs) {
				if (shaderDefs !== this._shaderDefs) {
						this._shaderDefs = shaderDefs;
						this.clearShaders();
				}
		}
		set calculateSortDistance(calculateSortDistance) {
				this._calculateSortDistance = calculateSortDistance;
		}
		get calculateSortDistance() {
				return this._calculateSortDistance;
		}
		set receiveShadow(val) {
				if (this._receiveShadow !== val) {
						this._receiveShadow = val;
						this._updateShaderDefs(val ? this._shaderDefs & -2 : this._shaderDefs | SHADERDEF_NOSHADOW);
				}
		}
		get receiveShadow() {
				return this._receiveShadow;
		}
		set batching(val) {
				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_BATCH : this._shaderDefs & -16385);
		}
		get batching() {
				return (this._shaderDefs & SHADERDEF_BATCH) !== 0;
		}
		set skinInstance(val) {
				this._skinInstance = val;
				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & -3);
				this._setupSkinUpdate();
		}
		get skinInstance() {
				return this._skinInstance;
		}
		set morphInstance(val) {
				var _this__morphInstance;
				(_this__morphInstance = this._morphInstance) == null ? void 0 : _this__morphInstance.destroy();
				this._morphInstance = val;
				var shaderDefs = this._shaderDefs;
				shaderDefs = val && val.morph.morphPositions ? shaderDefs | SHADERDEF_MORPH_POSITION : shaderDefs & -1025;
				shaderDefs = val && val.morph.morphNormals ? shaderDefs | SHADERDEF_MORPH_NORMAL : shaderDefs & -2049;
				shaderDefs = val && val.morph.intRenderFormat ? shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED_INT : shaderDefs & -8193;
				this._updateShaderDefs(shaderDefs);
		}
		get morphInstance() {
				return this._morphInstance;
		}
		set screenSpace(val) {
				if (this._screenSpace !== val) {
						this._screenSpace = val;
						this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & -257);
				}
		}
		get screenSpace() {
				return this._screenSpace;
		}
		set key(val) {
				this._sortKeyForward = val;
		}
		get key() {
				return this._sortKeyForward;
		}
		set mask(val) {
				var toggles = this._shaderDefs & 0x0000FFFF;
				this._updateShaderDefs(toggles | val << 16);
		}
		get mask() {
				return this._shaderDefs >> 16;
		}
		set instancingCount(value) {
				if (this.instancingData) {
						this.instancingData.count = value;
				}
		}
		get instancingCount() {
				return this.instancingData ? this.instancingData.count : 0;
		}
		destroy() {
				var _this__skinInstance, _this_morphInstance, _this_instancingData;
				var mesh = this.mesh;
				if (mesh) {
						this.mesh = null;
						if (mesh.refCount < 1) {
								mesh.destroy();
						}
				}
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
				(_this__skinInstance = this._skinInstance) == null ? void 0 : _this__skinInstance.destroy();
				this._skinInstance = null;
				(_this_morphInstance = this.morphInstance) == null ? void 0 : _this_morphInstance.destroy();
				this.morphInstance = null;
				this.clearShaders();
				this.material = null;
				(_this_instancingData = this.instancingData) == null ? void 0 : _this_instancingData.destroy();
		}
		static _prepareRenderStyleForArray(meshInstances, renderStyle) {
				if (meshInstances) {
						for(var i = 0; i < meshInstances.length; i++){
								meshInstances[i]._renderStyle = renderStyle;
								var mesh = meshInstances[i].mesh;
								if (!_meshSet.has(mesh)) {
										_meshSet.add(mesh);
										mesh.prepareRenderState(renderStyle);
								}
						}
						_meshSet.clear();
				}
		}
		_isVisible(camera) {
				if (this.visible) {
						if (this.isVisibleFunc) {
								return this.isVisibleFunc(camera);
						}
						_tempSphere.center = this.aabb.center;
						_tempSphere.radius = this._aabb.halfExtents.length();
						return camera.frustum.containsSphere(_tempSphere) > 0;
				}
				return false;
		}
		updateKey() {
				var { material } = this;
				this._sortKeyForward = this._drawBucket << 25 | (material.alphaToCoverage || material.alphaTest ? 0x1000000 : 0) | material.id & 0xffffff;
		}
		setInstancing(vertexBuffer, cull) {
				if (cull === void 0) cull = false;
				if (vertexBuffer) {
						this.instancingData = new InstancingData(vertexBuffer.numVertices);
						this.instancingData.vertexBuffer = vertexBuffer;
						vertexBuffer.format.instancing = true;
						this.cull = cull;
				} else {
						this.instancingData = null;
						this.cull = true;
				}
				this._updateShaderDefs(vertexBuffer ? this._shaderDefs | SHADERDEF_INSTANCING : this._shaderDefs & -33);
		}
		ensureMaterial(device) {
				if (!this.material) {
						this.material = getDefaultMaterial(device);
				}
		}
		clearParameters() {
				this.parameters = {};
		}
		getParameters() {
				return this.parameters;
		}
		getParameter(name) {
				return this.parameters[name];
		}
		setParameter(name, data, passFlags) {
				if (passFlags === void 0) passFlags = 0xFFFFFFFF;
				var param = this.parameters[name];
				if (param) {
						param.data = data;
						param.passFlags = passFlags;
				} else {
						this.parameters[name] = {
								scopeId: null,
								data: data,
								passFlags: passFlags
						};
				}
		}
		setRealtimeLightmap(name, texture) {
				var old = this.getParameter(name);
				if (old === texture) {
						return;
				}
				if (old) {
						LightmapCache.decRef(old.data);
				}
				if (texture) {
						LightmapCache.incRef(texture);
						this.setParameter(name, texture);
				} else {
						this.deleteParameter(name);
				}
		}
		deleteParameter(name) {
				if (this.parameters[name]) {
						delete this.parameters[name];
				}
		}
		setParameters(device, passFlag) {
				var parameters = this.parameters;
				for(var paramName in parameters){
						var parameter = parameters[paramName];
						if (parameter.passFlags & passFlag) {
								if (!parameter.scopeId) {
										parameter.scopeId = device.scope.resolve(paramName);
								}
								parameter.scopeId.setValue(parameter.data);
						}
				}
		}
		setLightmapped(value) {
				if (value) {
						this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & -6;
				} else {
						this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
						this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
						this._shaderDefs &= -4289;
						this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & -7;
				}
		}
		setCustomAabb(aabb) {
				if (aabb) {
						if (this._customAabb) {
								this._customAabb.copy(aabb);
						} else {
								this._customAabb = aabb.clone();
						}
				} else {
						this._customAabb = null;
						this._aabbVer = -1;
				}
				this._setupSkinUpdate();
		}
		_setupSkinUpdate() {
				if (this._skinInstance) {
						this._skinInstance._updateBeforeCull = !this._customAabb;
				}
		}
		constructor(mesh, material, node = null){
				this.castShadow = false;
				this.cull = true;
				this.drawOrder = 0;
				this._drawBucket = 127;
				this.visible = true;
				this.visibleThisFrame = false;
				this.flipFacesFactor = 1;
				this.gsplatInstance = null;
				this.id = id$2++;
				this.isVisibleFunc = null;
				this.instancingData = null;
				this.parameters = {};
				this.pick = true;
				this.stencilFront = null;
				this.stencilBack = null;
				this.transparent = false;
				this._aabb = new BoundingBox();
				this._aabbVer = -1;
				this._aabbMeshVer = -1;
				this._customAabb = null;
				this._updateAabb = true;
				this._updateAabbFunc = null;
				this._sortKeyShadow = 0;
				this._sortKeyForward = 0;
				this._sortKeyDynamic = 0;
				this._layer = LAYER_WORLD;
				this._material = null;
				this._skinInstance = null;
				this._morphInstance = null;
				this._receiveShadow = true;
				this._renderStyle = RENDERSTYLE_SOLID;
				this._screenSpace = false;
				this._shaderCache = new Map();
				this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
				this._calculateSortDistance = null;
				this.node = node;
				this._mesh = mesh;
				mesh.incRefCount();
				this.material = material;
				if (mesh.vertexBuffer) {
						var format = mesh.vertexBuffer.format;
						this._shaderDefs |= format.hasUv0 ? SHADERDEF_UV0 : 0;
						this._shaderDefs |= format.hasUv1 ? SHADERDEF_UV1 : 0;
						this._shaderDefs |= format.hasColor ? SHADERDEF_VCOLOR : 0;
						this._shaderDefs |= format.hasTangents ? SHADERDEF_TANGENTS : 0;
				}
				this.updateKey();
		}
}
MeshInstance.lightmapParamNames = [
		'texture_lightMap',
		'texture_dirLightMap'
];

var _triFanIndices = [
		0,
		1,
		3,
		2,
		3,
		1
];
var _triStripIndices = [
		0,
		1,
		3,
		0,
		3,
		2
];
var mat3 = new Mat3();
function paramsIdentical(a, b) {
		if (a && !b) return false;
		if (!a && b) return false;
		a = a.data;
		b = b.data;
		if (a === b) return true;
		if (a instanceof Float32Array && b instanceof Float32Array) {
				if (a.length !== b.length) return false;
				for(var i = 0; i < a.length; i++){
						if (a[i] !== b[i]) return false;
				}
				return true;
		}
		return false;
}
function equalParamSets(params1, params2) {
		for(var param in params1){
				if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) {
						return false;
				}
		}
		for(var param1 in params2){
				if (params2.hasOwnProperty(param1) && !paramsIdentical(params2[param1], params1[param1])) {
						return false;
				}
		}
		return true;
}
function getScaleSign(mi) {
		return mi.node.worldTransform.scaleSign;
}
class BatchManager {
		destroy() {
				this.device = null;
				this.rootNode = null;
				this.scene = null;
				this._batchGroups = {};
				this._batchList = [];
				this._dirtyGroups = [];
		}
		addGroup(name, dynamic, maxAabbSize, id, layers) {
				if (id === undefined) {
						id = this._batchGroupCounter;
						this._batchGroupCounter++;
				}
				if (this._batchGroups[id]) {
						return undefined;
				}
				var group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
				this._batchGroups[id] = group;
				return group;
		}
		removeGroup(id) {
				if (!this._batchGroups[id]) {
						return;
				}
				var newBatchList = [];
				for(var i = 0; i < this._batchList.length; i++){
						if (this._batchList[i].batchGroupId === id) {
								this.destroyBatch(this._batchList[i]);
						} else {
								newBatchList.push(this._batchList[i]);
						}
				}
				this._batchList = newBatchList;
				this._removeModelsFromBatchGroup(this.rootNode, id);
				delete this._batchGroups[id];
		}
		markGroupDirty(id) {
				if (this._dirtyGroups.indexOf(id) < 0) {
						this._dirtyGroups.push(id);
				}
		}
		getGroupByName(name) {
				var groups = this._batchGroups;
				for(var group in groups){
						if (!groups.hasOwnProperty(group)) continue;
						if (groups[group].name === name) {
								return groups[group];
						}
				}
				return null;
		}
		getBatches(batchGroupId) {
				var results = [];
				var len = this._batchList.length;
				for(var i = 0; i < len; i++){
						var batch = this._batchList[i];
						if (batch.batchGroupId === batchGroupId) {
								results.push(batch);
						}
				}
				return results;
		}
		_removeModelsFromBatchGroup(node, id) {
				if (!node.enabled) return;
				if (node.model && node.model.batchGroupId === id) {
						node.model.batchGroupId = -1;
				}
				if (node.render && node.render.batchGroupId === id) {
						node.render.batchGroupId = -1;
				}
				if (node.element && node.element.batchGroupId === id) {
						node.element.batchGroupId = -1;
				}
				if (node.sprite && node.sprite.batchGroupId === id) {
						node.sprite.batchGroupId = -1;
				}
				for(var i = 0; i < node._children.length; i++){
						this._removeModelsFromBatchGroup(node._children[i], id);
				}
		}
		insert(type, groupId, node) {
				var group = this._batchGroups[groupId];
				if (group) {
						if (group._obj[type].indexOf(node) < 0) {
								group._obj[type].push(node);
								this.markGroupDirty(groupId);
						}
				}
		}
		remove(type, groupId, node) {
				var group = this._batchGroups[groupId];
				if (group) {
						var idx = group._obj[type].indexOf(node);
						if (idx >= 0) {
								group._obj[type].splice(idx, 1);
								this.markGroupDirty(groupId);
						}
				}
		}
		_extractRender(node, arr, group, groupMeshInstances) {
				if (node.render) {
						arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
						node.render.removeFromLayers();
				}
				return arr;
		}
		_extractModel(node, arr, group, groupMeshInstances) {
				if (node.model && node.model.model) {
						arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
						node.model.removeModelFromLayers();
				}
				return arr;
		}
		_extractElement(node, arr, group) {
				if (!node.element) return;
				var valid = false;
				if (node.element._text && node.element._text._model.meshInstances.length > 0) {
						arr.push(node.element._text._model.meshInstances[0]);
						node.element.removeModelFromLayers(node.element._text._model);
						valid = true;
				} else if (node.element._image) {
						arr.push(node.element._image._renderable.meshInstance);
						node.element.removeModelFromLayers(node.element._image._renderable.model);
						if (node.element._image._renderable.unmaskMeshInstance) {
								arr.push(node.element._image._renderable.unmaskMeshInstance);
								if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
										node.element._dirtifyMask();
										node.element._onPrerender();
								}
						}
						valid = true;
				}
				if (valid) {
						group._ui = true;
				}
		}
		_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
				for(var g = 0; g < groupIds.length; g++){
						var id = groupIds[g];
						var group = this._batchGroups[id];
						if (!group) continue;
						var arr = groupMeshInstances[id];
						if (!arr) arr = groupMeshInstances[id] = [];
						for(var m = 0; m < group._obj.model.length; m++){
								arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
						}
						for(var r = 0; r < group._obj.render.length; r++){
								arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
						}
						for(var e = 0; e < group._obj.element.length; e++){
								this._extractElement(group._obj.element[e], arr, group);
						}
						for(var s = 0; s < group._obj.sprite.length; s++){
								var node = group._obj.sprite[s];
								if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
										arr.push(node.sprite._meshInstance);
										node.sprite.removeModelFromLayers();
										group._sprite = true;
										node.sprite._batchGroup = group;
								}
						}
				}
		}
		generate(groupIds) {
				var groupMeshInstances = {};
				if (!groupIds) {
						groupIds = Object.keys(this._batchGroups);
				}
				var newBatchList = [];
				for(var i = 0; i < this._batchList.length; i++){
						if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
								newBatchList.push(this._batchList[i]);
								continue;
						}
						this.destroyBatch(this._batchList[i]);
				}
				this._batchList = newBatchList;
				this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);
				if (groupIds === this._dirtyGroups) {
						this._dirtyGroups.length = 0;
				} else {
						var newDirtyGroups = [];
						for(var i1 = 0; i1 < this._dirtyGroups.length; i1++){
								if (groupIds.indexOf(this._dirtyGroups[i1]) < 0) newDirtyGroups.push(this._dirtyGroups[i1]);
						}
						this._dirtyGroups = newDirtyGroups;
				}
				var group, lists, groupData, batch;
				for(var groupId in groupMeshInstances){
						if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
						group = groupMeshInstances[groupId];
						groupData = this._batchGroups[groupId];
						if (!groupData) {
								continue;
						}
						lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
						for(var i2 = 0; i2 < lists.length; i2++){
								batch = this.create(lists[i2], groupData.dynamic, parseInt(groupId, 10));
								if (batch) {
										batch.addToLayers(this.scene, groupData.layers);
								}
						}
				}
		}
		prepare(meshInstances, dynamic, maxAabbSize, translucent) {
				if (maxAabbSize === void 0) maxAabbSize = Number.POSITIVE_INFINITY;
				if (meshInstances.length === 0) return [];
				var halfMaxAabbSize = maxAabbSize * 0.5;
				var maxInstanceCount = 1024;
				var maxNumVertices = 0xffffffff;
				var aabb = new BoundingBox();
				var testAabb = new BoundingBox();
				var skipTranslucentAabb = null;
				var sf;
				var lists = [];
				var j = 0;
				if (translucent) {
						meshInstances.sort((a, b)=>{
								return a.drawOrder - b.drawOrder;
						});
				}
				var meshInstancesLeftA = meshInstances;
				var meshInstancesLeftB;
				var skipMesh = translucent ? function skipMesh(mi) {
						if (skipTranslucentAabb) {
								skipTranslucentAabb.add(mi.aabb);
						} else {
								skipTranslucentAabb = mi.aabb.clone();
						}
						meshInstancesLeftB.push(mi);
				} : function(mi) {
						meshInstancesLeftB.push(mi);
				};
				while(meshInstancesLeftA.length > 0){
						lists[j] = [
								meshInstancesLeftA[0]
						];
						meshInstancesLeftB = [];
						var material = meshInstancesLeftA[0].material;
						var layer = meshInstancesLeftA[0].layer;
						var defs = meshInstancesLeftA[0]._shaderDefs;
						var params = meshInstancesLeftA[0].parameters;
						var stencil = meshInstancesLeftA[0].stencilFront;
						var vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
						var drawOrder = meshInstancesLeftA[0].drawOrder;
						aabb.copy(meshInstancesLeftA[0].aabb);
						var scaleSign = getScaleSign(meshInstancesLeftA[0]);
						var vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
						var indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
						skipTranslucentAabb = null;
						for(var i = 1; i < meshInstancesLeftA.length; i++){
								var mi = meshInstancesLeftA[i];
								if (dynamic && lists[j].length >= maxInstanceCount) {
										meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
										break;
								}
								if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
										skipMesh(mi);
										continue;
								}
								testAabb.copy(aabb);
								testAabb.add(mi.aabb);
								if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
										skipMesh(mi);
										continue;
								}
								if (stencil) {
										if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
												skipMesh(mi);
												continue;
										}
								}
								if (scaleSign !== getScaleSign(mi)) {
										skipMesh(mi);
										continue;
								}
								if (!equalParamSets(params, mi.parameters)) {
										skipMesh(mi);
										continue;
								}
								if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
										skipMesh(mi);
										continue;
								}
								aabb.add(mi.aabb);
								vertCount += mi.mesh.vertexBuffer.getNumVertices();
								lists[j].push(mi);
						}
						j++;
						meshInstancesLeftA = meshInstancesLeftB;
				}
				return lists;
		}
		collectBatchedMeshData(meshInstances, dynamic) {
				var streams = null;
				var batchNumVerts = 0;
				var batchNumIndices = 0;
				var material = null;
				for(var i = 0; i < meshInstances.length; i++){
						if (meshInstances[i].visible) {
								var mesh = meshInstances[i].mesh;
								var numVerts = mesh.vertexBuffer.numVertices;
								batchNumVerts += numVerts;
								if (mesh.primitive[0].indexed) {
										batchNumIndices += mesh.primitive[0].count;
								} else {
										var primitiveType = mesh.primitive[0].type;
										if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
												if (mesh.primitive[0].count === 4) {
														batchNumIndices += 6;
												}
										}
								}
								if (!streams) {
										material = meshInstances[i].material;
										streams = {};
										var elems = mesh.vertexBuffer.format.elements;
										for(var j = 0; j < elems.length; j++){
												var semantic = elems[j].name;
												streams[semantic] = {
														numComponents: elems[j].numComponents,
														dataType: elems[j].dataType,
														normalize: elems[j].normalize,
														count: 0
												};
										}
										if (dynamic) {
												streams[SEMANTIC_BLENDINDICES] = {
														numComponents: 1,
														dataType: TYPE_FLOAT32,
														normalize: false,
														count: 0
												};
										}
								}
						}
				}
				return {
						streams: streams,
						batchNumVerts: batchNumVerts,
						batchNumIndices: batchNumIndices,
						material: material
				};
		}
		create(meshInstances, dynamic, batchGroupId) {
				if (!this._init) {
						this.vertexFormats = {};
						this._init = true;
				}
				var stream = null;
				var semantic;
				var mesh, numVerts;
				var batch = null;
				var batchData = this.collectBatchedMeshData(meshInstances, dynamic);
				if (batchData.streams) {
						var streams = batchData.streams;
						var material = batchData.material;
						var batchNumVerts = batchData.batchNumVerts;
						var batchNumIndices = batchData.batchNumIndices;
						batch = new Batch(meshInstances, dynamic, batchGroupId);
						this._batchList.push(batch);
						var indexBase, numIndices, indexData;
						var verticesOffset = 0;
						var indexOffset = 0;
						var transform;
						var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
						var indices = new indexArrayType(batchNumIndices);
						for(semantic in streams){
								stream = streams[semantic];
								stream.typeArrayType = typedArrayTypes[stream.dataType];
								stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
								stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
						}
						for(var i = 0; i < meshInstances.length; i++){
								if (!meshInstances[i].visible) {
										continue;
								}
								mesh = meshInstances[i].mesh;
								numVerts = mesh.vertexBuffer.numVertices;
								if (!dynamic) {
										transform = meshInstances[i].node.getWorldTransform();
								}
								for(semantic in streams){
										if (semantic !== SEMANTIC_BLENDINDICES) {
												stream = streams[semantic];
												var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
												var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
												stream.count += totalComponents;
												if (!dynamic && stream.numComponents >= 3) {
														if (semantic === SEMANTIC_POSITION) {
																var m = transform.data;
																var m0 = m[0];
																var m1 = m[1];
																var m2 = m[2];
																var m4 = m[4];
																var m5 = m[5];
																var m6 = m[6];
																var m8 = m[8];
																var m9 = m[9];
																var m10 = m[10];
																var m12 = m[12];
																var m13 = m[13];
																var m14 = m[14];
																var x = void 0, y = void 0, z = void 0;
																for(var j = 0; j < totalComponents; j += stream.numComponents){
																		x = subarray[j];
																		y = subarray[j + 1];
																		z = subarray[j + 2];
																		subarray[j] = x * m0 + y * m4 + z * m8 + m12;
																		subarray[j + 1] = x * m1 + y * m5 + z * m9 + m13;
																		subarray[j + 2] = x * m2 + y * m6 + z * m10 + m14;
																}
														} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
																mat3.invertMat4(transform).transpose();
																var [m01, m11, m21, m3, m41, m51, m61, m7, m81] = mat3.data;
																var x1 = void 0, y1 = void 0, z1 = void 0;
																for(var j1 = 0; j1 < totalComponents; j1 += stream.numComponents){
																		x1 = subarray[j1];
																		y1 = subarray[j1 + 1];
																		z1 = subarray[j1 + 2];
																		subarray[j1] = x1 * m01 + y1 * m3 + z1 * m61;
																		subarray[j1 + 1] = x1 * m11 + y1 * m41 + z1 * m7;
																		subarray[j1 + 2] = x1 * m21 + y1 * m51 + z1 * m81;
																}
														}
												}
										}
								}
								if (dynamic) {
										stream = streams[SEMANTIC_BLENDINDICES];
										for(var j2 = 0; j2 < numVerts; j2++){
												stream.buffer[stream.count++] = i;
										}
								}
								if (mesh.primitive[0].indexed) {
										indexBase = mesh.primitive[0].base;
										numIndices = mesh.primitive[0].count;
										var srcFormat = mesh.indexBuffer[0].getFormat();
										indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
								} else {
										var primitiveType = mesh.primitive[0].type;
										if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
												if (mesh.primitive[0].count === 4) {
														indexBase = 0;
														numIndices = 6;
														indexData = primitiveType === PRIMITIVE_TRIFAN ? _triFanIndices : _triStripIndices;
												} else {
														numIndices = 0;
														continue;
												}
										}
								}
								for(var j3 = 0; j3 < numIndices; j3++){
										indices[j3 + indexOffset] = indexData[indexBase + j3] + verticesOffset;
								}
								indexOffset += numIndices;
								verticesOffset += numVerts;
						}
						mesh = new Mesh(this.device);
						for(semantic in streams){
								stream = streams[semantic];
								mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
						}
						if (indices.length > 0) {
								mesh.setIndices(indices);
						}
						mesh.update(PRIMITIVE_TRIANGLES, false);
						if (dynamic) {
								material = material.clone();
								material.update();
						}
						var meshInstance = new MeshInstance(mesh, material, this.rootNode);
						meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
						meshInstance.parameters = batch.origMeshInstances[0].parameters;
						meshInstance.layer = batch.origMeshInstances[0].layer;
						meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
						meshInstance.batching = true;
						meshInstance.cull = batch.origMeshInstances[0].cull;
						var batchGroup = this._batchGroups[batchGroupId];
						if (batchGroup && batchGroup._ui) {
								meshInstance.cull = false;
						}
						if (dynamic) {
								var nodes = [];
								for(var i1 = 0; i1 < batch.origMeshInstances.length; i1++){
										nodes.push(batch.origMeshInstances[i1].node);
								}
								meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
						}
						meshInstance._updateAabb = false;
						meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
						meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
						meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
						meshInstance.flipFacesFactor = getScaleSign(batch.origMeshInstances[0]);
						meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
						batch.meshInstance = meshInstance;
						batch.updateBoundingBox();
				}
				return batch;
		}
		updateAll() {
				if (this._dirtyGroups.length > 0) {
						this.generate(this._dirtyGroups);
				}
				for(var i = 0; i < this._batchList.length; i++){
						if (!this._batchList[i].dynamic) continue;
						this._batchList[i].updateBoundingBox();
				}
		}
		clone(batch, clonedMeshInstances) {
				var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
				this._batchList.push(batch2);
				var nodes = [];
				for(var i = 0; i < clonedMeshInstances.length; i++){
						nodes.push(clonedMeshInstances[i].node);
				}
				batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
				batch2.meshInstance._updateAabb = false;
				batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
				batch2.meshInstance.cull = clonedMeshInstances[0].cull;
				batch2.meshInstance.layer = clonedMeshInstances[0].layer;
				if (batch.dynamic) {
						batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
				}
				batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
				return batch2;
		}
		destroyBatch(batch) {
				batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
		}
		constructor(device, root, scene){
				this.device = device;
				this.rootNode = root;
				this.scene = scene;
				this._init = false;
				this._batchGroups = {};
				this._batchGroupCounter = 0;
				this._batchList = [];
				this._dirtyGroups = [];
		}
}

var _colorUniformName = 'uSceneColorMap';
class RenderPassColorGrab extends RenderPass {
		destroy() {
				super.destroy();
				this.releaseRenderTarget(this.colorRenderTarget);
		}
		shouldReallocate(targetRT, sourceTexture, sourceFormat) {
				var targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;
				if (targetFormat !== sourceFormat) {
						return true;
				}
				var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
				var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
				return !targetRT || width !== targetRT.width || height !== targetRT.height;
		}
		allocateRenderTarget(renderTarget, sourceRenderTarget, device, format) {
				var texture = new Texture(device, {
						name: _colorUniformName,
						format,
						width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
						height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
						mipmaps: true,
						minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
						magFilter: FILTER_LINEAR,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				if (renderTarget) {
						renderTarget.destroyFrameBuffers();
						renderTarget._colorBuffer = texture;
						renderTarget._colorBuffers = [
								texture
						];
				} else {
						renderTarget = new RenderTarget({
								name: 'ColorGrabRT',
								colorBuffer: texture,
								depth: false,
								stencil: false,
								autoResolve: false
						});
				}
				return renderTarget;
		}
		releaseRenderTarget(rt) {
				if (rt) {
						rt.destroyTextureBuffers();
						rt.destroy();
				}
		}
		frameUpdate() {
				var device = this.device;
				var sourceRt = this.source;
				var _sourceRt_colorBuffer_format;
				var sourceFormat = (_sourceRt_colorBuffer_format = sourceRt == null ? void 0 : sourceRt.colorBuffer.format) != null ? _sourceRt_colorBuffer_format : this.device.backBufferFormat;
				if (this.shouldReallocate(this.colorRenderTarget, sourceRt == null ? void 0 : sourceRt.colorBuffer, sourceFormat)) {
						this.releaseRenderTarget(this.colorRenderTarget);
						this.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, sourceRt, device, sourceFormat);
				}
				var colorBuffer = this.colorRenderTarget.colorBuffer;
				device.scope.resolve(_colorUniformName).setValue(colorBuffer);
		}
		execute() {
				var device = this.device;
				var sourceRt = this.source;
				var colorBuffer = this.colorRenderTarget.colorBuffer;
				if (device.isWebGPU) {
						device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
						device.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);
				} else {
						device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
						device.activeTexture(device.maxCombinedTextures - 1);
						device.bindTexture(colorBuffer);
						device.gl.generateMipmap(colorBuffer.impl._glTarget);
				}
		}
		constructor(...args){
				super(...args), this.colorRenderTarget = null, this.source = null;
		}
}

var _depthUniformName = 'uSceneDepthMap';
class RenderPassDepthGrab extends RenderPass {
		destroy() {
				super.destroy();
				this.releaseRenderTarget(this.depthRenderTarget);
		}
		shouldReallocate(targetRT, sourceTexture) {
				var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
				var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
				return !targetRT || width !== targetRT.width || height !== targetRT.height;
		}
		allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
				var texture = new Texture(device, {
						name: _depthUniformName,
						format,
						width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
						height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				if (renderTarget) {
						renderTarget.destroyFrameBuffers();
						if (isDepth) {
								renderTarget._depthBuffer = texture;
						} else {
								renderTarget._colorBuffer = texture;
								renderTarget._colorBuffers = [
										texture
								];
						}
				} else {
						renderTarget = new RenderTarget({
								name: 'DepthGrabRT',
								colorBuffer: isDepth ? null : texture,
								depthBuffer: isDepth ? texture : null,
								depth: !isDepth,
								stencil: device.supportsStencil,
								autoResolve: false
						});
				}
				return renderTarget;
		}
		releaseRenderTarget(rt) {
				if (rt) {
						rt.destroyTextureBuffers();
						rt.destroy();
				}
		}
		before() {
				var _camera_renderTarget, _camera_renderTarget1;
				var camera = this.camera;
				var device = this.device;
				var _camera_renderTarget2;
				var destinationRt = (_camera_renderTarget2 = camera == null ? void 0 : camera.renderTarget) != null ? _camera_renderTarget2 : device.backBuffer;
				var useDepthBuffer = true;
				var format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;
				if (device.isWebGPU) {
						var numSamples = destinationRt.samples;
						if (numSamples > 1) {
								format = PIXELFORMAT_R32F;
								useDepthBuffer = false;
						}
				}
				var _camera_renderTarget_depthBuffer;
				var sourceTexture = (_camera_renderTarget_depthBuffer = (_camera_renderTarget = camera.renderTarget) == null ? void 0 : _camera_renderTarget.depthBuffer) != null ? _camera_renderTarget_depthBuffer : (_camera_renderTarget1 = camera.renderTarget) == null ? void 0 : _camera_renderTarget1.colorBuffer;
				if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
						this.releaseRenderTarget(this.depthRenderTarget);
						this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
				}
				var colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
				device.scope.resolve(_depthUniformName).setValue(colorBuffer);
		}
		execute() {
				var device = this.device;
				if (device.isWebGL2 && device.renderTarget.samples > 1) {
						var src = device.renderTarget.impl._glFrameBuffer;
						var dest = this.depthRenderTarget;
						device.renderTarget = dest;
						device.updateBegin();
						this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
				} else {
						device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
				}
		}
		constructor(device, camera){
				super(device), this.depthRenderTarget = null, this.camera = null;
				this.camera = camera;
		}
}

class CameraShaderParams {
		get hash() {
				if (this._hash === undefined) {
						var key = this.gammaCorrection + "_" + this.toneMapping + "_" + this.srgbRenderTarget + "_" + this.fog + "_" + this.ssaoEnabled + "_" + this.sceneDepthMapLinear;
						this._hash = hashCode(key);
				}
				return this._hash;
		}
		get defines() {
				var defines = this._defines;
				if (this._definesDirty) {
						this._definesDirty = false;
						defines.clear();
						if (this._sceneDepthMapLinear) defines.set('SCENE_DEPTHMAP_LINEAR', true);
						defines.set('FOG', this._fog.toUpperCase());
						defines.set('TONEMAP', tonemapNames[this._toneMapping]);
						defines.set('GAMMA', gammaNames[this.shaderOutputGamma]);
				}
				return defines;
		}
		markDirty() {
				this._hash = undefined;
				this._definesDirty = true;
		}
		set fog(type) {
				if (this._fog !== type) {
						this._fog = type;
						this.markDirty();
				}
		}
		get fog() {
				return this._fog;
		}
		set ssaoEnabled(value) {
				if (this._ssaoEnabled !== value) {
						this._ssaoEnabled = value;
						this.markDirty();
				}
		}
		get ssaoEnabled() {
				return this._ssaoEnabled;
		}
		set gammaCorrection(value) {
				this._gammaCorrectionAssigned = true;
				if (this._gammaCorrection !== value) {
						this._gammaCorrection = value;
						this.markDirty();
				}
		}
		get gammaCorrection() {
				return this._gammaCorrection;
		}
		set toneMapping(value) {
				if (this._toneMapping !== value) {
						this._toneMapping = value;
						this.markDirty();
				}
		}
		get toneMapping() {
				return this._toneMapping;
		}
		set srgbRenderTarget(value) {
				if (this._srgbRenderTarget !== value) {
						this._srgbRenderTarget = value;
						this.markDirty();
				}
		}
		get srgbRenderTarget() {
				return this._srgbRenderTarget;
		}
		set sceneDepthMapLinear(value) {
				if (this._sceneDepthMapLinear !== value) {
						this._sceneDepthMapLinear = value;
						this.markDirty();
				}
		}
		get sceneDepthMapLinear() {
				return this._sceneDepthMapLinear;
		}
		get shaderOutputGamma() {
				var gammaOutput = this._gammaCorrection === GAMMA_SRGB && !this._srgbRenderTarget;
				return gammaOutput ? GAMMA_SRGB : GAMMA_NONE;
		}
		constructor(){
				this._gammaCorrection = GAMMA_SRGB;
				this._toneMapping = TONEMAP_LINEAR;
				this._srgbRenderTarget = false;
				this._ssaoEnabled = false;
				this._fog = FOG_NONE;
				this._sceneDepthMapLinear = false;
				this._defines = new Map();
				this._definesDirty = true;
		}
}

var _deviceCoord = new Vec3();
var _halfSize = new Vec3();
var _point$1 = new Vec3();
var _invViewProjMat = new Mat4();
var _frustumPoints = [
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3()
];
class Camera {
		destroy() {
				var _this_renderPassColorGrab, _this_renderPassDepthGrab;
				(_this_renderPassColorGrab = this.renderPassColorGrab) == null ? void 0 : _this_renderPassColorGrab.destroy();
				this.renderPassColorGrab = null;
				(_this_renderPassDepthGrab = this.renderPassDepthGrab) == null ? void 0 : _this_renderPassDepthGrab.destroy();
				this.renderPassDepthGrab = null;
				this.renderPasses.length = 0;
		}
		_storeShaderMatrices(viewProjMat, jitterX, jitterY, renderVersion) {
				if (this._shaderMatricesVersion !== renderVersion) {
						this._shaderMatricesVersion = renderVersion;
						var _this__viewProjCurrent;
						this._viewProjPrevious.copy((_this__viewProjCurrent = this._viewProjCurrent) != null ? _this__viewProjCurrent : viewProjMat);
						var _this__viewProjCurrent1;
						(_this__viewProjCurrent1 = this._viewProjCurrent) != null ? _this__viewProjCurrent1 : this._viewProjCurrent = new Mat4();
						this._viewProjCurrent.copy(viewProjMat);
						this._viewProjInverse.invert(viewProjMat);
						this._jitters[2] = this._jitters[0];
						this._jitters[3] = this._jitters[1];
						this._jitters[0] = jitterX;
						this._jitters[1] = jitterY;
				}
		}
		get fullSizeClearRect() {
				var rect = this._scissorRectClear ? this.scissorRect : this._rect;
				return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;
		}
		set aspectRatio(newValue) {
				if (this._aspectRatio !== newValue) {
						this._aspectRatio = newValue;
						this._projMatDirty = true;
				}
		}
		get aspectRatio() {
				var _this_xr;
				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.aspectRatio : this._aspectRatio;
		}
		set aspectRatioMode(newValue) {
				if (this._aspectRatioMode !== newValue) {
						this._aspectRatioMode = newValue;
						this._projMatDirty = true;
				}
		}
		get aspectRatioMode() {
				return this._aspectRatioMode;
		}
		set calculateProjection(newValue) {
				this._calculateProjection = newValue;
				this._projMatDirty = true;
		}
		get calculateProjection() {
				return this._calculateProjection;
		}
		set calculateTransform(newValue) {
				this._calculateTransform = newValue;
		}
		get calculateTransform() {
				return this._calculateTransform;
		}
		set clearColor(newValue) {
				this._clearColor.copy(newValue);
		}
		get clearColor() {
				return this._clearColor;
		}
		set clearColorBuffer(newValue) {
				this._clearColorBuffer = newValue;
		}
		get clearColorBuffer() {
				return this._clearColorBuffer;
		}
		set clearDepth(newValue) {
				this._clearDepth = newValue;
		}
		get clearDepth() {
				return this._clearDepth;
		}
		set clearDepthBuffer(newValue) {
				this._clearDepthBuffer = newValue;
		}
		get clearDepthBuffer() {
				return this._clearDepthBuffer;
		}
		set clearStencil(newValue) {
				this._clearStencil = newValue;
		}
		get clearStencil() {
				return this._clearStencil;
		}
		set clearStencilBuffer(newValue) {
				this._clearStencilBuffer = newValue;
		}
		get clearStencilBuffer() {
				return this._clearStencilBuffer;
		}
		set cullFaces(newValue) {
				this._cullFaces = newValue;
		}
		get cullFaces() {
				return this._cullFaces;
		}
		set farClip(newValue) {
				if (this._farClip !== newValue) {
						this._farClip = newValue;
						this._projMatDirty = true;
				}
		}
		get farClip() {
				var _this_xr;
				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.farClip : this._farClip;
		}
		set flipFaces(newValue) {
				this._flipFaces = newValue;
		}
		get flipFaces() {
				return this._flipFaces;
		}
		set fov(newValue) {
				if (this._fov !== newValue) {
						this._fov = newValue;
						this._projMatDirty = true;
				}
		}
		get fov() {
				var _this_xr;
				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.fov : this._fov;
		}
		set frustumCulling(newValue) {
				this._frustumCulling = newValue;
		}
		get frustumCulling() {
				return this._frustumCulling;
		}
		set horizontalFov(newValue) {
				if (this._horizontalFov !== newValue) {
						this._horizontalFov = newValue;
						this._projMatDirty = true;
				}
		}
		get horizontalFov() {
				var _this_xr;
				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.horizontalFov : this._horizontalFov;
		}
		set layers(newValue) {
				this._layers = newValue.slice(0);
				this._layersSet = new Set(this._layers);
		}
		get layers() {
				return this._layers;
		}
		get layersSet() {
				return this._layersSet;
		}
		set nearClip(newValue) {
				if (this._nearClip !== newValue) {
						this._nearClip = newValue;
						this._projMatDirty = true;
				}
		}
		get nearClip() {
				var _this_xr;
				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.nearClip : this._nearClip;
		}
		set node(newValue) {
				this._node = newValue;
		}
		get node() {
				return this._node;
		}
		set orthoHeight(newValue) {
				if (this._orthoHeight !== newValue) {
						this._orthoHeight = newValue;
						this._projMatDirty = true;
				}
		}
		get orthoHeight() {
				return this._orthoHeight;
		}
		set projection(newValue) {
				if (this._projection !== newValue) {
						this._projection = newValue;
						this._projMatDirty = true;
				}
		}
		get projection() {
				return this._projection;
		}
		get projectionMatrix() {
				this._evaluateProjectionMatrix();
				return this._projMat;
		}
		set rect(newValue) {
				this._rect.copy(newValue);
		}
		get rect() {
				return this._rect;
		}
		set renderTarget(newValue) {
				this._renderTarget = newValue;
		}
		get renderTarget() {
				return this._renderTarget;
		}
		set scissorRect(newValue) {
				this._scissorRect.copy(newValue);
		}
		get scissorRect() {
				return this._scissorRect;
		}
		get viewMatrix() {
				if (this._viewMatDirty) {
						var wtm = this._node.getWorldTransform();
						this._viewMat.copy(wtm).invert();
						this._viewMatDirty = false;
				}
				return this._viewMat;
		}
		set aperture(newValue) {
				this._aperture = newValue;
		}
		get aperture() {
				return this._aperture;
		}
		set sensitivity(newValue) {
				this._sensitivity = newValue;
		}
		get sensitivity() {
				return this._sensitivity;
		}
		set shutter(newValue) {
				this._shutter = newValue;
		}
		get shutter() {
				return this._shutter;
		}
		set xr(newValue) {
				if (this._xr !== newValue) {
						this._xr = newValue;
						this._projMatDirty = true;
				}
		}
		get xr() {
				return this._xr;
		}
		clone() {
				return new Camera().copy(this);
		}
		copy(other) {
				this._aspectRatio = other._aspectRatio;
				this._farClip = other._farClip;
				this._fov = other._fov;
				this._horizontalFov = other._horizontalFov;
				this._nearClip = other._nearClip;
				this._xrProperties.aspectRatio = other._xrProperties.aspectRatio;
				this._xrProperties.farClip = other._xrProperties.farClip;
				this._xrProperties.fov = other._xrProperties.fov;
				this._xrProperties.horizontalFov = other._xrProperties.horizontalFov;
				this._xrProperties.nearClip = other._xrProperties.nearClip;
				this.aspectRatioMode = other.aspectRatioMode;
				this.calculateProjection = other.calculateProjection;
				this.calculateTransform = other.calculateTransform;
				this.clearColor = other.clearColor;
				this.clearColorBuffer = other.clearColorBuffer;
				this.clearDepth = other.clearDepth;
				this.clearDepthBuffer = other.clearDepthBuffer;
				this.clearStencil = other.clearStencil;
				this.clearStencilBuffer = other.clearStencilBuffer;
				this.cullFaces = other.cullFaces;
				this.flipFaces = other.flipFaces;
				this.frustumCulling = other.frustumCulling;
				this.layers = other.layers;
				this.orthoHeight = other.orthoHeight;
				this.projection = other.projection;
				this.rect = other.rect;
				this.renderTarget = other.renderTarget;
				this.scissorRect = other.scissorRect;
				this.aperture = other.aperture;
				this.shutter = other.shutter;
				this.sensitivity = other.sensitivity;
				this.shaderPassInfo = other.shaderPassInfo;
				this.jitter = other.jitter;
				this._projMatDirty = true;
				return this;
		}
		_enableRenderPassColorGrab(device, enable) {
				if (enable) {
						if (!this.renderPassColorGrab) {
								this.renderPassColorGrab = new RenderPassColorGrab(device);
						}
				} else {
						var _this_renderPassColorGrab;
						(_this_renderPassColorGrab = this.renderPassColorGrab) == null ? void 0 : _this_renderPassColorGrab.destroy();
						this.renderPassColorGrab = null;
				}
		}
		_enableRenderPassDepthGrab(device, renderer, enable) {
				if (enable) {
						if (!this.renderPassDepthGrab) {
								this.renderPassDepthGrab = new RenderPassDepthGrab(device, this);
						}
				} else {
						var _this_renderPassDepthGrab;
						(_this_renderPassDepthGrab = this.renderPassDepthGrab) == null ? void 0 : _this_renderPassDepthGrab.destroy();
						this.renderPassDepthGrab = null;
				}
		}
		_updateViewProjMat() {
				if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
						this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);
						this._viewProjMatDirty = false;
				}
		}
		worldToScreen(worldCoord, cw, ch, screenCoord) {
				if (screenCoord === void 0) screenCoord = new Vec3();
				this._updateViewProjMat();
				this._viewProjMat.transformPoint(worldCoord, screenCoord);
				var vpm = this._viewProjMat.data;
				var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
				screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
				screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
				return screenCoord;
		}
		screenToWorld(x, y, z, cw, ch, worldCoord) {
				if (worldCoord === void 0) worldCoord = new Vec3();
				var range = this.farClip - this.nearClip;
				_deviceCoord.set(x / cw, (ch - y) / ch, z / range);
				_deviceCoord.mulScalar(2);
				_deviceCoord.sub(Vec3.ONE);
				if (this._projection === PROJECTION_PERSPECTIVE) {
						Mat4._getPerspectiveHalfSize(_halfSize, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov);
						_halfSize.x *= _deviceCoord.x;
						_halfSize.y *= _deviceCoord.y;
						var invView = this._node.getWorldTransform();
						_halfSize.z = -this.nearClip;
						invView.transformPoint(_halfSize, _point$1);
						var cameraPos = this._node.getPosition();
						worldCoord.sub2(_point$1, cameraPos);
						worldCoord.normalize();
						worldCoord.mulScalar(z);
						worldCoord.add(cameraPos);
				} else {
						this._updateViewProjMat();
						_invViewProjMat.copy(this._viewProjMat).invert();
						_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
				}
				return worldCoord;
		}
		_evaluateProjectionMatrix() {
				if (this._projMatDirty) {
						if (this._projection === PROJECTION_PERSPECTIVE) {
								this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);
								this._projMatSkybox.copy(this._projMat);
						} else {
								var y = this._orthoHeight;
								var x = y * this.aspectRatio;
								this._projMat.setOrtho(-x, x, -y, y, this.nearClip, this.farClip);
								this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);
						}
						this._projMatDirty = false;
				}
		}
		getProjectionMatrixSkybox() {
				this._evaluateProjectionMatrix();
				return this._projMatSkybox;
		}
		getExposure() {
				var ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100.0 / this._sensitivity);
				return 1.0 / (Math.pow(2.0, ev100) * 1.2);
		}
		getScreenSize(sphere) {
				if (this._projection === PROJECTION_PERSPECTIVE) {
						var distance = this._node.getPosition().distance(sphere.center);
						if (distance < sphere.radius) {
								return 1;
						}
						var viewAngle = Math.asin(sphere.radius / distance);
						var sphereViewHeight = Math.tan(viewAngle);
						var screenViewHeight = Math.tan(this.fov / 2 * math.DEG_TO_RAD);
						return Math.min(sphereViewHeight / screenViewHeight, 1);
				}
				return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
		}
		getFrustumCorners(near, far) {
				if (near === void 0) near = this.nearClip;
				if (far === void 0) far = this.farClip;
				var fov = this.fov * Math.PI / 180.0;
				var x, y;
				if (this.projection === PROJECTION_PERSPECTIVE) {
						if (this.horizontalFov) {
								x = near * Math.tan(fov / 2.0);
								y = x / this.aspectRatio;
						} else {
								y = near * Math.tan(fov / 2.0);
								x = y * this.aspectRatio;
						}
				} else {
						y = this._orthoHeight;
						x = y * this.aspectRatio;
				}
				var points = _frustumPoints;
				points[0].x = x;
				points[0].y = -y;
				points[0].z = -near;
				points[1].x = x;
				points[1].y = y;
				points[1].z = -near;
				points[2].x = -x;
				points[2].y = y;
				points[2].z = -near;
				points[3].x = -x;
				points[3].y = -y;
				points[3].z = -near;
				if (this._projection === PROJECTION_PERSPECTIVE) {
						if (this.horizontalFov) {
								x = far * Math.tan(fov / 2.0);
								y = x / this.aspectRatio;
						} else {
								y = far * Math.tan(fov / 2.0);
								x = y * this.aspectRatio;
						}
				}
				points[4].x = x;
				points[4].y = -y;
				points[4].z = -far;
				points[5].x = x;
				points[5].y = y;
				points[5].z = -far;
				points[6].x = -x;
				points[6].y = y;
				points[6].z = -far;
				points[7].x = -x;
				points[7].y = -y;
				points[7].z = -far;
				return points;
		}
		setXrProperties(properties) {
				Object.assign(this._xrProperties, properties);
				this._projMatDirty = true;
		}
		constructor(){
				this.shaderPassInfo = null;
				this.renderPassColorGrab = null;
				this.renderPassDepthGrab = null;
				this.fogParams = null;
				this.shaderParams = new CameraShaderParams();
				this.renderPasses = [];
				this.jitter = 0;
				this._aspectRatio = 16 / 9;
				this._aspectRatioMode = ASPECT_AUTO;
				this._calculateProjection = null;
				this._calculateTransform = null;
				this._clearColor = new Color(0.75, 0.75, 0.75, 1);
				this._clearColorBuffer = true;
				this._clearDepth = 1;
				this._clearDepthBuffer = true;
				this._clearStencil = 0;
				this._clearStencilBuffer = true;
				this._cullFaces = true;
				this._farClip = 1000;
				this._flipFaces = false;
				this._fov = 45;
				this._frustumCulling = true;
				this._horizontalFov = false;
				this._layers = [
						LAYERID_WORLD,
						LAYERID_DEPTH,
						LAYERID_SKYBOX,
						LAYERID_UI,
						LAYERID_IMMEDIATE
				];
				this._layersSet = new Set(this._layers);
				this._nearClip = 0.1;
				this._node = null;
				this._orthoHeight = 10;
				this._projection = PROJECTION_PERSPECTIVE;
				this._rect = new Vec4(0, 0, 1, 1);
				this._renderTarget = null;
				this._scissorRect = new Vec4(0, 0, 1, 1);
				this._scissorRectClear = false;
				this._aperture = 16.0;
				this._shutter = 1.0 / 1000.0;
				this._sensitivity = 1000;
				this._projMat = new Mat4();
				this._projMatDirty = true;
				this._projMatSkybox = new Mat4();
				this._viewMat = new Mat4();
				this._viewMatDirty = true;
				this._viewProjMat = new Mat4();
				this._viewProjMatDirty = true;
				this._shaderMatricesVersion = 0;
				this._viewProjInverse = new Mat4();
				this._viewProjCurrent = null;
				this._viewProjPrevious = new Mat4();
				this._jitters = [
						0,
						0,
						0,
						0
				];
				this.frustum = new Frustum();
				this._xr = null;
				this._xrProperties = {
						horizontalFov: this._horizontalFov,
						fov: this._fov,
						aspectRatio: this._aspectRatio,
						farClip: this._farClip,
						nearClip: this._nearClip
				};
		}
}

function _type_of(obj) {
		"@swc/helpers - typeof";
		return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var scaleCompensatePosTransform = new Mat4();
var scaleCompensatePos = new Vec3();
var scaleCompensateRot = new Quat();
var scaleCompensateRot2 = new Quat();
var scaleCompensateScale = new Vec3();
var scaleCompensateScaleForParent = new Vec3();
var tmpMat4 = new Mat4();
var tmpQuat = new Quat();
var position$1 = new Vec3();
var invParentWtm$1 = new Mat4();
var rotation = new Quat();
var invParentRot = new Quat();
var matrix = new Mat4();
var target = new Vec3();
var up = new Vec3();
function createTest(attr, value) {
		if (attr instanceof Function) {
				return attr;
		}
		return (node)=>{
				var x = node[attr];
				if (x instanceof Function) {
						x = x();
				}
				return x === value;
		};
}
function findNode(node, test) {
		if (test(node)) {
				return node;
		}
		var children = node._children;
		var len = children.length;
		for(var i = 0; i < len; ++i){
				var result = findNode(children[i], test);
				if (result) {
						return result;
				}
		}
		return null;
}
class GraphNode extends EventHandler {
		get right() {
				if (!this._right) {
						this._right = new Vec3();
				}
				return this.getWorldTransform().getX(this._right).normalize();
		}
		get up() {
				if (!this._up) {
						this._up = new Vec3();
				}
				return this.getWorldTransform().getY(this._up).normalize();
		}
		get forward() {
				if (!this._forward) {
						this._forward = new Vec3();
				}
				return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
		}
		get normalMatrix() {
				var normalMat = this._normalMatrix;
				if (this._dirtyNormal) {
						normalMat.invertMat4(this.getWorldTransform()).transpose();
						this._dirtyNormal = false;
				}
				return normalMat;
		}
		set enabled(enabled) {
				if (this._enabled !== enabled) {
						var _this__parent;
						this._enabled = enabled;
						if (enabled && ((_this__parent = this._parent) == null ? void 0 : _this__parent.enabled) || !enabled) {
								this._notifyHierarchyStateChanged(this, enabled);
						}
				}
		}
		get enabled() {
				return this._enabled && this._enabledInHierarchy;
		}
		get parent() {
				return this._parent;
		}
		get path() {
				var node = this._parent;
				if (!node) {
						return '';
				}
				var result = this.name;
				while(node && node._parent){
						result = node.name + "/" + result;
						node = node._parent;
				}
				return result;
		}
		get root() {
				var result = this;
				while(result._parent){
						result = result._parent;
				}
				return result;
		}
		get children() {
				return this._children;
		}
		get graphDepth() {
				return this._graphDepth;
		}
		_notifyHierarchyStateChanged(node, enabled) {
				node._onHierarchyStateChanged(enabled);
				var c = node._children;
				for(var i = 0, len = c.length; i < len; i++){
						if (c[i]._enabled) {
								this._notifyHierarchyStateChanged(c[i], enabled);
						}
				}
		}
		_onHierarchyStateChanged(enabled) {
				this._enabledInHierarchy = enabled;
				if (enabled && !this._frozen) {
						this._unfreezeParentToRoot();
				}
		}
		_cloneInternal(clone) {
				clone.name = this.name;
				var tags = this.tags._list;
				clone.tags.clear();
				for(var i = 0; i < tags.length; i++){
						clone.tags.add(tags[i]);
				}
				clone.localPosition.copy(this.localPosition);
				clone.localRotation.copy(this.localRotation);
				clone.localScale.copy(this.localScale);
				clone.localEulerAngles.copy(this.localEulerAngles);
				clone.position.copy(this.position);
				clone.rotation.copy(this.rotation);
				clone.eulerAngles.copy(this.eulerAngles);
				clone.localTransform.copy(this.localTransform);
				clone._dirtyLocal = this._dirtyLocal;
				clone.worldTransform.copy(this.worldTransform);
				clone._dirtyWorld = this._dirtyWorld;
				clone._dirtyNormal = this._dirtyNormal;
				clone._aabbVer = this._aabbVer + 1;
				clone._enabled = this._enabled;
				clone.scaleCompensation = this.scaleCompensation;
				clone._enabledInHierarchy = false;
		}
		clone() {
				var clone = new this.constructor();
				this._cloneInternal(clone);
				return clone;
		}
		copy(source) {
				source._cloneInternal(this);
				return this;
		}
		destroy() {
				this.remove();
				var children = this._children;
				while(children.length){
						var child = children.pop();
						child._parent = null;
						child.destroy();
				}
				this.fire('destroy', this);
				this.off();
		}
		find(attr, value) {
				var results = [];
				var test = createTest(attr, value);
				this.forEach((node)=>{
						if (test(node)) {
								results.push(node);
						}
				});
				return results;
		}
		findOne(attr, value) {
				var test = createTest(attr, value);
				return findNode(this, test);
		}
		findByTag() {
				var query = arguments;
				var results = [];
				var queryNode = (node, checkNode)=>{
						if (checkNode && node.tags.has(...query)) {
								results.push(node);
						}
						for(var i = 0; i < node._children.length; i++){
								queryNode(node._children[i], true);
						}
				};
				queryNode(this, false);
				return results;
		}
		findByName(name) {
				return this.findOne('name', name);
		}
		findByPath(path) {
				var _loop = function(i, imax) {
						result = result.children.find((c)=>c.name === parts[i]);
						if (!result) {
								return {
										v: null
								};
						}
				};
				var parts = Array.isArray(path) ? path : path.split('/');
				var result = this;
				for(var i = 0, imax = parts.length; i < imax; ++i){
						var _ret = _loop(i);
						if (_type_of(_ret) === "object") return _ret.v;
				}
				return result;
		}
		forEach(callback, thisArg) {
				callback.call(thisArg, this);
				var children = this._children;
				var len = children.length;
				for(var i = 0; i < len; ++i){
						children[i].forEach(callback, thisArg);
				}
		}
		isDescendantOf(node) {
				var parent = this._parent;
				while(parent){
						if (parent === node) {
								return true;
						}
						parent = parent._parent;
				}
				return false;
		}
		isAncestorOf(node) {
				return node.isDescendantOf(this);
		}
		getEulerAngles() {
				this.getWorldTransform().getEulerAngles(this.eulerAngles);
				return this.eulerAngles;
		}
		getLocalEulerAngles() {
				this.localRotation.getEulerAngles(this.localEulerAngles);
				return this.localEulerAngles;
		}
		getLocalPosition() {
				return this.localPosition;
		}
		getLocalRotation() {
				return this.localRotation;
		}
		getLocalScale() {
				return this.localScale;
		}
		getLocalTransform() {
				if (this._dirtyLocal) {
						this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
						this._dirtyLocal = false;
				}
				return this.localTransform;
		}
		getPosition() {
				this.getWorldTransform().getTranslation(this.position);
				return this.position;
		}
		getRotation() {
				this.rotation.setFromMat4(this.getWorldTransform());
				return this.rotation;
		}
		getScale() {
				if (!this._scale) {
						this._scale = new Vec3();
				}
				return this.getWorldTransform().getScale(this._scale);
		}
		getWorldTransform() {
				if (!this._dirtyLocal && !this._dirtyWorld) {
						return this.worldTransform;
				}
				if (this._parent) {
						this._parent.getWorldTransform();
				}
				this._sync();
				return this.worldTransform;
		}
		get worldScaleSign() {
				if (this._worldScaleSign === 0) {
						this._worldScaleSign = this.getWorldTransform().scaleSign;
				}
				return this._worldScaleSign;
		}
		remove() {
				var _this__parent;
				(_this__parent = this._parent) == null ? void 0 : _this__parent.removeChild(this);
		}
		reparent(parent, index) {
				this.remove();
				if (parent) {
						if (index >= 0) {
								parent.insertChild(this, index);
						} else {
								parent.addChild(this);
						}
				}
		}
		setLocalEulerAngles(x, y, z) {
				this.localRotation.setFromEulerAngles(x, y, z);
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		setLocalPosition(x, y, z) {
				if (x instanceof Vec3) {
						this.localPosition.copy(x);
				} else {
						this.localPosition.set(x, y, z);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		setLocalRotation(x, y, z, w) {
				if (x instanceof Quat) {
						this.localRotation.copy(x);
				} else {
						this.localRotation.set(x, y, z, w);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		setLocalScale(x, y, z) {
				if (x instanceof Vec3) {
						this.localScale.copy(x);
				} else {
						this.localScale.set(x, y, z);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		_dirtifyLocal() {
				if (!this._dirtyLocal) {
						this._dirtyLocal = true;
						if (!this._dirtyWorld) {
								this._dirtifyWorld();
						}
				}
		}
		_unfreezeParentToRoot() {
				var p = this._parent;
				while(p){
						p._frozen = false;
						p = p._parent;
				}
		}
		_dirtifyWorld() {
				if (!this._dirtyWorld) {
						this._unfreezeParentToRoot();
				}
				this._dirtifyWorldInternal();
		}
		_dirtifyWorldInternal() {
				if (!this._dirtyWorld) {
						this._frozen = false;
						this._dirtyWorld = true;
						for(var i = 0; i < this._children.length; i++){
								if (!this._children[i]._dirtyWorld) {
										this._children[i]._dirtifyWorldInternal();
								}
						}
				}
				this._dirtyNormal = true;
				this._worldScaleSign = 0;
				this._aabbVer++;
		}
		setPosition(x, y, z) {
				if (x instanceof Vec3) {
						position$1.copy(x);
				} else {
						position$1.set(x, y, z);
				}
				if (this._parent === null) {
						this.localPosition.copy(position$1);
				} else {
						invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
						invParentWtm$1.transformPoint(position$1, this.localPosition);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		setRotation(x, y, z, w) {
				if (x instanceof Quat) {
						rotation.copy(x);
				} else {
						rotation.set(x, y, z, w);
				}
				if (this._parent === null) {
						this.localRotation.copy(rotation);
				} else {
						var parentRot = this._parent.getRotation();
						invParentRot.copy(parentRot).invert();
						this.localRotation.copy(invParentRot).mul(rotation);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		setPositionAndRotation(position, rotation) {
				if (this._parent === null) {
						this.localPosition.copy(position);
						this.localRotation.copy(rotation);
				} else {
						var parentWtm = this._parent.getWorldTransform();
						invParentWtm$1.copy(parentWtm).invert();
						invParentWtm$1.transformPoint(position, this.localPosition);
						this.localRotation.setFromMat4(invParentWtm$1).mul(rotation);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		setEulerAngles(x, y, z) {
				this.localRotation.setFromEulerAngles(x, y, z);
				if (this._parent !== null) {
						var parentRot = this._parent.getRotation();
						invParentRot.copy(parentRot).invert();
						this.localRotation.mul2(invParentRot, this.localRotation);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		addChild(node) {
				this._prepareInsertChild(node);
				this._children.push(node);
				this._onInsertChild(node);
		}
		addChildAndSaveTransform(node) {
				var wPos = node.getPosition();
				var wRot = node.getRotation();
				this._prepareInsertChild(node);
				node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
				node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));
				this._children.push(node);
				this._onInsertChild(node);
		}
		insertChild(node, index) {
				this._prepareInsertChild(node);
				this._children.splice(index, 0, node);
				this._onInsertChild(node);
		}
		_prepareInsertChild(node) {
				node.remove();
		}
		_fireOnHierarchy(name, nameHierarchy, parent) {
				this.fire(name, parent);
				for(var i = 0; i < this._children.length; i++){
						this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
				}
		}
		_onInsertChild(node) {
				node._parent = this;
				var enabledInHierarchy = node._enabled && this.enabled;
				if (node._enabledInHierarchy !== enabledInHierarchy) {
						node._enabledInHierarchy = enabledInHierarchy;
						node._notifyHierarchyStateChanged(node, enabledInHierarchy);
				}
				node._updateGraphDepth();
				node._dirtifyWorld();
				if (this._frozen) {
						node._unfreezeParentToRoot();
				}
				node._fireOnHierarchy('insert', 'inserthierarchy', this);
				if (this.fire) this.fire('childinsert', node);
		}
		_updateGraphDepth() {
				this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
				for(var i = 0, len = this._children.length; i < len; i++){
						this._children[i]._updateGraphDepth();
				}
		}
		removeChild(child) {
				var index = this._children.indexOf(child);
				if (index === -1) {
						return;
				}
				this._children.splice(index, 1);
				child._parent = null;
				child._fireOnHierarchy('remove', 'removehierarchy', this);
				this.fire('childremove', child);
		}
		_sync() {
				if (this._dirtyLocal) {
						this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
						this._dirtyLocal = false;
				}
				if (this._dirtyWorld) {
						if (this._parent === null) {
								this.worldTransform.copy(this.localTransform);
						} else {
								if (this.scaleCompensation) {
										var parentWorldScale;
										var parent = this._parent;
										var scale = this.localScale;
										var parentToUseScaleFrom = parent;
										if (parentToUseScaleFrom) {
												while(parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation){
														parentToUseScaleFrom = parentToUseScaleFrom._parent;
												}
												if (parentToUseScaleFrom) {
														parentToUseScaleFrom = parentToUseScaleFrom._parent;
														if (parentToUseScaleFrom) {
																parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
																scaleCompensateScale.mul2(parentWorldScale, this.localScale);
																scale = scaleCompensateScale;
														}
												}
										}
										scaleCompensateRot2.setFromMat4(parent.worldTransform);
										scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
										var tmatrix = parent.worldTransform;
										if (parent.scaleCompensation) {
												scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
												scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
												tmatrix = scaleCompensatePosTransform;
										}
										tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
										this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
								} else {
										this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
								}
						}
						this._dirtyWorld = false;
				}
		}
		syncHierarchy() {
				if (!this._enabled) {
						return;
				}
				if (this._frozen) {
						return;
				}
				this._frozen = true;
				if (this._dirtyLocal || this._dirtyWorld) {
						this._sync();
				}
				var children = this._children;
				for(var i = 0, len = children.length; i < len; i++){
						children[i].syncHierarchy();
				}
		}
		lookAt(x, y, z, ux, uy, uz) {
				if (ux === void 0) ux = 0;
				if (uy === void 0) uy = 1;
				if (uz === void 0) uz = 0;
				if (x instanceof Vec3) {
						target.copy(x);
						if (y instanceof Vec3) {
								up.copy(y);
						} else {
								up.copy(Vec3.UP);
						}
				} else if (z === undefined) {
						return;
				} else {
						target.set(x, y, z);
						up.set(ux, uy, uz);
				}
				matrix.setLookAt(this.getPosition(), target, up);
				rotation.setFromMat4(matrix);
				this.setRotation(rotation);
		}
		translate(x, y, z) {
				if (x instanceof Vec3) {
						position$1.copy(x);
				} else {
						position$1.set(x, y, z);
				}
				position$1.add(this.getPosition());
				this.setPosition(position$1);
		}
		translateLocal(x, y, z) {
				if (x instanceof Vec3) {
						position$1.copy(x);
				} else {
						position$1.set(x, y, z);
				}
				this.localRotation.transformVector(position$1, position$1);
				this.localPosition.add(position$1);
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		rotate(x, y, z) {
				rotation.setFromEulerAngles(x, y, z);
				if (this._parent === null) {
						this.localRotation.mul2(rotation, this.localRotation);
				} else {
						var rot = this.getRotation();
						var parentRot = this._parent.getRotation();
						invParentRot.copy(parentRot).invert();
						rotation.mul2(invParentRot, rotation);
						this.localRotation.mul2(rotation, rot);
				}
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		rotateLocal(x, y, z) {
				rotation.setFromEulerAngles(x, y, z);
				this.localRotation.mul(rotation);
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		constructor(name = 'Untitled'){
				super(), this.tags = new Tags(this), this.localPosition = new Vec3(), this.localRotation = new Quat(), this.localScale = new Vec3(1, 1, 1), this.localEulerAngles = new Vec3(), this.position = new Vec3(), this.rotation = new Quat(), this.eulerAngles = new Vec3(), this._scale = null, this.localTransform = new Mat4(), this._dirtyLocal = false, this._aabbVer = 0, this._frozen = false, this.worldTransform = new Mat4(), this._dirtyWorld = false, this._worldScaleSign = 0, this._normalMatrix = new Mat3(), this._dirtyNormal = true, this._right = null, this._up = null, this._forward = null, this._parent = null, this._children = [], this._graphDepth = 0, this._enabled = true, this._enabledInHierarchy = false, this.scaleCompensation = false;
				this.name = name;
		}
}

var _viewMat = new Mat4();
var _viewProjMat = new Mat4();
var _viewportMatrix = new Mat4();
class LightCamera {
		static create(name, lightType, face) {
				var camera = new Camera();
				camera.node = new GraphNode(name);
				camera.aspectRatio = 1;
				camera.aspectRatioMode = ASPECT_MANUAL;
				camera._scissorRectClear = true;
				switch(lightType){
						case LIGHTTYPE_OMNI:
								camera.node.setRotation(LightCamera.pointLightRotations[face]);
								camera.fov = 90;
								camera.projection = PROJECTION_PERSPECTIVE;
								break;
						case LIGHTTYPE_SPOT:
								camera.projection = PROJECTION_PERSPECTIVE;
								break;
						case LIGHTTYPE_DIRECTIONAL:
								camera.projection = PROJECTION_ORTHOGRAPHIC;
								break;
				}
				return camera;
		}
		static evalSpotCookieMatrix(light) {
				var cookieCamera = LightCamera._spotCookieCamera;
				if (!cookieCamera) {
						cookieCamera = LightCamera.create('SpotCookieCamera', LIGHTTYPE_SPOT);
						LightCamera._spotCookieCamera = cookieCamera;
				}
				cookieCamera.fov = light._outerConeAngle * 2;
				var cookieNode = cookieCamera._node;
				cookieNode.setPosition(light._node.getPosition());
				cookieNode.setRotation(light._node.getRotation());
				cookieNode.rotateLocal(-90, 0, 0);
				_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();
				_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);
				var cookieMatrix = light.cookieMatrix;
				var rectViewport = light.atlasViewport;
				_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
				cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
				return cookieMatrix;
		}
}
LightCamera.pointLightRotations = [
		new Quat().setFromEulerAngles(0, 90, 180),
		new Quat().setFromEulerAngles(0, -90, 180),
		new Quat().setFromEulerAngles(90, 0, 0),
		new Quat().setFromEulerAngles(-90, 0, 0),
		new Quat().setFromEulerAngles(0, 180, 180),
		new Quat().setFromEulerAngles(0, 0, 180)
];
LightCamera._spotCookieCamera = null;

var decodePS = "\n\n#ifndef _DECODE_INCLUDED_\n#define _DECODE_INCLUDED_\n\nfn decodeLinear(raw: vec4f) -> vec3f {\n    return raw.rgb;\n}\n\nfn decodeGammaFloat(raw: f32) -> f32 {\n    return pow(raw, 2.2);\n}\n\nfn decodeGammaVec3(raw: vec3f) -> vec3f {\n    return pow(raw, vec3f(2.2));\n}\n\nfn decodeGamma(raw: vec4f) -> vec3f {\n    return pow(raw.xyz, vec3f(2.2));\n}\n\nfn decodeRGBM(raw: vec4f) -> vec3f {\n    let color = (8.0 * raw.a) * raw.rgb;\n    return color * color;\n}\n\nfn decodeRGBP(raw: vec4f) -> vec3f {\n    let color = raw.rgb * (-raw.a * 7.0 + 8.0);\n    return color * color;\n}\n\nfn decodeRGBE(raw: vec4f) -> vec3f {\n    return select(vec3f(0.0), raw.xyz * pow(2.0, raw.w * 255.0 - 128.0), raw.a != 0.0);\n}\n\nfn passThrough(raw: vec4f) -> vec4f {\n    return raw;\n}\n\n#endif\n";

var encodePS = "\nfn encodeLinear(source: vec3f) -> vec4f {\n    return vec4f(source, 1.0);\n}\n\nfn encodeGamma(source: vec3f) -> vec4f {\n    return vec4f(pow(source + vec3f(0.0000001), vec3f(1.0 / 2.2)), 1.0);\n}\n\nfn encodeRGBM(source: vec3f) -> vec4f {\n    var color: vec3f = pow(source, vec3f(0.5));\n    color *= 1.0 / 8.0;\n\n    var a: f32 = saturate(max(max(color.r, color.g), max(color.b, 1.0 / 255.0)));\n    a = ceil(a * 255.0) / 255.0;\n\n    color /= a;\n    return vec4f(color, a);\n}\n\nfn encodeRGBP(source: vec3f) -> vec4f {\n    // convert incoming linear to gamma(ish)\n    var gamma: vec3f = pow(source, vec3f(0.5));\n\n    // calculate the maximum component clamped to 1..8\n    var maxVal: f32 = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\n    // calculate storage factor\n    var v: f32 = 1.0 - ((maxVal - 1.0) / 7.0);\n\n    // round the value for storage in 8bit channel\n    v = ceil(v * 255.0) / 255.0;\n\n    return vec4f(gamma / (-v * 7.0 + 8.0), v);\n}\n\nfn encodeRGBE(source: vec3f) -> vec4f {\n    var maxVal: f32 = max(source.x, max(source.y, source.z));\n    if (maxVal < 1e-32) {\n        return vec4f(0.0, 0.0, 0.0, 0.0);\n    } else {\n        var e: f32 = ceil(log2(maxVal));\n        return vec4f(source / pow(2.0, e), (e + 128.0) / 255.0);\n    }\n}\n";

var envAtlasPS = "\n// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.\nconst atlasSize : f32 = 512.0;\nconst seamSize : f32 = 1.0 / atlasSize;\n\n// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).\nfn mapUv(uv : vec2f, rect : vec4f) -> vec2f {\n    return vec2f(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n                 mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\n\n// map a normalized equirect UV and roughness level to the correct atlas rect.\nfn mapRoughnessUv(uv : vec2f, level : f32) -> vec2f {\n    let t : f32 = 1.0 / exp2(level);\n    return mapUv(uv, vec4f(0.0, 1.0 - t, t, t * 0.5));\n}\n\n// map shiny level UV\nfn mapShinyUv(uv : vec2f, level : f32) -> vec2f {\n    let t : f32 = 1.0 / exp2(level);\n    return mapUv(uv, vec4f(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

var envProcPS = "\n#ifdef LIT_SKYBOX_INTENSITY\n    uniform skyboxIntensity : f32;\n#endif\n\nfn processEnvironment(color : vec3f) -> vec3f {\n    #ifdef LIT_SKYBOX_INTENSITY\n        return color * uniform.skyboxIntensity;\n    #else\n        return color;\n    #endif\n}\n";

var fogPS = "\n\n#if (FOG != NONE)\n    uniform fog_color : vec3f;\n    \n    #if (FOG == LINEAR)\n        uniform fog_start : f32;\n        uniform fog_end : f32;\n    #else\n        uniform fog_density : f32;\n    #endif\n#endif\n\nuniform dBlendModeFogFactor : f32;\n\nfn getFogFactor() -> f32 {\n\n    // TODO: find a way to do this in WGSL, for now the fog is not working\n    // let depth = gl_FragCoord.z / gl_FragCoord.w;\n    let depth = 1.0;\n\n    var fogFactor : f32 = 0.0;\n\n    #if (FOG == LINEAR)\n        fogFactor = (uniform.fog_end - depth) / (uniform.fog_end - uniform.fog_start);\n    #elif (FOG == EXP)\n        fogFactor = exp(-depth * uniform.fog_density);\n    #elif (FOG == EXP2)\n        fogFactor = exp(-depth * depth * uniform.fog_density * uniform.fog_density);\n    #endif\n\n    return clamp(fogFactor, 0.0, 1.0);\n}\n\nfn addFog(color : vec3f) -> vec3f {\n    #if (FOG != NONE)\n        return mix(uniform.fog_color * uniform.dBlendModeFogFactor, color, getFogFactor());\n    #else\n        return color;\n    #endif\n}\n";

var gammaPS = '\n\n#include "decodePS"\n\n#if (GAMMA == SRGB)\n\n    fn gammaCorrectInput(color: f32) -> f32 {\n        return decodeGammaFloat(color);\n    }\n\n    fn gammaCorrectInputVec3(color: vec3f) -> vec3f {\n        return decodeGammaVec3(color);\n    }\n\n    fn gammaCorrectInputVec4(color: vec4f) -> vec4f {\n        return vec4f(decodeGammaVec3(color.xyz), color.w);\n    }\n\n    fn gammaCorrectOutput(color: vec3f) -> vec3f {\n        return pow(color + 0.0000001, vec3f(1.0 / 2.2));\n    }\n\n#else // NONE\n\n    fn gammaCorrectInput(color: f32) -> f32 {\n        return color;\n    }\n\n    fn gammaCorrectInputVec3(color: vec3f) -> vec3f {\n        return color;\n    }\n\n    fn gammaCorrectInputVec4(color: vec4f) -> vec4f {\n        return color;\n    }\n\n    fn gammaCorrectOutput(color: vec3f) -> vec3f {\n        return color;\n    }\n\n#endif\n';

var immediateLinePS = '\n    #include "gammaPS"\n    varying color: vec4f;\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n        output.color = vec4f(gammaCorrectOutput(decodeGammaVec3(input.color.rgb)), input.color.a);\n        return output;\n    }\n';

var immediateLineVS = "\n    attribute vertex_position: vec4f;\n    attribute vertex_color: vec4f;\n    uniform matrix_model: mat4x4f;\n    uniform matrix_viewProjection: mat4x4f;\n    varying color: vec4f;\n    @vertex\n    fn vertexMain(input : VertexInput) -> VertexOutput {\n        var output : VertexOutput;\n        output.color = input.vertex_color;\n        output.position = uniform.matrix_viewProjection * uniform.matrix_model * input.vertex_position;\n        return output;\n    }\n";

var morphEvaluationPS = "\n    color += uniform.morphFactor[{i}].element * textureSampleLevel(morphBlendTex{i}, morphBlendTex{i}Sampler, input.uv0, 0).xyz;\n";

var morphDeclarationPS = "\n    var morphBlendTex{i}: texture_2d<f32>;\n    var morphBlendTex{i}Sampler : sampler;\n";

var morphPS = '\n\n    varying uv0: vec2f;\n\n    // LOOP - source morph target textures\n    #include "morphDeclarationPS, MORPH_TEXTURE_COUNT"\n\n    #if MORPH_TEXTURE_COUNT > 0\n        uniform morphFactor: array<f32, {MORPH_TEXTURE_COUNT}>;\n    #endif\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n\n        var color = vec3f(0, 0, 0);\n\n        // LOOP - source morph target textures\n        #include "morphEvaluationPS, MORPH_TEXTURE_COUNT"\n\n        output.color = vec4f(color, 1.0);\n        return output;\n    }\n';

var morphVS = "\n    attribute vertex_position: vec2f;\n    varying uv0: vec2f;\n\n    @vertex\n    fn vertexMain(input: VertexInput) -> VertexOutput {\n        var output: VertexOutput;\n        output.position = vec4f(input.vertex_position, 0.5, 1.0);\n        output.uv0 = input.vertex_position * 0.5 + vec2f(0.5, 0.5);\n        return output;\n    }\n";

var reprojectPS = '\n\nvarying vUv0: vec2f;\n\n#ifdef CUBEMAP_SOURCE\n    var sourceCube: texture_cube<f32>;\n    var sourceCubeSampler : sampler;\n#else\n    var sourceTex: texture_2d<f32>;\n    var sourceTexSampler : sampler;\n#endif\n\n#ifdef USE_SAMPLES_TEX\n    // samples\n    var samplesTex: texture_2d<f32>;\n    var samplesTexSampler : sampler;\n    uniform samplesTexInverseSize: vec2f;\n#endif\n\n// params:\n// x - target cubemap face 0..6\n// y - target image total pixels\n// z - source cubemap size\nuniform params: vec3f;\n\nfn targetFace() -> f32 { return uniform.params.x; }\nfn targetTotalPixels() -> f32 { return uniform.params.y; }\nfn sourceTotalPixels() -> f32 { return uniform.params.z; }\n\nconst PI: f32 = 3.141592653589793;\n\nfn saturate(x: f32) -> f32 {\n    return clamp(x, 0.0, 1.0);\n}\n\n#include "decodePS"\n#include "encodePS"\n\n//-- supported projections\n\nfn modifySeams(dir: vec3f, scale: f32) -> vec3f {\n    let adir = abs(dir);\n    let M = max(max(adir.x, adir.y), adir.z);\n    return dir / M * vec3f(\n        select(scale, 1.0, adir.x == M),\n        select(scale, 1.0, adir.y == M),\n        select(scale, 1.0, adir.z == M)\n    );\n}\n\nfn toSpherical(dir: vec3f) -> vec2f {\n    let nonZeroXZ = any(dir.xz != vec2f(0.0, 0.0));\n    return vec2f(select(0.0, atan2(dir.x, dir.z), nonZeroXZ), asin(dir.y));\n}\n\nfn fromSpherical(uv: vec2f) -> vec3f {\n    return vec3f(cos(uv.y) * sin(uv.x),\n                sin(uv.y),\n                cos(uv.y) * cos(uv.x));\n}\n\nfn getDirectionEquirect(uv: vec2f) -> vec3f {\n    return fromSpherical((vec2f(uv.x, 1.0 - uv.y) * 2.0 - 1.0) * vec2f(PI, PI * 0.5));\n}\n\n// octahedral code, based on https://jcgt.org/published/0003/02/01/\n// "Survey of Efficient Representations for Independent Unit Vectors" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer\n\nfn signNotZero(k: f32) -> f32 {\n    return select(-1.0, 1.0, k >= 0.0);\n}\n\nfn signNotZeroVec2(v: vec2f) -> vec2f {\n    return vec2f(signNotZero(v.x), signNotZero(v.y));\n}\n\n// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square\nfn octDecode(o: vec2f) -> vec3f {\n    var v = vec3f(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n    if (v.y < 0.0) {\n        var temp: vec2f = (1.0 - abs(v.zx)) * signNotZeroVec2(v.xz);\n        v = vec3f(temp.x, v.y, temp.y);\n    }\n    return normalize(v);\n}\n\nfn getDirectionOctahedral(uv: vec2f) -> vec3f {\n    return octDecode(vec2f(uv.x, 1.0 - uv.y) * 2.0 - 1.0);\n}\n\n// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square\nfn octEncode(v: vec3f) -> vec2f {\n    let l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n    var result = v.xz * (1.0 / l1norm);\n    if (v.y < 0.0) {\n        result = (1.0 - abs(result.yx)) * signNotZeroVec2(result.xy);\n    }\n    return result;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#ifdef CUBEMAP_SOURCE\n    fn sampleCubemapDir(dir: vec3f) -> vec4f {\n        return textureSample(sourceCube, sourceCubeSampler, modifySeams(dir, 1.0));\n    }\n\n    fn sampleCubemapSph(sph: vec2f) -> vec4f {\n        return sampleCubemapDir(fromSpherical(sph));\n    }\n\n    fn sampleCubemapDirLod(dir: vec3f, mipLevel: f32) -> vec4f {\n        return textureSampleLevel(sourceCube, sourceCubeSampler, modifySeams(dir, 1.0), mipLevel);\n    }\n\n    fn sampleCubemapSphLod(sph: vec2f, mipLevel: f32) -> vec4f {\n        return sampleCubemapDirLod(fromSpherical(sph), mipLevel);\n    }\n#else\n\n    fn sampleEquirectSph(sph: vec2f) -> vec4f {\n        let uv = sph / vec2f(PI * 2.0, PI) + 0.5;\n        return textureSample(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y));\n    }\n\n    fn sampleEquirectDir(dir: vec3f) -> vec4f {\n        return sampleEquirectSph(toSpherical(dir));\n    }\n\n    fn sampleEquirectSphLod(sph: vec2f, mipLevel: f32) -> vec4f {\n        let uv = sph / vec2f(PI * 2.0, PI) + 0.5;\n        return textureSampleLevel(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y), mipLevel);\n    }\n\n    fn sampleEquirectDirLod(dir: vec3f, mipLevel: f32) -> vec4f {\n        return sampleEquirectSphLod(toSpherical(dir), mipLevel);\n    }\n\n    fn sampleOctahedralDir(dir: vec3f) -> vec4f {\n        let uv = octEncode(dir) * 0.5 + 0.5;\n        return textureSample(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y));\n    }\n\n    fn sampleOctahedralSph(sph: vec2f) -> vec4f {\n        return sampleOctahedralDir(fromSpherical(sph));\n    }\n\n    fn sampleOctahedralDirLod(dir: vec3f, mipLevel: f32) -> vec4f {\n        let uv = octEncode(dir) * 0.5 + 0.5;\n        return textureSampleLevel(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y), mipLevel);\n    }\n\n    fn sampleOctahedralSphLod(sph: vec2f, mipLevel: f32) -> vec4f {\n        return sampleOctahedralDirLod(fromSpherical(sph), mipLevel);\n    }\n\n#endif\n\nfn getDirectionCubemap(uv: vec2f) -> vec3f {\n    let st = uv * 2.0 - 1.0;\n    let face = targetFace();\n\n    var vec: vec3f;\n    if (face == 0.0) {\n        vec = vec3f(1, -st.y, -st.x);\n    } else if (face == 1.0) {\n        vec = vec3f(-1, -st.y, st.x);\n    } else if (face == 2.0) {\n        vec = vec3f(st.x, 1, st.y);\n    } else if (face == 3.0) {\n        vec = vec3f(st.x, -1, -st.y);\n    } else if (face == 4.0) {\n        vec = vec3f(st.x, -st.y, 1);\n    } else {\n        vec = vec3f(-st.x, -st.y, -1);\n    }\n\n    return normalize(modifySeams(vec, 1.0));\n}\n\nfn matrixFromVector(n: vec3f) -> mat3x3f {\n    let a = 1.0 / (1.0 + n.z);\n    let b = -n.x * n.y * a;\n    let b1 = vec3f(1.0 - n.x * n.x * a, b, -n.x);\n    let b2 = vec3f(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3x3f(b1, b2, n);\n}\n\nfn matrixFromVectorSlow(n: vec3f) -> mat3x3f {\n    let up = select(vec3f(0.0, 0.0, select(-1.0, 1.0, n.y > 0.0)), vec3f(0.0, 1.0, 0.0), abs(n.y) > 0.0000001);\n    let x = normalize(cross(up, n));\n    let y = cross(n, x);\n    return mat3x3f(x, y, n);\n}\n\nfn reproject(uv: vec2f) -> vec4f {\n    if ({NUM_SAMPLES} <= 1) {\n        // single sample\n        return {ENCODE_FUNC}({DECODE_FUNC}({SOURCE_FUNC}Dir({TARGET_FUNC}(uv))));\n    } else {\n        // multi sample\n        let t = {TARGET_FUNC}(uv);\n        let tu = dpdx(t);\n        let tv = dpdy(t);\n\n        var result = vec3f(0.0);\n        for (var u = 0.0; u < {NUM_SAMPLES_SQRT}; u += 1.0) {\n            for (var v = 0.0; v < {NUM_SAMPLES_SQRT}; v += 1.0) {\n                result += {DECODE_FUNC}({SOURCE_FUNC}Dir(normalize(t +\n                                                            tu * (u / {NUM_SAMPLES_SQRT} - 0.5) +\n                                                            tv * (v / {NUM_SAMPLES_SQRT} - 0.5))));\n            }\n        }\n        return {ENCODE_FUNC}(result / ({NUM_SAMPLES_SQRT} * {NUM_SAMPLES_SQRT}));\n    }\n}\n\nconst unpackFloat: vec4f = vec4f(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n\n#ifdef USE_SAMPLES_TEX\n    fn unpackSample(i: i32, L: ptr<function, vec3f>, mipLevel: ptr<function, f32>) {\n        var u = (f32(i * 4) + 0.5) * uniform.samplesTexInverseSize.x;\n        var v = (floor(u) + 0.5) * uniform.samplesTexInverseSize.y;\n\n        var raw: vec4f;\n        raw.x = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;\n        raw.y = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;\n        raw.z = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;\n        raw.w = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat);\n\n        *L = raw.xyz * 2.0 - 1.0;\n        *mipLevel = raw.w * 8.0;\n    }\n\n    // convolve an environment given pre-generated samples\n    fn prefilterSamples(uv: vec2f) -> vec4f {\n        // construct vector space given target direction\n        let vecSpace = matrixFromVectorSlow({TARGET_FUNC}(uv));\n\n        var L: vec3f;\n        var mipLevel: f32;\n\n        var result = vec3f(0.0);\n        var totalWeight = 0.0;\n        for (var i = 0; i < {NUM_SAMPLES}; i += 1) {\n            unpackSample(i, &L, &mipLevel);\n            result += {DECODE_FUNC}({SOURCE_FUNC}DirLod(vecSpace * L, mipLevel)) * L.z;\n            totalWeight += L.z;\n        }\n\n        return {ENCODE_FUNC}(result / totalWeight);\n    }\n\n    // unweighted version of prefilterSamples\n    fn prefilterSamplesUnweighted(uv: vec2f) -> vec4f {\n        // construct vector space given target direction\n        let vecSpace = matrixFromVectorSlow({TARGET_FUNC}(uv));\n\n        var L: vec3f;\n        var mipLevel: f32;\n\n        var result = vec3f(0.0);\n        for (var i = 0; i < {NUM_SAMPLES}; i += 1) {\n            unpackSample(i, &L, &mipLevel);\n            result += {DECODE_FUNC}({SOURCE_FUNC}DirLod(vecSpace * L, mipLevel));\n        }\n\n        return {ENCODE_FUNC}(result / f32({NUM_SAMPLES}));\n    }\n#endif\n\n@fragment\nfn fragmentMain(input : FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n    output.color = {PROCESS_FUNC}(input.vUv0);\n    return output;\n}\n';

var reprojectVS = "\nattribute vertex_position: vec2f;\nuniform uvMod: vec4f;\nvarying vUv0: vec2f;\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n  output.position = vec4f(input.vertex_position, 0.5, 1.0);\n  output.vUv0 = getImageEffectUV((input.vertex_position * 0.5 + vec2f(0.5, 0.5)) * uniform.uvMod.xy + uniform.uvMod.zw);\n  return output;\n}\n";

var skyboxPS = '\n    #define LIT_SKYBOX_INTENSITY\n\n    #include "envProcPS"\n    #include "gammaPS"\n    #include "tonemappingPS"\n\n    // Varying and uniform declarations\n    varying vViewDir : vec3f;\n    uniform skyboxHighlightMultiplier : f32;\n\n    #ifdef SKY_CUBEMAP\n\n        var texture_cubeMap : texture_cube<f32>;\n        var texture_cubeMap_sampler : sampler;\n\n        #ifdef SKYMESH\n            varying vWorldPos : vec3f;\n            uniform cubeMapRotationMatrix : mat3x3f;\n            uniform projectedSkydomeCenter : vec3f;\n        #endif\n\n    #else // env-atlas\n\n        #include "sphericalPS"\n        #include "envAtlasPS"\n\n        var texture_envAtlas : texture_2d<f32>;\n        var texture_envAtlas_sampler : sampler;\n\n        uniform mipLevel : f32;\n\n    #endif\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n\n        var linear : vec3f;\n        var dir : vec3f;\n\n        #ifdef SKY_CUBEMAP\n\n            #ifdef SKYMESH\n                // get vector from world space pos to tripod origin\n                var envDir : vec3f = normalize(input.vWorldPos - uniform.projectedSkydomeCenter);\n                dir = envDir * uniform.cubeMapRotationMatrix;\n            #else\n                dir = input.vViewDir;\n            #endif\n\n            dir.x *= -1.0;\n            linear = {SKYBOX_DECODE_FNC}(textureSample(texture_cubeMap, texture_cubeMap_sampler, dir));\n\n        #else // env-atlas\n\n            dir = input.vViewDir * vec3f(-1.0, 1.0, 1.0);\n            let uv : vec2f = toSphericalUv(normalize(dir));\n            linear = {SKYBOX_DECODE_FNC}(textureSample(texture_envAtlas, texture_envAtlas_sampler, mapRoughnessUv(uv, uniform.mipLevel)));\n\n        #endif\n\n        // our HDR encodes values up to 64, so allow extra brightness for the clipped values\n        if (any(linear >= vec3f(64.0))) {\n            linear *= uniform.skyboxHighlightMultiplier;\n        }\n        \n        var output: FragmentOutput;\n        output.color = vec4f(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n        return output;\n    }\n';

var skyboxVS = "\n    // Attribute\n    attribute aPosition : vec4f;\n\n    #ifndef VIEWMATRIX\n    #define VIEWMATRIX\n    uniform matrix_view : mat4x4f;\n    #endif\n\n    uniform matrix_projectionSkybox : mat4x4f;\n    uniform cubeMapRotationMatrix : mat3x3f;\n\n    varying vViewDir : vec3f;\n\n    #ifdef SKYMESH\n        uniform matrix_model : mat4x4f;\n        varying vWorldPos : vec3f;\n    #endif\n\n    @vertex\n    fn vertexMain(input : VertexInput) -> VertexOutput {\n\n        var output : VertexOutput;\n        var view : mat4x4f = uniform.matrix_view;\n\n        #ifdef SKYMESH\n\n            var worldPos : vec4f = uniform.matrix_model * input.aPosition;\n            output.vWorldPos = worldPos.xyz;\n            output.position = uniform.matrix_projectionSkybox * (view * worldPos);\n\n        #else\n\n            view[3][0] = 0.0;\n            view[3][1] = 0.0;\n            view[3][2] = 0.0;\n            output.position = uniform.matrix_projectionSkybox * (view * input.aPosition);\n            output.vViewDir = input.aPosition.xyz * uniform.cubeMapRotationMatrix;\n\n        #endif\n\n        // Force skybox to far Z, regardless of the clip planes on the camera\n        // Subtract a tiny fudge factor to ensure floating point errors don't\n        // still push pixels beyond far Z. See:\n        // https://community.khronos.org/t/skybox-problem/61857\n\n        output.position.z = output.position.w - 1.0e-7;\n\n        return output;\n    }\n";

var sphericalPS = "\n// equirectangular helper functions\nconst PI : f32 = 3.141592653589793;\n\nfn toSpherical(dir: vec3f) -> vec2f {\n    let angle_xz = select(0.0, atan2(dir.x, dir.z), any(dir.xz != vec2f(0.0)));\n    return vec2f(angle_xz, asin(dir.y));\n}\n\nfn toSphericalUv(dir : vec3f) -> vec2f {\n    let uv : vec2f = toSpherical(dir) / vec2f(PI * 2.0, PI) + vec2f(0.5, 0.5);\n    return vec2f(uv.x, 1.0 - uv.y);\n}\n";

var tonemappingPS = '\n#if (TONEMAP == NONE)\n    #include "tonemappingNonePS"\n#elif TONEMAP == FILMIC\n    #include "tonemappingFilmicPS"\n#elif TONEMAP == LINEAR\n    #include "tonemappingLinearPS"\n#elif TONEMAP == HEJL\n    #include "tonemappingHejlPS"\n#elif TONEMAP == ACES\n    #include "tonemappingAcesPS"\n#elif TONEMAP == ACES2\n    #include "tonemappingAces2PS"\n#elif TONEMAP == NEUTRAL\n    #include "tonemappingNeutralPS"\n#endif\n';

var tonemappingAcesPS = "\nuniform exposure: f32;\n\nfn toneMap(color: vec3f) -> vec3f {\n    let tA: f32 = 2.51;\n    let tB: f32 = 0.03;\n    let tC: f32 = 2.43;\n    let tD: f32 = 0.59;\n    let tE: f32 = 0.14;\n    let x: vec3f = color * uniform.exposure;\n    return (x * (tA * x + tB)) / (x * (tC * x + tD) + tE);\n}\n";

var tonemappingAces2PS = "\nuniform exposure: f32;\n\n// ACES approximation by Stephen Hill\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst ACESInputMat: mat3x3f = mat3x3f(\n    vec3f(0.59719, 0.35458, 0.04823),\n    vec3f(0.07600, 0.90834, 0.01566),\n    vec3f(0.02840, 0.13383, 0.83777)\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst ACESOutputMat: mat3x3f = mat3x3f(\n    vec3f( 1.60475, -0.53108, -0.07367),\n    vec3f(-0.10208,  1.10813, -0.00605),\n    vec3f(-0.00327, -0.07276,  1.07602)\n);\n\nfn RRTAndODTFit(v: vec3f) -> vec3f {\n    let a: vec3f = v * (v + vec3f(0.0245786)) - vec3f(0.000090537);\n    let b: vec3f = v * (vec3f(0.983729) * v + vec3f(0.4329510)) + vec3f(0.238081);\n    return a / b;\n}\n\nfn toneMap(color: vec3f) -> vec3f {\n    var c: vec3f = color * (uniform.exposure / 0.6);\n    c = ACESInputMat * c;\n\n    // Apply RRT and ODT\n    c = RRTAndODTFit(c);\n    c = ACESOutputMat * c;\n\n    // Clamp to [0, 1]\n    return clamp(c, vec3f(0.0), vec3f(1.0));\n}\n";

var tonemappingFilmicPS = "\nconst A: f32 = 0.15;\nconst B: f32 = 0.50;\nconst C: f32 = 0.10;\nconst D: f32 = 0.20;\nconst E: f32 = 0.02;\nconst F: f32 = 0.30;\nconst W: f32 = 11.2;\n\nuniform exposure: f32;\n\nfn uncharted2Tonemap(x: vec3f) -> vec3f {\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - vec3f(E / F);\n}\n\nfn toneMap(color: vec3f) -> vec3f {\n    var c: vec3f = uncharted2Tonemap(color * uniform.exposure);\n    let whiteScale: vec3f = vec3f(1.0) / uncharted2Tonemap(vec3f(W, W, W));\n    c *= whiteScale;\n    return c;\n}\n";

var tonemappingHejlPS = "\nuniform exposure: f32;\n\nfn toneMap(color: vec3f) -> vec3f {\n    let A: f32 = 0.22;\n    let B: f32 = 0.3;\n    let C: f32 = 0.1;\n    let D: f32 = 0.2;\n    let E: f32 = 0.01;\n    let F: f32 = 0.3;\n    let Scl: f32 = 1.25;\n\n    let adjusted_color = color * uniform.exposure;\n    let h = max(vec3f(0.0), adjusted_color - vec3f(0.004));\n\n    return (h * ((Scl * A) * h + Scl * vec3f(C * B)) + Scl * vec3f(D * E)) /\n           (h * (A * h + vec3f(B)) + vec3f(D * F)) -\n           Scl * vec3f(E / F);\n}\n";

var tonemappingLinearPS = "\nuniform exposure: f32;\n\nfn toneMap(color: vec3f) -> vec3f {\n    return color * uniform.exposure;\n}\n";

var tonemappingNeutralPS = "\nuniform exposure: f32;\n\nfn toneMap(col: vec3f) -> vec3f {\n    var color = col * uniform.exposure;\n\n    let startCompression = 0.8 - 0.04;\n    let desaturation = 0.15;\n\n    let x = min(color.r, min(color.g, color.b));\n    let offset = select(0.04, x - 6.25 * x * x, x < 0.08);\n    color -= vec3f(offset);\n\n    let peak = max(color.r, max(color.g, color.b));\n    if (peak < startCompression) {\n        return color;\n    }\n\n    let d = 1.0 - startCompression;\n    let newPeak = 1.0 - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);\n    return mix(color, vec3f(newPeak), vec3f(g));\n}\n";

var tonemappingNonePS = "\nfn toneMap(color: vec3f) -> vec3f {\n    return color;\n}\n";

var shaderChunksWGSL = {
		decodePS,
		encodePS,
		envAtlasPS,
		envProcPS,
		fogPS,
		gammaPS,
		immediateLinePS,
		immediateLineVS,
		lightBufferDefinesPS: '',
		morphEvaluationPS,
		morphDeclarationPS,
		morphPS,
		morphVS,
		reprojectPS,
		reprojectVS,
		skyboxPS,
		skyboxVS,
		sphericalPS,
		tonemappingPS,
		tonemappingAcesPS,
		tonemappingAces2PS,
		tonemappingFilmicPS,
		tonemappingHejlPS,
		tonemappingLinearPS,
		tonemappingNeutralPS,
		tonemappingNonePS
};

var tempVec3$1 = new Vec3();
var tempAreaLightSizes = new Float32Array(6);
var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
var TextureIndexFloat = {
		POSITION_RANGE: 0,
		DIRECTION_FLAGS: 1,
		COLOR_ANGLES_BIAS: 2,
		PROJ_MAT_0: 3,
		ATLAS_VIEWPORT: 3,
		PROJ_MAT_1: 4,
		PROJ_MAT_2: 5,
		PROJ_MAT_3: 6,
		AREA_DATA_WIDTH: 7,
		AREA_DATA_HEIGHT: 8,
		COUNT: 9
};
var enums = {
		'{LIGHTSHAPE_PUNCTUAL}': "" + LIGHTSHAPE_PUNCTUAL + "u",
		'{LIGHTSHAPE_RECT}': "" + LIGHTSHAPE_RECT + "u",
		'{LIGHTSHAPE_DISK}': "" + LIGHTSHAPE_DISK + "u",
		'{LIGHTSHAPE_SPHERE}': "" + LIGHTSHAPE_SPHERE + "u"
};
var buildShaderDefines = (object, prefix)=>{
		return Object.keys(object).map((key)=>"#define " + prefix + key + " " + object[key]).join('\n');
};
shaderChunks.lightBufferDefinesPS = shaderChunksWGSL.lightBufferDefinesPS = "\n\n    " + buildShaderDefines(TextureIndexFloat, 'CLUSTER_TEXTURE_') + "\n    " + buildShaderDefines(enums, '') + "\n";
class LightsBuffer {
		destroy() {
				var _this_lightsTexture;
				(_this_lightsTexture = this.lightsTexture) == null ? void 0 : _this_lightsTexture.destroy();
				this.lightsTexture = null;
		}
		createTexture(device, width, height, format, name) {
				var tex = new Texture(device, {
						name: name,
						width: width,
						height: height,
						mipmaps: false,
						format: format,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						type: TEXTURETYPE_DEFAULT,
						magFilter: FILTER_NEAREST,
						minFilter: FILTER_NEAREST,
						anisotropy: 1
				});
				return tex;
		}
		setBounds(min, delta) {
				this.boundsMin.copy(min);
				this.boundsDelta.copy(delta);
		}
		uploadTextures() {
				this.lightsTexture.lock().set(this.lightsFloat);
				this.lightsTexture.unlock();
		}
		updateUniforms() {
				this._lightsTextureId.setValue(this.lightsTexture);
		}
		getSpotDirection(direction, spot) {
				var mat = spot._node.getWorldTransform();
				mat.getY(direction).mulScalar(-1);
				direction.normalize();
		}
		getLightAreaSizes(light) {
				var mat = light._node.getWorldTransform();
				mat.transformVector(areaHalfAxisWidth, tempVec3$1);
				tempAreaLightSizes[0] = tempVec3$1.x;
				tempAreaLightSizes[1] = tempVec3$1.y;
				tempAreaLightSizes[2] = tempVec3$1.z;
				mat.transformVector(areaHalfAxisHeight, tempVec3$1);
				tempAreaLightSizes[3] = tempVec3$1.x;
				tempAreaLightSizes[4] = tempVec3$1.y;
				tempAreaLightSizes[5] = tempVec3$1.z;
				return tempAreaLightSizes;
		}
		addLightData(light, lightIndex) {
				var isSpot = light._type === LIGHTTYPE_SPOT;
				var hasAtlasViewport = light.atlasViewportAllocated;
				var isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
				var isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
				var castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;
				var pos = light._node.getPosition();
				var lightProjectionMatrix = null;
				var atlasViewport = null;
				if (isSpot) {
						if (castShadows) {
								var lightRenderData = light.getRenderData(null, 0);
								lightProjectionMatrix = lightRenderData.shadowMatrix;
						} else if (isCookie) {
								lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
						}
				} else {
						if (castShadows || isCookie) {
								atlasViewport = light.atlasViewport;
						}
				}
				var dataFloat = this.lightsFloat;
				var dataUint = this.lightsUint;
				var dataFloatStart = lightIndex * this.lightsTexture.width * 4;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;
				var clusteredData = light.clusteredData;
				dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 0] = clusteredData[0];
				dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 1] = clusteredData[1];
				dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 2] = clusteredData[2];
				if (light.castShadows) {
						var lightRenderData1 = light.getRenderData(null, 0);
						var biases = light._getUniformBiasValues(lightRenderData1);
						var biasHalf = FloatPacking.float2Half(biases.bias);
						var normalBiasHalf = FloatPacking.float2Half(biases.normalBias);
						dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 3] = biasHalf | normalBiasHalf << 16;
				}
				if (isSpot) {
						this.getSpotDirection(tempVec3$1, light);
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 0] = tempVec3$1.x;
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 1] = tempVec3$1.y;
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 2] = tempVec3$1.z;
				}
				dataUint[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 3] = light.getClusteredFlags(castShadows, isCookie);
				if (lightProjectionMatrix) {
						var matData = lightProjectionMatrix.data;
						for(var m = 0; m < 16; m++){
								dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
						}
				}
				if (atlasViewport) {
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
				}
				if (isArea) {
						var areaSizes = this.getLightAreaSizes(light);
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
				}
		}
		constructor(device){
				this.areaLightsEnabled = false;
				this.device = device;
				this.cookiesEnabled = false;
				this.shadowsEnabled = false;
				this.areaLightsEnabled = false;
				this.maxLights = 255;
				var pixelsPerLightFloat = TextureIndexFloat.COUNT;
				this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
				this.lightsUint = new Uint32Array(this.lightsFloat.buffer);
				this.lightsTexture = this.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, 'LightsTexture');
				this._lightsTextureId = this.device.scope.resolve('lightsTexture');
				this.invMaxColorValue = 0;
				this.invMaxAttenuation = 0;
				this.boundsMin = new Vec3();
				this.boundsDelta = new Vec3();
		}
}

var tempVec3 = new Vec3();
var tempMin3 = new Vec3();
var tempMax3 = new Vec3();
var tempBox = new BoundingBox();
class ClusterLight {
		constructor(){
				this.light = null;
				this.min = new Vec3();
				this.max = new Vec3();
		}
}
class WorldClusters {
		set maxCellLightCount(count) {
				if (count !== this._maxCellLightCount) {
						this._maxCellLightCount = count;
						this._cellsDirty = true;
				}
		}
		get maxCellLightCount() {
				return this._maxCellLightCount;
		}
		set cells(value) {
				tempVec3.copy(value).floor();
				if (!this._cells.equals(tempVec3)) {
						this._cells.copy(tempVec3);
						this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);
						this._cellsDirty = true;
				}
		}
		get cells() {
				return this._cells;
		}
		destroy() {
				this.lightsBuffer.destroy();
				this.releaseClusterTexture();
		}
		releaseClusterTexture() {
				if (this.clusterTexture) {
						this.clusterTexture.destroy();
						this.clusterTexture = null;
				}
		}
		registerUniforms(device) {
				this._clusterSkipId = device.scope.resolve('clusterSkip');
				this._clusterMaxCellsId = device.scope.resolve('clusterMaxCells');
				this._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');
				this._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');
				this._clusterTextureSizeData = new Float32Array(3);
				this._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');
				this._clusterBoundsMinData = new Float32Array(3);
				this._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');
				this._clusterBoundsDeltaData = new Float32Array(3);
				this._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');
				this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
				this._clusterCellsDotId = device.scope.resolve('clusterCellsDot');
				this._clusterCellsDotData = new Float32Array(3);
				this._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');
				this._clusterCellsMaxData = new Float32Array(3);
		}
		updateParams(lightingParams) {
				if (lightingParams) {
						this.cells = lightingParams.cells;
						this.maxCellLightCount = lightingParams.maxLightsPerCell;
						this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
						this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
						this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
				}
		}
		updateCells() {
				if (this._cellsDirty) {
						this._cellsDirty = false;
						var cx = this._cells.x;
						var cy = this._cells.y;
						var cz = this._cells.z;
						var numCells = cx * cy * cz;
						var totalPixels = this.maxCellLightCount * numCells;
						var width = Math.ceil(Math.sqrt(totalPixels));
						width = math.roundUp(width, this.maxCellLightCount);
						var height = Math.ceil(totalPixels / width);
						this._clusterCellsMaxData[0] = cx;
						this._clusterCellsMaxData[1] = cy;
						this._clusterCellsMaxData[2] = cz;
						this._clusterCellsDotData[0] = this.maxCellLightCount;
						this._clusterCellsDotData[1] = cx * cz * this.maxCellLightCount;
						this._clusterCellsDotData[2] = cx * this.maxCellLightCount;
						this.clusters = new Uint8ClampedArray(totalPixels);
						this.counts = new Int32Array(numCells);
						this._clusterTextureSizeData[0] = width;
						this._clusterTextureSizeData[1] = 1.0 / width;
						this._clusterTextureSizeData[2] = 1.0 / height;
						this.releaseClusterTexture();
						this.clusterTexture = this.lightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8, 'ClusterTexture');
				}
		}
		uploadTextures() {
				this.clusterTexture.lock().set(this.clusters);
				this.clusterTexture.unlock();
				this.lightsBuffer.uploadTextures();
		}
		updateUniforms() {
				this._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1);
				this.lightsBuffer.updateUniforms();
				this._clusterWorldTextureId.setValue(this.clusterTexture);
				this._clusterMaxCellsId.setValue(this.maxCellLightCount);
				var boundsDelta = this.boundsDelta;
				this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
				this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
				this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;
				this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);
				this._clusterBoundsMinData[0] = this.boundsMin.x;
				this._clusterBoundsMinData[1] = this.boundsMin.y;
				this._clusterBoundsMinData[2] = this.boundsMin.z;
				this._clusterBoundsDeltaData[0] = boundsDelta.x;
				this._clusterBoundsDeltaData[1] = boundsDelta.y;
				this._clusterBoundsDeltaData[2] = boundsDelta.z;
				this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);
				this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);
				this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);
				this._clusterCellsDotId.setValue(this._clusterCellsDotData);
				this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);
		}
		evalLightCellMinMax(clusteredLight, min, max) {
				min.copy(clusteredLight.min);
				min.sub(this.boundsMin);
				min.div(this.boundsDelta);
				min.mul2(min, this.cells);
				min.floor();
				max.copy(clusteredLight.max);
				max.sub(this.boundsMin);
				max.div(this.boundsDelta);
				max.mul2(max, this.cells);
				max.ceil();
				min.max(Vec3.ZERO);
				max.min(this._cellsLimit);
		}
		collectLights(lights) {
				var maxLights = this.lightsBuffer.maxLights;
				var usedLights = this._usedLights;
				var lightIndex = 1;
				lights.forEach((light)=>{
						var runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));
						var zeroAngleSpotlight = light.type === LIGHTTYPE_SPOT && light._outerConeAngle === 0;
						if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {
								if (lightIndex < maxLights) {
										var clusteredLight;
										if (lightIndex < usedLights.length) {
												clusteredLight = usedLights[lightIndex];
										} else {
												clusteredLight = new ClusterLight();
												usedLights.push(clusteredLight);
										}
										clusteredLight.light = light;
										light.getBoundingBox(tempBox);
										clusteredLight.min.copy(tempBox.getMin());
										clusteredLight.max.copy(tempBox.getMax());
										lightIndex++;
								}
						}
				});
				usedLights.length = lightIndex;
		}
		evaluateBounds() {
				var usedLights = this._usedLights;
				var min = this.boundsMin;
				var max = this.boundsMax;
				if (usedLights.length > 1) {
						min.copy(usedLights[1].min);
						max.copy(usedLights[1].max);
						for(var i = 2; i < usedLights.length; i++){
								min.min(usedLights[i].min);
								max.max(usedLights[i].max);
						}
				} else {
						min.set(0, 0, 0);
						max.set(1, 1, 1);
				}
				this.boundsDelta.sub2(max, min);
				this.lightsBuffer.setBounds(min, this.boundsDelta);
		}
		updateClusters(lightingParams) {
				this.counts.fill(0);
				this.clusters.fill(0);
				this.lightsBuffer.areaLightsEnabled = lightingParams ? lightingParams.areaLightsEnabled : false;
				var divX = this._cells.x;
				var divZ = this._cells.z;
				var counts = this.counts;
				var limit = this._maxCellLightCount;
				var clusters = this.clusters;
				var pixelsPerCellCount = this.maxCellLightCount;
				var usedLights = this._usedLights;
				for(var i = 1; i < usedLights.length; i++){
						var clusteredLight = usedLights[i];
						var light = clusteredLight.light;
						this.lightsBuffer.addLightData(light, i);
						this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
						var xStart = tempMin3.x;
						var xEnd = tempMax3.x;
						var yStart = tempMin3.y;
						var yEnd = tempMax3.y;
						var zStart = tempMin3.z;
						var zEnd = tempMax3.z;
						for(var x = xStart; x <= xEnd; x++){
								for(var z = zStart; z <= zEnd; z++){
										for(var y = yStart; y <= yEnd; y++){
												var clusterIndex = x + divX * (z + y * divZ);
												var count = counts[clusterIndex];
												if (count < limit) {
														clusters[pixelsPerCellCount * clusterIndex + count] = i;
														counts[clusterIndex] = count + 1;
												}
										}
								}
						}
				}
		}
		update(lights, lightingParams) {
				if (lightingParams === void 0) lightingParams = null;
				this.updateParams(lightingParams);
				this.updateCells();
				this.collectLights(lights);
				this.evaluateBounds();
				this.updateClusters(lightingParams);
				this.uploadTextures();
		}
		activate() {
				this.updateUniforms();
		}
		constructor(device){
				this.device = device;
				this.name = 'Untitled';
				this.reportCount = 0;
				this.boundsMin = new Vec3();
				this.boundsMax = new Vec3();
				this.boundsDelta = new Vec3();
				this._cells = new Vec3(1, 1, 1);
				this._cellsLimit = new Vec3();
				this.cells = this._cells;
				this.maxCellLightCount = 4;
				this._usedLights = [];
				this._usedLights.push(new ClusterLight());
				this.lightsBuffer = new LightsBuffer(device);
				this.registerUniforms(device);
		}
}

var base64String = 'muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==';
var data = null;
var initData = ()=>{
		if (!data) {
				var binaryString = atob(base64String);
				data = Uint8Array.from(binaryString, (char)=>char.charCodeAt(0));
		}
};
var blueNoiseData = ()=>{
		initData();
		return data;
};
class BlueNoise {
		_next() {
				this.seed = (this.seed + 4) % data.length;
		}
		value() {
				this._next();
				return data[this.seed] / 255;
		}
		vec4(dest) {
				if (dest === void 0) dest = new Vec4();
				this._next();
				return dest.set(data[this.seed], data[this.seed + 1], data[this.seed + 2], data[this.seed + 3]).mulScalar(1 / 255);
		}
		constructor(seed = 0){
				this.seed = 0;
				this.seed = seed * 4;
				initData();
		}
}

var lightCubeDir = [
		new Vec3(-1, 0, 0),
		new Vec3(1, 0, 0),
		new Vec3(0, -1, 0),
		new Vec3(0, 1, 0),
		new Vec3(0, 0, -1),
		new Vec3(0, 0, 1)
];
class LightCube {
		update(ambientLight, lights) {
				var colors = this.colors;
				var { r, g, b } = ambientLight;
				for(var j = 0; j < 6; j++){
						colors[j * 3] = r;
						colors[j * 3 + 1] = g;
						colors[j * 3 + 2] = b;
				}
				for(var j1 = 0; j1 < lights.length; j1++){
						var light = lights[j1];
						if (light._type === LIGHTTYPE_DIRECTIONAL) {
								for(var c = 0; c < 6; c++){
										var weight = Math.max(lightCubeDir[c].dot(light._direction), 0) * light._intensity;
										var lightColor = light._color;
										colors[c * 3] += lightColor.r * weight;
										colors[c * 3 + 1] += lightColor.g * weight;
										colors[c * 3 + 2] += lightColor.b * weight;
								}
						}
				}
		}
		constructor(){
				this.colors = new Float32Array(6 * 3);
		}
}

var createTexture = (device, namePrefix, size, data)=>{
		var texture = new Texture(device, {
				name: "" + namePrefix + size,
				width: size,
				height: size,
				format: PIXELFORMAT_RGBA8,
				addressU: ADDRESS_REPEAT,
				addressV: ADDRESS_REPEAT,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_NEAREST,
				minFilter: FILTER_NEAREST,
				anisotropy: 1,
				mipmaps: false
		});
		texture.lock().set(data);
		texture.unlock();
		return texture;
};
var deviceCacheBlueNoise = new DeviceCache();
var getBlueNoiseTexture = (device)=>{
		return deviceCacheBlueNoise.get(device, ()=>{
				var data = blueNoiseData();
				var size = Math.sqrt(data.length / 4);
				return createTexture(device, 'BlueNoise', size, data);
		});
};

class ShadowMap {
		destroy() {
				if (this.texture) {
						this.texture.destroy();
						this.texture = null;
				}
				var targets = this.renderTargets;
				for(var i = 0; i < targets.length; i++){
						targets[i].destroy();
				}
				this.renderTargets.length = 0;
		}
		static create(device, light) {
				var shadowMap = null;
				if (light._type === LIGHTTYPE_OMNI) {
						shadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);
				} else {
						shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
				}
				return shadowMap;
		}
		static createAtlas(device, resolution, shadowType) {
				var shadowMap = this.create2dMap(device, resolution, shadowType);
				var targets = shadowMap.renderTargets;
				var rt = targets[0];
				for(var i = 0; i < 5; i++){
						targets.push(rt);
				}
				return shadowMap;
		}
		static create2dMap(device, size, shadowType) {
				var _pixelFormatInfo_get;
				var shadowInfo = shadowTypeInfo.get(shadowType);
				var format = shadowInfo.format;
				if (format === PIXELFORMAT_R32F && !device.textureFloatRenderable && device.textureHalfFloatRenderable) {
						format = PIXELFORMAT_R16F;
				}
				var formatName = (_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.name;
				var filter = FILTER_LINEAR;
				if (shadowType === SHADOW_VSM_32F) {
						filter = device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
				}
				if (shadowType === SHADOW_PCSS_32F) {
						filter = FILTER_NEAREST;
				}
				var texture = new Texture(device, {
						format: format,
						width: size,
						height: size,
						mipmaps: false,
						minFilter: filter,
						magFilter: filter,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						name: "ShadowMap2D_" + formatName
				});
				var target = null;
				if (shadowInfo == null ? void 0 : shadowInfo.pcf) {
						texture.compareOnRead = true;
						texture.compareFunc = FUNC_LESS;
						target = new RenderTarget({
								depthBuffer: texture
						});
				} else {
						target = new RenderTarget({
								colorBuffer: texture,
								depth: true
						});
				}
				if (device.isWebGPU) {
						target.flipY = true;
				}
				return new ShadowMap(texture, [
						target
				]);
		}
		static createCubemap(device, size, shadowType) {
				var _pixelFormatInfo_get;
				var shadowInfo = shadowTypeInfo.get(shadowType);
				var formatName = (_pixelFormatInfo_get = pixelFormatInfo.get(shadowInfo.format)) == null ? void 0 : _pixelFormatInfo_get.name;
				var isPcss = shadowType === SHADOW_PCSS_32F;
				var filter = isPcss ? FILTER_NEAREST : FILTER_LINEAR;
				var cubemap = new Texture(device, {
						format: shadowInfo == null ? void 0 : shadowInfo.format,
						width: size,
						height: size,
						cubemap: true,
						mipmaps: false,
						minFilter: filter,
						magFilter: filter,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						name: "ShadowMapCube_" + formatName
				});
				if (!isPcss) {
						cubemap.compareOnRead = true;
						cubemap.compareFunc = FUNC_LESS;
				}
				var targets = [];
				for(var i = 0; i < 6; i++){
						if (isPcss) {
								targets.push(new RenderTarget({
										colorBuffer: cubemap,
										face: i,
										depth: true
								}));
						} else {
								targets.push(new RenderTarget({
										depthBuffer: cubemap,
										face: i
								}));
						}
				}
				return new ShadowMap(cubemap, targets);
		}
		constructor(texture, targets){
				this.texture = texture;
				this.cached = false;
				this.renderTargets = targets;
		}
}

var _tempArray = [];
var _tempArray2 = [];
var _viewport$3 = new Vec4();
var _scissor = new Vec4();
class Slot {
		constructor(rect){
				this.size = Math.floor(rect.w * 1024);
				this.used = false;
				this.lightId = -1;
				this.rect = rect;
		}
}
class LightTextureAtlas {
		destroy() {
				this.destroyShadowAtlas();
				this.destroyCookieAtlas();
		}
		destroyShadowAtlas() {
				var _this_shadowAtlas;
				(_this_shadowAtlas = this.shadowAtlas) == null ? void 0 : _this_shadowAtlas.destroy();
				this.shadowAtlas = null;
		}
		destroyCookieAtlas() {
				var _this_cookieAtlas, _this_cookieRenderTarget;
				(_this_cookieAtlas = this.cookieAtlas) == null ? void 0 : _this_cookieAtlas.destroy();
				this.cookieAtlas = null;
				(_this_cookieRenderTarget = this.cookieRenderTarget) == null ? void 0 : _this_cookieRenderTarget.destroy();
				this.cookieRenderTarget = null;
		}
		allocateShadowAtlas(resolution, shadowType) {
				if (shadowType === void 0) shadowType = SHADOW_PCF3_32F;
				var _this_shadowAtlas;
				var existingFormat = (_this_shadowAtlas = this.shadowAtlas) == null ? void 0 : _this_shadowAtlas.texture.format;
				var requiredFormat = shadowTypeInfo.get(shadowType).format;
				if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution || existingFormat !== requiredFormat) {
						this.version++;
						this.destroyShadowAtlas();
						this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, shadowType);
						this.shadowAtlas.cached = true;
						var scissorOffset = 4 / this.shadowAtlasResolution;
						this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
				}
		}
		allocateCookieAtlas(resolution) {
				if (this.cookieAtlas.width !== resolution) {
						this.cookieRenderTarget.resize(resolution, resolution);
						this.version++;
				}
		}
		allocateUniforms() {
				this._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');
				this._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');
				this._shadowAtlasParams = new Float32Array(2);
				this._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');
		}
		updateUniforms() {
				var rt = this.shadowAtlas.renderTargets[0];
				var shadowBuffer = rt.depthBuffer;
				this._shadowAtlasTextureId.setValue(shadowBuffer);
				this._shadowAtlasParams[0] = this.shadowAtlasResolution;
				this._shadowAtlasParams[1] = this.shadowEdgePixels;
				this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);
				this._cookieAtlasTextureId.setValue(this.cookieAtlas);
		}
		subdivide(numLights, lightingParams) {
				var atlasSplit = lightingParams.atlasSplit;
				if (!atlasSplit) {
						var gridSize = Math.ceil(Math.sqrt(numLights));
						atlasSplit = _tempArray2;
						atlasSplit[0] = gridSize;
						atlasSplit.length = 1;
				}
				var arraysEqual = (a, b)=>a.length === b.length && a.every((v, i)=>v === b[i]);
				if (!arraysEqual(atlasSplit, this.atlasSplit)) {
						this.version++;
						this.slots.length = 0;
						this.atlasSplit.length = 0;
						this.atlasSplit.push(...atlasSplit);
						var splitCount = this.atlasSplit[0];
						if (splitCount > 1) {
								var invSize = 1 / splitCount;
								for(var i = 0; i < splitCount; i++){
										for(var j = 0; j < splitCount; j++){
												var rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
												var nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];
												if (nextLevelSplit > 1) {
														for(var x = 0; x < nextLevelSplit; x++){
																for(var y = 0; y < nextLevelSplit; y++){
																		var invSizeNext = invSize / nextLevelSplit;
																		var rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
																		this.slots.push(new Slot(rectNext));
																}
														}
												} else {
														this.slots.push(new Slot(rect));
												}
										}
								}
						} else {
								this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
						}
						this.slots.sort((a, b)=>{
								return b.size - a.size;
						});
				}
		}
		collectLights(localLights, lightingParams) {
				var cookiesEnabled = lightingParams.cookiesEnabled;
				var shadowsEnabled = lightingParams.shadowsEnabled;
				var needsShadowAtlas = false;
				var needsCookieAtlas = false;
				var lights = _tempArray;
				lights.length = 0;
				var processLights = (list)=>{
						for(var i = 0; i < list.length; i++){
								var light = list[i];
								if (light.visibleThisFrame) {
										var lightShadow = shadowsEnabled && light.castShadows;
										var lightCookie = cookiesEnabled && !!light.cookie;
										needsShadowAtlas || (needsShadowAtlas = lightShadow);
										needsCookieAtlas || (needsCookieAtlas = lightCookie);
										if (lightShadow || lightCookie) {
												lights.push(light);
										}
								}
						}
				};
				if (cookiesEnabled || shadowsEnabled) {
						processLights(localLights);
				}
				lights.sort((a, b)=>{
						return b.maxScreenSize - a.maxScreenSize;
				});
				if (needsShadowAtlas) {
						this.allocateShadowAtlas(this.shadowAtlasResolution, lightingParams.shadowType);
				}
				if (needsCookieAtlas) {
						this.allocateCookieAtlas(this.cookieAtlasResolution);
				}
				if (needsShadowAtlas || needsCookieAtlas) {
						this.subdivide(lights.length, lightingParams);
				}
				return lights;
		}
		setupSlot(light, rect) {
				light.atlasViewport.copy(rect);
				var faceCount = light.numShadowFaces;
				for(var face = 0; face < faceCount; face++){
						if (light.castShadows || light._cookie) {
								_viewport$3.copy(rect);
								_scissor.copy(rect);
								if (light._type === LIGHTTYPE_SPOT) {
										_viewport$3.add(this.scissorVec);
								}
								if (light._type === LIGHTTYPE_OMNI) {
										var smallSize = _viewport$3.z / 3;
										var offset = this.cubeSlotsOffsets[face];
										_viewport$3.x += smallSize * offset.x;
										_viewport$3.y += smallSize * offset.y;
										_viewport$3.z = smallSize;
										_viewport$3.w = smallSize;
										_scissor.copy(_viewport$3);
								}
								if (light.castShadows) {
										var lightRenderData = light.getRenderData(null, face);
										lightRenderData.shadowViewport.copy(_viewport$3);
										lightRenderData.shadowScissor.copy(_scissor);
								}
						}
				}
		}
		assignSlot(light, slotIndex, slotReassigned) {
				light.atlasViewportAllocated = true;
				var slot = this.slots[slotIndex];
				slot.lightId = light.id;
				slot.used = true;
				if (slotReassigned) {
						light.atlasSlotUpdated = true;
						light.atlasVersion = this.version;
						light.atlasSlotIndex = slotIndex;
				}
		}
		update(localLights, lightingParams) {
				this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
				this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
				var lights = this.collectLights(localLights, lightingParams);
				if (lights.length > 0) {
						var slots = this.slots;
						for(var i = 0; i < slots.length; i++){
								slots[i].used = false;
						}
						var assignCount = Math.min(lights.length, slots.length);
						for(var i1 = 0; i1 < assignCount; i1++){
								var light = lights[i1];
								if (light.castShadows) {
										light._shadowMap = this.shadowAtlas;
								}
								var previousSlot = slots[light.atlasSlotIndex];
								if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
										var previousSlot1 = slots[light.atlasSlotIndex];
										if (previousSlot1.size === slots[i1].size && !previousSlot1.used) {
												this.assignSlot(light, light.atlasSlotIndex, false);
										}
								}
						}
						var usedCount = 0;
						for(var i2 = 0; i2 < assignCount; i2++){
								while(usedCount < slots.length && slots[usedCount].used){
										usedCount++;
								}
								var light1 = lights[i2];
								if (!light1.atlasViewportAllocated) {
										this.assignSlot(light1, usedCount, true);
								}
								var slot = slots[light1.atlasSlotIndex];
								this.setupSlot(light1, slot.rect);
						}
				}
				this.updateUniforms();
		}
		constructor(device){
				this.device = device;
				this.version = 1;
				this.shadowAtlasResolution = 2048;
				this.shadowAtlas = null;
				this.shadowEdgePixels = 3;
				this.cookieAtlasResolution = 4;
				this.cookieAtlas = new Texture(this.device, {
						name: 'CookieAtlas',
						width: this.cookieAtlasResolution,
						height: this.cookieAtlasResolution,
						format: PIXELFORMAT_SRGBA8,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				this.cookieRenderTarget = new RenderTarget({
						colorBuffer: this.cookieAtlas,
						depth: false,
						flipY: true
				});
				this.slots = [];
				this.atlasSplit = [];
				this.cubeSlotsOffsets = [
						new Vec2(0, 0),
						new Vec2(0, 1),
						new Vec2(1, 0),
						new Vec2(1, 1),
						new Vec2(2, 0),
						new Vec2(2, 1)
				];
				this.scissorVec = new Vec4();
				this.allocateShadowAtlas(1);
				this.allocateCookieAtlas(1);
				this.allocateUniforms();
		}
}

var blendModes = [];
blendModes[BLEND_SUBTRACTIVE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_REVERSE_SUBTRACT
};
blendModes[BLEND_NONE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ZERO,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_NORMAL] = {
		src: BLENDMODE_SRC_ALPHA,
		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		op: BLENDEQUATION_ADD,
		alphaSrc: BLENDMODE_ONE
};
blendModes[BLEND_PREMULTIPLIED] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_ADDITIVE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_ADDITIVEALPHA] = {
		src: BLENDMODE_SRC_ALPHA,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_MULTIPLICATIVE2X] = {
		src: BLENDMODE_DST_COLOR,
		dst: BLENDMODE_SRC_COLOR,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_SCREEN] = {
		src: BLENDMODE_ONE_MINUS_DST_COLOR,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_MULTIPLICATIVE] = {
		src: BLENDMODE_DST_COLOR,
		dst: BLENDMODE_ZERO,
		op: BLENDEQUATION_ADD
};
blendModes[BLEND_MIN] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_MIN
};
blendModes[BLEND_MAX] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_MAX
};
var id$1 = 0;
class Material {
		set chunks(value) {
				this._dirtyShader = true;
				this._chunks = value;
		}
		get chunks() {
				this._dirtyShader = true;
				return this._chunks;
		}
		set depthBias(value) {
				this._depthState.depthBias = value;
		}
		get depthBias() {
				return this._depthState.depthBias;
		}
		set slopeDepthBias(value) {
				this._depthState.depthBiasSlope = value;
		}
		get slopeDepthBias() {
				return this._depthState.depthBiasSlope;
		}
		set redWrite(value) {
				this._blendState.redWrite = value;
		}
		get redWrite() {
				return this._blendState.redWrite;
		}
		set greenWrite(value) {
				this._blendState.greenWrite = value;
		}
		get greenWrite() {
				return this._blendState.greenWrite;
		}
		set blueWrite(value) {
				this._blendState.blueWrite = value;
		}
		get blueWrite() {
				return this._blendState.blueWrite;
		}
		set alphaWrite(value) {
				this._blendState.alphaWrite = value;
		}
		get alphaWrite() {
				return this._blendState.alphaWrite;
		}
		get transparent() {
				return this._blendState.blend;
		}
		_updateTransparency() {
				var transparent = this.transparent;
				var meshInstances = this.meshInstances;
				for(var i = 0; i < meshInstances.length; i++){
						meshInstances[i].transparent = transparent;
				}
		}
		set blendState(value) {
				this._blendState.copy(value);
				this._updateTransparency();
		}
		get blendState() {
				return this._blendState;
		}
		set blendType(type) {
				var blendMode = blendModes[type];
				this._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);
				var _blendMode_alphaOp, _blendMode_alphaSrc, _blendMode_alphaDst;
				this._blendState.setAlphaBlend((_blendMode_alphaOp = blendMode.alphaOp) != null ? _blendMode_alphaOp : blendMode.op, (_blendMode_alphaSrc = blendMode.alphaSrc) != null ? _blendMode_alphaSrc : blendMode.src, (_blendMode_alphaDst = blendMode.alphaDst) != null ? _blendMode_alphaDst : blendMode.dst);
				var blend = type !== BLEND_NONE;
				if (this._blendState.blend !== blend) {
						this._blendState.blend = blend;
						this._updateTransparency();
				}
				this._updateMeshInstanceKeys();
		}
		get blendType() {
				if (!this.transparent) {
						return BLEND_NONE;
				}
				var { colorOp, colorSrcFactor, colorDstFactor, alphaOp, alphaSrcFactor, alphaDstFactor } = this._blendState;
				for(var i = 0; i < blendModes.length; i++){
						var blendMode = blendModes[i];
						if (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {
								return i;
						}
				}
				return BLEND_NORMAL;
		}
		set depthState(value) {
				this._depthState.copy(value);
		}
		get depthState() {
				return this._depthState;
		}
		set depthTest(value) {
				this._depthState.test = value;
		}
		get depthTest() {
				return this._depthState.test;
		}
		set depthFunc(value) {
				this._depthState.func = value;
		}
		get depthFunc() {
				return this._depthState.func;
		}
		set depthWrite(value) {
				this._depthState.write = value;
		}
		get depthWrite() {
				return this._depthState.write;
		}
		copy(source) {
				var _source_stencilFront;
				this.name = source.name;
				this.alphaTest = source.alphaTest;
				this.alphaToCoverage = source.alphaToCoverage;
				this._blendState.copy(source._blendState);
				this._depthState.copy(source._depthState);
				this.cull = source.cull;
				this.stencilFront = (_source_stencilFront = source.stencilFront) == null ? void 0 : _source_stencilFront.clone();
				if (source.stencilBack) {
						this.stencilBack = source.stencilFront === source.stencilBack ? this.stencilFront : source.stencilBack.clone();
				}
				this.clearParameters();
				for(var name in source.parameters){
						if (source.parameters.hasOwnProperty(name)) {
								this._setParameterSimple(name, source.parameters[name].data);
						}
				}
				this.defines.clear();
				source.defines.forEach((value, key)=>this.defines.set(key, value));
				var srcChunks = source._chunks;
				for(var p in srcChunks){
						if (srcChunks.hasOwnProperty(p)) {
								this._chunks[p] = srcChunks[p];
						}
				}
				return this;
		}
		clone() {
				var clone = new this.constructor();
				return clone.copy(this);
		}
		_updateMeshInstanceKeys() {
				var meshInstances = this.meshInstances;
				for(var i = 0; i < meshInstances.length; i++){
						meshInstances[i].updateKey();
				}
		}
		updateUniforms(device, scene) {
				if (this._dirtyShader) {
						this.clearVariants();
				}
		}
		getShaderVariant(params) {}
		update() {
				if (this._definesDirty) {
						this._definesDirty = false;
						this.clearVariants();
				}
				this.dirty = true;
		}
		clearParameters() {
				this.parameters = {};
		}
		getParameters() {
				return this.parameters;
		}
		clearVariants() {
				this.variants.clear();
				var meshInstances = this.meshInstances;
				var count = meshInstances.length;
				for(var i = 0; i < count; i++){
						meshInstances[i].clearShaders();
				}
		}
		getParameter(name) {
				return this.parameters[name];
		}
		_setParameterSimple(name, data) {
				var param = this.parameters[name];
				if (param) {
						param.data = data;
				} else {
						this.parameters[name] = {
								scopeId: null,
								data: data
						};
				}
		}
		setParameter(name, data) {
				if (data === undefined && typeof name === 'object') {
						var uniformObject = name;
						if (uniformObject.length) {
								for(var i = 0; i < uniformObject.length; i++){
										this.setParameter(uniformObject[i]);
								}
								return;
						}
						name = uniformObject.name;
						data = uniformObject.value;
				}
				this._setParameterSimple(name, data);
		}
		deleteParameter(name) {
				if (this.parameters[name]) {
						delete this.parameters[name];
				}
		}
		setParameters(device, names) {
				var parameters = this.parameters;
				if (names === undefined) names = parameters;
				for(var paramName in names){
						var parameter = parameters[paramName];
						if (parameter) {
								if (!parameter.scopeId) {
										parameter.scopeId = device.scope.resolve(paramName);
								}
								parameter.scopeId.setValue(parameter.data);
						}
				}
		}
		setDefine(name, value) {
				var modified = false;
				var { defines } = this;
				if (value !== undefined && value !== false) {
						modified = !defines.has(name) || defines.get(name) !== value;
						defines.set(name, value);
				} else {
						modified = defines.has(name);
						defines.delete(name);
				}
				this._definesDirty || (this._definesDirty = modified);
		}
		getDefine(name) {
				return this.defines.has(name);
		}
		destroy() {
				this.variants.clear();
				for(var i = 0; i < this.meshInstances.length; i++){
						var meshInstance = this.meshInstances[i];
						meshInstance.clearShaders();
						meshInstance._material = null;
						if (meshInstance.mesh) {
								var defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);
								if (this !== defaultMaterial) {
										meshInstance.material = defaultMaterial;
								}
						}
				}
				this.meshInstances.length = 0;
		}
		addMeshInstanceRef(meshInstance) {
				this.meshInstances.push(meshInstance);
		}
		removeMeshInstanceRef(meshInstance) {
				var meshInstances = this.meshInstances;
				var i = meshInstances.indexOf(meshInstance);
				if (i !== -1) {
						meshInstances.splice(i, 1);
				}
		}
		constructor(){
				this.meshInstances = [];
				this.name = 'Untitled';
				this.userId = '';
				this.id = id$1++;
				this.variants = new Map();
				this.defines = new Map();
				this._definesDirty = false;
				this.parameters = {};
				this.alphaTest = 0;
				this.alphaToCoverage = false;
				this._blendState = new BlendState();
				this._depthState = new DepthState();
				this.cull = CULLFACE_BACK;
				this.stencilFront = null;
				this.stencilBack = null;
				this._chunks = {};
				this._dirtyShader = true;
				this._shaderVersion = 0;
				this._scene = null;
				this.dirty = true;
		}
}

class ShadowMapCache {
		destroy() {
				this.clear();
				this.cache = null;
		}
		clear() {
				this.cache.forEach((shadowMaps)=>{
						shadowMaps.forEach((shadowMap)=>{
								shadowMap.destroy();
						});
				});
				this.cache.clear();
		}
		getKey(light) {
				var isCubeMap = light._type === LIGHTTYPE_OMNI;
				var shadowType = light._shadowType;
				var resolution = light._shadowResolution;
				return isCubeMap + "-" + shadowType + "-" + resolution;
		}
		get(device, light) {
				var key = this.getKey(light);
				var shadowMaps = this.cache.get(key);
				if (shadowMaps && shadowMaps.length) {
						return shadowMaps.pop();
				}
				var shadowMap = ShadowMap.create(device, light);
				shadowMap.cached = true;
				return shadowMap;
		}
		add(light, shadowMap) {
				var key = this.getKey(light);
				var shadowMaps = this.cache.get(key);
				if (shadowMaps) {
						shadowMaps.push(shadowMap);
				} else {
						this.cache.set(key, [
								shadowMap
						]);
				}
		}
		constructor(){
				this.cache = new Map();
		}
}

class RenderPassShadowLocalNonClustered extends RenderPass {
		execute() {
				this.shadowRenderer.renderFace(this.light, null, this.face, false);
		}
		after() {
				if (this.applyVsm) {
						this.shadowRenderer.renderVsm(this.light, this.shadowCamera);
				}
		}
		constructor(device, shadowRenderer, light, face, applyVsm){
				super(device);
				this.requiresCubemaps = false;
				this.shadowRenderer = shadowRenderer;
				this.light = light;
				this.face = face;
				this.applyVsm = applyVsm;
				this.shadowCamera = shadowRenderer.prepareFace(light, null, face);
				shadowRenderer.setupRenderPass(this, this.shadowCamera, true);
		}
}

class ShadowRendererLocal {
		cull(light, comp, casters) {
				if (casters === void 0) casters = null;
				var isClustered = this.renderer.scene.clusteredLightingEnabled;
				light.visibleThisFrame = true;
				if (!isClustered) {
						if (!light._shadowMap) {
								light._shadowMap = ShadowMap.create(this.device, light);
						}
				}
				var type = light._type;
				var faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;
				for(var face = 0; face < faceCount; face++){
						var lightRenderData = light.getRenderData(null, face);
						var shadowCam = lightRenderData.shadowCamera;
						shadowCam.nearClip = light.attenuationEnd / 1000;
						shadowCam.farClip = light.attenuationEnd;
						var shadowCamNode = shadowCam._node;
						var lightNode = light._node;
						shadowCamNode.setPosition(lightNode.getPosition());
						if (type === LIGHTTYPE_SPOT) {
								shadowCam.fov = light._outerConeAngle * 2;
								shadowCamNode.setRotation(lightNode.getRotation());
								shadowCamNode.rotateLocal(-90, 0, 0);
						} else if (type === LIGHTTYPE_OMNI) {
								if (isClustered) {
										var tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
										var texelSize = 2 / tileSize;
										var filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
										shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
								} else {
										shadowCam.fov = 90;
								}
						}
						this.renderer.updateCameraFrustum(shadowCam);
						this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
				}
		}
		prepareLights(shadowLights, lights) {
				var shadowCamera;
				for(var i = 0; i < lights.length; i++){
						var light = lights[i];
						if (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {
								shadowLights.push(light);
								for(var face = 0; face < light.numShadowFaces; face++){
										shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
								}
						}
				}
				return shadowCamera;
		}
		buildNonClusteredRenderPasses(frameGraph, localLights) {
				for(var i = 0; i < localLights.length; i++){
						var light = localLights[i];
						if (this.shadowRenderer.needsShadowRendering(light)) {
								var applyVsm = light._type === LIGHTTYPE_SPOT;
								var faceCount = light.numShadowFaces;
								for(var face = 0; face < faceCount; face++){
										var renderPass = new RenderPassShadowLocalNonClustered(this.device, this.shadowRenderer, light, face, applyVsm);
										frameGraph.addRenderPass(renderPass);
								}
						}
				}
		}
		constructor(renderer, shadowRenderer){
				this.shadowLights = [];
				this.renderer = renderer;
				this.shadowRenderer = shadowRenderer;
				this.device = renderer.device;
		}
}

class RenderPassShadowDirectional extends RenderPass {
		execute() {
				var { light, camera, shadowRenderer, allCascadesRendering } = this;
				var faceCount = light.numShadowFaces;
				var shadowUpdateOverrides = light.shadowUpdateOverrides;
				for(var face = 0; face < faceCount; face++){
						if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== SHADOWUPDATE_NONE) {
								shadowRenderer.renderFace(light, camera, face, !allCascadesRendering);
						}
						if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_THISFRAME) {
								shadowUpdateOverrides[face] = SHADOWUPDATE_NONE;
						}
				}
		}
		after() {
				this.shadowRenderer.renderVsm(this.light, this.camera);
		}
		constructor(device, shadowRenderer, light, camera, allCascadesRendering){
				super(device);
				this.shadowRenderer = shadowRenderer;
				this.light = light;
				this.camera = camera;
				this.allCascadesRendering = allCascadesRendering;
		}
}

var visibleSceneAabb = new BoundingBox();
var center = new Vec3();
var shadowCamView$1 = new Mat4();
var aabbPoints = [
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3(),
		new Vec3()
];
var _depthRange = {
		min: 0,
		max: 0
};
function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
		aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
		aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
		aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
		aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
		aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
		aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
		var minz = 9999999999;
		var maxz = -9999999999;
		for(var i = 0; i < 8; ++i){
				cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
				var z = aabbPoints[i].z;
				if (z < minz) minz = z;
				if (z > maxz) maxz = z;
		}
		_depthRange.min = minz;
		_depthRange.max = maxz;
		return _depthRange;
}
class ShadowRendererDirectional {
		cull(light, comp, camera, casters) {
				if (casters === void 0) casters = null;
				light.visibleThisFrame = true;
				if (!light._shadowMap) {
						light._shadowMap = ShadowMap.create(this.device, light);
				}
				var nearDist = camera._nearClip;
				this.generateSplitDistances(light, nearDist, Math.min(camera._farClip, light.shadowDistance));
				var shadowUpdateOverrides = light.shadowUpdateOverrides;
				for(var cascade = 0; cascade < light.numCascades; cascade++){
						if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === SHADOWUPDATE_NONE) {
								break;
						}
						var lightRenderData = light.getRenderData(camera, cascade);
						var shadowCam = lightRenderData.shadowCamera;
						shadowCam.renderTarget = light._shadowMap.renderTargets[0];
						lightRenderData.shadowViewport.copy(light.cascades[cascade]);
						lightRenderData.shadowScissor.copy(light.cascades[cascade]);
						var shadowCamNode = shadowCam._node;
						var lightNode = light._node;
						shadowCamNode.setPosition(lightNode.getPosition());
						shadowCamNode.setRotation(lightNode.getRotation());
						shadowCamNode.rotateLocal(-90, 0, 0);
						var frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
						var frustumFarDist = light._shadowCascadeDistances[cascade];
						var frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);
						center.set(0, 0, 0);
						var cameraWorldMat = camera.node.getWorldTransform();
						for(var i = 0; i < 8; i++){
								cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
								center.add(frustumPoints[i]);
						}
						center.mulScalar(1 / 8);
						var radius = 0;
						for(var i1 = 0; i1 < 8; i1++){
								var dist = frustumPoints[i1].sub(center).length();
								if (dist > radius) {
										radius = dist;
								}
						}
						var right = shadowCamNode.right;
						var up = shadowCamNode.up;
						var lightDir = shadowCamNode.forward;
						var sizeRatio = 0.25 * light._shadowResolution / radius;
						var x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
						var y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
						var scaledUp = up.mulScalar(x);
						var scaledRight = right.mulScalar(y);
						var dot = center.dot(lightDir);
						var scaledDir = lightDir.mulScalar(dot);
						center.add2(scaledUp, scaledRight).add(scaledDir);
						shadowCamNode.setPosition(center);
						shadowCamNode.translateLocal(0, 0, 1000000);
						shadowCam.nearClip = 0.01;
						shadowCam.farClip = 2000000;
						shadowCam.orthoHeight = radius;
						this.renderer.updateCameraFrustum(shadowCam);
						this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
						var emptyAabb = true;
						var visibleCasters = lightRenderData.visibleCasters;
						for(var i2 = 0; i2 < visibleCasters.length; i2++){
								var meshInstance = visibleCasters[i2];
								if (emptyAabb) {
										emptyAabb = false;
										visibleSceneAabb.copy(meshInstance.aabb);
								} else {
										visibleSceneAabb.add(meshInstance.aabb);
								}
						}
						shadowCamView$1.copy(shadowCamNode.getWorldTransform()).invert();
						var depthRange = getDepthRange(shadowCamView$1, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
						shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
						shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
						lightRenderData.projectionCompensation = radius;
				}
		}
		generateSplitDistances(light, nearDist, farDist) {
				light._shadowCascadeDistances.fill(farDist);
				for(var i = 1; i < light.numCascades; i++){
						var fraction = i / light.numCascades;
						var linearDist = nearDist + (farDist - nearDist) * fraction;
						var logDist = nearDist * (farDist / nearDist) ** fraction;
						var dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
						light._shadowCascadeDistances[i - 1] = dist;
				}
		}
		getLightRenderPass(light, camera) {
				var renderPass = null;
				if (this.shadowRenderer.needsShadowRendering(light)) {
						var faceCount = light.numShadowFaces;
						var shadowUpdateOverrides = light.shadowUpdateOverrides;
						var allCascadesRendering = true;
						var shadowCamera;
						for(var face = 0; face < faceCount; face++){
								if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_NONE) {
										allCascadesRendering = false;
								}
								shadowCamera = this.shadowRenderer.prepareFace(light, camera, face);
						}
						renderPass = new RenderPassShadowDirectional(this.device, this.shadowRenderer, light, camera, allCascadesRendering);
						this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);
				}
				return renderPass;
		}
		constructor(renderer, shadowRenderer){
				this.renderer = renderer;
				this.shadowRenderer = shadowRenderer;
				this.device = renderer.device;
		}
}

var tempSet$1 = new Set();
var shadowCamView = new Mat4();
var shadowCamViewProj = new Mat4();
var pixelOffset = new Float32Array(2);
var blurScissorRect = new Vec4(1, 1, 0, 0);
var viewportMatrix = new Mat4();
function gauss(x, sigma) {
		return Math.exp(-(x * x) / (2.0 * sigma * sigma));
}
function gaussWeights(kernelSize) {
		var sigma = (kernelSize - 1) / (2 * 3);
		var halfWidth = (kernelSize - 1) * 0.5;
		var values = new Array(kernelSize);
		var sum = 0.0;
		for(var i = 0; i < kernelSize; ++i){
				values[i] = gauss(i - halfWidth, sigma);
				sum += values[i];
		}
		for(var i1 = 0; i1 < kernelSize; ++i1){
				values[i1] /= sum;
		}
		return values;
}
class ShadowRenderer {
		static createShadowCamera(shadowType, type, face) {
				var shadowCam = LightCamera.create('ShadowCamera', type, face);
				var shadowInfo = shadowTypeInfo.get(shadowType);
				var _shadowInfo_vsm;
				var isVsm = (_shadowInfo_vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo_vsm : false;
				var _shadowInfo_pcf;
				var isPcf = (_shadowInfo_pcf = shadowInfo == null ? void 0 : shadowInfo.pcf) != null ? _shadowInfo_pcf : false;
				if (isVsm) {
						shadowCam.clearColor = new Color(0, 0, 0, 0);
				} else {
						shadowCam.clearColor = new Color(1, 1, 1, 1);
				}
				shadowCam.clearDepthBuffer = true;
				shadowCam.clearStencilBuffer = false;
				shadowCam.clearColorBuffer = !isPcf;
				return shadowCam;
		}
		_cullShadowCastersInternal(meshInstances, visible, camera) {
				var numInstances = meshInstances.length;
				for(var i = 0; i < numInstances; i++){
						var meshInstance = meshInstances[i];
						if (meshInstance.castShadow) {
								if (!meshInstance.cull || meshInstance._isVisible(camera)) {
										meshInstance.visibleThisFrame = true;
										visible.push(meshInstance);
								}
						}
				}
		}
		cullShadowCasters(comp, light, visible, camera, casters) {
				visible.length = 0;
				if (casters) {
						this._cullShadowCastersInternal(casters, visible, camera);
				} else {
						var layers = comp.layerList;
						var len = layers.length;
						for(var i = 0; i < len; i++){
								var layer = layers[i];
								if (layer._lightsSet.has(light)) {
										if (!tempSet$1.has(layer)) {
												tempSet$1.add(layer);
												this._cullShadowCastersInternal(layer.shadowCasters, visible, camera);
										}
								}
						}
						tempSet$1.clear();
				}
				visible.sort(this.sortCompareShader);
		}
		sortCompareShader(drawCallA, drawCallB) {
				var keyA = drawCallA._sortKeyShadow;
				var keyB = drawCallB._sortKeyShadow;
				if (keyA === keyB) {
						return drawCallB.mesh.id - drawCallA.mesh.id;
				}
				return keyB - keyA;
		}
		setupRenderState(device, light) {
				var isClustered = this.renderer.scene.clusteredLightingEnabled;
				var useShadowSampler = isClustered ? light._isPcf : light._isPcf && light._type !== LIGHTTYPE_OMNI;
				device.setBlendState(useShadowSampler ? this.blendStateNoWrite : this.blendStateWrite);
				device.setDepthState(light.shadowDepthState);
				device.setStencilState(null, null);
		}
		dispatchUniforms(light, shadowCam, lightRenderData, face) {
				var shadowCamNode = shadowCam._node;
				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
						this.renderer.dispatchViewPos(shadowCamNode.getPosition());
						this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
				}
				shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
				shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
				var rectViewport = lightRenderData.shadowViewport;
				shadowCam.rect = rectViewport;
				shadowCam.scissorRect = lightRenderData.shadowScissor;
				viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
				lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);
				if (light._type === LIGHTTYPE_DIRECTIONAL) {
						light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
				}
		}
		getShadowPass(light) {
				var _this_shadowPassCache_lightType;
				var lightType = light._type;
				var shadowType = light._shadowType;
				var shadowPassInfo = (_this_shadowPassCache_lightType = this.shadowPassCache[lightType]) == null ? void 0 : _this_shadowPassCache_lightType[shadowType];
				if (!shadowPassInfo) {
						var shadowPassName = "ShadowPass_" + lightType + "_" + shadowType;
						shadowPassInfo = ShaderPass.get(this.device).allocate(shadowPassName, {
								isShadow: true,
								lightType: lightType,
								shadowType: shadowType
						});
						if (!this.shadowPassCache[lightType]) {
								this.shadowPassCache[lightType] = [];
						}
						this.shadowPassCache[lightType][shadowType] = shadowPassInfo;
				}
				return shadowPassInfo.index;
		}
		submitCasters(visibleCasters, light, camera) {
				var device = this.device;
				var renderer = this.renderer;
				var scene = renderer.scene;
				var passFlags = 1 << SHADER_SHADOW;
				var shadowPass = this.getShadowPass(light);
				var cameraShaderParams = camera.shaderParams;
				var flipFactor = camera.renderTarget.flipY ? -1 : 1;
				var count = visibleCasters.length;
				for(var i = 0; i < count; i++){
						var meshInstance = visibleCasters[i];
						var mesh = meshInstance.mesh;
						meshInstance.ensureMaterial(device);
						var material = meshInstance.material;
						renderer.setBaseConstants(device, material);
						renderer.setSkinning(device, meshInstance);
						if (material.dirty) {
								material.updateUniforms(device, scene);
								material.dirty = false;
						}
						renderer.setupCullMode(true, flipFactor, meshInstance);
						material.setParameters(device);
						meshInstance.setParameters(device, passFlags);
						var shaderInstance = meshInstance.getShaderInstance(shadowPass, 0, scene, cameraShaderParams, this.viewUniformFormat, this.viewBindGroupFormat);
						var shadowShader = shaderInstance.shader;
						meshInstance._sortKeyShadow = shadowShader.id;
						device.setShader(shadowShader);
						renderer.setVertexBuffers(device, mesh);
						renderer.setMorphing(device, meshInstance.morphInstance);
						this.renderer.setupMeshUniformBuffers(shaderInstance, meshInstance);
						var style = meshInstance.renderStyle;
						device.setIndexBuffer(mesh.indexBuffer[style]);
						renderer.drawInstance(device, meshInstance, mesh, style);
						renderer._shadowDrawCalls++;
				}
		}
		needsShadowRendering(light) {
				var needs = light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame;
				if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
						light.shadowUpdateMode = SHADOWUPDATE_NONE;
				}
				if (needs) {
						this.renderer._shadowMapUpdates += light.numShadowFaces;
				}
				return needs;
		}
		getLightRenderData(light, camera, face) {
				return light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
		}
		setupRenderPass(renderPass, shadowCamera, clearRenderTarget) {
				var rt = shadowCamera.renderTarget;
				renderPass.init(rt);
				renderPass.depthStencilOps.clearDepthValue = 1;
				renderPass.depthStencilOps.clearDepth = clearRenderTarget;
				if (rt.depthBuffer) {
						renderPass.depthStencilOps.storeDepth = true;
				} else {
						renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);
						renderPass.colorOps.clear = clearRenderTarget;
						renderPass.depthStencilOps.storeDepth = false;
				}
				renderPass.requiresCubemaps = false;
		}
		prepareFace(light, camera, face) {
				var type = light._type;
				var lightRenderData = this.getLightRenderData(light, camera, face);
				var shadowCam = lightRenderData.shadowCamera;
				var renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
				shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
				return shadowCam;
		}
		renderFace(light, camera, face, clear, insideRenderPass) {
				if (insideRenderPass === void 0) insideRenderPass = true;
				var device = this.device;
				var lightRenderData = this.getLightRenderData(light, camera, face);
				var shadowCam = lightRenderData.shadowCamera;
				this.dispatchUniforms(light, shadowCam, lightRenderData, face);
				var rt = shadowCam.renderTarget;
				var renderer = this.renderer;
				renderer.setCameraUniforms(shadowCam, rt);
				if (device.supportsUniformBuffers) {
						renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);
				}
				if (insideRenderPass) {
						renderer.setupViewport(shadowCam, rt);
						if (clear) {
								renderer.clear(shadowCam);
						}
				} else {
						renderer.clearView(shadowCam, rt, true, false);
				}
				this.setupRenderState(device, light);
				this.submitCasters(lightRenderData.visibleCasters, light, shadowCam);
		}
		render(light, camera, insideRenderPass) {
				if (insideRenderPass === void 0) insideRenderPass = true;
				if (this.needsShadowRendering(light)) {
						var faceCount = light.numShadowFaces;
						for(var face = 0; face < faceCount; face++){
								this.prepareFace(light, camera, face);
								this.renderFace(light, camera, face, true, insideRenderPass);
						}
						this.renderVsm(light, camera);
				}
		}
		renderVsm(light, camera) {
				if (light._isVsm && light._vsmBlurSize > 1) {
						var isClustered = this.renderer.scene.clusteredLightingEnabled;
						if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
								this.applyVsmBlur(light, camera);
						}
				}
		}
		getVsmBlurShader(blurMode, filterSize) {
				var cache = this.blurVsmShader;
				var blurShader = cache[blurMode][filterSize];
				if (!blurShader) {
						this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
						var blurVS = shaderChunks.fullscreenQuadVS;
						var blurFS = "#define SAMPLES " + filterSize + "\n";
						blurFS += this.blurVsmShaderCode[blurMode];
						var blurShaderName = "blurVsm" + blurMode + filterSize;
						blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
						cache[blurMode][filterSize] = blurShader;
				}
				return blurShader;
		}
		applyVsmBlur(light, camera) {
				var device = this.device;
				device.setBlendState(BlendState.NOBLEND);
				var lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
				var shadowCam = lightRenderData.shadowCamera;
				var origShadowMap = shadowCam.renderTarget;
				var tempShadowMap = this.renderer.shadowMapCache.get(device, light);
				var tempRt = tempShadowMap.renderTargets[0];
				var blurMode = light.vsmBlurMode;
				var filterSize = light._vsmBlurSize;
				var blurShader = this.getVsmBlurShader(blurMode, filterSize);
				blurScissorRect.z = light._shadowResolution - 2;
				blurScissorRect.w = blurScissorRect.z;
				this.sourceId.setValue(origShadowMap.colorBuffer);
				pixelOffset[0] = 1 / light._shadowResolution;
				pixelOffset[1] = 0;
				this.pixelOffsetId.setValue(pixelOffset);
				if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
				drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
				this.sourceId.setValue(tempRt.colorBuffer);
				pixelOffset[1] = pixelOffset[0];
				pixelOffset[0] = 0;
				this.pixelOffsetId.setValue(pixelOffset);
				drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
				this.renderer.shadowMapCache.add(light, tempShadowMap);
		}
		initViewBindGroupFormat() {
				if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
						this.viewUniformFormat = new UniformBufferFormat(this.device, [
								new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4)
						]);
						this.viewBindGroupFormat = new BindGroupFormat(this.device, [
								new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)
						]);
				}
		}
		frameUpdate() {
				this.initViewBindGroupFormat();
		}
		constructor(renderer, lightTextureAtlas){
				this.shadowPassCache = [];
				this.device = renderer.device;
				this.renderer = renderer;
				this.lightTextureAtlas = lightTextureAtlas;
				var scope = this.device.scope;
				this.sourceId = scope.resolve('source');
				this.pixelOffsetId = scope.resolve('pixelOffset');
				this.weightId = scope.resolve('weight[0]');
				this.blurVsmShaderCode = [
						shaderChunks.blurVSMPS,
						"#define GAUSS\n" + shaderChunks.blurVSMPS
				];
				this.blurVsmShader = [
						{},
						{}
				];
				this.blurVsmWeights = {};
				this.shadowMapLightRadiusId = scope.resolve('light_radius');
				this.viewUniformFormat = null;
				this.viewBindGroupFormat = null;
				this.blendStateWrite = new BlendState();
				this.blendStateNoWrite = new BlendState();
				this.blendStateNoWrite.setColorWrite(false, false, false, false);
		}
}

var tempClusterArray = [];
class WorldClustersAllocator {
		destroy() {
				if (this._empty) {
						this._empty.destroy();
						this._empty = null;
				}
				this._allocated.forEach((cluster)=>{
						cluster.destroy();
				});
				this._allocated.length = 0;
		}
		get count() {
				return this._allocated.length;
		}
		get empty() {
				if (!this._empty) {
						var empty = new WorldClusters(this.device);
						empty.name = 'ClusterEmpty';
						empty.update([]);
						this._empty = empty;
				}
				return this._empty;
		}
		assign(renderPasses) {
				var empty = this.empty;
				tempClusterArray.push(...this._allocated);
				this._allocated.length = 0;
				this._clusters.clear();
				var passCount = renderPasses.length;
				for(var p = 0; p < passCount; p++){
						var renderPass = renderPasses[p];
						var renderActions = renderPass.renderActions;
						if (renderActions) {
								var count = renderActions.length;
								for(var i = 0; i < count; i++){
										var ra = renderActions[i];
										ra.lightClusters = null;
										var layer = ra.layer;
										if (layer.hasClusteredLights && layer.meshInstances.length) {
												var hash = layer.getLightIdHash();
												var existingRenderAction = this._clusters.get(hash);
												var clusters = existingRenderAction == null ? void 0 : existingRenderAction.lightClusters;
												if (!clusters) {
														var _tempClusterArray_pop;
														clusters = (_tempClusterArray_pop = tempClusterArray.pop()) != null ? _tempClusterArray_pop : new WorldClusters(this.device);
														this._allocated.push(clusters);
														this._clusters.set(hash, ra);
												}
												ra.lightClusters = clusters;
										}
										if (!ra.lightClusters) {
												ra.lightClusters = empty;
										}
								}
						}
				}
				tempClusterArray.forEach((item)=>item.destroy());
				tempClusterArray.length = 0;
		}
		update(renderPasses, lighting) {
				this.assign(renderPasses);
				this._clusters.forEach((renderAction)=>{
						var layer = renderAction.layer;
						var cluster = renderAction.lightClusters;
						cluster.update(layer.clusteredLightsSet, lighting);
				});
		}
		constructor(graphicsDevice){
				this._empty = null;
				this._allocated = [];
				this._clusters = new Map();
				this.device = graphicsDevice;
		}
}

var textureBlitVertexShader$1 = "\n	attribute vec2 vertex_position;\n	varying vec2 uv0;\n	void main(void) {\n		gl_Position = vec4(vertex_position, 0.5, 1.0);\n		uv0 = vertex_position.xy * 0.5 + 0.5;\n		#ifndef WEBGPU\n			uv0.y = 1.0 - uv0.y;\n		#endif\n	}";
var textureBlitFragmentShader$1 = "\n	varying vec2 uv0;\n	uniform sampler2D blitTexture;\n	void main(void) {\n		gl_FragColor = texture2D(blitTexture, uv0);\n	}";
var textureCubeBlitFragmentShader = "\n	varying vec2 uv0;\n	uniform samplerCube blitTexture;\n	uniform mat4 invViewProj;\n	void main(void) {\n		vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n		vec4 worldPos = invViewProj * projPos;\n		gl_FragColor = textureCube(blitTexture, worldPos.xyz);\n	}";
var _viewport$2 = new Vec4();
var _invViewProjMatrices = [];
class RenderPassCookieRenderer extends RenderPass {
		destroy() {
				var _this__quadRenderer2D, _this__quadRendererCube;
				(_this__quadRenderer2D = this._quadRenderer2D) == null ? void 0 : _this__quadRenderer2D.destroy();
				this._quadRenderer2D = null;
				(_this__quadRendererCube = this._quadRendererCube) == null ? void 0 : _this__quadRendererCube.destroy();
				this._quadRendererCube = null;
		}
		static create(renderTarget, cubeSlotsOffsets) {
				var renderPass = new RenderPassCookieRenderer(renderTarget.device, cubeSlotsOffsets);
				renderPass.init(renderTarget);
				renderPass.colorOps.clear = false;
				renderPass.depthStencilOps.clearDepth = false;
				return renderPass;
		}
		update(lights) {
				var filteredLights = this._filteredLights;
				this.filter(lights, filteredLights);
				this.executeEnabled = filteredLights.length > 0;
		}
		filter(lights, filteredLights) {
				for(var i = 0; i < lights.length; i++){
						var light = lights[i];
						if (light._type === LIGHTTYPE_DIRECTIONAL) {
								continue;
						}
						if (!light.atlasViewportAllocated) {
								continue;
						}
						if (!light.atlasSlotUpdated) {
								continue;
						}
						if (light.enabled && light.cookie && light.visibleThisFrame) {
								filteredLights.push(light);
						}
				}
		}
		initInvViewProjMatrices() {
				if (!_invViewProjMatrices.length) {
						for(var face = 0; face < 6; face++){
								var camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
								var projMat = camera.projectionMatrix;
								var viewMat = camera.node.getLocalTransform().clone().invert();
								_invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
						}
				}
		}
		get quadRenderer2D() {
				if (!this._quadRenderer2D) {
						var shader = createShaderFromCode(this.device, textureBlitVertexShader$1, textureBlitFragmentShader$1, 'cookieRenderer2d');
						this._quadRenderer2D = new QuadRender(shader);
				}
				return this._quadRenderer2D;
		}
		get quadRendererCube() {
				if (!this._quadRendererCube) {
						var shader = createShaderFromCode(this.device, textureBlitVertexShader$1, textureCubeBlitFragmentShader, 'cookieRendererCube');
						this._quadRendererCube = new QuadRender(shader);
				}
				return this._quadRendererCube;
		}
		execute() {
				var device = this.device;
				device.setBlendState(BlendState.NOBLEND);
				device.setCullMode(CULLFACE_NONE);
				device.setDepthState(DepthState.NODEPTH);
				device.setStencilState();
				var renderTargetWidth = this.renderTarget.colorBuffer.width;
				var cubeSlotsOffsets = this._cubeSlotsOffsets;
				var filteredLights = this._filteredLights;
				for(var i = 0; i < filteredLights.length; i++){
						var light = filteredLights[i];
						var faceCount = light.numShadowFaces;
						var quad = faceCount > 1 ? this.quadRendererCube : this.quadRenderer2D;
						if (faceCount > 1) {
								this.initInvViewProjMatrices();
						}
						this.blitTextureId.setValue(light.cookie);
						for(var face = 0; face < faceCount; face++){
								_viewport$2.copy(light.atlasViewport);
								if (faceCount > 1) {
										var smallSize = _viewport$2.z / 3;
										var offset = cubeSlotsOffsets[face];
										_viewport$2.x += smallSize * offset.x;
										_viewport$2.y += smallSize * offset.y;
										_viewport$2.z = smallSize;
										_viewport$2.w = smallSize;
										this.invViewProjId.setValue(_invViewProjMatrices[face].data);
								}
								_viewport$2.mulScalar(renderTargetWidth);
								quad.render(_viewport$2);
						}
				}
				filteredLights.length = 0;
		}
		constructor(device, cubeSlotsOffsets){
				super(device), this._quadRenderer2D = null, this._quadRendererCube = null, this._filteredLights = [];
				this._cubeSlotsOffsets = cubeSlotsOffsets;
				this.requiresCubemaps = false;
				this.blitTextureId = device.scope.resolve('blitTexture');
				this.invViewProjId = device.scope.resolve('invViewProj');
		}
}

class RenderPassShadowLocalClustered extends RenderPass {
		update(localLights) {
				var shadowLights = this.shadowRendererLocal.shadowLights;
				var shadowCamera = this.shadowRendererLocal.prepareLights(shadowLights, localLights);
				var count = shadowLights.length;
				this.enabled = count > 0;
				if (count) {
						this.shadowRenderer.setupRenderPass(this, shadowCamera, false);
				}
		}
		execute() {
				var shadowLights = this.shadowRendererLocal.shadowLights;
				var count = shadowLights.length;
				for(var i = 0; i < count; i++){
						var light = shadowLights[i];
						for(var face = 0; face < light.numShadowFaces; face++){
								this.shadowRenderer.renderFace(light, null, face, true);
						}
				}
				shadowLights.length = 0;
		}
		constructor(device, shadowRenderer, shadowRendererLocal){
				super(device);
				this.requiresCubemaps = false;
				this.shadowRenderer = shadowRenderer;
				this.shadowRendererLocal = shadowRendererLocal;
		}
}

class RenderPassUpdateClustered extends RenderPass {
		update(frameGraph, shadowsEnabled, cookiesEnabled, lights, localLights) {
				this.frameGraph = frameGraph;
				this.cookiesRenderPass.enabled = cookiesEnabled;
				if (cookiesEnabled) {
						this.cookiesRenderPass.update(lights);
				}
				this.shadowRenderPass.enabled = shadowsEnabled;
				if (shadowsEnabled) {
						this.shadowRenderPass.update(localLights);
				}
		}
		destroy() {
				this.cookiesRenderPass.destroy();
				this.cookiesRenderPass = null;
		}
		execute() {
				var { renderer } = this;
				var { scene } = renderer;
				renderer.worldClustersAllocator.update(this.frameGraph.renderPasses, scene.lighting);
		}
		constructor(device, renderer, shadowRenderer, shadowRendererLocal, lightTextureAtlas){
				super(device);
				this.renderer = renderer;
				this.frameGraph = null;
				this.cookiesRenderPass = RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget, lightTextureAtlas.cubeSlotsOffsets);
				this.beforePasses.push(this.cookiesRenderPass);
				this.shadowRenderPass = new RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal);
				this.beforePasses.push(this.shadowRenderPass);
		}
}

var _skinUpdateIndex = 0;
var viewProjMat = new Mat4();
var viewInvMat = new Mat4();
var viewMat = new Mat4();
var viewMat3 = new Mat3();
var tempSphere$1 = new BoundingSphere();
var _flipYMat = new Mat4().setScale(1, -1, 1);
var _tempLightSet = new Set();
var _tempLayerSet = new Set();
var _dynamicBindGroup = new DynamicBindGroup();
var _fixProjRangeMat = new Mat4().set([
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		0.5,
		0,
		0,
		0,
		0.5,
		1
]);
var _haltonSequence = [
		new Vec2(0.5, 0.333333),
		new Vec2(0.25, 0.666667),
		new Vec2(0.75, 0.111111),
		new Vec2(0.125, 0.444444),
		new Vec2(0.625, 0.777778),
		new Vec2(0.375, 0.222222),
		new Vec2(0.875, 0.555556),
		new Vec2(0.0625, 0.888889),
		new Vec2(0.5625, 0.037037),
		new Vec2(0.3125, 0.370370),
		new Vec2(0.8125, 0.703704),
		new Vec2(0.1875, 0.148148),
		new Vec2(0.6875, 0.481481),
		new Vec2(0.4375, 0.814815),
		new Vec2(0.9375, 0.259259),
		new Vec2(0.03125, 0.592593)
];
var _tempProjMat0 = new Mat4();
var _tempProjMat1 = new Mat4();
var _tempProjMat2 = new Mat4();
var _tempProjMat3 = new Mat4();
var _tempProjMat4 = new Mat4();
var _tempProjMat5 = new Mat4();
var _tempSet = new Set();
var _tempMeshInstances = [];
var _tempMeshInstancesSkinned = [];
class Renderer {
		destroy() {
				this.shadowRenderer = null;
				this._shadowRendererLocal = null;
				this._shadowRendererDirectional = null;
				this.shadowMapCache.destroy();
				this.shadowMapCache = null;
				this._renderPassUpdateClustered.destroy();
				this._renderPassUpdateClustered = null;
				this.lightTextureAtlas.destroy();
				this.lightTextureAtlas = null;
		}
		setupViewport(camera, renderTarget) {
				var device = this.device;
				var pixelWidth = renderTarget ? renderTarget.width : device.width;
				var pixelHeight = renderTarget ? renderTarget.height : device.height;
				var rect = camera.rect;
				var x = Math.floor(rect.x * pixelWidth);
				var y = Math.floor(rect.y * pixelHeight);
				var w = Math.floor(rect.z * pixelWidth);
				var h = Math.floor(rect.w * pixelHeight);
				device.setViewport(x, y, w, h);
				if (camera._scissorRectClear) {
						var scissorRect = camera.scissorRect;
						x = Math.floor(scissorRect.x * pixelWidth);
						y = Math.floor(scissorRect.y * pixelHeight);
						w = Math.floor(scissorRect.z * pixelWidth);
						h = Math.floor(scissorRect.w * pixelHeight);
				}
				device.setScissor(x, y, w, h);
		}
		setCameraUniforms(camera, target) {
				var flipY = target == null ? void 0 : target.flipY;
				var viewCount = 1;
				if (camera.xr && camera.xr.session) {
						var _camera__node_parent, _camera__node;
						var transform = ((_camera__node = camera._node) == null ? void 0 : (_camera__node_parent = _camera__node.parent) == null ? void 0 : _camera__node_parent.getWorldTransform()) || null;
						var views = camera.xr.views;
						viewCount = views.list.length;
						for(var v = 0; v < viewCount; v++){
								var view = views.list[v];
								view.updateTransforms(transform);
								camera.frustum.setFromMat4(view.projViewOffMat);
						}
				} else {
						var projMat = camera.projectionMatrix;
						if (camera.calculateProjection) {
								camera.calculateProjection(projMat, VIEW_CENTER);
						}
						var projMatSkybox = camera.getProjectionMatrixSkybox();
						if (flipY) {
								projMat = _tempProjMat0.mul2(_flipYMat, projMat);
								projMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);
						}
						if (this.device.isWebGPU) {
								projMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);
								projMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);
						}
						var { jitter } = camera;
						var jitterX = 0;
						var jitterY = 0;
						if (jitter > 0) {
								var targetWidth = target ? target.width : this.device.width;
								var targetHeight = target ? target.height : this.device.height;
								var offset = _haltonSequence[this.device.renderVersion % _haltonSequence.length];
								jitterX = jitter * (offset.x * 2 - 1) / targetWidth;
								jitterY = jitter * (offset.y * 2 - 1) / targetHeight;
								projMat = _tempProjMat4.copy(projMat);
								projMat.data[8] = jitterX;
								projMat.data[9] = jitterY;
								projMatSkybox = _tempProjMat5.copy(projMatSkybox);
								projMatSkybox.data[8] = jitterX;
								projMatSkybox.data[9] = jitterY;
								if (this.blueNoiseJitterVersion !== this.device.renderVersion) {
										this.blueNoiseJitterVersion = this.device.renderVersion;
										this.blueNoise.vec4(this.blueNoiseJitterVec);
								}
						}
						var jitterVec = jitter > 0 ? this.blueNoiseJitterVec : Vec4.ZERO;
						this.blueNoiseJitterData[0] = jitterVec.x;
						this.blueNoiseJitterData[1] = jitterVec.y;
						this.blueNoiseJitterData[2] = jitterVec.z;
						this.blueNoiseJitterData[3] = jitterVec.w;
						this.blueNoiseJitterId.setValue(this.blueNoiseJitterData);
						this.projId.setValue(projMat.data);
						this.projSkyboxId.setValue(projMatSkybox.data);
						if (camera.calculateTransform) {
								camera.calculateTransform(viewInvMat, VIEW_CENTER);
						} else {
								var pos = camera._node.getPosition();
								var rot = camera._node.getRotation();
								viewInvMat.setTRS(pos, rot, Vec3.ONE);
						}
						this.viewInvId.setValue(viewInvMat.data);
						viewMat.copy(viewInvMat).invert();
						this.viewId.setValue(viewMat.data);
						viewMat3.setFromMat4(viewMat);
						this.viewId3.setValue(viewMat3.data);
						viewProjMat.mul2(projMat, viewMat);
						this.viewProjId.setValue(viewProjMat.data);
						camera._storeShaderMatrices(viewProjMat, jitterX, jitterY, this.device.renderVersion);
						this.flipYId.setValue(flipY ? -1 : 1);
						this.dispatchViewPos(camera._node.getPosition());
						camera.frustum.setFromMat4(viewProjMat);
				}
				this.tbnBasis.setValue(flipY ? -1 : 1);
				var n = camera._nearClip;
				var f = camera._farClip;
				this.nearClipId.setValue(n);
				this.farClipId.setValue(f);
				this.cameraParams[0] = 1 / f;
				this.cameraParams[1] = f;
				this.cameraParams[2] = n;
				this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
				this.cameraParamsId.setValue(this.cameraParams);
				this.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);
				return viewCount;
		}
		clear(camera, clearColor, clearDepth, clearStencil) {
				var flags = ((clearColor != null ? clearColor : camera._clearColorBuffer) ? CLEARFLAG_COLOR : 0) | ((clearDepth != null ? clearDepth : camera._clearDepthBuffer) ? CLEARFLAG_DEPTH : 0) | ((clearStencil != null ? clearStencil : camera._clearStencilBuffer) ? CLEARFLAG_STENCIL : 0);
				if (flags) {
						var device = this.device;
						device.clear({
								color: [
										camera._clearColor.r,
										camera._clearColor.g,
										camera._clearColor.b,
										camera._clearColor.a
								],
								depth: camera._clearDepth,
								stencil: camera._clearStencil,
								flags: flags
						});
				}
		}
		setCamera(camera, target, clear, renderAction) {
				this.setCameraUniforms(camera, target);
				this.clearView(camera, target, clear, false);
		}
		clearView(camera, target, clear, forceWrite) {
				var device = this.device;
				device.setRenderTarget(target);
				device.updateBegin();
				if (forceWrite) {
						device.setColorWrite(true, true, true, true);
						device.setDepthWrite(true);
				}
				this.setupViewport(camera, target);
				if (clear) {
						var options = camera._clearOptions;
						device.clear(options ? options : {
								color: [
										camera._clearColor.r,
										camera._clearColor.g,
										camera._clearColor.b,
										camera._clearColor.a
								],
								depth: camera._clearDepth,
								flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
								stencil: camera._clearStencil
						});
				}
		}
		setupCullMode(cullFaces, flipFactor, drawCall) {
				var material = drawCall.material;
				var mode = CULLFACE_NONE;
				if (cullFaces) {
						var flipFaces = 1;
						if (material.cull === CULLFACE_FRONT || material.cull === CULLFACE_BACK) {
								flipFaces = flipFactor * drawCall.flipFacesFactor * drawCall.node.worldScaleSign;
						}
						if (flipFaces < 0) {
								mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
						} else {
								mode = material.cull;
						}
				}
				this.device.setCullMode(mode);
				if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
						this.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);
				}
		}
		updateCameraFrustum(camera) {
				if (camera.xr && camera.xr.views.list.length) {
						var view = camera.xr.views.list[0];
						viewProjMat.mul2(view.projMat, view.viewOffMat);
						camera.frustum.setFromMat4(viewProjMat);
						return;
				}
				var projMat = camera.projectionMatrix;
				if (camera.calculateProjection) {
						camera.calculateProjection(projMat, VIEW_CENTER);
				}
				if (camera.calculateTransform) {
						camera.calculateTransform(viewInvMat, VIEW_CENTER);
				} else {
						var pos = camera._node.getPosition();
						var rot = camera._node.getRotation();
						viewInvMat.setTRS(pos, rot, Vec3.ONE);
						this.viewInvId.setValue(viewInvMat.data);
				}
				viewMat.copy(viewInvMat).invert();
				viewProjMat.mul2(projMat, viewMat);
				camera.frustum.setFromMat4(viewProjMat);
		}
		setBaseConstants(device, material) {
				device.setCullMode(material.cull);
				if (material.opacityMap) {
						this.opacityMapId.setValue(material.opacityMap);
				}
				if (material.opacityMap || material.alphaTest > 0) {
						this.alphaTestId.setValue(material.alphaTest);
				}
		}
		updateCpuSkinMatrices(drawCalls) {
				_skinUpdateIndex++;
				var drawCallsCount = drawCalls.length;
				if (drawCallsCount === 0) return;
				for(var i = 0; i < drawCallsCount; i++){
						var si = drawCalls[i].skinInstance;
						if (si) {
								si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
								si._dirty = true;
						}
				}
		}
		updateGpuSkinMatrices(drawCalls) {
				for (var drawCall of drawCalls){
						var skin = drawCall.skinInstance;
						if (skin && skin._dirty) {
								skin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);
								skin._dirty = false;
						}
				}
		}
		updateMorphing(drawCalls) {
				for (var drawCall of drawCalls){
						var morphInst = drawCall.morphInstance;
						if (morphInst && morphInst._dirty) {
								morphInst.update();
						}
				}
		}
		updateGSplats(drawCalls) {
				for (var drawCall of drawCalls){
						var _drawCall_gsplatInstance;
						(_drawCall_gsplatInstance = drawCall.gsplatInstance) == null ? void 0 : _drawCall_gsplatInstance.update();
				}
		}
		gpuUpdate(drawCalls) {
				this.updateGpuSkinMatrices(drawCalls);
				this.updateMorphing(drawCalls);
				this.updateGSplats(drawCalls);
		}
		setVertexBuffers(device, mesh) {
				device.setVertexBuffer(mesh.vertexBuffer);
		}
		setMorphing(device, morphInstance) {
				if (morphInstance) {
						morphInstance.prepareRendering(device);
						device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
						this.morphPositionTex.setValue(morphInstance.texturePositions);
						this.morphNormalTex.setValue(morphInstance.textureNormals);
						this.morphTexParams.setValue(morphInstance._textureParams);
				}
		}
		setSkinning(device, meshInstance) {
				var skinInstance = meshInstance.skinInstance;
				if (skinInstance) {
						this._skinDrawCalls++;
						var boneTexture = skinInstance.boneTexture;
						this.boneTextureId.setValue(boneTexture);
						this.boneTextureSizeId.setValue(skinInstance.boneTextureSize);
				}
		}
		dispatchViewPos(position) {
				var vp = this.viewPos;
				vp[0] = position.x;
				vp[1] = position.y;
				vp[2] = position.z;
				this.viewPosId.setValue(vp);
		}
		initViewBindGroupFormat(isClustered) {
				if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
						var uniforms = [
								new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4),
								new UniformFormat('cubeMapRotationMatrix', UNIFORMTYPE_MAT3),
								new UniformFormat('view_position', UNIFORMTYPE_VEC3),
								new UniformFormat('skyboxIntensity', UNIFORMTYPE_FLOAT),
								new UniformFormat('exposure', UNIFORMTYPE_FLOAT),
								new UniformFormat('textureBias', UNIFORMTYPE_FLOAT)
						];
						if (isClustered) {
								uniforms.push(...[
										new UniformFormat('clusterCellsCountByBoundsSize', UNIFORMTYPE_VEC3),
										new UniformFormat('clusterTextureSize', UNIFORMTYPE_VEC3),
										new UniformFormat('clusterBoundsMin', UNIFORMTYPE_VEC3),
										new UniformFormat('clusterBoundsDelta', UNIFORMTYPE_VEC3),
										new UniformFormat('clusterCellsDot', UNIFORMTYPE_VEC3),
										new UniformFormat('clusterCellsMax', UNIFORMTYPE_VEC3),
										new UniformFormat('shadowAtlasParams', UNIFORMTYPE_VEC2),
										new UniformFormat('clusterMaxCells', UNIFORMTYPE_INT),
										new UniformFormat('clusterSkip', UNIFORMTYPE_FLOAT)
								]);
						}
						this.viewUniformFormat = new UniformBufferFormat(this.device, uniforms);
						var formats = [
								new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT),
								new BindTextureFormat('lightsTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT),
								new BindTextureFormat('shadowAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_DEPTH),
								new BindTextureFormat('cookieAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT),
								new BindTextureFormat('areaLightsLutTex1', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT),
								new BindTextureFormat('areaLightsLutTex2', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT)
						];
						if (isClustered) {
								formats.push(...[
										new BindTextureFormat('clusterWorldTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT)
								]);
						}
						this.viewBindGroupFormat = new BindGroupFormat(this.device, formats);
				}
		}
		setupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {
				var device = this.device;
				while(viewBindGroups.length < viewCount){
						var ub = new UniformBuffer(device, viewUniformFormat, false);
						var bg = new BindGroup(device, viewBindGroupFormat, ub);
						viewBindGroups.push(bg);
				}
				var viewBindGroup = viewBindGroups[0];
				viewBindGroup.defaultUniformBuffer.update();
				viewBindGroup.update();
				device.setBindGroup(BINDGROUP_VIEW, viewBindGroup);
		}
		setupMeshUniformBuffers(shaderInstance, meshInstance) {
				var device = this.device;
				if (device.supportsUniformBuffers) {
						this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);
						this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
						var meshBindGroup = shaderInstance.getBindGroup(device);
						meshBindGroup.update();
						device.setBindGroup(BINDGROUP_MESH, meshBindGroup);
						var meshUniformBuffer = shaderInstance.getUniformBuffer(device);
						meshUniformBuffer.update(_dynamicBindGroup);
						device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup.bindGroup, _dynamicBindGroup.offsets);
				}
		}
		drawInstance(device, meshInstance, mesh, style, normal) {
				var modelMatrix = meshInstance.node.worldTransform;
				this.modelMatrixId.setValue(modelMatrix.data);
				if (normal) {
						this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
				}
				var instancingData = meshInstance.instancingData;
				if (instancingData) {
						if (instancingData.count > 0) {
								this._instancedDrawCalls++;
								device.setVertexBuffer(instancingData.vertexBuffer);
								device.draw(mesh.primitive[style], instancingData.count);
						} else {
								device.clearVertexBuffer();
								device.clearIndexBuffer();
						}
				} else {
						device.draw(mesh.primitive[style]);
				}
		}
		drawInstance2(device, meshInstance, mesh, style) {
				var instancingData = meshInstance.instancingData;
				if (instancingData) {
						if (instancingData.count > 0) {
								this._instancedDrawCalls++;
								device.draw(mesh.primitive[style], instancingData.count, true);
						} else {
								device.clearVertexBuffer();
								device.clearIndexBuffer();
						}
				} else {
						device.draw(mesh.primitive[style], undefined, true);
				}
		}
		cull(camera, drawCalls, culledInstances) {
				var opaque = culledInstances.opaque;
				opaque.length = 0;
				var transparent = culledInstances.transparent;
				transparent.length = 0;
				var doCull = camera.frustumCulling;
				var count = drawCalls.length;
				for(var i = 0; i < count; i++){
						var drawCall = drawCalls[i];
						if (drawCall.visible) {
								var visible = !doCull || !drawCall.cull || drawCall._isVisible(camera);
								if (visible) {
										drawCall.visibleThisFrame = true;
										var bucket = drawCall.transparent ? transparent : opaque;
										bucket.push(drawCall);
										if (drawCall.skinInstance || drawCall.morphInstance || drawCall.gsplatInstance) {
												this.processingMeshInstances.add(drawCall);
												if (drawCall.gsplatInstance) {
														drawCall.gsplatInstance.cameras.push(camera);
												}
										}
								}
						}
				}
		}
		collectLights(comp) {
				this.lights.length = 0;
				this.localLights.length = 0;
				var stats = this.scene._stats;
				var count = comp.layerList.length;
				for(var i = 0; i < count; i++){
						var layer = comp.layerList[i];
						if (!_tempLayerSet.has(layer)) {
								_tempLayerSet.add(layer);
								var lights = layer._lights;
								for(var j = 0; j < lights.length; j++){
										var light = lights[j];
										if (!_tempLightSet.has(light)) {
												_tempLightSet.add(light);
												this.lights.push(light);
												if (light._type !== LIGHTTYPE_DIRECTIONAL) {
														this.localLights.push(light);
												}
										}
								}
						}
				}
				stats.lights = this.lights.length;
				_tempLightSet.clear();
				_tempLayerSet.clear();
		}
		cullLights(camera, lights) {
				var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
				var physicalUnits = this.scene.physicalUnits;
				for(var i = 0; i < lights.length; i++){
						var light = lights[i];
						if (light.enabled) {
								if (light._type !== LIGHTTYPE_DIRECTIONAL) {
										light.getBoundingSphere(tempSphere$1);
										if (camera.frustum.containsSphere(tempSphere$1)) {
												light.visibleThisFrame = true;
												light.usePhysicalUnits = physicalUnits;
												var screenSize = camera.getScreenSize(tempSphere$1);
												light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
										} else {
												if (!clusteredLightingEnabled) {
														if (light.castShadows && !light.shadowMap) {
																light.visibleThisFrame = true;
														}
												}
										}
								} else {
										light.usePhysicalUnits = this.scene.physicalUnits;
								}
						}
				}
		}
		cullShadowmaps(comp) {
				var isClustered = this.scene.clusteredLightingEnabled;
				for(var i = 0; i < this.localLights.length; i++){
						var light = this.localLights[i];
						if (light._type !== LIGHTTYPE_DIRECTIONAL) {
								if (isClustered) {
										if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
												light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
										}
								} else {
										if (light.shadowUpdateMode === SHADOWUPDATE_NONE && light.castShadows) {
												if (!light.getRenderData(null, 0).shadowCamera.renderTarget) {
														light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
												}
										}
								}
								if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
										this._shadowRendererLocal.cull(light, comp);
								}
						}
				}
				this.cameraDirShadowLights.clear();
				var cameras = comp.cameras;
				for(var i1 = 0; i1 < cameras.length; i1++){
						var cameraComponent = cameras[i1];
						if (cameraComponent.enabled) {
								var camera = cameraComponent.camera;
								var lightList = void 0;
								var cameraLayers = camera.layers;
								for(var l = 0; l < cameraLayers.length; l++){
										var cameraLayer = comp.getLayerById(cameraLayers[l]);
										if (cameraLayer) {
												var layerDirLights = cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];
												for(var j = 0; j < layerDirLights.length; j++){
														var light1 = layerDirLights[j];
														if (light1.castShadows && !_tempSet.has(light1)) {
																_tempSet.add(light1);
																lightList = lightList != null ? lightList : [];
																lightList.push(light1);
																this._shadowRendererDirectional.cull(light1, comp, camera);
														}
												}
										}
								}
								if (lightList) {
										this.cameraDirShadowLights.set(camera, lightList);
								}
								_tempSet.clear();
						}
				}
		}
		cullComposition(comp) {
				var { scene } = this;
				this.processingMeshInstances.clear();
				var numCameras = comp.cameras.length;
				this._camerasRendered += numCameras;
				for(var i = 0; i < numCameras; i++){
						var camera = comp.cameras[i];
						scene == null ? void 0 : scene.fire(EVENT_PRECULL, camera);
						var renderTarget = camera.renderTarget;
						camera.frameUpdate(renderTarget);
						this.updateCameraFrustum(camera.camera);
						var layerIds = camera.layers;
						for(var j = 0; j < layerIds.length; j++){
								var layer = comp.getLayerById(layerIds[j]);
								if (layer && layer.enabled) {
										this.cullLights(camera.camera, layer._lights);
										var culledInstances = layer.getCulledInstances(camera.camera);
										this.cull(camera.camera, layer.meshInstances, culledInstances);
								}
						}
						scene == null ? void 0 : scene.fire(EVENT_POSTCULL, camera);
				}
				if (scene.clusteredLightingEnabled) {
						this.updateLightTextureAtlas();
				}
				this.cullShadowmaps(comp);
		}
		updateShaders(drawCalls, onlyLitShaders) {
				var count = drawCalls.length;
				for(var i = 0; i < count; i++){
						var mat = drawCalls[i].material;
						if (mat) {
								if (!_tempSet.has(mat)) {
										_tempSet.add(mat);
										if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
												if (onlyLitShaders) {
														if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) {
																continue;
														}
												}
												mat.clearVariants();
										}
								}
						}
				}
				_tempSet.clear();
		}
		updateFrameUniforms() {
				this.blueNoiseTextureId.setValue(getBlueNoiseTexture(this.device));
		}
		beginFrame(comp) {
				var scene = this.scene;
				var updateShaders = scene.updateShaders || this.device._shadersDirty;
				var layers = comp.layerList;
				var layerCount = layers.length;
				for(var i = 0; i < layerCount; i++){
						var layer = layers[i];
						var meshInstances = layer.meshInstances;
						var count = meshInstances.length;
						for(var j = 0; j < count; j++){
								var meshInst = meshInstances[j];
								meshInst.visibleThisFrame = false;
								if (updateShaders) {
										_tempMeshInstances.push(meshInst);
								}
								if (meshInst.skinInstance) {
										_tempMeshInstancesSkinned.push(meshInst);
								}
						}
				}
				if (updateShaders) {
						var onlyLitShaders = !scene.updateShaders || !this.device._shadersDirty;
						this.updateShaders(_tempMeshInstances, onlyLitShaders);
						scene.updateShaders = false;
						this.device._shadersDirty = false;
						scene._shaderVersion++;
				}
				this.updateFrameUniforms();
				this.updateCpuSkinMatrices(_tempMeshInstancesSkinned);
				_tempMeshInstances.length = 0;
				_tempMeshInstancesSkinned.length = 0;
				var lights = this.lights;
				var lightCount = lights.length;
				for(var i1 = 0; i1 < lightCount; i1++){
						lights[i1].beginFrame();
				}
		}
		updateLightTextureAtlas() {
				this.lightTextureAtlas.update(this.localLights, this.scene.lighting);
		}
		updateLayerComposition(comp) {
				var len = comp.layerList.length;
				var scene = this.scene;
				var shaderVersion = scene._shaderVersion;
				for(var i = 0; i < len; i++){
						var layer = comp.layerList[i];
						layer._shaderVersion = shaderVersion;
				}
				comp._update();
		}
		frameUpdate() {
				this.clustersDebugRendered = false;
				this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);
				this.dirLightShadows.clear();
		}
		constructor(graphicsDevice){
				this.clustersDebugRendered = false;
				this.processingMeshInstances = new Set();
				this.lights = [];
				this.localLights = [];
				this.cameraDirShadowLights = new Map();
				this.dirLightShadows = new Map();
				this.blueNoise = new BlueNoise(123);
				this.device = graphicsDevice;
				this.scene = null;
				this.worldClustersAllocator = new WorldClustersAllocator(graphicsDevice);
				this.lightTextureAtlas = new LightTextureAtlas(graphicsDevice);
				this.shadowMapCache = new ShadowMapCache();
				this.shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
				this._shadowRendererLocal = new ShadowRendererLocal(this, this.shadowRenderer);
				this._shadowRendererDirectional = new ShadowRendererDirectional(this, this.shadowRenderer);
				this._renderPassUpdateClustered = new RenderPassUpdateClustered(this.device, this, this.shadowRenderer, this._shadowRendererLocal, this.lightTextureAtlas);
				this.viewUniformFormat = null;
				this.viewBindGroupFormat = null;
				this._skinTime = 0;
				this._morphTime = 0;
				this._cullTime = 0;
				this._shadowMapTime = 0;
				this._lightClustersTime = 0;
				this._layerCompositionUpdateTime = 0;
				this._shadowDrawCalls = 0;
				this._skinDrawCalls = 0;
				this._instancedDrawCalls = 0;
				this._shadowMapUpdates = 0;
				this._numDrawCallsCulled = 0;
				this._camerasRendered = 0;
				this._lightClusters = 0;
				var scope = graphicsDevice.scope;
				this.boneTextureId = scope.resolve('texture_poseMap');
				this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
				this.modelMatrixId = scope.resolve('matrix_model');
				this.normalMatrixId = scope.resolve('matrix_normal');
				this.viewInvId = scope.resolve('matrix_viewInverse');
				this.viewPos = new Float32Array(3);
				this.viewPosId = scope.resolve('view_position');
				this.projId = scope.resolve('matrix_projection');
				this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
				this.viewId = scope.resolve('matrix_view');
				this.viewId3 = scope.resolve('matrix_view3');
				this.viewProjId = scope.resolve('matrix_viewProjection');
				this.flipYId = scope.resolve('projectionFlipY');
				this.tbnBasis = scope.resolve('tbnBasis');
				this.nearClipId = scope.resolve('camera_near');
				this.farClipId = scope.resolve('camera_far');
				this.cameraParams = new Float32Array(4);
				this.cameraParamsId = scope.resolve('camera_params');
				this.viewIndexId = scope.resolve('view_index');
				this.blueNoiseJitterVersion = 0;
				this.blueNoiseJitterVec = new Vec4();
				this.blueNoiseJitterData = new Float32Array(4);
				this.blueNoiseJitterId = scope.resolve('blueNoiseJitter');
				this.blueNoiseTextureId = scope.resolve('blueNoiseTex32');
				this.alphaTestId = scope.resolve('alpha_ref');
				this.opacityMapId = scope.resolve('texture_opacityMap');
				this.exposureId = scope.resolve('exposure');
				this.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');
				this.twoSidedLightingNegScaleFactorId.setValue(0);
				this.morphPositionTex = scope.resolve('morphPositionTex');
				this.morphNormalTex = scope.resolve('morphNormalTex');
				this.morphTexParams = scope.resolve('morph_tex_params');
				this.lightCube = new LightCube();
				this.constantLightCube = scope.resolve('lightCube[0]');
		}
}

class RenderAction {
		destroy() {
				this.viewBindGroups.forEach((bg)=>{
						bg.defaultUniformBuffer.destroy();
						bg.destroy();
				});
				this.viewBindGroups.length = 0;
		}
		setupClears(camera, layer) {
				this.clearColor = (camera == null ? void 0 : camera.clearColorBuffer) || layer.clearColorBuffer;
				this.clearDepth = (camera == null ? void 0 : camera.clearDepthBuffer) || layer.clearDepthBuffer;
				this.clearStencil = (camera == null ? void 0 : camera.clearStencilBuffer) || layer.clearStencilBuffer;
		}
		constructor(){
				this.camera = null;
				this.layer = null;
				this.transparent = false;
				this.renderTarget = null;
				this.lightClusters = null;
				this.clearColor = false;
				this.clearDepth = false;
				this.clearStencil = false;
				this.triggerPostprocess = false;
				this.firstCameraUse = false;
				this.lastCameraUse = false;
				this.viewBindGroups = [];
				this.useCameraPasses = false;
		}
}

class RenderPassForward extends RenderPass {
		get rendersAnything() {
				return this.renderActions.length > 0;
		}
		addRenderAction(renderAction) {
				this.renderActions.push(renderAction);
		}
		addLayer(cameraComponent, layer, transparent, autoClears) {
				if (autoClears === void 0) autoClears = true;
				var ra = new RenderAction();
				ra.renderTarget = this.renderTarget;
				ra.camera = cameraComponent;
				ra.layer = layer;
				ra.transparent = transparent;
				if (autoClears) {
						var firstRa = this.renderActions.length === 0;
						ra.setupClears(firstRa ? cameraComponent : undefined, layer);
				}
				this.addRenderAction(ra);
		}
		addLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent) {
				if (lastLayerIsTransparent === void 0) lastLayerIsTransparent = true;
				var { layerList, subLayerList } = composition;
				var clearRenderTarget = firstLayerClears;
				var index = startIndex;
				while(index < layerList.length){
						var layer = layerList[index];
						var isTransparent = subLayerList[index];
						var renderedByCamera = cameraComponent.camera.layersSet.has(layer.id);
						if (renderedByCamera) {
								this.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);
								clearRenderTarget = false;
						}
						index++;
						if (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {
								break;
						}
				}
				return index;
		}
		updateDirectionalShadows() {
				var { renderer, renderActions } = this;
				for(var i = 0; i < renderActions.length; i++){
						var renderAction = renderActions[i];
						var cameraComp = renderAction.camera;
						var camera = cameraComp.camera;
						var shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);
						if (shadowDirLights) {
								for(var l = 0; l < shadowDirLights.length; l++){
										var light = shadowDirLights[l];
										if (renderer.dirLightShadows.get(light) !== camera) {
												renderer.dirLightShadows.set(light, camera);
												var shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);
												if (shadowPass) {
														this.beforePasses.push(shadowPass);
												}
										}
								}
						}
				}
		}
		updateClears() {
				var renderAction = this.renderActions[0];
				if (renderAction) {
						var cameraComponent = renderAction.camera;
						var camera = cameraComponent.camera;
						var fullSizeClearRect = camera.fullSizeClearRect;
						this.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : undefined);
						this.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : undefined);
						this.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : undefined);
				}
		}
		frameUpdate() {
				super.frameUpdate();
				this.updateDirectionalShadows();
				this.updateClears();
		}
		before() {
				var { renderActions } = this;
				for(var i = 0; i < renderActions.length; i++){
						var ra = renderActions[i];
						if (ra.firstCameraUse) {
								this.scene.fire(EVENT_PRERENDER, ra.camera);
						}
				}
		}
		execute() {
				var { layerComposition, renderActions } = this;
				for(var i = 0; i < renderActions.length; i++){
						var ra = renderActions[i];
						var layer = ra.layer;
						if (layerComposition.isEnabled(layer, ra.transparent)) {
								this.renderRenderAction(ra, i === 0);
						}
				}
		}
		after() {
				for(var i = 0; i < this.renderActions.length; i++){
						var ra = this.renderActions[i];
						if (ra.lastCameraUse) {
								this.scene.fire(EVENT_POSTRENDER, ra.camera);
						}
				}
				this.beforePasses.length = 0;
		}
		renderRenderAction(renderAction, firstRenderAction) {
				var { renderer, scene } = this;
				var device = renderer.device;
				var { layer, transparent, camera } = renderAction;
				if (camera) {
						var _camera_camera_shaderPassInfo;
						var originalGammaCorrection = camera.gammaCorrection;
						var originalToneMapping = camera.toneMapping;
						if (this.gammaCorrection !== undefined) camera.gammaCorrection = this.gammaCorrection;
						if (this.toneMapping !== undefined) camera.toneMapping = this.toneMapping;
						scene.fire(EVENT_PRERENDER_LAYER, camera, layer, transparent);
						var options = {
								lightClusters: renderAction.lightClusters
						};
						var _camera_camera_shaderPassInfo_index;
						var shaderPass = (_camera_camera_shaderPassInfo_index = (_camera_camera_shaderPassInfo = camera.camera.shaderPassInfo) == null ? void 0 : _camera_camera_shaderPassInfo.index) != null ? _camera_camera_shaderPassInfo_index : SHADER_FORWARD;
						if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
								options.clearColor = renderAction.clearColor;
								options.clearDepth = renderAction.clearDepth;
								options.clearStencil = renderAction.clearStencil;
						}
						var _renderAction_renderTarget;
						var renderTarget = (_renderAction_renderTarget = renderAction.renderTarget) != null ? _renderAction_renderTarget : device.backBuffer;
						renderer.renderForwardLayer(camera.camera, renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options);
						device.setBlendState(BlendState.NOBLEND);
						device.setStencilState(null, null);
						device.setAlphaToCoverage(false);
						scene.fire(EVENT_POSTRENDER_LAYER, camera, layer, transparent);
						if (this.gammaCorrection !== undefined) camera.gammaCorrection = originalGammaCorrection;
						if (this.toneMapping !== undefined) camera.toneMapping = originalToneMapping;
				}
		}
		constructor(device, layerComposition, scene, renderer){
				super(device), this.renderActions = [], this.noDepthClear = false;
				this.layerComposition = layerComposition;
				this.scene = scene;
				this.renderer = renderer;
		}
}

class RenderPassPostprocessing extends RenderPass {
		execute() {
				var renderAction = this.renderAction;
				var camera = renderAction.camera;
				camera.onPostprocessing();
		}
		constructor(device, renderer, renderAction){
				super(device);
				this.renderer = renderer;
				this.renderAction = renderAction;
				this.requiresCubemaps = false;
		}
}

var _noLights = [
		[],
		[],
		[]
];
var tmpColor$1 = new Color();
var _drawCallList = {
		drawCalls: [],
		shaderInstances: [],
		isNewMaterial: [],
		lightMaskChanged: [],
		clear: function clear() {
				this.drawCalls.length = 0;
				this.shaderInstances.length = 0;
				this.isNewMaterial.length = 0;
				this.lightMaskChanged.length = 0;
		}
};
function vogelDiskPrecalculationSamples(numSamples) {
		var samples = [];
		for(var i = 0; i < numSamples; ++i){
				var r = Math.sqrt(i + 0.5) / Math.sqrt(numSamples);
				samples.push(r);
		}
		return samples;
}
function vogelSpherePrecalculationSamples(numSamples) {
		var samples = [];
		for(var i = 0; i < numSamples; i++){
				var weight = i / numSamples;
				var radius = Math.sqrt(weight * weight);
				samples.push(radius);
		}
		return samples;
}
class ForwardRenderer extends Renderer {
		destroy() {
				super.destroy();
		}
		dispatchGlobalLights(scene) {
				var ambientUniform = this.ambientColor;
				tmpColor$1.linear(scene.ambientLight);
				ambientUniform[0] = tmpColor$1.r;
				ambientUniform[1] = tmpColor$1.g;
				ambientUniform[2] = tmpColor$1.b;
				if (scene.physicalUnits) {
						for(var i = 0; i < 3; i++){
								ambientUniform[i] *= scene.ambientLuminance;
						}
				}
				this.ambientId.setValue(ambientUniform);
				this.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);
				this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);
		}
		_resolveLight(scope, i) {
				var light = "light" + i;
				this.lightColorId[i] = scope.resolve("" + light + "_color");
				this.lightDir[i] = new Float32Array(3);
				this.lightDirId[i] = scope.resolve("" + light + "_direction");
				this.lightShadowMapId[i] = scope.resolve("" + light + "_shadowMap");
				this.lightShadowMatrixId[i] = scope.resolve("" + light + "_shadowMatrix");
				this.lightShadowParamsId[i] = scope.resolve("" + light + "_shadowParams");
				this.lightShadowIntensity[i] = scope.resolve("" + light + "_shadowIntensity");
				this.lightShadowSearchAreaId[i] = scope.resolve("" + light + "_shadowSearchArea");
				this.lightRadiusId[i] = scope.resolve("" + light + "_radius");
				this.lightPos[i] = new Float32Array(3);
				this.lightPosId[i] = scope.resolve("" + light + "_position");
				this.lightWidth[i] = new Float32Array(3);
				this.lightWidthId[i] = scope.resolve("" + light + "_halfWidth");
				this.lightHeight[i] = new Float32Array(3);
				this.lightHeightId[i] = scope.resolve("" + light + "_halfHeight");
				this.lightInAngleId[i] = scope.resolve("" + light + "_innerConeAngle");
				this.lightOutAngleId[i] = scope.resolve("" + light + "_outerConeAngle");
				this.lightCookieId[i] = scope.resolve("" + light + "_cookie");
				this.lightCookieIntId[i] = scope.resolve("" + light + "_cookieIntensity");
				this.lightCookieMatrixId[i] = scope.resolve("" + light + "_cookieMatrix");
				this.lightCookieOffsetId[i] = scope.resolve("" + light + "_cookieOffset");
				this.lightCameraParamsId[i] = scope.resolve("" + light + "_cameraParams");
				this.lightSoftShadowParamsId[i] = scope.resolve("" + light + "_softShadowParams");
				this.shadowMatrixPaletteId[i] = scope.resolve("" + light + "_shadowMatrixPalette[0]");
				this.shadowCascadeDistancesId[i] = scope.resolve("" + light + "_shadowCascadeDistances");
				this.shadowCascadeCountId[i] = scope.resolve("" + light + "_shadowCascadeCount");
				this.shadowCascadeBlendId[i] = scope.resolve("" + light + "_shadowCascadeBlend");
		}
		setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
				this.lightPos[cnt][0] = campos.x - dir.x * far;
				this.lightPos[cnt][1] = campos.y - dir.y * far;
				this.lightPos[cnt][2] = campos.z - dir.z * far;
				this.lightPosId[cnt].setValue(this.lightPos[cnt]);
				var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
				this.lightWidth[cnt][0] = hWidth.x * far;
				this.lightWidth[cnt][1] = hWidth.y * far;
				this.lightWidth[cnt][2] = hWidth.z * far;
				this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
				var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
				this.lightHeight[cnt][0] = hHeight.x * far;
				this.lightHeight[cnt][1] = hHeight.y * far;
				this.lightHeight[cnt][2] = hHeight.z * far;
				this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		}
		dispatchDirectLights(dirs, mask, camera) {
				var cnt = 0;
				var scope = this.device.scope;
				for(var i = 0; i < dirs.length; i++){
						if (!(dirs[i].mask & mask)) continue;
						var directional = dirs[i];
						var wtm = directional._node.getWorldTransform();
						if (!this.lightColorId[cnt]) {
								this._resolveLight(scope, cnt);
						}
						this.lightColorId[cnt].setValue(directional._colorLinear);
						wtm.getY(directional._direction).mulScalar(-1);
						directional._direction.normalize();
						this.lightDir[cnt][0] = directional._direction.x;
						this.lightDir[cnt][1] = directional._direction.y;
						this.lightDir[cnt][2] = directional._direction.z;
						this.lightDirId[cnt].setValue(this.lightDir[cnt]);
						if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
								this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
						}
						if (directional.castShadows) {
								var lightRenderData = directional.getRenderData(camera, 0);
								var biases = directional._getUniformBiasValues(lightRenderData);
								this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
								this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
								this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
								this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
								this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
								this.shadowCascadeBlendId[cnt].setValue(1 - directional.cascadeBlend);
								this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);
								this.lightSoftShadowParamsId[cnt].setValue(directional._softShadowParams);
								var shadowRT = lightRenderData.shadowCamera.renderTarget;
								if (shadowRT) {
										this.lightShadowSearchAreaId[cnt].setValue(directional.penumbraSize / lightRenderData.shadowCamera.renderTarget.width * lightRenderData.projectionCompensation);
								}
								var cameraParams = directional._shadowCameraParams;
								cameraParams.length = 4;
								cameraParams[0] = 0;
								cameraParams[1] = lightRenderData.shadowCamera._farClip;
								cameraParams[2] = lightRenderData.shadowCamera._nearClip;
								cameraParams[3] = 1;
								this.lightCameraParamsId[cnt].setValue(cameraParams);
								var params = directional._shadowRenderParams;
								params.length = 4;
								params[0] = directional._shadowResolution;
								params[1] = biases.normalBias;
								params[2] = biases.bias;
								params[3] = 0;
								this.lightShadowParamsId[cnt].setValue(params);
						}
						cnt++;
				}
				return cnt;
		}
		setLTCPositionalLight(wtm, cnt) {
				var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
				this.lightWidth[cnt][0] = hWidth.x;
				this.lightWidth[cnt][1] = hWidth.y;
				this.lightWidth[cnt][2] = hWidth.z;
				this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
				var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
				this.lightHeight[cnt][0] = hHeight.x;
				this.lightHeight[cnt][1] = hHeight.y;
				this.lightHeight[cnt][2] = hHeight.z;
				this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		}
		dispatchOmniLight(scope, omni, cnt) {
				var wtm = omni._node.getWorldTransform();
				if (!this.lightColorId[cnt]) {
						this._resolveLight(scope, cnt);
				}
				this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
				this.lightColorId[cnt].setValue(omni._colorLinear);
				wtm.getTranslation(omni._position);
				this.lightPos[cnt][0] = omni._position.x;
				this.lightPos[cnt][1] = omni._position.y;
				this.lightPos[cnt][2] = omni._position.z;
				this.lightPosId[cnt].setValue(this.lightPos[cnt]);
				if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
						this.setLTCPositionalLight(wtm, cnt);
				}
				if (omni.castShadows) {
						var lightRenderData = omni.getRenderData(null, 0);
						this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
						var biases = omni._getUniformBiasValues(lightRenderData);
						var params = omni._shadowRenderParams;
						params.length = 4;
						params[0] = omni._shadowResolution;
						params[1] = biases.normalBias;
						params[2] = biases.bias;
						params[3] = 1.0 / omni.attenuationEnd;
						this.lightShadowParamsId[cnt].setValue(params);
						this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);
						var pixelsPerMeter = omni.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
						this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);
						var cameraParams = omni._shadowCameraParams;
						cameraParams.length = 4;
						cameraParams[0] = 0;
						cameraParams[1] = lightRenderData.shadowCamera._farClip;
						cameraParams[2] = lightRenderData.shadowCamera._nearClip;
						cameraParams[3] = 0;
						this.lightCameraParamsId[cnt].setValue(cameraParams);
				}
				if (omni._cookie) {
						this.lightCookieId[cnt].setValue(omni._cookie);
						this.lightShadowMatrixId[cnt].setValue(wtm.data);
						this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
				}
		}
		dispatchSpotLight(scope, spot, cnt) {
				var wtm = spot._node.getWorldTransform();
				if (!this.lightColorId[cnt]) {
						this._resolveLight(scope, cnt);
				}
				this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
				this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
				this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
				this.lightColorId[cnt].setValue(spot._colorLinear);
				wtm.getTranslation(spot._position);
				this.lightPos[cnt][0] = spot._position.x;
				this.lightPos[cnt][1] = spot._position.y;
				this.lightPos[cnt][2] = spot._position.z;
				this.lightPosId[cnt].setValue(this.lightPos[cnt]);
				if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
						this.setLTCPositionalLight(wtm, cnt);
				}
				wtm.getY(spot._direction).mulScalar(-1);
				spot._direction.normalize();
				this.lightDir[cnt][0] = spot._direction.x;
				this.lightDir[cnt][1] = spot._direction.y;
				this.lightDir[cnt][2] = spot._direction.z;
				this.lightDirId[cnt].setValue(this.lightDir[cnt]);
				if (spot.castShadows) {
						var lightRenderData = spot.getRenderData(null, 0);
						this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
						this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
						var biases = spot._getUniformBiasValues(lightRenderData);
						var params = spot._shadowRenderParams;
						params.length = 4;
						params[0] = spot._shadowResolution;
						params[1] = biases.normalBias;
						params[2] = biases.bias;
						params[3] = 1.0 / spot.attenuationEnd;
						this.lightShadowParamsId[cnt].setValue(params);
						this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);
						var pixelsPerMeter = spot.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
						var fov = lightRenderData.shadowCamera._fov * Math.PI / 180.0;
						var fovRatio = 1.0 / Math.tan(fov / 2.0);
						this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * fovRatio);
						var cameraParams = spot._shadowCameraParams;
						cameraParams.length = 4;
						cameraParams[0] = 0;
						cameraParams[1] = lightRenderData.shadowCamera._farClip;
						cameraParams[2] = lightRenderData.shadowCamera._nearClip;
						cameraParams[3] = 0;
						this.lightCameraParamsId[cnt].setValue(cameraParams);
				}
				if (spot._cookie) {
						if (!spot.castShadows) {
								var cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
								this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
						}
						this.lightCookieId[cnt].setValue(spot._cookie);
						this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
						if (spot._cookieTransform) {
								spot._cookieTransformUniform[0] = spot._cookieTransform.x;
								spot._cookieTransformUniform[1] = spot._cookieTransform.y;
								spot._cookieTransformUniform[2] = spot._cookieTransform.z;
								spot._cookieTransformUniform[3] = spot._cookieTransform.w;
								this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
								spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
								spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
								this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
						}
				}
		}
		dispatchLocalLights(sortedLights, mask, usedDirLights) {
				var cnt = usedDirLights;
				var scope = this.device.scope;
				var omnis = sortedLights[LIGHTTYPE_OMNI];
				var numOmnis = omnis.length;
				for(var i = 0; i < numOmnis; i++){
						var omni = omnis[i];
						if (!(omni.mask & mask)) continue;
						this.dispatchOmniLight(scope, omni, cnt);
						cnt++;
				}
				var spts = sortedLights[LIGHTTYPE_SPOT];
				var numSpts = spts.length;
				for(var i1 = 0; i1 < numSpts; i1++){
						var spot = spts[i1];
						if (!(spot.mask & mask)) continue;
						this.dispatchSpotLight(scope, spot, cnt);
						cnt++;
				}
		}
		renderForwardPrepareMaterials(camera, renderTarget, drawCalls, sortedLights, layer, pass) {
				var _camera_fog;
				var fogParams = (_camera_fog = camera.fog) != null ? _camera_fog : this.scene.fog;
				var shaderParams = camera.shaderParams;
				shaderParams.fog = fogParams.type;
				var _renderTarget_isColorBufferSrgb;
				shaderParams.srgbRenderTarget = (_renderTarget_isColorBufferSrgb = renderTarget == null ? void 0 : renderTarget.isColorBufferSrgb(0)) != null ? _renderTarget_isColorBufferSrgb : false;
				var addCall = (drawCall, shaderInstance, isNewMaterial, lightMaskChanged)=>{
						_drawCallList.drawCalls.push(drawCall);
						_drawCallList.shaderInstances.push(shaderInstance);
						_drawCallList.isNewMaterial.push(isNewMaterial);
						_drawCallList.lightMaskChanged.push(lightMaskChanged);
				};
				_drawCallList.clear();
				var device = this.device;
				var scene = this.scene;
				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
				var _layer_getLightHash;
				var lightHash = (_layer_getLightHash = layer == null ? void 0 : layer.getLightHash(clusteredLightingEnabled)) != null ? _layer_getLightHash : 0;
				var prevMaterial = null, prevObjDefs, prevLightMask;
				var drawCallsCount = drawCalls.length;
				for(var i = 0; i < drawCallsCount; i++){
						var drawCall = drawCalls[i];
						drawCall.ensureMaterial(device);
						var material = drawCall.material;
						var objDefs = drawCall._shaderDefs;
						var lightMask = drawCall.mask;
						if (material && material === prevMaterial && objDefs !== prevObjDefs) {
								prevMaterial = null;
						}
						if (material !== prevMaterial) {
								this._materialSwitches++;
								material._scene = scene;
								if (material.dirty) {
										material.updateUniforms(device, scene);
										material.dirty = false;
								}
						}
						var shaderInstance = drawCall.getShaderInstance(pass, lightHash, scene, shaderParams, this.viewUniformFormat, this.viewBindGroupFormat, sortedLights);
						addCall(drawCall, shaderInstance, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
						prevMaterial = material;
						prevObjDefs = objDefs;
						prevLightMask = lightMask;
				}
				return _drawCallList;
		}
		renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {
				var device = this.device;
				var scene = this.scene;
				var passFlag = 1 << pass;
				var flipFactor = flipFaces ? -1 : 1;
				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
				var preparedCallsCount = preparedCalls.drawCalls.length;
				for(var i = 0; i < preparedCallsCount; i++){
						var drawCall = preparedCalls.drawCalls[i];
						var newMaterial = preparedCalls.isNewMaterial[i];
						var lightMaskChanged = preparedCalls.lightMaskChanged[i];
						var shaderInstance = preparedCalls.shaderInstances[i];
						var material = drawCall.material;
						var lightMask = drawCall.mask;
						if (newMaterial) {
								var asyncCompile = false;
								device.setShader(shaderInstance.shader, asyncCompile);
								material.setParameters(device);
								if (lightMaskChanged) {
										var usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], lightMask, camera);
										if (!clusteredLightingEnabled) {
												this.dispatchLocalLights(sortedLights, lightMask, usedDirLights);
										}
								}
								this.alphaTestId.setValue(material.alphaTest);
								device.setBlendState(material.blendState);
								device.setDepthState(material.depthState);
								device.setAlphaToCoverage(material.alphaToCoverage);
						}
						this.setupCullMode(camera._cullFaces, flipFactor, drawCall);
						var _drawCall_stencilFront;
						var stencilFront = (_drawCall_stencilFront = drawCall.stencilFront) != null ? _drawCall_stencilFront : material.stencilFront;
						var _drawCall_stencilBack;
						var stencilBack = (_drawCall_stencilBack = drawCall.stencilBack) != null ? _drawCall_stencilBack : material.stencilBack;
						device.setStencilState(stencilFront, stencilBack);
						drawCall.setParameters(device, passFlag);
						device.scope.resolve('meshInstanceId').setValue(drawCall.id);
						var mesh = drawCall.mesh;
						this.setVertexBuffers(device, mesh);
						this.setMorphing(device, drawCall.morphInstance);
						this.setSkinning(device, drawCall);
						this.setupMeshUniformBuffers(shaderInstance, drawCall);
						var style = drawCall.renderStyle;
						device.setIndexBuffer(mesh.indexBuffer[style]);
						drawCallback == null ? void 0 : drawCallback(drawCall, i);
						if (camera.xr && camera.xr.session && camera.xr.views.list.length) {
								var views = camera.xr.views;
								for(var v = 0; v < views.list.length; v++){
										var view = views.list[v];
										device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
										this.projId.setValue(view.projMat.data);
										this.projSkyboxId.setValue(view.projMat.data);
										this.viewId.setValue(view.viewOffMat.data);
										this.viewInvId.setValue(view.viewInvOffMat.data);
										this.viewId3.setValue(view.viewMat3.data);
										this.viewProjId.setValue(view.projViewOffMat.data);
										this.viewPosId.setValue(view.positionData);
										this.viewIndexId.setValue(v);
										if (v === 0) {
												this.drawInstance(device, drawCall, mesh, style, true);
										} else {
												this.drawInstance2(device, drawCall, mesh, style);
										}
										this._forwardDrawCalls++;
								}
						} else {
								this.drawInstance(device, drawCall, mesh, style, true);
								this._forwardDrawCalls++;
						}
						if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
								material.setParameters(device, drawCall.parameters);
						}
				}
		}
		renderForward(camera, renderTarget, allDrawCalls, sortedLights, pass, drawCallback, layer, flipFaces) {
				var preparedCalls = this.renderForwardPrepareMaterials(camera, renderTarget, allDrawCalls, sortedLights, layer, pass);
				this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);
				_drawCallList.clear();
		}
		renderForwardLayer(camera, renderTarget, layer, transparent, shaderPass, viewBindGroups, options) {
				if (options === void 0) options = {};
				var { scene, device } = this;
				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
				this.setupViewport(camera, renderTarget);
				var visible, splitLights;
				if (layer) {
						layer.sortVisible(camera, transparent);
						var culledInstances = layer.getCulledInstances(camera);
						visible = transparent ? culledInstances.transparent : culledInstances.opaque;
						scene.immediate.onPreRenderLayer(layer, visible, transparent);
						if (layer.requiresLightCube) {
								this.lightCube.update(scene.ambientLight, layer._lights);
								this.constantLightCube.setValue(this.lightCube.colors);
						}
						splitLights = layer.splitLights;
				} else {
						visible = options.meshInstances;
						var _options_splitLights;
						splitLights = (_options_splitLights = options.splitLights) != null ? _options_splitLights : _noLights;
				}
				if (clusteredLightingEnabled) {
						var _options_lightClusters;
						var lightClusters = (_options_lightClusters = options.lightClusters) != null ? _options_lightClusters : this.worldClustersAllocator.empty;
						lightClusters.activate();
						if (layer) {
								if (!this.clustersDebugRendered && scene.lighting.debugLayer === layer.id) {
										this.clustersDebugRendered = true;
								}
						}
				}
				scene._activeCamera = camera;
				var _camera_fog;
				var fogParams = (_camera_fog = camera.fog) != null ? _camera_fog : this.scene.fog;
				this.setFogConstants(fogParams);
				var viewCount = this.setCameraUniforms(camera, renderTarget);
				if (device.supportsUniformBuffers) {
						this.setupViewUniformBuffers(viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, viewCount);
				}
				var _options_clearColor;
				var clearColor = (_options_clearColor = options.clearColor) != null ? _options_clearColor : false;
				var _options_clearDepth;
				var clearDepth = (_options_clearDepth = options.clearDepth) != null ? _options_clearDepth : false;
				var _options_clearStencil;
				var clearStencil = (_options_clearStencil = options.clearStencil) != null ? _options_clearStencil : false;
				if (clearColor || clearDepth || clearStencil) {
						this.clear(camera, clearColor, clearDepth, clearStencil);
				}
				var flipFaces = !!(camera._flipFaces ^ (renderTarget == null ? void 0 : renderTarget.flipY));
				var forwardDrawCalls = this._forwardDrawCalls;
				this.renderForward(camera, renderTarget, visible, splitLights, shaderPass, null, layer, flipFaces);
				if (layer) {
						layer._forwardDrawCalls += this._forwardDrawCalls - forwardDrawCalls;
				}
		}
		setFogConstants(fogParams) {
				if (fogParams.type !== FOG_NONE) {
						tmpColor$1.linear(fogParams.color);
						var fogUniform = this.fogColor;
						fogUniform[0] = tmpColor$1.r;
						fogUniform[1] = tmpColor$1.g;
						fogUniform[2] = tmpColor$1.b;
						this.fogColorId.setValue(fogUniform);
						if (fogParams.type === FOG_LINEAR) {
								this.fogStartId.setValue(fogParams.start);
								this.fogEndId.setValue(fogParams.end);
						} else {
								this.fogDensityId.setValue(fogParams.density);
						}
				}
		}
		setSceneConstants() {
				var scene = this.scene;
				this.dispatchGlobalLights(scene);
				var device = this.device;
				this._screenSize[0] = device.width;
				this._screenSize[1] = device.height;
				this._screenSize[2] = 1 / device.width;
				this._screenSize[3] = 1 / device.height;
				this.screenSizeId.setValue(this._screenSize);
				this.pcssDiskSamplesId.setValue(this.pcssDiskSamples);
				this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
		}
		buildFrameGraph(frameGraph, layerComposition) {
				var scene = this.scene;
				frameGraph.reset();
				if (scene.clusteredLightingEnabled) {
						var { shadowsEnabled, cookiesEnabled } = scene.lighting;
						this._renderPassUpdateClustered.update(frameGraph, shadowsEnabled, cookiesEnabled, this.lights, this.localLights);
						frameGraph.addRenderPass(this._renderPassUpdateClustered);
				} else {
						this._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph, this.localLights);
				}
				var startIndex = 0;
				var newStart = true;
				var renderTarget = null;
				var renderActions = layerComposition._renderActions;
				for(var i = startIndex; i < renderActions.length; i++){
						var renderAction = renderActions[i];
						var { layer, camera } = renderAction;
						if (renderAction.useCameraPasses) {
								camera.camera.renderPasses.forEach((renderPass)=>{
										frameGraph.addRenderPass(renderPass);
								});
						} else {
								var isDepthLayer = layer.id === LAYERID_DEPTH;
								var isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
								if (newStart) {
										newStart = false;
										startIndex = i;
										renderTarget = renderAction.renderTarget;
								}
								var nextRenderAction = renderActions[i + 1];
								var isNextLayerDepth = nextRenderAction ? !nextRenderAction.useCameraPasses && nextRenderAction.layer.id === LAYERID_DEPTH : false;
								var isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
								var nextNeedDirShadows = nextRenderAction ? nextRenderAction.firstCameraUse && this.cameraDirShadowLights.has(nextRenderAction.camera.camera) : false;
								if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextNeedDirShadows || isNextLayerGrabPass || isGrabPass) {
										var isDepthOnly = isDepthLayer && startIndex === i;
										if (!isDepthOnly) {
												this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i);
										}
										if (isDepthLayer) {
												if (camera.renderSceneColorMap) {
														var colorGrabPass = camera.camera.renderPassColorGrab;
														colorGrabPass.source = camera.renderTarget;
														frameGraph.addRenderPass(colorGrabPass);
												}
												if (camera.renderSceneDepthMap) {
														frameGraph.addRenderPass(camera.camera.renderPassDepthGrab);
												}
										}
										if (renderAction.triggerPostprocess && (camera == null ? void 0 : camera.onPostprocessing)) {
												var renderPass = new RenderPassPostprocessing(this.device, this, renderAction);
												frameGraph.addRenderPass(renderPass);
										}
										newStart = true;
								}
						}
				}
		}
		addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex) {
				var renderPass = new RenderPassForward(this.device, layerComposition, this.scene, this);
				renderPass.init(renderTarget);
				var renderActions = layerComposition._renderActions;
				for(var i = startIndex; i <= endIndex; i++){
						renderPass.addRenderAction(renderActions[i]);
				}
				frameGraph.addRenderPass(renderPass);
		}
		update(comp) {
				this.frameUpdate();
				this.shadowRenderer.frameUpdate();
				this.scene._updateSkyMesh();
				this.updateLayerComposition(comp);
				this.collectLights(comp);
				this.beginFrame(comp);
				this.setSceneConstants();
				this.cullComposition(comp);
				this.gpuUpdate(this.processingMeshInstances);
		}
		constructor(graphicsDevice){
				super(graphicsDevice);
				var device = this.device;
				this._forwardDrawCalls = 0;
				this._materialSwitches = 0;
				this._depthMapTime = 0;
				this._forwardTime = 0;
				this._sortTime = 0;
				var scope = device.scope;
				this.fogColorId = scope.resolve('fog_color');
				this.fogStartId = scope.resolve('fog_start');
				this.fogEndId = scope.resolve('fog_end');
				this.fogDensityId = scope.resolve('fog_density');
				this.ambientId = scope.resolve('light_globalAmbient');
				this.skyboxIntensityId = scope.resolve('skyboxIntensity');
				this.cubeMapRotationMatrixId = scope.resolve('cubeMapRotationMatrix');
				this.pcssDiskSamplesId = scope.resolve('pcssDiskSamples[0]');
				this.pcssSphereSamplesId = scope.resolve('pcssSphereSamples[0]');
				this.lightColorId = [];
				this.lightDir = [];
				this.lightDirId = [];
				this.lightShadowMapId = [];
				this.lightShadowMatrixId = [];
				this.lightShadowParamsId = [];
				this.lightShadowIntensity = [];
				this.lightRadiusId = [];
				this.lightPos = [];
				this.lightPosId = [];
				this.lightWidth = [];
				this.lightWidthId = [];
				this.lightHeight = [];
				this.lightHeightId = [];
				this.lightInAngleId = [];
				this.lightOutAngleId = [];
				this.lightCookieId = [];
				this.lightCookieIntId = [];
				this.lightCookieMatrixId = [];
				this.lightCookieOffsetId = [];
				this.lightShadowSearchAreaId = [];
				this.lightCameraParamsId = [];
				this.lightSoftShadowParamsId = [];
				this.shadowMatrixPaletteId = [];
				this.shadowCascadeDistancesId = [];
				this.shadowCascadeCountId = [];
				this.shadowCascadeBlendId = [];
				this.screenSizeId = scope.resolve('uScreenSize');
				this._screenSize = new Float32Array(4);
				this.fogColor = new Float32Array(3);
				this.ambientColor = new Float32Array(3);
				this.pcssDiskSamples = vogelDiskPrecalculationSamples(16);
				this.pcssSphereSamples = vogelSpherePrecalculationSamples(16);
		}
}

var layerCounter = 0;
var lightKeys = [];
var _tempMaterials = new Set();
function sortManual(drawCallA, drawCallB) {
		return drawCallA.drawOrder - drawCallB.drawOrder;
}
function sortMaterialMesh(drawCallA, drawCallB) {
		var keyA = drawCallA._sortKeyForward;
		var keyB = drawCallB._sortKeyForward;
		if (keyA === keyB) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
		}
		return keyB - keyA;
}
function sortBackToFront(drawCallA, drawCallB) {
		return drawCallB._sortKeyDynamic - drawCallA._sortKeyDynamic;
}
function sortFrontToBack(drawCallA, drawCallB) {
		return drawCallA._sortKeyDynamic - drawCallB._sortKeyDynamic;
}
var sortCallbacks = [
		null,
		sortManual,
		sortMaterialMesh,
		sortBackToFront,
		sortFrontToBack
];
class CulledInstances {
		constructor(){
				this.opaque = [];
				this.transparent = [];
		}
}
class Layer {
		set enabled(val) {
				if (val !== this._enabled) {
						this._dirtyComposition = true;
						this._enabled = val;
						if (val) {
								this.incrementCounter();
								if (this.onEnable) this.onEnable();
						} else {
								this.decrementCounter();
								if (this.onDisable) this.onDisable();
						}
				}
		}
		get enabled() {
				return this._enabled;
		}
		set clearColorBuffer(val) {
				this._clearColorBuffer = val;
				this._dirtyComposition = true;
		}
		get clearColorBuffer() {
				return this._clearColorBuffer;
		}
		set clearDepthBuffer(val) {
				this._clearDepthBuffer = val;
				this._dirtyComposition = true;
		}
		get clearDepthBuffer() {
				return this._clearDepthBuffer;
		}
		set clearStencilBuffer(val) {
				this._clearStencilBuffer = val;
				this._dirtyComposition = true;
		}
		get clearStencilBuffer() {
				return this._clearStencilBuffer;
		}
		get hasClusteredLights() {
				return this._clusteredLightsSet.size > 0;
		}
		get clusteredLightsSet() {
				return this._clusteredLightsSet;
		}
		incrementCounter() {
				if (this._refCounter === 0) {
						this._enabled = true;
						if (this.onEnable) this.onEnable();
				}
				this._refCounter++;
		}
		decrementCounter() {
				if (this._refCounter === 1) {
						this._enabled = false;
						if (this.onDisable) this.onDisable();
				} else if (this._refCounter === 0) {
						return;
				}
				this._refCounter--;
		}
		addMeshInstances(meshInstances, skipShadowCasters) {
				var destMeshInstances = this.meshInstances;
				var destMeshInstancesSet = this.meshInstancesSet;
				for(var i = 0; i < meshInstances.length; i++){
						var mi = meshInstances[i];
						if (!destMeshInstancesSet.has(mi)) {
								destMeshInstances.push(mi);
								destMeshInstancesSet.add(mi);
								_tempMaterials.add(mi.material);
						}
				}
				if (!skipShadowCasters) {
						this.addShadowCasters(meshInstances);
				}
				if (_tempMaterials.size > 0) {
						var sceneShaderVer = this._shaderVersion;
						_tempMaterials.forEach((mat)=>{
								if (sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
										if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
												mat.clearVariants();
										}
										mat._shaderVersion = sceneShaderVer;
								}
						});
						_tempMaterials.clear();
				}
		}
		removeMeshInstances(meshInstances, skipShadowCasters) {
				var destMeshInstances = this.meshInstances;
				var destMeshInstancesSet = this.meshInstancesSet;
				for(var i = 0; i < meshInstances.length; i++){
						var mi = meshInstances[i];
						if (destMeshInstancesSet.has(mi)) {
								destMeshInstancesSet.delete(mi);
								var j = destMeshInstances.indexOf(mi);
								if (j >= 0) {
										destMeshInstances.splice(j, 1);
								}
						}
				}
				if (!skipShadowCasters) {
						this.removeShadowCasters(meshInstances);
				}
		}
		addShadowCasters(meshInstances) {
				var shadowCasters = this.shadowCasters;
				var shadowCastersSet = this.shadowCastersSet;
				for(var i = 0; i < meshInstances.length; i++){
						var mi = meshInstances[i];
						if (mi.castShadow && !shadowCastersSet.has(mi)) {
								shadowCastersSet.add(mi);
								shadowCasters.push(mi);
						}
				}
		}
		removeShadowCasters(meshInstances) {
				var shadowCasters = this.shadowCasters;
				var shadowCastersSet = this.shadowCastersSet;
				for(var i = 0; i < meshInstances.length; i++){
						var mi = meshInstances[i];
						if (shadowCastersSet.has(mi)) {
								shadowCastersSet.delete(mi);
								var j = shadowCasters.indexOf(mi);
								if (j >= 0) {
										shadowCasters.splice(j, 1);
								}
						}
				}
		}
		clearMeshInstances(skipShadowCasters) {
				if (skipShadowCasters === void 0) skipShadowCasters = false;
				this.meshInstances.length = 0;
				this.meshInstancesSet.clear();
				if (!skipShadowCasters) {
						this.shadowCasters.length = 0;
						this.shadowCastersSet.clear();
				}
		}
		markLightsDirty() {
				this._lightHashDirty = true;
				this._lightIdHashDirty = true;
				this._splitLightsDirty = true;
		}
		hasLight(light) {
				return this._lightsSet.has(light);
		}
		addLight(light) {
				var l = light.light;
				if (!this._lightsSet.has(l)) {
						this._lightsSet.add(l);
						this._lights.push(l);
						this.markLightsDirty();
				}
				if (l.type !== LIGHTTYPE_DIRECTIONAL) {
						this._clusteredLightsSet.add(l);
				}
		}
		removeLight(light) {
				var l = light.light;
				if (this._lightsSet.has(l)) {
						this._lightsSet.delete(l);
						this._lights.splice(this._lights.indexOf(l), 1);
						this.markLightsDirty();
				}
				if (l.type !== LIGHTTYPE_DIRECTIONAL) {
						this._clusteredLightsSet.delete(l);
				}
		}
		clearLights() {
				this._lightsSet.forEach((light)=>light.removeLayer(this));
				this._lightsSet.clear();
				this._clusteredLightsSet.clear();
				this._lights.length = 0;
				this.markLightsDirty();
		}
		get splitLights() {
				if (this._splitLightsDirty) {
						this._splitLightsDirty = false;
						var splitLights = this._splitLights;
						for(var i = 0; i < splitLights.length; i++){
								splitLights[i].length = 0;
						}
						var lights = this._lights;
						for(var i1 = 0; i1 < lights.length; i1++){
								var light = lights[i1];
								if (light.enabled) {
										splitLights[light._type].push(light);
								}
						}
						for(var i2 = 0; i2 < splitLights.length; i2++){
								splitLights[i2].sort((a, b)=>a.key - b.key);
						}
				}
				return this._splitLights;
		}
		evaluateLightHash(localLights, directionalLights, useIds) {
				var hash = 0;
				var lights = this._lights;
				for(var i = 0; i < lights.length; i++){
						var isLocalLight = lights[i].type !== LIGHTTYPE_DIRECTIONAL;
						if (localLights && isLocalLight || directionalLights && !isLocalLight) {
								lightKeys.push(useIds ? lights[i].id : lights[i].key);
						}
				}
				if (lightKeys.length > 0) {
						lightKeys.sort();
						hash = hash32Fnv1a(lightKeys);
						lightKeys.length = 0;
				}
				return hash;
		}
		getLightHash(isClustered) {
				if (this._lightHashDirty) {
						this._lightHashDirty = false;
						this._lightHash = this.evaluateLightHash(!isClustered, true, false);
				}
				return this._lightHash;
		}
		getLightIdHash() {
				if (this._lightIdHashDirty) {
						this._lightIdHashDirty = false;
						this._lightIdHash = this.evaluateLightHash(true, false, true);
				}
				return this._lightIdHash;
		}
		addCamera(camera) {
				if (!this.camerasSet.has(camera.camera)) {
						this.camerasSet.add(camera.camera);
						this.cameras.push(camera);
						this._dirtyComposition = true;
				}
		}
		removeCamera(camera) {
				if (this.camerasSet.has(camera.camera)) {
						this.camerasSet.delete(camera.camera);
						var index = this.cameras.indexOf(camera);
						this.cameras.splice(index, 1);
						this._dirtyComposition = true;
				}
		}
		clearCameras() {
				this.cameras.length = 0;
				this.camerasSet.clear();
				this._dirtyComposition = true;
		}
		_calculateSortDistances(drawCalls, camPos, camFwd) {
				var count = drawCalls.length;
				var { x: px, y: py, z: pz } = camPos;
				var { x: fx, y: fy, z: fz } = camFwd;
				for(var i = 0; i < count; i++){
						var drawCall = drawCalls[i];
						var zDist = void 0;
						if (drawCall.calculateSortDistance) {
								zDist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
						} else {
								var meshPos = drawCall.aabb.center;
								zDist = (meshPos.x - px) * fx + (meshPos.y - py) * fy + (meshPos.z - pz) * fz;
						}
						var bucket = drawCall._drawBucket * 1e9;
						drawCall._sortKeyDynamic = bucket + zDist;
				}
		}
		getCulledInstances(camera) {
				var instances = this._visibleInstances.get(camera);
				if (!instances) {
						instances = new CulledInstances();
						this._visibleInstances.set(camera, instances);
				}
				return instances;
		}
		sortVisible(camera, transparent) {
				var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
				if (sortMode === SORTMODE_NONE) {
						return;
				}
				var culledInstances = this.getCulledInstances(camera);
				var instances = transparent ? culledInstances.transparent : culledInstances.opaque;
				var cameraNode = camera.node;
				if (sortMode === SORTMODE_CUSTOM) {
						var sortPos = cameraNode.getPosition();
						var sortDir = cameraNode.forward;
						if (this.customCalculateSortValues) {
								this.customCalculateSortValues(instances, instances.length, sortPos, sortDir);
						}
						if (this.customSortCallback) {
								instances.sort(this.customSortCallback);
						}
				} else {
						if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
								var sortPos1 = cameraNode.getPosition();
								var sortDir1 = cameraNode.forward;
								this._calculateSortDistances(instances, sortPos1, sortDir1);
						}
						instances.sort(sortCallbacks[sortMode]);
				}
		}
		constructor(options = {}){
				this.meshInstances = [];
				this.meshInstancesSet = new Set();
				this.shadowCasters = [];
				this.shadowCastersSet = new Set();
				this._visibleInstances = new WeakMap();
				this._lights = [];
				this._lightsSet = new Set();
				this._clusteredLightsSet = new Set();
				this._splitLights = [
						[],
						[],
						[]
				];
				this._splitLightsDirty = true;
				this.requiresLightCube = false;
				this.cameras = [];
				this.camerasSet = new Set();
				this._dirtyComposition = false;
				if (options.id !== undefined) {
						this.id = options.id;
						layerCounter = Math.max(this.id + 1, layerCounter);
				} else {
						this.id = layerCounter++;
				}
				this.name = options.name;
				var _options_enabled;
				this._enabled = (_options_enabled = options.enabled) != null ? _options_enabled : true;
				this._refCounter = this._enabled ? 1 : 0;
				var _options_opaqueSortMode;
				this.opaqueSortMode = (_options_opaqueSortMode = options.opaqueSortMode) != null ? _options_opaqueSortMode : SORTMODE_MATERIALMESH;
				var _options_transparentSortMode;
				this.transparentSortMode = (_options_transparentSortMode = options.transparentSortMode) != null ? _options_transparentSortMode : SORTMODE_BACK2FRONT;
				if (options.renderTarget) {
						this.renderTarget = options.renderTarget;
				}
				this._clearColorBuffer = !!options.clearColorBuffer;
				this._clearDepthBuffer = !!options.clearDepthBuffer;
				this._clearStencilBuffer = !!options.clearStencilBuffer;
				this.onEnable = options.onEnable;
				this.onDisable = options.onDisable;
				if (this._enabled && this.onEnable) {
						this.onEnable();
				}
				this.customSortCallback = null;
				this.customCalculateSortValues = null;
				this._lightHash = 0;
				this._lightHashDirty = false;
				this._lightIdHash = 0;
				this._lightIdHashDirty = false;
				this._shaderVersion = -1;
		}
}

var cmpPriority = (a, b)=>a.priority - b.priority;
var sortPriority = (arr)=>arr.sort(cmpPriority);

class LayerComposition extends EventHandler {
		destroy() {
				this.destroyRenderActions();
		}
		destroyRenderActions() {
				this._renderActions.forEach((ra)=>ra.destroy());
				this._renderActions.length = 0;
		}
		_update() {
				var len = this.layerList.length;
				if (!this._dirty) {
						for(var i = 0; i < len; i++){
								if (this.layerList[i]._dirtyComposition) {
										this._dirty = true;
										break;
								}
						}
				}
				if (this._dirty) {
						this._dirty = false;
						this.cameras.length = 0;
						for(var i1 = 0; i1 < len; i1++){
								var layer = this.layerList[i1];
								layer._dirtyComposition = false;
								for(var j = 0; j < layer.cameras.length; j++){
										var camera = layer.cameras[j];
										var index = this.cameras.indexOf(camera);
										if (index < 0) {
												this.cameras.push(camera);
										}
								}
						}
						if (this.cameras.length > 1) {
								sortPriority(this.cameras);
						}
						var cameraLayers = [];
						var renderActionCount = 0;
						this.destroyRenderActions();
						for(var i2 = 0; i2 < this.cameras.length; i2++){
								var camera1 = this.cameras[i2];
								cameraLayers.length = 0;
								if (camera1.camera.renderPasses.length > 0) {
										this.addDummyRenderAction(renderActionCount, camera1);
										renderActionCount++;
										continue;
								}
								var cameraFirstRenderAction = true;
								var cameraFirstRenderActionIndex = renderActionCount;
								var lastRenderAction = null;
								var postProcessMarked = false;
								for(var j1 = 0; j1 < len; j1++){
										var layer1 = this.layerList[j1];
										var isLayerEnabled = layer1.enabled && this.subLayerEnabled[j1];
										if (isLayerEnabled) {
												if (layer1.cameras.length > 0) {
														if (camera1.layers.indexOf(layer1.id) >= 0) {
																cameraLayers.push(layer1);
																if (!postProcessMarked && layer1.id === camera1.disablePostEffectsLayer) {
																		postProcessMarked = true;
																		if (lastRenderAction) {
																				lastRenderAction.triggerPostprocess = true;
																		}
																}
																var isTransparent = this.subLayerList[j1];
																lastRenderAction = this.addRenderAction(renderActionCount, layer1, isTransparent, camera1, cameraFirstRenderAction, postProcessMarked);
																renderActionCount++;
																cameraFirstRenderAction = false;
														}
												}
										}
								}
								if (cameraFirstRenderActionIndex < renderActionCount) {
										lastRenderAction.lastCameraUse = true;
								}
								if (!postProcessMarked && lastRenderAction) {
										lastRenderAction.triggerPostprocess = true;
								}
								if (camera1.renderTarget && camera1.postEffectsEnabled) {
										this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera1);
								}
						}
						this._logRenderActions();
				}
		}
		getNextRenderAction(renderActionIndex) {
				var renderAction = new RenderAction();
				this._renderActions.push(renderAction);
				return renderAction;
		}
		addDummyRenderAction(renderActionIndex, camera) {
				var renderAction = this.getNextRenderAction(renderActionIndex);
				renderAction.camera = camera;
				renderAction.useCameraPasses = true;
		}
		addRenderAction(renderActionIndex, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked) {
				var rt = layer.id !== LAYERID_DEPTH ? camera.renderTarget : null;
				var used = false;
				var renderActions = this._renderActions;
				for(var i = renderActionIndex - 1; i >= 0; i--){
						if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
								used = true;
								break;
						}
				}
				if (postProcessMarked && camera.postEffectsEnabled) {
						rt = null;
				}
				var renderAction = this.getNextRenderAction(renderActionIndex);
				renderAction.triggerPostprocess = false;
				renderAction.layer = layer;
				renderAction.transparent = isTransparent;
				renderAction.camera = camera;
				renderAction.renderTarget = rt;
				renderAction.firstCameraUse = cameraFirstRenderAction;
				renderAction.lastCameraUse = false;
				var needsCameraClear = cameraFirstRenderAction || !used;
				var needsLayerClear = layer.clearColorBuffer || layer.clearDepthBuffer || layer.clearStencilBuffer;
				if (needsCameraClear || needsLayerClear) {
						renderAction.setupClears(needsCameraClear ? camera : undefined, layer);
				}
				return renderAction;
		}
		propagateRenderTarget(startIndex, fromCamera) {
				for(var a = startIndex; a >= 0; a--){
						var ra = this._renderActions[a];
						var layer = ra.layer;
						if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
								break;
						}
						if (layer.id === LAYERID_DEPTH) {
								continue;
						}
						if (ra.useCameraPasses) {
								break;
						}
						var thisCamera = ra == null ? void 0 : ra.camera.camera;
						if (thisCamera) {
								if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
										break;
								}
						}
						ra.renderTarget = fromCamera.renderTarget;
				}
		}
		_logRenderActions() {}
		_isLayerAdded(layer) {
				var found = this.layerIdMap.get(layer.id) === layer;
				return found;
		}
		_isSublayerAdded(layer, transparent) {
				var map = transparent ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
				if (map.get(layer) !== undefined) {
						return true;
				}
				return false;
		}
		push(layer) {
				if (this._isLayerAdded(layer)) return;
				this.layerList.push(layer);
				this.layerList.push(layer);
				this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
				this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
				this.subLayerEnabled.push(true);
				this.subLayerEnabled.push(true);
				this._updateLayerMaps();
				this._dirty = true;
				this.fire('add', layer);
		}
		insert(layer, index) {
				if (this._isLayerAdded(layer)) return;
				this.layerList.splice(index, 0, layer, layer);
				this.subLayerList.splice(index, 0, false, true);
				var count = this.layerList.length;
				this._updateOpaqueOrder(index, count - 1);
				this._updateTransparentOrder(index, count - 1);
				this.subLayerEnabled.splice(index, 0, true, true);
				this._updateLayerMaps();
				this._dirty = true;
				this.fire('add', layer);
		}
		remove(layer) {
				var id = this.layerList.indexOf(layer);
				delete this._opaqueOrder[id];
				delete this._transparentOrder[id];
				while(id >= 0){
						this.layerList.splice(id, 1);
						this.subLayerList.splice(id, 1);
						this.subLayerEnabled.splice(id, 1);
						id = this.layerList.indexOf(layer);
						this._dirty = true;
						this.fire('remove', layer);
				}
				var count = this.layerList.length;
				this._updateOpaqueOrder(0, count - 1);
				this._updateTransparentOrder(0, count - 1);
				this._updateLayerMaps();
		}
		pushOpaque(layer) {
				if (this._isSublayerAdded(layer, false)) return;
				this.layerList.push(layer);
				this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
				this.subLayerEnabled.push(true);
				this._updateLayerMaps();
				this._dirty = true;
				this.fire('add', layer);
		}
		insertOpaque(layer, index) {
				if (this._isSublayerAdded(layer, false)) return;
				this.layerList.splice(index, 0, layer);
				this.subLayerList.splice(index, 0, false);
				var count = this.subLayerList.length;
				this._updateOpaqueOrder(index, count - 1);
				this.subLayerEnabled.splice(index, 0, true);
				this._updateLayerMaps();
				this._dirty = true;
				this.fire('add', layer);
		}
		removeOpaque(layer) {
				for(var i = 0, len = this.layerList.length; i < len; i++){
						if (this.layerList[i] === layer && !this.subLayerList[i]) {
								this.layerList.splice(i, 1);
								this.subLayerList.splice(i, 1);
								len--;
								this._updateOpaqueOrder(i, len - 1);
								this.subLayerEnabled.splice(i, 1);
								this._dirty = true;
								if (this.layerList.indexOf(layer) < 0) {
										this.fire('remove', layer);
								}
								break;
						}
				}
				this._updateLayerMaps();
		}
		pushTransparent(layer) {
				if (this._isSublayerAdded(layer, true)) return;
				this.layerList.push(layer);
				this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
				this.subLayerEnabled.push(true);
				this._updateLayerMaps();
				this._dirty = true;
				this.fire('add', layer);
		}
		insertTransparent(layer, index) {
				if (this._isSublayerAdded(layer, true)) return;
				this.layerList.splice(index, 0, layer);
				this.subLayerList.splice(index, 0, true);
				var count = this.subLayerList.length;
				this._updateTransparentOrder(index, count - 1);
				this.subLayerEnabled.splice(index, 0, true);
				this._updateLayerMaps();
				this._dirty = true;
				this.fire('add', layer);
		}
		removeTransparent(layer) {
				for(var i = 0, len = this.layerList.length; i < len; i++){
						if (this.layerList[i] === layer && this.subLayerList[i]) {
								this.layerList.splice(i, 1);
								this.subLayerList.splice(i, 1);
								len--;
								this._updateTransparentOrder(i, len - 1);
								this.subLayerEnabled.splice(i, 1);
								this._dirty = true;
								if (this.layerList.indexOf(layer) < 0) {
										this.fire('remove', layer);
								}
								break;
						}
				}
				this._updateLayerMaps();
		}
		getOpaqueIndex(layer) {
				var _this_layerOpaqueIndexMap_get;
				return (_this_layerOpaqueIndexMap_get = this.layerOpaqueIndexMap.get(layer)) != null ? _this_layerOpaqueIndexMap_get : -1;
		}
		getTransparentIndex(layer) {
				var _this_layerTransparentIndexMap_get;
				return (_this_layerTransparentIndexMap_get = this.layerTransparentIndexMap.get(layer)) != null ? _this_layerTransparentIndexMap_get : -1;
		}
		isEnabled(layer, transparent) {
				if (layer.enabled) {
						var index = transparent ? this.getTransparentIndex(layer) : this.getOpaqueIndex(layer);
						if (index >= 0) {
								return this.subLayerEnabled[index];
						}
				}
				return false;
		}
		_updateLayerMaps() {
				this.layerIdMap.clear();
				this.layerNameMap.clear();
				this.layerOpaqueIndexMap.clear();
				this.layerTransparentIndexMap.clear();
				for(var i = 0; i < this.layerList.length; i++){
						var layer = this.layerList[i];
						this.layerIdMap.set(layer.id, layer);
						this.layerNameMap.set(layer.name, layer);
						var subLayerIndexMap = this.subLayerList[i] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
						subLayerIndexMap.set(layer, i);
				}
		}
		getLayerById(id) {
				var _this_layerIdMap_get;
				return (_this_layerIdMap_get = this.layerIdMap.get(id)) != null ? _this_layerIdMap_get : null;
		}
		getLayerByName(name) {
				var _this_layerNameMap_get;
				return (_this_layerNameMap_get = this.layerNameMap.get(name)) != null ? _this_layerNameMap_get : null;
		}
		_updateOpaqueOrder(startIndex, endIndex) {
				for(var i = startIndex; i <= endIndex; i++){
						if (this.subLayerList[i] === false) {
								this._opaqueOrder[this.layerList[i].id] = i;
						}
				}
		}
		_updateTransparentOrder(startIndex, endIndex) {
				for(var i = startIndex; i <= endIndex; i++){
						if (this.subLayerList[i] === true) {
								this._transparentOrder[this.layerList[i].id] = i;
						}
				}
		}
		_sortLayersDescending(layersA, layersB, order) {
				var topLayerA = -1;
				var topLayerB = -1;
				for(var i = 0, len = layersA.length; i < len; i++){
						var id = layersA[i];
						if (order.hasOwnProperty(id)) {
								topLayerA = Math.max(topLayerA, order[id]);
						}
				}
				for(var i1 = 0, len1 = layersB.length; i1 < len1; i1++){
						var id1 = layersB[i1];
						if (order.hasOwnProperty(id1)) {
								topLayerB = Math.max(topLayerB, order[id1]);
						}
				}
				if (topLayerA === -1 && topLayerB !== -1) {
						return 1;
				} else if (topLayerB === -1 && topLayerA !== -1) {
						return -1;
				}
				return topLayerB - topLayerA;
		}
		sortTransparentLayers(layersA, layersB) {
				return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
		}
		sortOpaqueLayers(layersA, layersB) {
				return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
		}
		constructor(name = 'Untitled'){
				super(), this.layerList = [], this.layerIdMap = new Map(), this.layerNameMap = new Map(), this.layerOpaqueIndexMap = new Map(), this.layerTransparentIndexMap = new Map(), this.subLayerList = [], this.subLayerEnabled = [], this.cameras = [], this._renderActions = [], this._dirty = false;
				this.name = name;
				this._opaqueOrder = {};
				this._transparentOrder = {};
		}
}

var tmpVec = new Vec3();
var tmpBiases = {
		bias: 0,
		normalBias: 0
};
var tmpColor = new Color();
var chanId = {
		r: 0,
		g: 1,
		b: 2,
		a: 3
};
var lightTypes = {
		'directional': LIGHTTYPE_DIRECTIONAL,
		'omni': LIGHTTYPE_OMNI,
		'point': LIGHTTYPE_OMNI,
		'spot': LIGHTTYPE_SPOT
};
var directionalCascades = [
		[
				new Vec4(0, 0, 1, 1)
		],
		[
				new Vec4(0, 0, 0.5, 0.5),
				new Vec4(0, 0.5, 0.5, 0.5)
		],
		[
				new Vec4(0, 0, 0.5, 0.5),
				new Vec4(0, 0.5, 0.5, 0.5),
				new Vec4(0.5, 0, 0.5, 0.5)
		],
		[
				new Vec4(0, 0, 0.5, 0.5),
				new Vec4(0, 0.5, 0.5, 0.5),
				new Vec4(0.5, 0, 0.5, 0.5),
				new Vec4(0.5, 0.5, 0.5, 0.5)
		]
];
var channelMap = {
		'rrr': 1,
		'ggg': 2,
		'bbb': 4,
		'aaa': 8,
		'rgb': 7
};
var id = 0;
class LightRenderData {
		destroy() {
				this.viewBindGroups.forEach((bg)=>{
						bg.defaultUniformBuffer.destroy();
						bg.destroy();
				});
				this.viewBindGroups.length = 0;
		}
		get shadowBuffer() {
				var rt = this.shadowCamera.renderTarget;
				if (rt) {
						return this.light._isPcf ? rt.depthBuffer : rt.colorBuffer;
				}
				return null;
		}
		constructor(camera, face, light){
				this.light = light;
				this.camera = camera;
				this.shadowCamera = ShadowRenderer.createShadowCamera(light._shadowType, light._type, face);
				this.shadowMatrix = new Mat4();
				this.shadowViewport = new Vec4(0, 0, 1, 1);
				this.shadowScissor = new Vec4(0, 0, 1, 1);
				this.projectionCompensation = 0;
				this.face = face;
				this.visibleCasters = [];
				this.viewBindGroups = [];
		}
}
class Light {
		destroy() {
				this._destroyShadowMap();
				this.releaseRenderData();
				this._renderData = null;
		}
		releaseRenderData() {
				if (this._renderData) {
						for(var i = 0; i < this._renderData.length; i++){
								this._renderData[i].destroy();
						}
						this._renderData.length = 0;
				}
		}
		addLayer(layer) {
				this.layers.add(layer);
		}
		removeLayer(layer) {
				this.layers.delete(layer);
		}
		set shadowSamples(value) {
				this._softShadowParams[0] = value;
		}
		get shadowSamples() {
				return this._softShadowParams[0];
		}
		set shadowBlockerSamples(value) {
				this._softShadowParams[1] = value;
		}
		get shadowBlockerSamples() {
				return this._softShadowParams[1];
		}
		set shadowBias(value) {
				if (this._shadowBias !== value) {
						this._shadowBias = value;
						this._updateShadowBias();
				}
		}
		get shadowBias() {
				return this._shadowBias;
		}
		set numCascades(value) {
				if (!this.cascades || this.numCascades !== value) {
						this.cascades = directionalCascades[value - 1];
						this._shadowMatrixPalette = new Float32Array(4 * 16);
						this._shadowCascadeDistances = new Float32Array(4);
						this._destroyShadowMap();
						this.updateKey();
				}
		}
		get numCascades() {
				return this.cascades.length;
		}
		set cascadeBlend(value) {
				if (this._cascadeBlend !== value) {
						this._cascadeBlend = value;
						this.updateKey();
				}
		}
		get cascadeBlend() {
				return this._cascadeBlend;
		}
		set shadowMap(shadowMap) {
				if (this._shadowMap !== shadowMap) {
						this._destroyShadowMap();
						this._shadowMap = shadowMap;
				}
		}
		get shadowMap() {
				return this._shadowMap;
		}
		set mask(value) {
				if (this._mask !== value) {
						this._mask = value;
						this.updateKey();
						this.updateClusteredFlags();
				}
		}
		get mask() {
				return this._mask;
		}
		get numShadowFaces() {
				var type = this._type;
				if (type === LIGHTTYPE_DIRECTIONAL) {
						return this.numCascades;
				} else if (type === LIGHTTYPE_OMNI) {
						return 6;
				}
				return 1;
		}
		set type(value) {
				if (this._type === value) {
						return;
				}
				this._type = value;
				this._destroyShadowMap();
				this._updateShadowBias();
				this.updateKey();
				this.updateClusteredFlags();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowUpdateOverrides = null;
				this.shadowType = stype;
		}
		get type() {
				return this._type;
		}
		set shape(value) {
				if (this._shape === value) {
						return;
				}
				this._shape = value;
				this._destroyShadowMap();
				this.updateKey();
				this.updateClusteredFlags();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowType = stype;
		}
		get shape() {
				return this._shape;
		}
		set usePhysicalUnits(value) {
				if (this._usePhysicalUnits !== value) {
						this._usePhysicalUnits = value;
						this._updateLinearColor();
				}
		}
		get usePhysicalUnits() {
				return this._usePhysicalUnits;
		}
		set shadowType(value) {
				if (this._shadowType === value) {
						return;
				}
				var shadowInfo = shadowTypeInfo.get(value);
				if (!shadowInfo) {
						value = SHADOW_PCF3_32F;
				}
				var device = this.device;
				if (value === SHADOW_PCSS_32F && !device.textureFloatRenderable && !device.textureHalfFloatRenderable) {
						value = SHADOW_PCF3_32F;
				}
				if (this._type === LIGHTTYPE_OMNI && value !== SHADOW_PCF1_32F && value !== SHADOW_PCF3_32F && value !== SHADOW_PCF1_16F && value !== SHADOW_PCF3_16F && value !== SHADOW_PCSS_32F) {
						value = SHADOW_PCF3_32F;
				}
				if (value === SHADOW_VSM_32F && (!device.textureFloatRenderable || !device.textureFloatFilterable)) {
						value = SHADOW_VSM_16F;
				}
				if (value === SHADOW_VSM_16F && !device.textureHalfFloatRenderable) {
						value = SHADOW_PCF3_32F;
				}
				shadowInfo = shadowTypeInfo.get(value);
				var _shadowInfo_vsm;
				this._isVsm = (_shadowInfo_vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo_vsm : false;
				var _shadowInfo_pcf;
				this._isPcf = (_shadowInfo_pcf = shadowInfo == null ? void 0 : shadowInfo.pcf) != null ? _shadowInfo_pcf : false;
				this._shadowType = value;
				this._destroyShadowMap();
				this.updateKey();
		}
		get shadowType() {
				return this._shadowType;
		}
		set enabled(value) {
				if (this._enabled !== value) {
						this._enabled = value;
						this.layersDirty();
				}
		}
		get enabled() {
				return this._enabled;
		}
		set castShadows(value) {
				if (this._castShadows !== value) {
						this._castShadows = value;
						this._destroyShadowMap();
						this.layersDirty();
						this.updateKey();
				}
		}
		get castShadows() {
				return this._castShadows && this._mask !== MASK_BAKE && this._mask !== 0;
		}
		set shadowIntensity(value) {
				if (this._shadowIntensity !== value) {
						this._shadowIntensity = value;
						this.updateKey();
				}
		}
		get shadowIntensity() {
				return this._shadowIntensity;
		}
		get bakeShadows() {
				return this._castShadows && this._mask === MASK_BAKE;
		}
		set shadowResolution(value) {
				if (this._shadowResolution !== value) {
						if (this._type === LIGHTTYPE_OMNI) {
								value = Math.min(value, this.device.maxCubeMapSize);
						} else {
								value = Math.min(value, this.device.maxTextureSize);
						}
						this._shadowResolution = value;
						this._destroyShadowMap();
				}
		}
		get shadowResolution() {
				return this._shadowResolution;
		}
		set vsmBlurSize(value) {
				if (this._vsmBlurSize === value) {
						return;
				}
				if (value % 2 === 0) value++;
				this._vsmBlurSize = value;
		}
		get vsmBlurSize() {
				return this._vsmBlurSize;
		}
		set normalOffsetBias(value) {
				if (this._normalOffsetBias !== value) {
						var dirty = !this._normalOffsetBias && value || this._normalOffsetBias && !value;
						this._normalOffsetBias = value;
						if (dirty) {
								this.updateKey();
						}
				}
		}
		get normalOffsetBias() {
				return this._normalOffsetBias;
		}
		set falloffMode(value) {
				if (this._falloffMode === value) {
						return;
				}
				this._falloffMode = value;
				this.updateKey();
				this.updateClusteredFlags();
		}
		get falloffMode() {
				return this._falloffMode;
		}
		set innerConeAngle(value) {
				if (this._innerConeAngle === value) {
						return;
				}
				this._innerConeAngle = value;
				this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
				this.updateClusterData(false, true);
				if (this._usePhysicalUnits) {
						this._updateLinearColor();
				}
		}
		get innerConeAngle() {
				return this._innerConeAngle;
		}
		set outerConeAngle(value) {
				if (this._outerConeAngle === value) {
						return;
				}
				this._outerConeAngle = value;
				this._updateOuterAngle(value);
				if (this._usePhysicalUnits) {
						this._updateLinearColor();
				}
		}
		get outerConeAngle() {
				return this._outerConeAngle;
		}
		set penumbraSize(value) {
				this._penumbraSize = value;
				this._softShadowParams[2] = value;
		}
		get penumbraSize() {
				return this._penumbraSize;
		}
		set penumbraFalloff(value) {
				this._softShadowParams[3] = value;
		}
		get penumbraFalloff() {
				return this._softShadowParams[3];
		}
		_updateOuterAngle(angle) {
				var radAngle = angle * Math.PI / 180;
				this._outerConeAngleCos = Math.cos(radAngle);
				this._outerConeAngleSin = Math.sin(radAngle);
				this.updateClusterData(false, true);
		}
		set intensity(value) {
				if (this._intensity !== value) {
						this._intensity = value;
						this._updateLinearColor();
				}
		}
		get intensity() {
				return this._intensity;
		}
		set affectSpecularity(value) {
				if (this._type === LIGHTTYPE_DIRECTIONAL) {
						this._affectSpecularity = value;
						this.updateKey();
				}
		}
		get affectSpecularity() {
				return this._affectSpecularity;
		}
		set luminance(value) {
				if (this._luminance !== value) {
						this._luminance = value;
						this._updateLinearColor();
				}
		}
		get luminance() {
				return this._luminance;
		}
		get cookieMatrix() {
				if (!this._cookieMatrix) {
						this._cookieMatrix = new Mat4();
				}
				return this._cookieMatrix;
		}
		get atlasViewport() {
				if (!this._atlasViewport) {
						this._atlasViewport = new Vec4(0, 0, 1, 1);
				}
				return this._atlasViewport;
		}
		set cookie(value) {
				if (this._cookie === value) {
						return;
				}
				this._cookie = value;
				this.updateKey();
		}
		get cookie() {
				return this._cookie;
		}
		set cookieFalloff(value) {
				if (this._cookieFalloff === value) {
						return;
				}
				this._cookieFalloff = value;
				this.updateKey();
		}
		get cookieFalloff() {
				return this._cookieFalloff;
		}
		set cookieChannel(value) {
				if (this._cookieChannel === value) {
						return;
				}
				if (value.length < 3) {
						var chr = value.charAt(value.length - 1);
						var addLen = 3 - value.length;
						for(var i = 0; i < addLen; i++){
								value += chr;
						}
				}
				this._cookieChannel = value;
				this.updateKey();
				this.updateClusteredFlags();
		}
		get cookieChannel() {
				return this._cookieChannel;
		}
		set cookieTransform(value) {
				if (this._cookieTransform === value) {
						return;
				}
				this._cookieTransform = value;
				this._cookieTransformSet = !!value;
				if (value && !this._cookieOffset) {
						this.cookieOffset = new Vec2();
						this._cookieOffsetSet = false;
				}
				this.updateKey();
		}
		get cookieTransform() {
				return this._cookieTransform;
		}
		set cookieOffset(value) {
				if (this._cookieOffset === value) {
						return;
				}
				var xformNew = !!(this._cookieTransformSet || value);
				if (xformNew && !value && this._cookieOffset) {
						this._cookieOffset.set(0, 0);
				} else {
						this._cookieOffset = value;
				}
				this._cookieOffsetSet = !!value;
				if (value && !this._cookieTransform) {
						this.cookieTransform = new Vec4(1, 1, 0, 0);
						this._cookieTransformSet = false;
				}
				this.updateKey();
		}
		get cookieOffset() {
				return this._cookieOffset;
		}
		beginFrame() {
				this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
				this.maxScreenSize = 0;
				this.atlasViewportAllocated = false;
				this.atlasSlotUpdated = false;
		}
		_destroyShadowMap() {
				this.releaseRenderData();
				if (this._shadowMap) {
						if (!this._shadowMap.cached) {
								this._shadowMap.destroy();
						}
						this._shadowMap = null;
				}
				if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
						this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
				}
				if (this.shadowUpdateOverrides) {
						for(var i = 0; i < this.shadowUpdateOverrides.length; i++){
								if (this.shadowUpdateOverrides[i] === SHADOWUPDATE_NONE) {
										this.shadowUpdateOverrides[i] = SHADOWUPDATE_THISFRAME;
								}
						}
				}
		}
		getRenderData(camera, face) {
				for(var i = 0; i < this._renderData.length; i++){
						var current = this._renderData[i];
						if (current.camera === camera && current.face === face) {
								return current;
						}
				}
				var rd = new LightRenderData(camera, face, this);
				this._renderData.push(rd);
				return rd;
		}
		clone() {
				var clone = new Light(this.device, this.clusteredLighting);
				clone.type = this._type;
				clone.setColor(this._color);
				clone.intensity = this._intensity;
				clone.affectSpecularity = this._affectSpecularity;
				clone.luminance = this._luminance;
				clone.castShadows = this.castShadows;
				clone._enabled = this._enabled;
				clone.attenuationStart = this.attenuationStart;
				clone.attenuationEnd = this.attenuationEnd;
				clone.falloffMode = this._falloffMode;
				clone.shadowType = this._shadowType;
				clone.vsmBlurSize = this._vsmBlurSize;
				clone.vsmBlurMode = this.vsmBlurMode;
				clone.vsmBias = this.vsmBias;
				clone.shadowUpdateMode = this.shadowUpdateMode;
				clone.mask = this.mask;
				if (this.shadowUpdateOverrides) {
						clone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();
				}
				clone.innerConeAngle = this._innerConeAngle;
				clone.outerConeAngle = this._outerConeAngle;
				clone.numCascades = this.numCascades;
				clone.cascadeDistribution = this.cascadeDistribution;
				clone.cascadeBlend = this._cascadeBlend;
				clone.shape = this._shape;
				clone.shadowDepthState.copy(this.shadowDepthState);
				clone.shadowBias = this.shadowBias;
				clone.normalOffsetBias = this._normalOffsetBias;
				clone.shadowResolution = this._shadowResolution;
				clone.shadowDistance = this.shadowDistance;
				clone.shadowIntensity = this.shadowIntensity;
				clone.shadowSamples = this.shadowSamples;
				clone.shadowBlockerSamples = this.shadowBlockerSamples;
				clone.penumbraSize = this.penumbraSize;
				clone.penumbraFalloff = this.penumbraFalloff;
				return clone;
		}
		static getLightUnitConversion(type, outerAngle, innerAngle) {
				if (outerAngle === void 0) outerAngle = Math.PI / 4;
				if (innerAngle === void 0) innerAngle = 0;
				switch(type){
						case LIGHTTYPE_SPOT:
								{
										var falloffEnd = Math.cos(outerAngle);
										var falloffStart = Math.cos(innerAngle);
										return 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2.0);
								}
						case LIGHTTYPE_OMNI:
								return 4 * Math.PI;
						case LIGHTTYPE_DIRECTIONAL:
								return 1;
				}
		}
		_getUniformBiasValues(lightRenderData) {
				var farClip = lightRenderData.shadowCamera._farClip;
				switch(this._type){
						case LIGHTTYPE_OMNI:
								tmpBiases.bias = this.shadowBias;
								tmpBiases.normalBias = this._normalOffsetBias;
								break;
						case LIGHTTYPE_SPOT:
								if (this._isVsm) {
										tmpBiases.bias = -1e-5 * 20;
								} else {
										tmpBiases.bias = this.shadowBias * 20;
								}
								tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
								break;
						case LIGHTTYPE_DIRECTIONAL:
								if (this._isVsm) {
										tmpBiases.bias = -1e-5 * 20;
								} else {
										tmpBiases.bias = this.shadowBias / farClip * 100;
								}
								tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
								break;
				}
				return tmpBiases;
		}
		getColor() {
				return this._color;
		}
		getBoundingSphere(sphere) {
				if (this._type === LIGHTTYPE_SPOT) {
						var size = this.attenuationEnd;
						var angle = this._outerConeAngle;
						var cosAngle = this._outerConeAngleCos;
						var node = this._node;
						tmpVec.copy(node.up);
						if (angle > 45) {
								sphere.radius = size * this._outerConeAngleSin;
								tmpVec.mulScalar(-size * cosAngle);
						} else {
								sphere.radius = size / (2 * cosAngle);
								tmpVec.mulScalar(-sphere.radius);
						}
						sphere.center.add2(node.getPosition(), tmpVec);
				} else if (this._type === LIGHTTYPE_OMNI) {
						sphere.center = this._node.getPosition();
						sphere.radius = this.attenuationEnd;
				}
		}
		getBoundingBox(box) {
				if (this._type === LIGHTTYPE_SPOT) {
						var range = this.attenuationEnd;
						var angle = this._outerConeAngle;
						var node = this._node;
						var scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
						box.center.set(0, -range * 0.5, 0);
						box.halfExtents.set(scl, range * 0.5, scl);
						box.setFromTransformedAabb(box, node.getWorldTransform(), true);
				} else if (this._type === LIGHTTYPE_OMNI) {
						box.center.copy(this._node.getPosition());
						box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
				}
		}
		_updateShadowBias() {
				if (this._type === LIGHTTYPE_OMNI && !this.clusteredLighting) {
						this.shadowDepthState.depthBias = 0;
						this.shadowDepthState.depthBiasSlope = 0;
				} else {
						var bias = this.shadowBias * -1e3;
						this.shadowDepthState.depthBias = bias;
						this.shadowDepthState.depthBiasSlope = bias;
				}
		}
		_updateLinearColor() {
				var intensity = this._intensity;
				if (this._usePhysicalUnits) {
						intensity = this._luminance / Light.getLightUnitConversion(this._type, this._outerConeAngle * math.DEG_TO_RAD, this._innerConeAngle * math.DEG_TO_RAD);
				}
				var color = this._color;
				var colorLinear = this._colorLinear;
				if (intensity >= 1) {
						tmpColor.linear(color).mulScalar(intensity);
				} else {
						tmpColor.copy(color).mulScalar(intensity).linear();
				}
				colorLinear[0] = tmpColor.r;
				colorLinear[1] = tmpColor.g;
				colorLinear[2] = tmpColor.b;
				this.updateClusterData(true);
		}
		setColor() {
				if (arguments.length === 1) {
						this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
				} else if (arguments.length === 3) {
						this._color.set(arguments[0], arguments[1], arguments[2]);
				}
				this._updateLinearColor();
		}
		layersDirty() {
				this.layers.forEach((layer)=>{
						if (layer.hasLight(this)) {
								layer.markLightsDirty();
						}
				});
		}
		updateKey() {
				var key = this._type << 29 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | (this.numCascades > 0 ? 1 : 0) << 9 | (this._cascadeBlend > 0 ? 1 : 0) << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6 | (this._castShadows ? 1 : 0) << 3;
				if (this._cookieChannel.length === 3) {
						key |= chanId[this._cookieChannel.charAt(1)] << 16;
						key |= chanId[this._cookieChannel.charAt(2)] << 14;
				}
				if (key !== this.key) {
						this.layersDirty();
				}
				this.key = key;
		}
		updateClusteredFlags() {
				var isDynamic = !!(this.mask & MASK_AFFECT_DYNAMIC);
				var isLightmapped = !!(this.mask & MASK_AFFECT_LIGHTMAPPED);
				var _channelMap_this__cookieChannel;
				this.clusteredFlags = (this.type === LIGHTTYPE_SPOT ? 1 : 0) << 30 | (this._shape & 0x3) << 28 | (this._falloffMode & 0x1) << 27 | ((_channelMap_this__cookieChannel = channelMap[this._cookieChannel]) != null ? _channelMap_this__cookieChannel : 0) << 23 | (isDynamic ? 1 : 0) << 22 | (isLightmapped ? 1 : 0) << 21;
		}
		getClusteredFlags(castShadows, useCookie) {
				return this.clusteredFlags | ((castShadows ? Math.floor(this.shadowIntensity * 255) : 0) & 0xFF) << 0 | ((useCookie ? Math.floor(this.cookieIntensity * 255) : 0) & 0xFF) << 8;
		}
		updateClusterData(updateColor, updateAngles) {
				var { clusteredData16 } = this;
				var float2Half = FloatPacking.float2Half;
				if (updateColor) {
						clusteredData16[0] = float2Half(this._colorLinear[0]);
						clusteredData16[1] = float2Half(this._colorLinear[1]);
						clusteredData16[2] = float2Half(this._colorLinear[2]);
				}
				if (updateAngles) {
						clusteredData16[4] = float2Half(this._innerConeAngleCos);
						clusteredData16[5] = float2Half(this._outerConeAngleCos);
				}
		}
		constructor(graphicsDevice, clusteredLighting){
				this.layers = new Set();
				this.shadowDepthState = DepthState.DEFAULT.clone();
				this.clusteredFlags = 0;
				this.clusteredData = new Uint32Array(3);
				this.clusteredData16 = new Uint16Array(this.clusteredData.buffer);
				this.device = graphicsDevice;
				this.clusteredLighting = clusteredLighting;
				this.id = id++;
				this._type = LIGHTTYPE_DIRECTIONAL;
				this._color = new Color(0.8, 0.8, 0.8);
				this._intensity = 1;
				this._affectSpecularity = true;
				this._luminance = 0;
				this._castShadows = false;
				this._enabled = false;
				this._mask = MASK_AFFECT_DYNAMIC;
				this.isStatic = false;
				this.key = 0;
				this.bakeDir = true;
				this.bakeNumSamples = 1;
				this.bakeArea = 0;
				this.attenuationStart = 10;
				this.attenuationEnd = 10;
				this._falloffMode = LIGHTFALLOFF_LINEAR;
				this._shadowType = SHADOW_PCF3_32F;
				this._vsmBlurSize = 11;
				this.vsmBlurMode = BLUR_GAUSSIAN;
				this.vsmBias = 0.01 * 0.25;
				this._cookie = null;
				this.cookieIntensity = 1;
				this._cookieFalloff = true;
				this._cookieChannel = 'rgb';
				this._cookieTransform = null;
				this._cookieTransformUniform = new Float32Array(4);
				this._cookieOffset = null;
				this._cookieOffsetUniform = new Float32Array(2);
				this._cookieTransformSet = false;
				this._cookieOffsetSet = false;
				this._innerConeAngle = 40;
				this._outerConeAngle = 45;
				this.cascades = null;
				this._shadowMatrixPalette = null;
				this._shadowCascadeDistances = null;
				this.numCascades = 1;
				this._cascadeBlend = 0;
				this.cascadeDistribution = 0.5;
				this._shape = LIGHTSHAPE_PUNCTUAL;
				this._colorLinear = new Float32Array(3);
				this._updateLinearColor();
				this._position = new Vec3(0, 0, 0);
				this._direction = new Vec3(0, 0, 0);
				this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
				this._updateOuterAngle(this._outerConeAngle);
				this._usePhysicalUnits = undefined;
				this._shadowMap = null;
				this._shadowRenderParams = [];
				this._shadowCameraParams = [];
				this.shadowDistance = 40;
				this._shadowResolution = 1024;
				this._shadowBias = -5e-4;
				this._shadowIntensity = 1.0;
				this._normalOffsetBias = 0.0;
				this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
				this.shadowUpdateOverrides = null;
				this._isVsm = false;
				this._isPcf = true;
				this._softShadowParams = new Float32Array(4);
				this.shadowSamples = 16;
				this.shadowBlockerSamples = 16;
				this.penumbraSize = 1.0;
				this.penumbraFalloff = 1.0;
				this._cookieMatrix = null;
				this._atlasViewport = null;
				this.atlasViewportAllocated = false;
				this.atlasVersion = 0;
				this.atlasSlotIndex = 0;
				this.atlasSlotUpdated = false;
				this._node = null;
				this._renderData = [];
				this.visibleThisFrame = false;
				this.maxScreenSize = 0;
				this._updateShadowBias();
		}
}

class LightingParams {
		applySettings(render) {
				var _render_lightingShadowsEnabled;
				this.shadowsEnabled = (_render_lightingShadowsEnabled = render.lightingShadowsEnabled) != null ? _render_lightingShadowsEnabled : this.shadowsEnabled;
				var _render_lightingCookiesEnabled;
				this.cookiesEnabled = (_render_lightingCookiesEnabled = render.lightingCookiesEnabled) != null ? _render_lightingCookiesEnabled : this.cookiesEnabled;
				var _render_lightingAreaLightsEnabled;
				this.areaLightsEnabled = (_render_lightingAreaLightsEnabled = render.lightingAreaLightsEnabled) != null ? _render_lightingAreaLightsEnabled : this.areaLightsEnabled;
				var _render_lightingShadowAtlasResolution;
				this.shadowAtlasResolution = (_render_lightingShadowAtlasResolution = render.lightingShadowAtlasResolution) != null ? _render_lightingShadowAtlasResolution : this.shadowAtlasResolution;
				var _render_lightingCookieAtlasResolution;
				this.cookieAtlasResolution = (_render_lightingCookieAtlasResolution = render.lightingCookieAtlasResolution) != null ? _render_lightingCookieAtlasResolution : this.cookieAtlasResolution;
				var _render_lightingMaxLightsPerCell;
				this.maxLightsPerCell = (_render_lightingMaxLightsPerCell = render.lightingMaxLightsPerCell) != null ? _render_lightingMaxLightsPerCell : this.maxLightsPerCell;
				var _render_lightingShadowType;
				this.shadowType = (_render_lightingShadowType = render.lightingShadowType) != null ? _render_lightingShadowType : this.shadowType;
				if (render.lightingCells) {
						this.cell = new Vec3(render.lightingCells);
				}
		}
		set cells(value) {
				this._cells.copy(value);
		}
		get cells() {
				return this._cells;
		}
		set maxLightsPerCell(value) {
				this._maxLightsPerCell = math.clamp(value, 1, 255);
		}
		get maxLightsPerCell() {
				return this._maxLightsPerCell;
		}
		set cookieAtlasResolution(value) {
				this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
		}
		get cookieAtlasResolution() {
				return this._cookieAtlasResolution;
		}
		set shadowAtlasResolution(value) {
				this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
		}
		get shadowAtlasResolution() {
				return this._shadowAtlasResolution;
		}
		set shadowType(value) {
				if (this._shadowType !== value) {
						this._shadowType = value;
						this._dirtyLightsFnc();
				}
		}
		get shadowType() {
				return this._shadowType;
		}
		set cookiesEnabled(value) {
				if (this._cookiesEnabled !== value) {
						this._cookiesEnabled = value;
						this._dirtyLightsFnc();
				}
		}
		get cookiesEnabled() {
				return this._cookiesEnabled;
		}
		set areaLightsEnabled(value) {
				if (this._supportsAreaLights) {
						if (this._areaLightsEnabled !== value) {
								this._areaLightsEnabled = value;
								this._dirtyLightsFnc();
						}
				}
		}
		get areaLightsEnabled() {
				return this._areaLightsEnabled;
		}
		set shadowsEnabled(value) {
				if (this._shadowsEnabled !== value) {
						this._shadowsEnabled = value;
						this._dirtyLightsFnc();
				}
		}
		get shadowsEnabled() {
				return this._shadowsEnabled;
		}
		constructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc){
				this._areaLightsEnabled = false;
				this._cells = new Vec3(10, 3, 10);
				this._maxLightsPerCell = 255;
				this._shadowsEnabled = true;
				this._shadowType = SHADOW_PCF3_32F;
				this._shadowAtlasResolution = 2048;
				this._cookiesEnabled = false;
				this._cookieAtlasResolution = 2048;
				this.atlasSplit = null;
				this._supportsAreaLights = supportsAreaLights;
				this._maxTextureSize = maxTextureSize;
				this._dirtyLightsFnc = dirtyLightsFnc;
		}
}

var blendStateAdditive = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
class MorphInstance {
		destroy() {
				this.shader = null;
				var morph = this.morph;
				if (morph) {
						this.morph = null;
						morph.decRefCount();
						if (morph.refCount < 1) {
								morph.destroy();
						}
				}
				if (this.rtPositions) {
						this.rtPositions.destroy();
						this.rtPositions = null;
				}
				if (this.texturePositions) {
						this.texturePositions.destroy();
						this.texturePositions = null;
				}
				if (this.rtNormals) {
						this.rtNormals.destroy();
						this.rtNormals = null;
				}
				if (this.textureNormals) {
						this.textureNormals.destroy();
						this.textureNormals = null;
				}
		}
		clone() {
				return new MorphInstance(this.morph);
		}
		_getWeightIndex(key) {
				if (typeof key === 'string') {
						var index = this._weightMap.get(key);
						return index;
				}
				return key;
		}
		getWeight(key) {
				var index = this._getWeightIndex(key);
				return this._weights[index];
		}
		setWeight(key, weight) {
				var index = this._getWeightIndex(key);
				this._weights[index] = weight;
				this._dirty = true;
		}
		_getShader(count) {
				var shader = this.shaderCache[count];
				if (!shader) {
						var wgsl = this.device.isWebGPU;
						var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
						var defines = new Map();
						defines.set('MORPH_TEXTURE_COUNT', count);
						defines.set('{MORPH_TEXTURE_COUNT}', count);
						if (this.morph.intRenderFormat) defines.set('MORPH_INT', '');
						var includes = new Map();
						includes.set('morphDeclarationPS', chunks.morphDeclarationPS);
						includes.set('morphEvaluationPS', chunks.morphEvaluationPS);
						var outputType = this.morph.intRenderFormat ? 'uvec4' : 'vec4';
						shader = createShaderFromCode(this.device, chunks.morphVS, chunks.morphPS, "textureMorph" + count, {
								vertex_position: SEMANTIC_POSITION
						}, {
								shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL,
								fragmentIncludes: includes,
								fragmentDefines: defines,
								fragmentOutputTypes: [
										outputType
								]
						});
						this.shaderCache[count] = shader;
				}
				return shader;
		}
		_updateTextureRenderTarget(renderTarget, srcTextureName, isPos) {
				var device = this.device;
				var submitBatch = (usedCount, blending)=>{
						this.morphFactor.setValue(this._shaderMorphWeights);
						device.setBlendState(blending ? blendStateAdditive : BlendState.NOBLEND);
						var shader = this._getShader(usedCount);
						drawQuadWithShader(device, renderTarget, shader);
				};
				this.setAabbUniforms(isPos);
				var usedCount = 0;
				var blending = false;
				var count = this._activeTargets.length;
				for(var i = 0; i < count; i++){
						var activeTarget = this._activeTargets[i];
						var tex = activeTarget.target[srcTextureName];
						if (tex) {
								this["morphBlendTex" + usedCount].setValue(tex);
								this._shaderMorphWeights[usedCount] = activeTarget.weight;
								usedCount++;
								if (usedCount >= this.maxSubmitCount) {
										submitBatch(usedCount, blending);
										usedCount = 0;
										blending = true;
								}
						}
				}
				if (usedCount > 0 || count === 0 && !this.zeroTextures) {
						submitBatch(usedCount, blending);
				}
		}
		_updateTextureMorph() {
				this.device;
				if (this._activeTargets.length > 0 || !this.zeroTextures) {
						if (this.rtPositions) {
								this._updateTextureRenderTarget(this.rtPositions, 'texturePositions', true);
						}
						if (this.rtNormals) {
								this._updateTextureRenderTarget(this.rtNormals, 'textureNormals', false);
						}
						this.zeroTextures = this._activeTargets.length === 0;
				}
		}
		setAabbUniforms(isPos) {
				if (isPos === void 0) isPos = true;
				this.aabbSizeId.setValue(isPos ? this._aabbSize : this._aabbNrmSize);
				this.aabbMinId.setValue(isPos ? this._aabbMin : this._aabbNrmMin);
		}
		prepareRendering(device) {
				this.setAabbUniforms();
		}
		update() {
				this._dirty = false;
				var targets = this.morph._targets;
				var activeCount = 0;
				var epsilon = 0.00001;
				for(var i = 0; i < targets.length; i++){
						var absWeight = Math.abs(this.getWeight(i));
						if (absWeight > epsilon) {
								if (this._activeTargets.length <= activeCount) {
										this._activeTargets[activeCount] = {};
								}
								var activeTarget = this._activeTargets[activeCount++];
								activeTarget.absWeight = absWeight;
								activeTarget.weight = this.getWeight(i);
								activeTarget.target = targets[i];
						}
				}
				this._activeTargets.length = activeCount;
				if (this.morph.intRenderFormat) {
						if (this._activeTargets.length > this.maxSubmitCount) {
								this._activeTargets.sort((l, r)=>{
										return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
								});
								this._activeTargets.length = this.maxSubmitCount;
						}
				}
				this._updateTextureMorph();
		}
		constructor(morph){
				this.shaderCache = [];
				this.morph = morph;
				morph.incRefCount();
				this.device = morph.device;
				this._weights = [];
				this._weightMap = new Map();
				for(var v = 0; v < morph._targets.length; v++){
						var target = morph._targets[v];
						if (target.name) {
								this._weightMap.set(target.name, v);
						}
						this.setWeight(v, target.defaultWeight);
				}
				this._activeTargets = [];
				this.maxSubmitCount = this.device.maxTextures;
				this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
				var createRT = (name, textureVar)=>{
						this[textureVar] = morph._createTexture(name, morph._renderTextureFormat);
						return new RenderTarget({
								colorBuffer: this[textureVar],
								depth: false
						});
				};
				if (morph.morphPositions) {
						this.rtPositions = createRT('MorphRTPos', 'texturePositions');
				}
				if (morph.morphNormals) {
						this.rtNormals = createRT('MorphRTNrm', 'textureNormals');
				}
				this._textureParams = new Float32Array([
						morph.morphTextureWidth,
						morph.morphTextureHeight
				]);
				var halfSize = morph.aabb.halfExtents;
				this._aabbSize = new Float32Array([
						halfSize.x * 4,
						halfSize.y * 4,
						halfSize.z * 4
				]);
				var min = morph.aabb.getMin();
				this._aabbMin = new Float32Array([
						min.x * 2,
						min.y * 2,
						min.z * 2
				]);
				this._aabbNrmSize = new Float32Array([
						2,
						2,
						2
				]);
				this._aabbNrmMin = new Float32Array([
						-1,
						-1,
						-1
				]);
				this.aabbSizeId = this.device.scope.resolve('aabbSize');
				this.aabbMinId = this.device.scope.resolve('aabbMin');
				for(var i = 0; i < this.maxSubmitCount; i++){
						this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
				}
				this.morphFactor = this.device.scope.resolve('morphFactor[0]');
				this.zeroTextures = false;
		}
}

class Model {
		getGraph() {
				return this.graph;
		}
		setGraph(graph) {
				this.graph = graph;
		}
		getCameras() {
				return this.cameras;
		}
		setCameras(cameras) {
				this.cameras = cameras;
		}
		getLights() {
				return this.lights;
		}
		setLights(lights) {
				this.lights = lights;
		}
		getMaterials() {
				var materials = [];
				for(var i = 0; i < this.meshInstances.length; i++){
						var meshInstance = this.meshInstances[i];
						if (materials.indexOf(meshInstance.material) === -1) {
								materials.push(meshInstance.material);
						}
				}
				return materials;
		}
		clone() {
				var srcNodes = [];
				var cloneNodes = [];
				var _duplicate = function _duplicate1(node) {
						var newNode = node.clone();
						srcNodes.push(node);
						cloneNodes.push(newNode);
						for(var idx = 0; idx < node._children.length; idx++){
								newNode.addChild(_duplicate(node._children[idx]));
						}
						return newNode;
				};
				var cloneGraph = _duplicate(this.graph);
				var cloneMeshInstances = [];
				var cloneSkinInstances = [];
				var cloneMorphInstances = [];
				for(var i = 0; i < this.skinInstances.length; i++){
						var skin = this.skinInstances[i].skin;
						var cloneSkinInstance = new SkinInstance(skin);
						var bones = [];
						for(var j = 0; j < skin.boneNames.length; j++){
								var boneName = skin.boneNames[j];
								var bone = cloneGraph.findByName(boneName);
								bones.push(bone);
						}
						cloneSkinInstance.bones = bones;
						cloneSkinInstances.push(cloneSkinInstance);
				}
				for(var i1 = 0; i1 < this.morphInstances.length; i1++){
						var morph = this.morphInstances[i1].morph;
						var cloneMorphInstance = new MorphInstance(morph);
						cloneMorphInstances.push(cloneMorphInstance);
				}
				for(var i2 = 0; i2 < this.meshInstances.length; i2++){
						var meshInstance = this.meshInstances[i2];
						var nodeIndex = srcNodes.indexOf(meshInstance.node);
						var cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);
						if (meshInstance.skinInstance) {
								var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
								cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
						}
						if (meshInstance.morphInstance) {
								var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
								cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
						}
						cloneMeshInstances.push(cloneMeshInstance);
				}
				var clone = new Model();
				clone.graph = cloneGraph;
				clone.meshInstances = cloneMeshInstances;
				clone.skinInstances = cloneSkinInstances;
				clone.morphInstances = cloneMorphInstances;
				clone.getGraph().syncHierarchy();
				return clone;
		}
		destroy() {
				var meshInstances = this.meshInstances;
				for(var i = 0; i < meshInstances.length; i++){
						meshInstances[i].destroy();
				}
				this.meshInstances.length = 0;
		}
		generateWireframe() {
				MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
		}
		constructor(){
				this.graph = null;
				this.meshInstances = [];
				this.skinInstances = [];
				this.morphInstances = [];
				this.cameras = [];
				this.lights = [];
				this._shadersVersion = 0;
				this._immutable = false;
		}
}

class Morph extends RefCountedObject {
		get aabb() {
				if (!this._aabb) {
						var min = new Vec3();
						var max = new Vec3();
						for(var i = 0; i < this._targets.length; i++){
								var targetAabb = this._targets[i].aabb;
								min.min(targetAabb.getMin());
								max.max(targetAabb.getMax());
						}
						this._aabb = new BoundingBox();
						this._aabb.setMinMax(min, max);
				}
				return this._aabb;
		}
		get morphPositions() {
				return this._morphPositions;
		}
		get morphNormals() {
				return this._morphNormals;
		}
		_init() {
				this._initTextureBased();
				for(var i = 0; i < this._targets.length; i++){
						this._targets[i]._postInit();
				}
		}
		_findSparseSet(deltaArrays, ids, usedDataIndices) {
				var freeIndex = 1;
				var dataCount = deltaArrays[0].length;
				for(var v = 0; v < dataCount; v += 3){
						var vertexUsed = false;
						for(var i = 0; i < deltaArrays.length; i++){
								var data = deltaArrays[i];
								if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
										vertexUsed = true;
										break;
								}
						}
						if (vertexUsed) {
								ids.push(freeIndex);
								usedDataIndices.push(v / 3);
								freeIndex++;
						} else {
								ids.push(0);
						}
				}
				return freeIndex;
		}
		_initTextureBased() {
				var deltaArrays = [], deltaInfos = [];
				for(var i = 0; i < this._targets.length; i++){
						var target = this._targets[i];
						if (target.options.deltaPositions) {
								deltaArrays.push(target.options.deltaPositions);
								deltaInfos.push({
										target: target,
										name: 'texturePositions'
								});
						}
						if (target.options.deltaNormals) {
								deltaArrays.push(target.options.deltaNormals);
								deltaInfos.push({
										target: target,
										name: 'textureNormals'
								});
						}
				}
				var ids = [], usedDataIndices = [];
				var freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices);
				var maxTextureSize = this.device.maxTextureSize;
				var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
				morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
				var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
				if (morphTextureHeight > maxTextureSize) {
						return false;
				}
				this.morphTextureWidth = morphTextureWidth;
				this.morphTextureHeight = morphTextureHeight;
				var halfFloat = false;
				var float2Half = FloatPacking.float2Half;
				if (this._textureFormat === PIXELFORMAT_RGBA16F) {
						halfFloat = true;
				}
				var textures = [];
				for(var i1 = 0; i1 < deltaArrays.length; i1++){
						textures.push(this._createTexture('MorphTarget', this._textureFormat));
				}
				for(var i2 = 0; i2 < deltaArrays.length; i2++){
						var data = deltaArrays[i2];
						var texture = textures[i2];
						var textureData = texture.lock();
						if (halfFloat) {
								for(var v = 0; v < usedDataIndices.length; v++){
										var index = usedDataIndices[v] * 3;
										var dstIndex = v * 4 + 4;
										textureData[dstIndex] = float2Half(data[index]);
										textureData[dstIndex + 1] = float2Half(data[index + 1]);
										textureData[dstIndex + 2] = float2Half(data[index + 2]);
								}
						} else {
								for(var v1 = 0; v1 < usedDataIndices.length; v1++){
										var index1 = usedDataIndices[v1] * 3;
										var dstIndex1 = v1 * 4 + 4;
										textureData[dstIndex1] = data[index1];
										textureData[dstIndex1 + 1] = data[index1 + 1];
										textureData[dstIndex1 + 2] = data[index1 + 2];
								}
						}
						texture.unlock();
						var target1 = deltaInfos[i2].target;
						target1._setTexture(deltaInfos[i2].name, texture);
				}
				var formatDesc = [
						{
								semantic: SEMANTIC_ATTR15,
								components: 1,
								type: TYPE_UINT32,
								asInt: true
						}
				];
				this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, {
						data: new Uint32Array(ids)
				});
				return true;
		}
		destroy() {
				var _this_vertexBufferIds;
				(_this_vertexBufferIds = this.vertexBufferIds) == null ? void 0 : _this_vertexBufferIds.destroy();
				this.vertexBufferIds = null;
				for(var i = 0; i < this._targets.length; i++){
						this._targets[i].destroy();
				}
				this._targets.length = 0;
		}
		get targets() {
				return this._targets;
		}
		_updateMorphFlags() {
				this._morphPositions = false;
				this._morphNormals = false;
				for(var i = 0; i < this._targets.length; i++){
						var target = this._targets[i];
						if (target.morphPositions) {
								this._morphPositions = true;
						}
						if (target.morphNormals) {
								this._morphNormals = true;
						}
				}
		}
		_createTexture(name, format) {
				return new Texture(this.device, {
						width: this.morphTextureWidth,
						height: this.morphTextureHeight,
						format: format,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						name: name
				});
		}
		constructor(targets, graphicsDevice, { preferHighPrecision = false } = {}){
				super();
				this.device = graphicsDevice;
				var device = graphicsDevice;
				this.preferHighPrecision = preferHighPrecision;
				this._targets = targets.slice();
				var renderableHalf = device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
				var renderableFloat = device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
				this._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;
				var _this__renderTextureFormat;
				this._renderTextureFormat = (_this__renderTextureFormat = this._renderTextureFormat) != null ? _this__renderTextureFormat : PIXELFORMAT_RGBA16U;
				this.intRenderFormat = isIntegerPixelFormat(this._renderTextureFormat);
				this._textureFormat = this.preferHighPrecision ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
				this._init();
				this._updateMorphFlags();
		}
}

class MorphTarget {
		destroy() {
				var _this_texturePositions, _this_textureNormals;
				(_this_texturePositions = this.texturePositions) == null ? void 0 : _this_texturePositions.destroy();
				this.texturePositions = null;
				(_this_textureNormals = this.textureNormals) == null ? void 0 : _this_textureNormals.destroy();
				this.textureNormals = null;
		}
		get name() {
				return this._name;
		}
		get defaultWeight() {
				return this._defaultWeight;
		}
		get aabb() {
				if (!this._aabb) {
						this._aabb = new BoundingBox();
						if (this.deltaPositions) {
								this._aabb.compute(this.deltaPositions);
						}
				}
				return this._aabb;
		}
		get morphPositions() {
				return !!this.texturePositions;
		}
		get morphNormals() {
				return !!this.textureNormals;
		}
		clone() {
				return new MorphTarget(this.options);
		}
		_postInit() {
				if (!this.options.preserveData) {
						this.options = null;
				}
				this.used = true;
		}
		_setTexture(name, texture) {
				this[name] = texture;
		}
		constructor(options){
				this.used = false;
				this.options = options;
				this._name = options.name;
				this._defaultWeight = options.defaultWeight || 0;
				this._aabb = options.aabb;
				this.deltaPositions = options.deltaPositions;
		}
}

var nonUniformScale;
var uniformScale = 1;
var particleTexChannels$1 = 4;
var rotMat = new Mat4();
var rotMatInv = new Mat4();
var randomPosTformed = new Vec3();
var randomPos = new Vec3();
var rndFactor3Vec = new Vec3();
var particlePosPrev = new Vec3();
var velocityVec = new Vec3();
var localVelocityVec = new Vec3();
var velocityVec2 = new Vec3();
var localVelocityVec2 = new Vec3();
var radialVelocityVec = new Vec3();
var particlePos = new Vec3();
var particleFinalPos = new Vec3();
var moveDirVec = new Vec3();
var tmpVec3$1 = new Vec3();
function frac(f) {
		return f - Math.floor(f);
}
function saturate$1(x) {
		return Math.max(Math.min(x, 1), 0);
}
function glMod(x, y) {
		return x - y * Math.floor(x / y);
}
function encodeFloatRGBA(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		var encZ = frac(65025.0 * v);
		var encW = frac(160581375.0 * v);
		encX -= encY / 255.0;
		encY -= encZ / 255.0;
		encZ -= encW / 255.0;
		encW -= encW / 255.0;
		return [
				encX,
				encY,
				encZ,
				encW
		];
}
function encodeFloatRG(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		encX -= encY / 255.0;
		encY -= encY / 255.0;
		return [
				encX,
				encY
		];
}
class ParticleCPUUpdater {
		calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
				var emitter = this._emitter;
				var rX = Math.random();
				var rY = Math.random();
				var rZ = Math.random();
				var rW = Math.random();
				if (emitter.useCpu) {
						particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
						particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
						particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
				}
				randomPos.x = rX - 0.5;
				randomPos.y = rY - 0.5;
				randomPos.z = rZ - 0.5;
				if (emitter.emitterShape === EMITTERSHAPE_BOX) {
						var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
						var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
						var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
						var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
						randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
						randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
						randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
						if (!emitter.localSpace) {
								randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));
						} else {
								randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
						}
				} else {
						randomPos.normalize();
						var spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
						var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
						if (!emitter.localSpace) {
								randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));
						} else {
								randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
						}
				}
				var particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
				var startSpawnTime = -particleRate * i;
				if (emitter.pack8) {
						var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
						var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
						var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
						var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
						packA = packA % (Math.PI * 2) / (Math.PI * 2);
						var rg0 = encodeFloatRG(packX);
						particleTex[i * particleTexChannels$1] = rg0[0];
						particleTex[i * particleTexChannels$1 + 1] = rg0[1];
						var ba0 = encodeFloatRG(packY);
						particleTex[i * particleTexChannels$1 + 2] = ba0[0];
						particleTex[i * particleTexChannels$1 + 3] = ba0[1];
						var rg1 = encodeFloatRG(packZ);
						particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
						particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
						var ba1 = encodeFloatRG(packA);
						particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
						var a2 = 1.0;
						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
						var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
						var maxPosLife = emitter.lifetime + 1.0;
						startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
						var rgba3 = encodeFloatRGBA(startSpawnTime);
						particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
						particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
						particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
				} else {
						particleTex[i * particleTexChannels$1] = randomPosTformed.x;
						particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
						particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
						particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
				}
		}
		update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
				var a, b, c;
				var emitter = this._emitter;
				if (emitter.meshInstance.node) {
						var fullMat = emitter.meshInstance.node.worldTransform;
						for(var j = 0; j < 12; j++){
								rotMat.data[j] = fullMat.data[j];
						}
						rotMatInv.copy(rotMat);
						rotMatInv.invert();
						nonUniformScale = emitter.meshInstance.node.localScale;
						uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
				}
				emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
				var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
				var vertSize = !emitter.useMesh ? 15 : 17;
				var cf, cc;
				var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
				var precision1 = emitter.precision - 1;
				for(var i = 0; i < emitter.numParticles; i++){
						var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
						var rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
						rndFactor3Vec.x = rndFactor;
						rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
						rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
						var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
						var particleLifetime = emitter.lifetime;
						var life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
						var nlife = saturate$1(life / particleLifetime);
						var scale = 0;
						var alphaDiv = 0;
						var angle = 0;
						var respawn = life - delta <= 0.0 || life >= particleLifetime;
						if (respawn) {
								this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
						}
						var particleEnabled = life > 0.0 && life < particleLifetime;
						if (particleEnabled) {
								c = nlife * precision1;
								cf = Math.floor(c);
								cc = Math.ceil(c);
								c %= 1;
								a = emitter.qRotSpeed[cf];
								b = emitter.qRotSpeed[cc];
								rotSpeed = a + (b - a) * c;
								a = emitter.qRotSpeed2[cf];
								b = emitter.qRotSpeed2[cc];
								rotSpeed2 = a + (b - a) * c;
								a = emitter.qScale[cf];
								b = emitter.qScale[cc];
								scale = a + (b - a) * c;
								a = emitter.qScale2[cf];
								b = emitter.qScale2[cc];
								scale2 = a + (b - a) * c;
								a = emitter.qAlpha[cf];
								b = emitter.qAlpha[cc];
								alpha = a + (b - a) * c;
								a = emitter.qAlpha2[cf];
								b = emitter.qAlpha2[cc];
								alpha2 = a + (b - a) * c;
								a = emitter.qRadialSpeed[cf];
								b = emitter.qRadialSpeed[cc];
								radialSpeed = a + (b - a) * c;
								a = emitter.qRadialSpeed2[cf];
								b = emitter.qRadialSpeed2[cc];
								radialSpeed2 = a + (b - a) * c;
								radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
								particlePosPrev.x = particleTex[id * particleTexChannels$1];
								particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
								particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
								if (!emitter.localSpace) {
										radialVelocityVec.copy(particlePosPrev).sub(emitterPos);
								} else {
										radialVelocityVec.copy(particlePosPrev);
								}
								radialVelocityVec.normalize().mulScalar(radialSpeed);
								cf *= 3;
								cc *= 3;
								a = emitter.qLocalVelocity[cf];
								b = emitter.qLocalVelocity[cc];
								localVelocityVec.x = a + (b - a) * c;
								a = emitter.qLocalVelocity[cf + 1];
								b = emitter.qLocalVelocity[cc + 1];
								localVelocityVec.y = a + (b - a) * c;
								a = emitter.qLocalVelocity[cf + 2];
								b = emitter.qLocalVelocity[cc + 2];
								localVelocityVec.z = a + (b - a) * c;
								a = emitter.qLocalVelocity2[cf];
								b = emitter.qLocalVelocity2[cc];
								localVelocityVec2.x = a + (b - a) * c;
								a = emitter.qLocalVelocity2[cf + 1];
								b = emitter.qLocalVelocity2[cc + 1];
								localVelocityVec2.y = a + (b - a) * c;
								a = emitter.qLocalVelocity2[cf + 2];
								b = emitter.qLocalVelocity2[cc + 2];
								localVelocityVec2.z = a + (b - a) * c;
								a = emitter.qVelocity[cf];
								b = emitter.qVelocity[cc];
								velocityVec.x = a + (b - a) * c;
								a = emitter.qVelocity[cf + 1];
								b = emitter.qVelocity[cc + 1];
								velocityVec.y = a + (b - a) * c;
								a = emitter.qVelocity[cf + 2];
								b = emitter.qVelocity[cc + 2];
								velocityVec.z = a + (b - a) * c;
								a = emitter.qVelocity2[cf];
								b = emitter.qVelocity2[cc];
								velocityVec2.x = a + (b - a) * c;
								a = emitter.qVelocity2[cf + 1];
								b = emitter.qVelocity2[cc + 1];
								velocityVec2.y = a + (b - a) * c;
								a = emitter.qVelocity2[cf + 2];
								b = emitter.qVelocity2[cc + 2];
								velocityVec2.z = a + (b - a) * c;
								localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
								localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
								localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
								if (emitter.initialVelocity > 0) {
										if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
												randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
												localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
										} else {
												localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
										}
								}
								velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
								velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
								velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
								rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
								scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
								alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);
								if (emitter.meshInstance.node) {
										if (!emitter.localSpace) {
												rotMat.transformPoint(localVelocityVec, localVelocityVec);
										} else {
												localVelocityVec.x /= nonUniformScale.x;
												localVelocityVec.y /= nonUniformScale.y;
												localVelocityVec.z /= nonUniformScale.z;
										}
								}
								if (!emitter.localSpace) {
										localVelocityVec.add(velocityVec.mul(nonUniformScale));
										localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
								} else {
										rotMatInv.transformPoint(velocityVec, velocityVec);
										localVelocityVec.add(velocityVec).add(radialVelocityVec);
								}
								moveDirVec.copy(localVelocityVec);
								particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
								particleFinalPos.copy(particlePos);
								particleTex[id * particleTexChannels$1] = particleFinalPos.x;
								particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
								particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
								particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;
								if (emitter.wrap && emitter.wrapBounds) {
										if (!emitter.localSpace) {
												particleFinalPos.sub(emitterPos);
										}
										particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
										particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
										particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
										if (!emitter.localSpace) {
												particleFinalPos.add(emitterPos);
										}
								}
								if (emitter.sort > 0) {
										if (emitter.sort === 1) {
												tmpVec3$1.copy(particleFinalPos).sub(posCam);
												emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
										} else if (emitter.sort === 2) {
												emitter.particleDistance[id] = life;
										} else if (emitter.sort === 3) {
												emitter.particleDistance[id] = -life;
										}
								}
						}
						if (isOnStop) {
								if (life < 0) {
										particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
								}
						} else {
								if (life >= particleLifetime) {
										life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
										particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
								}
								if (life < 0 && emitter.loop) {
										particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
								}
						}
						if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) {
								particleEnabled = false;
						}
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;
						for(var v = 0; v < emitter.numParticleVerts; v++){
								var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
								var quadX = emitter.vbCPU[vbOffset];
								var quadY = emitter.vbCPU[vbOffset + 1];
								var quadZ = emitter.vbCPU[vbOffset + 2];
								if (!particleEnabled) {
										quadX = quadY = quadZ = 0;
								}
								var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
								data[w] = particleFinalPos.x;
								data[w + 1] = particleFinalPos.y;
								data[w + 2] = particleFinalPos.z;
								data[w + 3] = nlife;
								data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
								data[w + 5] = scale;
								data[w + 6] = alphaDiv;
								data[w + 7] = moveDirVec.x;
								data[w + 8] = quadX;
								data[w + 9] = quadY;
								data[w + 10] = quadZ;
								data[w + 11] = moveDirVec.y;
								data[w + 12] = id;
								data[w + 13] = moveDirVec.z;
								data[w + 14] = emitter.vbCPU[vbOffset + 3];
								if (emitter.useMesh) {
										data[w + 15] = emitter.vbCPU[vbOffset + 4];
										data[w + 16] = emitter.vbCPU[vbOffset + 5];
								}
						}
				}
				if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
						var vbStride = emitter.useMesh ? 6 : 4;
						var particleDistance = emitter.particleDistance;
						for(var i1 = 0; i1 < emitter.numParticles; i1++){
								vbToSort[i1][0] = i1;
								vbToSort[i1][1] = particleDistance[Math.floor(emitter.vbCPU[i1 * emitter.numParticleVerts * vbStride + 3])];
						}
						emitter.vbOld.set(emitter.vbCPU);
						vbToSort.sort((p1, p2)=>{
								return p1[1] - p2[1];
						});
						for(var i2 = 0; i2 < emitter.numParticles; i2++){
								var src = vbToSort[i2][0] * emitter.numParticleVerts * vbStride;
								var dest = i2 * emitter.numParticleVerts * vbStride;
								for(var j1 = 0; j1 < emitter.numParticleVerts * vbStride; j1++){
										emitter.vbCPU[dest + j1] = emitter.vbOld[src + j1];
								}
						}
				}
		}
		constructor(emitter){
				this._emitter = emitter;
		}
}

var spawnMatrix3 = new Mat3();
var emitterMatrix3 = new Mat3();
var emitterMatrix3Inv = new Mat3();
class ParticleGPUUpdater {
		_setInputBounds() {
				this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
				this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
				this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
				this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
				this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
				this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
				this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
				this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
		}
		randomize() {
				this.frameRandomUniform[0] = Math.random();
				this.frameRandomUniform[1] = Math.random();
				this.frameRandomUniform[2] = Math.random();
		}
		update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
				var emitter = this._emitter;
				device.setBlendState(BlendState.NOBLEND);
				device.setDepthState(DepthState.NODEPTH);
				device.setCullMode(CULLFACE_NONE);
				this.randomize();
				this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
				this.constantGraphNumSamples.setValue(emitter.precision);
				this.constantNumParticles.setValue(emitter.numParticles);
				this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
				this.constantInternalTex0.setValue(emitter.internalTex0);
				this.constantInternalTex1.setValue(emitter.internalTex1);
				this.constantInternalTex2.setValue(emitter.internalTex2);
				this.constantInternalTex3.setValue(emitter.internalTex3);
				var node = emitter.meshInstance.node;
				var emitterScale = node === null ? Vec3.ONE : node.localScale;
				if (emitter.pack8) {
						this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
						this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
						this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
						this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
						this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
						this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
						this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
						this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
						this._setInputBounds();
						var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
						maxVel = Math.max(maxVel, 1);
						this.constantMaxVel.setValue(maxVel);
				}
				var emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
				var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
				if (emitter.emitterShape === EMITTERSHAPE_BOX) {
						spawnMatrix3.setFromMat4(spawnMatrix);
						this.constantSpawnBounds.setValue(spawnMatrix3.data);
						this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
				} else {
						this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
						this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
				}
				this.constantInitialVelocity.setValue(emitter.initialVelocity);
				emitterMatrix3.setFromMat4(emitterMatrix);
				emitterMatrix3Inv.invertMat4(emitterMatrix);
				this.emitterPosUniform[0] = emitterPos.x;
				this.emitterPosUniform[1] = emitterPos.y;
				this.emitterPosUniform[2] = emitterPos.z;
				this.constantEmitterPos.setValue(this.emitterPosUniform);
				this.constantFrameRandom.setValue(this.frameRandomUniform);
				this.constantDelta.setValue(delta);
				this.constantRate.setValue(emitter.rate);
				this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
				this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
				this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
				this.constantSeed.setValue(emitter.seed);
				this.constantLifetime.setValue(emitter.lifetime);
				this.emitterScaleUniform[0] = emitterScale.x;
				this.emitterScaleUniform[1] = emitterScale.y;
				this.emitterScaleUniform[2] = emitterScale.z;
				this.constantEmitterScale.setValue(this.emitterScaleUniform);
				this.constantEmitterMatrix.setValue(emitterMatrix3.data);
				this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
				this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
				this.constantVelocityDivMult.setValue(emitter.velocityUMax);
				this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
				var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
				texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
				var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
				this.constantParticleTexIN.setValue(texIN);
				drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
				emitter.material.setParameter('particleTexOUT', texIN);
				emitter.material.setParameter('particleTexIN', texOUT);
				emitter.beenReset = false;
				emitter.swapTex = !emitter.swapTex;
				emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
				emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
				if (emitter.pack8) {
						this._setInputBounds();
				}
		}
		constructor(emitter, gd){
				this._emitter = emitter;
				this.frameRandomUniform = new Float32Array(3);
				this.emitterPosUniform = new Float32Array(3);
				this.emitterScaleUniform = new Float32Array([
						1,
						1,
						1
				]);
				this.worldBoundsMulUniform = new Float32Array(3);
				this.worldBoundsAddUniform = new Float32Array(3);
				this.inBoundsSizeUniform = new Float32Array(3);
				this.inBoundsCenterUniform = new Float32Array(3);
				this.constantParticleTexIN = gd.scope.resolve('particleTexIN');
				this.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');
				this.constantEmitterPos = gd.scope.resolve('emitterPos');
				this.constantEmitterScale = gd.scope.resolve('emitterScale');
				this.constantSpawnBounds = gd.scope.resolve('spawnBounds');
				this.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');
				this.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');
				this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');
				this.constantInitialVelocity = gd.scope.resolve('initialVelocity');
				this.constantFrameRandom = gd.scope.resolve('frameRandom');
				this.constantDelta = gd.scope.resolve('delta');
				this.constantRate = gd.scope.resolve('rate');
				this.constantRateDiv = gd.scope.resolve('rateDiv');
				this.constantLifetime = gd.scope.resolve('lifetime');
				this.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');
				this.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');
				this.constantInternalTex0 = gd.scope.resolve('internalTex0');
				this.constantInternalTex1 = gd.scope.resolve('internalTex1');
				this.constantInternalTex2 = gd.scope.resolve('internalTex2');
				this.constantInternalTex3 = gd.scope.resolve('internalTex3');
				this.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');
				this.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');
				this.constantNumParticles = gd.scope.resolve('numParticles');
				this.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');
				this.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');
				this.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');
				this.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');
				this.constantSeed = gd.scope.resolve('seed');
				this.constantStartAngle = gd.scope.resolve('startAngle');
				this.constantStartAngle2 = gd.scope.resolve('startAngle2');
				this.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');
				this.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');
				this.constantInBoundsSize = gd.scope.resolve('inBoundsSize');
				this.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');
				this.constantMaxVel = gd.scope.resolve('maxVel');
				this.constantFaceTangent = gd.scope.resolve('faceTangent');
				this.constantFaceBinorm = gd.scope.resolve('faceBinorm');
		}
}

function _extends$h() {
		_extends$h = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$h.apply(this, arguments);
}
class ShaderGeneratorParticle extends ShaderGenerator {
		generateKey(options) {
				var definesHash = ShaderGenerator.definesHash(options.defines);
				var key = "particle_" + definesHash + "_";
				for(var prop in options){
						if (options.hasOwnProperty(prop)) {
								key += options[prop];
						}
				}
				return key;
		}
		_animTex(options) {
				var vshader = '';
				vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
				vshader += shaderChunks.particleAnimTexVS;
				return vshader;
		}
		createShaderDefinition(device, options) {
				var executionDefine = "#define PARTICLE_" + (options.useCpu ? 'CPU' : 'GPU') + "\n";
				var fshader = "#define PARTICLE\n" + executionDefine;
				var vshader = "#define VERTEXSHADER\n" + executionDefine;
				if (options.mesh) vshader += '#define USE_MESH\n';
				if (options.localSpace) vshader += '#define LOCAL_SPACE\n';
				if (options.screenSpace) vshader += '#define SCREEN_SPACE\n';
				if (options.animTex) vshader += '\nuniform vec2 animTexTilesParams;\n';
				if (options.animTex) vshader += '\nuniform vec4 animTexParams;\n';
				if (options.animTex) vshader += '\nuniform vec2 animTexIndexParams;\n';
				if (options.normal === 2) vshader += '\nvarying mat3 ParticleMat;\n';
				if (options.normal === 1) vshader += '\nvarying vec3 Normal;\n';
				if (options.soft) vshader += '\nvarying float vDepth;\n';
				var faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;
				if (!options.useCpu) {
						vshader += shaderChunks.particle_initVS;
						vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
						if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
						vshader += shaderChunks.particleVS;
						if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
						if (options.animTex) vshader += this._animTex(options);
						if (options.wrap) vshader += shaderChunks.particle_wrapVS;
						if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
						vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
						if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
						if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
						if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
						vshader += shaderChunks.particle_endVS;
						if (options.soft > 0) vshader += shaderChunks.particle_softVS;
				} else {
						if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
						vshader += shaderChunks.particle_cpuVS;
						if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
						if (options.animTex) vshader += this._animTex(options);
						if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
						vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
						if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
						if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
						if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
						vshader += shaderChunks.particle_cpu_endVS;
						if (options.soft > 0) vshader += shaderChunks.particle_softVS;
				}
				vshader += '}\n';
				if (options.normal > 0) {
						if (options.normal === 1) {
								fshader += '\nvarying vec3 Normal;\n';
						} else if (options.normal === 2) {
								fshader += '\nvarying mat3 ParticleMat;\n';
						}
						fshader += '\nuniform vec3 lightCube[6];\n';
				}
				if (options.soft) fshader += '\nvarying float vDepth;\n';
				fshader += shaderChunks.decodePS;
				fshader += '#include "gammaPS"\n';
				fshader += '#include "tonemappingPS"\n';
				fshader += '#include "fogPS"\n';
				if (options.normal === 2) fshader += '\nuniform sampler2D normalMap;\n';
				if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
				fshader += shaderChunks.particlePS;
				if (options.soft > 0) fshader += shaderChunks.particle_softPS;
				if (options.normal === 1) fshader += '\nvec3 normal = Normal;\n';
				if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
				if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
				if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;
				if (options.blend === BLEND_NORMAL) {
						fshader += shaderChunks.particle_blendNormalPS;
				} else if (options.blend === BLEND_ADDITIVE) {
						fshader += shaderChunks.particle_blendAddPS;
				} else if (options.blend === BLEND_MULTIPLICATIVE) {
						fshader += shaderChunks.particle_blendMultiplyPS;
				}
				fshader += shaderChunks.particle_endPS;
				var includes = new Map(Object.entries(_extends$h({}, shaderChunks, options.chunks)));
				return ShaderUtils.createDefinition(device, {
						name: 'ParticleShader',
						vertexCode: vshader,
						fragmentCode: fshader,
						fragmentDefines: options.defines,
						fragmentIncludes: includes,
						vertexDefines: options.defines
				});
		}
}
var particle = new ShaderGeneratorParticle();

class ParticleMaterial extends Material {
		getShaderVariant(params) {
				var { device, scene, cameraShaderParams } = params;
				var { emitter } = this;
				var _cameraShaderParams_shaderOutputGamma, _cameraShaderParams_toneMapping;
				var options = {
						defines: getCoreDefines(this, params),
						pass: SHADER_FORWARD,
						useCpu: this.emitter.useCpu,
						normal: emitter.lighting ? emitter.normalMap !== null ? 2 : 1 : 0,
						halflambert: this.emitter.halfLambert,
						stretch: this.emitter.stretch,
						alignToMotion: this.emitter.alignToMotion,
						soft: this.emitter.depthSoftening,
						mesh: this.emitter.useMesh,
						gamma: (_cameraShaderParams_shaderOutputGamma = cameraShaderParams == null ? void 0 : cameraShaderParams.shaderOutputGamma) != null ? _cameraShaderParams_shaderOutputGamma : GAMMA_NONE,
						toneMap: (_cameraShaderParams_toneMapping = cameraShaderParams == null ? void 0 : cameraShaderParams.toneMapping) != null ? _cameraShaderParams_toneMapping : TONEMAP_LINEAR,
						fog: scene && !this.emitter.noFog ? scene.fog.type : 'none',
						wrap: this.emitter.wrap && this.emitter.wrapBounds,
						localSpace: this.emitter.localSpace,
						screenSpace: emitter.inTools ? false : this.emitter.screenSpace,
						blend: this.blendType,
						animTex: this.emitter._isAnimated(),
						animTexLoop: this.emitter.animLoop,
						pack8: this.emitter.pack8,
						customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
				};
				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
				var library = getProgramLibrary(device);
				library.register('particle', particle);
				return library.getProgram('particle', options, processingOptions, this.userId);
		}
		constructor(emitter){
				super(), this.emitter = null;
				this.emitter = emitter;
		}
}

var particleVerts = [
		[
				-1,
				-1
		],
		[
				1,
				-1
		],
		[
				1,
				1
		],
		[
				-1,
				1
		]
];
function _createTexture(device, width, height, pixelData, format, mult8Bit, filter) {
		if (format === void 0) format = PIXELFORMAT_RGBA32F;
		var mipFilter = FILTER_NEAREST;
		if (filter && (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8)) {
				mipFilter = FILTER_LINEAR;
		}
		var texture = new Texture(device, {
				width: width,
				height: height,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: mipFilter,
				magFilter: mipFilter,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: 'ParticleSystemTexture'
		});
		var pixels = texture.lock();
		if (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8) {
				var temp = new Uint8Array(pixelData.length);
				for(var i = 0; i < pixelData.length; i++){
						temp[i] = pixelData[i] * mult8Bit * 255;
				}
				pixelData = temp;
		}
		pixels.set(pixelData);
		texture.unlock();
		return texture;
}
function saturate(x) {
		return Math.max(Math.min(x, 1), 0);
}
var default0Curve = new Curve([
		0,
		0,
		1,
		0
]);
var default1Curve = new Curve([
		0,
		1,
		1,
		1
]);
var default0Curve3 = new CurveSet([
		0,
		0,
		1,
		0
], [
		0,
		0,
		1,
		0
], [
		0,
		0,
		1,
		0
]);
var default1Curve3 = new CurveSet([
		0,
		1,
		1,
		1
], [
		0,
		1,
		1,
		1
], [
		0,
		1,
		1,
		1
]);
var particleTexHeight = 2;
var particleTexChannels = 4;
var extentsInnerRatioUniform = new Float32Array(3);
var spawnMatrix = new Mat4();
var tmpVec3 = new Vec3();
var bMin = new Vec3();
var bMax = new Vec3();
var setPropertyTarget;
var setPropertyOptions;
function setProperty(pName, defaultVal) {
		if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
				setPropertyTarget[pName] = setPropertyOptions[pName];
		} else {
				setPropertyTarget[pName] = defaultVal;
		}
}
function pack3NFloats(a, b, c) {
		var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
		return packed / (1 << 24);
}
function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
		var num = qXYZ.length / 3;
		var colors = new Array(num * 4);
		for(var i = 0; i < num; i++){
				colors[i * 4] = qXYZ[i * 3];
				colors[i * 4 + 1] = qXYZ[i * 3 + 1];
				colors[i * 4 + 2] = qXYZ[i * 3 + 2];
				colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
		}
		return colors;
}
function packTextureRGBA(qRGB, qA) {
		var colors = new Array(qA.length * 4);
		for(var i = 0; i < qA.length; i++){
				colors[i * 4] = qRGB[i * 3];
				colors[i * 4 + 1] = qRGB[i * 3 + 1];
				colors[i * 4 + 2] = qRGB[i * 3 + 2];
				colors[i * 4 + 3] = qA[i];
		}
		return colors;
}
function packTexture5Floats(qA, qB, qC, qD, qE) {
		var colors = new Array(qA.length * 4);
		for(var i = 0; i < qA.length; i++){
				colors[i * 4] = qA[i];
				colors[i * 4 + 1] = qB[i];
				colors[i * 4 + 2] = 0;
				colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
		}
		return colors;
}
function packTexture2Floats(qA, qB) {
		var colors = new Array(qA.length * 4);
		for(var i = 0; i < qA.length; i++){
				colors[i * 4] = qA[i];
				colors[i * 4 + 1] = qB[i];
				colors[i * 4 + 2] = 0;
				colors[i * 4 + 3] = 0;
		}
		return colors;
}
function calcEndTime(emitter) {
		var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
		return Date.now() + interval * 1000;
}
function subGraph(A, B) {
		var r = new Float32Array(A.length);
		for(var i = 0; i < A.length; i++){
				r[i] = A[i] - B[i];
		}
		return r;
}
function maxUnsignedGraphValue(A, outUMax) {
		var chans = outUMax.length;
		var values = A.length / chans;
		for(var i = 0; i < values; i++){
				for(var j = 0; j < chans; j++){
						var a = Math.abs(A[i * chans + j]);
						outUMax[j] = Math.max(outUMax[j], a);
				}
		}
}
function normalizeGraph(A, uMax) {
		var chans = uMax.length;
		var values = A.length / chans;
		for(var i = 0; i < values; i++){
				for(var j = 0; j < chans; j++){
						A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
						A[i * chans + j] *= 0.5;
						A[i * chans + j] += 0.5;
				}
		}
}
function divGraphFrom2Curves(curve1, curve2, outUMax) {
		var sub = subGraph(curve2, curve1);
		maxUnsignedGraphValue(sub, outUMax);
		normalizeGraph(sub, outUMax);
		return sub;
}
var particleEmitterDeviceCache = new DeviceCache();
class ParticleEmitter {
		get defaultParamTexture() {
				return particleEmitterDeviceCache.get(this.graphicsDevice, ()=>{
						var resolution = 16;
						var centerPoint = resolution * 0.5 + 0.5;
						var dtex = new Float32Array(resolution * resolution * 4);
						for(var y = 0; y < resolution; y++){
								for(var x = 0; x < resolution; x++){
										var xgrad = x + 1 - centerPoint;
										var ygrad = y + 1 - centerPoint;
										var c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
										var p = y * resolution + x;
										dtex[p * 4] = 1;
										dtex[p * 4 + 1] = 1;
										dtex[p * 4 + 2] = 1;
										dtex[p * 4 + 3] = c;
								}
						}
						var texture = _createTexture(this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_SRGBA8, 1.0, true);
						texture.minFilter = FILTER_LINEAR;
						texture.magFilter = FILTER_LINEAR;
						return texture;
				});
		}
		onChangeCamera() {
				this.resetMaterial();
		}
		calculateBoundsMad() {
				this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
				this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
				this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
				this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
				this.worldBoundsAdd.x += 0.5;
				this.worldBoundsAdd.y += 0.5;
				this.worldBoundsAdd.z += 0.5;
		}
		calculateWorldBounds() {
				if (!this.node) return;
				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
				if (!this.useCpu) {
						var recalculateLocalBounds = false;
						if (this.emitterShape === EMITTERSHAPE_BOX) {
								recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
						} else {
								recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
						}
						if (recalculateLocalBounds) {
								this.calculateLocalBounds();
						}
				}
				var nodeWT = this.node.getWorldTransform();
				if (this.localSpace) {
						this.worldBoundsNoTrail.copy(this.localBounds);
				} else {
						this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
				}
				this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
				this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
				var now = this.simTimeTotal;
				if (now >= this.timeToSwitchBounds) {
						this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
						this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
						this.timeToSwitchBounds = now + this.lifetime;
				}
				this.worldBounds.copy(this.worldBoundsTrail[0]);
				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
				if (this.localSpace) {
						this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
						this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
				} else {
						this.meshInstance.aabb.copy(this.worldBounds);
						this.meshInstance.mesh.aabb.copy(this.worldBounds);
				}
				this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
				if (this.pack8) this.calculateBoundsMad();
		}
		resetWorldBounds() {
				if (!this.node) return;
				this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
				this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
				this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
				this.worldBounds.copy(this.worldBoundsTrail[0]);
				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
				this.simTimeTotal = 0;
				this.timeToSwitchBounds = 0;
		}
		calculateLocalBounds() {
				var minx = Number.MAX_VALUE;
				var miny = Number.MAX_VALUE;
				var minz = Number.MAX_VALUE;
				var maxx = -Number.MAX_VALUE;
				var maxy = -Number.MAX_VALUE;
				var maxz = -Number.MAX_VALUE;
				var maxR = 0;
				var maxScale = 0;
				var stepWeight = this.lifetime / this.precision;
				var wVels = [
						this.qVelocity,
						this.qVelocity2
				];
				var lVels = [
						this.qLocalVelocity,
						this.qLocalVelocity2
				];
				var accumX = [
						0,
						0
				];
				var accumY = [
						0,
						0
				];
				var accumZ = [
						0,
						0
				];
				var accumR = [
						0,
						0
				];
				var accumW = [
						0,
						0
				];
				var x, y, z;
				for(var i = 0; i < this.precision + 1; i++){
						var index = Math.min(i, this.precision - 1);
						for(var j = 0; j < 2; j++){
								x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
								y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
								z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
								minx = Math.min(x, minx);
								miny = Math.min(y, miny);
								minz = Math.min(z, minz);
								maxx = Math.max(x, maxx);
								maxy = Math.max(y, maxy);
								maxz = Math.max(z, maxz);
								accumX[j] = x;
								accumY[j] = y;
								accumZ[j] = z;
						}
						for(var j1 = 0; j1 < 2; j1++){
								accumW[j1] += stepWeight * Math.sqrt(wVels[j1][index * 3 + 0] * wVels[j1][index * 3 + 0] + wVels[j1][index * 3 + 1] * wVels[j1][index * 3 + 1] + wVels[j1][index * 3 + 2] * wVels[j1][index * 3 + 2]);
						}
						accumR[0] += this.qRadialSpeed[index] * stepWeight;
						accumR[1] += this.qRadialSpeed2[index] * stepWeight;
						maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
						maxScale = Math.max(maxScale, this.qScale[index]);
				}
				if (this.emitterShape === EMITTERSHAPE_BOX) {
						x = this.emitterExtents.x * 0.5;
						y = this.emitterExtents.y * 0.5;
						z = this.emitterExtents.z * 0.5;
				} else {
						x = this.emitterRadius;
						y = this.emitterRadius;
						z = this.emitterRadius;
				}
				var w = Math.max(accumW[0], accumW[1]);
				bMin.x = minx - maxScale - x - maxR - w;
				bMin.y = miny - maxScale - y - maxR - w;
				bMin.z = minz - maxScale - z - maxR - w;
				bMax.x = maxx + maxScale + x + maxR + w;
				bMax.y = maxy + maxScale + y + maxR + w;
				bMax.z = maxz + maxScale + z + maxR + w;
				this.localBounds.setMinMax(bMin, bMax);
		}
		rebuild() {
				var gd = this.graphicsDevice;
				if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
				this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
				this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles;
				this._destroyResources();
				this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
				particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
				this.useMesh = !!this.mesh;
				this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
				this.rebuildGraphs();
				this.calculateLocalBounds();
				this.resetWorldBounds();
				if (this.node) {
						this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
						this.worldBoundsTrail[0].copy(this.worldBounds);
						this.worldBoundsTrail[1].copy(this.worldBounds);
						this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
						this.prevWorldBoundsSize.copy(this.worldBoundsSize);
						this.prevWorldBoundsCenter.copy(this.worldBounds.center);
						if (this.pack8) this.calculateBoundsMad();
				}
				this.vbToSort = new Array(this.numParticles);
				for(var iSort = 0; iSort < this.numParticles; iSort++)this.vbToSort[iSort] = [
						0,
						0
				];
				this.particleDistance = new Float32Array(this.numParticles);
				this._gpuUpdater.randomize();
				this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
				var emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();
				if (this.emitterShape === EMITTERSHAPE_BOX) {
						if (this.node === null || this.localSpace) {
								spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
						} else {
								spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
						}
						extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
						extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
						extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
				}
				for(var i = 0; i < this.numParticles; i++){
						this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
						if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
				}
				this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
				for(var i1 = 0; i1 < this.particleTexStart.length; i1++){
						this.particleTexStart[i1] = this.particleTex[i1];
				}
				if (!this.useCpu) {
						if (this.pack8) {
								this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
								this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
								this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_RGBA8, 1, false);
						} else {
								this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
								this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
								this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
						}
						this.rtParticleTexIN = new RenderTarget({
								colorBuffer: this.particleTexIN,
								depth: false
						});
						this.rtParticleTexOUT = new RenderTarget({
								colorBuffer: this.particleTexOUT,
								depth: false
						});
						this.swapTex = false;
				}
				var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
				var shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
				var shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
				var shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
				var params = "Shape:" + this.emitterShape + "-Pack:" + this.pack8 + "-Local:" + this.localSpace;
				this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "ParticleUpdateRespawn-" + params);
				this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "ParticleUpdateNoRespawn-" + params);
				this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "ParticleUpdateStop-" + params);
				this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
				this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
				this._allocate(this.numParticles);
				var mesh = new Mesh(gd);
				mesh.vertexBuffer = this.vertexBuffer;
				mesh.indexBuffer[0] = this.indexBuffer;
				mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
				mesh.primitive[0].base = 0;
				mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
				mesh.primitive[0].indexed = true;
				this.material = this._createMaterial();
				this.resetMaterial();
				var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
				this.meshInstance = new MeshInstance(mesh, this.material, this.node);
				this.meshInstance.pick = false;
				this.meshInstance.updateKey();
				this.meshInstance.cull = true;
				if (this.localSpace) {
						this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
				} else {
						this.meshInstance.aabb.copy(this.worldBounds);
				}
				this.meshInstance._updateAabb = false;
				this.meshInstance.visible = wasVisible;
				this._setMaterialTextures();
				this.resetTime();
				this.addTime(0, false);
				if (this.preWarm) this.prewarm(this.lifetime);
		}
		_isAnimated() {
				return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
		}
		rebuildGraphs() {
				var precision = this.precision;
				var gd = this.graphicsDevice;
				this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
				this.qVelocity = this.velocityGraph.quantize(precision);
				this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
				this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
				this.qScale = this.scaleGraph.quantize(precision);
				this.qAlpha = this.alphaGraph.quantize(precision);
				this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
				this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
				this.qVelocity2 = this.velocityGraph2.quantize(precision);
				this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
				this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
				this.qScale2 = this.scaleGraph2.quantize(precision);
				this.qAlpha2 = this.alphaGraph2.quantize(precision);
				this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);
				for(var i = 0; i < precision; i++){
						this.qRotSpeed[i] *= math.DEG_TO_RAD;
						this.qRotSpeed2[i] *= math.DEG_TO_RAD;
				}
				this.localVelocityUMax = new Float32Array(3);
				this.velocityUMax = new Float32Array(3);
				this.colorUMax = new Float32Array(3);
				this.rotSpeedUMax = [
						0
				];
				this.scaleUMax = [
						0
				];
				this.alphaUMax = [
						0
				];
				this.radialSpeedUMax = [
						0
				];
				this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
				this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
				this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
				this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
				this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
				this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
				this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
				if (this.pack8) {
						var umax = [
								0,
								0,
								0
						];
						maxUnsignedGraphValue(this.qVelocity, umax);
						var umax2 = [
								0,
								0,
								0
						];
						maxUnsignedGraphValue(this.qVelocity2, umax2);
						var lumax = [
								0,
								0,
								0
						];
						maxUnsignedGraphValue(this.qLocalVelocity, lumax);
						var lumax2 = [
								0,
								0,
								0
						];
						maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
						var rumax = [
								0
						];
						maxUnsignedGraphValue(this.qRadialSpeed, rumax);
						var rumax2 = [
								0
						];
						maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
						var maxVel = Math.max(umax[0], umax2[0]);
						maxVel = Math.max(maxVel, umax[1]);
						maxVel = Math.max(maxVel, umax2[1]);
						maxVel = Math.max(maxVel, umax[2]);
						maxVel = Math.max(maxVel, umax2[2]);
						var lmaxVel = Math.max(lumax[0], lumax2[0]);
						lmaxVel = Math.max(lmaxVel, lumax[1]);
						lmaxVel = Math.max(lmaxVel, lumax2[1]);
						lmaxVel = Math.max(lmaxVel, lumax[2]);
						lmaxVel = Math.max(lmaxVel, lumax2[2]);
						var maxRad = Math.max(rumax[0], rumax2[0]);
						this.maxVel = maxVel + lmaxVel + maxRad;
				}
				if (!this.useCpu) {
						this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
						this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
						this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
						this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
				}
				this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_SRGBA8, 1.0, true);
		}
		_setMaterialTextures() {
				if (this.colorMap) {
						this.material.setParameter('colorMap', this.colorMap);
						if (this.lighting && this.normalMap) {
								this.material.setParameter('normalMap', this.normalMap);
						}
				}
		}
		_createMaterial() {
				var material = new ParticleMaterial(this);
				material.name = "EmitterMaterial:" + this.node.name;
				material.cull = CULLFACE_NONE;
				material.alphaWrite = false;
				material.blendType = this.blendType;
				material.depthWrite = this.depthWrite;
				return material;
		}
		resetMaterial() {
				var material = this.material;
				material.setParameter('stretch', this.stretch);
				if (this._isAnimated()) {
						material.setParameter('animTexTilesParams', this.animTilesParams);
						material.setParameter('animTexParams', this.animParams);
						material.setParameter('animTexIndexParams', this.animIndexParams);
				}
				material.setParameter('colorMult', this.intensity);
				if (!this.useCpu) {
						material.setParameter('internalTex0', this.internalTex0);
						material.setParameter('internalTex1', this.internalTex1);
						material.setParameter('internalTex2', this.internalTex2);
						material.setParameter('internalTex3', this.internalTex3);
				}
				material.setParameter('colorParam', this.colorParam);
				material.setParameter('numParticles', this.numParticles);
				material.setParameter('numParticlesPot', this.numParticlesPot);
				material.setParameter('lifetime', this.lifetime);
				material.setParameter('rate', this.rate);
				material.setParameter('rateDiv', this.rate2 - this.rate);
				material.setParameter('seed', this.seed);
				material.setParameter('scaleDivMult', this.scaleUMax[0]);
				material.setParameter('alphaDivMult', this.alphaUMax[0]);
				material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
				material.setParameter('graphNumSamples', this.precision);
				material.setParameter('graphSampleSize', 1.0 / this.precision);
				material.setParameter('emitterScale', new Float32Array([
						1,
						1,
						1
				]));
				if (this.pack8) {
						this._gpuUpdater._setInputBounds();
						material.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);
						material.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);
						material.setParameter('maxVel', this.maxVel);
				}
				if (this.wrap && this.wrapBounds) {
						this.wrapBoundsUniform[0] = this.wrapBounds.x;
						this.wrapBoundsUniform[1] = this.wrapBounds.y;
						this.wrapBoundsUniform[2] = this.wrapBounds.z;
						material.setParameter('wrapBounds', this.wrapBoundsUniform);
				}
				this._setMaterialTextures();
				if (this.depthSoftening > 0) {
						material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
				}
				if (this.stretch > 0.0) material.cull = CULLFACE_NONE;
				this._compParticleFaceParams();
		}
		_compParticleFaceParams() {
				var tangent, binormal;
				if (this.orientation === PARTICLEORIENTATION_SCREEN) {
						tangent = new Float32Array([
								1,
								0,
								0
						]);
						binormal = new Float32Array([
								0,
								0,
								1
						]);
				} else {
						var n;
						if (this.orientation === PARTICLEORIENTATION_WORLD) {
								n = this.particleNormal.normalize();
						} else {
								var emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
								n = emitterMat.transformVector(this.particleNormal).normalize();
						}
						var t = new Vec3(1, 0, 0);
						if (Math.abs(t.dot(n)) === 1) {
								t.set(0, 0, 1);
						}
						var b = new Vec3().cross(n, t).normalize();
						t.cross(b, n).normalize();
						tangent = new Float32Array([
								t.x,
								t.y,
								t.z
						]);
						binormal = new Float32Array([
								b.x,
								b.y,
								b.z
						]);
				}
				this.material.setParameter('faceTangent', tangent);
				this.material.setParameter('faceBinorm', binormal);
		}
		_allocate(numParticles) {
				var psysVertCount = numParticles * this.numParticleVerts;
				var psysIndexCount = numParticles * this.numParticleIndices;
				if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
						var elements = [];
						if (!this.useCpu) {
								elements.push({
										semantic: SEMANTIC_ATTR0,
										components: 4,
										type: TYPE_FLOAT32
								});
								if (this.useMesh) {
										elements.push({
												semantic: SEMANTIC_ATTR1,
												components: 2,
												type: TYPE_FLOAT32
										});
								}
						} else {
								elements.push({
										semantic: SEMANTIC_ATTR0,
										components: 4,
										type: TYPE_FLOAT32
								}, {
										semantic: SEMANTIC_ATTR1,
										components: 4,
										type: TYPE_FLOAT32
								}, {
										semantic: SEMANTIC_ATTR2,
										components: 4,
										type: TYPE_FLOAT32
								}, {
										semantic: SEMANTIC_ATTR3,
										components: 1,
										type: TYPE_FLOAT32
								}, {
										semantic: SEMANTIC_ATTR4,
										components: this.useMesh ? 4 : 2,
										type: TYPE_FLOAT32
								});
						}
						var vertexFormat = new VertexFormat(this.graphicsDevice, elements);
						this.vertexBuffer = new VertexBuffer(this.graphicsDevice, vertexFormat, psysVertCount, {
								usage: BUFFER_DYNAMIC
						});
						this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT32, psysIndexCount);
						var data = new Float32Array(this.vertexBuffer.lock());
						var meshData, stride, texCoordOffset;
						if (this.useMesh) {
								meshData = new Float32Array(this.mesh.vertexBuffer.lock());
								stride = meshData.length / this.mesh.vertexBuffer.numVertices;
								for(var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++){
										if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
												texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
												break;
										}
								}
						}
						for(var i = 0; i < psysVertCount; i++){
								var id = Math.floor(i / this.numParticleVerts);
								if (!this.useMesh) {
										var vertID = i % 4;
										data[i * 4] = particleVerts[vertID][0];
										data[i * 4 + 1] = particleVerts[vertID][1];
										data[i * 4 + 2] = 0;
										data[i * 4 + 3] = id;
								} else {
										var vert = i % this.numParticleVerts;
										data[i * 6] = meshData[vert * stride];
										data[i * 6 + 1] = meshData[vert * stride + 1];
										data[i * 6 + 2] = meshData[vert * stride + 2];
										data[i * 6 + 3] = id;
										data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
										data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
								}
						}
						if (this.useCpu) {
								this.vbCPU = new Float32Array(data);
								this.vbOld = new Float32Array(this.vbCPU.length);
						}
						this.vertexBuffer.unlock();
						if (this.useMesh) {
								this.mesh.vertexBuffer.unlock();
						}
						var dst = 0;
						var indices = new Uint32Array(this.indexBuffer.lock());
						if (this.useMesh) {
								var ib = this.mesh.indexBuffer[0];
								meshData = new typedArrayIndexFormats[ib.format](ib.lock());
						}
						for(var i1 = 0; i1 < numParticles; i1++){
								if (!this.useMesh) {
										var baseIndex = i1 * 4;
										indices[dst++] = baseIndex;
										indices[dst++] = baseIndex + 1;
										indices[dst++] = baseIndex + 2;
										indices[dst++] = baseIndex;
										indices[dst++] = baseIndex + 2;
										indices[dst++] = baseIndex + 3;
								} else {
										for(var j = 0; j < this.numParticleIndices; j++){
												indices[i1 * this.numParticleIndices + j] = meshData[j] + i1 * this.numParticleVerts;
										}
								}
						}
						this.indexBuffer.unlock();
						if (this.useMesh) this.mesh.indexBuffer[0].unlock();
				}
		}
		reset() {
				this.beenReset = true;
				this.seed = Math.random();
				this.material.setParameter('seed', this.seed);
				if (this.useCpu) {
						for(var i = 0; i < this.particleTexStart.length; i++){
								this.particleTex[i] = this.particleTexStart[i];
						}
				} else {
						this._setMaterialTextures();
				}
				this.resetWorldBounds();
				this.resetTime();
				var origLoop = this.loop;
				this.loop = true;
				this.addTime(0, false);
				this.loop = origLoop;
				if (this.preWarm) {
						this.prewarm(this.lifetime);
				}
		}
		prewarm(time) {
				var lifetimeFraction = time / this.lifetime;
				var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
				var stepDelta = time / iterations;
				for(var i = 0; i < iterations; i++){
						this.addTime(stepDelta, false);
				}
		}
		resetTime() {
				this.endTime = calcEndTime(this);
		}
		finishFrame() {
				if (this.useCpu) this.vertexBuffer.unlock();
		}
		addTime(delta, isOnStop) {
				var device = this.graphicsDevice;
				this.simTimeTotal += delta;
				this.calculateWorldBounds();
				if (this._isAnimated()) {
						var tilesParams = this.animTilesParams;
						tilesParams[0] = 1.0 / this.animTilesX;
						tilesParams[1] = 1.0 / this.animTilesY;
						var params = this.animParams;
						params[0] = this.animStartFrame;
						params[1] = this.animNumFrames * this.animSpeed;
						params[2] = this.animNumFrames - 1;
						params[3] = this.animNumAnimations - 1;
						var animIndexParams = this.animIndexParams;
						animIndexParams[0] = this.animIndex;
						animIndexParams[1] = this.randomizeAnimIndex;
				}
				if (this.scene) {
						if (this.camera !== this.scene._activeCamera) {
								this.camera = this.scene._activeCamera;
								this.onChangeCamera();
						}
				}
				if (this.emitterShape === EMITTERSHAPE_BOX) {
						extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
						extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
						extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
						if (this.meshInstance.node === null) {
								spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
						} else {
								spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
						}
				}
				var emitterPos;
				var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
				this.emitterScaleUniform[0] = emitterScale.x;
				this.emitterScaleUniform[1] = emitterScale.y;
				this.emitterScaleUniform[2] = emitterScale.z;
				this.material.setParameter('emitterScale', this.emitterScaleUniform);
				if (this.localSpace && this.meshInstance.node) {
						emitterPos = this.meshInstance.node.getPosition();
						this.emitterPosUniform[0] = emitterPos.x;
						this.emitterPosUniform[1] = emitterPos.y;
						this.emitterPosUniform[2] = emitterPos.z;
						this.material.setParameter('emitterPos', this.emitterPosUniform);
				}
				this._compParticleFaceParams();
				if (!this.useCpu) {
						this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
				} else {
						var data = new Float32Array(this.vertexBuffer.lock());
						this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
				}
				if (!this.loop) {
						if (Date.now() > this.endTime) {
								if (this.onFinished) this.onFinished();
								this.meshInstance.visible = false;
						}
				}
				if (this.meshInstance) {
						this.meshInstance.drawOrder = this.drawOrder;
				}
		}
		_destroyResources() {
				var _this_particleTexIN, _this_particleTexOUT, _this_rtParticleTexIN, _this_rtParticleTexOUT, _this_internalTex0, _this_internalTex1, _this_internalTex2, _this_internalTex3, _this_colorParam, _this_vertexBuffer, _this_indexBuffer, _this_material;
				(_this_particleTexIN = this.particleTexIN) == null ? void 0 : _this_particleTexIN.destroy();
				this.particleTexIN = null;
				(_this_particleTexOUT = this.particleTexOUT) == null ? void 0 : _this_particleTexOUT.destroy();
				this.particleTexOUT = null;
				if (this.particleTexStart && this.particleTexStart.destroy) {
						this.particleTexStart.destroy();
						this.particleTexStart = null;
				}
				(_this_rtParticleTexIN = this.rtParticleTexIN) == null ? void 0 : _this_rtParticleTexIN.destroy();
				this.rtParticleTexIN = null;
				(_this_rtParticleTexOUT = this.rtParticleTexOUT) == null ? void 0 : _this_rtParticleTexOUT.destroy();
				this.rtParticleTexOUT = null;
				(_this_internalTex0 = this.internalTex0) == null ? void 0 : _this_internalTex0.destroy();
				this.internalTex0 = null;
				(_this_internalTex1 = this.internalTex1) == null ? void 0 : _this_internalTex1.destroy();
				this.internalTex1 = null;
				(_this_internalTex2 = this.internalTex2) == null ? void 0 : _this_internalTex2.destroy();
				this.internalTex2 = null;
				(_this_internalTex3 = this.internalTex3) == null ? void 0 : _this_internalTex3.destroy();
				this.internalTex3 = null;
				(_this_colorParam = this.colorParam) == null ? void 0 : _this_colorParam.destroy();
				this.colorParam = null;
				(_this_vertexBuffer = this.vertexBuffer) == null ? void 0 : _this_vertexBuffer.destroy();
				this.vertexBuffer = undefined;
				(_this_indexBuffer = this.indexBuffer) == null ? void 0 : _this_indexBuffer.destroy();
				this.indexBuffer = undefined;
				(_this_material = this.material) == null ? void 0 : _this_material.destroy();
				this.material = null;
		}
		destroy() {
				this.camera = null;
				this._destroyResources();
		}
		constructor(graphicsDevice, options){
				this.material = null;
				this.internalTex0 = null;
				this.internalTex1 = null;
				this.internalTex2 = null;
				this.colorParam = null;
				this.graphicsDevice = graphicsDevice;
				var gd = graphicsDevice;
				var precision = 32;
				this.precision = precision;
				this._addTimeTime = 0;
				setPropertyTarget = this;
				setPropertyOptions = options;
				setProperty('numParticles', 1);
				if (this.numParticles > graphicsDevice.maxTextureSize) {
						this.numParticles = graphicsDevice.maxTextureSize;
				}
				setProperty('rate', 1);
				setProperty('rate2', this.rate);
				setProperty('lifetime', 50);
				setProperty('emitterExtents', new Vec3(0, 0, 0));
				setProperty('emitterExtentsInner', new Vec3(0, 0, 0));
				setProperty('emitterRadius', 0);
				setProperty('emitterRadiusInner', 0);
				setProperty('emitterShape', EMITTERSHAPE_BOX);
				setProperty('initialVelocity', 1);
				setProperty('wrap', false);
				setProperty('localSpace', false);
				setProperty('screenSpace', false);
				setProperty('wrapBounds', null);
				setProperty('colorMap', this.defaultParamTexture);
				setProperty('normalMap', null);
				setProperty('loop', true);
				setProperty('preWarm', false);
				setProperty('sort', PARTICLESORT_NONE);
				setProperty('mode', PARTICLEMODE_GPU);
				setProperty('scene', null);
				setProperty('lighting', false);
				setProperty('halfLambert', false);
				setProperty('intensity', 1.0);
				setProperty('stretch', 0.0);
				setProperty('alignToMotion', false);
				setProperty('depthSoftening', 0);
				setProperty('mesh', null);
				setProperty('particleNormal', new Vec3(0, 1, 0));
				setProperty('orientation', PARTICLEORIENTATION_SCREEN);
				setProperty('depthWrite', false);
				setProperty('noFog', false);
				setProperty('blendType', BLEND_NORMAL);
				setProperty('node', null);
				setProperty('startAngle', 0);
				setProperty('startAngle2', this.startAngle);
				setProperty('animTilesX', 1);
				setProperty('animTilesY', 1);
				setProperty('animStartFrame', 0);
				setProperty('animNumFrames', 1);
				setProperty('animNumAnimations', 1);
				setProperty('animIndex', 0);
				setProperty('randomizeAnimIndex', false);
				setProperty('animSpeed', 1);
				setProperty('animLoop', true);
				this._gpuUpdater = new ParticleGPUUpdater(this, gd);
				this._cpuUpdater = new ParticleCPUUpdater(this);
				this.emitterPosUniform = new Float32Array(3);
				this.wrapBoundsUniform = new Float32Array(3);
				this.emitterScaleUniform = new Float32Array([
						1,
						1,
						1
				]);
				setProperty('colorGraph', default1Curve3);
				setProperty('colorGraph2', this.colorGraph);
				setProperty('scaleGraph', default1Curve);
				setProperty('scaleGraph2', this.scaleGraph);
				setProperty('alphaGraph', default1Curve);
				setProperty('alphaGraph2', this.alphaGraph);
				setProperty('localVelocityGraph', default0Curve3);
				setProperty('localVelocityGraph2', this.localVelocityGraph);
				setProperty('velocityGraph', default0Curve3);
				setProperty('velocityGraph2', this.velocityGraph);
				setProperty('rotationSpeedGraph', default0Curve);
				setProperty('rotationSpeedGraph2', this.rotationSpeedGraph);
				setProperty('radialSpeedGraph', default0Curve);
				setProperty('radialSpeedGraph2', this.radialSpeedGraph);
				this.animTilesParams = new Float32Array(2);
				this.animParams = new Float32Array(4);
				this.animIndexParams = new Float32Array(2);
				this.vbToSort = null;
				this.vbOld = null;
				this.particleDistance = null;
				this.camera = null;
				this.swapTex = false;
				this.useMesh = true;
				this.useCpu = !graphicsDevice.supportsGpuParticles;
				this.pack8 = true;
				this.localBounds = new BoundingBox();
				this.worldBoundsNoTrail = new BoundingBox();
				this.worldBoundsTrail = [
						new BoundingBox(),
						new BoundingBox()
				];
				this.worldBounds = new BoundingBox();
				this.worldBoundsSize = new Vec3();
				this.prevWorldBoundsSize = new Vec3();
				this.prevWorldBoundsCenter = new Vec3();
				this.prevEmitterExtents = this.emitterExtents;
				this.prevEmitterRadius = this.emitterRadius;
				this.worldBoundsMul = new Vec3();
				this.worldBoundsAdd = new Vec3();
				this.timeToSwitchBounds = 0;
				this.shaderParticleUpdateRespawn = null;
				this.shaderParticleUpdateNoRespawn = null;
				this.shaderParticleUpdateOnStop = null;
				this.numParticleVerts = 0;
				this.numParticleIndices = 0;
				this.material = null;
				this.meshInstance = null;
				this.drawOrder = 0;
				this.seed = Math.random();
				this.fixedTimeStep = 1.0 / 60;
				this.maxSubSteps = 10;
				this.simTime = 0;
				this.simTimeTotal = 0;
				this.beenReset = false;
				this._layer = null;
				this.rebuild();
		}
}

function _extends$g() {
		_extends$g = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$g.apply(this, arguments);
}
class ShaderGeneratorShader extends ShaderGenerator {
		generateKey(options) {
				var desc = options.shaderDesc;
				var vsHash = desc.vertexCode ? hashCode(desc.vertexCode) : 0;
				var fsHash = desc.fragmentCode ? hashCode(desc.fragmentCode) : 0;
				var definesHash = ShaderGenerator.definesHash(options.defines);
				var key = desc.uniqueName + "_" + vsHash + "_" + fsHash + "_" + definesHash;
				if (options.skin) key += '_skin';
				if (options.useInstancing) key += '_inst';
				if (options.useMorphPosition) key += '_morphp';
				if (options.useMorphNormal) key += '_morphn';
				if (options.useMorphTextureBasedInt) key += '_morphi';
				return key;
		}
		createAttributesDefinition(definitionOptions, options) {
				var srcAttributes = options.shaderDesc.attributes;
				var attributes = srcAttributes ? _extends$g({}, srcAttributes) : undefined;
				if (options.skin) {
						attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
						attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
				}
				if (options.useMorphPosition || options.useMorphNormal) {
						attributes.morph_vertex_id = SEMANTIC_ATTR15;
				}
				definitionOptions.attributes = attributes;
		}
		createVertexDefinition(definitionOptions, options, sharedIncludes) {
				var desc = options.shaderDesc;
				var includes = new Map(sharedIncludes);
				var defines = new Map(options.defines);
				includes.set('userCode', desc.vertexCode);
				includes.set('transformInstancingVS', '');
				if (options.skin) defines.set('SKIN', true);
				if (options.useInstancing) defines.set('INSTANCING', true);
				if (options.useMorphPosition || options.useMorphNormal) {
						defines.set('MORPHING', true);
						if (options.useMorphTextureBasedInt) defines.set('MORPHING_INT', true);
						if (options.useMorphPosition) defines.set('MORPHING_POSITION', true);
						if (options.useMorphNormal) defines.set('MORPHING_NORMAL', true);
				}
				definitionOptions.vertexCode = desc.vertexCode;
				definitionOptions.vertexIncludes = includes;
				definitionOptions.vertexDefines = defines;
		}
		createFragmentDefinition(definitionOptions, options, sharedIncludes) {
				var desc = options.shaderDesc;
				var includes = new Map(sharedIncludes);
				var defines = new Map(options.defines);
				definitionOptions.fragmentCode = desc.fragmentCode;
				definitionOptions.fragmentIncludes = includes;
				definitionOptions.fragmentDefines = defines;
		}
		createShaderDefinition(device, options) {
				var desc = options.shaderDesc;
				var definitionOptions = {
						name: "ShaderMaterial-" + desc.uniqueName,
						shaderLanguage: desc.shaderLanguage,
						fragmentOutputTypes: desc.fragmentOutputTypes,
						meshUniformBufferFormat: desc.meshUniformBufferFormat,
						meshBindGroupFormat: desc.meshBindGroupFormat
				};
				var chunks = desc.shaderLanguage === SHADERLANGUAGE_WGSL ? shaderChunksWGSL : shaderChunks;
				var sharedIncludes = new Map(Object.entries(_extends$g({}, chunks, options.chunks)));
				this.createAttributesDefinition(definitionOptions, options);
				this.createVertexDefinition(definitionOptions, options, sharedIncludes);
				this.createFragmentDefinition(definitionOptions, options, sharedIncludes);
				return ShaderUtils.createDefinition(device, definitionOptions);
		}
}
var shaderGeneratorShader = new ShaderGeneratorShader();

function _extends$f() {
		_extends$f = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$f.apply(this, arguments);
}
class ShaderMaterial extends Material {
		set shaderDesc(value) {
				this._shaderDesc = value ? _extends$f({}, value) : undefined;
				this.clearVariants();
		}
		get shaderDesc() {
				return this._shaderDesc;
		}
		copy(source) {
				super.copy(source);
				this.shaderDesc = source.shaderDesc;
				return this;
		}
		getShaderVariant(params) {
				var { objDefs } = params;
				var _this_chunks;
				var options = {
						defines: getCoreDefines(this, params),
						skin: (objDefs & SHADERDEF_SKIN) !== 0,
						useInstancing: (objDefs & SHADERDEF_INSTANCING) !== 0,
						useMorphPosition: (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
						useMorphNormal: (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
						useMorphTextureBasedInt: (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0,
						pass: params.pass,
						gamma: params.cameraShaderParams.shaderOutputGamma,
						toneMapping: params.cameraShaderParams.toneMapping,
						fog: params.cameraShaderParams.fog,
						shaderDesc: this.shaderDesc,
						chunks: (_this_chunks = this.chunks) != null ? _this_chunks : {}
				};
				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
				var library = getProgramLibrary(params.device);
				library.register('shader-material', shaderGeneratorShader);
				return library.getProgram('shader-material', options, processingOptions, this.userId);
		}
		constructor(shaderDesc){
				super();
				this.shaderDesc = shaderDesc;
		}
}

var decodeTable = {
		'linear': 'decodeLinear',
		'srgb': 'decodeGamma',
		'rgbm': 'decodeRGBM',
		'rgbe': 'decodeRGBE',
		'rgbp': 'decodeRGBP'
};
var encodeTable = {
		'linear': 'encodeLinear',
		'srgb': 'encodeGamma',
		'rgbm': 'encodeRGBM',
		'rgbe': 'encodeRGBE',
		'rgbp': 'encodeRGBP'
};
class ChunkUtils {
		static decodeFunc(encoding) {
				var _decodeTable_encoding;
				return (_decodeTable_encoding = decodeTable[encoding]) != null ? _decodeTable_encoding : 'decodeGamma';
		}
		static encodeFunc(encoding) {
				var _encodeTable_encoding;
				return (_encodeTable_encoding = encodeTable[encoding]) != null ? _encodeTable_encoding : 'encodeGamma';
		}
		static getScreenDepthChunk(device, cameraShaderParams) {
				return "\n            " + (cameraShaderParams.sceneDepthMapLinear ? '#define SCENE_DEPTHMAP_LINEAR' : '') + "\n            " + (device.textureFloatRenderable ? '#define SCENE_DEPTHMAP_FLOAT' : '') + "\n            " + shaderChunks.screenDepthPS + "\n        ";
		}
}

var calculateNormals = (positions, indices)=>{
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var p1 = new Vec3();
		var p2 = new Vec3();
		var p3 = new Vec3();
		var p1p2 = new Vec3();
		var p1p3 = new Vec3();
		var faceNormal = new Vec3();
		var normals = [];
		for(var i = 0; i < positions.length; i++){
				normals[i] = 0;
		}
		for(var i1 = 0; i1 < triangleCount; i1++){
				var i11 = indices[i1 * 3];
				var i2 = indices[i1 * 3 + 1];
				var i3 = indices[i1 * 3 + 2];
				p1.set(positions[i11 * 3], positions[i11 * 3 + 1], positions[i11 * 3 + 2]);
				p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
				p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
				p1p2.sub2(p2, p1);
				p1p3.sub2(p3, p1);
				faceNormal.cross(p1p2, p1p3).normalize();
				normals[i11 * 3] += faceNormal.x;
				normals[i11 * 3 + 1] += faceNormal.y;
				normals[i11 * 3 + 2] += faceNormal.z;
				normals[i2 * 3] += faceNormal.x;
				normals[i2 * 3 + 1] += faceNormal.y;
				normals[i2 * 3 + 2] += faceNormal.z;
				normals[i3 * 3] += faceNormal.x;
				normals[i3 * 3 + 1] += faceNormal.y;
				normals[i3 * 3 + 2] += faceNormal.z;
		}
		for(var i4 = 0; i4 < vertexCount; i4++){
				var nx = normals[i4 * 3];
				var ny = normals[i4 * 3 + 1];
				var nz = normals[i4 * 3 + 2];
				var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
				normals[i4 * 3] *= invLen;
				normals[i4 * 3 + 1] *= invLen;
				normals[i4 * 3 + 2] *= invLen;
		}
		return normals;
};
var calculateTangents = (positions, normals, uvs, indices)=>{
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var v1 = new Vec3();
		var v2 = new Vec3();
		var v3 = new Vec3();
		var w1 = new Vec2();
		var w2 = new Vec2();
		var w3 = new Vec2();
		var sdir = new Vec3();
		var tdir = new Vec3();
		var tan1 = new Float32Array(vertexCount * 3);
		var tan2 = new Float32Array(vertexCount * 3);
		var tangents = [];
		for(var i = 0; i < triangleCount; i++){
				var i1 = indices[i * 3];
				var i2 = indices[i * 3 + 1];
				var i3 = indices[i * 3 + 2];
				v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
				v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
				v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
				w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
				w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
				w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
				var x1 = v2.x - v1.x;
				var x2 = v3.x - v1.x;
				var y1 = v2.y - v1.y;
				var y2 = v3.y - v1.y;
				var z1 = v2.z - v1.z;
				var z2 = v3.z - v1.z;
				var s1 = w2.x - w1.x;
				var s2 = w3.x - w1.x;
				var t1 = w2.y - w1.y;
				var t2 = w3.y - w1.y;
				var area = s1 * t2 - s2 * t1;
				if (area === 0) {
						sdir.set(0, 1, 0);
						tdir.set(1, 0, 0);
				} else {
						var r = 1 / area;
						sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
						tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
				}
				tan1[i1 * 3 + 0] += sdir.x;
				tan1[i1 * 3 + 1] += sdir.y;
				tan1[i1 * 3 + 2] += sdir.z;
				tan1[i2 * 3 + 0] += sdir.x;
				tan1[i2 * 3 + 1] += sdir.y;
				tan1[i2 * 3 + 2] += sdir.z;
				tan1[i3 * 3 + 0] += sdir.x;
				tan1[i3 * 3 + 1] += sdir.y;
				tan1[i3 * 3 + 2] += sdir.z;
				tan2[i1 * 3 + 0] += tdir.x;
				tan2[i1 * 3 + 1] += tdir.y;
				tan2[i1 * 3 + 2] += tdir.z;
				tan2[i2 * 3 + 0] += tdir.x;
				tan2[i2 * 3 + 1] += tdir.y;
				tan2[i2 * 3 + 2] += tdir.z;
				tan2[i3 * 3 + 0] += tdir.x;
				tan2[i3 * 3 + 1] += tdir.y;
				tan2[i3 * 3 + 2] += tdir.z;
		}
		var t11 = new Vec3();
		var t21 = new Vec3();
		var n = new Vec3();
		var temp = new Vec3();
		for(var i4 = 0; i4 < vertexCount; i4++){
				n.set(normals[i4 * 3], normals[i4 * 3 + 1], normals[i4 * 3 + 2]);
				t11.set(tan1[i4 * 3], tan1[i4 * 3 + 1], tan1[i4 * 3 + 2]);
				t21.set(tan2[i4 * 3], tan2[i4 * 3 + 1], tan2[i4 * 3 + 2]);
				var ndott = n.dot(t11);
				temp.copy(n).mulScalar(ndott);
				temp.sub2(t11, temp).normalize();
				tangents[i4 * 4] = temp.x;
				tangents[i4 * 4 + 1] = temp.y;
				tangents[i4 * 4 + 2] = temp.z;
				temp.cross(n, t11);
				tangents[i4 * 4 + 3] = temp.dot(t21) < 0.0 ? -1 : 1.0;
		}
		return tangents;
};

class Geometry {
		calculateNormals() {
				this.normals = calculateNormals(this.positions, this.indices);
		}
		calculateTangents() {
				this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
		}
}

var primitiveUv1Padding$1 = 4.0 / 64;
var primitiveUv1PaddingScale$1 = 1.0 - primitiveUv1Padding$1 * 2;
class BoxGeometry extends Geometry {
		constructor(opts = {}){
				super();
				var _opts_halfExtents;
				var he = (_opts_halfExtents = opts.halfExtents) != null ? _opts_halfExtents : new Vec3(0.5, 0.5, 0.5);
				var _opts_widthSegments;
				var ws = (_opts_widthSegments = opts.widthSegments) != null ? _opts_widthSegments : 1;
				var _opts_lengthSegments;
				var ls = (_opts_lengthSegments = opts.lengthSegments) != null ? _opts_lengthSegments : 1;
				var _opts_heightSegments;
				var hs = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 1;
				var _opts_yOffset;
				var yOffset = (_opts_yOffset = opts.yOffset) != null ? _opts_yOffset : 0;
				var minY = -he.y + yOffset;
				var maxY = he.y + yOffset;
				var corners = [
						new Vec3(-he.x, minY, he.z),
						new Vec3(he.x, minY, he.z),
						new Vec3(he.x, maxY, he.z),
						new Vec3(-he.x, maxY, he.z),
						new Vec3(he.x, minY, -he.z),
						new Vec3(-he.x, minY, -he.z),
						new Vec3(-he.x, maxY, -he.z),
						new Vec3(he.x, maxY, -he.z)
				];
				var faceAxes = [
						[
								0,
								1,
								3
						],
						[
								4,
								5,
								7
						],
						[
								3,
								2,
								6
						],
						[
								1,
								0,
								4
						],
						[
								1,
								4,
								2
						],
						[
								5,
								0,
								6
						]
				];
				var faceNormals = [
						[
								0,
								0,
								1
						],
						[
								0,
								0,
								-1
						],
						[
								0,
								1,
								0
						],
						[
								0,
								-1,
								0
						],
						[
								1,
								0,
								0
						],
						[
								-1,
								0,
								0
						]
				];
				var sides = {
						FRONT: 0,
						BACK: 1,
						TOP: 2,
						BOTTOM: 3,
						RIGHT: 4,
						LEFT: 5
				};
				var positions = [];
				var normals = [];
				var uvs = [];
				var indices = [];
				var vcounter = 0;
				var generateFace = (side, uSegments, vSegments)=>{
						var temp1 = new Vec3();
						var temp2 = new Vec3();
						var temp3 = new Vec3();
						var r = new Vec3();
						for(var i = 0; i <= uSegments; i++){
								for(var j = 0; j <= vSegments; j++){
										temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
										temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
										temp3.sub2(temp2, corners[faceAxes[side][0]]);
										r.add2(temp1, temp3);
										var u = i / uSegments;
										var v = j / vSegments;
										positions.push(r.x, r.y, r.z);
										normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
										uvs.push(u, 1 - v);
										u = u * primitiveUv1PaddingScale$1 + primitiveUv1Padding$1;
										v = v * primitiveUv1PaddingScale$1 + primitiveUv1Padding$1;
										u /= 3;
										v /= 3;
										u += side % 3 / 3;
										v += Math.floor(side / 3) / 3;
										if (i < uSegments && j < vSegments) {
												indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
												indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
										}
										vcounter++;
								}
						}
				};
				generateFace(sides.FRONT, ws, hs);
				generateFace(sides.BACK, ws, hs);
				generateFace(sides.TOP, ws, ls);
				generateFace(sides.BOTTOM, ws, ls);
				generateFace(sides.RIGHT, ls, hs);
				generateFace(sides.LEFT, ls, hs);
				this.positions = positions;
				this.normals = normals;
				this.uvs = uvs;
				this.uvs1 = uvs;
				this.indices = indices;
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(positions, normals, uvs, indices);
				}
		}
}

class SphereGeometry extends Geometry {
		constructor(opts = {}){
				super();
				var _opts_radius;
				var radius = (_opts_radius = opts.radius) != null ? _opts_radius : 0.5;
				var _opts_latitudeBands;
				var latitudeBands = (_opts_latitudeBands = opts.latitudeBands) != null ? _opts_latitudeBands : 16;
				var _opts_longitudeBands;
				var longitudeBands = (_opts_longitudeBands = opts.longitudeBands) != null ? _opts_longitudeBands : 16;
				var positions = [];
				var normals = [];
				var uvs = [];
				var indices = [];
				for(var lat = 0; lat <= latitudeBands; lat++){
						var theta = lat * Math.PI / latitudeBands;
						var sinTheta = Math.sin(theta);
						var cosTheta = Math.cos(theta);
						for(var lon = 0; lon <= longitudeBands; lon++){
								var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
								var sinPhi = Math.sin(phi);
								var cosPhi = Math.cos(phi);
								var x = cosPhi * sinTheta;
								var y = cosTheta;
								var z = sinPhi * sinTheta;
								var u = 1 - lon / longitudeBands;
								var v = 1 - lat / latitudeBands;
								positions.push(x * radius, y * radius, z * radius);
								normals.push(x, y, z);
								uvs.push(u, 1 - v);
						}
				}
				for(var lat1 = 0; lat1 < latitudeBands; ++lat1){
						for(var lon1 = 0; lon1 < longitudeBands; ++lon1){
								var first = lat1 * (longitudeBands + 1) + lon1;
								var second = first + longitudeBands + 1;
								indices.push(first + 1, second, first);
								indices.push(first + 1, second + 1, second);
						}
				}
				this.positions = positions;
				this.normals = normals;
				this.uvs = uvs;
				this.uvs1 = uvs;
				this.indices = indices;
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(positions, normals, uvs, indices);
				}
		}
}

class DomeGeometry extends SphereGeometry {
		constructor(opts = {}){
				var radius = 0.5;
				var _opts_latitudeBands;
				var latitudeBands = (_opts_latitudeBands = opts.latitudeBands) != null ? _opts_latitudeBands : 16;
				var _opts_longitudeBands;
				var longitudeBands = (_opts_longitudeBands = opts.longitudeBands) != null ? _opts_longitudeBands : 16;
				super({
						radius,
						latitudeBands,
						longitudeBands
				});
				var bottomLimit = 0.1;
				var curvatureRadius = 0.95;
				var curvatureRadiusSq = curvatureRadius * curvatureRadius;
				var positions = this.positions;
				for(var i = 0; i < positions.length; i += 3){
						var x = positions[i] / radius;
						var y = positions[i + 1] / radius;
						var z = positions[i + 2] / radius;
						if (y < 0) {
								y *= 0.3;
								if (x * x + z * z < curvatureRadiusSq) {
										y = -0.1;
								}
						}
						y += bottomLimit;
						y *= radius;
						positions[i + 1] = y;
				}
		}
}

class SkyGeometry {
		static create(device, type) {
				switch(type){
						case SKYTYPE_BOX:
								return SkyGeometry.box(device);
						case SKYTYPE_DOME:
								return SkyGeometry.dome(device);
				}
				return SkyGeometry.infinite(device);
		}
		static infinite(device) {
				return Mesh.fromGeometry(device, new BoxGeometry(device));
		}
		static box(device) {
				return Mesh.fromGeometry(device, new BoxGeometry({
						yOffset: 0.5
				}));
		}
		static dome(device) {
				var geom = new DomeGeometry({
						latitudeBands: 50,
						longitudeBands: 50
				});
				geom.normals = undefined;
				geom.uvs = undefined;
				return Mesh.fromGeometry(device, geom);
		}
}

class SkyMesh {
		destroy() {
				if (this.meshInstance) {
						if (this.skyLayer) {
								this.skyLayer.removeMeshInstances([
										this.meshInstance
								]);
						}
						this.meshInstance.destroy();
						this.meshInstance = null;
				}
		}
		constructor(device, scene, node, texture, type){
				this.meshInstance = null;
				var wgsl = device.isWebGPU;
				var material = new ShaderMaterial({
						uniqueName: 'SkyMaterial',
						vertexCode: wgsl ? shaderChunksWGSL.skyboxVS : shaderChunks.skyboxVS,
						fragmentCode: wgsl ? shaderChunksWGSL.skyboxPS : shaderChunks.skyboxPS,
						shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL,
						attributes: {
								aPosition: SEMANTIC_POSITION
						}
				});
				material.setDefine('{SKYBOX_DECODE_FNC}', ChunkUtils.decodeFunc(texture.encoding));
				if (type !== SKYTYPE_INFINITE) material.setDefine('SKYMESH', '');
				if (texture.cubemap) material.setDefine('SKY_CUBEMAP', '');
				material.setParameter('skyboxHighlightMultiplier', scene.skyboxHighlightMultiplier);
				if (texture.cubemap) {
						material.setParameter('texture_cubeMap', texture);
				} else {
						material.setParameter('texture_envAtlas', texture);
						material.setParameter('mipLevel', scene.skyboxMip);
				}
				material.cull = CULLFACE_FRONT;
				material.depthWrite = false;
				var skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);
				if (skyLayer) {
						var mesh = SkyGeometry.create(device, type);
						var meshInstance = new MeshInstance(mesh, material, node);
						this.meshInstance = meshInstance;
						meshInstance.cull = false;
						meshInstance.pick = false;
						skyLayer.addMeshInstances([
								meshInstance
						]);
						this.skyLayer = skyLayer;
				}
		}
}

class Sky {
		applySettings(render) {
				var _render_skyType;
				this.type = (_render_skyType = render.skyType) != null ? _render_skyType : SKYTYPE_INFINITE;
				var _render_skyMeshPosition;
				this.node.setLocalPosition(new Vec3((_render_skyMeshPosition = render.skyMeshPosition) != null ? _render_skyMeshPosition : [
						0,
						0,
						0
				]));
				var _render_skyMeshRotation;
				this.node.setLocalEulerAngles(new Vec3((_render_skyMeshRotation = render.skyMeshRotation) != null ? _render_skyMeshRotation : [
						0,
						0,
						0
				]));
				var _render_skyMeshScale;
				this.node.setLocalScale(new Vec3((_render_skyMeshScale = render.skyMeshScale) != null ? _render_skyMeshScale : [
						1,
						1,
						1
				]));
				if (render.skyCenter) {
						this._center = new Vec3(render.skyCenter);
				}
		}
		set type(value) {
				if (this._type !== value) {
						this._type = value;
						this.scene.updateShaders = true;
						this.updateSkyMesh();
				}
		}
		get type() {
				return this._type;
		}
		set center(value) {
				this._center.copy(value);
		}
		get center() {
				return this._center;
		}
		updateSkyMesh() {
				var texture = this.scene._getSkyboxTex();
				if (texture) {
						this.resetSkyMesh();
						this.skyMesh = new SkyMesh(this.device, this.scene, this.node, texture, this.type);
						this.scene.fire('set:skybox', texture);
				}
		}
		resetSkyMesh() {
				var _this_skyMesh;
				(_this_skyMesh = this.skyMesh) == null ? void 0 : _this_skyMesh.destroy();
				this.skyMesh = null;
		}
		update() {
				if (this.type !== SKYTYPE_INFINITE) {
						var { center, centerArray } = this;
						var temp = new Vec3();
						this.node.getWorldTransform().transformPoint(center, temp);
						centerArray[0] = temp.x;
						centerArray[1] = temp.y;
						centerArray[2] = temp.z;
						this.projectedSkydomeCenterId.setValue(centerArray);
				}
		}
		constructor(scene){
				this._type = SKYTYPE_INFINITE;
				this._center = new Vec3(0, 1, 0);
				this.skyMesh = null;
				this.node = new GraphNode('SkyMeshNode');
				this.device = scene.device;
				this.scene = scene;
				this.center = new Vec3(0, 1, 0);
				this.centerArray = new Float32Array(3);
				this.projectedSkydomeCenterId = this.device.scope.resolve('projectedSkydomeCenter');
		}
}

var identityGraphNode = new GraphNode();
identityGraphNode.worldTransform = Mat4.IDENTITY;
identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
class ImmediateBatch {
		addLines(positions, color) {
				var destPos = this.positions;
				var count = positions.length;
				for(var i = 0; i < count; i++){
						var pos = positions[i];
						destPos.push(pos.x, pos.y, pos.z);
				}
				var destCol = this.colors;
				if (color.length) {
						for(var i1 = 0; i1 < count; i1++){
								var col = color[i1];
								destCol.push(col.r, col.g, col.b, col.a);
						}
				} else {
						for(var i2 = 0; i2 < count; i2++){
								destCol.push(color.r, color.g, color.b, color.a);
						}
				}
		}
		addLinesArrays(positions, color) {
				var destPos = this.positions;
				for(var i = 0; i < positions.length; i += 3){
						destPos.push(positions[i], positions[i + 1], positions[i + 2]);
				}
				var destCol = this.colors;
				if (color.length) {
						for(var i1 = 0; i1 < color.length; i1 += 4){
								destCol.push(color[i1], color[i1 + 1], color[i1 + 2], color[i1 + 3]);
						}
				} else {
						var count = positions.length / 3;
						for(var i2 = 0; i2 < count; i2++){
								destCol.push(color.r, color.g, color.b, color.a);
						}
				}
		}
		onPreRender(visibleList, transparent) {
				if (this.positions.length > 0 && this.material.transparent === transparent) {
						this.mesh.setPositions(this.positions);
						this.mesh.setColors(this.colors);
						this.mesh.update(PRIMITIVE_LINES, false);
						if (!this.meshInstance) {
								this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
						}
						visibleList.push(this.meshInstance);
				}
		}
		clear() {
				this.positions.length = 0;
				this.colors.length = 0;
		}
		constructor(device, material, layer){
				this.material = material;
				this.layer = layer;
				this.positions = [];
				this.colors = [];
				this.mesh = new Mesh(device);
				this.meshInstance = null;
		}
}

class ImmediateBatches {
		getBatch(material, layer) {
				var batch = this.map.get(material);
				if (!batch) {
						batch = new ImmediateBatch(this.device, material, layer);
						this.map.set(material, batch);
				}
				return batch;
		}
		onPreRender(visibleList, transparent) {
				this.map.forEach((batch)=>{
						batch.onPreRender(visibleList, transparent);
				});
		}
		clear() {
				this.map.forEach((batch)=>batch.clear());
		}
		constructor(device){
				this.device = device;
				this.map = new Map();
		}
}

var tempPoints = [];
var vec = new Vec3();
var lineShaderDescGLSL = {
		uniqueName: 'ImmediateLine',
		vertexCode: shaderChunks.immediateLineVS,
		fragmentCode: shaderChunks.immediateLinePS,
		shaderLanguage: SHADERLANGUAGE_GLSL,
		attributes: {
				vertex_position: SEMANTIC_POSITION,
				vertex_color: SEMANTIC_COLOR
		}
};
var lineShaderDescWGSL = {
		uniqueName: 'ImmediateLine',
		vertexCode: shaderChunksWGSL.immediateLineVS,
		fragmentCode: shaderChunksWGSL.immediateLinePS,
		shaderLanguage: SHADERLANGUAGE_WGSL,
		attributes: {
				vertex_position: SEMANTIC_POSITION,
				vertex_color: SEMANTIC_COLOR
		}
};
class Immediate {
		createMaterial(depthTest) {
				var material = new ShaderMaterial(this.device.isWebGPU ? lineShaderDescWGSL : lineShaderDescGLSL);
				material.blendType = BLEND_NORMAL;
				material.depthTest = depthTest;
				material.update();
				return material;
		}
		get materialDepth() {
				if (!this._materialDepth) {
						this._materialDepth = this.createMaterial(true);
				}
				return this._materialDepth;
		}
		get materialNoDepth() {
				if (!this._materialNoDepth) {
						this._materialNoDepth = this.createMaterial(false);
				}
				return this._materialNoDepth;
		}
		getBatch(layer, depthTest) {
				var batches = this.batchesMap.get(layer);
				if (!batches) {
						batches = new ImmediateBatches(this.device);
						this.batchesMap.set(layer, batches);
				}
				this.allBatches.add(batches);
				var material = depthTest ? this.materialDepth : this.materialNoDepth;
				return batches.getBatch(material, layer);
		}
		getShaderDesc(id, fragment) {
				if (!this.shaderDescs.has(id)) {
						var vertex = "\n				attribute vec2 vertex_position;\n				uniform mat4 matrix_model;\n				varying vec2 uv0;\n				void main(void) {\n					gl_Position = matrix_model * vec4(vertex_position, 0, 1);\n					uv0 = vertex_position.xy + 0.5;\n				}\n			";
						this.shaderDescs.set(id, {
								uniqueName: "DebugShader:" + id,
								vertexCode: vertex,
								fragmentCode: fragment,
								attributes: {
										vertex_position: SEMANTIC_POSITION
								}
						});
				}
				return this.shaderDescs.get(id);
		}
		getTextureShaderDesc(encoding) {
				var decodeFunc = ChunkUtils.decodeFunc(encoding);
				return this.getShaderDesc("textureShader-" + encoding, '\n			#include "gammaPS"\n			varying vec2 uv0;\n			uniform sampler2D colorMap;\n			void main (void) {\n				vec3 linearColor = ' + decodeFunc + "(texture2D(colorMap, uv0));\n				gl_FragColor = vec4(gammaCorrectOutput(linearColor), 1);\n			}\n		");
		}
		getUnfilterableTextureShaderDesc() {
				return this.getShaderDesc('textureShaderUnfilterable', "\n			varying vec2 uv0;\n			uniform highp sampler2D colorMap;\n			void main (void) {\n				ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));\n				gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);\n			}\n		");
		}
		getDepthTextureShaderDesc() {
				return this.getShaderDesc('depthTextureShader', "\n			" + shaderChunks.screenDepthPS + '\n			#include "gammaPS"\n			varying vec2 uv0;\n			void main() {\n				float depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;\n				gl_FragColor = vec4(gammaCorrectOutput(vec3(depth)), 1.0);\n			}\n		');
		}
		getQuadMesh() {
				if (!this.quadMesh) {
						this.quadMesh = new Mesh(this.device);
						this.quadMesh.setPositions([
								-0.5,
								-0.5,
								0,
								0.5,
								-0.5,
								0,
								-0.5,
								0.5,
								0,
								0.5,
								0.5,
								0
						]);
						this.quadMesh.update(PRIMITIVE_TRISTRIP);
				}
				return this.quadMesh;
		}
		drawMesh(material, matrix, mesh, meshInstance, layer) {
				if (!meshInstance) {
						var graphNode = this.getGraphNode(matrix);
						meshInstance = new MeshInstance(mesh, material, graphNode);
				}
				var layerMeshInstances = this.layerMeshInstances.get(layer);
				if (!layerMeshInstances) {
						layerMeshInstances = [];
						this.layerMeshInstances.set(layer, layerMeshInstances);
				}
				layerMeshInstances.push(meshInstance);
		}
		drawWireAlignedBox(min, max, color, depthTest, layer, mat) {
				if (mat) {
						var mulPoint = (x, y, z)=>{
								vec.set(x, y, z);
								mat.transformPoint(vec, vec);
								tempPoints.push(vec.x, vec.y, vec.z);
						};
						mulPoint(min.x, min.y, min.z);
						mulPoint(min.x, max.y, min.z);
						mulPoint(min.x, max.y, min.z);
						mulPoint(max.x, max.y, min.z);
						mulPoint(max.x, max.y, min.z);
						mulPoint(max.x, min.y, min.z);
						mulPoint(max.x, min.y, min.z);
						mulPoint(min.x, min.y, min.z);
						mulPoint(min.x, min.y, max.z);
						mulPoint(min.x, max.y, max.z);
						mulPoint(min.x, max.y, max.z);
						mulPoint(max.x, max.y, max.z);
						mulPoint(max.x, max.y, max.z);
						mulPoint(max.x, min.y, max.z);
						mulPoint(max.x, min.y, max.z);
						mulPoint(min.x, min.y, max.z);
						mulPoint(min.x, min.y, min.z);
						mulPoint(min.x, min.y, max.z);
						mulPoint(min.x, max.y, min.z);
						mulPoint(min.x, max.y, max.z);
						mulPoint(max.x, max.y, min.z);
						mulPoint(max.x, max.y, max.z);
						mulPoint(max.x, min.y, min.z);
						mulPoint(max.x, min.y, max.z);
				} else {
						tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
				}
				var batch = this.getBatch(layer, depthTest);
				batch.addLinesArrays(tempPoints, color);
				tempPoints.length = 0;
		}
		drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
				var step = 2 * Math.PI / numSegments;
				var angle = 0;
				for(var i = 0; i < numSegments; i++){
						var sin0 = Math.sin(angle);
						var cos0 = Math.cos(angle);
						angle += step;
						var sin1 = Math.sin(angle);
						var cos1 = Math.cos(angle);
						tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
						tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
						tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
						tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
						tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
						tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
				}
				var batch = this.getBatch(layer, depthTest);
				batch.addLinesArrays(tempPoints, color);
				tempPoints.length = 0;
		}
		getGraphNode(matrix) {
				var graphNode = new GraphNode('ImmediateDebug');
				graphNode.worldTransform = matrix;
				graphNode._dirtyWorld = graphNode._dirtyNormal = false;
				return graphNode;
		}
		onPreRenderLayer(layer, visibleList, transparent) {
				this.batchesMap.forEach((batches, batchLayer)=>{
						if (batchLayer === layer) {
								batches.onPreRender(visibleList, transparent);
						}
				});
				if (!this.updatedLayers.has(layer)) {
						this.updatedLayers.add(layer);
						var meshInstances = this.layerMeshInstances.get(layer);
						if (meshInstances) {
								for(var i = 0; i < meshInstances.length; i++){
										visibleList.push(meshInstances[i]);
								}
								meshInstances.length = 0;
						}
				}
		}
		onPostRender() {
				this.allBatches.forEach((batch)=>batch.clear());
				this.allBatches.clear();
				this.updatedLayers.clear();
		}
		constructor(device){
				this.shaderDescs = new Map();
				this.device = device;
				this.quadMesh = null;
				this.textureShader = null;
				this.depthTextureShader = null;
				this.cubeLocalPos = null;
				this.cubeWorldPos = null;
				this.batchesMap = new Map();
				this.allBatches = new Set();
				this.updatedLayers = new Set();
				this._materialDepth = null;
				this._materialNoDepth = null;
				this.layerMeshInstances = new Map();
		}
}

var _goldenAngle = 2.399963229728653;
var random = {
		circlePoint (point) {
				var r = Math.sqrt(Math.random());
				var theta = Math.random() * 2 * Math.PI;
				point.x = r * Math.cos(theta);
				point.y = r * Math.sin(theta);
		},
		circlePointDeterministic (point, index, numPoints) {
				var theta = index * _goldenAngle;
				var r = Math.sqrt(index) / Math.sqrt(numPoints);
				point.x = r * Math.cos(theta);
				point.y = r * Math.sin(theta);
		},
		spherePointDeterministic (point, index, numPoints, start, end) {
				if (start === void 0) start = 0;
				if (end === void 0) end = 1;
				start = 1 - 2 * start;
				end = 1 - 2 * end;
				var y = math.lerp(start, end, index / numPoints);
				var radius = Math.sqrt(1 - y * y);
				var theta = _goldenAngle * index;
				point.x = Math.cos(theta) * radius;
				point.y = y;
				point.z = Math.sin(theta) * radius;
		},
		radicalInverse (i) {
				var bits = (i << 16 | i >>> 16) >>> 0;
				bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
				bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
				bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
				bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
				return bits * 2.3283064365386963e-10;
		}
};

var getProjectionName = (projection)=>{
		switch(projection){
				case TEXTUREPROJECTION_CUBE:
						return 'Cubemap';
				case TEXTUREPROJECTION_OCTAHEDRAL:
						return 'Octahedral';
				default:
						return 'Equirect';
		}
};
var packFloat32ToRGBA8 = (value, array, offset)=>{
		if (value <= 0) {
				array[offset + 0] = 0;
				array[offset + 1] = 0;
				array[offset + 2] = 0;
				array[offset + 3] = 0;
		} else if (value >= 1.0) {
				array[offset + 0] = 255;
				array[offset + 1] = 0;
				array[offset + 2] = 0;
				array[offset + 3] = 0;
		} else {
				var encX = 1 * value % 1;
				var encY = 255 * value % 1;
				var encZ = 65025 * value % 1;
				var encW = 16581375.0 * value % 1;
				encX -= encY / 255;
				encY -= encZ / 255;
				encZ -= encW / 255;
				array[offset + 0] = Math.min(255, Math.floor(encX * 256));
				array[offset + 1] = Math.min(255, Math.floor(encY * 256));
				array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
				array[offset + 3] = Math.min(255, Math.floor(encW * 256));
		}
};
var packSamples = (samples)=>{
		var numSamples = samples.length;
		var w = Math.min(numSamples, 512);
		var h = Math.ceil(numSamples / w);
		var data = new Uint8Array(w * h * 4);
		var off = 0;
		for(var i = 0; i < numSamples; i += 4){
				packFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data, off + 0);
				packFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data, off + 4);
				packFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data, off + 8);
				packFloat32ToRGBA8(samples[i + 3] / 8, data, off + 12);
				off += 16;
		}
		return {
				width: w,
				height: h,
				data: data
		};
};
var hemisphereSamplePhong = (dstVec, x, y, specularPower)=>{
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};
var hemisphereSampleLambert = (dstVec, x, y)=>{
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt(1 - x);
		var sinTheta = Math.sqrt(x);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};
var hemisphereSampleGGX = (dstVec, x, y, a)=>{
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};
var D_GGX = (NoH, linearRoughness)=>{
		var a = NoH * linearRoughness;
		var k = linearRoughness / (1.0 - NoH * NoH + a * a);
		return k * k * (1 / Math.PI);
};
var generatePhongSamples = (numSamples, specularPower)=>{
		var H = new Vec3();
		var result = [];
		for(var i = 0; i < numSamples; ++i){
				hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
				result.push(H.x, H.y, H.z, 0);
		}
		return result;
};
var generateLambertSamples = (numSamples, sourceTotalPixels)=>{
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var H = new Vec3();
		var result = [];
		for(var i = 0; i < numSamples; ++i){
				hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
				var pdf = H.z / Math.PI;
				var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
				result.push(H.x, H.y, H.z, mipLevel);
		}
		return result;
};
var requiredSamplesGGX = {
		'16': {
				'2': 26,
				'8': 20,
				'32': 17,
				'128': 16,
				'512': 16
		},
		'32': {
				'2': 53,
				'8': 40,
				'32': 34,
				'128': 32,
				'512': 32
		},
		'128': {
				'2': 214,
				'8': 163,
				'32': 139,
				'128': 130,
				'512': 128
		},
		'1024': {
				'2': 1722,
				'8': 1310,
				'32': 1114,
				'128': 1041,
				'512': 1025
		}
};
var getRequiredSamplesGGX = (numSamples, specularPower)=>{
		var table = requiredSamplesGGX[numSamples];
		return table && table[specularPower] || numSamples;
};
var generateGGXSamples = (numSamples, specularPower, sourceTotalPixels)=>{
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var roughness = 1 - Math.log2(specularPower) / 11.0;
		var a = roughness * roughness;
		var H = new Vec3();
		var L = new Vec3();
		var N = new Vec3(0, 0, 1);
		var result = [];
		var requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);
		for(var i = 0; i < requiredSamples; ++i){
				hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
				var NoH = H.z;
				L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);
				if (L.z > 0) {
						var pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
						var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
						result.push(L.x, L.y, L.z, mipLevel);
				}
		}
		while(result.length < numSamples * 4){
				result.push(0, 0, 0, 0);
		}
		return result;
};
var createSamplesTex = (device, name, samples)=>{
		var packedSamples = packSamples(samples);
		return new Texture(device, {
				name: name,
				width: packedSamples.width,
				height: packedSamples.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				levels: [
						packedSamples.data
				]
		});
};
class SimpleCache {
		destroy() {
				if (this.destroyContent) {
						this.map.forEach((value, key)=>{
								value.destroy();
						});
				}
		}
		get(key, missFunc) {
				if (!this.map.has(key)) {
						var result = missFunc();
						this.map.set(key, result);
						return result;
				}
				return this.map.get(key);
		}
		constructor(destroyContent = true){
				this.map = new Map();
				this.destroyContent = destroyContent;
		}
}
var samplesCache = new SimpleCache(false);
var deviceCache$1 = new DeviceCache();
var getCachedTexture = (device, key, getSamplesFnc)=>{
		var cache = deviceCache$1.get(device, ()=>{
				return new SimpleCache();
		});
		return cache.get(key, ()=>{
				return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
		});
};
var generateLambertSamplesTex = (device, numSamples, sourceTotalPixels)=>{
		var key = "lambert-samples-" + numSamples + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, ()=>{
				return generateLambertSamples(numSamples, sourceTotalPixels);
		});
};
var generatePhongSamplesTex = (device, numSamples, specularPower)=>{
		var key = "phong-samples-" + numSamples + "-" + specularPower;
		return getCachedTexture(device, key, ()=>{
				return generatePhongSamples(numSamples, specularPower);
		});
};
var generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels)=>{
		var key = "ggx-samples-" + numSamples + "-" + specularPower + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, ()=>{
				return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
		});
};
function reprojectTexture(source, target, options) {
		if (options === void 0) options = {};
		var _options_rect, _options_rect1;
		var _options_seamPixels;
		var seamPixels = (_options_seamPixels = options.seamPixels) != null ? _options_seamPixels : 0;
		var _options_rect_z;
		var innerWidth = ((_options_rect_z = (_options_rect = options.rect) == null ? void 0 : _options_rect.z) != null ? _options_rect_z : target.width) - seamPixels * 2;
		var _options_rect_w;
		var innerHeight = ((_options_rect_w = (_options_rect1 = options.rect) == null ? void 0 : _options_rect1.w) != null ? _options_rect_w : target.height) - seamPixels * 2;
		if (innerWidth < 1 || innerHeight < 1) {
				return false;
		}
		var funcNames = {
				'none': 'reproject',
				'lambert': 'prefilterSamplesUnweighted',
				'phong': 'prefilterSamplesUnweighted',
				'ggx': 'prefilterSamples'
		};
		var specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
		var face = options.hasOwnProperty('face') ? options.face : null;
		var distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
		var processFunc = funcNames[distribution] || 'reproject';
		var prefilterSamples = processFunc.startsWith('prefilterSamples');
		var decodeFunc = ChunkUtils.decodeFunc(source.encoding);
		var encodeFunc = ChunkUtils.encodeFunc(target.encoding);
		var sourceFunc = "sample" + getProjectionName(source.projection);
		var targetFunc = "getDirection" + getProjectionName(target.projection);
		var numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
		var shaderKey = processFunc + "_" + decodeFunc + "_" + encodeFunc + "_" + sourceFunc + "_" + targetFunc + "_" + numSamples;
		var device = source.device;
		var shader = getProgramLibrary(device).getCachedShader(shaderKey);
		if (!shader) {
				var defines = "\n            " + (prefilterSamples ? '#define USE_SAMPLES_TEX' : '') + "\n            " + (source.cubemap ? '#define CUBEMAP_SOURCE' : '') + "\n            #define {PROCESS_FUNC} " + processFunc + "\n            #define {DECODE_FUNC} " + decodeFunc + "\n            #define {ENCODE_FUNC} " + encodeFunc + "\n            #define {SOURCE_FUNC} " + sourceFunc + "\n            #define {TARGET_FUNC} " + targetFunc + "\n            #define {NUM_SAMPLES} " + numSamples + "\n            #define {NUM_SAMPLES_SQRT} " + Math.round(Math.sqrt(numSamples)).toFixed(1) + "\n        ";
				var wgsl = device.isWebGPU;
				var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
				var includes = new Map();
				includes.set('decodePS', chunks.decodePS);
				includes.set('encodePS', chunks.encodePS);
				var vert = chunks.reprojectVS;
				var frag = chunks.reprojectPS;
				shader = createShaderFromCode(device, vert, "\n                " + defines + "\n                " + frag + "\n            ", shaderKey, {
						vertex_position: SEMANTIC_POSITION
				}, {
						fragmentIncludes: includes,
						shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL
				});
		}
		device.setBlendState(BlendState.NOBLEND);
		var constantSource = device.scope.resolve(source.cubemap ? 'sourceCube' : 'sourceTex');
		constantSource.setValue(source);
		var constantParams = device.scope.resolve('params');
		var uvModParam = device.scope.resolve('uvMod');
		if (seamPixels > 0) {
				uvModParam.setValue([
						(innerWidth + seamPixels * 2) / innerWidth,
						(innerHeight + seamPixels * 2) / innerHeight,
						-seamPixels / innerWidth,
						-seamPixels / innerHeight
				]);
		} else {
				uvModParam.setValue([
						1,
						1,
						0,
						0
				]);
		}
		var params = [
				0,
				target.width * target.height * (target.cubemap ? 6 : 1),
				source.width * source.height * (source.cubemap ? 6 : 1)
		];
		if (prefilterSamples) {
				var sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
				var samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
				device.scope.resolve('samplesTex').setValue(samplesTex);
				device.scope.resolve('samplesTexInverseSize').setValue([
						1.0 / samplesTex.width,
						1.0 / samplesTex.height
				]);
		}
		for(var f = 0; f < (target.cubemap ? 6 : 1); f++){
				if (face === null || f === face) {
						var renderTarget = new RenderTarget({
								colorBuffer: target,
								face: f,
								depth: false,
								flipY: device.isWebGPU
						});
						params[0] = f;
						constantParams.setValue(params);
						drawQuadWithShader(device, renderTarget, shader, options == null ? void 0 : options.rect);
						renderTarget.destroy();
				}
		}
		return true;
}

var calcLevels = (width, height)=>{
		if (height === void 0) height = 0;
		return 1 + Math.floor(Math.log2(Math.max(width, height)));
};
var supportsFloat16 = (device)=>{
		return device.textureHalfFloatRenderable;
};
var supportsFloat32 = (device)=>{
		return device.textureFloatRenderable;
};
var lightingSourcePixelFormat = (device)=>{
		return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;
};
var lightingPixelFormat = (device)=>{
		return PIXELFORMAT_RGBA8;
};
var createCubemap = (device, size, format, mipmaps)=>{
		return new Texture(device, {
				name: "lighting-" + size,
				cubemap: true,
				width: size,
				height: size,
				format: format,
				type: TEXTURETYPE_RGBP ,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
		});
};
class EnvLighting {
		static generateSkyboxCubemap(source, size) {
				var device = source.device;
				var result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_RGBA8);
				reprojectTexture(source, result, {
						numSamples: 1024
				});
				return result;
		}
		static generateLightingSource(source, options) {
				var device = source.device;
				var format = lightingSourcePixelFormat(device);
				var result = (options == null ? void 0 : options.target) || new Texture(device, {
						name: 'lighting-source',
						cubemap: true,
						width: (options == null ? void 0 : options.size) || 128,
						height: (options == null ? void 0 : options.size) || 128,
						format: format,
						type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						mipmaps: true
				});
				reprojectTexture(source, result, {
						numSamples: source.mipmaps ? 1 : 1024
				});
				return result;
		}
		static generateAtlas(source, options) {
				var device = source.device;
				var format = lightingPixelFormat();
				var result = (options == null ? void 0 : options.target) || new Texture(device, {
						name: 'envAtlas',
						width: (options == null ? void 0 : options.size) || 512,
						height: (options == null ? void 0 : options.size) || 512,
						format: format,
						type: TEXTURETYPE_RGBP ,
						projection: TEXTUREPROJECTION_EQUIRECT,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						mipmaps: false
				});
				var s = result.width / 512;
				var rect = new Vec4(0, 0, 512 * s, 256 * s);
				var levels = calcLevels(256) - calcLevels(4);
				for(var i = 0; i < levels; ++i){
						reprojectTexture(source, result, {
								numSamples: 1,
								rect: rect,
								seamPixels: s
						});
						rect.x += rect.w;
						rect.y += rect.w;
						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
				}
				rect.set(0, 256 * s, 256 * s, 128 * s);
				for(var i1 = 1; i1 < 7; ++i1){
						reprojectTexture(source, result, {
								numSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,
								distribution: (options == null ? void 0 : options.distribution) || 'ggx',
								specularPower: Math.max(1, 2048 >> i1 * 2),
								rect: rect,
								seamPixels: s
						});
						rect.y += rect.w;
						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
				}
				rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
				reprojectTexture(source, result, {
						numSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,
						distribution: 'lambert',
						rect: rect,
						seamPixels: s
				});
				return result;
		}
		static generatePrefilteredAtlas(sources, options) {
				var device = sources[0].device;
				var format = sources[0].format;
				var type = sources[0].type;
				var result = (options == null ? void 0 : options.target) || new Texture(device, {
						name: 'envPrefilteredAtlas',
						width: (options == null ? void 0 : options.size) || 512,
						height: (options == null ? void 0 : options.size) || 512,
						format: format,
						type: type,
						projection: TEXTUREPROJECTION_EQUIRECT,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						mipmaps: false
				});
				var s = result.width / 512;
				var rect = new Vec4(0, 0, 512 * s, 256 * s);
				var levels = calcLevels(512);
				for(var i = 0; i < levels; ++i){
						reprojectTexture(sources[0], result, {
								numSamples: 1,
								rect: rect,
								seamPixels: s
						});
						rect.x += rect.w;
						rect.y += rect.w;
						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
				}
				rect.set(0, 256 * s, 256 * s, 128 * s);
				for(var i1 = 1; i1 < sources.length; ++i1){
						reprojectTexture(sources[i1], result, {
								numSamples: 1,
								rect: rect,
								seamPixels: s
						});
						rect.y += rect.w;
						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
				}
				rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
				if (options == null ? void 0 : options.legacyAmbient) {
						reprojectTexture(sources[5], result, {
								numSamples: 1,
								rect: rect,
								seamPixels: s
						});
				} else {
						reprojectTexture(sources[0], result, {
								numSamples: (options == null ? void 0 : options.numSamples) || 2048,
								distribution: 'lambert',
								rect: rect,
								seamPixels: s
						});
				}
				return result;
		}
}

class FogParams {
		constructor(){
				this.type = FOG_NONE;
				this.color = new Color(0, 0, 0);
				this.density = 0;
				this.start = 1;
				this.end = 1000;
		}
}

class Scene extends EventHandler {
		get defaultDrawLayer() {
				return this.layers.getLayerById(LAYERID_IMMEDIATE);
		}
		set ambientBakeNumSamples(value) {
				this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
		}
		get ambientBakeNumSamples() {
				return this._ambientBakeNumSamples;
		}
		set ambientBakeSpherePart(value) {
				this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
		}
		get ambientBakeSpherePart() {
				return this._ambientBakeSpherePart;
		}
		set clusteredLightingEnabled(value) {
				if (this.device.isWebGPU && !value) {
						return;
				}
				if (!this._clusteredLightingEnabled && value) {
						console.error('Turning on disabled clustered lighting is not currently supported');
						return;
				}
				this._clusteredLightingEnabled = value;
		}
		get clusteredLightingEnabled() {
				return this._clusteredLightingEnabled;
		}
		set envAtlas(value) {
				if (value !== this._envAtlas) {
						this._envAtlas = value;
						if (value) {
								value.addressU = ADDRESS_CLAMP_TO_EDGE;
								value.addressV = ADDRESS_CLAMP_TO_EDGE;
								value.minFilter = FILTER_LINEAR;
								value.magFilter = FILTER_LINEAR;
								value.mipmaps = false;
						}
						this._prefilteredCubemaps = [];
						if (this._internalEnvAtlas) {
								this._internalEnvAtlas.destroy();
								this._internalEnvAtlas = null;
						}
						this._resetSkyMesh();
				}
		}
		get envAtlas() {
				return this._envAtlas;
		}
		set layers(layers) {
				var prev = this._layers;
				this._layers = layers;
				this.fire('set:layers', prev, layers);
		}
		get layers() {
				return this._layers;
		}
		get sky() {
				return this._sky;
		}
		get lighting() {
				return this._lightingParams;
		}
		get fog() {
				return this._fogParams;
		}
		set lightmapFilterRange(value) {
				this._lightmapFilterRange = Math.max(value, 0.001);
		}
		get lightmapFilterRange() {
				return this._lightmapFilterRange;
		}
		set lightmapFilterSmoothness(value) {
				this._lightmapFilterSmoothness = Math.max(value, 0.001);
		}
		get lightmapFilterSmoothness() {
				return this._lightmapFilterSmoothness;
		}
		set prefilteredCubemaps(value) {
				value = value || [];
				var cubemaps = this._prefilteredCubemaps;
				var changed = cubemaps.length !== value.length || cubemaps.some((c, i)=>c !== value[i]);
				if (changed) {
						var complete = value.length === 6 && value.every((c)=>!!c);
						if (complete) {
								this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(value, {
										target: this._internalEnvAtlas
								});
								this._envAtlas = this._internalEnvAtlas;
						} else {
								if (this._internalEnvAtlas) {
										this._internalEnvAtlas.destroy();
										this._internalEnvAtlas = null;
								}
								this._envAtlas = null;
						}
						this._prefilteredCubemaps = value.slice();
						this._resetSkyMesh();
				}
		}
		get prefilteredCubemaps() {
				return this._prefilteredCubemaps;
		}
		set skybox(value) {
				if (value !== this._skyboxCubeMap) {
						this._skyboxCubeMap = value;
						this._resetSkyMesh();
				}
		}
		get skybox() {
				return this._skyboxCubeMap;
		}
		set skyboxIntensity(value) {
				if (value !== this._skyboxIntensity) {
						this._skyboxIntensity = value;
						this._resetSkyMesh();
				}
		}
		get skyboxIntensity() {
				return this._skyboxIntensity;
		}
		set skyboxLuminance(value) {
				if (value !== this._skyboxLuminance) {
						this._skyboxLuminance = value;
						this._resetSkyMesh();
				}
		}
		get skyboxLuminance() {
				return this._skyboxLuminance;
		}
		set skyboxMip(value) {
				if (value !== this._skyboxMip) {
						this._skyboxMip = value;
						this._resetSkyMesh();
				}
		}
		get skyboxMip() {
				return this._skyboxMip;
		}
		set skyboxHighlightMultiplier(value) {
				if (value !== this._skyboxHighlightMultiplier) {
						this._skyboxHighlightMultiplier = value;
						this._resetSkyMesh();
				}
		}
		get skyboxHighlightMultiplier() {
				return this._skyboxHighlightMultiplier;
		}
		set skyboxRotation(value) {
				if (!this._skyboxRotation.equals(value)) {
						var isIdentity = value.equals(Quat.IDENTITY);
						this._skyboxRotation.copy(value);
						if (isIdentity) {
								this._skyboxRotationMat3.setIdentity();
						} else {
								this._skyboxRotationMat4.setTRS(Vec3.ZERO, value, Vec3.ONE);
								this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);
						}
						if (!this._skyboxRotationShaderInclude && !isIdentity) {
								this._skyboxRotationShaderInclude = true;
								this._resetSkyMesh();
						}
				}
		}
		get skyboxRotation() {
				return this._skyboxRotation;
		}
		destroy() {
				this._resetSkyMesh();
				this.root = null;
				this.off();
		}
		drawLine(start, end, color, depthTest, layer) {
				if (color === void 0) color = Color.WHITE;
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.defaultDrawLayer;
				var batch = this.immediate.getBatch(layer, depthTest);
				batch.addLines([
						start,
						end
				], [
						color,
						color
				]);
		}
		drawLines(positions, colors, depthTest, layer) {
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.defaultDrawLayer;
				var batch = this.immediate.getBatch(layer, depthTest);
				batch.addLines(positions, colors);
		}
		drawLineArrays(positions, colors, depthTest, layer) {
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.defaultDrawLayer;
				var batch = this.immediate.getBatch(layer, depthTest);
				batch.addLinesArrays(positions, colors);
		}
		applySettings(settings) {
				var physics = settings.physics;
				var render = settings.render;
				this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);
				this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
				this.ambientLuminance = render.ambientLuminance;
				this.fog.type = render.fog;
				this.fog.color.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
				this.fog.start = render.fog_start;
				this.fog.end = render.fog_end;
				this.fog.density = render.fog_density;
				this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
				this.lightmapMaxResolution = render.lightmapMaxResolution;
				this.lightmapMode = render.lightmapMode;
				this.exposure = render.exposure;
				var _render_skyboxIntensity;
				this._skyboxIntensity = (_render_skyboxIntensity = render.skyboxIntensity) != null ? _render_skyboxIntensity : 1;
				var _render_skyboxLuminance;
				this._skyboxLuminance = (_render_skyboxLuminance = render.skyboxLuminance) != null ? _render_skyboxLuminance : 20000;
				var _render_skyboxMip;
				this._skyboxMip = (_render_skyboxMip = render.skyboxMip) != null ? _render_skyboxMip : 0;
				if (render.skyboxRotation) {
						this.skyboxRotation = new Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
				}
				this.sky.applySettings(render);
				var _render_clusteredLightingEnabled;
				this.clusteredLightingEnabled = (_render_clusteredLightingEnabled = render.clusteredLightingEnabled) != null ? _render_clusteredLightingEnabled : false;
				this.lighting.applySettings(render);
				[
						'lightmapFilterEnabled',
						'lightmapFilterRange',
						'lightmapFilterSmoothness',
						'ambientBake',
						'ambientBakeNumSamples',
						'ambientBakeSpherePart',
						'ambientBakeOcclusionBrightness',
						'ambientBakeOcclusionContrast'
				].forEach((setting)=>{
						if (render.hasOwnProperty(setting)) {
								this[setting] = render[setting];
						}
				});
				this._resetSkyMesh();
		}
		_getSkyboxTex() {
				var cubemaps = this._prefilteredCubemaps;
				if (this._skyboxMip) {
						var skyboxMapping = [
								0,
								1,
								3,
								4,
								5,
								6
						];
						return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
				}
				return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
		}
		_updateSkyMesh() {
				if (!this.sky.skyMesh) {
						this.sky.updateSkyMesh();
				}
				this.sky.update();
		}
		_resetSkyMesh() {
				this.sky.resetSkyMesh();
				this.updateShaders = true;
		}
		setSkybox(cubemaps) {
				if (!cubemaps) {
						this.skybox = null;
						this.envAtlas = null;
				} else {
						this.skybox = cubemaps[0] || null;
						if (cubemaps[1] && !cubemaps[1].cubemap) {
								this.envAtlas = cubemaps[1];
						} else {
								this.prefilteredCubemaps = cubemaps.slice(1);
						}
				}
		}
		get lightmapPixelFormat() {
				return this.lightmapHDR && this.device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
		}
		constructor(graphicsDevice){
				super(), this.ambientBake = false, this.ambientBakeOcclusionBrightness = 0, this.ambientBakeOcclusionContrast = 0, this.ambientLight = new Color(0, 0, 0), this.ambientLuminance = 0, this.exposure = 1, this.lightmapSizeMultiplier = 1, this.lightmapMaxResolution = 2048, this.lightmapMode = BAKE_COLORDIR, this.lightmapFilterEnabled = false, this.lightmapHDR = false, this.root = null, this.physicalUnits = false, this._envAtlas = null, this._skyboxCubeMap = null, this._fogParams = new FogParams();
				this.device = graphicsDevice;
				this._gravity = new Vec3(0, -9.8, 0);
				this._layers = null;
				this._prefilteredCubemaps = [];
				this._internalEnvAtlas = null;
				this._skyboxIntensity = 1;
				this._skyboxLuminance = 0;
				this._skyboxMip = 0;
				this._skyboxHighlightMultiplier = 1;
				this._skyboxRotationShaderInclude = false;
				this._skyboxRotation = new Quat();
				this._skyboxRotationMat3 = new Mat3();
				this._skyboxRotationMat4 = new Mat4();
				this._ambientBakeNumSamples = 1;
				this._ambientBakeSpherePart = 0.4;
				this._lightmapFilterRange = 10;
				this._lightmapFilterSmoothness = 0.2;
				this._clusteredLightingEnabled = true;
				this._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, ()=>{
						this.updateShaders = true;
				});
				this._sky = new Sky(this);
				this._stats = {
						meshInstances: 0,
						lights: 0,
						dynamicLights: 0,
						bakedLights: 0,
						updateShadersTime: 0
				};
				this.updateShaders = true;
				this._shaderVersion = 0;
				this.immediate = new Immediate(this.device);
		}
}
Scene.EVENT_SETLAYERS = 'set:layers';
Scene.EVENT_SETSKYBOX = 'set:skybox';
Scene.EVENT_PRERENDER = 'prerender';
Scene.EVENT_POSTRENDER = 'postrender';
Scene.EVENT_PRERENDER_LAYER = 'prerender:layer';
Scene.EVENT_POSTRENDER_LAYER = 'postrender:layer';
Scene.EVENT_PRECULL = 'precull';
Scene.EVENT_POSTCULL = 'postcull';

class Skin {
		constructor(graphicsDevice, ibp, boneNames){
				this.device = graphicsDevice;
				this.inverseBindPose = ibp;
				this.boneNames = boneNames;
		}
}

var spriteNormals = [
		0,
		0,
		1,
		0,
		0,
		1,
		0,
		0,
		1,
		0,
		0,
		1
];
var spriteIndices = [
		0,
		1,
		3,
		2,
		3,
		1
];
class Sprite extends EventHandler {
		set frameKeys(value) {
				this._frameKeys = value;
				if (this._atlas && this._frameKeys) {
						if (this._updatingProperties) {
								this._meshesDirty = true;
						} else {
								this._createMeshes();
						}
				}
				this.fire('set:frameKeys', value);
		}
		get frameKeys() {
				return this._frameKeys;
		}
		set atlas(value) {
				if (value === this._atlas) return;
				if (this._atlas) {
						this._atlas.off('set:frames', this._onSetFrames, this);
						this._atlas.off('set:frame', this._onFrameChanged, this);
						this._atlas.off('remove:frame', this._onFrameRemoved, this);
				}
				this._atlas = value;
				if (this._atlas && this._frameKeys) {
						this._atlas.on('set:frames', this._onSetFrames, this);
						this._atlas.on('set:frame', this._onFrameChanged, this);
						this._atlas.on('remove:frame', this._onFrameRemoved, this);
						if (this._updatingProperties) {
								this._meshesDirty = true;
						} else {
								this._createMeshes();
						}
				}
				this.fire('set:atlas', value);
		}
		get atlas() {
				return this._atlas;
		}
		set pixelsPerUnit(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				this.fire('set:pixelsPerUnit', value);
				if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
						if (this._updatingProperties) {
								this._meshesDirty = true;
						} else {
								this._createMeshes();
						}
				}
		}
		get pixelsPerUnit() {
				return this._pixelsPerUnit;
		}
		set renderMode(value) {
				if (this._renderMode === value) {
						return;
				}
				var prev = this._renderMode;
				this._renderMode = value;
				this.fire('set:renderMode', value);
				if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
						if (this._atlas && this._frameKeys) {
								if (this._updatingProperties) {
										this._meshesDirty = true;
								} else {
										this._createMeshes();
								}
						}
				}
		}
		get renderMode() {
				return this._renderMode;
		}
		get meshes() {
				return this._meshes;
		}
		_createMeshes() {
				var len = this._meshes.length;
				for(var i = 0; i < len; i++){
						var mesh = this._meshes[i];
						if (mesh) {
								mesh.destroy();
						}
				}
				var count = this._frameKeys.length;
				this._meshes = new Array(count);
				var createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
				for(var i1 = 0; i1 < count; i1++){
						var frame = this._atlas.frames[this._frameKeys[i1]];
						this._meshes[i1] = frame ? createMeshFunc.call(this, frame) : null;
				}
				this.fire('set:meshes');
		}
		_createSimpleMesh(frame) {
				var rect = frame.rect;
				var texWidth = this._atlas.texture.width;
				var texHeight = this._atlas.texture.height;
				var w = rect.z / this._pixelsPerUnit;
				var h = rect.w / this._pixelsPerUnit;
				var hp = frame.pivot.x;
				var vp = frame.pivot.y;
				var positions = [
						-hp * w,
						-vp * h,
						0,
						(1 - hp) * w,
						-vp * h,
						0,
						(1 - hp) * w,
						(1 - vp) * h,
						0,
						-hp * w,
						(1 - vp) * h,
						0
				];
				var lu = rect.x / texWidth;
				var bv = 1.0 - rect.y / texHeight;
				var ru = (rect.x + rect.z) / texWidth;
				var tv = 1.0 - (rect.y + rect.w) / texHeight;
				var uvs = [
						lu,
						bv,
						ru,
						bv,
						ru,
						tv,
						lu,
						tv
				];
				var geom = new Geometry();
				geom.positions = positions;
				geom.normals = spriteNormals;
				geom.uvs = uvs;
				geom.indices = spriteIndices;
				return Mesh.fromGeometry(this._device, geom);
		}
		_create9SliceMesh() {
				var he = Vec2.ONE;
				var ws = 3;
				var ls = 3;
				var positions = [];
				var normals = [];
				var uvs = [];
				var indices = [];
				var vcounter = 0;
				for(var i = 0; i <= ws; i++){
						var u = i === 0 || i === ws ? 0 : 1;
						for(var j = 0; j <= ls; j++){
								var x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
								var y = 0.0;
								var z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
								var v = j === 0 || j === ls ? 0 : 1;
								positions.push(-x, y, z);
								normals.push(0.0, 1.0, 0.0);
								uvs.push(u, v);
								if (i < ws && j < ls) {
										indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
										indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
								}
								vcounter++;
						}
				}
				var geom = new Geometry();
				geom.positions = positions;
				geom.normals = normals;
				geom.uvs = uvs;
				geom.indices = indices;
				return Mesh.fromGeometry(this._device, geom);
		}
		_onSetFrames(frames) {
				if (this._updatingProperties) {
						this._meshesDirty = true;
				} else {
						this._createMeshes();
				}
		}
		_onFrameChanged(frameKey, frame) {
				var idx = this._frameKeys.indexOf(frameKey);
				if (idx < 0) return;
				if (frame) {
						if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
								this._meshes[idx] = this._createSimpleMesh(frame);
						}
				} else {
						this._meshes[idx] = null;
				}
				this.fire('set:meshes');
		}
		_onFrameRemoved(frameKey) {
				var idx = this._frameKeys.indexOf(frameKey);
				if (idx < 0) return;
				this._meshes[idx] = null;
				this.fire('set:meshes');
		}
		startUpdate() {
				this._updatingProperties = true;
				this._meshesDirty = false;
		}
		endUpdate() {
				this._updatingProperties = false;
				if (this._meshesDirty && this._atlas && this._frameKeys) {
						this._createMeshes();
				}
				this._meshesDirty = false;
		}
		destroy() {
				for (var mesh of this._meshes){
						if (mesh) {
								mesh.destroy();
						}
				}
				this._meshes.length = 0;
		}
		constructor(device, options){
				super();
				this._device = device;
				this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
				this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
				this._atlas = options && options.atlas !== undefined ? options.atlas : null;
				this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
				this._meshes = [];
				this._updatingProperties = false;
				this._meshesDirty = false;
				if (this._atlas && this._frameKeys) {
						this._createMeshes();
				}
		}
}

class TextureAtlas extends EventHandler {
		set texture(value) {
				this._texture = value;
				this.fire('set:texture', value);
		}
		get texture() {
				return this._texture;
		}
		set frames(value) {
				this._frames = value;
				this.fire('set:frames', value);
		}
		get frames() {
				return this._frames;
		}
		setFrame(key, data) {
				var frame = this._frames[key];
				if (!frame) {
						frame = {
								rect: data.rect.clone(),
								pivot: data.pivot.clone(),
								border: data.border.clone()
						};
						this._frames[key] = frame;
				} else {
						frame.rect.copy(data.rect);
						frame.pivot.copy(data.pivot);
						frame.border.copy(data.border);
				}
				this.fire('set:frame', key.toString(), frame);
		}
		removeFrame(key) {
				var frame = this._frames[key];
				if (frame) {
						delete this._frames[key];
						this.fire('remove:frame', key.toString(), frame);
				}
		}
		destroy() {
				if (this._texture) {
						this._texture.destroy();
				}
		}
		constructor(){
				super();
				this._texture = null;
				this._frames = null;
		}
}

class Key {
		constructor(time, position, rotation, scale){
				this.time = time;
				this.position = position;
				this.rotation = rotation;
				this.scale = scale;
		}
}
class Node {
		constructor(){
				this._name = '';
				this._keys = [];
		}
}
class Animation {
		getNode(name) {
				return this._nodeDict[name];
		}
		addNode(node) {
				this._nodes.push(node);
				this._nodeDict[node._name] = node;
		}
		get nodes() {
				return this._nodes;
		}
		constructor(){
				this.name = '';
				this.duration = 0;
				this._nodes = [];
				this._nodeDict = {};
		}
}

class InterpolatedKey {
		getTarget() {
				return this._targetNode;
		}
		setTarget(node) {
				this._targetNode = node;
		}
		constructor(){
				this._written = false;
				this._name = '';
				this._keyFrames = [];
				this._quat = new Quat();
				this._pos = new Vec3();
				this._scale = new Vec3();
				this._targetNode = null;
		}
}
class Skeleton {
		set animation(value) {
				this._animation = value;
				this.currentTime = 0;
		}
		get animation() {
				return this._animation;
		}
		set currentTime(value) {
				this._time = value;
				var numNodes = this._interpolatedKeys.length;
				for(var i = 0; i < numNodes; i++){
						var node = this._interpolatedKeys[i];
						var nodeName = node._name;
						this._currKeyIndices[nodeName] = 0;
				}
				this.addTime(0);
				this.updateGraph();
		}
		get currentTime() {
				return this._time;
		}
		get numNodes() {
				return this._interpolatedKeys.length;
		}
		addTime(delta) {
				if (this._animation !== null) {
						var nodes = this._animation._nodes;
						var duration = this._animation.duration;
						if (this._time === duration && !this.looping) {
								return;
						}
						this._time += delta;
						if (this._time > duration) {
								this._time = this.looping ? 0.0 : duration;
								for(var i = 0; i < nodes.length; i++){
										var node = nodes[i];
										var nodeName = node._name;
										this._currKeyIndices[nodeName] = 0;
								}
						} else if (this._time < 0) {
								this._time = this.looping ? duration : 0.0;
								for(var i1 = 0; i1 < nodes.length; i1++){
										var node1 = nodes[i1];
										var nodeName1 = node1._name;
										this._currKeyIndices[nodeName1] = node1._keys.length - 2;
								}
						}
						var offset = delta >= 0 ? 1 : -1;
						for(var i2 = 0; i2 < nodes.length; i2++){
								var node2 = nodes[i2];
								var nodeName2 = node2._name;
								var keys = node2._keys;
								var interpKey = this._interpolatedKeyDict[nodeName2];
								if (interpKey === undefined) {
										continue;
								}
								var foundKey = false;
								if (keys.length !== 1) {
										for(var currKeyIndex = this._currKeyIndices[nodeName2]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset){
												var k1 = keys[currKeyIndex];
												var k2 = keys[currKeyIndex + 1];
												if (k1.time <= this._time && k2.time >= this._time) {
														var alpha = (this._time - k1.time) / (k2.time - k1.time);
														interpKey._pos.lerp(k1.position, k2.position, alpha);
														interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
														interpKey._scale.lerp(k1.scale, k2.scale, alpha);
														interpKey._written = true;
														this._currKeyIndices[nodeName2] = currKeyIndex;
														foundKey = true;
														break;
												}
										}
								}
								if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
										interpKey._pos.copy(keys[0].position);
										interpKey._quat.copy(keys[0].rotation);
										interpKey._scale.copy(keys[0].scale);
										interpKey._written = true;
								}
						}
				}
		}
		blend(skel1, skel2, alpha) {
				var numNodes = this._interpolatedKeys.length;
				for(var i = 0; i < numNodes; i++){
						var key1 = skel1._interpolatedKeys[i];
						var key2 = skel2._interpolatedKeys[i];
						var dstKey = this._interpolatedKeys[i];
						if (key1._written && key2._written) {
								dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
								dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
								dstKey._scale.lerp(key1._scale, key2._scale, alpha);
								dstKey._written = true;
						} else if (key1._written) {
								dstKey._quat.copy(key1._quat);
								dstKey._pos.copy(key1._pos);
								dstKey._scale.copy(key1._scale);
								dstKey._written = true;
						} else if (key2._written) {
								dstKey._quat.copy(key2._quat);
								dstKey._pos.copy(key2._pos);
								dstKey._scale.copy(key2._scale);
								dstKey._written = true;
						}
				}
		}
		setGraph(graph) {
				this.graph = graph;
				if (graph) {
						for(var i = 0; i < this._interpolatedKeys.length; i++){
								var interpKey = this._interpolatedKeys[i];
								var graphNode = graph.findByName(interpKey._name);
								this._interpolatedKeys[i].setTarget(graphNode);
						}
				} else {
						for(var i1 = 0; i1 < this._interpolatedKeys.length; i1++){
								this._interpolatedKeys[i1].setTarget(null);
						}
				}
		}
		updateGraph() {
				if (this.graph) {
						for(var i = 0; i < this._interpolatedKeys.length; i++){
								var interpKey = this._interpolatedKeys[i];
								if (interpKey._written) {
										var transform = interpKey.getTarget();
										transform.localPosition.copy(interpKey._pos);
										transform.localRotation.copy(interpKey._quat);
										transform.localScale.copy(interpKey._scale);
										if (!transform._dirtyLocal) {
												transform._dirtifyLocal();
										}
										interpKey._written = false;
								}
						}
				}
		}
		constructor(graph){
				this.looping = true;
				this._animation = null;
				this._time = 0;
				this._interpolatedKeys = [];
				this._interpolatedKeyDict = {};
				this._currKeyIndices = {};
				this.graph = null;
				var addInterpolatedKeys = (node)=>{
						var interpKey = new InterpolatedKey();
						interpKey._name = node.name;
						this._interpolatedKeys.push(interpKey);
						this._interpolatedKeyDict[node.name] = interpKey;
						this._currKeyIndices[node.name] = 0;
						for(var i = 0; i < node._children.length; i++){
								addInterpolatedKeys(node._children[i]);
						}
				};
				addInterpolatedKeys(graph);
		}
}

var _viewport$1 = new Vec4();
class PostEffect {
		render(inputTarget, outputTarget, rect) {}
		drawQuad(target, shader, rect) {
				var viewport;
				if (rect) {
						var w = target ? target.width : this.device.width;
						var h = target ? target.height : this.device.height;
						viewport = _viewport$1.set(rect.x * w, rect.y * h, rect.z * w, rect.w * h);
				}
				this.device.setBlendState(BlendState.NOBLEND);
				drawQuadWithShader(this.device, target, shader, viewport);
		}
		constructor(graphicsDevice){
				this.device = graphicsDevice;
				this.needsDepthBuffer = false;
		}
}
PostEffect.quadVertexShader = "\n        attribute vec2 aPosition;\n        varying vec2 vUv0;\n        void main(void)\n        {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);\n        }\n    ";

class RenderPassShaderQuad extends RenderPass {
		set shader(shader) {
				var _this_quadRender;
				(_this_quadRender = this.quadRender) == null ? void 0 : _this_quadRender.destroy();
				this.quadRender = null;
				this._shader = shader;
				if (shader) {
						this.quadRender = new QuadRender(shader);
				}
		}
		get shader() {
				return this._shader;
		}
		createQuadShader(name, fs, shaderDefinitionOptions) {
				if (shaderDefinitionOptions === void 0) shaderDefinitionOptions = {};
				return createShaderFromCode(this.device, RenderPassShaderQuad.quadVertexShader, fs, name, {
						aPosition: SEMANTIC_POSITION
				}, shaderDefinitionOptions);
		}
		execute() {
				var device = this.device;
				device.setBlendState(this.blendState);
				device.setCullMode(this.cullMode);
				device.setDepthState(this.depthState);
				device.setStencilState(this.stencilFront, this.stencilBack);
				this.quadRender.render();
		}
		constructor(...args){
				super(...args), this._shader = null, this.quadRender = null, this.cullMode = CULLFACE_NONE, this.blendState = BlendState.NOBLEND, this.depthState = DepthState.NODEPTH, this.stencilFront = null, this.stencilBack = null;
		}
}
RenderPassShaderQuad.quadVertexShader = "\n        attribute vec2 aPosition;\n        varying vec2 uv0;\n        void main(void)\n        {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            uv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);\n        }\n    ";

class LitShaderOptions {
		constructor(){
				this.hasTangents = false;
				this.chunks = {};
				this.pass = 0;
				this.alphaTest = false;
				this.blendType = BLEND_NONE;
				this.separateAmbient = false;
				this.screenSpace = false;
				this.skin = false;
				this.batch = false;
				this.useInstancing = false;
				this.useMorphPosition = false;
				this.useMorphNormal = false;
				this.useMorphTextureBasedInt = false;
				this.nineSlicedMode = 0;
				this.clusteredLightingEnabled = true;
				this.clusteredLightingCookiesEnabled = false;
				this.clusteredLightingShadowsEnabled = false;
				this.clusteredLightingShadowType = 0;
				this.clusteredLightingAreaLightsEnabled = false;
				this.vertexColors = false;
				this.lightMapEnabled = false;
				this.dirLightMapEnabled = false;
				this.useHeights = false;
				this.useNormals = false;
				this.useClearCoatNormals = false;
				this.useAo = false;
				this.diffuseMapEnabled = false;
				this.customFragmentShader = null;
				this.pixelSnap = false;
				this.ambientSH = false;
				this.ssao = false;
				this.twoSidedLighting = false;
				this.occludeDirect = false;
				this.occludeSpecular = 0;
				this.occludeSpecularFloat = false;
				this.useMsdf = false;
				this.msdfTextAttribute = false;
				this.alphaToCoverage = false;
				this.opacityFadesSpecular = false;
				this.opacityDither = DITHER_NONE;
				this.opacityShadowDither = DITHER_NONE;
				this.cubeMapProjection = 0;
				this.useSpecular = false;
				this.useSpecularityFactor = false;
				this.enableGGXSpecular = false;
				this.fresnelModel = 0;
				this.useRefraction = false;
				this.useClearCoat = false;
				this.useSheen = false;
				this.useIridescence = false;
				this.useMetalness = false;
				this.useDynamicRefraction = false;
				this.dispersion = false;
				this.fog = FOG_NONE;
				this.gamma = GAMMA_NONE;
				this.toneMap = -1;
				this.reflectionSource = REFLECTIONSRC_NONE;
				this.reflectionEncoding = null;
				this.reflectionCubemapEncoding = null;
				this.ambientSource = 'constant';
				this.ambientEncoding = null;
				this.skyboxIntensity = 1.0;
				this.useCubeMapRotation = false;
				this.lightMapWithoutAmbient = false;
				this.lights = [];
				this.noShadow = false;
				this.lightMaskDynamic = 0x0;
				this.userAttributes = {};
				this.linearDepth = false;
				this.shadowCatcher = false;
		}
}

class LitMaterialOptions {
		constructor(){
				this.litOptions = new LitShaderOptions();
		}
}

class LitMaterialOptionsBuilder {
		static update(litOptions, material, scene, renderParams, objDefs, pass, sortedLights) {
				LitMaterialOptionsBuilder.updateSharedOptions(litOptions, material, scene, objDefs, pass);
				LitMaterialOptionsBuilder.updateMaterialOptions(litOptions, material);
				LitMaterialOptionsBuilder.updateEnvOptions(litOptions, material, scene, renderParams);
				LitMaterialOptionsBuilder.updateLightingOptions(litOptions, material, objDefs, sortedLights);
		}
		static updateSharedOptions(litOptions, material, scene, objDefs, pass) {
				litOptions.chunks = material.chunks;
				litOptions.pass = pass;
				litOptions.alphaTest = material.alphaTest > 0;
				litOptions.blendType = material.blendType;
				litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
				litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
				litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
				litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
				litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
				litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
				litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
				litOptions.nineSlicedMode = material.nineSlicedMode || SPRITE_RENDERMODE_SIMPLE;
				if (material.useLighting && scene.clusteredLightingEnabled) {
						litOptions.clusteredLightingEnabled = true;
						litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
						litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
						litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
						litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
				} else {
						litOptions.clusteredLightingEnabled = false;
						litOptions.clusteredLightingCookiesEnabled = false;
						litOptions.clusteredLightingShadowsEnabled = false;
						litOptions.clusteredLightingAreaLightsEnabled = false;
				}
		}
		static updateMaterialOptions(litOptions, material) {
				litOptions.separateAmbient = false;
				litOptions.customFragmentShader = null;
				litOptions.pixelSnap = material.pixelSnap;
				litOptions.ambientSH = material.ambientSH;
				litOptions.twoSidedLighting = material.twoSidedLighting;
				litOptions.occludeDirect = material.occludeDirect;
				litOptions.occludeSpecular = material.occludeSpecular;
				litOptions.occludeSpecularFloat = material.occludeSpecularIntensity !== 1.0;
				litOptions.useMsdf = false;
				litOptions.msdfTextAttribute = false;
				litOptions.alphaToCoverage = material.alphaToCoverage;
				litOptions.opacityFadesSpecular = material.opacityFadesSpecular;
				litOptions.opacityDither = material.opacityDither;
				litOptions.cubeMapProjection = CUBEPROJ_NONE;
				litOptions.useSpecular = material.hasSpecular;
				litOptions.useSpecularityFactor = material.hasSpecularityFactor;
				litOptions.enableGGXSpecular = material.ggxSpecular;
				litOptions.fresnelModel = material.fresnelModel;
				litOptions.useRefraction = material.hasRefraction;
				litOptions.useClearCoat = material.hasClearCoat;
				litOptions.useSheen = material.hasSheen;
				litOptions.useIridescence = material.hasIrridescence;
				litOptions.useMetalness = material.hasMetalness;
				litOptions.useDynamicRefraction = material.dynamicRefraction;
				litOptions.dispersion = material.dispersion > 0;
				litOptions.vertexColors = false;
				litOptions.lightMapEnabled = material.hasLighting;
				litOptions.dirLightMapEnabled = material.dirLightMap;
				litOptions.useHeights = material.hasHeights;
				litOptions.useNormals = material.hasNormals;
				litOptions.useClearCoatNormals = material.hasClearCoatNormals;
				litOptions.useAo = material.hasAo;
				litOptions.diffuseMapEnabled = material.hasDiffuseMap;
		}
		static updateEnvOptions(litOptions, material, scene, renderParams) {
				litOptions.fog = material.useFog ? renderParams.fog : FOG_NONE;
				litOptions.gamma = renderParams.shaderOutputGamma;
				litOptions.toneMap = material.useTonemap ? renderParams.toneMapping : TONEMAP_NONE;
				if (material.useSkybox && scene.envAtlas && scene.skybox) {
						litOptions.reflectionSource = REFLECTIONSRC_ENVATLASHQ;
						litOptions.reflectionEncoding = scene.envAtlas.encoding;
						litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
				} else if (material.useSkybox && scene.envAtlas) {
						litOptions.reflectionSource = REFLECTIONSRC_ENVATLAS;
						litOptions.reflectionEncoding = scene.envAtlas.encoding;
				} else if (material.useSkybox && scene.skybox) {
						litOptions.reflectionSource = REFLECTIONSRC_CUBEMAP;
						litOptions.reflectionEncoding = scene.skybox.encoding;
				} else {
						litOptions.reflectionSource = REFLECTIONSRC_NONE;
						litOptions.reflectionEncoding = null;
				}
				if (material.ambientSH) {
						litOptions.ambientSource = AMBIENTSRC_AMBIENTSH;
						litOptions.ambientEncoding = null;
				} else if (litOptions.reflectionSource !== REFLECTIONSRC_NONE && scene.envAtlas) {
						litOptions.ambientSource = AMBIENTSRC_ENVALATLAS;
						litOptions.ambientEncoding = scene.envAtlas.encoding;
				} else {
						litOptions.ambientSource = AMBIENTSRC_CONSTANT;
						litOptions.ambientEncoding = null;
				}
				var hasSkybox = litOptions.reflectionSource !== REFLECTIONSRC_NONE;
				litOptions.skyboxIntensity = hasSkybox;
				litOptions.useCubeMapRotation = hasSkybox && scene._skyboxRotationShaderInclude;
		}
		static updateLightingOptions(litOptions, material, objDefs, sortedLights) {
				litOptions.lightMapWithoutAmbient = false;
				if (material.useLighting) {
						var lightsFiltered = [];
						var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
						litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
						litOptions.lightMapWithoutAmbient = false;
						if (sortedLights) {
								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
						}
						litOptions.lights = lightsFiltered;
				} else {
						litOptions.lights = [];
				}
				if (litOptions.lights.length === 0 || (objDefs & SHADERDEF_NOSHADOW) !== 0) {
						litOptions.noShadow = true;
				}
		}
		static collectLights(lType, lights, lightsFiltered, mask) {
				for(var i = 0; i < lights.length; i++){
						var light = lights[i];
						if (light.enabled) {
								if (light.mask & mask) {
										lightsFiltered.push(light);
								}
						}
				}
		}
}

class ChunkBuilder {
		append() {
				for(var _len = arguments.length, chunks = new Array(_len), _key = 0; _key < _len; _key++){
						chunks[_key] = arguments[_key];
				}
				chunks.forEach((chunk)=>{
						if (chunk.endsWith('\n')) {
								this.code += chunk;
						} else {
								this.code += "" + chunk + "\n";
						}
				});
		}
		prepend() {
				for(var _len = arguments.length, chunks = new Array(_len), _key = 0; _key < _len; _key++){
						chunks[_key] = arguments[_key];
				}
				chunks.forEach((chunk)=>{
						if (chunk.endsWith('\n')) {
								this.code = chunk + this.code;
						} else {
								this.code = chunk + "\n" + this.code;
						}
				});
		}
		constructor(){
				this.code = '';
		}
}

var builtinAttributes = {
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
		vertex_boneIndices: SEMANTIC_BLENDINDICES
};
class LitShader {
		fDefineSet(condition, name, value) {
				if (value === void 0) value = '';
				if (condition) {
						this.fDefines.set(name, value);
				}
		}
		generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
				var { options, vDefines, attributes, chunks } = this;
				var varyings = new Map();
				varyings.set('vPositionW', 'vec3');
				if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
						vDefines.set('NINESLICED', true);
				}
				if (this.options.linearDepth) {
						vDefines.set('LINEAR_DEPTH', true);
						varyings.set('vLinearDepth', 'float');
				}
				if (this.needsNormal) vDefines.set('NORMALS', true);
				if (this.options.useInstancing) {
						if (this.chunks.transformInstancingVS === shaderChunks.transformInstancingVS) {
								attributes.instance_line1 = SEMANTIC_ATTR12;
								attributes.instance_line2 = SEMANTIC_ATTR13;
								attributes.instance_line3 = SEMANTIC_ATTR14;
								attributes.instance_line4 = SEMANTIC_ATTR15;
						}
				}
				if (this.needsNormal) {
						attributes.vertex_normal = SEMANTIC_NORMAL;
						varyings.set('vNormalW', 'vec3');
						if (options.hasTangents && (options.useHeights || options.useNormals || options.enableGGXSpecular)) {
								vDefines.set('TANGENTS', true);
								attributes.vertex_tangent = SEMANTIC_TANGENT;
								varyings.set('vTangentW', 'vec3');
								varyings.set('vBinormalW', 'vec3');
						} else if (options.enableGGXSpecular) {
								vDefines.set('GGX_SPECULAR', true);
								varyings.set('vObjectSpaceUpW', 'vec3');
						}
				}
				var maxUvSets = 2;
				for(var i = 0; i < maxUvSets; i++){
						if (useUv[i]) {
								vDefines.set("UV" + i, true);
								attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
						}
						if (useUnmodifiedUv[i]) {
								vDefines.set("UV" + i + "_UNMODIFIED", true);
								varyings.set("vUv" + i, 'vec2');
						}
				}
				var numTransforms = 0;
				var transformDone = new Set();
				mapTransforms.forEach((mapTransform)=>{
						var { id, uv, name } = mapTransform;
						var checkId = id + uv * 100;
						if (!transformDone.has(checkId)) {
								transformDone.add(checkId);
								varyings.set("vUV" + uv + "_" + id, 'vec2');
								var varName = "texture_" + name + "MapTransform";
								vDefines.set("{TRANSFORM_NAME_" + numTransforms + "}", varName);
								vDefines.set("{TRANSFORM_UV_" + numTransforms + "}", uv);
								vDefines.set("{TRANSFORM_ID_" + numTransforms + "}", id);
								numTransforms++;
						}
				});
				vDefines.set('UV_TRANSFORMS_COUNT', numTransforms);
				if (options.vertexColors) {
						attributes.vertex_color = SEMANTIC_COLOR;
						vDefines.set('VERTEX_COLOR', true);
						varyings.set('vVertexColor', 'vec4');
				}
				if (options.useMsdf && options.msdfTextAttribute) {
						attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
						attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
						vDefines.set('MSDF', true);
				}
				if (options.useMorphPosition || options.useMorphNormal) {
						vDefines.set('MORPHING', true);
						if (options.useMorphTextureBasedInt) vDefines.set('MORPHING_INT', true);
						if (options.useMorphPosition) vDefines.set('MORPHING_POSITION', true);
						if (options.useMorphNormal) vDefines.set('MORPHING_NORMAL', true);
						attributes.morph_vertex_id = SEMANTIC_ATTR15;
				}
				if (options.skin) {
						attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
						if (options.batch) {
								vDefines.set('BATCH', true);
						} else {
								attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
								vDefines.set('SKIN', true);
						}
				}
				if (options.useInstancing) vDefines.set('INSTANCING', true);
				if (options.screenSpace) vDefines.set('SCREENSPACE', true);
				if (options.pixelSnap) vDefines.set('PIXELSNAP', true);
				varyings.forEach((type, name)=>{
						vDefines.set("VARYING_" + name.toUpperCase(), true);
						this.varyingsCode += "varying " + type + " " + name + ";\n";
				});
				this.vshader = this.varyingsCode + chunks.litMainVS;
		}
		_setupLightingDefines(hasAreaLights, clusteredLightingEnabled) {
				var fDefines = this.fDefines;
				var options = this.options;
				this.fDefines.set('LIGHT_COUNT', options.lights.length);
				if (hasAreaLights) fDefines.set('AREA_LIGHTS', true);
				if (clusteredLightingEnabled && this.lighting) {
						fDefines.set('LIT_CLUSTERED_LIGHTS', true);
						if (options.clusteredLightingCookiesEnabled) fDefines.set('CLUSTER_COOKIES', true);
						if (options.clusteredLightingAreaLightsEnabled) fDefines.set('CLUSTER_AREALIGHTS', true);
						if (options.lightMaskDynamic) fDefines.set('CLUSTER_MESH_DYNAMIC_LIGHTS', true);
						if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
								var clusteredShadowInfo = shadowTypeInfo.get(options.clusteredLightingShadowType);
								fDefines.set('CLUSTER_SHADOWS', true);
								fDefines.set("SHADOW_KIND_" + clusteredShadowInfo.kind, true);
								fDefines.set("CLUSTER_SHADOW_TYPE_" + clusteredShadowInfo.kind, true);
						}
				}
				for(var i = 0; i < options.lights.length; i++){
						var light = options.lights[i];
						var lightType = light._type;
						if (clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
								continue;
						}
						var lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
						var shadowType = light._shadowType;
						var castShadow = light.castShadows && !options.noShadow;
						var shadowInfo = shadowTypeInfo.get(shadowType);
						fDefines.set("LIGHT" + i, true);
						fDefines.set("LIGHT" + i + "TYPE", "" + lightTypeNames[lightType]);
						fDefines.set("LIGHT" + i + "SHADOWTYPE", "" + shadowInfo.name);
						fDefines.set("LIGHT" + i + "SHAPE", "" + lightShapeNames[lightShape]);
						fDefines.set("LIGHT" + i + "FALLOFF", "" + lightFalloffNames[light._falloffMode]);
						if (light.affectSpecularity) fDefines.set("LIGHT" + i + "AFFECT_SPECULARITY", true);
						if (light._cookie) {
								if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap || lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
										fDefines.set("LIGHT" + i + "COOKIE", true);
										fDefines.set("{LIGHT" + i + "COOKIE_CHANNEL}", light._cookieChannel);
										if (lightType === LIGHTTYPE_SPOT) {
												if (light._cookieTransform) fDefines.set("LIGHT" + i + "COOKIE_TRANSFORM", true);
												if (light._cookieFalloff) fDefines.set("LIGHT" + i + "COOKIE_FALLOFF", true);
										}
								}
						}
						if (castShadow) {
								fDefines.set("LIGHT" + i + "CASTSHADOW", true);
								if (shadowInfo.pcf) fDefines.set("LIGHT" + i + "SHADOW_PCF", true);
								if (light._normalOffsetBias && !light._isVsm) fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_NORMAL_OFFSET", true);
								if (lightType === LIGHTTYPE_DIRECTIONAL) {
										fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_ORTHO", true);
										if (light.cascadeBlend > 0) fDefines.set("LIGHT" + i + "_SHADOW_CASCADE_BLEND", true);
										if (light.numCascades > 1) fDefines.set("LIGHT" + i + "_SHADOW_CASCADES", true);
								}
								if (shadowInfo.pcf || shadowInfo.pcss || this.device.isWebGPU) fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_SOURCE_ZBUFFER", true);
								if (lightType === LIGHTTYPE_OMNI) fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_POINT", true);
						}
						if (castShadow) {
								fDefines.set("SHADOW_KIND_" + shadowInfo.kind, true);
								if (lightType === LIGHTTYPE_DIRECTIONAL) fDefines.set('SHADOW_DIRECTIONAL', true);
						}
				}
		}
		prepareForwardPass(lightingUv) {
				var { options } = this;
				var clusteredAreaLights = options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled;
				var hasAreaLights = clusteredAreaLights || options.lights.some((light)=>{
						return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
				});
				var addAmbient = !options.lightMapEnabled || options.lightMapWithoutAmbient;
				var hasTBN = this.needsNormal && (options.useNormals || options.useClearCoatNormals || options.enableGGXSpecular && !options.useHeights);
				if (options.useSpecular) {
						this.fDefineSet(true, 'LIT_SPECULAR');
						this.fDefineSet(this.reflections, 'LIT_REFLECTIONS');
						this.fDefineSet(options.useClearCoat, 'LIT_CLEARCOAT');
						this.fDefineSet(options.fresnelModel > 0, 'LIT_SPECULAR_FRESNEL');
						this.fDefineSet(options.useSheen, 'LIT_SHEEN');
						this.fDefineSet(options.useIridescence, 'LIT_IRIDESCENCE');
				}
				this.fDefineSet(this.needsNormal, 'LIT_NEEDS_NORMAL');
				this.fDefineSet(this.lighting, 'LIT_LIGHTING');
				this.fDefineSet(options.useMetalness, 'LIT_METALNESS');
				this.fDefineSet(options.enableGGXSpecular, 'LIT_GGX_SPECULAR');
				this.fDefineSet(options.useSpecularityFactor, 'LIT_SPECULARITY_FACTOR');
				this.fDefineSet(options.useCubeMapRotation, 'CUBEMAP_ROTATION');
				this.fDefineSet(options.occludeSpecularFloat, 'LIT_OCCLUDE_SPECULAR_FLOAT');
				this.fDefineSet(options.separateAmbient, 'LIT_SEPARATE_AMBIENT');
				this.fDefineSet(options.twoSidedLighting, 'LIT_TWO_SIDED_LIGHTING');
				this.fDefineSet(options.lightMapEnabled, 'LIT_LIGHTMAP');
				this.fDefineSet(options.dirLightMapEnabled, 'LIT_DIR_LIGHTMAP');
				this.fDefineSet(options.skyboxIntensity > 0, 'LIT_SKYBOX_INTENSITY');
				this.fDefineSet(options.clusteredLightingShadowsEnabled, 'LIT_CLUSTERED_SHADOWS');
				this.fDefineSet(options.clusteredLightingAreaLightsEnabled, 'LIT_CLUSTERED_AREA_LIGHTS');
				this.fDefineSet(hasTBN, 'LIT_TBN');
				this.fDefineSet(addAmbient, 'LIT_ADD_AMBIENT');
				this.fDefineSet(options.hasTangents, 'LIT_TANGENTS');
				this.fDefineSet(options.useNormals, 'LIT_USE_NORMALS');
				this.fDefineSet(options.useClearCoatNormals, 'LIT_USE_CLEARCOAT_NORMALS');
				this.fDefineSet(options.useRefraction, 'LIT_REFRACTION');
				this.fDefineSet(options.useDynamicRefraction, 'LIT_DYNAMIC_REFRACTION');
				this.fDefineSet(options.dispersion, 'LIT_DISPERSION');
				this.fDefineSet(options.useHeights, 'LIT_HEIGHTS');
				this.fDefineSet(options.opacityFadesSpecular, 'LIT_OPACITY_FADES_SPECULAR');
				this.fDefineSet(options.alphaToCoverage, 'LIT_ALPHA_TO_COVERAGE');
				this.fDefineSet(options.useMsdf, 'LIT_MSDF');
				this.fDefineSet(options.ssao, 'LIT_SSAO');
				this.fDefineSet(options.useAo, 'LIT_AO');
				this.fDefineSet(options.occludeDirect, 'LIT_OCCLUDE_DIRECT');
				this.fDefineSet(options.msdfTextAttribute, 'LIT_MSDF_TEXT_ATTRIBUTE');
				this.fDefineSet(options.diffuseMapEnabled, 'LIT_DIFFUSE_MAP');
				this.fDefineSet(options.shadowCatcher, 'LIT_SHADOW_CATCHER');
				this.fDefineSet(true, 'LIT_FRESNEL_MODEL', fresnelNames[options.fresnelModel]);
				this.fDefineSet(true, 'LIT_NONE_SLICE_MODE', spriteRenderModeNames[options.nineSlicedMode]);
				this.fDefineSet(true, 'LIT_BLEND_TYPE', blendNames[options.blendType]);
				this.fDefineSet(true, 'LIT_CUBEMAP_PROJECTION', cubemaProjectionNames[options.cubeMapProjection]);
				this.fDefineSet(true, 'LIT_OCCLUDE_SPECULAR', specularOcclusionNames[options.occludeSpecular]);
				this.fDefineSet(true, 'LIT_REFLECTION_SOURCE', reflectionSrcNames[options.reflectionSource]);
				this.fDefineSet(true, 'LIT_AMBIENT_SOURCE', ambientSrcNames[options.ambientSource]);
				this.fDefineSet(true, '{lightingUv}', lightingUv != null ? lightingUv : '');
				this.fDefineSet(true, '{reflectionDecode}', ChunkUtils.decodeFunc(options.reflectionEncoding));
				this.fDefineSet(true, '{reflectionCubemapDecode}', ChunkUtils.decodeFunc(options.reflectionCubemapEncoding));
				this.fDefineSet(true, '{ambientDecode}', ChunkUtils.decodeFunc(options.ambientEncoding));
				this._setupLightingDefines(hasAreaLights, options.clusteredLightingEnabled);
		}
		prepareShadowPass() {
				var lightType = this.shaderPassInfo.lightType;
				var shadowType = this.shaderPassInfo.shadowType;
				var shadowInfo = shadowTypeInfo.get(shadowType);
				var usePerspectiveDepth = lightType === LIGHTTYPE_DIRECTIONAL || !shadowInfo.vsm && lightType === LIGHTTYPE_SPOT;
				this.fDefineSet(usePerspectiveDepth, 'PERSPECTIVE_DEPTH');
				this.fDefineSet(true, 'LIGHT_TYPE', "" + lightTypeNames[lightType]);
				this.fDefineSet(true, 'SHADOW_TYPE', "" + shadowInfo.name);
		}
		generateFragmentShader(frontendDecl, frontendCode, lightingUv) {
				var options = this.options;
				if (options.pass === SHADER_PICK || options.pass === SHADER_DEPTH || options.pass === SHADER_PREPASS) {
						this.fshader = "\n\n                " + this.varyingsCode + "\n                " + frontendDecl + "\n                " + frontendCode + '\n                #include "litOtherMainPS"\n            ';
				} else if (this.shadowPass) {
						this.prepareShadowPass();
						this.fshader = "\n                " + this.varyingsCode + "\n                " + frontendDecl + "\n                " + frontendCode + '\n                #include "litShadowMainPS"\n            ';
				} else if (options.customFragmentShader) {
						this.fshader = "\n                " + options.customFragmentShader + "\n            ";
				} else {
						this.prepareForwardPass(lightingUv);
						this.fshader = "\n                " + this.varyingsCode + "\n                " + frontendDecl + '\n                #include "litForwardDeclarationPS"\n                #include "litForwardPreCodePS"\n                ' + frontendCode + '\n                #include "litForwardPostCodePS"\n                #include "litForwardBackendPS"\n                #include "litForwardMainPS"\n            ';
				}
		}
		constructor(device, options){
				this.varyingsCode = '';
				this.device = device;
				this.options = options;
				this.attributes = {
						vertex_position: SEMANTIC_POSITION
				};
				if (options.userAttributes) {
						for (var [semantic, name] of Object.entries(options.userAttributes)){
								this.attributes[name] = semantic;
						}
				}
				if (options.chunks) {
						var userChunks = options.chunks;
						this.chunks = Object.create(shaderChunks);
						for(var chunkName in shaderChunks){
								if (userChunks.hasOwnProperty(chunkName)) {
										var chunk = userChunks[chunkName];
										for(var a in builtinAttributes){
												if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
														this.attributes[a] = builtinAttributes[a];
												}
										}
										this.chunks[chunkName] = chunk;
								}
						}
				} else {
						this.chunks = shaderChunks;
				}
				this.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options.pass);
				this.shadowPass = this.shaderPassInfo.isShadow;
				this.lighting = options.lights.length > 0 || options.dirLightMapEnabled || options.clusteredLightingEnabled;
				this.reflections = options.reflectionSource !== REFLECTIONSRC_NONE;
				this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.useHeights || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.useClearCoatNormals;
				this.needsNormal = this.needsNormal && !this.shadowPass;
				this.needsSceneColor = options.useDynamicRefraction;
				this.needsScreenSize = options.useDynamicRefraction;
				this.needsTransforms = options.useDynamicRefraction;
				this.vshader = null;
				this.vDefines = new Map();
				this.fDefines = new Map();
				this.fshader = null;
		}
}

var LitOptionsUtils = {
		generateKey (options) {
				return "lit" + Object.keys(options).sort().map((key)=>{
						if (key === 'chunks') {
								return LitOptionsUtils.generateChunksKey(options);
						} else if (key === 'lights') {
								return LitOptionsUtils.generateLightsKey(options);
						}
						return key + options[key];
				}).join('\n');
		},
		generateLightsKey (options) {
				return "lights:" + options.lights.map((light)=>{
						return !options.clusteredLightingEnabled || light._type === LIGHTTYPE_DIRECTIONAL ? "" + light.key + "," : '';
				}).join('');
		},
		generateChunksKey (options) {
				var _options_chunks;
				return "chunks:\n" + Object.keys((_options_chunks = options.chunks) != null ? _options_chunks : {}).sort().map((key)=>key + options.chunks[key]).join('');
		}
};

function _extends$e() {
		_extends$e = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$e.apply(this, arguments);
}
var dummyUvs = [
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7
];
class ShaderGeneratorLit extends ShaderGenerator {
		generateKey(options) {
				var definesHash = ShaderGenerator.definesHash(options.defines);
				var key = "lit_" + definesHash + "_" + dummyUvs.map((dummy, index)=>{
						return options.usedUvs[index] ? '1' : '0';
				}).join('') + options.shaderChunk + LitOptionsUtils.generateKey(options.litOptions);
				return key;
		}
		createShaderDefinition(device, options) {
				var litShader = new LitShader(device, options.litOptions);
				var decl = new ChunkBuilder();
				var code = new ChunkBuilder();
				decl.append('uniform float textureBias;');
				decl.append(litShader.chunks.litShaderArgsPS);
				code.append(options.shaderChunk);
				var definitionOptions = {
						name: 'LitShader',
						shaderLanguage: SHADERLANGUAGE_GLSL,
						tag: litShader.shaderPassInfo.isForward ? SHADERTAG_MATERIAL : undefined
				};
				var usedUvSets = options.usedUvs || [
						true
				];
				var mapTransforms = [];
				litShader.generateVertexShader(usedUvSets, usedUvSets, mapTransforms);
				litShader.generateFragmentShader(decl.code, code.code, 'vUv0');
				var includes = new Map(Object.entries(_extends$e({}, Object.getPrototypeOf(litShader.chunks), litShader.chunks, options.litOptions.chunks)));
				var vDefines = litShader.vDefines;
				options.defines.forEach((value, key)=>vDefines.set(key, value));
				var fDefines = litShader.fDefines;
				options.defines.forEach((value, key)=>fDefines.set(key, value));
				definitionOptions.attributes = litShader.attributes;
				definitionOptions.vertexCode = litShader.vshader;
				definitionOptions.vertexIncludes = includes;
				definitionOptions.vertexDefines = vDefines;
				definitionOptions.fragmentCode = litShader.fshader;
				definitionOptions.fragmentIncludes = includes;
				definitionOptions.fragmentDefines = fDefines;
				return ShaderUtils.createDefinition(device, definitionOptions);
		}
}
var lit = new ShaderGeneratorLit();

var options = new LitMaterialOptions();
class LitMaterial extends Material {
		getShaderVariant(params) {
				options.usedUvs = this.usedUvs.slice();
				options.shaderChunk = this.shaderChunk;
				options.defines = getCoreDefines(this, params);
				LitMaterialOptionsBuilder.update(options.litOptions, this, params.scene, params.cameraShaderParams, params.objDefs, params.pass, params.sortedLights);
				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
				var library = getProgramLibrary(params.device);
				library.register('lit', lit);
				var shader = library.getProgram('lit', options, processingOptions, this.userId);
				return shader;
		}
		constructor(...args){
				super(...args), this.usedUvs = [
						true
				], this.shaderChunk = 'void evaluateFrontend() {}\n', this.useLighting = true, this.useFog = true, this.useTonemap = true, this.useSkybox = true, this.ambientSH = null, this.pixelSnap = false, this.nineSlicedMode = null, this.twoSidedLighting = false, this.occludeDirect = false, this.occludeSpecular = SPECOCC_AO, this.occludeSpecularIntensity = 1, this.opacityFadesSpecular = true, this.opacityDither = DITHER_NONE, this.opacityShadowDither = DITHER_NONE, this.shadowCatcher = false, this.ggxSpecular = false, this.fresnelModel = FRESNEL_SCHLICK, this.dynamicRefraction = false, this.hasAo = false, this.hasSpecular = false, this.hasSpecularityFactor = false, this.hasLighting = false, this.hasHeights = false, this.hasNormals = false, this.hasSheen = false, this.hasRefraction = false, this.hasIrridescence = false, this.hasMetalness = false, this.hasClearCoat = false, this.hasClearCoatNormals = false;
		}
}

class StandardMaterialOptions {
		get pass() {
				return this.litOptions.pass;
		}
		constructor(){
				this.defines = new Map();
				this.forceUv1 = false;
				this.specularTint = false;
				this.metalnessTint = false;
				this.glossTint = false;
				this.emissiveEncoding = 'linear';
				this.lightMapEncoding = 'linear';
				this.packedNormal = false;
				this.glossInvert = false;
				this.sheenGlossInvert = false;
				this.clearCoatGlossInvert = false;
				this.useAO = false;
				this.litOptions = new LitShaderOptions();
		}
}

function _extends$d() {
		_extends$d = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$d.apply(this, arguments);
}
var _matTex2D = [];
var buildPropertiesList = (options)=>{
		return Object.keys(options).filter((key)=>key !== 'litOptions').sort();
};
class ShaderGeneratorStandard extends ShaderGenerator {
		generateKey(options) {
				var props;
				if (options === this.optionsContextMin) {
						if (!this.propsMin) this.propsMin = buildPropertiesList(options);
						props = this.propsMin;
				} else if (options === this.optionsContext) {
						if (!this.props) this.props = buildPropertiesList(options);
						props = this.props;
				} else {
						props = buildPropertiesList(options);
				}
				var definesHash = ShaderGenerator.definesHash(options.defines);
				var key = "standard:\n" + definesHash + "\n" + props.map((prop)=>prop + options[prop]).join('\n') + LitOptionsUtils.generateKey(options.litOptions);
				return key;
		}
		_getUvSourceExpression(transformPropName, uVPropName, options) {
				var transformId = options[transformPropName];
				var uvChannel = options[uVPropName];
				var isMainPass = options.litOptions.pass === SHADER_FORWARD;
				var expression;
				if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
						expression = 'nineSlicedUv';
				} else if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
						expression = 'nineSlicedUv';
				} else {
						if (transformId === 0) {
								expression = "vUv" + uvChannel;
						} else {
								expression = "vUV" + uvChannel + "_" + transformId;
						}
						if (options.heightMap && transformPropName !== 'heightMapTransform') {
								expression += ' + dUvOffset';
						}
				}
				return expression;
		}
		_addMapDef(name, enabled) {
				return enabled ? "#define " + name + "\n" : "#undef " + name + "\n";
		}
		_addMapDefs(float, color, vertex, map, invert) {
				return this._addMapDef('MAPFLOAT', float) + this._addMapDef('MAPCOLOR', color) + this._addMapDef('MAPVERTEX', vertex) + this._addMapDef('MAPTEXTURE', map) + this._addMapDef('MAPINVERT', invert);
		}
		_addMap(propName, chunkName, options, chunks, mapping, encoding) {
				if (encoding === void 0) encoding = null;
				var mapPropName = "" + propName + "Map";
				var uVPropName = "" + mapPropName + "Uv";
				var identifierPropName = "" + mapPropName + "Identifier";
				var transformPropName = "" + mapPropName + "Transform";
				var channelPropName = "" + mapPropName + "Channel";
				var vertexColorChannelPropName = "" + propName + "VertexColorChannel";
				var tintPropName = "" + propName + "Tint";
				var vertexColorPropName = "" + propName + "VertexColor";
				var detailModePropName = "" + propName + "Mode";
				var invertName = "" + propName + "Invert";
				var tintOption = options[tintPropName];
				var vertexColorOption = options[vertexColorPropName];
				var textureOption = options[mapPropName];
				var textureIdentifier = options[identifierPropName];
				var detailModeOption = options[detailModePropName];
				var subCode = chunks[chunkName];
				if (textureOption) {
						var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);
						subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);
						if (mapping && subCode.search(/\$SAMPLER/g) !== -1) {
								var samplerName = "texture_" + mapPropName;
								var alias = mapping[textureIdentifier];
								if (alias) {
										samplerName = alias;
								} else {
										mapping[textureIdentifier] = samplerName;
								}
								subCode = subCode.replace(/\$SAMPLER/g, samplerName);
						}
						if (encoding) {
								if (options[channelPropName] === 'aaa') {
										subCode = subCode.replace(/\$DECODE/g, 'passThrough');
								} else {
										subCode = subCode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(encoding));
								}
								if (subCode.indexOf('$texture2DSAMPLE')) {
										var decodeTable = {
												linear: 'texture2D',
												srgb: 'texture2DSRGB',
												rgbm: 'texture2DRGBM',
												rgbe: 'texture2DRGBE'
										};
										subCode = subCode.replace(/\$texture2DSAMPLE/g, decodeTable[encoding] || 'texture2D');
								}
						}
				}
				if (vertexColorOption) {
						subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
				}
				if (detailModeOption) {
						subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
				}
				var isFloatTint = !!(tintOption & 1);
				var isVecTint = !!(tintOption & 2);
				var invertOption = !!options[invertName];
				subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption, invertOption) + subCode;
				return subCode.replace(/\$/g, '');
		}
		_correctChannel(p, chan, _matTex2D) {
				if (_matTex2D[p] > 0) {
						if (_matTex2D[p] < chan.length) {
								return chan.substring(0, _matTex2D[p]);
						} else if (_matTex2D[p] > chan.length) {
								var str = chan;
								var chr = str.charAt(str.length - 1);
								var addLen = _matTex2D[p] - str.length;
								for(var i = 0; i < addLen; i++)str += chr;
								return str;
						}
						return chan;
				}
		}
		createVertexShader(litShader, options) {
				var useUv = [];
				var useUnmodifiedUv = [];
				var mapTransforms = [];
				var maxUvSets = 2;
				for(var p in _matTex2D){
						var mapName = "" + p + "Map";
						if (options["" + p + "VertexColor"]) {
								var colorChannelName = "" + p + "VertexColorChannel";
								options[colorChannelName] = this._correctChannel(p, options[colorChannelName], _matTex2D);
						}
						if (options[mapName]) {
								var channelName = "" + mapName + "Channel";
								var transformName = "" + mapName + "Transform";
								var uvName = "" + mapName + "Uv";
								options[uvName] = Math.min(options[uvName], maxUvSets - 1);
								options[channelName] = this._correctChannel(p, options[channelName], _matTex2D);
								var uvSet = options[uvName];
								useUv[uvSet] = true;
								useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mapName] && !options[transformName];
								if (options[transformName]) {
										mapTransforms.push({
												name: p,
												id: options[transformName],
												uv: options[uvName]
										});
								}
						}
				}
				if (options.forceUv1) {
						useUv[1] = true;
						useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
				}
				litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);
		}
		createShaderDefinition(device, options) {
				var shaderPassInfo = ShaderPass.get(device).getByIndex(options.litOptions.pass);
				var isForwardPass = shaderPassInfo.isForward;
				var litShader = new LitShader(device, options.litOptions);
				this.createVertexShader(litShader, options);
				var textureMapping = {};
				options.litOptions.fresnelModel = options.litOptions.fresnelModel === 0 ? FRESNEL_SCHLICK : options.litOptions.fresnelModel;
				var decl = new ChunkBuilder();
				var code = new ChunkBuilder();
				var func = new ChunkBuilder();
				var args = new ChunkBuilder();
				var lightingUv = '';
				if (options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
						decl.append('const float textureBias = -1000.0;');
				} else {
						decl.append('uniform float textureBias;');
				}
				if (isForwardPass) {
						if (options.heightMap) {
								decl.append('vec2 dUvOffset;');
								code.append(this._addMap('height', 'parallaxPS', options, litShader.chunks, textureMapping));
								func.append('getParallax();');
						}
						if (options.litOptions.blendType !== BLEND_NONE || options.litOptions.alphaTest || options.litOptions.alphaToCoverage || options.litOptions.opacityDither !== DITHER_NONE) {
								decl.append('float dAlpha;');
								code.append(this._addMap('opacity', 'opacityPS', options, litShader.chunks, textureMapping));
								func.append('getOpacity();');
								args.append('litArgs_opacity = dAlpha;');
								if (options.litOptions.alphaTest) {
										code.append(litShader.chunks.alphaTestPS);
										func.append('alphaTest(dAlpha);');
								}
								var opacityDither = options.litOptions.opacityDither;
								if (opacityDither !== DITHER_NONE) {
										if (opacityDither === DITHER_BAYER8) {
												decl.append(litShader.chunks.bayerPS);
										}
										decl.append("#define DITHER_" + opacityDither.toUpperCase() + "\n");
										decl.append(litShader.chunks.opacityDitherPS);
										func.append('opacityDither(dAlpha, 0.0);');
								}
						} else {
								decl.append('float dAlpha = 1.0;');
						}
						if (litShader.needsNormal) {
								if (options.normalMap || options.clearCoatNormalMap) {
										code.append(options.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);
										if (!options.litOptions.hasTangents) {
												var baseName = options.normalMap ? 'normalMap' : 'clearCoatNormalMap';
												lightingUv = this._getUvSourceExpression("" + baseName + "Transform", "" + baseName + "Uv", options);
										}
								}
								decl.append('vec3 dNormalW;');
								code.append(this._addMap('normalDetail', 'normalDetailMapPS', options, litShader.chunks, textureMapping));
								code.append(this._addMap('normal', 'normalMapPS', options, litShader.chunks, textureMapping));
								func.append('getNormal();');
								args.append('litArgs_worldNormal = dNormalW;');
						}
						if (litShader.needsSceneColor) {
								decl.append('uniform sampler2D uSceneColorMap;');
						}
						if (litShader.needsScreenSize) {
								decl.append('uniform vec4 uScreenSize;');
						}
						if (litShader.needsTransforms) {
								decl.append('uniform mat4 matrix_viewProjection;');
								decl.append('uniform mat4 matrix_model;');
						}
						if (options.diffuseDetail || options.aoDetail) {
								code.append(litShader.chunks.detailModesPS);
						}
						decl.append('vec3 dAlbedo;');
						if (options.diffuseDetail) {
								code.append(this._addMap('diffuseDetail', 'diffuseDetailMapPS', options, litShader.chunks, textureMapping, options.diffuseDetailEncoding));
						}
						code.append(this._addMap('diffuse', 'diffusePS', options, litShader.chunks, textureMapping, options.diffuseEncoding));
						func.append('getAlbedo();');
						args.append('litArgs_albedo = dAlbedo;');
						if (options.litOptions.useRefraction) {
								decl.append('float dTransmission;');
								code.append(this._addMap('refraction', 'transmissionPS', options, litShader.chunks, textureMapping));
								func.append('getRefraction();');
								args.append('litArgs_transmission = dTransmission;');
								decl.append('float dThickness;');
								code.append(this._addMap('thickness', 'thicknessPS', options, litShader.chunks, textureMapping));
								func.append('getThickness();');
								args.append('litArgs_thickness = dThickness;');
								if (options.litOptions.dispersion) {
										args.append('litArgs_dispersion = material_dispersion;');
								}
						}
						if (options.litOptions.useIridescence) {
								decl.append('float dIridescence;');
								code.append(this._addMap('iridescence', 'iridescencePS', options, litShader.chunks, textureMapping));
								func.append('getIridescence();');
								args.append('litArgs_iridescence_intensity = dIridescence;');
								decl.append('float dIridescenceThickness;');
								code.append(this._addMap('iridescenceThickness', 'iridescenceThicknessPS', options, litShader.chunks, textureMapping));
								func.append('getIridescenceThickness();');
								args.append('litArgs_iridescence_thickness = dIridescenceThickness;');
						}
						if (litShader.lighting && options.litOptions.useSpecular || litShader.reflections) {
								decl.append('vec3 dSpecularity;');
								decl.append('float dGlossiness;');
								if (options.litOptions.useSheen) {
										decl.append('vec3 sSpecularity;');
										code.append(this._addMap('sheen', 'sheenPS', options, litShader.chunks, textureMapping, options.sheenEncoding));
										func.append('getSheen();');
										args.append('litArgs_sheen_specularity = sSpecularity;');
										decl.append('float sGlossiness;');
										code.append(this._addMap('sheenGloss', 'sheenGlossPS', options, litShader.chunks, textureMapping));
										func.append('getSheenGlossiness();');
										args.append('litArgs_sheen_gloss = sGlossiness;');
								}
								if (options.litOptions.useMetalness) {
										decl.append('float dMetalness;');
										code.append(this._addMap('metalness', 'metalnessPS', options, litShader.chunks, textureMapping));
										func.append('getMetalness();');
										args.append('litArgs_metalness = dMetalness;');
										decl.append('float dIor;');
										code.append(this._addMap('ior', 'iorPS', options, litShader.chunks, textureMapping));
										func.append('getIor();');
										args.append('litArgs_ior = dIor;');
								}
								if (options.litOptions.useSpecularityFactor) {
										decl.append('float dSpecularityFactor;');
										code.append(this._addMap('specularityFactor', 'specularityFactorPS', options, litShader.chunks, textureMapping));
										func.append('getSpecularityFactor();');
										args.append('litArgs_specularityFactor = dSpecularityFactor;');
								}
								if (options.useSpecularColor) {
										code.append(this._addMap('specular', 'specularPS', options, litShader.chunks, textureMapping, options.specularEncoding));
								} else {
										code.append('void getSpecularity() { dSpecularity = vec3(1); }');
								}
								code.append(this._addMap('gloss', 'glossPS', options, litShader.chunks, textureMapping));
								func.append('getGlossiness();');
								func.append('getSpecularity();');
								args.append('litArgs_specularity = dSpecularity;');
								args.append('litArgs_gloss = dGlossiness;');
						} else {
								decl.append('vec3 dSpecularity = vec3(0.0);');
								decl.append('float dGlossiness = 0.0;');
						}
						if (options.aoDetail) {
								code.append(this._addMap('aoDetail', 'aoDetailMapPS', options, litShader.chunks, textureMapping));
						}
						if (options.aoMap || options.aoVertexColor || options.useAO) {
								decl.append('float dAo;');
								code.append(this._addMap('ao', 'aoPS', options, litShader.chunks, textureMapping));
								func.append('getAO();');
								args.append('litArgs_ao = dAo;');
						}
						decl.append('vec3 dEmission;');
						code.append(this._addMap('emissive', 'emissivePS', options, litShader.chunks, textureMapping, options.emissiveEncoding));
						func.append('getEmission();');
						args.append('litArgs_emission = dEmission;');
						if (options.litOptions.useClearCoat) {
								decl.append('float ccSpecularity;');
								decl.append('float ccGlossiness;');
								decl.append('vec3 ccNormalW;');
								code.append(this._addMap('clearCoat', 'clearCoatPS', options, litShader.chunks, textureMapping));
								code.append(this._addMap('clearCoatGloss', 'clearCoatGlossPS', options, litShader.chunks, textureMapping));
								code.append(this._addMap('clearCoatNormal', 'clearCoatNormalPS', options, litShader.chunks, textureMapping));
								func.append('getClearCoat();');
								func.append('getClearCoatGlossiness();');
								func.append('getClearCoatNormal();');
								args.append('litArgs_clearcoat_specularity = ccSpecularity;');
								args.append('litArgs_clearcoat_gloss = ccGlossiness;');
								args.append('litArgs_clearcoat_worldNormal = ccNormalW;');
						}
						if (options.lightMap || options.lightVertexColor) {
								var lightmapDir = options.dirLightMap && options.litOptions.useSpecular;
								var lightmapChunkPropName = lightmapDir ? 'lightmapDirPS' : 'lightmapSinglePS';
								decl.append('vec3 dLightmap;');
								if (lightmapDir) {
										decl.append('vec3 dLightmapDir;');
								}
								code.append(this._addMap('light', lightmapChunkPropName, options, litShader.chunks, textureMapping, options.lightMapEncoding));
								func.append('getLightMap();');
								args.append('litArgs_lightmap = dLightmap;');
								if (lightmapDir) {
										args.append('litArgs_lightmapDir = dLightmapDir;');
								}
						}
				} else {
						var opacityShadowDither = options.litOptions.opacityShadowDither;
						if (options.litOptions.alphaTest || opacityShadowDither) {
								decl.append('float dAlpha;');
								code.append(this._addMap('opacity', 'opacityPS', options, litShader.chunks, textureMapping));
								func.append('getOpacity();');
								args.append('litArgs_opacity = dAlpha;');
								if (options.litOptions.alphaTest) {
										code.append(litShader.chunks.alphaTestPS);
										func.append('alphaTest(dAlpha);');
								}
								if (opacityShadowDither !== DITHER_NONE) {
										if (opacityShadowDither === DITHER_BAYER8) {
												decl.append(litShader.chunks.bayerPS);
										}
										decl.append("#define DITHER_" + opacityShadowDither.toUpperCase() + "\n");
										decl.append(litShader.chunks.opacityDitherPS);
										func.append('opacityDither(dAlpha, 0.0);');
								}
						}
				}
				decl.append(litShader.chunks.litShaderArgsPS);
				code.append("\n            void evaluateFrontend() {\n                " + func.code + "\n                " + args.code + "\n            }\n        ");
				for(var texture in textureMapping){
						decl.append("uniform sampler2D " + textureMapping[texture] + ";");
				}
				litShader.generateFragmentShader(decl.code, code.code, lightingUv);
				var includes = new Map(Object.entries(_extends$d({}, Object.getPrototypeOf(litShader.chunks), litShader.chunks, options.litOptions.chunks)));
				var vDefines = litShader.vDefines;
				options.defines.forEach((value, key)=>vDefines.set(key, value));
				var fDefines = litShader.fDefines;
				options.defines.forEach((value, key)=>fDefines.set(key, value));
				var definition = ShaderUtils.createDefinition(device, {
						name: 'StandardShader',
						attributes: litShader.attributes,
						vertexCode: litShader.vshader,
						fragmentCode: litShader.fshader,
						vertexIncludes: includes,
						fragmentIncludes: includes,
						fragmentDefines: fDefines,
						vertexDefines: vDefines
				});
				if (litShader.shaderPassInfo.isForward) {
						definition.tag = SHADERTAG_MATERIAL;
				}
				return definition;
		}
		constructor(...args){
				super(...args), this.optionsContext = new StandardMaterialOptions(), this.optionsContextMin = new StandardMaterialOptions();
		}
}
var standard = new ShaderGeneratorStandard();

var arraysEqual = (a, b)=>{
		if (a.length !== b.length) {
				return false;
		}
		for(var i = 0; i < a.length; ++i){
				if (a[i] !== b[i]) {
						return false;
				}
		}
		return true;
};
var notWhite = (color)=>{
		return color.r !== 1 || color.g !== 1 || color.b !== 1;
};
var notBlack = (color)=>{
		return color.r !== 0 || color.g !== 0 || color.b !== 0;
};
class StandardMaterialOptionsBuilder {
		updateMinRef(options, scene, stdMat, objDefs, pass, sortedLights) {
				this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
				this._updateMinOptions(options, stdMat, pass);
				this._updateUVOptions(options, stdMat, objDefs, true);
		}
		updateRef(options, scene, cameraShaderParams, stdMat, objDefs, pass, sortedLights) {
				this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
				this._updateEnvOptions(options, stdMat, scene, cameraShaderParams);
				this._updateMaterialOptions(options, stdMat);
				options.litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
				this._updateLightOptions(options, scene, stdMat, objDefs, sortedLights);
				this._updateUVOptions(options, stdMat, objDefs, false, cameraShaderParams);
		}
		_updateSharedOptions(options, scene, stdMat, objDefs, pass) {
				options.forceUv1 = stdMat.forceUv1;
				if (stdMat.userAttributes) {
						options.litOptions.userAttributes = Object.fromEntries(stdMat.userAttributes.entries());
				}
				options.litOptions.chunks = stdMat.chunks || {};
				options.litOptions.pass = pass;
				options.litOptions.alphaTest = stdMat.alphaTest > 0;
				options.litOptions.blendType = stdMat.blendType;
				options.litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
				options.litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
				options.litOptions.batch = objDefs && (objDefs & SHADERDEF_BATCH) !== 0;
				options.litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
				options.litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
				options.litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
				options.litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
				options.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;
				if (scene.clusteredLightingEnabled && stdMat.useLighting) {
						options.litOptions.clusteredLightingEnabled = true;
						options.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
						options.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
						options.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
						options.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
				} else {
						options.litOptions.clusteredLightingEnabled = false;
						options.litOptions.clusteredLightingCookiesEnabled = false;
						options.litOptions.clusteredLightingShadowsEnabled = false;
						options.litOptions.clusteredLightingAreaLightsEnabled = false;
				}
		}
		_updateUVOptions(options, stdMat, objDefs, minimalOptions, cameraShaderParams) {
				var hasUv0 = false;
				var hasUv1 = false;
				var hasVcolor = false;
				if (objDefs) {
						hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
						hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
						hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
				}
				options.litOptions.vertexColors = false;
				this._mapXForms = [];
				var uniqueTextureMap = {};
				for(var p in _matTex2D){
						this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);
				}
				this._mapXForms = null;
				options.litOptions.ssao = cameraShaderParams == null ? void 0 : cameraShaderParams.ssaoEnabled;
				options.useAO = options.litOptions.ssao;
				options.litOptions.lightMapEnabled = options.lightMap;
				options.litOptions.dirLightMapEnabled = options.dirLightMap;
				options.litOptions.useHeights = options.heightMap;
				options.litOptions.useNormals = options.normalMap;
				options.litOptions.useClearCoatNormals = options.clearCoatNormalMap;
				options.litOptions.useAo = options.aoMap || options.aoVertexColor || options.litOptions.ssao;
				options.litOptions.diffuseMapEnabled = options.diffuseMap;
		}
		_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {
				var isOpacity = p === 'opacity';
				if (!minimalOptions || isOpacity) {
						var mname = "" + p + "Map";
						var vname = "" + p + "VertexColor";
						var vcname = "" + p + "VertexColorChannel";
						var cname = "" + mname + "Channel";
						var tname = "" + mname + "Transform";
						var uname = "" + mname + "Uv";
						var iname = "" + mname + "Identifier";
						if (p !== 'light') {
								options[mname] = false;
								options[iname] = undefined;
								options[cname] = '';
								options[tname] = 0;
								options[uname] = 0;
						}
						options[vname] = false;
						options[vcname] = '';
						if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage && stdMat.opacityDither === DITHER_NONE) {
								return;
						}
						if (p !== 'height' && stdMat[vname]) {
								if (hasVcolor) {
										options[vname] = stdMat[vname];
										options[vcname] = stdMat[vcname];
										options.litOptions.vertexColors = true;
								}
						}
						if (stdMat[mname]) {
								var allow = true;
								if (stdMat[uname] === 0 && !hasUv0) allow = false;
								if (stdMat[uname] === 1 && !hasUv1) allow = false;
								if (allow) {
										var mapId = stdMat[mname].id;
										var identifier = uniqueTextureMap[mapId];
										if (identifier === undefined) {
												uniqueTextureMap[mapId] = p;
												identifier = p;
										}
										options[mname] = !!stdMat[mname];
										options[iname] = identifier;
										options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
										options[cname] = stdMat[cname];
										options[uname] = stdMat[uname];
								}
						}
				}
		}
		_updateMinOptions(options, stdMat, pass) {
				var isPrepass = pass === SHADER_PREPASS;
				options.litOptions.opacityShadowDither = isPrepass ? stdMat.opacityDither : stdMat.opacityShadowDither;
				options.litOptions.linearDepth = isPrepass;
				options.litOptions.lights = [];
		}
		_updateMaterialOptions(options, stdMat) {
				var _stdMat_diffuseMap, _stdMat_diffuseDetailMap, _stdMat_emissiveMap, _stdMat_lightMap;
				var useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
				var useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;
				var specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
				var specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);
				var isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
				var equalish = (a, b)=>Math.abs(a - b) < 1e-4;
				options.specularTint = specularTint ? 2 : 0;
				options.specularityFactorTint = specularityFactorTint ? 1 : 0;
				options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
				options.glossTint = 1;
				options.diffuseEncoding = (_stdMat_diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat_diffuseMap.encoding;
				options.diffuseDetailEncoding = (_stdMat_diffuseDetailMap = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat_diffuseDetailMap.encoding;
				options.emissiveEncoding = (_stdMat_emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat_emissiveMap.encoding;
				options.lightMapEncoding = (_stdMat_lightMap = stdMat.lightMap) == null ? void 0 : _stdMat_lightMap.encoding;
				options.packedNormal = isPackedNormalMap;
				options.refractionTint = equalish(stdMat.refraction, 1.0) ? 0 : 1;
				options.refractionIndexTint = equalish(stdMat.refractionIndex, 1.0 / 1.5) ? 0 : 1;
				options.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0 ? 1 : 0;
				options.specularEncoding = stdMat.specularEncoding || 'linear';
				options.sheenEncoding = stdMat.sheenEncoding || 'linear';
				options.aoMapUv = stdMat.aoUvSet;
				options.aoDetail = !!stdMat.aoMap;
				options.diffuseDetail = !!stdMat.diffuseMap;
				options.normalDetail = !!stdMat.normalMap;
				options.diffuseDetailMode = stdMat.diffuseDetailMode;
				options.aoDetailMode = stdMat.aoDetailMode;
				options.clearCoatTint = equalish(stdMat.clearCoat, 1.0) ? 0 : 1;
				options.clearCoatGloss = !!stdMat.clearCoatGloss;
				options.clearCoatGlossTint = stdMat.clearCoatGloss !== 1.0 ? 1 : 0;
				options.iorTint = equalish(stdMat.refractionIndex, 1.0 / 1.5) ? 0 : 1;
				options.iridescenceTint = stdMat.iridescence !== 1.0 ? 1 : 0;
				options.glossInvert = stdMat.glossInvert;
				options.sheenGlossInvert = stdMat.sheenGlossInvert;
				options.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;
				options.useSpecularColor = useSpecularColor;
				options.litOptions.separateAmbient = false;
				options.litOptions.customFragmentShader = stdMat.customFragmentShader;
				options.litOptions.pixelSnap = stdMat.pixelSnap;
				options.litOptions.ambientSH = !!stdMat.ambientSH;
				options.litOptions.twoSidedLighting = stdMat.twoSidedLighting;
				options.litOptions.occludeSpecular = stdMat.occludeSpecular;
				options.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
				options.litOptions.useMsdf = !!stdMat.msdfMap;
				options.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;
				options.litOptions.alphaToCoverage = stdMat.alphaToCoverage;
				options.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;
				options.litOptions.opacityDither = stdMat.opacityDither;
				options.litOptions.cubeMapProjection = stdMat.cubeMapProjection;
				options.litOptions.occludeDirect = stdMat.occludeDirect;
				options.litOptions.useSpecular = useSpecular;
				options.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;
				options.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;
				options.litOptions.fresnelModel = stdMat.fresnelModel;
				options.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || options.litOptions.reflectionSource !== REFLECTIONSRC_NONE);
				options.litOptions.useClearCoat = !!stdMat.clearCoat;
				options.litOptions.useSheen = stdMat.useSheen;
				options.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0.0;
				options.litOptions.useMetalness = stdMat.useMetalness;
				options.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;
				options.litOptions.dispersion = stdMat.dispersion > 0;
				options.litOptions.shadowCatcher = stdMat.shadowCatcher;
		}
		_updateEnvOptions(options, stdMat, scene, cameraShaderParams) {
				options.litOptions.fog = stdMat.useFog ? cameraShaderParams.fog : FOG_NONE;
				options.litOptions.gamma = cameraShaderParams.shaderOutputGamma;
				options.litOptions.toneMap = stdMat.useTonemap ? cameraShaderParams.toneMapping : TONEMAP_NONE;
				var usingSceneEnv = false;
				if (stdMat.envAtlas && stdMat.cubeMap) {
						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLASHQ;
						options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
						options.litOptions.reflectionCubemapEncoding = stdMat.cubeMap.encoding;
				} else if (stdMat.envAtlas) {
						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLAS;
						options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
				} else if (stdMat.cubeMap) {
						options.litOptions.reflectionSource = REFLECTIONSRC_CUBEMAP;
						options.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;
				} else if (stdMat.sphereMap) {
						options.litOptions.reflectionSource = REFLECTIONSRC_SPHEREMAP;
						options.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;
				} else if (stdMat.useSkybox && scene.envAtlas && scene.skybox) {
						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLASHQ;
						options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
						options.litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
						usingSceneEnv = true;
				} else if (stdMat.useSkybox && scene.envAtlas) {
						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLAS;
						options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
						usingSceneEnv = true;
				} else if (stdMat.useSkybox && scene.skybox) {
						options.litOptions.reflectionSource = REFLECTIONSRC_CUBEMAP;
						options.litOptions.reflectionEncoding = scene.skybox.encoding;
						usingSceneEnv = true;
				} else {
						options.litOptions.reflectionSource = REFLECTIONSRC_NONE;
						options.litOptions.reflectionEncoding = null;
				}
				if (stdMat.ambientSH) {
						options.litOptions.ambientSource = AMBIENTSRC_AMBIENTSH;
						options.litOptions.ambientEncoding = null;
				} else {
						var envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);
						if (envAtlas && !stdMat.sphereMap) {
								options.litOptions.ambientSource = AMBIENTSRC_ENVALATLAS;
								options.litOptions.ambientEncoding = envAtlas.encoding;
						} else {
								options.litOptions.ambientSource = AMBIENTSRC_CONSTANT;
								options.litOptions.ambientEncoding = null;
						}
				}
				options.litOptions.skyboxIntensity = usingSceneEnv;
				options.litOptions.useCubeMapRotation = usingSceneEnv && scene._skyboxRotationShaderInclude;
		}
		_updateLightOptions(options, scene, stdMat, objDefs, sortedLights) {
				options.lightMap = false;
				options.lightMapChannel = '';
				options.lightMapUv = 0;
				options.lightMapTransform = 0;
				options.litOptions.lightMapWithoutAmbient = false;
				options.dirLightMap = false;
				if (objDefs) {
						options.litOptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;
						if ((objDefs & SHADERDEF_LM) !== 0) {
								options.lightMapEncoding = scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? 'rgbm' : 'linear';
								options.lightMap = true;
								options.lightMapChannel = 'rgb';
								options.lightMapUv = 1;
								options.lightMapTransform = 0;
								options.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;
								if ((objDefs & SHADERDEF_DIRLM) !== 0) {
										options.dirLightMap = true;
								}
								if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
										options.litOptions.lightMapWithoutAmbient = false;
								}
						}
				}
				if (stdMat.useLighting) {
						var lightsFiltered = [];
						var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
						options.litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
						if (sortedLights) {
								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
						}
						options.litOptions.lights = lightsFiltered;
				} else {
						options.litOptions.lights = [];
				}
				if (options.litOptions.lights.length === 0) {
						options.litOptions.noShadow = true;
				}
		}
		_getMapTransformID(xform, uv) {
				if (!xform) return 0;
				var xforms = this._mapXForms[uv];
				if (!xforms) {
						xforms = [];
						this._mapXForms[uv] = xforms;
				}
				for(var i = 0; i < xforms.length; i++){
						if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
								return i + 1;
						}
				}
				return xforms.push(xform);
		}
		constructor(){
				this._mapXForms = null;
		}
}

function _extends$c() {
		_extends$c = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$c.apply(this, arguments);
}
function _textureParameter(name, channel, vertexColor) {
		if (channel === void 0) channel = true;
		if (vertexColor === void 0) vertexColor = true;
		var result = {};
		result["" + name + "Map"] = 'texture';
		result["" + name + "MapTiling"] = 'vec2';
		result["" + name + "MapOffset"] = 'vec2';
		result["" + name + "MapRotation"] = 'number';
		result["" + name + "MapUv"] = 'number';
		if (channel) {
				result["" + name + "MapChannel"] = 'string';
				if (vertexColor) {
						result["" + name + "VertexColor"] = 'boolean';
						result["" + name + "VertexColorChannel"] = 'string';
				}
		}
		return result;
}
var standardMaterialParameterTypes = _extends$c({
		name: 'string',
		chunks: 'chunks',
		mappingFormat: 'string',
		_engine: 'boolean',
		ambient: 'rgb'
}, _textureParameter('ao'), _textureParameter('aoDetail', true, false), {
		aoDetailMode: 'string',
		diffuse: 'rgb'
}, _textureParameter('diffuse'), _textureParameter('diffuseDetail', true, false), {
		diffuseDetailMode: 'string',
		specular: 'rgb',
		specularTint: 'boolean'
}, _textureParameter('specular'), {
		occludeSpecular: 'enum:occludeSpecular',
		specularityFactor: 'number',
		specularityFactorTint: 'boolean'
}, _textureParameter('specularityFactor'), {
		useMetalness: 'boolean',
		metalness: 'number',
		enableGGXSpecular: 'boolean',
		anisotropy: 'number',
		metalnessTint: 'boolean'
}, _textureParameter('metalness'), {
		useMetalnessSpecularColor: 'boolean',
		shininess: 'number',
		gloss: 'number',
		glossInvert: 'boolean'
}, _textureParameter('gloss'), {
		clearCoat: 'number'
}, _textureParameter('clearCoat'), {
		clearCoatGloss: 'number',
		clearCoatGlossInvert: 'boolean'
}, _textureParameter('clearCoatGloss'), {
		clearCoatBumpiness: 'number'
}, _textureParameter('clearCoatNormal', false), {
		useSheen: 'boolean',
		sheen: 'rgb'
}, _textureParameter('sheen'), {
		sheenGloss: 'number',
		sheenGlossInvert: 'boolean'
}, _textureParameter('sheenGloss'), {
		fresnelModel: 'number',
		emissive: 'rgb'
}, _textureParameter('emissive'), {
		emissiveIntensity: 'number'
}, _textureParameter('normal', false), {
		bumpiness: 'number'
}, _textureParameter('normalDetail', false), {
		normalDetailMapBumpiness: 'number'
}, _textureParameter('height', true, false), {
		heightMapFactor: 'number',
		alphaToCoverage: 'boolean',
		alphaTest: 'number',
		alphaFade: 'number',
		opacity: 'number'
}, _textureParameter('opacity'), {
		opacityFadesSpecular: 'boolean',
		opacityDither: 'string',
		opacityShadowDither: 'string',
		reflectivity: 'number',
		refraction: 'number',
		refractionTint: 'boolean'
}, _textureParameter('refraction'), {
		refractionIndex: 'number',
		dispersion: 'number',
		thickness: 'number',
		thicknessTint: 'boolean'
}, _textureParameter('thickness'), {
		attenuation: 'rgb',
		attenuationDistance: 'number',
		useDynamicRefraction: 'boolean',
		sphereMap: 'texture',
		cubeMap: 'cubemap',
		cubeMapProjection: 'number',
		cubeMapProjectionBox: 'boundingbox',
		useIridescence: 'boolean',
		iridescence: 'number',
		iridescenceTint: 'boolean'
}, _textureParameter('iridescence'), {
		iridescenceThicknessTint: 'boolean',
		iridescenceThicknessMin: 'number',
		iridescenceThicknessMax: 'number',
		iridescenceRefractionIndex: 'number'
}, _textureParameter('iridescenceThickness'), _textureParameter('light'), {
		depthTest: 'boolean',
		depthFunc: 'enum:depthFunc',
		depthWrite: 'boolean',
		depthBias: 'number',
		slopeDepthBias: 'number',
		cull: 'enum:cull',
		blendType: 'enum:blendType',
		useFog: 'boolean',
		useLighting: 'boolean',
		useSkybox: 'boolean',
		useTonemap: 'boolean',
		envAtlas: 'texture',
		twoSidedLighting: 'boolean',
		shadowCatcher: 'boolean'
});
var standardMaterialTextureParameters = [];
for(var key in standardMaterialParameterTypes){
		var type = standardMaterialParameterTypes[key];
		if (type === 'texture') {
				standardMaterialTextureParameters.push(key);
		}
}
var standardMaterialCubemapParameters = [];
for(var key1 in standardMaterialParameterTypes){
		var type1 = standardMaterialParameterTypes[key1];
		if (type1 === 'cubemap') {
				standardMaterialCubemapParameters.push(key1);
		}
}
var standardMaterialRemovedParameters = {
		aoMapVertexColor: 'boolean',
		diffuseMapTint: 'boolean',
		diffuseMapVertexColor: 'boolean',
		emissiveMapTint: 'boolean',
		emissiveMapVertexColor: 'boolean',
		glossMapVertexColor: 'boolean',
		metalnessMapVertexColor: 'boolean',
		opacityMapVertexColor: 'boolean',
		specularAntialias: 'boolean',
		specularMapTint: 'boolean',
		specularMapVertexColor: 'boolean',
		ambientTint: 'boolean',
		emissiveTint: 'boolean',
		diffuseTint: 'boolean',
		sheenTint: 'boolean',
		conserveEnergy: 'boolean',
		useGamma: 'boolean',
		useGammaTonemap: 'boolean',
		sheenGlossTint: 'boolean'
};

var _props = {};
var _uniforms = {};
var _params = new Set();
var _tempColor$3 = new Color();
class StandardMaterial extends Material {
		reset() {
				Object.keys(_props).forEach((name)=>{
						this["_" + name] = _props[name].value();
				});
				this._uniformCache = {};
		}
		copy(source) {
				super.copy(source);
				Object.keys(_props).forEach((k)=>{
						this[k] = source[k];
				});
				this.userAttributes = new Map(source.userAttributes);
				return this;
		}
		setAttribute(name, semantic) {
				this.userAttributes.set(semantic, name);
		}
		_setParameter(name, value) {
				_params.add(name);
				this.setParameter(name, value);
		}
		_setParameters(parameters) {
				parameters.forEach((v)=>{
						this._setParameter(v.name, v.value);
				});
		}
		_processParameters(paramsName) {
				var prevParams = this[paramsName];
				prevParams.forEach((param)=>{
						if (!_params.has(param)) {
								delete this.parameters[param];
						}
				});
				this[paramsName] = _params;
				_params = prevParams;
				_params.clear();
		}
		_updateMap(p) {
				var mname = "" + p + "Map";
				var map = this[mname];
				if (map) {
						this._setParameter("texture_" + mname, map);
						var tname = "" + mname + "Transform";
						var uniform = this.getUniform(tname);
						if (uniform) {
								this._setParameters(uniform);
						}
				}
		}
		_allocUniform(name, allocFunc) {
				var uniform = this._uniformCache[name];
				if (!uniform) {
						uniform = allocFunc();
						this._uniformCache[name] = uniform;
				}
				return uniform;
		}
		getUniform(name, device, scene) {
				return _uniforms[name](this, device, scene);
		}
		updateUniforms(device, scene) {
				var getUniform = (name)=>{
						return this.getUniform(name, device, scene);
				};
				this._setParameter('material_ambient', getUniform('ambient'));
				this._setParameter('material_diffuse', getUniform('diffuse'));
				this._setParameter('material_aoIntensity', this.aoIntensity);
				if (this.useMetalness) {
						if (!this.metalnessMap || this.metalness < 1) {
								this._setParameter('material_metalness', this.metalness);
						}
						if (!this.specularMap || this.specularTint) {
								this._setParameter('material_specular', getUniform('specular'));
						}
						if (!this.specularityFactorMap || this.specularityFactorTint) {
								this._setParameter('material_specularityFactor', this.specularityFactor);
						}
						this._setParameter('material_sheen', getUniform('sheen'));
						this._setParameter('material_sheenGloss', this.sheenGloss);
						this._setParameter('material_refractionIndex', this.refractionIndex);
				} else {
						if (!this.specularMap || this.specularTint) {
								this._setParameter('material_specular', getUniform('specular'));
						}
				}
				if (this.enableGGXSpecular) {
						this._setParameter('material_anisotropy', this.anisotropy);
				}
				if (this.clearCoat > 0) {
						this._setParameter('material_clearCoat', this.clearCoat);
						this._setParameter('material_clearCoatGloss', this.clearCoatGloss);
						this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
				}
				this._setParameter('material_gloss', this.gloss);
				this._setParameter('material_emissive', getUniform('emissive'));
				this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
				if (this.refraction > 0) {
						this._setParameter('material_refraction', this.refraction);
				}
				if (this.dispersion > 0) {
						this._setParameter('material_dispersion', this.dispersion);
				}
				if (this.useDynamicRefraction) {
						this._setParameter('material_thickness', this.thickness);
						this._setParameter('material_attenuation', getUniform('attenuation'));
						this._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);
				}
				if (this.useIridescence) {
						this._setParameter('material_iridescence', this.iridescence);
						this._setParameter('material_iridescenceRefractionIndex', this.iridescenceRefractionIndex);
						this._setParameter('material_iridescenceThicknessMin', this.iridescenceThicknessMin);
						this._setParameter('material_iridescenceThicknessMax', this.iridescenceThicknessMax);
				}
				this._setParameter('material_opacity', this.opacity);
				if (this.opacityFadesSpecular === false) {
						this._setParameter('material_alphaFade', this.alphaFade);
				}
				if (this.occludeSpecular) {
						this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
				}
				if (this.cubeMapProjection === CUBEPROJ_BOX) {
						this._setParameter(getUniform('cubeMapProjectionBox'));
				}
				for(var p in _matTex2D){
						this._updateMap(p);
				}
				if (this.ambientSH) {
						this._setParameter('ambientSH[0]', this.ambientSH);
				}
				if (this.normalMap) {
						this._setParameter('material_bumpiness', this.bumpiness);
				}
				if (this.normalMap && this.normalDetailMap) {
						this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
				}
				if (this.heightMap) {
						this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
				}
				if (this.envAtlas && this.cubeMap) {
						this._setParameter('texture_envAtlas', this.envAtlas);
						this._setParameter('texture_cubeMap', this.cubeMap);
				} else if (this.envAtlas) {
						this._setParameter('texture_envAtlas', this.envAtlas);
				} else if (this.cubeMap) {
						this._setParameter('texture_cubeMap', this.cubeMap);
				} else if (this.sphereMap) {
						this._setParameter('texture_sphereMap', this.sphereMap);
				}
				this._setParameter('material_reflectivity', this.reflectivity);
				this._processParameters('_activeParams');
				super.updateUniforms(device, scene);
		}
		updateEnvUniforms(device, scene) {
				var hasLocalEnvOverride = this.envAtlas || this.cubeMap || this.sphereMap;
				if (!hasLocalEnvOverride && this.useSkybox) {
						if (scene.envAtlas && scene.skybox) {
								this._setParameter('texture_envAtlas', scene.envAtlas);
								this._setParameter('texture_cubeMap', scene.skybox);
						} else if (scene.envAtlas) {
								this._setParameter('texture_envAtlas', scene.envAtlas);
						} else if (scene.skybox) {
								this._setParameter('texture_cubeMap', scene.skybox);
						}
				}
				this._processParameters('_activeLightingParams');
		}
		getShaderVariant(params) {
				var { device, scene, pass, objDefs, sortedLights, cameraShaderParams } = params;
				this.updateEnvUniforms(device, scene);
				var shaderPassInfo = ShaderPass.get(device).getByIndex(pass);
				var minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS || shaderPassInfo.isShadow;
				var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
				options.defines = getCoreDefines(this, params);
				if (minimalOptions) {
						this.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, pass, sortedLights);
				} else {
						this.shaderOptBuilder.updateRef(options, scene, cameraShaderParams, this, objDefs, pass, sortedLights);
				}
				if (!this.useFog) options.defines.set('FOG', 'NONE');
				options.defines.set('TONEMAP', tonemapNames[options.litOptions.toneMap]);
				if (this.onUpdateShader) {
						options = this.onUpdateShader(options);
				}
				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
				var library = getProgramLibrary(device);
				library.register('standard', standard);
				var shader = library.getProgram('standard', options, processingOptions, this.userId);
				this._dirtyShader = false;
				return shader;
		}
		destroy() {
				for(var asset in this._assetReferences){
						this._assetReferences[asset]._unbind();
				}
				this._assetReferences = null;
				super.destroy();
		}
		constructor(){
				super(), this.userAttributes = new Map();
				this._assetReferences = {};
				this._activeParams = new Set();
				this._activeLightingParams = new Set();
				this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
				this.reset();
		}
}
StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;
var defineUniform = (name, getUniformFunc)=>{
		_uniforms[name] = getUniformFunc;
};
var definePropInternal = (name, constructorFunc, setterFunc, getterFunc)=>{
		Object.defineProperty(StandardMaterial.prototype, name, {
				get: getterFunc || function() {
						return this["_" + name];
				},
				set: setterFunc
		});
		_props[name] = {
				value: constructorFunc
		};
};
var defineValueProp = (prop)=>{
		var internalName = "_" + prop.name;
		var dirtyShaderFunc = prop.dirtyShaderFunc || (()=>true);
		var setterFunc = function setterFunc(value) {
				var oldValue = this[internalName];
				if (oldValue !== value) {
						this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
						this[internalName] = value;
				}
		};
		definePropInternal(prop.name, ()=>prop.defaultValue, setterFunc, prop.getterFunc);
};
var defineAggProp = (prop)=>{
		var internalName = "_" + prop.name;
		var dirtyShaderFunc = prop.dirtyShaderFunc || (()=>true);
		var setterFunc = function setterFunc(value) {
				var oldValue = this[internalName];
				if (!oldValue.equals(value)) {
						this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
						this[internalName] = oldValue.copy(value);
				}
		};
		definePropInternal(prop.name, ()=>prop.defaultValue.clone(), setterFunc, prop.getterFunc);
};
var defineProp = (prop)=>{
		return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
};
function _defineTex2D(name, channel, vertexColor, uv) {
		if (channel === void 0) channel = 'rgb';
		if (vertexColor === void 0) vertexColor = true;
		if (uv === void 0) uv = 0;
		_matTex2D[name] = channel.length || -1;
		defineProp({
				name: "" + name + "Map",
				defaultValue: null,
				dirtyShaderFunc: (oldValue, newValue)=>{
						return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.format !== newValue.format);
				}
		});
		defineProp({
				name: "" + name + "MapTiling",
				defaultValue: new Vec2(1, 1)
		});
		defineProp({
				name: "" + name + "MapOffset",
				defaultValue: new Vec2(0, 0)
		});
		defineProp({
				name: "" + name + "MapRotation",
				defaultValue: 0
		});
		defineProp({
				name: "" + name + "MapUv",
				defaultValue: uv
		});
		if (channel) {
				defineProp({
						name: "" + name + "MapChannel",
						defaultValue: channel
				});
				if (vertexColor) {
						defineProp({
								name: "" + name + "VertexColor",
								defaultValue: false
						});
						defineProp({
								name: "" + name + "VertexColorChannel",
								defaultValue: channel
						});
				}
		}
		var mapTiling = "" + name + "MapTiling";
		var mapOffset = "" + name + "MapOffset";
		var mapRotation = "" + name + "MapRotation";
		var mapTransform = "" + name + "MapTransform";
		defineUniform(mapTransform, (material, device, scene)=>{
				var tiling = material[mapTiling];
				var offset = material[mapOffset];
				var rotation = material[mapRotation];
				if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
						return null;
				}
				var uniform = material._allocUniform(mapTransform, ()=>{
						return [
								{
										name: "texture_" + mapTransform + "0",
										value: new Float32Array(3)
								},
								{
										name: "texture_" + mapTransform + "1",
										value: new Float32Array(3)
								}
						];
				});
				var cr = Math.cos(rotation * math.DEG_TO_RAD);
				var sr = Math.sin(rotation * math.DEG_TO_RAD);
				var uniform0 = uniform[0].value;
				uniform0[0] = cr * tiling.x;
				uniform0[1] = -sr * tiling.y;
				uniform0[2] = offset.x;
				var uniform1 = uniform[1].value;
				uniform1[0] = sr * tiling.x;
				uniform1[1] = cr * tiling.y;
				uniform1[2] = 1.0 - tiling.y - offset.y;
				return uniform;
		});
}
function _defineColor(name, defaultValue) {
		defineProp({
				name: name,
				defaultValue: defaultValue,
				getterFunc: function getterFunc() {
						this._dirtyShader = true;
						return this["_" + name];
				}
		});
		defineUniform(name, (material, device, scene)=>{
				var uniform = material._allocUniform(name, ()=>new Float32Array(3));
				var color = material[name];
				_tempColor$3.linear(color);
				uniform[0] = _tempColor$3.r;
				uniform[1] = _tempColor$3.g;
				uniform[2] = _tempColor$3.b;
				return uniform;
		});
}
function _defineFloat(name, defaultValue, getUniformFunc) {
		defineProp({
				name: name,
				defaultValue: defaultValue,
				dirtyShaderFunc: (oldValue, newValue)=>{
						return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
				}
		});
		defineUniform(name, getUniformFunc);
}
function _defineObject(name, getUniformFunc) {
		defineProp({
				name: name,
				defaultValue: null,
				dirtyShaderFunc: (oldValue, newValue)=>{
						return !!oldValue === !!newValue;
				}
		});
		defineUniform(name, getUniformFunc);
}
function _defineFlag(name, defaultValue) {
		defineProp({
				name: name,
				defaultValue: defaultValue
		});
}
function _defineMaterialProps() {
		_defineColor('ambient', new Color(1, 1, 1));
		_defineColor('diffuse', new Color(1, 1, 1));
		_defineColor('specular', new Color(0, 0, 0));
		_defineColor('emissive', new Color(0, 0, 0));
		_defineColor('sheen', new Color(1, 1, 1));
		_defineColor('attenuation', new Color(1, 1, 1));
		_defineFloat('emissiveIntensity', 1);
		_defineFloat('specularityFactor', 1);
		_defineFloat('sheenGloss', 0.0);
		_defineFloat('gloss', 0.25);
		_defineFloat('aoIntensity', 1);
		_defineFloat('heightMapFactor', 1, (material, device, scene)=>{
				return material.heightMapFactor * 0.025;
		});
		_defineFloat('opacity', 1);
		_defineFloat('alphaFade', 1);
		_defineFloat('alphaTest', 0);
		_defineFloat('bumpiness', 1);
		_defineFloat('normalDetailMapBumpiness', 1);
		_defineFloat('reflectivity', 1);
		_defineFloat('occludeSpecularIntensity', 1);
		_defineFloat('refraction', 0);
		_defineFloat('refractionIndex', 1.0 / 1.5);
		_defineFloat('dispersion', 0);
		_defineFloat('thickness', 0);
		_defineFloat('attenuationDistance', 0);
		_defineFloat('metalness', 1);
		_defineFloat('anisotropy', 0);
		_defineFloat('clearCoat', 0);
		_defineFloat('clearCoatGloss', 1);
		_defineFloat('clearCoatBumpiness', 1);
		_defineFloat('aoUvSet', 0, null);
		_defineFloat('iridescence', 0);
		_defineFloat('iridescenceRefractionIndex', 1.0 / 1.5);
		_defineFloat('iridescenceThicknessMin', 0);
		_defineFloat('iridescenceThicknessMax', 0);
		_defineObject('ambientSH');
		_defineObject('cubeMapProjectionBox', (material, device, scene)=>{
				var uniform = material._allocUniform('cubeMapProjectionBox', ()=>{
						return [
								{
										name: 'envBoxMin',
										value: new Float32Array(3)
								},
								{
										name: 'envBoxMax',
										value: new Float32Array(3)
								}
						];
				});
				var bboxMin = material.cubeMapProjectionBox.getMin();
				var minUniform = uniform[0].value;
				minUniform[0] = bboxMin.x;
				minUniform[1] = bboxMin.y;
				minUniform[2] = bboxMin.z;
				var bboxMax = material.cubeMapProjectionBox.getMax();
				var maxUniform = uniform[1].value;
				maxUniform[0] = bboxMax.x;
				maxUniform[1] = bboxMax.y;
				maxUniform[2] = bboxMax.z;
				return uniform;
		});
		_defineFlag('specularTint', false);
		_defineFlag('specularityFactorTint', false);
		_defineFlag('useMetalness', false);
		_defineFlag('useMetalnessSpecularColor', false);
		_defineFlag('useSheen', false);
		_defineFlag('enableGGXSpecular', false);
		_defineFlag('occludeDirect', false);
		_defineFlag('opacityFadesSpecular', true);
		_defineFlag('occludeSpecular', SPECOCC_AO);
		_defineFlag('fresnelModel', FRESNEL_SCHLICK);
		_defineFlag('useDynamicRefraction', false);
		_defineFlag('cubeMapProjection', CUBEPROJ_NONE);
		_defineFlag('customFragmentShader', null);
		_defineFlag('useFog', true);
		_defineFlag('useLighting', true);
		_defineFlag('useTonemap', true);
		_defineFlag('useSkybox', true);
		_defineFlag('forceUv1', false);
		_defineFlag('pixelSnap', false);
		_defineFlag('twoSidedLighting', false);
		_defineFlag('nineSlicedMode', undefined);
		_defineFlag('msdfTextAttribute', false);
		_defineFlag('useIridescence', false);
		_defineFlag('glossInvert', false);
		_defineFlag('sheenGlossInvert', false);
		_defineFlag('clearCoatGlossInvert', false);
		_defineFlag('opacityDither', DITHER_NONE);
		_defineFlag('opacityShadowDither', DITHER_NONE);
		_defineFlag('shadowCatcher', false);
		_defineTex2D('diffuse');
		_defineTex2D('specular');
		_defineTex2D('emissive');
		_defineTex2D('thickness', 'g');
		_defineTex2D('specularityFactor', 'g');
		_defineTex2D('normal', '');
		_defineTex2D('metalness', 'g');
		_defineTex2D('gloss', 'g');
		_defineTex2D('opacity', 'a');
		_defineTex2D('refraction', 'g');
		_defineTex2D('height', 'g', false);
		_defineTex2D('ao', 'g');
		_defineTex2D('light', 'rgb', true, 1);
		_defineTex2D('msdf', '');
		_defineTex2D('diffuseDetail', 'rgb', false);
		_defineTex2D('normalDetail', '');
		_defineTex2D('aoDetail', 'g', false);
		_defineTex2D('clearCoat', 'g');
		_defineTex2D('clearCoatGloss', 'g');
		_defineTex2D('clearCoatNormal', '');
		_defineTex2D('sheen', 'rgb');
		_defineTex2D('sheenGloss', 'g');
		_defineTex2D('iridescence', 'g');
		_defineTex2D('iridescenceThickness', 'g');
		_defineFlag('diffuseDetailMode', DETAILMODE_MUL);
		_defineFlag('aoDetailMode', DETAILMODE_MUL);
		_defineObject('cubeMap');
		_defineObject('sphereMap');
		_defineObject('envAtlas');
		var getterFunc = function getterFunc() {
				return this._prefilteredCubemaps;
		};
		var setterFunc = function setterFunc(value) {
				var cubemaps = this._prefilteredCubemaps;
				value = value || [];
				var changed = false;
				var complete = true;
				for(var i = 0; i < 6; ++i){
						var v = value[i] || null;
						if (cubemaps[i] !== v) {
								cubemaps[i] = v;
								changed = true;
						}
						complete = complete && !!cubemaps[i];
				}
				if (changed) {
						if (complete) {
								this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
										target: this.envAtlas
								});
						} else {
								if (this.envAtlas) {
										this.envAtlas.destroy();
										this.envAtlas = null;
								}
						}
						this._dirtyShader = true;
				}
		};
		var empty = [
				null,
				null,
				null,
				null,
				null,
				null
		];
		definePropInternal('prefilteredCubemaps', ()=>empty.slice(), setterFunc, getterFunc);
}
_defineMaterialProps();

var primitiveUv1Padding = 4.0 / 64;
var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
class ConeBaseGeometry extends Geometry {
		constructor(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps){
				super();
				var pos = new Vec3();
				var bottomToTop = new Vec3();
				var norm = new Vec3();
				var top = new Vec3();
				var bottom = new Vec3();
				var tangent = new Vec3();
				var positions = [];
				var normals = [];
				var uvs = [];
				var uvs1 = [];
				var indices = [];
				var offset;
				if (height > 0) {
						for(var i = 0; i <= heightSegments; i++){
								for(var j = 0; j <= capSegments; j++){
										var theta = j / capSegments * 2 * Math.PI - Math.PI;
										var sinTheta = Math.sin(theta);
										var cosTheta = Math.cos(theta);
										bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
										top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
										pos.lerp(bottom, top, i / heightSegments);
										bottomToTop.sub2(top, bottom).normalize();
										tangent.set(cosTheta, 0, -sinTheta);
										norm.cross(tangent, bottomToTop).normalize();
										positions.push(pos.x, pos.y, pos.z);
										normals.push(norm.x, norm.y, norm.z);
										var u = j / capSegments;
										var v = i / heightSegments;
										uvs.push(u, 1 - v);
										var _v = v;
										v = u;
										u = _v;
										u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
										v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
										u /= 3;
										uvs1.push(u, 1 - v);
										if (i < heightSegments && j < capSegments) {
												var first = i * (capSegments + 1) + j;
												var second = i * (capSegments + 1) + (j + 1);
												var third = (i + 1) * (capSegments + 1) + j;
												var fourth = (i + 1) * (capSegments + 1) + (j + 1);
												indices.push(first, second, third);
												indices.push(second, fourth, third);
										}
								}
						}
				}
				if (roundedCaps) {
						var latitudeBands = Math.floor(capSegments / 2);
						var longitudeBands = capSegments;
						var capOffset = height / 2;
						for(var lat = 0; lat <= latitudeBands; lat++){
								var theta1 = lat * Math.PI * 0.5 / latitudeBands;
								var sinTheta1 = Math.sin(theta1);
								var cosTheta1 = Math.cos(theta1);
								for(var lon = 0; lon <= longitudeBands; lon++){
										var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
										var sinPhi = Math.sin(phi);
										var cosPhi = Math.cos(phi);
										var x = cosPhi * sinTheta1;
										var y = cosTheta1;
										var z = sinPhi * sinTheta1;
										var u1 = 1 - lon / longitudeBands;
										var v1 = 1 - lat / latitudeBands;
										positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
										normals.push(x, y, z);
										uvs.push(u1, 1 - v1);
										u1 = u1 * primitiveUv1PaddingScale + primitiveUv1Padding;
										v1 = v1 * primitiveUv1PaddingScale + primitiveUv1Padding;
										u1 /= 3;
										v1 /= 3;
										u1 += 1.0 / 3;
										uvs1.push(u1, 1 - v1);
								}
						}
						offset = (heightSegments + 1) * (capSegments + 1);
						for(var lat1 = 0; lat1 < latitudeBands; ++lat1){
								for(var lon1 = 0; lon1 < longitudeBands; ++lon1){
										var first1 = lat1 * (longitudeBands + 1) + lon1;
										var second1 = first1 + longitudeBands + 1;
										indices.push(offset + first1 + 1, offset + second1, offset + first1);
										indices.push(offset + first1 + 1, offset + second1 + 1, offset + second1);
								}
						}
						for(var lat2 = 0; lat2 <= latitudeBands; lat2++){
								var theta2 = Math.PI * 0.5 + lat2 * Math.PI * 0.5 / latitudeBands;
								var sinTheta2 = Math.sin(theta2);
								var cosTheta2 = Math.cos(theta2);
								for(var lon2 = 0; lon2 <= longitudeBands; lon2++){
										var phi1 = lon2 * 2 * Math.PI / longitudeBands - Math.PI / 2;
										var sinPhi1 = Math.sin(phi1);
										var cosPhi1 = Math.cos(phi1);
										var x1 = cosPhi1 * sinTheta2;
										var y1 = cosTheta2;
										var z1 = sinPhi1 * sinTheta2;
										var u2 = 1 - lon2 / longitudeBands;
										var v2 = 1 - lat2 / latitudeBands;
										positions.push(x1 * peakRadius, y1 * peakRadius - capOffset, z1 * peakRadius);
										normals.push(x1, y1, z1);
										uvs.push(u2, 1 - v2);
										u2 = u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
										v2 = v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
										u2 /= 3;
										v2 /= 3;
										u2 += 2.0 / 3;
										uvs1.push(u2, 1 - v2);
								}
						}
						offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
						for(var lat3 = 0; lat3 < latitudeBands; ++lat3){
								for(var lon3 = 0; lon3 < longitudeBands; ++lon3){
										var first2 = lat3 * (longitudeBands + 1) + lon3;
										var second2 = first2 + longitudeBands + 1;
										indices.push(offset + first2 + 1, offset + second2, offset + first2);
										indices.push(offset + first2 + 1, offset + second2 + 1, offset + second2);
								}
						}
				} else {
						offset = (heightSegments + 1) * (capSegments + 1);
						if (baseRadius > 0) {
								for(var i1 = 0; i1 < capSegments; i1++){
										var theta3 = i1 / capSegments * 2 * Math.PI;
										var x2 = Math.sin(theta3);
										var y2 = -height / 2;
										var z2 = Math.cos(theta3);
										var u3 = 1 - (x2 + 1) / 2;
										var v3 = (z2 + 1) / 2;
										positions.push(x2 * baseRadius, y2, z2 * baseRadius);
										normals.push(0, -1, 0);
										uvs.push(u3, 1 - v3);
										u3 = u3 * primitiveUv1PaddingScale + primitiveUv1Padding;
										v3 = v3 * primitiveUv1PaddingScale + primitiveUv1Padding;
										u3 /= 3;
										v3 /= 3;
										u3 += 1 / 3;
										uvs1.push(u3, 1 - v3);
										if (i1 > 1) {
												indices.push(offset, offset + i1, offset + i1 - 1);
										}
								}
						}
						offset += capSegments;
						if (peakRadius > 0) {
								for(var i2 = 0; i2 < capSegments; i2++){
										var theta4 = i2 / capSegments * 2 * Math.PI;
										var x3 = Math.sin(theta4);
										var y3 = height / 2;
										var z3 = Math.cos(theta4);
										var u4 = 1 - (x3 + 1) / 2;
										var v4 = (z3 + 1) / 2;
										positions.push(x3 * peakRadius, y3, z3 * peakRadius);
										normals.push(0, 1, 0);
										uvs.push(u4, 1 - v4);
										u4 = u4 * primitiveUv1PaddingScale + primitiveUv1Padding;
										v4 = v4 * primitiveUv1PaddingScale + primitiveUv1Padding;
										u4 /= 3;
										v4 /= 3;
										u4 += 2 / 3;
										uvs1.push(u4, 1 - v4);
										if (i2 > 1) {
												indices.push(offset, offset + i2 - 1, offset + i2);
										}
								}
						}
				}
				this.positions = positions;
				this.normals = normals;
				this.uvs = uvs;
				this.uvs1 = uvs1;
				this.indices = indices;
		}
}

class CapsuleGeometry extends ConeBaseGeometry {
		constructor(opts = {}){
				var _opts_radius;
				var radius = (_opts_radius = opts.radius) != null ? _opts_radius : 0.3;
				var _opts_height;
				var height = (_opts_height = opts.height) != null ? _opts_height : 1;
				var _opts_heightSegments;
				var heightSegments = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 1;
				var _opts_sides;
				var sides = (_opts_sides = opts.sides) != null ? _opts_sides : 20;
				super(radius, radius, height - 2 * radius, heightSegments, sides, true);
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
				}
		}
}

class ConeGeometry extends ConeBaseGeometry {
		constructor(opts = {}){
				var _opts_baseRadius;
				var baseRadius = (_opts_baseRadius = opts.baseRadius) != null ? _opts_baseRadius : 0.5;
				var _opts_peakRadius;
				var peakRadius = (_opts_peakRadius = opts.peakRadius) != null ? _opts_peakRadius : 0;
				var _opts_height;
				var height = (_opts_height = opts.height) != null ? _opts_height : 1;
				var _opts_heightSegments;
				var heightSegments = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 5;
				var _opts_capSegments;
				var capSegments = (_opts_capSegments = opts.capSegments) != null ? _opts_capSegments : 18;
				super(baseRadius, peakRadius, height, heightSegments, capSegments, false);
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
				}
		}
}

class CylinderGeometry extends ConeBaseGeometry {
		constructor(opts = {}){
				var _opts_radius;
				var radius = (_opts_radius = opts.radius) != null ? _opts_radius : 0.5;
				var _opts_height;
				var height = (_opts_height = opts.height) != null ? _opts_height : 1;
				var _opts_heightSegments;
				var heightSegments = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 5;
				var _opts_capSegments;
				var capSegments = (_opts_capSegments = opts.capSegments) != null ? _opts_capSegments : 20;
				super(radius, radius, height, heightSegments, capSegments, false);
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
				}
		}
}

class PlaneGeometry extends Geometry {
		constructor(opts = {}){
				super();
				var _opts_halfExtents;
				var he = (_opts_halfExtents = opts.halfExtents) != null ? _opts_halfExtents : new Vec2(0.5, 0.5);
				var _opts_widthSegments;
				var ws = (_opts_widthSegments = opts.widthSegments) != null ? _opts_widthSegments : 5;
				var _opts_lengthSegments;
				var ls = (_opts_lengthSegments = opts.lengthSegments) != null ? _opts_lengthSegments : 5;
				var positions = [];
				var normals = [];
				var uvs = [];
				var indices = [];
				var vcounter = 0;
				for(var i = 0; i <= ws; i++){
						for(var j = 0; j <= ls; j++){
								var x = -he.x + 2 * he.x * i / ws;
								var y = 0.0;
								var z = -(-he.y + 2 * he.y * j / ls);
								var u = i / ws;
								var v = j / ls;
								positions.push(x, y, z);
								normals.push(0, 1, 0);
								uvs.push(u, 1 - v);
								if (i < ws && j < ls) {
										indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
										indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
								}
								vcounter++;
						}
				}
				this.positions = positions;
				this.normals = normals;
				this.uvs = uvs;
				this.uvs1 = uvs;
				this.indices = indices;
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(positions, normals, uvs, indices);
				}
		}
}

class TorusGeometry extends Geometry {
		constructor(opts = {}){
				super();
				var _opts_tubeRadius;
				var rc = (_opts_tubeRadius = opts.tubeRadius) != null ? _opts_tubeRadius : 0.2;
				var _opts_ringRadius;
				var rt = (_opts_ringRadius = opts.ringRadius) != null ? _opts_ringRadius : 0.3;
				var _opts_sectorAngle;
				var sectorAngle = ((_opts_sectorAngle = opts.sectorAngle) != null ? _opts_sectorAngle : 360) * math.DEG_TO_RAD;
				var _opts_segments;
				var segments = (_opts_segments = opts.segments) != null ? _opts_segments : 30;
				var _opts_sides;
				var sides = (_opts_sides = opts.sides) != null ? _opts_sides : 20;
				var positions = [];
				var normals = [];
				var uvs = [];
				var indices = [];
				for(var i = 0; i <= sides; i++){
						for(var j = 0; j <= segments; j++){
								var x = Math.cos(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
								var y = Math.sin(2 * Math.PI * i / sides) * rc;
								var z = Math.sin(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
								var nx = Math.cos(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
								var ny = Math.sin(2 * Math.PI * i / sides);
								var nz = Math.sin(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
								var u = i / sides;
								var v = 1 - j / segments;
								positions.push(x, y, z);
								normals.push(nx, ny, nz);
								uvs.push(u, 1.0 - v);
								if (i < sides && j < segments) {
										var first = i * (segments + 1) + j;
										var second = (i + 1) * (segments + 1) + j;
										var third = i * (segments + 1) + (j + 1);
										var fourth = (i + 1) * (segments + 1) + (j + 1);
										indices.push(first, second, third);
										indices.push(second, fourth, third);
								}
						}
				}
				this.positions = positions;
				this.normals = normals;
				this.uvs = uvs;
				this.uvs1 = uvs;
				this.indices = indices;
				if (opts.calculateTangents) {
						this.tangents = calculateTangents(positions, normals, uvs, indices);
				}
		}
}

class ProgramLibrary {
		destroy() {
				this.clearCache();
		}
		register(name, generator) {
				if (!this._generators.has(name)) {
						this._generators.set(name, generator);
				}
		}
		unregister(name) {
				if (this._generators.has(name)) {
						this._generators.delete(name);
				}
		}
		isRegistered(name) {
				return this._generators.has(name);
		}
		generateShaderDefinition(generator, name, key, options) {
				var def = this.definitionsCache.get(key);
				if (!def) {
						var _options_litOptions, _options_litOptions1;
						var lights;
						if ((_options_litOptions = options.litOptions) == null ? void 0 : _options_litOptions.lights) {
								lights = options.litOptions.lights;
								options.litOptions.lights = lights.map((l)=>{
										var lcopy = l.clone ? l.clone() : l;
										lcopy.key = l.key;
										return lcopy;
								});
						}
						this.storeNewProgram(name, options);
						if ((_options_litOptions1 = options.litOptions) == null ? void 0 : _options_litOptions1.lights) {
								options.litOptions.lights = lights;
						}
						if (this._precached) ;
						var device = this._device;
						def = generator.createShaderDefinition(device, options);
						var _def_name;
						def.name = (_def_name = def.name) != null ? _def_name : options.pass ? name + "-pass:" + options.pass : name;
						this.definitionsCache.set(key, def);
				}
				return def;
		}
		getCachedShader(key) {
				return this.processedCache.get(key);
		}
		setCachedShader(key, shader) {
				this.processedCache.set(key, shader);
		}
		getProgram(name, options, processingOptions, userMaterialId) {
				var generator = this._generators.get(name);
				if (!generator) {
						return null;
				}
				var generationKeyString = generator.generateKey(options);
				var generationKey = hashCode(generationKeyString);
				var processingKeyString = processingOptions.generateKey(this._device);
				var processingKey = hashCode(processingKeyString);
				var totalKey = generationKey + "#" + processingKey;
				var processedShader = this.getCachedShader(totalKey);
				if (!processedShader) {
						var generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);
						var passName = '';
						var shaderPassInfo;
						if (options.pass !== undefined) {
								shaderPassInfo = ShaderPass.get(this._device).getByIndex(options.pass);
								passName = "-" + shaderPassInfo.name;
						}
						this._device.fire('shader:generate', {
								userMaterialId,
								shaderPassInfo,
								definition: generatedShaderDef
						});
						var shaderDefinition = {
								name: "" + generatedShaderDef.name + passName + "-proc",
								attributes: generatedShaderDef.attributes,
								vshader: generatedShaderDef.vshader,
								vincludes: generatedShaderDef.vincludes,
								fincludes: generatedShaderDef.fincludes,
								fshader: generatedShaderDef.fshader,
								processingOptions: processingOptions,
								shaderLanguage: generatedShaderDef.shaderLanguage,
								meshUniformBufferFormat: generatedShaderDef.meshUniformBufferFormat,
								meshBindGroupFormat: generatedShaderDef.meshBindGroupFormat
						};
						processedShader = new Shader(this._device, shaderDefinition);
						this.setCachedShader(totalKey, processedShader);
				}
				return processedShader;
		}
		storeNewProgram(name, options) {
				var opt = {};
				if (name === 'standard') {
						var defaultMat = this._getDefaultStdMatOptions(options.pass);
						for(var p in options){
								if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === 'pass') {
										opt[p] = options[p];
								}
						}
						for(var p1 in options.litOptions){
								opt[p1] = options.litOptions[p1];
						}
				} else {
						opt = options;
				}
				this._programsCollection.push(JSON.stringify({
						name: name,
						options: opt
				}));
		}
		dumpPrograms() {
				var text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
				text += 'let shaders = [';
				if (this._programsCollection[0]) {
						text += "\n	" + this._programsCollection[0];
				}
				for(var i = 1; i < this._programsCollection.length; ++i){
						text += ",\n	" + this._programsCollection[i];
				}
				text += '\n];\n';
				text += 'pc.getProgramLibrary(device).precompile(shaders);\n';
				text += 'if (pc.version != "' + version + '" || pc.revision != "' + revision + '")\n';
				text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
				var element = document.createElement('a');
				element.setAttribute('href', "data:text/plain;charset=utf-8," + encodeURIComponent(text));
				element.setAttribute('download', 'precompile-shaders.js');
				element.style.display = 'none';
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
		}
		clearCache() {
				this._isClearingCache = true;
				this.processedCache.forEach((shader)=>{
						shader.destroy();
				});
				this.processedCache.clear();
				this._isClearingCache = false;
		}
		removeFromCache(shader) {
				if (this._isClearingCache) {
						return;
				}
				this.processedCache.forEach((cachedShader, key)=>{
						if (shader === cachedShader) {
								this.processedCache.delete(key);
						}
				});
		}
		_getDefaultStdMatOptions(pass) {
				var shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);
				return pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
		}
		precompile(cache) {
				if (cache) {
						var shaders = new Array(cache.length);
						for(var i = 0; i < cache.length; i++){
								if (cache[i].name === 'standard') {
										var opt = cache[i].options;
										var defaultMat = this._getDefaultStdMatOptions(opt.pass);
										for(var p in defaultMat){
												if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) {
														opt[p] = defaultMat[p];
												}
										}
								}
								shaders[i] = this.getProgram(cache[i].name, cache[i].options);
						}
				}
				this._precached = true;
		}
		constructor(device, standardMaterial){
				this.processedCache = new Map();
				this.definitionsCache = new Map();
				this._generators = new Map();
				this._device = device;
				this._isClearingCache = false;
				this._precached = false;
				this._programsCollection = [];
				this._defaultStdMatOption = new StandardMaterialOptions();
				this._defaultStdMatOptionMin = new StandardMaterialOptions();
				var defaultCameraShaderParams = new CameraShaderParams();
				standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, defaultCameraShaderParams, standardMaterial, null, [], SHADER_FORWARD, null);
				standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);
				device.on('destroy:shader', (shader)=>{
						this.removeFromCache(shader);
				});
		}
}

var bakeDirLmEndPS = "\n	vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n	if (bakeDir > 0.5) {\n		if (dAtten > 0.00001) {\n			dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n			dAtten = saturate(dAtten);\n			gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n			gl_FragColor.a = dirLm.w + dAtten;\n			gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n		} else {\n			gl_FragColor = dirLm;\n		}\n	} else {\n		gl_FragColor.rgb = dirLm.xyz;\n		gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n	}\n";

var bakeLmEndPS = "\n#ifdef LIGHTMAP_RGBM\n	gl_FragColor.rgb = dDiffuseLight;\n	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n	gl_FragColor.rgb /= 8.0;\n	gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n	gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n	gl_FragColor.rgb /= gl_FragColor.a;\n#else\n	gl_FragColor = vec4(dDiffuseLight, 1.0);\n#endif\n";

var dilatePS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nbool isUsed(vec4 pixel) {\n	#if HDR\n		return any(greaterThan(pixel.rgb, vec3(0.0)));\n	#else\n		return pixel.a > 0.0;\n	#endif\n}\nvoid main(void) {\n	vec4 c = texture2DLod(source, vUv0, 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 - pixelOffset, 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(0, pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + pixelOffset, 0.0);\n	gl_FragColor = c;\n}\n";

var bilateralDeNoisePS = "\nfloat normpdf3(in vec3 v, in float sigma) {\n	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n	return color * color;\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n	vec4 encoded;\n	encoded.rgb = pow(color.rgb, vec3(0.5));\n	encoded.rgb *= 1.0 / 8.0;\n	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n	encoded.a = ceil(encoded.a * 255.0) / 255.0;\n	encoded.rgb /= encoded.a;\n	return encoded;\n}\nvec3 decode(vec4 pixel) {\n	#if HDR\n		return pixel.rgb;\n	#else\n		return decodeRGBM(pixel);\n	#endif\n}\nbool isUsed(vec4 pixel) {\n	#if HDR\n		return any(greaterThan(pixel.rgb, vec3(0.0)));\n	#else\n		return pixel.a > 0.0;\n	#endif\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n	\n	vec4 pixel = texture2DLod(source, vUv0, 0.0);\n	if (!isUsed(pixel)) {\n		gl_FragColor = pixel;\n		return ;\n	}\n	float sigma = sigmas.x;\n	float bSigma = sigmas.y;\n	vec3 pixelHdr = decode(pixel);\n	vec3 accumulatedHdr = vec3(0.0);\n	float accumulatedFactor = 0.000001;\n	const int kSize = (MSIZE-1)/2;\n	for (int i = -kSize; i <= kSize; ++i) {\n		for (int j = -kSize; j <= kSize; ++j) {\n			\n			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n			vec4 pix = texture2DLod(source, coord, 0.0);\n			if (isUsed(pix)) {\n				vec3 hdr = decode(pix);\n				float factor = kernel[kSize + j] * kernel[kSize + i];\n				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n				accumulatedHdr += factor * hdr;\n				accumulatedFactor += factor;\n			}\n		}\n	}\n	vec3 finalHDR = accumulatedHdr / accumulatedFactor;\n	#if HDR\n		gl_FragColor = vec4(finalHDR, 1.0);\n	#else\n		gl_FragColor = encodeRGBM(finalHDR);\n	#endif\n}\n";

var shaderChunksLightmapper = {
		bakeDirLmEndPS,
		bakeLmEndPS,
		dilatePS,
		bilateralDeNoisePS
};

var mat4$1 = new Mat4();
var quat$2 = new Quat();
var aabb = new BoundingBox();
var aabb2 = new BoundingBox();
var debugColor = new Color(1, 1, 0, 0.4);
var SH_C0$1 = 0.28209479177387814;
class SplatIterator {
		constructor(gsplatData, p, r, s, c){
				var x = gsplatData.getProp('x');
				var y = gsplatData.getProp('y');
				var z = gsplatData.getProp('z');
				var rx = gsplatData.getProp('rot_1');
				var ry = gsplatData.getProp('rot_2');
				var rz = gsplatData.getProp('rot_3');
				var rw = gsplatData.getProp('rot_0');
				var sx = gsplatData.getProp('scale_0');
				var sy = gsplatData.getProp('scale_1');
				var sz = gsplatData.getProp('scale_2');
				var cr = gsplatData.getProp('f_dc_0');
				var cg = gsplatData.getProp('f_dc_1');
				var cb = gsplatData.getProp('f_dc_2');
				var ca = gsplatData.getProp('opacity');
				var sigmoid = (v)=>{
						if (v > 0) {
								return 1 / (1 + Math.exp(-v));
						}
						var t = Math.exp(v);
						return t / (1 + t);
				};
				this.read = (i)=>{
						if (p) {
								p.x = x[i];
								p.y = y[i];
								p.z = z[i];
						}
						if (r) {
								r.set(rx[i], ry[i], rz[i], rw[i]);
						}
						if (s) {
								s.set(Math.exp(sx[i]), Math.exp(sy[i]), Math.exp(sz[i]));
						}
						if (c) {
								c.set(0.5 + cr[i] * SH_C0$1, 0.5 + cg[i] * SH_C0$1, 0.5 + cb[i] * SH_C0$1, sigmoid(ca[i]));
						}
				};
		}
}
var calcSplatMat = (result, p, r)=>{
		quat$2.set(r.x, r.y, r.z, r.w).normalize();
		result.setTRS(p, quat$2, Vec3.ONE);
};
class GSplatData {
		static calcSplatAabb(result, p, r, s) {
				calcSplatMat(mat4$1, p, r);
				aabb.center.set(0, 0, 0);
				aabb.halfExtents.set(s.x * 2, s.y * 2, s.z * 2);
				result.setFromTransformedAabb(aabb, mat4$1);
		}
		getProp(name, elementName) {
				if (elementName === void 0) elementName = 'vertex';
				var _this_getElement_properties_find, _this_getElement;
				return (_this_getElement = this.getElement(elementName)) == null ? void 0 : (_this_getElement_properties_find = _this_getElement.properties.find((p)=>p.name === name)) == null ? void 0 : _this_getElement_properties_find.storage;
		}
		getElement(name) {
				return this.elements.find((e)=>e.name === name);
		}
		addProp(name, storage) {
				this.getElement('vertex').properties.push({
						type: 'float',
						name,
						storage,
						byteSize: 4
				});
		}
		createIter(p, r, s, c) {
				return new SplatIterator(this, p, r, s, c);
		}
		calcAabb(result, pred) {
				var mx, my, mz, Mx, My, Mz;
				var first = true;
				var x = this.getProp('x');
				var y = this.getProp('y');
				var z = this.getProp('z');
				var sx = this.getProp('scale_0');
				var sy = this.getProp('scale_1');
				var sz = this.getProp('scale_2');
				for(var i = 0; i < this.numSplats; ++i){
						if (pred && !pred(i)) {
								continue;
						}
						var scaleVal = 2.0 * Math.exp(Math.max(sx[i], sy[i], sz[i]));
						var px = x[i];
						var py = y[i];
						var pz = z[i];
						if (first) {
								first = false;
								mx = px - scaleVal;
								my = py - scaleVal;
								mz = pz - scaleVal;
								Mx = px + scaleVal;
								My = py + scaleVal;
								Mz = pz + scaleVal;
						} else {
								mx = Math.min(mx, px - scaleVal);
								my = Math.min(my, py - scaleVal);
								mz = Math.min(mz, pz - scaleVal);
								Mx = Math.max(Mx, px + scaleVal);
								My = Math.max(My, py + scaleVal);
								Mz = Math.max(Mz, pz + scaleVal);
						}
				}
				if (!first) {
						result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
						result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
				}
				return !first;
		}
		calcAabbExact(result, pred) {
				var p = new Vec3();
				var r = new Quat();
				var s = new Vec3();
				var iter = this.createIter(p, r, s);
				var first = true;
				for(var i = 0; i < this.numSplats; ++i){
						if (pred && !pred(i)) {
								continue;
						}
						iter.read(i);
						if (first) {
								first = false;
								GSplatData.calcSplatAabb(result, p, r, s);
						} else {
								GSplatData.calcSplatAabb(aabb2, p, r, s);
								result.add(aabb2);
						}
				}
				return !first;
		}
		getCenters(result) {
				var x = this.getProp('x');
				var y = this.getProp('y');
				var z = this.getProp('z');
				for(var i = 0; i < this.numSplats; ++i){
						result[i * 3 + 0] = x[i];
						result[i * 3 + 1] = y[i];
						result[i * 3 + 2] = z[i];
				}
		}
		calcFocalPoint(result, pred) {
				var x = this.getProp('x');
				var y = this.getProp('y');
				var z = this.getProp('z');
				var sx = this.getProp('scale_0');
				var sy = this.getProp('scale_1');
				var sz = this.getProp('scale_2');
				result.x = 0;
				result.y = 0;
				result.z = 0;
				var sum = 0;
				for(var i = 0; i < this.numSplats; ++i){
						if (pred && !pred(i)) {
								continue;
						}
						var weight = 1.0 / (1.0 + Math.exp(Math.max(sx[i], sy[i], sz[i])));
						result.x += x[i] * weight;
						result.y += y[i] * weight;
						result.z += z[i] * weight;
						sum += weight;
				}
				result.mulScalar(1 / sum);
		}
		renderWireframeBounds(scene, worldMat) {
				var p = new Vec3();
				var r = new Quat();
				var s = new Vec3();
				var min = new Vec3();
				var max = new Vec3();
				var iter = this.createIter(p, r, s);
				for(var i = 0; i < this.numSplats; ++i){
						iter.read(i);
						calcSplatMat(mat4$1, p, r);
						mat4$1.mul2(worldMat, mat4$1);
						min.set(s.x * -2, s.y * -2, s.z * -2);
						max.set(s.x * 2.0, s.y * 2.0, s.z * 2.0);
						scene.immediate.drawWireAlignedBox(min, max, debugColor, true, scene.defaultDrawLayer, mat4$1);
				}
		}
		get isCompressed() {
				return false;
		}
		get shBands() {
				var numProps = ()=>{
						for(var i = 0; i < 45; ++i){
								if (!this.getProp("f_rest_" + i)) {
										return i;
								}
						}
						return 45;
				};
				var sizes = {
						9: 1,
						24: 2,
						45: 3
				};
				var _sizes_numProps;
				return (_sizes_numProps = sizes[numProps()]) != null ? _sizes_numProps : 0;
		}
		calcMortonOrder() {
				var calcMinMax = (arr)=>{
						var min = arr[0];
						var max = arr[0];
						for(var i = 1; i < arr.length; i++){
								if (arr[i] < min) min = arr[i];
								if (arr[i] > max) max = arr[i];
						}
						return {
								min,
								max
						};
				};
				var encodeMorton3 = (x, y, z)=>{
						var Part1By2 = (x)=>{
								x &= 0x000003ff;
								x = (x ^ x << 16) & 0xff0000ff;
								x = (x ^ x << 8) & 0x0300f00f;
								x = (x ^ x << 4) & 0x030c30c3;
								x = (x ^ x << 2) & 0x09249249;
								return x;
						};
						return (Part1By2(z) << 2) + (Part1By2(y) << 1) + Part1By2(x);
				};
				var x = this.getProp('x');
				var y = this.getProp('y');
				var z = this.getProp('z');
				var { min: minX, max: maxX } = calcMinMax(x);
				var { min: minY, max: maxY } = calcMinMax(y);
				var { min: minZ, max: maxZ } = calcMinMax(z);
				var sizeX = minX === maxX ? 0 : 1024 / (maxX - minX);
				var sizeY = minY === maxY ? 0 : 1024 / (maxY - minY);
				var sizeZ = minZ === maxZ ? 0 : 1024 / (maxZ - minZ);
				var codes = new Map();
				for(var i = 0; i < this.numSplats; i++){
						var ix = Math.floor((x[i] - minX) * sizeX);
						var iy = Math.floor((y[i] - minY) * sizeY);
						var iz = Math.floor((z[i] - minZ) * sizeZ);
						var code = encodeMorton3(ix, iy, iz);
						var val = codes.get(code);
						if (val) {
								val.push(i);
						} else {
								codes.set(code, [
										i
								]);
						}
				}
				var keys = Array.from(codes.keys()).sort((a, b)=>a - b);
				var indices = new Uint32Array(this.numSplats);
				var idx = 0;
				for(var i1 = 0; i1 < keys.length; ++i1){
						var val1 = codes.get(keys[i1]);
						for(var j = 0; j < val1.length; ++j){
								indices[idx++] = val1[j];
						}
				}
				return indices;
		}
		reorder(order) {
				var cache = new Map();
				var getStorage = (size)=>{
						if (cache.has(size)) {
								var buffer = cache.get(size);
								cache.delete(size);
								return buffer;
						}
						return new ArrayBuffer(size);
				};
				var returnStorage = (buffer)=>{
						cache.set(buffer.byteLength, buffer);
				};
				var reorder = (data)=>{
						var result = new data.constructor(getStorage(data.byteLength));
						for(var i = 0; i < order.length; i++){
								result[i] = data[order[i]];
						}
						returnStorage(data.buffer);
						return result;
				};
				this.elements.forEach((element)=>{
						element.properties.forEach((property)=>{
								if (property.storage) {
										property.storage = reorder(property.storage);
								}
						});
				});
		}
		reorderData() {
				this.reorder(this.calcMortonOrder());
		}
		constructor(elements){
				this.elements = elements;
				this.numSplats = this.getElement('vertex').count;
		}
}

var createGSplatMaterial = (options)=>{
		if (options === void 0) options = {};
		var _options_dither;
		var ditherEnum = (_options_dither = options.dither) != null ? _options_dither : DITHER_NONE;
		var dither = ditherEnum !== DITHER_NONE;
		var _options_vertex, _options_fragment;
		var material = new ShaderMaterial({
				uniqueName: 'SplatMaterial',
				vertexCode: (_options_vertex = options.vertex) != null ? _options_vertex : shaderChunks.gsplatVS,
				fragmentCode: (_options_fragment = options.fragment) != null ? _options_fragment : shaderChunks.gsplatPS,
				attributes: {
						vertex_position: SEMANTIC_POSITION,
						vertex_id_attrib: SEMANTIC_ATTR13
				}
		});
		material.setDefine("DITHER_" + ditherEnum.toUpperCase(), '');
		material.cull = CULLFACE_NONE;
		material.blendType = dither ? BLEND_NONE : BLEND_PREMULTIPLIED;
		material.depthWrite = dither;
		material.update();
		return material;
};

var getSHData = (gsplatData, numCoeffs)=>{
		var result = [];
		for(var i = 0; i < numCoeffs; ++i){
				result.push(gsplatData.getProp("f_rest_" + i));
		}
		return result;
};
class GSplat {
		destroy() {
				var _this_colorTexture, _this_transformATexture, _this_transformBTexture, _this_sh1to3Texture, _this_sh4to7Texture, _this_sh8to11Texture, _this_sh12to15Texture;
				(_this_colorTexture = this.colorTexture) == null ? void 0 : _this_colorTexture.destroy();
				(_this_transformATexture = this.transformATexture) == null ? void 0 : _this_transformATexture.destroy();
				(_this_transformBTexture = this.transformBTexture) == null ? void 0 : _this_transformBTexture.destroy();
				(_this_sh1to3Texture = this.sh1to3Texture) == null ? void 0 : _this_sh1to3Texture.destroy();
				(_this_sh4to7Texture = this.sh4to7Texture) == null ? void 0 : _this_sh4to7Texture.destroy();
				(_this_sh8to11Texture = this.sh8to11Texture) == null ? void 0 : _this_sh8to11Texture.destroy();
				(_this_sh12to15Texture = this.sh12to15Texture) == null ? void 0 : _this_sh12to15Texture.destroy();
		}
		createMaterial(options) {
				var result = createGSplatMaterial(options);
				result.setParameter('splatColor', this.colorTexture);
				result.setParameter('transformA', this.transformATexture);
				result.setParameter('transformB', this.transformBTexture);
				result.setParameter('numSplats', this.numSplatsVisible);
				result.setDefine('SH_BANDS', this.shBands);
				if (this.sh1to3Texture) result.setParameter('splatSH_1to3', this.sh1to3Texture);
				if (this.sh4to7Texture) result.setParameter('splatSH_4to7', this.sh4to7Texture);
				if (this.sh8to11Texture) result.setParameter('splatSH_8to11', this.sh8to11Texture);
				if (this.sh12to15Texture) result.setParameter('splatSH_12to15', this.sh12to15Texture);
				return result;
		}
		evalTextureSize(count) {
				var width = Math.ceil(Math.sqrt(count));
				var height = Math.ceil(count / width);
				return new Vec2(width, height);
		}
		createTexture(name, format, size) {
				return new Texture(this.device, {
						name: name,
						width: size.x,
						height: size.y,
						format: format,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
		}
		updateColorData(gsplatData) {
				var texture = this.colorTexture;
				if (!texture) {
						return;
				}
				var float2Half = FloatPacking.float2Half;
				var data = texture.lock();
				var cr = gsplatData.getProp('f_dc_0');
				var cg = gsplatData.getProp('f_dc_1');
				var cb = gsplatData.getProp('f_dc_2');
				var ca = gsplatData.getProp('opacity');
				var SH_C0 = 0.28209479177387814;
				for(var i = 0; i < this.numSplats; ++i){
						var r = cr[i] * SH_C0 + 0.5;
						var g = cg[i] * SH_C0 + 0.5;
						var b = cb[i] * SH_C0 + 0.5;
						var a = 1 / (1 + Math.exp(-ca[i]));
						data[i * 4 + 0] = float2Half(r);
						data[i * 4 + 1] = float2Half(g);
						data[i * 4 + 2] = float2Half(b);
						data[i * 4 + 3] = float2Half(a);
				}
				texture.unlock();
		}
		updateTransformData(gsplatData) {
				var float2Half = FloatPacking.float2Half;
				if (!this.transformATexture) {
						return;
				}
				var dataA = this.transformATexture.lock();
				var dataAFloat32 = new Float32Array(dataA.buffer);
				var dataB = this.transformBTexture.lock();
				var p = new Vec3();
				var r = new Quat();
				var s = new Vec3();
				var iter = gsplatData.createIter(p, r, s);
				for(var i = 0; i < this.numSplats; i++){
						iter.read(i);
						r.normalize();
						if (r.w < 0) {
								r.mulScalar(-1);
						}
						dataAFloat32[i * 4 + 0] = p.x;
						dataAFloat32[i * 4 + 1] = p.y;
						dataAFloat32[i * 4 + 2] = p.z;
						dataA[i * 4 + 3] = float2Half(r.x) | float2Half(r.y) << 16;
						dataB[i * 4 + 0] = float2Half(s.x);
						dataB[i * 4 + 1] = float2Half(s.y);
						dataB[i * 4 + 2] = float2Half(s.z);
						dataB[i * 4 + 3] = float2Half(r.z);
				}
				this.transformATexture.unlock();
				this.transformBTexture.unlock();
		}
		updateSHData(gsplatData) {
				var _this_sh4to7Texture, _this_sh8to11Texture, _this_sh12to15Texture, _this_sh4to7Texture1, _this_sh8to11Texture1, _this_sh12to15Texture1;
				var sh1to3Data = this.sh1to3Texture.lock();
				var sh4to7Data = (_this_sh4to7Texture = this.sh4to7Texture) == null ? void 0 : _this_sh4to7Texture.lock();
				var sh8to11Data = (_this_sh8to11Texture = this.sh8to11Texture) == null ? void 0 : _this_sh8to11Texture.lock();
				var sh12to15Data = (_this_sh12to15Texture = this.sh12to15Texture) == null ? void 0 : _this_sh12to15Texture.lock();
				var numCoeffs = {
						1: 3,
						2: 8,
						3: 15
				}[this.shBands];
				var src = getSHData(gsplatData, numCoeffs * 3);
				var t11 = (1 << 11) - 1;
				var t10 = (1 << 10) - 1;
				var float32 = new Float32Array(1);
				var uint32 = new Uint32Array(float32.buffer);
				var c = new Array(numCoeffs * 3).fill(0);
				for(var i = 0; i < gsplatData.numSplats; ++i){
						for(var j = 0; j < numCoeffs; ++j){
								c[j * 3] = src[j][i];
								c[j * 3 + 1] = src[j + numCoeffs][i];
								c[j * 3 + 2] = src[j + numCoeffs * 2][i];
						}
						var max = c[0];
						for(var j1 = 1; j1 < numCoeffs * 3; ++j1){
								max = Math.max(max, Math.abs(c[j1]));
						}
						if (max === 0) {
								continue;
						}
						for(var j2 = 0; j2 < numCoeffs; ++j2){
								c[j2 * 3 + 0] = Math.max(0, Math.min(t11, Math.floor((c[j2 * 3 + 0] / max * 0.5 + 0.5) * t11 + 0.5)));
								c[j2 * 3 + 1] = Math.max(0, Math.min(t10, Math.floor((c[j2 * 3 + 1] / max * 0.5 + 0.5) * t10 + 0.5)));
								c[j2 * 3 + 2] = Math.max(0, Math.min(t11, Math.floor((c[j2 * 3 + 2] / max * 0.5 + 0.5) * t11 + 0.5)));
						}
						float32[0] = max;
						sh1to3Data[i * 4 + 0] = uint32[0];
						sh1to3Data[i * 4 + 1] = c[0] << 21 | c[1] << 11 | c[2];
						sh1to3Data[i * 4 + 2] = c[3] << 21 | c[4] << 11 | c[5];
						sh1to3Data[i * 4 + 3] = c[6] << 21 | c[7] << 11 | c[8];
						if (this.shBands > 1) {
								sh4to7Data[i * 4 + 0] = c[9] << 21 | c[10] << 11 | c[11];
								sh4to7Data[i * 4 + 1] = c[12] << 21 | c[13] << 11 | c[14];
								sh4to7Data[i * 4 + 2] = c[15] << 21 | c[16] << 11 | c[17];
								sh4to7Data[i * 4 + 3] = c[18] << 21 | c[19] << 11 | c[20];
								if (this.shBands > 2) {
										sh8to11Data[i * 4 + 0] = c[21] << 21 | c[22] << 11 | c[23];
										sh8to11Data[i * 4 + 1] = c[24] << 21 | c[25] << 11 | c[26];
										sh8to11Data[i * 4 + 2] = c[27] << 21 | c[28] << 11 | c[29];
										sh8to11Data[i * 4 + 3] = c[30] << 21 | c[31] << 11 | c[32];
										sh12to15Data[i * 4 + 0] = c[33] << 21 | c[34] << 11 | c[35];
										sh12to15Data[i * 4 + 1] = c[36] << 21 | c[37] << 11 | c[38];
										sh12to15Data[i * 4 + 2] = c[39] << 21 | c[40] << 11 | c[41];
										sh12to15Data[i * 4 + 3] = c[42] << 21 | c[43] << 11 | c[44];
								} else {
										sh8to11Data[i] = c[21] << 21 | c[22] << 11 | c[23];
								}
						}
				}
				this.sh1to3Texture.unlock();
				(_this_sh4to7Texture1 = this.sh4to7Texture) == null ? void 0 : _this_sh4to7Texture1.unlock();
				(_this_sh8to11Texture1 = this.sh8to11Texture) == null ? void 0 : _this_sh8to11Texture1.unlock();
				(_this_sh12to15Texture1 = this.sh12to15Texture) == null ? void 0 : _this_sh12to15Texture1.unlock();
		}
		constructor(device, gsplatData){
				var numSplats = gsplatData.numSplats;
				this.device = device;
				this.numSplats = numSplats;
				this.numSplatsVisible = numSplats;
				this.centers = new Float32Array(gsplatData.numSplats * 3);
				gsplatData.getCenters(this.centers);
				this.aabb = new BoundingBox();
				gsplatData.calcAabb(this.aabb);
				var size = this.evalTextureSize(numSplats);
				this.colorTexture = this.createTexture('splatColor', PIXELFORMAT_RGBA16F, size);
				this.transformATexture = this.createTexture('transformA', PIXELFORMAT_RGBA32U, size);
				this.transformBTexture = this.createTexture('transformB', PIXELFORMAT_RGBA16F, size);
				this.updateColorData(gsplatData);
				this.updateTransformData(gsplatData);
				this.shBands = gsplatData.shBands;
				if (this.shBands > 0) {
						this.sh1to3Texture = this.createTexture('splatSH_1to3', PIXELFORMAT_RGBA32U, size);
						if (this.shBands > 1) {
								this.sh4to7Texture = this.createTexture('splatSH_4to7', PIXELFORMAT_RGBA32U, size);
								if (this.shBands > 2) {
										this.sh8to11Texture = this.createTexture('splatSH_8to11', PIXELFORMAT_RGBA32U, size);
										this.sh12to15Texture = this.createTexture('splatSH_12to15', PIXELFORMAT_RGBA32U, size);
								} else {
										this.sh8to11Texture = this.createTexture('splatSH_8to11', PIXELFORMAT_R32U, size);
								}
						}
						this.updateSHData(gsplatData);
				}
		}
}

function SortWorker() {
		var order;
		var centers;
		var chunks;
		var mapping;
		var cameraPosition;
		var cameraDirection;
		var forceUpdate = false;
		var lastCameraPosition = {
				x: 0,
				y: 0,
				z: 0
		};
		var lastCameraDirection = {
				x: 0,
				y: 0,
				z: 0
		};
		var boundMin = {
				x: 0,
				y: 0,
				z: 0
		};
		var boundMax = {
				x: 0,
				y: 0,
				z: 0
		};
		var distances;
		var countBuffer;
		var numBins = 32;
		var binCount = new Array(numBins).fill(0);
		var binBase = new Array(numBins).fill(0);
		var binDivider = new Array(numBins).fill(0);
		var binarySearch = (m, n, compare_fn)=>{
				while(m <= n){
						var k = n + m >> 1;
						var cmp = compare_fn(k);
						if (cmp > 0) {
								m = k + 1;
						} else if (cmp < 0) {
								n = k - 1;
						} else {
								return k;
						}
				}
				return ~m;
		};
		var update = ()=>{
				if (!order || !centers || centers.length === 0 || !cameraPosition || !cameraDirection) return;
				var px = cameraPosition.x;
				var py = cameraPosition.y;
				var pz = cameraPosition.z;
				var dx = cameraDirection.x;
				var dy = cameraDirection.y;
				var dz = cameraDirection.z;
				var epsilon = 0.001;
				if (!forceUpdate && Math.abs(px - lastCameraPosition.x) < epsilon && Math.abs(py - lastCameraPosition.y) < epsilon && Math.abs(pz - lastCameraPosition.z) < epsilon && Math.abs(dx - lastCameraDirection.x) < epsilon && Math.abs(dy - lastCameraDirection.y) < epsilon && Math.abs(dz - lastCameraDirection.z) < epsilon) {
						return;
				}
				forceUpdate = false;
				lastCameraPosition.x = px;
				lastCameraPosition.y = py;
				lastCameraPosition.z = pz;
				lastCameraDirection.x = dx;
				lastCameraDirection.y = dy;
				lastCameraDirection.z = dz;
				var minDist;
				var maxDist;
				for(var i = 0; i < 8; ++i){
						var x = i & 1 ? boundMin.x : boundMax.x;
						var y = i & 2 ? boundMin.y : boundMax.y;
						var z = i & 4 ? boundMin.z : boundMax.z;
						var d = x * dx + y * dy + z * dz;
						if (i === 0) {
								minDist = maxDist = d;
						} else {
								minDist = Math.min(minDist, d);
								maxDist = Math.max(maxDist, d);
						}
				}
				var numVertices = centers.length / 3;
				var compareBits = Math.max(10, Math.min(20, Math.round(Math.log2(numVertices / 4))));
				var bucketCount = 2 ** compareBits + 1;
				if ((distances == null ? void 0 : distances.length) !== numVertices) {
						distances = new Uint32Array(numVertices);
				}
				if (!countBuffer || countBuffer.length !== bucketCount) {
						countBuffer = new Uint32Array(bucketCount);
				} else {
						countBuffer.fill(0);
				}
				var range = maxDist - minDist;
				if (range < 1e-6) {
						for(var i1 = 0; i1 < numVertices; ++i1){
								distances[i1] = 0;
								countBuffer[0]++;
						}
				} else if (chunks) {
						var numChunks = chunks.length / 6;
						binCount.fill(0);
						for(var i2 = 0; i2 < numChunks; ++i2){
								var x1 = chunks[i2 * 6 + 0];
								var y1 = chunks[i2 * 6 + 1];
								var z1 = chunks[i2 * 6 + 2];
								var r = chunks[i2 * 6 + 3];
								var d1 = x1 * dx + y1 * dy + z1 * dz - minDist;
								var binMin = Math.max(0, Math.floor((d1 - r) * numBins / range));
								var binMax = Math.min(numBins, Math.ceil((d1 + r) * numBins / range));
								for(var j = binMin; j < binMax; ++j){
										binCount[j]++;
								}
						}
						var binTotal = binCount.reduce((a, b)=>a + b, 0);
						for(var i3 = 0; i3 < numBins; ++i3){
								binDivider[i3] = binCount[i3] / binTotal * bucketCount >>> 0;
						}
						for(var i4 = 0; i4 < numBins; ++i4){
								binBase[i4] = i4 === 0 ? 0 : binBase[i4 - 1] + binDivider[i4 - 1];
						}
						var binRange = range / numBins;
						var ii = 0;
						for(var i5 = 0; i5 < numVertices; ++i5){
								var x2 = centers[ii++];
								var y2 = centers[ii++];
								var z2 = centers[ii++];
								var d2 = (x2 * dx + y2 * dy + z2 * dz - minDist) / binRange;
								var bin = d2 >>> 0;
								var sortKey = binBase[bin] + binDivider[bin] * (d2 - bin) >>> 0;
								distances[i5] = sortKey;
								countBuffer[sortKey]++;
						}
				} else {
						var divider = 2 ** compareBits / range;
						var ii1 = 0;
						for(var i6 = 0; i6 < numVertices; ++i6){
								var x3 = centers[ii1++];
								var y3 = centers[ii1++];
								var z3 = centers[ii1++];
								var d3 = (x3 * dx + y3 * dy + z3 * dz - minDist) * divider;
								var sortKey1 = d3 >>> 0;
								distances[i6] = sortKey1;
								countBuffer[sortKey1]++;
						}
				}
				for(var i7 = 1; i7 < bucketCount; i7++){
						countBuffer[i7] += countBuffer[i7 - 1];
				}
				for(var i8 = 0; i8 < numVertices; i8++){
						var distance = distances[i8];
						var destIndex = --countBuffer[distance];
						order[destIndex] = i8;
				}
				var cameraDist = px * dx + py * dy + pz * dz;
				var dist = (i)=>{
						var o = order[i] * 3;
						return centers[o++] * dx + centers[o++] * dy + centers[o] * dz - cameraDist;
				};
				var findZero = ()=>{
						var result = binarySearch(0, numVertices - 1, (i)=>-dist(i));
						return Math.min(numVertices, Math.abs(result));
				};
				var count = dist(numVertices - 1) >= 0 ? findZero() : numVertices;
				if (mapping) {
						for(var i9 = 0; i9 < numVertices; ++i9){
								order[i9] = mapping[order[i9]];
						}
				}
				self.postMessage({
						order: order.buffer,
						count
				}, [
						order.buffer
				]);
				order = null;
		};
		self.onmessage = (message)=>{
				if (message.data.order) {
						order = new Uint32Array(message.data.order);
				}
				if (message.data.centers) {
						centers = new Float32Array(message.data.centers);
						forceUpdate = true;
						var initialized = false;
						var numVertices = centers.length / 3;
						for(var i = 0; i < numVertices; ++i){
								var x = centers[i * 3 + 0];
								var y = centers[i * 3 + 1];
								var z = centers[i * 3 + 2];
								if (isNaN(x)) {
										x = centers[i * 3 + 0] = 0;
								}
								if (isNaN(y)) {
										y = centers[i * 3 + 1] = 0;
								}
								if (isNaN(z)) {
										z = centers[i * 3 + 2] = 0;
								}
								if (!initialized) {
										initialized = true;
										boundMin.x = boundMax.x = x;
										boundMin.y = boundMax.y = y;
										boundMin.z = boundMax.z = z;
								} else {
										boundMin.x = Math.min(boundMin.x, x);
										boundMax.x = Math.max(boundMax.x, x);
										boundMin.y = Math.min(boundMin.y, y);
										boundMax.y = Math.max(boundMax.y, y);
										boundMin.z = Math.min(boundMin.z, z);
										boundMax.z = Math.max(boundMax.z, z);
								}
						}
						if (!initialized) {
								boundMin.x = boundMax.x = boundMin.y = boundMax.y = boundMin.z = boundMax.z = 0;
						}
				}
				if (message.data.chunks) {
						chunks = new Float32Array(message.data.chunks);
						forceUpdate = true;
						for(var i1 = 0; i1 < chunks.length / 6; ++i1){
								var mx = chunks[i1 * 6 + 0];
								var my = chunks[i1 * 6 + 1];
								var mz = chunks[i1 * 6 + 2];
								var Mx = chunks[i1 * 6 + 3];
								var My = chunks[i1 * 6 + 4];
								var Mz = chunks[i1 * 6 + 5];
								chunks[i1 * 6 + 0] = (mx + Mx) * 0.5;
								chunks[i1 * 6 + 1] = (my + My) * 0.5;
								chunks[i1 * 6 + 2] = (mz + Mz) * 0.5;
								chunks[i1 * 6 + 3] = Math.sqrt((Mx - mx) ** 2 + (My - my) ** 2 + (Mz - mz) ** 2) * 0.5;
						}
				}
				if (message.data.hasOwnProperty('mapping')) {
						mapping = message.data.mapping ? new Uint32Array(message.data.mapping) : null;
						forceUpdate = true;
				}
				if (message.data.cameraPosition) cameraPosition = message.data.cameraPosition;
				if (message.data.cameraDirection) cameraDirection = message.data.cameraDirection;
				update();
		};
}
class GSplatSorter extends EventHandler {
		destroy() {
				this.worker.terminate();
				this.worker = null;
		}
		init(orderTexture, centers, chunks) {
				this.orderTexture = orderTexture;
				this.centers = centers.slice();
				var orderBuffer = this.orderTexture.lock({
						mode: TEXTURELOCK_READ
				}).slice();
				this.orderTexture.unlock();
				for(var i = 0; i < orderBuffer.length; ++i){
						orderBuffer[i] = i;
				}
				var obj = {
						order: orderBuffer.buffer,
						centers: centers.buffer,
						chunks: chunks == null ? void 0 : chunks.buffer
				};
				var transfer = [
						orderBuffer.buffer,
						centers.buffer
				].concat(chunks ? [
						chunks.buffer
				] : []);
				this.worker.postMessage(obj, transfer);
		}
		setMapping(mapping) {
				if (mapping) {
						var centers = new Float32Array(mapping.length * 3);
						for(var i = 0; i < mapping.length; ++i){
								var src = mapping[i] * 3;
								var dst = i * 3;
								centers[dst + 0] = this.centers[src + 0];
								centers[dst + 1] = this.centers[src + 1];
								centers[dst + 2] = this.centers[src + 2];
						}
						this.worker.postMessage({
								centers: centers.buffer,
								mapping: mapping.buffer
						}, [
								centers.buffer,
								mapping.buffer
						]);
				} else {
						var centers1 = this.centers.slice();
						this.worker.postMessage({
								centers: centers1.buffer,
								mapping: null
						}, [
								centers1.buffer
						]);
				}
		}
		setCamera(pos, dir) {
				this.worker.postMessage({
						cameraPosition: {
								x: pos.x,
								y: pos.y,
								z: pos.z
						},
						cameraDirection: {
								x: dir.x,
								y: dir.y,
								z: dir.z
						}
				});
		}
		constructor(){
				super();
				this.worker = new Worker(URL.createObjectURL(new Blob([
						"(" + SortWorker.toString() + ")()"
				], {
						type: "application/javascript"
				})));
				this.worker.onmessage = (message)=>{
						var newOrder = message.data.order;
						var oldOrder = this.orderTexture._levels[0].buffer;
						this.worker.postMessage({
								order: oldOrder
						}, [
								oldOrder
						]);
						this.orderTexture._levels[0] = new Uint32Array(newOrder);
						this.orderTexture.upload();
						this.fire('updated', message.data.count);
				};
		}
}

var mat = new Mat4();
var cameraPosition = new Vec3();
var cameraDirection = new Vec3();
var viewport = [
		0,
		0
];
class GSplatInstance {
		destroy() {
				var _this_material, _this_meshInstance, _this_sorter;
				(_this_material = this.material) == null ? void 0 : _this_material.destroy();
				(_this_meshInstance = this.meshInstance) == null ? void 0 : _this_meshInstance.destroy();
				(_this_sorter = this.sorter) == null ? void 0 : _this_sorter.destroy();
		}
		clone() {
				return new GSplatInstance(this.splat, this.options);
		}
		createMaterial(options) {
				this.material = this.splat.createMaterial(options);
				this.material.setParameter('splatOrder', this.orderTexture);
				this.material.setParameter('alphaClip', 0.3);
				if (this.meshInstance) {
						this.meshInstance.material = this.material;
				}
		}
		updateViewport(cameraNode) {
				var camera = cameraNode == null ? void 0 : cameraNode.camera;
				var renderTarget = camera == null ? void 0 : camera.renderTarget;
				var { width, height } = renderTarget != null ? renderTarget : this.splat.device;
				viewport[0] = width;
				viewport[1] = height;
				var xr = camera == null ? void 0 : camera.xr;
				if ((xr == null ? void 0 : xr.active) && xr.views.list.length === 2) {
						viewport[0] *= 0.5;
				}
				this.material.setParameter('viewport', viewport);
		}
		sort(cameraNode) {
				if (this.sorter) {
						var cameraMat = cameraNode.getWorldTransform();
						cameraMat.getTranslation(cameraPosition);
						cameraMat.getZ(cameraDirection);
						var modelMat = this.meshInstance.node.getWorldTransform();
						var invModelMat = mat.invert(modelMat);
						invModelMat.transformPoint(cameraPosition, cameraPosition);
						invModelMat.transformVector(cameraDirection, cameraDirection);
						if (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {
								this.lastCameraPosition.copy(cameraPosition);
								this.lastCameraDirection.copy(cameraDirection);
								this.sorter.setCamera(cameraPosition, cameraDirection);
						}
				}
				this.updateViewport(cameraNode);
		}
		update() {
				if (this.cameras.length > 0) {
						var camera = this.cameras[0];
						this.sort(camera._node);
						this.cameras.length = 0;
				}
		}
		constructor(splat, options){
				var _splat_chunks;
				this.options = {};
				this.sorter = null;
				this.lastCameraPosition = new Vec3();
				this.lastCameraDirection = new Vec3();
				this.cameras = [];
				this.splat = splat;
				options = Object.assign(this.options, options);
				var device = splat.device;
				this.orderTexture = this.splat.createTexture('splatOrder', PIXELFORMAT_R32U, this.splat.evalTextureSize(this.splat.numSplats));
				this.createMaterial(options);
				var splatInstanceSize = 128;
				var numSplats = Math.ceil(splat.numSplats / splatInstanceSize) * splatInstanceSize;
				var numSplatInstances = numSplats / splatInstanceSize;
				var indexData = new Uint32Array(numSplatInstances);
				for(var i = 0; i < numSplatInstances; ++i){
						indexData[i] = i * splatInstanceSize;
				}
				var vertexFormat = new VertexFormat(device, [
						{
								semantic: SEMANTIC_ATTR13,
								components: 1,
								type: TYPE_UINT32,
								asInt: true
						}
				]);
				var indicesVB = new VertexBuffer(device, vertexFormat, numSplatInstances, {
						usage: BUFFER_STATIC,
						data: indexData.buffer
				});
				var meshPositions = new Float32Array(12 * splatInstanceSize);
				var meshIndices = new Uint32Array(6 * splatInstanceSize);
				for(var i1 = 0; i1 < splatInstanceSize; ++i1){
						meshPositions.set([
								-1,
								-1,
								i1,
								1,
								-1,
								i1,
								1,
								1,
								i1,
								-1,
								1,
								i1
						], i1 * 12);
						var b = i1 * 4;
						meshIndices.set([
								0 + b,
								1 + b,
								2 + b,
								0 + b,
								2 + b,
								3 + b
						], i1 * 6);
				}
				var mesh = new Mesh(device);
				mesh.setPositions(meshPositions, 3);
				mesh.setIndices(meshIndices);
				mesh.update();
				this.mesh = mesh;
				this.mesh.aabb.copy(splat.aabb);
				this.meshInstance = new MeshInstance(this.mesh, this.material);
				this.meshInstance.setInstancing(indicesVB, true);
				this.meshInstance.gsplatInstance = this;
				this.meshInstance.instancingCount = 0;
				var centers = splat.centers.slice();
				var chunks = (_splat_chunks = splat.chunks) == null ? void 0 : _splat_chunks.slice();
				if (!options.dither || options.dither === DITHER_NONE) {
						this.sorter = new GSplatSorter();
						this.sorter.init(this.orderTexture, centers, chunks);
						this.sorter.on('updated', (count)=>{
								this.meshInstance.instancingCount = Math.ceil(count / splatInstanceSize);
								this.material.setParameter('numSplats', count);
						});
				}
		}
}

var FILLMODE_NONE = 'NONE';
var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
var RESOLUTION_AUTO = 'AUTO';
var RESOLUTION_FIXED = 'FIXED';

var currentApplication;
function getApplication() {
		return currentApplication;
}
function setApplication(app) {
		currentApplication = app;
}

var _createdLoadingScreen = false;
var script = {
		app: null,
		createLoadingScreen (callback) {
				if (_createdLoadingScreen) {
						return;
				}
				_createdLoadingScreen = true;
				var app = getApplication();
				callback(app);
		}
};

class FrameGraph {
		addRenderPass(renderPass) {
				renderPass.frameUpdate();
				var beforePasses = renderPass.beforePasses;
				for(var i = 0; i < beforePasses.length; i++){
						var pass = beforePasses[i];
						if (pass.enabled) {
								this.addRenderPass(pass);
						}
				}
				if (renderPass.enabled) {
						this.renderPasses.push(renderPass);
				}
				var afterPasses = renderPass.afterPasses;
				for(var i1 = 0; i1 < afterPasses.length; i1++){
						var pass1 = afterPasses[i1];
						if (pass1.enabled) {
								this.addRenderPass(pass1);
						}
				}
		}
		reset() {
				this.renderPasses.length = 0;
		}
		compile() {
				var renderTargetMap = this.renderTargetMap;
				var renderPasses = this.renderPasses;
				for(var i = 0; i < renderPasses.length; i++){
						var renderPass = renderPasses[i];
						var renderTarget = renderPass.renderTarget;
						if (renderTarget !== undefined) {
								var prevPass = renderTargetMap.get(renderTarget);
								if (prevPass) {
										var count = renderPass.colorArrayOps.length;
										for(var j = 0; j < count; j++){
												var colorOps = renderPass.colorArrayOps[j];
												if (!colorOps.clear) {
														prevPass.colorArrayOps[j].store = true;
												}
										}
										if (!renderPass.depthStencilOps.clearDepth) {
												prevPass.depthStencilOps.storeDepth = true;
										}
										if (!renderPass.depthStencilOps.clearStencil) {
												prevPass.depthStencilOps.storeStencil = true;
										}
								}
								renderTargetMap.set(renderTarget, renderPass);
						}
				}
				for(var i1 = 0; i1 < renderPasses.length - 1; i1++){
						var firstPass = renderPasses[i1];
						var firstRT = firstPass.renderTarget;
						var secondPass = renderPasses[i1 + 1];
						var secondRT = secondPass.renderTarget;
						if (firstRT !== secondRT || firstRT === undefined) {
								continue;
						}
						if (secondPass.depthStencilOps.clearDepth || secondPass.depthStencilOps.clearStencil || secondPass.colorArrayOps.some((colorOps)=>colorOps.clear)) {
								continue;
						}
						if (firstPass.afterPasses.length > 0) {
								continue;
						}
						if (secondPass.beforePasses.length > 0) {
								continue;
						}
						firstPass._skipEnd = true;
						secondPass._skipStart = true;
				}
				var lastCubeTexture = null;
				var lastCubeRenderPass = null;
				for(var i2 = 0; i2 < renderPasses.length; i2++){
						var renderPass1 = renderPasses[i2];
						var renderTarget1 = renderPass1.renderTarget;
						var thisTexture = renderTarget1 == null ? void 0 : renderTarget1.colorBuffer;
						if (thisTexture == null ? void 0 : thisTexture.cubemap) {
								if (lastCubeTexture === thisTexture) {
										var count1 = lastCubeRenderPass.colorArrayOps.length;
										for(var j1 = 0; j1 < count1; j1++){
												lastCubeRenderPass.colorArrayOps[j1].mipmaps = false;
										}
								}
								lastCubeTexture = renderTarget1.colorBuffer;
								lastCubeRenderPass = renderPass1;
						} else if (renderPass1.requiresCubemaps) {
								lastCubeTexture = null;
								lastCubeRenderPass = null;
						}
				}
				renderTargetMap.clear();
		}
		render(device) {
				this.compile();
				var renderPasses = this.renderPasses;
				for(var i = 0; i < renderPasses.length; i++){
						renderPasses[i].render();
				}
		}
		constructor(){
				this.renderPasses = [];
				this.renderTargetMap = new Map();
		}
}

class AreaLightCacheEntry {
		destroy() {
				var _this_texture0, _this_texture1;
				(_this_texture0 = this.texture0) == null ? void 0 : _this_texture0.destroy();
				(_this_texture1 = this.texture1) == null ? void 0 : _this_texture1.destroy();
		}
		constructor(texture0, texture1){
				this.texture0 = texture0;
				this.texture1 = texture1;
		}
}
var deviceCache = new DeviceCache();
class AreaLightLuts {
		static createTexture(device, format, size, postfix) {
				if (postfix === void 0) postfix = '';
				var tex = new Texture(device, {
						name: "AreaLightLUT" + postfix,
						width: size,
						height: size,
						format: format,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						type: TEXTURETYPE_DEFAULT,
						magFilter: FILTER_LINEAR,
						minFilter: FILTER_NEAREST,
						anisotropy: 1,
						mipmaps: false
				});
				return tex;
		}
		static applyTextures(device, texture1, texture2) {
				deviceCache.remove(device);
				deviceCache.get(device, ()=>{
						return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
				});
				device.scope.resolve('areaLightsLutTex1').setValue(texture1);
				device.scope.resolve('areaLightsLutTex2').setValue(texture2);
		}
		static createPlaceholder(device) {
				var texture = AreaLightLuts.createTexture(device, PIXELFORMAT_RGBA16F, 2, 'placeholder');
				var pixels = texture.lock();
				pixels.fill(0);
				texture.unlock();
				AreaLightLuts.applyTextures(device, texture, texture);
		}
		static set(device, ltcMat1, ltcMat2) {
				function buildTexture(device, data, format) {
						var texture = AreaLightLuts.createTexture(device, format, 64);
						texture.lock().set(data);
						texture.unlock();
						return texture;
				}
				function convertToHalfFloat(data) {
						var count = data.length;
						var ret = new Uint16Array(count);
						var float2Half = FloatPacking.float2Half;
						for(var i = 0; i < count; i++){
								ret[i] = float2Half(data[i]);
						}
						return ret;
				}
				var srcData1 = ltcMat1;
				var srcData2 = ltcMat2;
				var data1 = convertToHalfFloat(srcData1);
				var data2 = convertToHalfFloat(srcData2);
				var tex1 = buildTexture(device, data1, PIXELFORMAT_RGBA16F);
				var tex2 = buildTexture(device, data2, PIXELFORMAT_RGBA16F);
				AreaLightLuts.applyTextures(device, tex1, tex2);
		}
}

var DEFAULT_LOCALE = 'en-US';
var DEFAULT_LOCALE_FALLBACKS = {
		'en': 'en-US',
		'es': 'en-ES',
		'zh': 'zh-CN',
		'zh-HK': 'zh-TW',
		'zh-TW': 'zh-HK',
		'zh-MO': 'zh-HK',
		'fr': 'fr-FR',
		'de': 'de-DE',
		'it': 'it-IT',
		'ru': 'ru-RU',
		'ja': 'ja-JP'
};

var PLURALS = {};
function definePluralFn(locales, fn) {
		for(var i = 0, len = locales.length; i < len; i++){
				PLURALS[locales[i]] = fn;
		}
}
function getLang(locale) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
				return locale.substring(0, idx);
		}
		return locale;
}
function replaceLang(locale, desiredLang) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
				return desiredLang + locale.substring(idx);
		}
		return desiredLang;
}
function findAvailableLocale(desiredLocale, availableLocales) {
		if (availableLocales[desiredLocale]) {
				return desiredLocale;
		}
		var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
		if (fallback && availableLocales[fallback]) {
				return fallback;
		}
		var lang = getLang(desiredLocale);
		fallback = DEFAULT_LOCALE_FALLBACKS[lang];
		if (availableLocales[fallback]) {
				return fallback;
		}
		if (availableLocales[lang]) {
				return lang;
		}
		return DEFAULT_LOCALE;
}
definePluralFn([
		'ja',
		'ko',
		'th',
		'vi',
		'zh',
		'id'
], (n)=>{
		return 0;
});
definePluralFn([
		'fa',
		'hi'
], (n)=>{
		if (n >= 0 && n <= 1) {
				return 0;
		}
		return 1;
});
definePluralFn([
		'fr',
		'pt'
], (n)=>{
		if (n >= 0 && n < 2) {
				return 0;
		}
		return 1;
});
definePluralFn([
		'da'
], (n)=>{
		if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
				return 0;
		}
		return 1;
});
definePluralFn([
		'de',
		'en',
		'it',
		'el',
		'es',
		'tr',
		'fi',
		'sv',
		'nb',
		'no',
		'ur'
], (n)=>{
		if (n === 1) {
				return 0;
		}
		return 1;
});
definePluralFn([
		'ru',
		'uk'
], (n)=>{
		if (Number.isInteger(n)) {
				var mod10 = n % 10;
				var mod100 = n % 100;
				if (mod10 === 1 && mod100 !== 11) {
						return 0;
				} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
						return 1;
				} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
						return 2;
				}
		}
		return 3;
});
definePluralFn([
		'pl'
], (n)=>{
		if (Number.isInteger(n)) {
				if (n === 1) {
						return 0;
				}
				var mod10 = n % 10;
				var mod100 = n % 100;
				if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
						return 1;
				} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
						return 2;
				}
		}
		return 3;
});
definePluralFn([
		'ar'
], (n)=>{
		if (n === 0) {
				return 0;
		} else if (n === 1) {
				return 1;
		} else if (n === 2) {
				return 2;
		}
		if (Number.isInteger(n)) {
				var mod100 = n % 100;
				if (mod100 >= 3 && mod100 <= 10) {
						return 3;
				} else if (mod100 >= 11 && mod100 <= 99) {
						return 4;
				}
		}
		return 5;
});
var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
function getPluralFn(lang) {
		return PLURALS[lang] || DEFAULT_PLURAL_FN;
}

var ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-+.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
var ASSET_ANIMATION = 'animation';
var ASSET_AUDIO = 'audio';
var ASSET_IMAGE = 'image';
var ASSET_JSON = 'json';
var ASSET_MODEL = 'model';
var ASSET_MATERIAL = 'material';
var ASSET_TEXT = 'text';
var ASSET_TEXTURE = 'texture';
var ASSET_TEXTUREATLAS = 'textureatlas';
var ASSET_CUBEMAP = 'cubemap';
var ASSET_SHADER = 'shader';
var ASSET_CSS = 'css';
var ASSET_HTML = 'html';
var ASSET_SCRIPT = "script";
var ASSET_CONTAINER = 'container';

class AssetFile {
		equals(other) {
				return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
		}
		constructor(url = '', filename = '', hash = null, size = null, opt = null, contents = null){
				this.url = url;
				this.filename = filename;
				this.hash = hash;
				this.size = size;
				this.opt = opt;
				this.contents = contents;
		}
}

var assetIdCounter = -1;
var VARIANT_SUPPORT = {
		pvr: 'extCompressedTexturePVRTC',
		dxt: 'extCompressedTextureS3TC',
		etc2: 'extCompressedTextureETC',
		etc1: 'extCompressedTextureETC1',
		basis: 'canvas'
};
var VARIANT_DEFAULT_PRIORITY = [
		'pvr',
		'dxt',
		'etc2',
		'etc1',
		'basis'
];
class Asset extends EventHandler {
		set id(value) {
				this._id = value;
		}
		get id() {
				return this._id;
		}
		set name(value) {
				if (this._name === value) {
						return;
				}
				var old = this._name;
				this._name = value;
				this.fire('name', this, this._name, old);
		}
		get name() {
				return this._name;
		}
		set file(value) {
				if (value && value.variants && [
						'texture',
						'textureatlas',
						'bundle'
				].indexOf(this.type) !== -1) {
						var _this_registry__loader, _this_registry;
						var app = ((_this_registry = this.registry) == null ? void 0 : (_this_registry__loader = _this_registry._loader) == null ? void 0 : _this_registry__loader._app) || getApplication();
						var device = app == null ? void 0 : app.graphicsDevice;
						if (device) {
								var _this, _loop = function(i, len) {
										var variant = VARIANT_DEFAULT_PRIORITY[i];
										if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
												value = value.variants[variant];
												return "break";
										}
										if (app.enableBundles) {
												var bundles = app.bundles.listBundlesForAsset(_this);
												if (bundles && bundles.find((b)=>{
														var _b_file;
														return b == null ? void 0 : (_b_file = b.file) == null ? void 0 : _b_file.variants[variant];
												})) {
														return "break";
												}
										}
								};
								for(var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++){
										var _ret = (_this = this, _loop(i, len));
										if (_ret === "break") break;
								}
						}
				}
				var oldFile = this._file;
				var newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;
				if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
						this._file = newFile;
						this.fire('change', this, 'file', newFile, oldFile);
						this.reload();
				}
		}
		get file() {
				return this._file;
		}
		set data(value) {
				var old = this._data;
				this._data = value;
				if (value !== old) {
						this.fire('change', this, 'data', value, old);
						if (this.loaded) {
								this.registry._loader.patch(this, this.registry);
						}
				}
		}
		get data() {
				return this._data;
		}
		set resource(value) {
				var _old = this._resources[0];
				this._resources[0] = value;
				this.fire('change', this, 'resource', value, _old);
		}
		get resource() {
				return this._resources[0];
		}
		set resources(value) {
				var _old = this._resources;
				this._resources = value;
				this.fire('change', this, 'resources', value, _old);
		}
		get resources() {
				return this._resources;
		}
		set preload(value) {
				value = !!value;
				if (this._preload === value) {
						return;
				}
				this._preload = value;
				if (this._preload && !this.loaded && !this.loading && this.registry) {
						this.registry.load(this);
				}
		}
		get preload() {
				return this._preload;
		}
		set loadFaces(value) {
				value = !!value;
				if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
						this._loadFaces = value;
						if (this.loaded) {
								this.registry._loader.patch(this, this.registry);
						}
				}
		}
		get loadFaces() {
				return this._loadFaces;
		}
		getFileUrl() {
				var file = this.file;
				if (!file || !file.url) {
						return null;
				}
				var url = file.url;
				if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {
						url = this.registry.prefix + url;
				}
				if (this.type !== "script" && file.hash) {
						var separator = url.indexOf('?') !== -1 ? '&' : '?';
						url += separator + "t=" + file.hash;
				}
				return url;
		}
		getAbsoluteUrl(relativePath) {
				if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
						return relativePath;
				}
				var base = path.getDirectory(this.file.url);
				return path.join(base, relativePath);
		}
		getLocalizedAssetId(locale) {
				locale = findAvailableLocale(locale, this._i18n);
				return this._i18n[locale] || null;
		}
		addLocalizedAssetId(locale, assetId) {
				this._i18n[locale] = assetId;
				this.fire('add:localized', locale, assetId);
		}
		removeLocalizedAssetId(locale) {
				var assetId = this._i18n[locale];
				if (assetId) {
						delete this._i18n[locale];
						this.fire('remove:localized', locale, assetId);
				}
		}
		ready(callback, scope) {
				scope = scope || this;
				if (this.loaded) {
						callback.call(scope, this);
				} else {
						this.once('load', (asset)=>{
								callback.call(scope, asset);
						});
				}
		}
		reload() {
				if (this.loaded) {
						this.loaded = false;
						this.registry.load(this);
				}
		}
		unload() {
				if (!this.loaded && this._resources.length === 0) {
						return;
				}
				this.fire('unload', this);
				this.registry.fire("unload:" + this.id, this);
				var old = this._resources;
				if (this.urlObject) {
						URL.revokeObjectURL(this.urlObject);
						this.urlObject = null;
				}
				this.resources = [];
				this.loaded = false;
				if (this.file) {
						this.registry._loader.clearCache(this.getFileUrl(), this.type);
				}
				for(var i = 0; i < old.length; ++i){
						var resource = old[i];
						if (resource && resource.destroy) {
								resource.destroy();
						}
				}
		}
		static fetchArrayBuffer(loadUrl, callback, asset, maxRetries) {
				if (maxRetries === void 0) maxRetries = 0;
				var _asset_file;
				if (asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : _asset_file.contents) {
						setTimeout(()=>{
								callback(null, asset.file.contents);
						});
				} else {
						http.get(loadUrl, {
								cache: true,
								responseType: 'arraybuffer',
								retry: maxRetries > 0,
								maxRetries: maxRetries
						}, callback);
				}
		}
		constructor(name, type, file, data, options){
				super();
				this._id = assetIdCounter--;
				this._name = name || '';
				this.type = type;
				this.tags = new Tags(this);
				this._preload = false;
				this._file = null;
				this._data = data || {};
				this.options = options || {};
				this._resources = [];
				this.urlObject = null;
				this._i18n = {};
				this.loaded = false;
				this.loading = false;
				this.registry = null;
				if (file) this.file = file;
		}
}
Asset.EVENT_LOAD = 'load';
Asset.EVENT_UNLOAD = 'unload';
Asset.EVENT_REMOVE = 'remove';
Asset.EVENT_ERROR = 'error';
Asset.EVENT_CHANGE = 'change';
Asset.EVENT_PROGRESS = 'progress';
Asset.EVENT_ADDLOCALIZED = 'add:localized';
Asset.EVENT_REMOVELOCALIZED = 'remove:localized';

class TagsCache {
		addItem(item) {
				var tags = item.tags._list;
				for (var tag of tags){
						this.add(tag, item);
				}
		}
		removeItem(item) {
				var tags = item.tags._list;
				for (var tag of tags){
						this.remove(tag, item);
				}
		}
		add(tag, item) {
				if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {
						return;
				}
				if (!this._index[tag]) {
						this._index[tag] = {
								list: []
						};
						if (this._key) {
								this._index[tag].keys = {};
						}
				}
				this._index[tag].list.push(item);
				if (this._key) {
						this._index[tag].keys[item[this._key]] = item;
				}
		}
		remove(tag, item) {
				if (!this._index[tag]) {
						return;
				}
				if (this._key) {
						if (!this._index[tag].keys[item[this._key]]) {
								return;
						}
				}
				var ind = this._index[tag].list.indexOf(item);
				if (ind === -1) {
						return;
				}
				this._index[tag].list.splice(ind, 1);
				if (this._key) {
						delete this._index[tag].keys[item[this._key]];
				}
				if (this._index[tag].list.length === 0) {
						delete this._index[tag];
				}
		}
		find(args) {
				var index = {};
				var items = [];
				var item, tag, tags, tagsRest, missingIndex;
				var sort = (a, b)=>{
						return this._index[a].list.length - this._index[b].list.length;
				};
				for(var i = 0; i < args.length; i++){
						tag = args[i];
						if (tag instanceof Array) {
								if (tag.length === 0) {
										continue;
								}
								if (tag.length === 1) {
										tag = tag[0];
								} else {
										missingIndex = false;
										for(var t = 0; t < tag.length; t++){
												if (!this._index[tag[t]]) {
														missingIndex = true;
														break;
												}
										}
										if (missingIndex) {
												continue;
										}
										tags = tag.slice(0).sort(sort);
										tagsRest = tags.slice(1);
										if (tagsRest.length === 1) {
												tagsRest = tagsRest[0];
										}
										for(var n = 0; n < this._index[tags[0]].list.length; n++){
												item = this._index[tags[0]].list[n];
												if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
														if (this._key) {
																index[item[this._key]] = true;
														}
														items.push(item);
												}
										}
										continue;
								}
						}
						if (tag && typeof tag === 'string' && this._index[tag]) {
								for(var n1 = 0; n1 < this._index[tag].list.length; n1++){
										item = this._index[tag].list[n1];
										if (this._key) {
												if (!index[item[this._key]]) {
														index[item[this._key]] = true;
														items.push(item);
												}
										} else if (items.indexOf(item) === -1) {
												items.push(item);
										}
								}
						}
				}
				return items;
		}
		constructor(key = null){
				this._index = {};
				this._key = key;
		}
}

class AssetRegistry extends EventHandler {
		list(filters) {
				if (filters === void 0) filters = {};
				var assets = Array.from(this._assets);
				if (filters.preload !== undefined) {
						return assets.filter((asset)=>asset.preload === filters.preload);
				}
				return assets;
		}
		add(asset) {
				var _asset_file, _asset_file1;
				if (this._assets.has(asset)) return;
				this._assets.add(asset);
				this._idToAsset.set(asset.id, asset);
				if ((_asset_file = asset.file) == null ? void 0 : _asset_file.url) {
						this._urlToAsset.set(asset.file.url, asset);
				}
				if (!this._nameToAsset.has(asset.name)) {
						this._nameToAsset.set(asset.name, new Set());
				}
				this._nameToAsset.get(asset.name).add(asset);
				asset.on('name', this._onNameChange, this);
				asset.registry = this;
				this._tags.addItem(asset);
				asset.tags.on('add', this._onTagAdd, this);
				asset.tags.on('remove', this._onTagRemove, this);
				this.fire('add', asset);
				this.fire("add:" + asset.id, asset);
				if ((_asset_file1 = asset.file) == null ? void 0 : _asset_file1.url) {
						this.fire("add:url:" + asset.file.url, asset);
				}
				if (asset.preload) {
						this.load(asset);
				}
		}
		remove(asset) {
				var _asset_file, _asset_file1;
				if (!this._assets.has(asset)) return false;
				this._assets.delete(asset);
				this._idToAsset.delete(asset.id);
				if ((_asset_file = asset.file) == null ? void 0 : _asset_file.url) {
						this._urlToAsset.delete(asset.file.url);
				}
				asset.off('name', this._onNameChange, this);
				if (this._nameToAsset.has(asset.name)) {
						var items = this._nameToAsset.get(asset.name);
						items.delete(asset);
						if (items.size === 0) {
								this._nameToAsset.delete(asset.name);
						}
				}
				this._tags.removeItem(asset);
				asset.tags.off('add', this._onTagAdd, this);
				asset.tags.off('remove', this._onTagRemove, this);
				asset.fire('remove', asset);
				this.fire('remove', asset);
				this.fire("remove:" + asset.id, asset);
				if ((_asset_file1 = asset.file) == null ? void 0 : _asset_file1.url) {
						this.fire("remove:url:" + asset.file.url, asset);
				}
				return true;
		}
		get(id) {
				return this._idToAsset.get(Number(id));
		}
		getByUrl(url) {
				return this._urlToAsset.get(url);
		}
		load(asset, options) {
				if ((asset.loading || asset.loaded) && !(options == null ? void 0 : options.force)) {
						return;
				}
				var file = asset.file;
				var _fireLoad = ()=>{
						this.fire('load', asset);
						this.fire("load:" + asset.id, asset);
						if (file && file.url) {
								this.fire("load:url:" + file.url, asset);
						}
						asset.fire('load', asset);
				};
				var _opened = (resource)=>{
						if (resource instanceof Array) {
								asset.resources = resource;
						} else {
								asset.resource = resource;
						}
						this._loader.patch(asset, this);
						if (asset.type === 'bundle') {
								var assetIds = asset.data.assets;
								for(var i = 0; i < assetIds.length; i++){
										var assetInBundle = this._idToAsset.get(assetIds[i]);
										if (assetInBundle && !assetInBundle.loaded) {
												this.load(assetInBundle, {
														force: true
												});
										}
								}
								if (asset.resource.loaded) {
										_fireLoad();
								} else {
										this.fire('load:start', asset);
										this.fire("load:start:" + asset.id, asset);
										if (file && file.url) {
												this.fire("load:start:url:" + file.url, asset);
										}
										asset.fire('load:start', asset);
										asset.resource.on('load', _fireLoad);
								}
						} else {
								_fireLoad();
						}
				};
				var _loaded = (err, resource, extra)=>{
						asset.loaded = true;
						asset.loading = false;
						if (err) {
								this.fire('error', err, asset);
								this.fire("error:" + asset.id, err, asset);
								asset.fire('error', err, asset);
						} else {
								if (asset.type === "script") {
										var handler = this._loader.getHandler("script");
										if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
												document.head.removeChild(handler._cache[asset.id]);
										}
										handler._cache[asset.id] = extra;
								}
								_opened(resource);
						}
				};
				if (file || asset.type === 'cubemap') {
						this.fire('load:start', asset);
						this.fire("load:" + asset.id + ":start", asset);
						asset.loading = true;
						var fileUrl = asset.getFileUrl();
						if (asset.type === 'bundle') {
								var assetIds = asset.data.assets;
								for(var i = 0; i < assetIds.length; i++){
										var assetInBundle = this._idToAsset.get(assetIds[i]);
										if (!assetInBundle) {
												continue;
										}
										if (assetInBundle.loaded || assetInBundle.resource || assetInBundle.loading) {
												continue;
										}
										assetInBundle.loading = true;
								}
						}
						this._loader.load(fileUrl, asset.type, _loaded, asset, options);
				} else {
						var resource = this._loader.open(asset.type, asset.data);
						asset.loaded = true;
						_opened(resource);
				}
		}
		loadFromUrl(url, type, callback) {
				this.loadFromUrlAndFilename(url, null, type, callback);
		}
		loadFromUrlAndFilename(url, filename, type, callback) {
				var name = path.getBasename(filename || url);
				var file = {
						filename: filename || name,
						url: url
				};
				var asset = this.getByUrl(url);
				if (!asset) {
						asset = new Asset(name, type, file);
						this.add(asset);
				} else if (asset.loaded) {
						callback(asset.loadFromUrlError || null, asset);
						return;
				}
				var startLoad = (asset)=>{
						asset.once('load', (loadedAsset)=>{
								if (type === 'material') {
										this._loadTextures(loadedAsset, (err, textures)=>{
												callback(err, loadedAsset);
										});
								} else {
										callback(null, loadedAsset);
								}
						});
						asset.once('error', (err)=>{
								if (err) {
										this.loadFromUrlError = err;
								}
								callback(err, asset);
						});
						this.load(asset);
				};
				if (asset.resource) {
						callback(null, asset);
				} else if (type === 'model') {
						this._loadModel(asset, startLoad);
				} else {
						startLoad(asset);
				}
		}
		_loadModel(modelAsset, continuation) {
				var url = modelAsset.getFileUrl();
				var ext = path.getExtension(url);
				if (ext === '.json' || ext === '.glb') {
						var dir = path.getDirectory(url);
						var basename = path.getBasename(url);
						var mappingUrl = path.join(dir, basename.replace(ext, '.mapping.json'));
						this._loader.load(mappingUrl, 'json', (err, data)=>{
								if (err) {
										modelAsset.data = {
												mapping: []
										};
										continuation(modelAsset);
								} else {
										this._loadMaterials(modelAsset, data, (e, materials)=>{
												modelAsset.data = data;
												continuation(modelAsset);
										});
								}
						});
				} else {
						continuation(modelAsset);
				}
		}
		_loadMaterials(modelAsset, mapping, callback) {
				var materials = [];
				var count = 0;
				var onMaterialLoaded = (err, materialAsset)=>{
						this._loadTextures(materialAsset, (err, textures)=>{
								materials.push(materialAsset);
								if (materials.length === count) {
										callback(null, materials);
								}
						});
				};
				for(var i = 0; i < mapping.mapping.length; i++){
						var path = mapping.mapping[i].path;
						if (path) {
								count++;
								var url = modelAsset.getAbsoluteUrl(path);
								this.loadFromUrl(url, 'material', onMaterialLoaded);
						}
				}
				if (count === 0) {
						callback(null, materials);
				}
		}
		_loadTextures(materialAsset, callback) {
				var textures = [];
				var count = 0;
				var data = materialAsset.data;
				if (data.mappingFormat !== 'path') {
						callback(null, textures);
						return;
				}
				var onTextureLoaded = (err, texture)=>{
						if (err) console.error(err);
						textures.push(texture);
						if (textures.length === count) {
								callback(null, textures);
						}
				};
				var texParams = standardMaterialTextureParameters;
				for(var i = 0; i < texParams.length; i++){
						var path = data[texParams[i]];
						if (path && typeof path === 'string') {
								count++;
								var url = materialAsset.getAbsoluteUrl(path);
								this.loadFromUrl(url, 'texture', onTextureLoaded);
						}
				}
				if (count === 0) {
						callback(null, textures);
				}
		}
		_onTagAdd(tag, asset) {
				this._tags.add(tag, asset);
		}
		_onTagRemove(tag, asset) {
				this._tags.remove(tag, asset);
		}
		_onNameChange(asset, name, nameOld) {
				if (this._nameToAsset.has(nameOld)) {
						var items = this._nameToAsset.get(nameOld);
						items.delete(asset);
						if (items.size === 0) {
								this._nameToAsset.delete(nameOld);
						}
				}
				if (!this._nameToAsset.has(asset.name)) {
						this._nameToAsset.set(asset.name, new Set());
				}
				this._nameToAsset.get(asset.name).add(asset);
		}
		findByTag() {
				for(var _len = arguments.length, query = new Array(_len), _key = 0; _key < _len; _key++){
						query[_key] = arguments[_key];
				}
				return this._tags.find(query);
		}
		filter(callback) {
				return Array.from(this._assets).filter((asset)=>callback(asset));
		}
		find(name, type) {
				var items = this._nameToAsset.get(name);
				if (!items) return null;
				for (var asset of items){
						if (!type || asset.type === type) {
								return asset;
						}
				}
				return null;
		}
		findAll(name, type) {
				var items = this._nameToAsset.get(name);
				if (!items) return [];
				var results = Array.from(items);
				if (!type) return results;
				return results.filter((asset)=>asset.type === type);
		}
		constructor(loader){
				super(), this._assets = new Set(), this._idToAsset = new Map(), this._urlToAsset = new Map(), this._nameToAsset = new Map(), this._tags = new TagsCache('_id'), this.prefix = null, this.bundles = null;
				this._loader = loader;
		}
}
AssetRegistry.EVENT_LOAD = 'load';
AssetRegistry.EVENT_ADD = 'add';
AssetRegistry.EVENT_REMOVE = 'remove';
AssetRegistry.EVENT_ERROR = 'error';

class BundleRegistry {
		_onAssetAdd(asset) {
				if (asset.type === 'bundle') {
						this._idToBundle.set(asset.id, asset);
						this._assets.on("load:start:" + asset.id, this._onBundleLoadStart, this);
						this._assets.on("load:" + asset.id, this._onBundleLoad, this);
						this._assets.on("error:" + asset.id, this._onBundleError, this);
						var assetIds = asset.data.assets;
						for(var i = 0; i < assetIds.length; i++){
								this._indexAssetInBundle(assetIds[i], asset);
						}
				} else {
						if (this._assetToBundles.has(asset.id)) {
								this._indexAssetFileUrls(asset);
						}
				}
		}
		_unbindAssetEvents(id) {
				this._assets.off("load:start:" + id, this._onBundleLoadStart, this);
				this._assets.off("load:" + id, this._onBundleLoad, this);
				this._assets.off("error:" + id, this._onBundleError, this);
		}
		_indexAssetInBundle(id, bundle) {
				var bundles = this._assetToBundles.get(id);
				if (!bundles) {
						bundles = new Set();
						this._assetToBundles.set(id, bundles);
				}
				bundles.add(bundle);
				var asset = this._assets.get(id);
				if (asset) this._indexAssetFileUrls(asset);
		}
		_indexAssetFileUrls(asset) {
				var urls = this._getAssetFileUrls(asset);
				if (!urls) return;
				for(var i = 0; i < urls.length; i++){
						var bundles = this._assetToBundles.get(asset.id);
						if (!bundles) continue;
						this._urlsToBundles.set(urls[i], bundles);
				}
		}
		_getAssetFileUrls(asset) {
				var url = asset.getFileUrl();
				if (!url) return null;
				url = url.split('?')[0];
				var urls = [
						url
				];
				if (asset.type === 'font') {
						var numFiles = asset.data.info.maps.length;
						for(var i = 1; i < numFiles; i++){
								urls.push(url.replace('.png', "" + i + ".png"));
						}
				}
				return urls;
		}
		_onAssetRemove(asset) {
				if (asset.type === 'bundle') {
						this._idToBundle.delete(asset.id);
						this._unbindAssetEvents(asset.id);
						var assetIds = asset.data.assets;
						for(var i = 0; i < assetIds.length; i++){
								var bundles = this._assetToBundles.get(assetIds[i]);
								if (!bundles) continue;
								bundles.delete(asset);
								if (bundles.size === 0) {
										this._assetToBundles.delete(assetIds[i]);
										for (var [url, otherBundles] of this._urlsToBundles){
												if (otherBundles !== bundles) {
														continue;
												}
												this._urlsToBundles.delete(url);
										}
								}
						}
						this._onBundleError("Bundle " + asset.id + " was removed");
				} else {
						var bundles1 = this._assetToBundles.get(asset.id);
						if (!bundles1) return;
						this._assetToBundles.delete(asset.id);
						var urls = this._getAssetFileUrls(asset);
						if (!urls) return;
						for(var i1 = 0; i1 < urls.length; i1++){
								this._urlsToBundles.delete(urls[i1]);
						}
				}
		}
		_onBundleLoadStart(asset) {
				asset.resource.on('add', (url, data)=>{
						var callbacks = this._fileRequests.get(url);
						if (!callbacks) return;
						for(var i = 0; i < callbacks.length; i++){
								callbacks[i](null, data);
						}
						this._fileRequests.delete(url);
				});
		}
		_onBundleLoad(asset) {
				if (!asset.resource) {
						this._onBundleError("Bundle " + asset.id + " failed to load");
						return;
				}
				if (!this._fileRequests) {
						return;
				}
				for (var [url, requests] of this._fileRequests){
						var bundles = this._urlsToBundles.get(url);
						if (!bundles || !bundles.has(asset)) continue;
						var decodedUrl = decodeURIComponent(url);
						var err = void 0, data = void 0;
						if (asset.resource.has(decodedUrl)) {
								data = asset.resource.get(decodedUrl);
						} else if (asset.resource.loaded) {
								err = "Bundle " + asset.id + " does not contain URL " + url;
						} else {
								continue;
						}
						for(var i = 0; i < requests.length; i++){
								requests[i](err, err || data);
						}
						this._fileRequests.delete(url);
				}
		}
		_onBundleError(err) {
				for (var [url, requests] of this._fileRequests){
						var bundle = this._findLoadedOrLoadingBundleForUrl(url);
						if (!bundle) {
								for(var i = 0; i < requests.length; i++){
										requests[i](err);
								}
								this._fileRequests.delete(url);
						}
				}
		}
		_findLoadedOrLoadingBundleForUrl(url) {
				var bundles = this._urlsToBundles.get(url);
				if (!bundles) return null;
				var candidate = null;
				for (var bundle of bundles){
						if (bundle.loaded && bundle.resource) {
								return bundle;
						} else if (bundle.loading) {
								candidate = bundle;
						}
				}
				return candidate;
		}
		listBundlesForAsset(asset) {
				var bundles = this._assetToBundles.get(asset.id);
				if (bundles) return Array.from(bundles);
				return null;
		}
		list() {
				return Array.from(this._idToBundle.values());
		}
		hasUrl(url) {
				return this._urlsToBundles.has(url);
		}
		urlIsLoadedOrLoading(url) {
				return !!this._findLoadedOrLoadingBundleForUrl(url);
		}
		loadUrl(url, callback) {
				var bundle = this._findLoadedOrLoadingBundleForUrl(url);
				if (!bundle) {
						callback("URL " + url + " not found in any bundles");
						return;
				}
				if (bundle.loaded) {
						var decodedUrl = decodeURIComponent(url);
						if (bundle.resource.has(decodedUrl)) {
								callback(null, bundle.resource.get(decodedUrl));
								return;
						} else if (bundle.resource.loaded) {
								callback("Bundle " + bundle.id + " does not contain URL " + url);
								return;
						}
				}
				var callbacks = this._fileRequests.get(url);
				if (!callbacks) {
						callbacks = [];
						this._fileRequests.set(url, callbacks);
				}
				callbacks.push(callback);
		}
		destroy() {
				this._assets.off('add', this._onAssetAdd, this);
				this._assets.off('remove', this._onAssetRemove, this);
				for (var id of this._idToBundle.keys()){
						this._unbindAssetEvents(id);
				}
				this._assets = null;
				this._idToBundle.clear();
				this._idToBundle = null;
				this._assetToBundles.clear();
				this._assetToBundles = null;
				this._urlsToBundles.clear();
				this._urlsToBundles = null;
				this._fileRequests.clear();
				this._fileRequests = null;
		}
		constructor(assets){
				this._idToBundle = new Map();
				this._assetToBundles = new Map();
				this._urlsToBundles = new Map();
				this._fileRequests = new Map();
				this._assets = assets;
				this._assets.bundles = this;
				this._assets.on('add', this._onAssetAdd, this);
				this._assets.on('remove', this._onAssetRemove, this);
		}
}

class ComponentSystemRegistry extends EventHandler {
		add(system) {
				var id = system.id;
				if (this[id]) {
						throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
				}
				this[id] = system;
				this.list.push(system);
		}
		remove(system) {
				var id = system.id;
				if (!this[id]) {
						throw new Error("No ComponentSystem named '" + id + "' registered");
				}
				delete this[id];
				var index = this.list.indexOf(this[id]);
				if (index !== -1) {
						this.list.splice(index, 1);
				}
		}
		destroy() {
				this.off();
				for(var i = 0; i < this.list.length; i++){
						this.list[i].destroy();
				}
		}
		constructor(){
				super();
				this.list = [];
		}
}

class Bundle extends EventHandler {
		addFile(url, data) {
				if (this._index.has(url)) {
						return;
				}
				this._index.set(url, data);
				this.fire('add', url, data);
		}
		has(url) {
				return this._index.has(url);
		}
		get(url) {
				return this._index.get(url) || null;
		}
		destroy() {
				this._index.clear();
		}
		set loaded(value) {
				if (!value || this._loaded) {
						return;
				}
				this._loaded = true;
				this.fire('load');
		}
		get loaded() {
				return this._loaded;
		}
		constructor(...args){
				super(...args), this._index = new Map(), this._loaded = false;
		}
}
Bundle.EVENT_ADD = 'add';
Bundle.EVENT_LOAD = 'load';

class Untar extends EventHandler {
		pump(done, value) {
				if (done) {
						this.fire('done');
						return null;
				}
				this.bytesReceived += value.byteLength;
				var data = new Uint8Array(this.data.length + value.length);
				data.set(this.data);
				data.set(value, this.data.length);
				this.data = data;
				while(this.readFile());
				return this.reader.read().then((res)=>{
						this.pump(res.done, res.value);
				}).catch((err)=>{
						this.fire('error', err);
				});
		}
		readFile() {
				if (!this.headerRead && this.bytesReceived > this.bytesRead + this.headerSize) {
						this.headerRead = true;
						var view = new DataView(this.data.buffer, this.bytesRead, this.headerSize);
						var _this_decoder;
						(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('windows-1252');
						var headers = this.decoder.decode(view);
						this.fileName = headers.substring(0, 100).replace(/\0/g, '');
						this.fileSize = parseInt(headers.substring(124, 136), 8);
						this.fileType = headers.substring(156, 157);
						this.ustarFormat = headers.substring(257, 263);
						if (this.ustarFormat.indexOf('ustar') !== -1) {
								var prefix = headers.substring(345, 500).replace(/\0/g, '');
								if (prefix.length > 0) {
										this.fileName = prefix.trim() + this.fileName.trim();
								}
						}
						this.bytesRead += 512;
				}
				if (this.headerRead) {
						if (this.bytesReceived < this.bytesRead + this.fileSize) {
								return false;
						}
						if (this.fileType === '' || this.fileType === '0') {
								var dataView = new DataView(this.data.buffer, this.bytesRead, this.fileSize);
								var file = {
										name: this.prefix + this.fileName,
										size: this.fileSize,
										data: dataView
								};
								this.fire('file', file);
						}
						this.bytesRead += this.fileSize;
						this.headerRead = false;
						var bytesRemained = this.bytesRead % this.paddingSize;
						if (bytesRemained !== 0) {
								this.bytesRead += this.paddingSize - bytesRemained;
						}
						return true;
				}
				return false;
		}
		constructor(fetchPromise, assetsPrefix = ''){
				super(), this.headerSize = 512, this.paddingSize = 512, this.bytesRead = 0, this.bytesReceived = 0, this.headerRead = false, this.reader = null, this.data = new Uint8Array(0), this.decoder = null, this.prefix = '', this.fileName = '', this.fileSize = 0, this.fileType = '', this.ustarFormat = '';
				this.prefix = assetsPrefix || '';
				this.reader = fetchPromise.body.getReader();
				this.reader.read().then((res)=>{
						this.pump(res.done, res.value);
				}).catch((err)=>{
						this.fire('error', err);
				});
		}
}

class ResourceHandler {
		set maxRetries(value) {
				this._maxRetries = value;
		}
		get maxRetries() {
				return this._maxRetries;
		}
		load(url, callback, asset) {}
		open(url, data, asset) {
				return data;
		}
		patch(asset, assets) {}
		constructor(app, handlerType){
				this.handlerType = '';
				this._maxRetries = 0;
				this._app = app;
				this.handlerType = handlerType;
		}
}

class BundleHandler extends ResourceHandler {
		_fetchRetries(url, options, retries) {
				if (retries === void 0) retries = 0;
				return new Promise((resolve, reject)=>{
						var tryFetch = ()=>{
								fetch(url, options).then(resolve).catch((err)=>{
										retries++;
										if (retries < this.maxRetries) {
												tryFetch();
										} else {
												reject(err);
										}
								});
						};
						tryFetch();
				});
		}
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				this._fetchRetries(url.load, {
						mode: 'cors',
						credentials: 'include'
				}, this.maxRetries).then((res)=>{
						var bundle = new Bundle();
						callback(null, bundle);
						var untar = new Untar(res, this._assets.prefix);
						untar.on('file', (file)=>{
								bundle.addFile(file.name, file.data);
						});
						untar.on('done', ()=>{
								bundle.loaded = true;
						});
						untar.on('error', (err)=>{
								callback(err);
						});
				}).catch((err)=>{
						callback(err);
				});
		}
		open(url, bundle) {
				return bundle;
		}
		constructor(app){
				super(app, 'bundle');
				this._assets = app.assets;
		}
}

class ResourceLoader {
		addHandler(type, handler) {
				this._handlers[type] = handler;
				handler._loader = this;
		}
		removeHandler(type) {
				delete this._handlers[type];
		}
		getHandler(type) {
				return this._handlers[type];
		}
		static makeKey(url, type) {
				return url + "-" + type;
		}
		load(url, type, callback, asset, options) {
				var handler = this._handlers[type];
				if (!handler) {
						var err = "No resource handler for asset type: '" + type + "' when loading [" + url + "]";
						callback(err);
						return;
				}
				if (!url) {
						this._loadNull(handler, callback, asset);
						return;
				}
				var key = ResourceLoader.makeKey(url, type);
				if (this._cache[key] !== undefined) {
						callback(null, this._cache[key]);
				} else if (this._requests[key]) {
						this._requests[key].push(callback);
				} else {
						this._requests[key] = [
								callback
						];
						var self = this;
						var handleLoad = function handleLoad(err, urlObj) {
								if (err) {
										self._onFailure(key, err);
										return;
								}
								if (urlObj.load instanceof DataView) {
										if (handler.openBinary) {
												if (!self._requests[key]) {
														return;
												}
												try {
														var data = handler.openBinary(urlObj.load);
														self._onSuccess(key, data);
												} catch (err) {
														self._onFailure(key, err);
												}
												return;
										}
										urlObj.load = URL.createObjectURL(new Blob([
												urlObj.load
										]));
										if (asset) {
												if (asset.urlObject) {
														URL.revokeObjectURL(asset.urlObject);
												}
												asset.urlObject = urlObj.load;
										}
								}
								handler.load(urlObj, (err, data, extra)=>{
										if (!self._requests[key]) {
												return;
										}
										if (err) {
												self._onFailure(key, err);
												return;
										}
										try {
												self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
										} catch (e) {
												self._onFailure(key, e);
										}
								}, asset);
						};
						var normalizedUrl = url.split('?')[0];
						if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl) && !(options && options.bundlesIgnore)) {
								if (!this._app.bundles.urlIsLoadedOrLoading(normalizedUrl)) {
										var _this__app_assets;
										var bundles = this._app.bundles.listBundlesForAsset(asset);
										var bundle;
										if (options && options.bundlesFilter) {
												bundle = options.bundlesFilter(bundles);
										}
										if (!bundle) {
												bundles == null ? void 0 : bundles.sort((a, b)=>{
														return a.file.size - b.file.size;
												});
												bundle = bundles == null ? void 0 : bundles[0];
										}
										if (bundle) (_this__app_assets = this._app.assets) == null ? void 0 : _this__app_assets.load(bundle);
								}
								this._app.bundles.loadUrl(normalizedUrl, (err, fileUrlFromBundle)=>{
										handleLoad(err, {
												load: fileUrlFromBundle,
												original: normalizedUrl
										});
								});
						} else {
								handleLoad(null, {
										load: url,
										original: asset && asset.file.filename || url
								});
						}
				}
		}
		_loadNull(handler, callback, asset) {
				var onLoad = function onLoad(err, data, extra) {
						if (err) {
								callback(err);
						} else {
								try {
										callback(null, handler.open(null, data, asset), extra);
								} catch (e) {
										callback(e);
								}
						}
				};
				handler.load(null, onLoad, asset);
		}
		_onSuccess(key, result, extra) {
				if (result !== null) {
						this._cache[key] = result;
				} else {
						delete this._cache[key];
				}
				for(var i = 0; i < this._requests[key].length; i++){
						this._requests[key][i](null, result, extra);
				}
				delete this._requests[key];
		}
		_onFailure(key, err) {
				console.error(err);
				if (this._requests[key]) {
						for(var i = 0; i < this._requests[key].length; i++){
								this._requests[key][i](err);
						}
						delete this._requests[key];
				}
		}
		open(type, data) {
				var handler = this._handlers[type];
				if (!handler) {
						console.warn("No resource handler found for: " + type);
						return data;
				}
				return handler.open(null, data);
		}
		patch(asset, assets) {
				var handler = this._handlers[asset.type];
				if (!handler) {
						console.warn("No resource handler found for: " + asset.type);
						return;
				}
				if (handler.patch) {
						handler.patch(asset, assets);
				}
		}
		clearCache(url, type) {
				var key = ResourceLoader.makeKey(url, type);
				delete this._cache[key];
		}
		getFromCache(url, type) {
				var key = ResourceLoader.makeKey(url, type);
				if (this._cache[key]) {
						return this._cache[key];
				}
				return undefined;
		}
		enableRetry(maxRetries) {
				if (maxRetries === void 0) maxRetries = 5;
				maxRetries = Math.max(0, maxRetries) || 0;
				for(var key in this._handlers){
						this._handlers[key].maxRetries = maxRetries;
				}
		}
		disableRetry() {
				for(var key in this._handlers){
						this._handlers[key].maxRetries = 0;
				}
		}
		destroy() {
				this._handlers = {};
				this._requests = {};
				this._cache = {};
		}
		constructor(app){
				this._handlers = {};
				this._requests = {};
				this._cache = {};
				this._app = app;
		}
}

class I18nParser {
		_validate(data) {
				if (!data.header) {
						throw new Error('pc.I18n#addData: Missing "header" field');
				}
				if (!data.header.version) {
						throw new Error('pc.I18n#addData: Missing "header.version" field');
				}
				if (data.header.version !== 1) {
						throw new Error('pc.I18n#addData: Invalid "header.version" field');
				}
				if (!data.data) {
						throw new Error('pc.I18n#addData: Missing "data" field');
				} else if (!Array.isArray(data.data)) {
						throw new Error('pc.I18n#addData: "data" field must be an array');
				}
				for(var i = 0, len = data.data.length; i < len; i++){
						var entry = data.data[i];
						if (!entry.info) {
								throw new Error('pc.I18n#addData: missing "data[' + i + '].info" field');
						}
						if (!entry.info.locale) {
								throw new Error('pc.I18n#addData: missing "data[' + i + '].info.locale" field');
						}
						if (typeof entry.info.locale !== 'string') {
								throw new Error('pc.I18n#addData: "data[' + i + '].info.locale" must be a string');
						}
						if (!entry.messages) {
								throw new Error('pc.I18n#addData: missing "data[' + i + '].messages" field');
						}
				}
		}
		parse(data) {
				return data.data;
		}
}

class I18n extends EventHandler {
		set assets(value) {
				var index = {};
				for(var i = 0, len = value.length; i < len; i++){
						var id = value[i] instanceof Asset ? value[i].id : value[i];
						index[id] = true;
				}
				var i1 = this._assets.length;
				while(i1--){
						var id1 = this._assets[i1];
						if (!index[id1]) {
								this._app.assets.off("add:" + id1, this._onAssetAdd, this);
								var asset = this._app.assets.get(id1);
								if (asset) {
										this._onAssetRemove(asset);
								}
								this._assets.splice(i1, 1);
						}
				}
				for(var id2 in index){
						var idNum = parseInt(id2, 10);
						if (this._assets.indexOf(idNum) !== -1) continue;
						this._assets.push(idNum);
						var asset1 = this._app.assets.get(idNum);
						if (!asset1) {
								this._app.assets.once("add:" + idNum, this._onAssetAdd, this);
						} else {
								this._onAssetAdd(asset1);
						}
				}
		}
		get assets() {
				return this._assets;
		}
		set locale(value) {
				if (this._locale === value) {
						return;
				}
				var lang = getLang(value);
				if (lang === 'in') {
						lang = 'id';
						value = replaceLang(value, lang);
						if (this._locale === value) {
								return;
						}
				}
				var old = this._locale;
				this._locale = value;
				this._lang = lang;
				this._pluralFn = getPluralFn(this._lang);
				this.fire('set:locale', value, old);
		}
		get locale() {
				return this._locale;
		}
		static findAvailableLocale(desiredLocale, availableLocales) {
				return findAvailableLocale(desiredLocale, availableLocales);
		}
		findAvailableLocale(desiredLocale) {
				if (this._translations[desiredLocale]) {
						return desiredLocale;
				}
				var lang = getLang(desiredLocale);
				return this._findFallbackLocale(desiredLocale, lang);
		}
		getText(key, locale) {
				var result = key;
				var lang;
				if (!locale) {
						locale = this._locale;
						lang = this._lang;
				}
				var translations = this._translations[locale];
				if (!translations) {
						if (!lang) {
								lang = getLang(locale);
						}
						locale = this._findFallbackLocale(locale, lang);
						translations = this._translations[locale];
				}
				if (translations && translations.hasOwnProperty(key)) {
						result = translations[key];
						if (Array.isArray(result)) {
								result = result[0];
						}
						if (result === null || result === undefined) {
								result = key;
						}
				}
				return result;
		}
		getPluralText(key, n, locale) {
				var result = key;
				var lang;
				var pluralFn;
				if (!locale) {
						locale = this._locale;
						lang = this._lang;
						pluralFn = this._pluralFn;
				} else {
						lang = getLang(locale);
						pluralFn = getPluralFn(lang);
				}
				var translations = this._translations[locale];
				if (!translations) {
						locale = this._findFallbackLocale(locale, lang);
						lang = getLang(locale);
						pluralFn = getPluralFn(lang);
						translations = this._translations[locale];
				}
				if (translations && translations[key] && pluralFn) {
						var index = pluralFn(n);
						result = translations[key][index];
						if (result === null || result === undefined) {
								result = key;
						}
				}
				return result;
		}
		addData(data) {
				var parsed;
				try {
						parsed = this._parser.parse(data);
				} catch (err) {
						console.error(err);
						return;
				}
				for(var i = 0, len = parsed.length; i < len; i++){
						var entry = parsed[i];
						var locale = entry.info.locale;
						var messages = entry.messages;
						if (!this._translations[locale]) {
								this._translations[locale] = {};
								var lang = getLang(locale);
								if (!this._availableLangs[lang]) {
										this._availableLangs[lang] = locale;
								}
						}
						Object.assign(this._translations[locale], messages);
						this.fire('data:add', locale, messages);
				}
		}
		removeData(data) {
				var parsed;
				try {
						parsed = this._parser.parse(data);
				} catch (err) {
						console.error(err);
						return;
				}
				for(var i = 0, len = parsed.length; i < len; i++){
						var entry = parsed[i];
						var locale = entry.info.locale;
						var translations = this._translations[locale];
						if (!translations) continue;
						var messages = entry.messages;
						for(var key in messages){
								delete translations[key];
						}
						if (Object.keys(translations).length === 0) {
								delete this._translations[locale];
								delete this._availableLangs[getLang(locale)];
						}
						this.fire('data:remove', locale, messages);
				}
		}
		destroy() {
				this._translations = null;
				this._availableLangs = null;
				this._assets = null;
				this._parser = null;
				this.off();
		}
		_findFallbackLocale(locale, lang) {
				var result = DEFAULT_LOCALE_FALLBACKS[locale];
				if (result && this._translations[result]) {
						return result;
				}
				result = DEFAULT_LOCALE_FALLBACKS[lang];
				if (result && this._translations[result]) {
						return result;
				}
				result = this._availableLangs[lang];
				if (result && this._translations[result]) {
						return result;
				}
				return DEFAULT_LOCALE;
		}
		_onAssetAdd(asset) {
				asset.on('load', this._onAssetLoad, this);
				asset.on('change', this._onAssetChange, this);
				asset.on('remove', this._onAssetRemove, this);
				asset.on('unload', this._onAssetUnload, this);
				if (asset.resource) {
						this._onAssetLoad(asset);
				}
		}
		_onAssetLoad(asset) {
				this.addData(asset.resource);
		}
		_onAssetChange(asset) {
				if (asset.resource) {
						this.addData(asset.resource);
				}
		}
		_onAssetRemove(asset) {
				asset.off('load', this._onAssetLoad, this);
				asset.off('change', this._onAssetChange, this);
				asset.off('remove', this._onAssetRemove, this);
				asset.off('unload', this._onAssetUnload, this);
				if (asset.resource) {
						this.removeData(asset.resource);
				}
				this._app.assets.once("add:" + asset.id, this._onAssetAdd, this);
		}
		_onAssetUnload(asset) {
				if (asset.resource) {
						this.removeData(asset.resource);
				}
		}
		constructor(app){
				super();
				this.locale = DEFAULT_LOCALE;
				this._translations = {};
				this._availableLangs = {};
				this._app = app;
				this._assets = [];
				this._parser = new I18nParser();
		}
}

class ScriptRegistry extends EventHandler {
		destroy() {
				this.app = null;
				this.off();
		}
		addSchema(id, schema) {
				if (!schema) return;
				this._scriptSchemas.set(id, schema);
		}
		getSchema(id) {
				return this._scriptSchemas.get(id);
		}
		add(script) {
				var scriptName = script.__name;
				if (this._scripts.hasOwnProperty(scriptName)) {
						setTimeout(()=>{
								if (script.prototype.swap) {
										var old = this._scripts[scriptName];
										var ind = this._list.indexOf(old);
										this._list[ind] = script;
										this._scripts[scriptName] = script;
										this.fire('swap', scriptName, script);
										this.fire("swap:" + scriptName, script);
								} else {
										console.warn("script registry already has '" + scriptName + "' script, define 'swap' method for new script type to enable code hot swapping");
								}
						});
						return false;
				}
				this._scripts[scriptName] = script;
				this._list.push(script);
				this.fire('add', scriptName, script);
				this.fire("add:" + scriptName, script);
				setTimeout(()=>{
						if (!this._scripts.hasOwnProperty(scriptName)) {
								return;
						}
						if (!this.app || !this.app.systems || !this.app.systems.script) {
								return;
						}
						var components = this.app.systems.script._components;
						var attributes;
						var scriptInstances = [];
						var scriptInstancesInitialized = [];
						for(components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++){
								var component = components.items[components.loopIndex];
								if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
										if (component._scriptsData && component._scriptsData[scriptName]) {
												attributes = component._scriptsData[scriptName].attributes;
										}
										var scriptInstance = component.create(scriptName, {
												preloading: true,
												ind: component._scriptsIndex[scriptName].ind,
												attributes: attributes
										});
										if (scriptInstance) {
												scriptInstances.push(scriptInstance);
										}
										for (var _$script of component.scripts){
												component.initializeAttributes(_$script);
										}
								}
						}
						for(var i = 0; i < scriptInstances.length; i++){
								if (scriptInstances[i].enabled) {
										scriptInstances[i]._initialized = true;
										scriptInstancesInitialized.push(scriptInstances[i]);
										if (scriptInstances[i].initialize) {
												scriptInstances[i].initialize();
										}
								}
						}
						for(var i1 = 0; i1 < scriptInstancesInitialized.length; i1++){
								if (!scriptInstancesInitialized[i1].enabled || scriptInstancesInitialized[i1]._postInitialized) {
										continue;
								}
								scriptInstancesInitialized[i1]._postInitialized = true;
								if (scriptInstancesInitialized[i1].postInitialize) {
										scriptInstancesInitialized[i1].postInitialize();
								}
						}
				});
				return true;
		}
		remove(nameOrType) {
				var scriptType = nameOrType;
				var scriptName = nameOrType;
				if (typeof scriptName !== 'string') {
						scriptName = scriptType.__name;
				} else {
						scriptType = this.get(scriptName);
				}
				if (this.get(scriptName) !== scriptType) {
						return false;
				}
				delete this._scripts[scriptName];
				var ind = this._list.indexOf(scriptType);
				this._list.splice(ind, 1);
				this.fire('remove', scriptName, scriptType);
				this.fire("remove:" + scriptName, scriptType);
				return true;
		}
		get(name) {
				return this._scripts[name] || null;
		}
		has(nameOrType) {
				if (typeof nameOrType === 'string') {
						return this._scripts.hasOwnProperty(nameOrType);
				}
				if (!nameOrType) return false;
				var scriptName = nameOrType.__name;
				return this._scripts[scriptName] === nameOrType;
		}
		list() {
				return this._list;
		}
		constructor(app){
				super(), this._scripts = {}, this._list = [], this._scriptSchemas = new Map();
				this.app = app;
		}
}

var cmpStaticOrder = (a, b)=>a.constructor.order - b.constructor.order;
var sortStaticOrder = (arr)=>arr.sort(cmpStaticOrder);
var _enableList = [];
var tmpPool = [];
var getTempArray = ()=>{
		var _tmpPool_pop;
		return (_tmpPool_pop = tmpPool.pop()) != null ? _tmpPool_pop : [];
};
var releaseTempArray = (a)=>{
		a.length = 0;
		tmpPool.push(a);
};
class Entity extends GraphNode {
		addComponent(type, data) {
				var system = this._app.systems[type];
				if (!system) {
						return null;
				}
				if (this.c[type]) {
						return null;
				}
				return system.addComponent(this, data);
		}
		removeComponent(type) {
				var system = this._app.systems[type];
				if (!system) {
						return;
				}
				if (!this.c[type]) {
						return;
				}
				system.removeComponent(this);
		}
		findComponent(type) {
				var entity = this.findOne((entity)=>{
						var _entity_c;
						return (_entity_c = entity.c) == null ? void 0 : _entity_c[type];
				});
				return entity && entity.c[type];
		}
		findComponents(type) {
				return this.find((entity)=>{
						var _entity_c;
						return (_entity_c = entity.c) == null ? void 0 : _entity_c[type];
				}).map((entity)=>entity.c[type]);
		}
		findScript(nameOrType) {
				var entity = this.findOne((node)=>{
						var _node_c_script, _node_c;
						return (_node_c = node.c) == null ? void 0 : (_node_c_script = _node_c.script) == null ? void 0 : _node_c_script.has(nameOrType);
				});
				return entity == null ? void 0 : entity.c.script.get(nameOrType);
		}
		findScripts(nameOrType) {
				var entities = this.find((node)=>{
						var _node_c_script, _node_c;
						return (_node_c = node.c) == null ? void 0 : (_node_c_script = _node_c.script) == null ? void 0 : _node_c_script.has(nameOrType);
				});
				return entities.map((entity)=>entity.c.script.get(nameOrType));
		}
		getGuid() {
				if (!this._guid) {
						this.setGuid(guid.create());
				}
				return this._guid;
		}
		setGuid(guid) {
				var index = this._app._entityIndex;
				if (this._guid) {
						delete index[this._guid];
				}
				this._guid = guid;
				index[this._guid] = this;
		}
		_notifyHierarchyStateChanged(node, enabled) {
				var enableFirst = false;
				if (node === this && _enableList.length === 0) {
						enableFirst = true;
				}
				node._beingEnabled = true;
				node._onHierarchyStateChanged(enabled);
				if (node._onHierarchyStatePostChanged) {
						_enableList.push(node);
				}
				var c = node._children;
				for(var i = 0, len = c.length; i < len; i++){
						if (c[i]._enabled) {
								this._notifyHierarchyStateChanged(c[i], enabled);
						}
				}
				node._beingEnabled = false;
				if (enableFirst) {
						for(var i1 = 0; i1 < _enableList.length; i1++){
								_enableList[i1]._onHierarchyStatePostChanged();
						}
						_enableList.length = 0;
				}
		}
		_onHierarchyStateChanged(enabled) {
				super._onHierarchyStateChanged(enabled);
				var components = this._getSortedComponents();
				for(var i = 0; i < components.length; i++){
						var component = components[i];
						if (component.enabled) {
								if (enabled) {
										component.onEnable();
								} else {
										component.onDisable();
								}
						}
				}
				releaseTempArray(components);
		}
		_onHierarchyStatePostChanged() {
				var components = this._getSortedComponents();
				for(var i = 0; i < components.length; i++){
						components[i].onPostStateChange();
				}
				releaseTempArray(components);
		}
		findByGuid(guid) {
				if (this._guid === guid) return this;
				var e = this._app._entityIndex[guid];
				if (e && (e === this || e.isDescendantOf(this))) {
						return e;
				}
				return null;
		}
		destroy() {
				this._destroying = true;
				for(var name in this.c){
						this.c[name].enabled = false;
				}
				for(var name1 in this.c){
						this.c[name1].system.removeComponent(this);
				}
				super.destroy();
				if (this._guid) {
						delete this._app._entityIndex[this._guid];
				}
				this._destroying = false;
		}
		clone() {
				var duplicatedIdsMap = {};
				var clone = this._cloneRecursively(duplicatedIdsMap);
				duplicatedIdsMap[this.getGuid()] = clone;
				resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
				return clone;
		}
		_getSortedComponents() {
				var components = this.c;
				var sortedArray = getTempArray();
				var needSort = 0;
				for(var type in components){
						if (components.hasOwnProperty(type)) {
								var component = components[type];
								needSort |= component.constructor.order !== 0;
								sortedArray.push(component);
						}
				}
				if (needSort && sortedArray.length > 1) {
						sortStaticOrder(sortedArray);
				}
				return sortedArray;
		}
		_cloneRecursively(duplicatedIdsMap) {
				var clone = new this.constructor(undefined, this._app);
				super._cloneInternal(clone);
				for(var type in this.c){
						var component = this.c[type];
						component.system.cloneComponent(this, clone);
				}
				for(var i = 0; i < this._children.length; i++){
						var oldChild = this._children[i];
						if (oldChild instanceof Entity) {
								var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
								clone.addChild(newChild);
								duplicatedIdsMap[oldChild.getGuid()] = newChild;
						}
				}
				return clone;
		}
		constructor(name, app = getApplication()){
				super(name), this.c = {}, this._destroying = false, this._guid = null, this._template = false;
				this._app = app;
		}
}
Entity.EVENT_DESTROY = 'destroy';
function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
		if (oldEntity instanceof Entity) {
				var components = oldEntity.c;
				for(var componentName in components){
						var component = components[componentName];
						var entityProperties = component.system.getPropertiesOfType('entity');
						for(var i = 0, len = entityProperties.length; i < len; i++){
								var propertyDescriptor = entityProperties[i];
								var propertyName = propertyDescriptor.name;
								var oldEntityReferenceId = component[propertyName];
								var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
								if (entityIsWithinOldSubtree) {
										var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
										if (newEntityReferenceId) {
												newEntity.c[componentName][propertyName] = newEntityReferenceId;
										}
								}
						}
				}
				if (components.script) {
						newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
				}
				if (components.render) {
						newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
				}
				if (components.button) {
						newEntity.button.resolveDuplicatedEntityReferenceProperties(components.button, duplicatedIdsMap);
				}
				if (components.scrollview) {
						newEntity.scrollview.resolveDuplicatedEntityReferenceProperties(components.scrollview, duplicatedIdsMap);
				}
				if (components.scrollbar) {
						newEntity.scrollbar.resolveDuplicatedEntityReferenceProperties(components.scrollbar, duplicatedIdsMap);
				}
				if (components.anim) {
						newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
				}
				var _old = oldEntity.children.filter((e)=>e instanceof Entity);
				var _new = newEntity.children.filter((e)=>e instanceof Entity);
				for(var i1 = 0, len1 = _old.length; i1 < len1; i1++){
						resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i1], _new[i1], duplicatedIdsMap);
				}
		}
}

class SceneRegistryItem {
		get loaded() {
				return !!this.data;
		}
		get loading() {
				return this._loading;
		}
		constructor(name, url){
				this.data = null;
				this._loading = false;
				this._onLoadedCallbacks = [];
				this.name = name;
				this.url = url;
		}
}

class SceneRegistry {
		destroy() {
				this._app = null;
		}
		list() {
				return this._list;
		}
		add(name, url) {
				if (this._index.hasOwnProperty(name)) {
						return false;
				}
				var item = new SceneRegistryItem(name, url);
				var i = this._list.push(item);
				this._index[item.name] = i - 1;
				this._urlIndex[item.url] = i - 1;
				return true;
		}
		find(name) {
				if (this._index.hasOwnProperty(name)) {
						return this._list[this._index[name]];
				}
				return null;
		}
		findByUrl(url) {
				if (this._urlIndex.hasOwnProperty(url)) {
						return this._list[this._urlIndex[url]];
				}
				return null;
		}
		remove(name) {
				if (this._index.hasOwnProperty(name)) {
						var idx = this._index[name];
						var item = this._list[idx];
						delete this._urlIndex[item.url];
						delete this._index[name];
						this._list.splice(idx, 1);
						for(var i = 0; i < this._list.length; i++){
								item = this._list[i];
								this._index[item.name] = i;
								this._urlIndex[item.url] = i;
						}
				}
		}
		_loadSceneData(sceneItem, storeInCache, callback) {
				var app = this._app;
				var url = sceneItem;
				if (typeof sceneItem === 'string') {
						sceneItem = this.findByUrl(url) || this.find(url) || new SceneRegistryItem('Untitled', url);
				}
				url = sceneItem.url;
				if (!url) {
						callback('Cannot find scene to load');
						return;
				}
				if (sceneItem.loaded) {
						callback(null, sceneItem);
						return;
				}
				if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
						url = path.join(app.assets.prefix, url);
				}
				sceneItem._onLoadedCallbacks.push(callback);
				if (!sceneItem._loading) {
						var handler = app.loader.getHandler('hierarchy');
						handler.load(url, (err, data)=>{
								sceneItem.data = data;
								sceneItem._loading = false;
								for(var i = 0; i < sceneItem._onLoadedCallbacks.length; i++){
										sceneItem._onLoadedCallbacks[i](err, sceneItem);
								}
								if (!storeInCache) {
										sceneItem.data = null;
								}
								sceneItem._onLoadedCallbacks.length = 0;
						});
				}
				sceneItem._loading = true;
		}
		loadSceneData(sceneItem, callback) {
				this._loadSceneData(sceneItem, true, callback);
		}
		unloadSceneData(sceneItem) {
				if (typeof sceneItem === 'string') {
						sceneItem = this.findByUrl(sceneItem);
				}
				if (sceneItem) {
						sceneItem.data = null;
				}
		}
		_loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {
				this._loadSceneData(sceneItem, false, (err, sceneItem)=>{
						if (err) {
								if (callback) {
										callback(err);
								}
								return;
						}
						if (onBeforeAddHierarchy) {
								onBeforeAddHierarchy(sceneItem);
						}
						var app = this._app;
						var _loaded = ()=>{
								var handler = app.loader.getHandler('hierarchy');
								app.systems.script.preloading = true;
								var entity = handler.open(sceneItem.url, sceneItem.data);
								app.systems.script.preloading = false;
								app.loader.clearCache(sceneItem.url, 'hierarchy');
								app.root.addChild(entity);
								app.systems.fire('initialize', entity);
								app.systems.fire('postInitialize', entity);
								app.systems.fire('postPostInitialize', entity);
								if (callback) callback(null, entity);
						};
						app._preloadScripts(sceneItem.data, _loaded);
				});
		}
		loadSceneHierarchy(sceneItem, callback) {
				this._loadSceneHierarchy(sceneItem, null, callback);
		}
		loadSceneSettings(sceneItem, callback) {
				this._loadSceneData(sceneItem, false, (err, sceneItem)=>{
						if (!err) {
								this._app.applySceneSettings(sceneItem.data.settings);
								if (callback) {
										callback(null);
								}
						} else {
								if (callback) {
										callback(err);
								}
						}
				});
		}
		changeScene(sceneItem, callback) {
				var app = this._app;
				var onBeforeAddHierarchy = (sceneItem)=>{
						var { children } = app.root;
						while(children.length){
								children[0].destroy();
						}
						app.applySceneSettings(sceneItem.data.settings);
				};
				this._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);
		}
		loadScene(url, callback) {
				var app = this._app;
				var handler = app.loader.getHandler('scene');
				if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
						url = path.join(app.assets.prefix, url);
				}
				handler.load(url, (err, data)=>{
						if (!err) {
								var _loaded = ()=>{
										app.systems.script.preloading = true;
										var scene = handler.open(url, data);
										var sceneItem = this.findByUrl(url);
										if (sceneItem && !sceneItem.loaded) {
												sceneItem.data = data;
										}
										app.systems.script.preloading = false;
										app.loader.clearCache(url, 'scene');
										app.loader.patch({
												resource: scene,
												type: 'scene'
										}, app.assets);
										app.root.addChild(scene.root);
										if (app.systems.rigidbody && typeof Ammo !== 'undefined') {
												app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
										}
										if (callback) {
												callback(null, scene);
										}
								};
								app._preloadScripts(data, _loaded);
						} else {
								if (callback) {
										callback(err);
								}
						}
				});
		}
		constructor(app){
				this._list = [];
				this._index = {};
				this._urlIndex = {};
				this._app = app;
		}
}

class ApplicationStats {
		get scene() {
				return getApplication().scene._stats;
		}
		get lightmapper() {
				var _getApplication_lightmapper;
				return (_getApplication_lightmapper = getApplication().lightmapper) == null ? void 0 : _getApplication_lightmapper.stats;
		}
		get batcher() {
				var batcher = getApplication()._batcher;
				return batcher ? batcher._stats : null;
		}
		constructor(device){
				this.frame = {
						fps: 0,
						ms: 0,
						dt: 0,
						updateStart: 0,
						updateTime: 0,
						renderStart: 0,
						renderTime: 0,
						physicsStart: 0,
						physicsTime: 0,
						cullTime: 0,
						sortTime: 0,
						skinTime: 0,
						morphTime: 0,
						instancingTime: 0,
						triangles: 0,
						otherPrimitives: 0,
						shaders: 0,
						materials: 0,
						cameras: 0,
						shadowMapUpdates: 0,
						shadowMapTime: 0,
						depthMapTime: 0,
						forwardTime: 0,
						lightClustersTime: 0,
						lightClusters: 0,
						_timeToCountFrames: 0,
						_fpsAccum: 0
				};
				this.drawCalls = {
						forward: 0,
						depth: 0,
						shadow: 0,
						immediate: 0,
						misc: 0,
						total: 0,
						skinned: 0,
						instanced: 0,
						removedByInstancing: 0
				};
				this.misc = {
						renderTargetCreationTime: 0
				};
				this.particles = {
						updatesPerFrame: 0,
						_updatesPerFrame: 0,
						frameTime: 0,
						_frameTime: 0
				};
				this.shaders = device._shaderStats;
				this.vram = device._vram;
				Object.defineProperty(this.vram, 'totalUsed', {
						get: function get() {
								return this.tex + this.vb + this.ib;
						}
				});
				Object.defineProperty(this.vram, 'geom', {
						get: function get() {
								return this.vb + this.ib;
						}
				});
		}
}

var app = null;
class AppBase extends EventHandler {
		init(appOptions) {
				var { assetPrefix, batchManager, componentSystems, elementInput, gamepads, graphicsDevice, keyboard, lightmapper, mouse, resourceHandlers, scriptsOrder, scriptPrefix, soundManager, touch, xr } = appOptions;
				this.graphicsDevice = graphicsDevice;
				this._initDefaultMaterial();
				this._initProgramLibrary();
				this.stats = new ApplicationStats(graphicsDevice);
				this._soundManager = soundManager;
				this.scene = new Scene(graphicsDevice);
				this._registerSceneImmediate(this.scene);
				this.assets = new AssetRegistry(this.loader);
				if (assetPrefix) this.assets.prefix = assetPrefix;
				this.bundles = new BundleRegistry(this.assets);
				this.scriptsOrder = scriptsOrder || [];
				this.defaultLayerWorld = new Layer({
						name: 'World',
						id: LAYERID_WORLD
				});
				this.defaultLayerDepth = new Layer({
						name: 'Depth',
						id: LAYERID_DEPTH,
						enabled: false,
						opaqueSortMode: SORTMODE_NONE
				});
				this.defaultLayerSkybox = new Layer({
						name: 'Skybox',
						id: LAYERID_SKYBOX,
						opaqueSortMode: SORTMODE_NONE
				});
				this.defaultLayerUi = new Layer({
						name: 'UI',
						id: LAYERID_UI,
						transparentSortMode: SORTMODE_MANUAL
				});
				this.defaultLayerImmediate = new Layer({
						name: 'Immediate',
						id: LAYERID_IMMEDIATE,
						opaqueSortMode: SORTMODE_NONE
				});
				var defaultLayerComposition = new LayerComposition('default');
				defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
				defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
				defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
				defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
				defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
				defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
				defaultLayerComposition.pushTransparent(this.defaultLayerUi);
				this.scene.layers = defaultLayerComposition;
				AreaLightLuts.createPlaceholder(graphicsDevice);
				this.renderer = new ForwardRenderer(graphicsDevice);
				this.renderer.scene = this.scene;
				if (lightmapper) {
						this.lightmapper = new lightmapper(graphicsDevice, this.root, this.scene, this.renderer, this.assets);
						this.once('prerender', this._firstBake, this);
				}
				if (batchManager) {
						this._batcher = new batchManager(graphicsDevice, this.root, this.scene);
						this.once('prerender', this._firstBatch, this);
				}
				this.keyboard = keyboard || null;
				this.mouse = mouse || null;
				this.touch = touch || null;
				this.gamepads = gamepads || null;
				if (elementInput) {
						this.elementInput = elementInput;
						this.elementInput.app = this;
				}
				this.xr = xr ? new xr(this) : null;
				if (this.elementInput) this.elementInput.attachSelectEvents();
				this._scriptPrefix = scriptPrefix || '';
				if (this.enableBundles) {
						this.loader.addHandler('bundle', new BundleHandler(this));
				}
				resourceHandlers.forEach((resourceHandler)=>{
						var handler = new resourceHandler(this);
						this.loader.addHandler(handler.handlerType, handler);
				});
				componentSystems.forEach((componentSystem)=>{
						this.systems.add(new componentSystem(this));
				});
				this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
				if (typeof document !== 'undefined') {
						if (document.hidden !== undefined) {
								this._hiddenAttr = 'hidden';
								document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
						} else if (document.mozHidden !== undefined) {
								this._hiddenAttr = 'mozHidden';
								document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
						} else if (document.msHidden !== undefined) {
								this._hiddenAttr = 'msHidden';
								document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
						} else if (document.webkitHidden !== undefined) {
								this._hiddenAttr = 'webkitHidden';
								document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
						}
				}
				this.tick = makeTick(this);
		}
		static getApplication(id) {
				return id ? AppBase._applications[id] : getApplication();
		}
		_initDefaultMaterial() {
				var material = new StandardMaterial();
				material.name = 'Default Material';
				setDefaultMaterial(this.graphicsDevice, material);
		}
		_initProgramLibrary() {
				var library = new ProgramLibrary(this.graphicsDevice, new StandardMaterial());
				setProgramLibrary(this.graphicsDevice, library);
		}
		get soundManager() {
				return this._soundManager;
		}
		get batcher() {
				return this._batcher;
		}
		get fillMode() {
				return this._fillMode;
		}
		get resolutionMode() {
				return this._resolutionMode;
		}
		configure(url, callback) {
				http.get(url, (err, response)=>{
						if (err) {
								callback(err);
								return;
						}
						var props = response.application_properties;
						var scenes = response.scenes;
						var assets = response.assets;
						this._parseApplicationProperties(props, (err)=>{
								this._parseScenes(scenes);
								this._parseAssets(assets);
								if (!err) {
										callback(null);
								} else {
										callback(err);
								}
						});
				});
		}
		preload(callback) {
				this.fire('preload:start');
				var assets = this.assets.list({
						preload: true
				});
				if (assets.length === 0) {
						this.fire('preload:end');
						callback();
						return;
				}
				var loadedCount = 0;
				var onAssetLoadOrError = ()=>{
						loadedCount++;
						this.fire('preload:progress', loadedCount / assets.length);
						if (loadedCount === assets.length) {
								this.fire('preload:end');
								callback();
						}
				};
				assets.forEach((asset)=>{
						if (!asset.loaded) {
								asset.once('load', onAssetLoadOrError);
								asset.once('error', onAssetLoadOrError);
								this.assets.load(asset);
						} else {
								onAssetLoadOrError();
						}
				});
		}
		_preloadScripts(sceneData, callback) {
				callback();
		}
		_parseApplicationProperties(props, callback) {
				if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
						this.loader.enableRetry(props.maxAssetRetries);
				}
				if (!props.useDevicePixelRatio) {
						props.useDevicePixelRatio = props.use_device_pixel_ratio;
				}
				if (!props.resolutionMode) {
						props.resolutionMode = props.resolution_mode;
				}
				if (!props.fillMode) {
						props.fillMode = props.fill_mode;
				}
				this._width = props.width;
				this._height = props.height;
				if (props.useDevicePixelRatio) {
						this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
				}
				this.setCanvasResolution(props.resolutionMode, this._width, this._height);
				this.setCanvasFillMode(props.fillMode, this._width, this._height);
				if (props.layers && props.layerOrder) {
						var composition = new LayerComposition('application');
						var layers = {};
						for(var key in props.layers){
								var data = props.layers[key];
								data.id = parseInt(key, 10);
								data.enabled = data.id !== LAYERID_DEPTH;
								layers[key] = new Layer(data);
						}
						for(var i = 0, len = props.layerOrder.length; i < len; i++){
								var sublayer = props.layerOrder[i];
								var layer = layers[sublayer.layer];
								if (!layer) continue;
								if (sublayer.transparent) {
										composition.pushTransparent(layer);
								} else {
										composition.pushOpaque(layer);
								}
								composition.subLayerEnabled[i] = sublayer.enabled;
						}
						this.scene.layers = composition;
				}
				if (props.batchGroups) {
						var batcher = this.batcher;
						if (batcher) {
								for(var i1 = 0, len1 = props.batchGroups.length; i1 < len1; i1++){
										var grp = props.batchGroups[i1];
										batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
								}
						}
				}
				if (props.i18nAssets) {
						this.i18n.assets = props.i18nAssets;
				}
				this._loadLibraries(props.libraries, callback);
		}
		_loadLibraries(urls, callback) {
				var len = urls.length;
				var count = len;
				var regex = /^https?:\/\//;
				if (len) {
						var onLoad = (err, script)=>{
								count--;
								if (err) {
										callback(err);
								} else if (count === 0) {
										this.onLibrariesLoaded();
										callback(null);
								}
						};
						for(var i = 0; i < len; ++i){
								var url = urls[i];
								if (!regex.test(url.toLowerCase()) && this._scriptPrefix) {
										url = path.join(this._scriptPrefix, url);
								}
								this.loader.load(url, "script", onLoad);
						}
				} else {
						this.onLibrariesLoaded();
						callback(null);
				}
		}
		_parseScenes(scenes) {
				if (!scenes) return;
				for(var i = 0; i < scenes.length; i++){
						this.scenes.add(scenes[i].name, scenes[i].url);
				}
		}
		_parseAssets(assets) {
				var list = [];
				var scriptsIndex = {};
				var bundlesIndex = {};
				for(var i = 0; i < this.scriptsOrder.length; i++){
						var id = this.scriptsOrder[i];
						if (!assets[id]) {
								continue;
						}
						scriptsIndex[id] = true;
						list.push(assets[id]);
				}
				if (this.enableBundles) {
						for(var id1 in assets){
								if (assets[id1].type === 'bundle') {
										bundlesIndex[id1] = true;
										list.push(assets[id1]);
								}
						}
				}
				for(var id2 in assets){
						if (scriptsIndex[id2] || bundlesIndex[id2]) {
								continue;
						}
						list.push(assets[id2]);
				}
				for(var i1 = 0; i1 < list.length; i1++){
						var data = list[i1];
						var asset = new Asset(data.name, data.type, data.file, data.data);
						asset.id = parseInt(data.id, 10);
						asset.preload = data.preload ? data.preload : false;
						asset.loaded = data.type === "script" && data.data && data.data.loadingType > 0;
						asset.tags.add(data.tags);
						if (data.i18n) {
								for(var locale in data.i18n){
										asset.addLocalizedAssetId(locale, data.i18n[locale]);
								}
						}
						this.assets.add(asset);
				}
		}
		start() {
				this.frame = 0;
				this.fire('start', {
						timestamp: now(),
						target: this
				});
				if (!this._librariesLoaded) {
						this.onLibrariesLoaded();
				}
				this.systems.fire('initialize', this.root);
				this.fire('initialize');
				this.systems.fire('postInitialize', this.root);
				this.systems.fire('postPostInitialize', this.root);
				this.fire('postinitialize');
				this.tick();
		}
		inputUpdate(dt) {
				if (this.controller) {
						this.controller.update(dt);
				}
				if (this.mouse) {
						this.mouse.update();
				}
				if (this.keyboard) {
						this.keyboard.update();
				}
				if (this.gamepads) {
						this.gamepads.update();
				}
		}
		update(dt) {
				this.frame++;
				this.graphicsDevice.updateClientRect();
				this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
				this.systems.fire('animationUpdate', dt);
				this.systems.fire('postUpdate', dt);
				this.fire('update', dt);
				this.inputUpdate(dt);
		}
		frameStart() {
				this.graphicsDevice.frameStart();
		}
		frameEnd() {
				this.graphicsDevice.frameEnd();
		}
		render() {
				this.fire('prerender');
				this.root.syncHierarchy();
				if (this._batcher) {
						this._batcher.updateAll();
				}
				this.renderComposition(this.scene.layers);
				this.fire('postrender');
		}
		renderComposition(layerComposition) {
				this.renderer.update(layerComposition);
				this.renderer.buildFrameGraph(this.frameGraph, layerComposition);
				this.frameGraph.render(this.graphicsDevice);
		}
		_fillFrameStatsBasic(now, dt, ms) {
				var stats = this.stats.frame;
				stats.dt = dt;
				stats.ms = ms;
				if (now > stats._timeToCountFrames) {
						stats.fps = stats._fpsAccum;
						stats._fpsAccum = 0;
						stats._timeToCountFrames = now + 1000;
				} else {
						stats._fpsAccum++;
				}
				this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
				this.graphicsDevice._drawCallsPerFrame = 0;
		}
		_fillFrameStats() {
				var stats = this.stats.frame;
				stats.cameras = this.renderer._camerasRendered;
				stats.materials = this.renderer._materialSwitches;
				stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
				stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
				stats.shadowMapTime = this.renderer._shadowMapTime;
				stats.depthMapTime = this.renderer._depthMapTime;
				stats.forwardTime = this.renderer._forwardTime;
				var prims = this.graphicsDevice._primsPerFrame;
				stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
				stats.cullTime = this.renderer._cullTime;
				stats.sortTime = this.renderer._sortTime;
				stats.skinTime = this.renderer._skinTime;
				stats.morphTime = this.renderer._morphTime;
				stats.lightClusters = this.renderer._lightClusters;
				stats.lightClustersTime = this.renderer._lightClustersTime;
				stats.otherPrimitives = 0;
				for(var i = 0; i < prims.length; i++){
						if (i < PRIMITIVE_TRIANGLES) {
								stats.otherPrimitives += prims[i];
						}
						prims[i] = 0;
				}
				this.renderer._camerasRendered = 0;
				this.renderer._materialSwitches = 0;
				this.renderer._shadowMapUpdates = 0;
				this.graphicsDevice._shaderSwitchesPerFrame = 0;
				this.renderer._cullTime = 0;
				this.renderer._layerCompositionUpdateTime = 0;
				this.renderer._lightClustersTime = 0;
				this.renderer._sortTime = 0;
				this.renderer._skinTime = 0;
				this.renderer._morphTime = 0;
				this.renderer._shadowMapTime = 0;
				this.renderer._depthMapTime = 0;
				this.renderer._forwardTime = 0;
				stats = this.stats.drawCalls;
				stats.forward = this.renderer._forwardDrawCalls;
				stats.culled = this.renderer._numDrawCallsCulled;
				stats.depth = 0;
				stats.shadow = this.renderer._shadowDrawCalls;
				stats.skinned = this.renderer._skinDrawCalls;
				stats.immediate = 0;
				stats.instanced = 0;
				stats.removedByInstancing = 0;
				stats.misc = stats.total - (stats.forward + stats.shadow);
				this.renderer._depthDrawCalls = 0;
				this.renderer._shadowDrawCalls = 0;
				this.renderer._forwardDrawCalls = 0;
				this.renderer._numDrawCallsCulled = 0;
				this.renderer._skinDrawCalls = 0;
				this.renderer._immediateRendered = 0;
				this.renderer._instancedDrawCalls = 0;
				this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
				stats = this.stats.particles;
				stats.updatesPerFrame = stats._updatesPerFrame;
				stats.frameTime = stats._frameTime;
				stats._updatesPerFrame = 0;
				stats._frameTime = 0;
		}
		setCanvasFillMode(mode, width, height) {
				this._fillMode = mode;
				this.resizeCanvas(width, height);
		}
		setCanvasResolution(mode, width, height) {
				this._resolutionMode = mode;
				if (mode === RESOLUTION_AUTO && width === undefined) {
						width = this.graphicsDevice.canvas.clientWidth;
						height = this.graphicsDevice.canvas.clientHeight;
				}
				this.graphicsDevice.resizeCanvas(width, height);
		}
		isHidden() {
				return document[this._hiddenAttr];
		}
		onVisibilityChange() {
				if (this.isHidden()) {
						if (this._soundManager) {
								this._soundManager.suspend();
						}
				} else {
						if (this._soundManager) {
								this._soundManager.resume();
						}
				}
		}
		resizeCanvas(width, height) {
				if (!this._allowResize) return undefined;
				if (this.xr && this.xr.session) {
						return undefined;
				}
				var windowWidth = window.innerWidth;
				var windowHeight = window.innerHeight;
				if (this._fillMode === FILLMODE_KEEP_ASPECT) {
						var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
						var winR = windowWidth / windowHeight;
						if (r > winR) {
								width = windowWidth;
								height = width / r;
						} else {
								height = windowHeight;
								width = height * r;
						}
				} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
						width = windowWidth;
						height = windowHeight;
				}
				this.graphicsDevice.canvas.style.width = "" + width + "px";
				this.graphicsDevice.canvas.style.height = "" + height + "px";
				this.updateCanvasSize();
				return {
						width: width,
						height: height
				};
		}
		updateCanvasSize() {
				var _this_xr;
				if (!this._allowResize || ((_this_xr = this.xr) == null ? void 0 : _this_xr.active)) {
						return;
				}
				if (this._resolutionMode === RESOLUTION_AUTO) {
						var canvas = this.graphicsDevice.canvas;
						this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
				}
		}
		onLibrariesLoaded() {
				this._librariesLoaded = true;
				if (this.systems.rigidbody) {
						this.systems.rigidbody.onLibraryLoaded();
				}
		}
		applySceneSettings(settings) {
				var asset;
				if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
						var [x, y, z] = settings.physics.gravity;
						this.systems.rigidbody.gravity.set(x, y, z);
				}
				this.scene.applySettings(settings);
				if (settings.render.hasOwnProperty('skybox')) {
						if (settings.render.skybox) {
								asset = this.assets.get(settings.render.skybox);
								if (asset) {
										this.setSkybox(asset);
								} else {
										this.assets.once("add:" + settings.render.skybox, this.setSkybox, this);
								}
						} else {
								this.setSkybox(null);
						}
				}
		}
		setAreaLightLuts(ltcMat1, ltcMat2) {
				if (ltcMat1 && ltcMat2) {
						AreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);
				}
		}
		setSkybox(asset) {
				if (asset !== this._skyboxAsset) {
						var onSkyboxRemoved = ()=>{
								this.setSkybox(null);
						};
						var onSkyboxChanged = ()=>{
								this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);
						};
						if (this._skyboxAsset) {
								this.assets.off("load:" + this._skyboxAsset.id, onSkyboxChanged, this);
								this.assets.off("remove:" + this._skyboxAsset.id, onSkyboxRemoved, this);
								this._skyboxAsset.off('change', onSkyboxChanged, this);
						}
						this._skyboxAsset = asset;
						if (this._skyboxAsset) {
								this.assets.on("load:" + this._skyboxAsset.id, onSkyboxChanged, this);
								this.assets.once("remove:" + this._skyboxAsset.id, onSkyboxRemoved, this);
								this._skyboxAsset.on('change', onSkyboxChanged, this);
								if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
										this._skyboxAsset.loadFaces = true;
								}
								this.assets.load(this._skyboxAsset);
						}
						onSkyboxChanged();
				}
		}
		_firstBake() {
				var _this_lightmapper;
				(_this_lightmapper = this.lightmapper) == null ? void 0 : _this_lightmapper.bake(null, this.scene.lightmapMode);
		}
		_firstBatch() {
				var _this_batcher;
				(_this_batcher = this.batcher) == null ? void 0 : _this_batcher.generate();
		}
		_processTimestamp(timestamp) {
				return timestamp;
		}
		drawLine(start, end, color, depthTest, layer) {
				this.scene.drawLine(start, end, color, depthTest, layer);
		}
		drawLines(positions, colors, depthTest, layer) {
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.drawLines(positions, colors, depthTest, layer);
		}
		drawLineArrays(positions, colors, depthTest, layer) {
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.drawLineArrays(positions, colors, depthTest, layer);
		}
		drawWireSphere(center, radius, color, segments, depthTest, layer) {
				if (color === void 0) color = Color.WHITE;
				if (segments === void 0) segments = 20;
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
		}
		drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat) {
				if (color === void 0) color = Color.WHITE;
				if (depthTest === void 0) depthTest = true;
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat);
		}
		drawMeshInstance(meshInstance, layer) {
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
		}
		drawMesh(mesh, material, matrix, layer) {
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
		}
		drawQuad(matrix, material, layer) {
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
		}
		drawTexture(x, y, width, height, texture, material, layer, filterable) {
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				if (filterable === void 0) filterable = true;
				if (filterable === false && !this.graphicsDevice.isWebGPU) {
						return;
				}
				var matrix = new Mat4();
				matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, -height, 0.0));
				if (!material) {
						material = new ShaderMaterial();
						material.cull = CULLFACE_NONE;
						material.setParameter('colorMap', texture);
						material.shaderDesc = filterable ? this.scene.immediate.getTextureShaderDesc(texture.encoding) : this.scene.immediate.getUnfilterableTextureShaderDesc();
						material.update();
				}
				this.drawQuad(matrix, material, layer);
		}
		drawDepthTexture(x, y, width, height, layer) {
				if (layer === void 0) layer = this.scene.defaultDrawLayer;
				var material = new ShaderMaterial();
				material.cull = CULLFACE_NONE;
				material.shaderDesc = this.scene.immediate.getDepthTextureShaderDesc();
				material.update();
				this.drawTexture(x, y, width, height, null, material, layer);
		}
		destroy() {
				var _this_lightmapper, _this_xr, _this_xr1, _this__soundManager;
				if (this._inFrameUpdate) {
						this._destroyRequested = true;
						return;
				}
				var canvasId = this.graphicsDevice.canvas.id;
				this.fire('destroy', this);
				this.off('librariesloaded');
				if (typeof document !== 'undefined') {
						document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
						document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
						document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
						document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
				}
				this._visibilityChangeHandler = null;
				this.root.destroy();
				this.root = null;
				if (this.mouse) {
						this.mouse.off();
						this.mouse.detach();
						this.mouse = null;
				}
				if (this.keyboard) {
						this.keyboard.off();
						this.keyboard.detach();
						this.keyboard = null;
				}
				if (this.touch) {
						this.touch.off();
						this.touch.detach();
						this.touch = null;
				}
				if (this.elementInput) {
						this.elementInput.detach();
						this.elementInput = null;
				}
				if (this.gamepads) {
						this.gamepads.destroy();
						this.gamepads = null;
				}
				if (this.controller) {
						this.controller = null;
				}
				this.systems.destroy();
				if (this.scene.layers) {
						this.scene.layers.destroy();
				}
				var assets = this.assets.list();
				for(var i = 0; i < assets.length; i++){
						assets[i].unload();
						assets[i].off();
				}
				this.assets.off();
				this.bundles.destroy();
				this.bundles = null;
				this.i18n.destroy();
				this.i18n = null;
				var scriptHandler = this.loader.getHandler("script");
				scriptHandler == null ? void 0 : scriptHandler.clearCache();
				this.loader.destroy();
				this.loader = null;
				this.scene.destroy();
				this.scene = null;
				this.systems = null;
				this.context = null;
				this.scripts.destroy();
				this.scripts = null;
				this.scenes.destroy();
				this.scenes = null;
				(_this_lightmapper = this.lightmapper) == null ? void 0 : _this_lightmapper.destroy();
				this.lightmapper = null;
				if (this._batcher) {
						this._batcher.destroy();
						this._batcher = null;
				}
				this._entityIndex = {};
				this.defaultLayerDepth.onDisable = null;
				this.defaultLayerDepth.onEnable = null;
				this.defaultLayerDepth = null;
				this.defaultLayerWorld = null;
				(_this_xr = this.xr) == null ? void 0 : _this_xr.end();
				(_this_xr1 = this.xr) == null ? void 0 : _this_xr1.destroy();
				this.renderer.destroy();
				this.renderer = null;
				this.graphicsDevice.destroy();
				this.graphicsDevice = null;
				this.tick = null;
				this.off();
				(_this__soundManager = this._soundManager) == null ? void 0 : _this__soundManager.destroy();
				this._soundManager = null;
				script.app = null;
				AppBase._applications[canvasId] = null;
				if (getApplication() === this) {
						setApplication(null);
				}
				AppBase.cancelTick(this);
		}
		static cancelTick(app) {
				if (app.frameRequestId) {
						window.cancelAnimationFrame(app.frameRequestId);
						app.frameRequestId = undefined;
				}
		}
		getEntityFromIndex(guid) {
				return this._entityIndex[guid];
		}
		_registerSceneImmediate(scene) {
				this.on('postrender', scene.immediate.onPostRender, scene.immediate);
		}
		constructor(canvas){
				super(), this._batcher = null, this._destroyRequested = false, this._inFrameUpdate = false, this._librariesLoaded = false, this._fillMode = FILLMODE_KEEP_ASPECT, this._resolutionMode = RESOLUTION_FIXED, this._allowResize = true, this._skyboxAsset = null, this._entityIndex = {}, this._inTools = false, this._scriptPrefix = '', this._time = 0, this.enableBundles = typeof TextDecoder !== 'undefined', this.timeScale = 1, this.maxDeltaTime = 0.1, this.frame = 0, this.frameGraph = new FrameGraph(), this.scriptsOrder = [], this.autoRender = true, this.renderNextFrame = false, this.lightmapper = null, this.loader = new ResourceLoader(this), this.scenes = new SceneRegistry(this), this.scripts = new ScriptRegistry(this), this.systems = new ComponentSystemRegistry(), this.i18n = new I18n(this), this.keyboard = null, this.mouse = null, this.touch = null, this.gamepads = null, this.elementInput = null, this.xr = null;
				AppBase._applications[canvas.id] = this;
				setApplication(this);
				app = this;
				this.root = new Entity();
				this.root._enabledInHierarchy = true;
		}
}
AppBase._applications = {};
var _frameEndData = {};
var makeTick = function makeTick(_app) {
		var application = _app;
		return function(timestamp, frame) {
				var _application_xr;
				if (!application.graphicsDevice) {
						return;
				}
				if (application.frameRequestId) {
						var _application_xr_session, _application_xr1;
						(_application_xr1 = application.xr) == null ? void 0 : (_application_xr_session = _application_xr1.session) == null ? void 0 : _application_xr_session.cancelAnimationFrame(application.frameRequestId);
						cancelAnimationFrame(application.frameRequestId);
						application.frameRequestId = null;
				}
				application._inFrameUpdate = true;
				setApplication(application);
				app = application;
				var currentTime = application._processTimestamp(timestamp) || now();
				var ms = currentTime - (application._time || currentTime);
				var dt = ms / 1000.0;
				dt = math.clamp(dt, 0, application.maxDeltaTime);
				dt *= application.timeScale;
				application._time = currentTime;
				if ((_application_xr = application.xr) == null ? void 0 : _application_xr.session) {
						application.frameRequestId = application.xr.session.requestAnimationFrame(application.tick);
				} else {
						application.frameRequestId = platform.browser || platform.worker ? requestAnimationFrame(application.tick) : null;
				}
				if (application.graphicsDevice.contextLost) {
						return;
				}
				application._fillFrameStatsBasic(currentTime, dt, ms);
				application.fire('frameupdate', ms);
				var shouldRenderFrame = true;
				if (frame) {
						var _application_xr2;
						shouldRenderFrame = (_application_xr2 = application.xr) == null ? void 0 : _application_xr2.update(frame);
						application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
				} else {
						application.graphicsDevice.defaultFramebuffer = null;
				}
				if (shouldRenderFrame) {
						application.update(dt);
						application.fire('framerender');
						if (application.autoRender || application.renderNextFrame) {
								application.updateCanvasSize();
								application.frameStart();
								application.render();
								application.frameEnd();
								application.renderNextFrame = false;
						}
						_frameEndData.timestamp = now();
						_frameEndData.target = application;
						application.fire('frameend', _frameEndData);
				}
				application._inFrameUpdate = false;
				if (application._destroyRequested) {
						application.destroy();
				}
		};
};

class AppOptions {
		constructor(){
				this.componentSystems = [];
				this.resourceHandlers = [];
		}
}

var tempSphere = new BoundingSphere();
class BakeLight {
		store() {
				this.mask = this.light.mask;
				this.shadowUpdateMode = this.light.shadowUpdateMode;
				this.enabled = this.light.enabled;
				this.intensity = this.light.intensity;
				this.rotation = this.light._node.getLocalRotation().clone();
				this.numCascades = this.light.numCascades;
				this.castShadows = this.light._castShadows;
		}
		restore() {
				var light = this.light;
				light.mask = this.mask;
				light.shadowUpdateMode = this.shadowUpdateMode;
				light.enabled = this.enabled;
				light.intensity = this.intensity;
				light._node.setLocalRotation(this.rotation);
				light.numCascades = this.numCascades;
				light._castShadows = this.castShadows;
		}
		startBake() {
				this.light.enabled = true;
				this.light._destroyShadowMap();
				this.light.beginFrame();
		}
		endBake(shadowMapCache) {
				var light = this.light;
				light.enabled = false;
				if (light.shadowMap) {
						if (light.shadowMap.cached) {
								shadowMapCache.add(light, light.shadowMap);
						}
						light.shadowMap = null;
				}
		}
		constructor(scene, light, lightingParams){
				this.scene = scene;
				this.light = light;
				this.store();
				light.numCascades = 1;
				if (this.scene.clusteredLightingEnabled && !lightingParams.shadowsEnabled) {
						light.castShadows = false;
				}
				if (light.type !== LIGHTTYPE_DIRECTIONAL) {
						light._node.getWorldTransform();
						light.getBoundingSphere(tempSphere);
						this.lightBounds = new BoundingBox();
						this.lightBounds.center.copy(tempSphere.center);
						this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
				}
		}
}

var _tempPoint$1 = new Vec2();
class BakeLightSimple extends BakeLight {
		get numVirtualLights() {
				if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
						return this.light.bakeNumSamples;
				}
				return 1;
		}
		prepareVirtualLight(index, numVirtualLights) {
				var light = this.light;
				light._node.setLocalRotation(this.rotation);
				if (index > 0) {
						var directionalSpreadAngle = light.bakeArea;
						random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);
						_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);
						light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
				}
				light._node.getWorldTransform();
				var gamma = 2.2;
				var linearIntensity = Math.pow(this.intensity, gamma);
				light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		}
		constructor(lightmapper, light){
				super(lightmapper.scene, light, lightmapper.lightingParams);
		}
}

var _tempPoint = new Vec3();
class BakeLightAmbient extends BakeLight {
		get numVirtualLights() {
				return this.light.bakeNumSamples;
		}
		prepareVirtualLight(index, numVirtualLights) {
				random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);
				this.light._node.lookAt(_tempPoint.mulScalar(-1));
				this.light._node.rotateLocal(90, 0, 0);
				var gamma = 2.2;
				var fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
				var linearIntensity = Math.pow(fullIntensity, gamma);
				this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		}
		constructor(lightmapper){
				var scene = lightmapper.scene;
				var lightEntity = new Entity('AmbientLight');
				lightEntity.addComponent('light', {
						type: 'directional',
						affectDynamic: true,
						affectLightmapped: false,
						bake: true,
						bakeNumSamples: scene.ambientBakeNumSamples,
						castShadows: true,
						normalOffsetBias: 0.05,
						shadowBias: 0.2,
						shadowDistance: 1,
						shadowResolution: 2048,
						shadowType: SHADOW_PCF3_32F,
						color: Color.WHITE,
						intensity: 1,
						bakeDir: false
				});
				super(scene, lightEntity.light.light, lightmapper.lightingParams);
		}
}

class BakeMeshNode {
		store() {
				this.castShadows = this.component.castShadows;
		}
		restore() {
				this.component.castShadows = this.castShadows;
		}
		constructor(node, meshInstances = null){
				this.node = node;
				this.component = node.render || node.model;
				meshInstances = meshInstances || this.component.meshInstances;
				this.store();
				this.meshInstances = meshInstances;
				this.bounds = null;
				this.renderTargets = [];
		}
}

var DENOISE_FILTER_SIZE = 15;
class LightmapFilters {
		setSourceTexture(texture) {
				this.constantTexSource.setValue(texture);
		}
		prepare(textureWidth, textureHeight) {
				this.pixelOffset[0] = 1 / textureWidth;
				this.pixelOffset[1] = 1 / textureHeight;
				this.constantPixelOffset.setValue(this.pixelOffset);
		}
		prepareDenoise(filterRange, filterSmoothness, bakeHDR) {
				var index = bakeHDR ? 0 : 1;
				if (!this.shaderDenoise[index]) {
						var name = "lmBilateralDeNoise-" + (bakeHDR ? 'hdr' : 'rgbm');
						var define = bakeHDR ? '#define HDR\n' : '';
						this.shaderDenoise[index] = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, define + shaderChunksLightmapper.bilateralDeNoisePS, name);
						this.sigmas = new Float32Array(2);
						this.constantSigmas = this.device.scope.resolve('sigmas');
						this.constantKernel = this.device.scope.resolve('kernel[0]');
						this.bZnorm = this.device.scope.resolve('bZnorm');
				}
				this.sigmas[0] = filterRange;
				this.sigmas[1] = filterSmoothness;
				this.constantSigmas.setValue(this.sigmas);
				this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
		}
		getDenoise(bakeHDR) {
				var index = bakeHDR ? 0 : 1;
				return this.shaderDenoise[index];
		}
		getDilate(device, bakeHDR) {
				var index = bakeHDR ? 0 : 1;
				if (!this.shaderDilate[index]) {
						var name = "lmDilate-" + (bakeHDR ? 'hdr' : 'rgbm');
						var define = bakeHDR ? '#define HDR\n' : '';
						this.shaderDilate[index] = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, define + shaderChunksLightmapper.dilatePS, name);
				}
				return this.shaderDilate[index];
		}
		evaluateDenoiseUniforms(filterRange, filterSmoothness) {
				function normpdf(x, sigma) {
						return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
				}
				this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
				var kernel = this.kernel;
				var kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);
				for(var j = 0; j <= kSize; ++j){
						var value = normpdf(j, filterRange);
						kernel[kSize + j] = value;
						kernel[kSize - j] = value;
				}
				this.constantKernel.setValue(this.kernel);
				var bZnorm = 1 / normpdf(0.0, filterSmoothness);
				this.bZnorm.setValue(bZnorm);
		}
		constructor(device){
				this.device = device;
				this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, 'lmDilate');
				this.constantTexSource = device.scope.resolve('source');
				this.constantPixelOffset = device.scope.resolve('pixelOffset');
				this.pixelOffset = new Float32Array(2);
				this.shaderDenoise = [];
				this.sigmas = null;
				this.constantSigmas = null;
				this.kernel = null;
		}
}

class RenderPassLightmapper extends RenderPass {
		destroy() {
				this.viewBindGroups.forEach((bg)=>{
						bg.defaultUniformBuffer.destroy();
						bg.destroy();
				});
				this.viewBindGroups.length = 0;
		}
		execute() {
				this.device;
				var { renderer, camera, receivers, renderTarget, worldClusters, lightArray } = this;
				renderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_FORWARD, this.viewBindGroups, {
						meshInstances: receivers,
						splitLights: lightArray,
						lightClusters: worldClusters
				});
		}
		constructor(device, renderer, camera, worldClusters, receivers, lightArray){
				super(device), this.viewBindGroups = [];
				this.renderer = renderer;
				this.camera = camera;
				this.worldClusters = worldClusters;
				this.receivers = receivers;
				this.lightArray = lightArray;
		}
}

var MAX_LIGHTMAP_SIZE = 2048;
var PASS_COLOR = 0;
var PASS_DIR = 1;
var tempVec$1 = new Vec3();
class Lightmapper {
		destroy() {
				var _this_camera;
				LightmapCache.decRef(this.blackTex);
				this.blackTex = null;
				LightmapCache.destroy();
				this.device = null;
				this.root = null;
				this.scene = null;
				this.renderer = null;
				this.assets = null;
				(_this_camera = this.camera) == null ? void 0 : _this_camera.destroy();
				this.camera = null;
		}
		initBake(device) {
				this.bakeHDR = this.scene.lightmapPixelFormat !== PIXELFORMAT_RGBA8;
				if (!this._initCalled) {
						this._initCalled = true;
						this.lightmapFilters = new LightmapFilters(device);
						this.constantBakeDir = device.scope.resolve('bakeDir');
						this.materials = [];
						this.blackTex = new Texture(this.device, {
								width: 4,
								height: 4,
								format: PIXELFORMAT_RGBA8,
								type: TEXTURETYPE_RGBM,
								name: 'lightmapBlack'
						});
						LightmapCache.incRef(this.blackTex);
						var camera = new Camera();
						camera.clearColor.set(0, 0, 0, 0);
						camera.clearColorBuffer = true;
						camera.clearDepthBuffer = false;
						camera.clearStencilBuffer = false;
						camera.frustumCulling = false;
						camera.projection = PROJECTION_ORTHOGRAPHIC;
						camera.aspectRatio = 1;
						camera.node = new GraphNode();
						this.camera = camera;
						this.camera.shaderParams.gammaCorrection = GAMMA_NONE;
						this.camera.shaderParams.toneMapping = TONEMAP_LINEAR;
				}
				if (this.scene.clusteredLightingEnabled) {
						var lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, ()=>{});
						this.lightingParams = lightingParams;
						var srcParams = this.scene.lighting;
						lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
						lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
						lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
						lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
						lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
						lightingParams.cells = new Vec3(3, 3, 3);
						lightingParams.maxLightsPerCell = 4;
						this.worldClusters = new WorldClusters(device);
						this.worldClusters.name = 'ClusterLightmapper';
				}
		}
		finishBake(bakeNodes) {
				this.materials = [];
				function destroyRT(rt) {
						LightmapCache.decRef(rt.colorBuffer);
						rt.destroy();
				}
				this.renderTargets.forEach((rt)=>{
						destroyRT(rt);
				});
				this.renderTargets.clear();
				bakeNodes.forEach((node)=>{
						node.renderTargets.forEach((rt)=>{
								destroyRT(rt);
						});
						node.renderTargets.length = 0;
				});
				this.ambientAOMaterial = null;
				if (this.worldClusters) {
						this.worldClusters.destroy();
						this.worldClusters = null;
				}
		}
		createMaterialForPass(device, scene, pass, addAmbient) {
				var material = new StandardMaterial();
				material.name = "lmMaterial-pass:" + pass + "-ambient:" + addAmbient;
				material.chunks.APIVersion = CHUNKAPI_1_65;
				material.setDefine('UV1LAYOUT', '');
				if (pass === PASS_COLOR) {
						var bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;
						if (addAmbient) {
								bakeLmEndChunk = "\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(" + scene.ambientBakeOcclusionContrast.toFixed(1) + " + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(" + scene.ambientBakeOcclusionBrightness.toFixed(1) + ");\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                " + bakeLmEndChunk;
						} else {
								material.ambient = new Color(0, 0, 0);
						}
						material.chunks.basePS = shaderChunks.basePS + (this.bakeHDR ? '' : '\n#define LIGHTMAP_RGBM\n');
						material.chunks.endPS = bakeLmEndChunk;
						material.lightMap = this.blackTex;
				} else {
						material.chunks.basePS = "" + shaderChunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
						material.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;
				}
				material.chunks.outputAlphaPS = '\n';
				material.cull = CULLFACE_NONE;
				material.forceUv1 = true;
				material.update();
				return material;
		}
		createMaterials(device, scene, passCount) {
				for(var pass = 0; pass < passCount; pass++){
						if (!this.passMaterials[pass]) {
								this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
						}
				}
				if (!this.ambientAOMaterial) {
						this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);
						this.ambientAOMaterial.onUpdateShader = function(options) {
								options.litOptions.lightMapWithoutAmbient = true;
								options.litOptions.separateAmbient = true;
								return options;
						};
				}
		}
		createTexture(size, name) {
				return new Texture(this.device, {
						width: size,
						height: size,
						format: this.scene.lightmapPixelFormat,
						mipmaps: false,
						type: this.bakeHDR ? TEXTURETYPE_DEFAULT : TEXTURETYPE_RGBM,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						name: name
				});
		}
		collectModels(node, bakeNodes, allNodes) {
				var _node_model, _node_model1, _node_render;
				if (!node.enabled) return;
				var meshInstances;
				if (((_node_model = node.model) == null ? void 0 : _node_model.model) && ((_node_model1 = node.model) == null ? void 0 : _node_model1.enabled)) {
						if (allNodes) allNodes.push(new BakeMeshNode(node));
						if (node.model.lightmapped) {
								if (bakeNodes) {
										meshInstances = node.model.model.meshInstances;
								}
						}
				}
				if ((_node_render = node.render) == null ? void 0 : _node_render.enabled) {
						if (allNodes) allNodes.push(new BakeMeshNode(node));
						if (node.render.lightmapped) {
								if (bakeNodes) {
										meshInstances = node.render.meshInstances;
								}
						}
				}
				if (meshInstances) {
						var hasUv1 = true;
						for(var i = 0; i < meshInstances.length; i++){
								if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
										hasUv1 = false;
										break;
								}
						}
						if (hasUv1) {
								var notInstancedMeshInstances = [];
								for(var i1 = 0; i1 < meshInstances.length; i1++){
										var mesh = meshInstances[i1].mesh;
										if (this._tempSet.has(mesh)) {
												bakeNodes.push(new BakeMeshNode(node, [
														meshInstances[i1]
												]));
										} else {
												notInstancedMeshInstances.push(meshInstances[i1]);
										}
										this._tempSet.add(mesh);
								}
								this._tempSet.clear();
								if (notInstancedMeshInstances.length > 0) {
										bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
								}
						}
				}
				for(var i2 = 0; i2 < node._children.length; i2++){
						this.collectModels(node._children[i2], bakeNodes, allNodes);
				}
		}
		prepareShadowCasters(nodes) {
				var casters = [];
				for(var n = 0; n < nodes.length; n++){
						var component = nodes[n].component;
						component.castShadows = component.castShadowsLightmap;
						if (component.castShadowsLightmap) {
								var meshes = nodes[n].meshInstances;
								for(var i = 0; i < meshes.length; i++){
										meshes[i].visibleThisFrame = true;
										casters.push(meshes[i]);
								}
						}
				}
				return casters;
		}
		updateTransforms(nodes) {
				for(var i = 0; i < nodes.length; i++){
						var meshInstances = nodes[i].meshInstances;
						for(var j = 0; j < meshInstances.length; j++){
								meshInstances[j].node.getWorldTransform();
						}
				}
		}
		calculateLightmapSize(node) {
				var data;
				var sizeMult = this.scene.lightmapSizeMultiplier || 16;
				var scale = tempVec$1;
				var srcArea, lightmapSizeMultiplier;
				if (node.model) {
						lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;
						if (node.model.asset) {
								data = this.assets.get(node.model.asset).data;
								if (data.area) {
										srcArea = data.area;
								}
						} else if (node.model._area) {
								data = node.model;
								if (data._area) {
										srcArea = data._area;
								}
						}
				} else if (node.render) {
						lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;
						if (node.render.type !== 'asset') {
								if (node.render._area) {
										data = node.render;
										if (data._area) {
												srcArea = data._area;
										}
								}
						}
				}
				var area = {
						x: 1,
						y: 1,
						z: 1,
						uv: 1
				};
				if (srcArea) {
						area.x = srcArea.x;
						area.y = srcArea.y;
						area.z = srcArea.z;
						area.uv = srcArea.uv;
				}
				var areaMult = lightmapSizeMultiplier || 1;
				area.x *= areaMult;
				area.y *= areaMult;
				area.z *= areaMult;
				var component = node.render || node.model;
				var bounds = this.computeNodeBounds(component.meshInstances);
				scale.copy(bounds.halfExtents);
				var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
				totalArea /= area.uv;
				totalArea = Math.sqrt(totalArea);
				var lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
				return lightmapSize;
		}
		setLightmapping(nodes, value, passCount, shaderDefs) {
				for(var i = 0; i < nodes.length; i++){
						var node = nodes[i];
						var meshInstances = node.meshInstances;
						for(var j = 0; j < meshInstances.length; j++){
								var meshInstance = meshInstances[j];
								meshInstance.setLightmapped(value);
								if (value) {
										if (shaderDefs) {
												meshInstance._shaderDefs |= shaderDefs;
										}
										meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;
										for(var pass = 0; pass < passCount; pass++){
												var tex = node.renderTargets[pass].colorBuffer;
												tex.minFilter = FILTER_LINEAR;
												tex.magFilter = FILTER_LINEAR;
												meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
										}
								}
						}
				}
		}
		bake(nodes, mode) {
				if (mode === void 0) mode = BAKE_COLORDIR;
				var device = this.device;
				var startTime = now();
				this.scene._updateSkyMesh();
				this.stats.renderPasses = 0;
				this.stats.shadowMapTime = 0;
				this.stats.forwardTime = 0;
				var startShaders = device._shaderStats.linked;
				var startFboTime = device._renderTargetCreationTime;
				var startCompileTime = device._shaderStats.compileTime;
				var bakeNodes = [];
				var allNodes = [];
				if (nodes) {
						for(var i = 0; i < nodes.length; i++){
								this.collectModels(nodes[i], bakeNodes, null);
						}
						this.collectModels(this.root, null, allNodes);
				} else {
						this.collectModels(this.root, bakeNodes, allNodes);
				}
				if (bakeNodes.length > 0) {
						this.renderer.shadowRenderer.frameUpdate();
						var passCount = mode === BAKE_COLORDIR ? 2 : 1;
						this.setLightmapping(bakeNodes, false, passCount);
						this.initBake(device);
						this.bakeInternal(passCount, bakeNodes, allNodes);
						var shaderDefs = SHADERDEF_LM;
						if (mode === BAKE_COLORDIR) {
								shaderDefs |= SHADERDEF_DIRLM;
						}
						if (this.scene.ambientBake) {
								shaderDefs |= SHADERDEF_LMAMBIENT;
						}
						this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
						this.finishBake(bakeNodes);
				}
				var nowTime = now();
				this.stats.totalRenderTime = nowTime - startTime;
				this.stats.shadersLinked = device._shaderStats.linked - startShaders;
				this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
				this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
				this.stats.lightmapCount = bakeNodes.length;
		}
		allocateTextures(bakeNodes, passCount) {
				for(var i = 0; i < bakeNodes.length; i++){
						var bakeNode = bakeNodes[i];
						var size = this.calculateLightmapSize(bakeNode.node);
						for(var pass = 0; pass < passCount; pass++){
								var tex = this.createTexture(size, "lightmapper_lightmap_" + i);
								LightmapCache.incRef(tex);
								bakeNode.renderTargets[pass] = new RenderTarget({
										colorBuffer: tex,
										depth: false
								});
						}
						if (!this.renderTargets.has(size)) {
								var tex1 = this.createTexture(size, "lightmapper_temp_lightmap_" + size);
								LightmapCache.incRef(tex1);
								this.renderTargets.set(size, new RenderTarget({
										colorBuffer: tex1,
										depth: false
								}));
						}
				}
		}
		prepareLightsToBake(allLights, bakeLights) {
				if (this.scene.ambientBake) {
						var ambientLight = new BakeLightAmbient(this);
						bakeLights.push(ambientLight);
				}
				var sceneLights = this.renderer.lights;
				for(var i = 0; i < sceneLights.length; i++){
						var light = sceneLights[i];
						var bakeLight = new BakeLightSimple(this, light);
						allLights.push(bakeLight);
						if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
								light.mask = MASK_BAKE | MASK_AFFECT_LIGHTMAPPED | MASK_AFFECT_DYNAMIC;
								light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
								bakeLights.push(bakeLight);
						}
				}
				bakeLights.sort();
		}
		restoreLights(allLights) {
				for(var i = 0; i < allLights.length; i++){
						allLights[i].restore();
				}
		}
		setupScene() {
				this.ambientLight.copy(this.scene.ambientLight);
				if (!this.scene.ambientBake) {
						this.scene.ambientLight.set(0, 0, 0);
				}
				this.renderer.setSceneConstants();
		}
		restoreScene() {
				this.scene.ambientLight.copy(this.ambientLight);
		}
		computeNodeBounds(meshInstances) {
				var bounds = new BoundingBox();
				if (meshInstances.length > 0) {
						bounds.copy(meshInstances[0].aabb);
						for(var m = 1; m < meshInstances.length; m++){
								bounds.add(meshInstances[m].aabb);
						}
				}
				return bounds;
		}
		computeNodesBounds(nodes) {
				for(var i = 0; i < nodes.length; i++){
						var meshInstances = nodes[i].meshInstances;
						nodes[i].bounds = this.computeNodeBounds(meshInstances);
				}
		}
		computeBounds(meshInstances) {
				var bounds = new BoundingBox();
				for(var i = 0; i < meshInstances.length; i++){
						bounds.copy(meshInstances[0].aabb);
						for(var m = 1; m < meshInstances.length; m++){
								bounds.add(meshInstances[m].aabb);
						}
				}
				return bounds;
		}
		backupMaterials(meshInstances) {
				for(var i = 0; i < meshInstances.length; i++){
						this.materials[i] = meshInstances[i].material;
				}
		}
		restoreMaterials(meshInstances) {
				for(var i = 0; i < meshInstances.length; i++){
						meshInstances[i].material = this.materials[i];
				}
		}
		lightCameraPrepare(device, bakeLight) {
				var light = bakeLight.light;
				var shadowCam;
				if (light.type === LIGHTTYPE_SPOT) {
						var lightRenderData = light.getRenderData(null, 0);
						shadowCam = lightRenderData.shadowCamera;
						shadowCam._node.setPosition(light._node.getPosition());
						shadowCam._node.setRotation(light._node.getRotation());
						shadowCam._node.rotateLocal(-90, 0, 0);
						shadowCam.projection = PROJECTION_PERSPECTIVE;
						shadowCam.nearClip = light.attenuationEnd / 1000;
						shadowCam.farClip = light.attenuationEnd;
						shadowCam.aspectRatio = 1;
						shadowCam.fov = light._outerConeAngle * 2;
						this.renderer.updateCameraFrustum(shadowCam);
				}
				return shadowCam;
		}
		lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
				var light = bakeLight.light;
				var lightAffectsNode = true;
				if (light.type === LIGHTTYPE_DIRECTIONAL) {
						tempVec$1.copy(casterBounds.center);
						tempVec$1.y += casterBounds.halfExtents.y;
						this.camera.node.setPosition(tempVec$1);
						this.camera.node.setEulerAngles(-90, 0, 0);
						this.camera.nearClip = 0;
						this.camera.farClip = casterBounds.halfExtents.y * 2;
						var frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
						this.camera.orthoHeight = frustumSize;
				} else {
						if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
								lightAffectsNode = false;
						}
				}
				if (light.type === LIGHTTYPE_SPOT) {
						var nodeVisible = false;
						var meshInstances = bakeNode.meshInstances;
						for(var i = 0; i < meshInstances.length; i++){
								if (meshInstances[i]._isVisible(shadowCam)) {
										nodeVisible = true;
										break;
								}
						}
						if (!nodeVisible) {
								lightAffectsNode = false;
						}
				}
				return lightAffectsNode;
		}
		setupLightArray(lightArray, light) {
				lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
				lightArray[LIGHTTYPE_OMNI].length = 0;
				lightArray[LIGHTTYPE_SPOT].length = 0;
				lightArray[light.type][0] = light;
				light.visibleThisFrame = true;
		}
		renderShadowMap(comp, shadowMapRendered, casters, bakeLight) {
				var light = bakeLight.light;
				var isClustered = this.scene.clusteredLightingEnabled;
				var castShadow = light.castShadows && (!isClustered || this.scene.lighting.shadowsEnabled);
				if (!shadowMapRendered && castShadow) {
						if (!light.shadowMap && !isClustered) {
								light.shadowMap = this.shadowMapCache.get(this.device, light);
						}
						if (light.type === LIGHTTYPE_DIRECTIONAL) {
								this.renderer._shadowRendererDirectional.cull(light, comp, this.camera, casters);
								var shadowPass = this.renderer._shadowRendererDirectional.getLightRenderPass(light, this.camera);
								shadowPass == null ? void 0 : shadowPass.render();
						} else {
								if (this.device.isWebGPU) {
										return true;
								}
								this.renderer._shadowRendererLocal.cull(light, comp, casters);
								var insideRenderPass = false;
								this.renderer.shadowRenderer.render(light, this.camera, insideRenderPass);
						}
				}
				return true;
		}
		postprocessTextures(device, bakeNodes, passCount) {
				var numDilates2x = 1;
				var dilateShader = this.lightmapFilters.getDilate(device, this.bakeHDR);
				var denoiseShader;
				var filterLightmap = this.scene.lightmapFilterEnabled;
				if (filterLightmap) {
						this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness, this.bakeHDR);
						denoiseShader = this.lightmapFilters.getDenoise(this.bakeHDR);
				}
				device.setBlendState(BlendState.NOBLEND);
				device.setDepthState(DepthState.NODEPTH);
				device.setStencilState(null, null);
				for(var node = 0; node < bakeNodes.length; node++){
						var bakeNode = bakeNodes[node];
						for(var pass = 0; pass < passCount; pass++){
								var nodeRT = bakeNode.renderTargets[pass];
								var lightmap = nodeRT.colorBuffer;
								var tempRT = this.renderTargets.get(lightmap.width);
								var tempTex = tempRT.colorBuffer;
								this.lightmapFilters.prepare(lightmap.width, lightmap.height);
								for(var i = 0; i < numDilates2x; i++){
										this.lightmapFilters.setSourceTexture(lightmap);
										var bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
										drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? denoiseShader : dilateShader);
										this.lightmapFilters.setSourceTexture(tempTex);
										drawQuadWithShader(device, nodeRT, dilateShader);
								}
						}
				}
		}
		bakeInternal(passCount, bakeNodes, allNodes) {
				var scene = this.scene;
				var comp = scene.layers;
				var device = this.device;
				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
				this.createMaterials(device, scene, passCount);
				this.setupScene();
				comp._update();
				this.computeNodesBounds(bakeNodes);
				this.allocateTextures(bakeNodes, passCount);
				this.renderer.collectLights(comp);
				var allLights = [], bakeLights = [];
				this.prepareLightsToBake(allLights, bakeLights);
				this.updateTransforms(allNodes);
				var casters = this.prepareShadowCasters(allNodes);
				this.renderer.updateCpuSkinMatrices(casters);
				this.renderer.gpuUpdate(casters);
				var casterBounds = this.computeBounds(casters);
				var i, j, rcv, m;
				for(i = 0; i < bakeNodes.length; i++){
						var bakeNode = bakeNodes[i];
						rcv = bakeNode.meshInstances;
						for(j = 0; j < rcv.length; j++){
								m = rcv[j];
								m.setLightmapped(false);
								m.mask = MASK_BAKE;
								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], this.blackTex);
								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
						}
				}
				for(j = 0; j < bakeLights.length; j++){
						bakeLights[j].light.enabled = false;
				}
				var lightArray = [
						[],
						[],
						[]
				];
				var pass, node;
				var shadersUpdatedOn1stPass = false;
				for(i = 0; i < bakeLights.length; i++){
						var bakeLight = bakeLights[i];
						var isAmbientLight = bakeLight instanceof BakeLightAmbient;
						var isDirectional = bakeLight.light.type === LIGHTTYPE_DIRECTIONAL;
						var numVirtualLights = bakeLight.numVirtualLights;
						if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
								numVirtualLights = 1;
						}
						for(var virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++){
								if (numVirtualLights > 1) {
										bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
								}
								bakeLight.startBake();
								var shadowMapRendered = false;
								var shadowCam = this.lightCameraPrepare(device, bakeLight);
								for(node = 0; node < bakeNodes.length; node++){
										var bakeNode1 = bakeNodes[node];
										rcv = bakeNode1.meshInstances;
										var lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode1, shadowCam, casterBounds);
										if (!lightAffectsNode) {
												continue;
										}
										this.setupLightArray(lightArray, bakeLight.light);
										var clusterLights = isDirectional ? [] : [
												bakeLight.light
										];
										if (clusteredLightingEnabled) {
												this.renderer.lightTextureAtlas.update(clusterLights, this.lightingParams);
										}
										shadowMapRendered = this.renderShadowMap(comp, shadowMapRendered, casters, bakeLight);
										if (clusteredLightingEnabled) {
												this.worldClusters.update(clusterLights, this.lightingParams);
										}
										this.backupMaterials(rcv);
										for(pass = 0; pass < passCount; pass++){
												if (pass > 0 && virtualLightIndex > 0) {
														break;
												}
												if (isAmbientLight && pass > 0) {
														break;
												}
												var nodeRT = bakeNode1.renderTargets[pass];
												var lightmapSize = bakeNode1.renderTargets[pass].colorBuffer.width;
												var tempRT = this.renderTargets.get(lightmapSize);
												var tempTex = tempRT.colorBuffer;
												if (pass === 0) {
														shadersUpdatedOn1stPass = scene.updateShaders;
												} else if (shadersUpdatedOn1stPass) {
														scene.updateShaders = true;
												}
												var passMaterial = this.passMaterials[pass];
												if (isAmbientLight) {
														var lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;
														if (lastVirtualLightForPass && pass === 0) {
																passMaterial = this.ambientAOMaterial;
														}
												}
												for(j = 0; j < rcv.length; j++){
														rcv[j].material = passMaterial;
												}
												this.renderer.updateShaders(rcv);
												if (pass === PASS_DIR) {
														this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
												}
												if (device.isWebGPU) {
														var renderPass = new RenderPassLightmapper(device, this.renderer, this.camera, clusteredLightingEnabled ? this.worldClusters : null, rcv, lightArray);
														renderPass.init(tempRT);
														renderPass.render();
														renderPass.destroy();
												} else {
														this.renderer.setCamera(this.camera, tempRT, true);
														if (clusteredLightingEnabled) {
																this.worldClusters.activate();
														}
														this.renderer._forwardTime = 0;
														this.renderer._shadowMapTime = 0;
														this.renderer.renderForward(this.camera, tempRT, rcv, lightArray, SHADER_FORWARD);
														device.updateEnd();
												}
												bakeNode1.renderTargets[pass] = tempRT;
												this.renderTargets.set(lightmapSize, nodeRT);
												for(j = 0; j < rcv.length; j++){
														m = rcv[j];
														m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
														m._shaderDefs |= SHADERDEF_LM;
												}
										}
										this.restoreMaterials(rcv);
								}
								bakeLight.endBake(this.shadowMapCache);
						}
				}
				this.postprocessTextures(device, bakeNodes, passCount);
				for(node = 0; node < allNodes.length; node++){
						allNodes[node].restore();
				}
				this.restoreLights(allLights);
				this.restoreScene();
				if (!clusteredLightingEnabled) {
						this.shadowMapCache.clear();
				}
		}
		constructor(device, root, scene, renderer, assets){
				this.device = device;
				this.root = root;
				this.scene = scene;
				this.renderer = renderer;
				this.assets = assets;
				this.shadowMapCache = renderer.shadowMapCache;
				this._tempSet = new Set();
				this._initCalled = false;
				this.passMaterials = [];
				this.ambientAOMaterial = null;
				this.fog = '';
				this.ambientLight = new Color();
				this.renderTargets = new Map();
				this.stats = {
						renderPasses: 0,
						lightmapCount: 0,
						totalRenderTime: 0,
						forwardTime: 0,
						fboTime: 0,
						shadowMapTime: 0,
						compileTime: 0,
						shadersLinked: 0
				};
		}
}

class Component extends EventHandler {
		static _buildAccessors(obj, schema) {
				schema.forEach((descriptor)=>{
						var name = typeof descriptor === 'object' ? descriptor.name : descriptor;
						Object.defineProperty(obj, name, {
								get: function get() {
										return this.data[name];
								},
								set: function set(value) {
										var data = this.data;
										var oldValue = data[name];
										data[name] = value;
										this.fire('set', name, oldValue, value);
								},
								configurable: true
						});
				});
				obj._accessorsBuilt = true;
		}
		buildAccessors(schema) {
				Component._buildAccessors(this, schema);
		}
		onSetEnabled(name, oldValue, newValue) {
				if (oldValue !== newValue) {
						if (this.entity.enabled) {
								if (newValue) {
										this.onEnable();
								} else {
										this.onDisable();
								}
						}
				}
		}
		onEnable() {}
		onDisable() {}
		onPostStateChange() {}
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {}
		get enabled() {
				return true;
		}
		constructor(system, entity){
				super();
				this.system = system;
				this.entity = entity;
				if (this.system.schema && !this._accessorsBuilt) {
						this.buildAccessors(this.system.schema);
				}
				this.on('set', function(name, oldValue, newValue) {
						this.fire("set_" + name, name, oldValue, newValue);
				});
				this.on('set_enabled', this.onSetEnabled, this);
		}
}
Component.order = 0;

class ComponentSystem extends EventHandler {
		addComponent(entity, data) {
				if (data === void 0) data = {};
				var component = new this.ComponentType(this, entity);
				var componentData = new this.DataType();
				this.store[entity.getGuid()] = {
						entity: entity,
						data: componentData
				};
				entity[this.id] = component;
				entity.c[this.id] = component;
				this.initializeComponentData(component, data, []);
				this.fire('add', entity, component);
				return component;
		}
		removeComponent(entity) {
				var id = this.id;
				var record = this.store[entity.getGuid()];
				var component = entity.c[id];
				component.fire('beforeremove');
				this.fire('beforeremove', entity, component);
				delete this.store[entity.getGuid()];
				entity[id] = undefined;
				delete entity.c[id];
				this.fire('remove', entity, record.data);
		}
		cloneComponent(entity, clone) {
				var src = this.store[entity.getGuid()];
				return this.addComponent(clone, src.data);
		}
		initializeComponentData(component, data, properties) {
				if (data === void 0) data = {};
				for(var i = 0, len = properties.length; i < len; i++){
						var descriptor = properties[i];
						var name = void 0, type = void 0;
						if (typeof descriptor === 'object') {
								name = descriptor.name;
								type = descriptor.type;
						} else {
								name = descriptor;
								type = undefined;
						}
						var value = data[name];
						if (value !== undefined) {
								if (type !== undefined) {
										value = convertValue(value, type);
								}
								component[name] = value;
						} else {
								component[name] = component.data[name];
						}
				}
				if (component.enabled && component.entity.enabled) {
						component.onEnable();
				}
		}
		getPropertiesOfType(type) {
				var matchingProperties = [];
				var schema = this.schema || [];
				schema.forEach((descriptor)=>{
						if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
								matchingProperties.push(descriptor);
						}
				});
				return matchingProperties;
		}
		destroy() {
				this.off();
		}
		constructor(app){
				super();
				this.app = app;
				this.store = {};
				this.schema = [];
		}
}
function convertValue(value, type) {
		if (!value) {
				return value;
		}
		switch(type){
				case 'rgb':
						if (value instanceof Color) {
								return value.clone();
						}
						return new Color(value[0], value[1], value[2]);
				case 'rgba':
						if (value instanceof Color) {
								return value.clone();
						}
						return new Color(value[0], value[1], value[2], value[3]);
				case 'vec2':
						if (value instanceof Vec2) {
								return value.clone();
						}
						return new Vec2(value[0], value[1]);
				case 'vec3':
						if (value instanceof Vec3) {
								return value.clone();
						}
						return new Vec3(value[0], value[1], value[2]);
				case 'vec4':
						if (value instanceof Vec4) {
								return value.clone();
						}
						return new Vec4(value[0], value[1], value[2], value[3]);
				case 'boolean':
				case 'number':
				case 'string':
						return value;
				case 'entity':
						return value;
				default:
						throw new Error("Could not convert unhandled type: " + type);
		}
}

var INTERPOLATION_STEP = 0;
var INTERPOLATION_LINEAR = 1;
var INTERPOLATION_CUBIC = 2;

class AnimCache {
		update(time, input) {
				if (time < this._left || time >= this._right) {
						var len = input.length;
						if (!len) {
								this._left = -Infinity;
								this._right = Infinity;
								this._len = 0;
								this._recip = 0;
								this._p0 = this._p1 = 0;
						} else {
								if (time < input[0]) {
										this._left = -Infinity;
										this._right = input[0];
										this._len = 0;
										this._recip = 0;
										this._p0 = this._p1 = 0;
								} else if (time >= input[len - 1]) {
										this._left = input[len - 1];
										this._right = Infinity;
										this._len = 0;
										this._recip = 0;
										this._p0 = this._p1 = len - 1;
								} else {
										var index = this._findKey(time, input);
										this._left = input[index];
										this._right = input[index + 1];
										this._len = this._right - this._left;
										var diff = 1.0 / this._len;
										this._recip = isFinite(diff) ? diff : 0;
										this._p0 = index;
										this._p1 = index + 1;
								}
						}
				}
				this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
				this._hermite.valid = false;
		}
		_findKey(time, input) {
				var index = 0;
				while(time >= input[index + 1]){
						index++;
				}
				return index;
		}
		eval(result, interpolation, output) {
				var data = output._data;
				var comp = output._components;
				var idx0 = this._p0 * comp;
				if (interpolation === INTERPOLATION_STEP) {
						for(var i = 0; i < comp; ++i){
								result[i] = data[idx0 + i];
						}
				} else {
						var t = this._t;
						var idx1 = this._p1 * comp;
						switch(interpolation){
								case INTERPOLATION_LINEAR:
										for(var i1 = 0; i1 < comp; ++i1){
												result[i1] = math.lerp(data[idx0 + i1], data[idx1 + i1], t);
										}
										break;
								case INTERPOLATION_CUBIC:
										{
												var hermite = this._hermite;
												if (!hermite.valid) {
														var t2 = t * t;
														var twot = t + t;
														var omt = 1 - t;
														var omt2 = omt * omt;
														hermite.valid = true;
														hermite.p0 = (1 + twot) * omt2;
														hermite.m0 = t * omt2;
														hermite.p1 = t2 * (3 - twot);
														hermite.m1 = t2 * (t - 1);
												}
												var p0 = (this._p0 * 3 + 1) * comp;
												var m0 = (this._p0 * 3 + 2) * comp;
												var p1 = (this._p1 * 3 + 1) * comp;
												var m1 = (this._p1 * 3 + 0) * comp;
												for(var i2 = 0; i2 < comp; ++i2){
														result[i2] = hermite.p0 * data[p0 + i2] + hermite.m0 * data[m0 + i2] * this._len + hermite.p1 * data[p1 + i2] + hermite.m1 * data[m1 + i2] * this._len;
												}
												break;
										}
						}
				}
		}
		constructor(){
				this._left = Infinity;
				this._right = -Infinity;
				this._len = 0;
				this._recip = 0;
				this._p0 = 0;
				this._p1 = 0;
				this._t = 0;
				this._hermite = {
						valid: false,
						p0: 0,
						m0: 0,
						p1: 0,
						m1: 0
				};
		}
}

class AnimSnapshot {
		constructor(animTrack){
				this._name = "" + animTrack.name + "Snapshot";
				this._time = -1;
				this._cache = [];
				this._results = [];
				for(var i = 0; i < animTrack._inputs.length; ++i){
						this._cache[i] = new AnimCache();
				}
				var curves = animTrack._curves;
				var outputs = animTrack._outputs;
				for(var i1 = 0; i1 < curves.length; ++i1){
						var curve = curves[i1];
						var output = outputs[curve._output];
						var storage = [];
						for(var j = 0; j < output._components; ++j){
								storage[j] = 0;
						}
						this._results[i1] = storage;
				}
		}
}

function _extends$b() {
		_extends$b = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$b.apply(this, arguments);
}
class AnimClip {
		set name(name) {
				this._name = name;
		}
		get name() {
				return this._name;
		}
		set track(track) {
				this._track = track;
				this._snapshot = new AnimSnapshot(track);
		}
		get track() {
				return this._track;
		}
		get snapshot() {
				return this._snapshot;
		}
		set time(time) {
				this._time = time;
				this.alignCursorToCurrentTime();
		}
		get time() {
				return this._time;
		}
		set speed(speed) {
				var signChanged = Math.sign(speed) !== Math.sign(this._speed);
				this._speed = speed;
				if (signChanged) {
						this.alignCursorToCurrentTime();
				}
		}
		get speed() {
				return this._speed;
		}
		set loop(loop) {
				this._loop = loop;
		}
		get loop() {
				return this._loop;
		}
		set blendWeight(blendWeight) {
				this._blendWeight = blendWeight;
		}
		get blendWeight() {
				return this._blendWeight;
		}
		set blendOrder(blendOrder) {
				this._blendOrder = blendOrder;
		}
		get blendOrder() {
				return this._blendOrder;
		}
		set eventCursor(value) {
				this._eventCursor = value;
		}
		get eventCursor() {
				return this._eventCursor;
		}
		get eventCursorEnd() {
				return this.isReverse ? 0 : this._track.events.length - 1;
		}
		get nextEvent() {
				return this._track.events[this._eventCursor];
		}
		get isReverse() {
				return this._speed < 0;
		}
		nextEventAheadOfTime(time) {
				if (!this.nextEvent) return false;
				return this.isReverse ? this.nextEvent.time <= time : this.nextEvent.time >= time;
		}
		nextEventBehindTime(time) {
				if (!this.nextEvent) return false;
				if (time === this.track.duration) {
						return this.isReverse ? this.nextEvent.time >= time : this.nextEvent.time <= time;
				}
				return this.isReverse ? this.nextEvent.time > time : this.nextEvent.time < time;
		}
		resetEventCursor() {
				this._eventCursor = this.isReverse ? this._track.events.length - 1 : 0;
		}
		moveEventCursor() {
				this._eventCursor += this.isReverse ? -1 : 1;
				if (this._eventCursor >= this.track.events.length) {
						this._eventCursor = 0;
				} else if (this._eventCursor < 0) {
						this._eventCursor = this.track.events.length - 1;
				}
		}
		clipFrameTime(frameEndTime) {
				var eventFrame = AnimClip.eventFrame;
				eventFrame.start = 0;
				eventFrame.end = frameEndTime;
				eventFrame.residual = 0;
				if (this.isReverse) {
						if (frameEndTime < 0) {
								eventFrame.start = this.track.duration;
								eventFrame.end = 0;
								eventFrame.residual = frameEndTime + this.track.duration;
						}
				} else {
						if (frameEndTime > this.track.duration) {
								eventFrame.start = 0;
								eventFrame.end = this.track.duration;
								eventFrame.residual = frameEndTime - this.track.duration;
						}
				}
		}
		alignCursorToCurrentTime() {
				this.resetEventCursor();
				while(this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd){
						this.moveEventCursor();
				}
		}
		fireNextEvent() {
				this._eventHandler.fire(this.nextEvent.name, _extends$b({
						track: this.track
				}, this.nextEvent));
				this.moveEventCursor();
		}
		fireNextEventInFrame(frameStartTime, frameEndTime) {
				if (this.nextEventAheadOfTime(frameStartTime) && this.nextEventBehindTime(frameEndTime)) {
						this.fireNextEvent();
						return true;
				}
				return false;
		}
		activeEventsForFrame(frameStartTime, frameEndTime) {
				var eventFrame = AnimClip.eventFrame;
				this.clipFrameTime(frameEndTime);
				var initialCursor = this.eventCursor;
				while(this.fireNextEventInFrame(frameStartTime, eventFrame.end)){
						if (initialCursor === this.eventCursor) {
								break;
						}
				}
				if (this.loop && Math.abs(eventFrame.residual) > 0) {
						this.activeEventsForFrame(eventFrame.start, eventFrame.residual);
				}
		}
		progressForTime(time) {
				return time * this._speed / this._track.duration;
		}
		_update(deltaTime) {
				if (this._playing) {
						var time = this._time;
						var duration = this._track.duration;
						var speed = this._speed;
						var loop = this._loop;
						if (this._track.events.length > 0 && duration > 0) {
								this.activeEventsForFrame(time, time + speed * deltaTime);
						}
						time += speed * deltaTime;
						if (speed >= 0) {
								if (time > duration) {
										if (loop) {
												time = time % duration || 0;
										} else {
												time = this._track.duration;
												this.pause();
										}
								}
						} else {
								if (time < 0) {
										if (loop) {
												time = duration + (time % duration || 0);
										} else {
												time = 0;
												this.pause();
										}
								}
						}
						this._time = time;
				}
				if (this._time !== this._snapshot._time) {
						this._track.eval(this._time, this._snapshot);
				}
		}
		play() {
				this._playing = true;
				this._time = 0;
		}
		stop() {
				this._playing = false;
				this._time = 0;
		}
		pause() {
				this._playing = false;
		}
		resume() {
				this._playing = true;
		}
		reset() {
				this._time = 0;
		}
		constructor(track, time, speed, playing, loop, eventHandler){
				this._name = track.name;
				this._track = track;
				this._snapshot = new AnimSnapshot(track);
				this._playing = playing;
				this._time = time;
				this._speed = speed;
				this._loop = loop;
				this._blendWeight = 1.0;
				this._blendOrder = 0.0;
				this._eventHandler = eventHandler;
				this.alignCursorToCurrentTime();
		}
}
AnimClip.eventFrame = {
		start: 0,
		end: 0,
		residual: 0
};

var ANIM_INTERRUPTION_NONE = 'NONE';
var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
var ANIM_GREATER_THAN = 'GREATER_THAN';
var ANIM_LESS_THAN = 'LESS_THAN';
var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
var ANIM_EQUAL_TO = 'EQUAL_TO';
var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
var ANIM_PARAMETER_INTEGER = 'INTEGER';
var ANIM_PARAMETER_FLOAT = 'FLOAT';
var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
var ANIM_BLEND_1D = '1D';
var ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
var ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
var ANIM_BLEND_DIRECT = 'DIRECT';
var ANIM_STATE_START = 'START';
var ANIM_STATE_END = 'END';
var ANIM_STATE_ANY = 'ANY';
var ANIM_CONTROL_STATES = [
		ANIM_STATE_START,
		ANIM_STATE_END,
		ANIM_STATE_ANY
];
var ANIM_LAYER_OVERWRITE = 'OVERWRITE';
var ANIM_LAYER_ADDITIVE = 'ADDITIVE';

class AnimBlend {
		static dot(a, b) {
				var len = a.length;
				var result = 0;
				for(var i = 0; i < len; ++i){
						result += a[i] * b[i];
				}
				return result;
		}
		static normalize(a) {
				var l = AnimBlend.dot(a, a);
				if (l > 0) {
						l = 1.0 / Math.sqrt(l);
						var len = a.length;
						for(var i = 0; i < len; ++i){
								a[i] *= l;
						}
				}
		}
		static set(a, b, type) {
				var len = a.length;
				if (type === 'quaternion') {
						var l = AnimBlend.dot(b, b);
						if (l > 0) {
								l = 1.0 / Math.sqrt(l);
						}
						for(var i = 0; i < len; ++i){
								a[i] = b[i] * l;
						}
				} else {
						for(var i1 = 0; i1 < len; ++i1){
								a[i1] = b[i1];
						}
				}
		}
		static blendVec(a, b, t, additive) {
				var it = additive ? 1.0 : 1.0 - t;
				var len = a.length;
				for(var i = 0; i < len; ++i){
						a[i] = a[i] * it + b[i] * t;
				}
		}
		static blendQuat(a, b, t, additive) {
				var len = a.length;
				var it = additive ? 1.0 : 1.0 - t;
				if (AnimBlend.dot(a, b) < 0) {
						t = -t;
				}
				for(var i = 0; i < len; ++i){
						a[i] = a[i] * it + b[i] * t;
				}
				if (!additive) {
						AnimBlend.normalize(a);
				}
		}
		static blend(a, b, t, type, additive) {
				if (type === 'quaternion') {
						AnimBlend.blendQuat(a, b, t, additive);
				} else {
						AnimBlend.blendVec(a, b, t, additive);
				}
		}
		static stableSort(a, lessFunc) {
				var len = a.length;
				for(var i = 0; i < len - 1; ++i){
						for(var j = i + 1; j < len; ++j){
								if (lessFunc(a[j], a[i])) {
										var tmp = a[i];
										a[i] = a[j];
										a[j] = tmp;
								}
						}
				}
		}
}

class AnimTargetValue {
		get _normalizeWeights() {
				return this._component.normalizeWeights;
		}
		getWeight(index) {
				if (this.dirty) this.updateWeights();
				if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
						return 0;
				} else if (this._normalizeWeights) {
						return this.weights[index] / this.totalWeight;
				}
				return math.clamp(this.weights[index], 0, 1);
		}
		_layerBlendType(index) {
				return this._component.layers[index].blendType;
		}
		setMask(index, value) {
				this.mask[index] = value;
				if (this._normalizeWeights) {
						if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
								this.mask = this.mask.fill(0, 0, index);
						}
						this.dirty = true;
				}
		}
		updateWeights() {
				this.totalWeight = 0;
				for(var i = 0; i < this.weights.length; i++){
						this.weights[i] = this._component.layers[i].weight;
						this.totalWeight += this.mask[i] * this.weights[i];
				}
				this.dirty = false;
		}
		updateValue(index, value) {
				if (this.counter === 0) {
						AnimBlend.set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);
						if (!this._normalizeWeights) {
								AnimBlend.blend(this.value, this.baseValue, 1, this.valueType);
						}
				}
				if (!this.mask[index] || this.getWeight(index) === 0) return;
				if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
						if (this.valueType === AnimTargetValue.TYPE_QUAT) {
								var v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
								var aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
								var aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
								var aV = aV1.invert().mul(aV2);
								aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
								v.mul(aV);
								AnimTargetValue.quatArr[0] = v.x;
								AnimTargetValue.quatArr[1] = v.y;
								AnimTargetValue.quatArr[2] = v.z;
								AnimTargetValue.quatArr[3] = v.w;
								AnimBlend.set(this.value, AnimTargetValue.quatArr, this.valueType);
						} else {
								AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
								AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
								AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];
								AnimBlend.blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
						}
				} else {
						AnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);
				}
				if (this.setter) this.setter(this.value);
		}
		unbind() {
				if (this.setter) {
						this.setter(this.baseValue);
				}
		}
		constructor(component, type){
				this._component = component;
				this.mask = new Int8Array(component.layers.length);
				this.weights = new Float32Array(component.layers.length);
				this.totalWeight = 0;
				this.counter = 0;
				this.layerCounter = 0;
				this.valueType = type;
				this.dirty = true;
				this.value = type === AnimTargetValue.TYPE_QUAT ? [
						0,
						0,
						0,
						1
				] : [
						0,
						0,
						0
				];
				this.baseValue = null;
				this.setter = null;
		}
}
AnimTargetValue.TYPE_QUAT = 'quaternion';
AnimTargetValue.TYPE_VEC3 = 'vector3';
AnimTargetValue.q1 = new Quat();
AnimTargetValue.q2 = new Quat();
AnimTargetValue.q3 = new Quat();
AnimTargetValue.quatArr = [
		0,
		0,
		0,
		1
];
AnimTargetValue.vecArr = [
		0,
		0,
		0
];
AnimTargetValue.IDENTITY_QUAT_ARR = [
		0,
		0,
		0,
		1
];

class AnimEvaluator {
		get clips() {
				return this._clips;
		}
		addClip(clip) {
				var targets = this._targets;
				var binder = this._binder;
				var curves = clip.track.curves;
				var snapshot = clip.snapshot;
				var inputs = [];
				var outputs = [];
				for(var i = 0; i < curves.length; ++i){
						var curve = curves[i];
						var paths = curve.paths;
						for(var j = 0; j < paths.length; ++j){
								var path = paths[j];
								var resolved = binder.resolve(path);
								var target = targets[resolved && resolved.targetPath || null];
								if (!target && resolved) {
										target = {
												target: resolved,
												value: [],
												curves: 0,
												blendCounter: 0
										};
										for(var k = 0; k < target.target.components; ++k){
												target.value.push(0);
										}
										targets[resolved.targetPath] = target;
										if (binder.animComponent) {
												if (!binder.animComponent.targets[resolved.targetPath]) {
														var type = void 0;
														if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
																type = AnimTargetValue.TYPE_QUAT;
														} else {
																type = AnimTargetValue.TYPE_VEC3;
														}
														binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
												}
												binder.animComponent.targets[resolved.targetPath].layerCounter++;
												binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
										}
								}
								if (target) {
										target.curves++;
										inputs.push(snapshot._results[i]);
										outputs.push(target);
								}
						}
				}
				this._clips.push(clip);
				this._inputs.push(inputs);
				this._outputs.push(outputs);
		}
		removeClip(index) {
				var targets = this._targets;
				var binder = this._binder;
				var clips = this._clips;
				var clip = clips[index];
				var curves = clip.track.curves;
				for(var i = 0; i < curves.length; ++i){
						var curve = curves[i];
						var paths = curve.paths;
						for(var j = 0; j < paths.length; ++j){
								var path = paths[j];
								var target = this._binder.resolve(path);
								if (target) {
										target.curves--;
										if (target.curves === 0) {
												binder.unresolve(path);
												delete targets[target.targetPath];
												if (binder.animComponent) {
														binder.animComponent.targets[target.targetPath].layerCounter--;
												}
										}
								}
						}
				}
				clips.splice(index, 1);
				this._inputs.splice(index, 1);
				this._outputs.splice(index, 1);
		}
		removeClips() {
				while(this._clips.length > 0){
						this.removeClip(0);
				}
		}
		updateClipTrack(name, animTrack) {
				this._clips.forEach((clip)=>{
						if (clip.name.includes(name)) {
								clip.track = animTrack;
						}
				});
				this.rebind();
		}
		findClip(name) {
				var clips = this._clips;
				for(var i = 0; i < clips.length; ++i){
						var clip = clips[i];
						if (clip.name === name) {
								return clip;
						}
				}
				return null;
		}
		rebind() {
				this._binder.rebind();
				this._targets = {};
				var clips = [
						...this.clips
				];
				this.removeClips();
				clips.forEach((clip)=>{
						this.addClip(clip);
				});
		}
		assignMask(mask) {
				return this._binder.assignMask(mask);
		}
		update(deltaTime, outputAnimation) {
				if (outputAnimation === void 0) outputAnimation = true;
				var clips = this._clips;
				var order = clips.map((c, i)=>{
						return i;
				});
				AnimBlend.stableSort(order, (a, b)=>{
						return clips[a].blendOrder < clips[b].blendOrder;
				});
				for(var i = 0; i < order.length; ++i){
						var index = order[i];
						var clip = clips[index];
						var inputs = this._inputs[index];
						var outputs = this._outputs[index];
						var blendWeight = clip.blendWeight;
						if (blendWeight > 0.0) {
								clip._update(deltaTime);
						}
						if (!outputAnimation) break;
						var input = void 0;
						var output = void 0;
						var value = void 0;
						if (blendWeight >= 1.0) {
								for(var j = 0; j < inputs.length; ++j){
										input = inputs[j];
										output = outputs[j];
										value = output.value;
										AnimBlend.set(value, input, output.target.type);
										output.blendCounter++;
								}
						} else if (blendWeight > 0.0) {
								for(var j1 = 0; j1 < inputs.length; ++j1){
										input = inputs[j1];
										output = outputs[j1];
										value = output.value;
										if (output.blendCounter === 0) {
												AnimBlend.set(value, input, output.target.type);
										} else {
												AnimBlend.blend(value, input, blendWeight, output.target.type);
										}
										output.blendCounter++;
								}
						}
				}
				var targets = this._targets;
				var binder = this._binder;
				for(var path in targets){
						if (targets.hasOwnProperty(path)) {
								var target = targets[path];
								if (binder.animComponent && target.target.isTransform) {
										var animTarget = binder.animComponent.targets[path];
										if (animTarget.counter === animTarget.layerCounter) {
												animTarget.counter = 0;
										}
										if (!animTarget.path) {
												animTarget.path = path;
												animTarget.baseValue = target.target.get();
												animTarget.setter = target.target.set;
										}
										animTarget.updateValue(binder.layerIndex, target.value);
										animTarget.counter++;
								} else {
										target.target.set(target.value);
								}
								target.blendCounter = 0;
						}
				}
				this._binder.update(deltaTime);
		}
		constructor(binder){
				this._binder = binder;
				this._clips = [];
				this._inputs = [];
				this._outputs = [];
				this._targets = {};
		}
}

class AnimEvents {
		get events() {
				return this._events;
		}
		constructor(events){
				this._events = [
						...events
				];
				this._events.sort((a, b)=>a.time - b.time);
		}
}

class AnimTrack {
		get name() {
				return this._name;
		}
		get duration() {
				return this._duration;
		}
		get inputs() {
				return this._inputs;
		}
		get outputs() {
				return this._outputs;
		}
		get curves() {
				return this._curves;
		}
		set events(animEvents) {
				this._animEvents = animEvents;
		}
		get events() {
				return this._animEvents.events;
		}
		eval(time, snapshot) {
				snapshot._time = time;
				var inputs = this._inputs;
				var outputs = this._outputs;
				var curves = this._curves;
				var cache = snapshot._cache;
				var results = snapshot._results;
				for(var i = 0; i < inputs.length; ++i){
						cache[i].update(time, inputs[i]._data);
				}
				for(var i1 = 0; i1 < curves.length; ++i1){
						var curve = curves[i1];
						var output = outputs[curve._output];
						var result = results[i1];
						cache[curve._input].eval(result, curve._interpolation, output);
				}
		}
		constructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])){
				this._name = name;
				this._duration = duration;
				this._inputs = inputs;
				this._outputs = outputs;
				this._curves = curves;
				this._animEvents = animEvents;
		}
}
AnimTrack.EMPTY = Object.freeze(new AnimTrack('empty', Number.MAX_VALUE, [], [], []));

class AnimBinder {
		static joinPath(pathSegments, character) {
				character = character || '.';
				var escape = function escape(string) {
						return string.replace(/\\/g, '\\\\').replace(new RegExp("\\" + character, 'g'), "\\" + character);
				};
				return pathSegments.map(escape).join(character);
		}
		static splitPath(path, character) {
				character = character || '.';
				var result = [];
				var curr = '';
				var i = 0;
				while(i < path.length){
						var c = path[i++];
						if (c === '\\' && i < path.length) {
								c = path[i++];
								if (c === '\\' || c === character) {
										curr += c;
								} else {
										curr += "\\" + c;
								}
						} else if (c === character) {
								result.push(curr);
								curr = '';
						} else {
								curr += c;
						}
				}
				if (curr.length > 0) {
						result.push(curr);
				}
				return result;
		}
		static encode(entityPath, component, propertyPath) {
				return (Array.isArray(entityPath) ? entityPath.join('/') : entityPath) + "/" + component + "/" + (Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath);
		}
		resolve(path) {
				return null;
		}
		unresolve(path) {}
		update(deltaTime) {}
}

class AnimTarget {
		get set() {
				return this._set;
		}
		get get() {
				return this._get;
		}
		get type() {
				return this._type;
		}
		get components() {
				return this._components;
		}
		get targetPath() {
				return this._targetPath;
		}
		get isTransform() {
				return this._isTransform;
		}
		constructor(func, type, components, targetPath){
				if (func.set) {
						this._set = func.set;
						this._get = func.get;
				} else {
						this._set = func;
				}
				this._type = type;
				this._components = components;
				this._targetPath = targetPath;
				this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
		}
}

class DefaultAnimBinder {
		_isPathActive(path) {
				if (!this._mask) return true;
				var rootNodeNames = [
						path.entityPath[0],
						this.graph.name
				];
				for(var j = 0; j < rootNodeNames.length; ++j){
						var currEntityPath = rootNodeNames[j];
						if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;
						for(var i = 1; i < path.entityPath.length; i++){
								currEntityPath += "/" + path.entityPath[i];
								if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
						}
				}
				return false;
		}
		findNode(path) {
				if (!this._isPathActive(path)) {
						return null;
				}
				var node;
				if (this.graph) {
						node = this.graph.findByPath(path.entityPath);
						if (!node) {
								node = this.graph.findByPath(path.entityPath.slice(1));
						}
				}
				if (!node) {
						node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];
				}
				return node;
		}
		static createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
				var targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
				return new AnimTarget(func, type, valueCount, targetPath);
		}
		resolve(path) {
				var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
				var target = this.targetCache[encodedPath];
				if (target) return target;
				var node = this.findNode(path);
				if (!node) {
						return null;
				}
				var handler = this.handlers[path.propertyPath];
				if (!handler) {
						return null;
				}
				target = handler(node);
				if (!target) {
						return null;
				}
				this.targetCache[encodedPath] = target;
				if (!this.nodeCounts[node.path]) {
						this.activeNodes.push(node);
						this.nodeCounts[node.path] = 1;
				} else {
						this.nodeCounts[node.path]++;
				}
				return target;
		}
		unresolve(path) {
				if (path.component !== 'graph') {
						return;
				}
				var node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];
				this.nodeCounts[node.path]--;
				if (this.nodeCounts[node.path] === 0) {
						var activeNodes = this.activeNodes;
						var i = activeNodes.indexOf(node.node);
						var len = activeNodes.length;
						if (i < len - 1) {
								activeNodes[i] = activeNodes[len - 1];
						}
						activeNodes.pop();
				}
		}
		update(deltaTime) {
				var activeNodes = this.activeNodes;
				for(var i = 0; i < activeNodes.length; ++i){
						activeNodes[i]._dirtifyLocal();
				}
		}
		assignMask(mask) {
				if (mask !== this._mask) {
						this._mask = mask;
						return true;
				}
				return false;
		}
		constructor(graph){
				this._isPathInMask = (path, checkMaskValue)=>{
						var maskItem = this._mask[path];
						if (!maskItem) return false;
						else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
						return false;
				};
				this.graph = graph;
				if (!graph) return;
				this._mask = null;
				var nodes = {};
				var flatten = function flatten1(node) {
						nodes[node.name] = node;
						for(var i = 0; i < node.children.length; ++i){
								flatten(node.children[i]);
						}
				};
				flatten(graph);
				this.nodes = nodes;
				this.targetCache = {};
				var findMeshInstances = function findMeshInstances(node) {
						var object = node;
						while(object && !(object instanceof Entity)){
								object = object.parent;
						}
						var meshInstances;
						if (object) {
								if (object.render) {
										meshInstances = object.render.meshInstances;
								} else if (object.model) {
										meshInstances = object.model.meshInstances;
								}
						}
						return meshInstances;
				};
				this.nodeCounts = {};
				this.activeNodes = [];
				this.handlers = {
						'localPosition': function(node) {
								var object = node.localPosition;
								var func = function func(value) {
										object.set(...value);
								};
								return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
						},
						'localRotation': function(node) {
								var object = node.localRotation;
								var func = function func(value) {
										object.set(...value);
								};
								return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
						},
						'localScale': function(node) {
								var object = node.localScale;
								var func = function func(value) {
										object.set(...value);
								};
								return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
						},
						'weight': function(node, weightName) {
								if (weightName.indexOf('name.') === 0) {
										weightName = weightName.replace('name.', '');
								} else {
										weightName = Number(weightName);
								}
								var meshInstances = findMeshInstances(node);
								var setters;
								if (meshInstances) {
										var _loop = function(i) {
												if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
														var morphInstance = meshInstances[i].morphInstance;
														var func = (value)=>{
																morphInstance.setWeight(weightName, value[0]);
														};
														if (!setters) setters = [];
														setters.push(func);
												}
										};
										for(var i = 0; i < meshInstances.length; ++i)_loop(i);
								}
								if (setters) {
										var callSetters = (value)=>{
												for(var i = 0; i < setters.length; ++i){
														setters[i](value);
												}
										};
										return DefaultAnimBinder.createAnimTarget(callSetters, 'number', 1, node, "weight." + weightName);
								}
								return null;
						},
						'materialTexture': (node, textureName)=>{
								var meshInstances = findMeshInstances(node);
								if (meshInstances) {
										var meshInstance;
										for(var i = 0; i < meshInstances.length; ++i){
												if (meshInstances[i].node.name === node.name) {
														meshInstance = meshInstances[i];
														break;
												}
										}
										if (meshInstance) {
												var func = (value)=>{
														var textureAsset = this.animComponent.system.app.assets.get(value[0]);
														if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
																meshInstance.material[textureName] = textureAsset.resource;
																meshInstance.material.update();
														}
												};
												return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
										}
								}
								return null;
						}
				};
		}
}

class AnimationComponent extends Component {
		set animations(value) {
				this._animations = value;
				this.onSetAnimations();
		}
		get animations() {
				return this._animations;
		}
		set assets(value) {
				var assets = this._assets;
				if (assets && assets.length) {
						for(var i = 0; i < assets.length; i++){
								if (assets[i]) {
										var asset = this.system.app.assets.get(assets[i]);
										if (asset) {
												asset.off('change', this.onAssetChanged, this);
												asset.off('remove', this.onAssetRemoved, this);
												var animName = this.animationsIndex[asset.id];
												if (this.currAnim === animName) {
														this._stopCurrentAnimation();
												}
												delete this.animations[animName];
												delete this.animationsIndex[asset.id];
										}
								}
						}
				}
				this._assets = value;
				var assetIds = value.map((value)=>{
						return value instanceof Asset ? value.id : value;
				});
				this.loadAnimationAssets(assetIds);
		}
		get assets() {
				return this._assets;
		}
		set currentTime(currentTime) {
				if (this.skeleton) {
						this.skeleton.currentTime = currentTime;
						this.skeleton.addTime(0);
						this.skeleton.updateGraph();
				}
				if (this.animEvaluator) {
						var clips = this.animEvaluator.clips;
						for(var i = 0; i < clips.length; ++i){
								clips[i].time = currentTime;
						}
				}
		}
		get currentTime() {
				if (this.skeleton) {
						return this.skeleton._time;
				}
				if (this.animEvaluator) {
						var clips = this.animEvaluator.clips;
						if (clips.length > 0) {
								return clips[clips.length - 1].time;
						}
				}
				return 0;
		}
		get duration() {
				if (this.currAnim) {
						return this.animations[this.currAnim].duration;
				}
				return 0;
		}
		set loop(value) {
				this._loop = value;
				if (this.skeleton) {
						this.skeleton.looping = value;
				}
				if (this.animEvaluator) {
						for(var i = 0; i < this.animEvaluator.clips.length; ++i){
								this.animEvaluator.clips[i].loop = value;
						}
				}
		}
		get loop() {
				return this._loop;
		}
		play(name, blendTime) {
				if (blendTime === void 0) blendTime = 0;
				if (!this.enabled || !this.entity.enabled) {
						return;
				}
				if (!this.animations[name]) {
						return;
				}
				this.prevAnim = this.currAnim;
				this.currAnim = name;
				if (this.model) {
						if (!this.skeleton && !this.animEvaluator) {
								this._createAnimationController();
						}
						var prevAnim = this.animations[this.prevAnim];
						var currAnim = this.animations[this.currAnim];
						this.blending = blendTime > 0 && !!this.prevAnim;
						if (this.blending) {
								this.blend = 0;
								this.blendSpeed = 1 / blendTime;
						}
						if (this.skeleton) {
								if (this.blending) {
										this.fromSkel.animation = prevAnim;
										this.fromSkel.addTime(this.skeleton._time);
										this.toSkel.animation = currAnim;
								} else {
										this.skeleton.animation = currAnim;
								}
						}
						if (this.animEvaluator) {
								var animEvaluator = this.animEvaluator;
								if (this.blending) {
										while(animEvaluator.clips.length > 1){
												animEvaluator.removeClip(0);
										}
								} else {
										this.animEvaluator.removeClips();
								}
								var clip = new AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);
								clip.name = this.currAnim;
								clip.blendWeight = this.blending ? 0 : 1;
								clip.reset();
								this.animEvaluator.addClip(clip);
						}
				}
				this.playing = true;
		}
		getAnimation(name) {
				return this.animations[name];
		}
		setModel(model) {
				if (model !== this.model) {
						this._resetAnimationController();
						this.model = model;
						if (this.animations && this.currAnim && this.animations[this.currAnim]) {
								this.play(this.currAnim);
						}
				}
		}
		onSetAnimations() {
				var modelComponent = this.entity.model;
				if (modelComponent) {
						var m = modelComponent.model;
						if (m && m !== this.model) {
								this.setModel(m);
						}
				}
				if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
						var animationNames = Object.keys(this._animations);
						if (animationNames.length > 0) {
								this.play(animationNames[0]);
						}
				}
		}
		_resetAnimationController() {
				this.skeleton = null;
				this.fromSkel = null;
				this.toSkel = null;
				this.animEvaluator = null;
		}
		_createAnimationController() {
				var model = this.model;
				var animations = this.animations;
				var hasJson = false;
				var hasGlb = false;
				for(var animation in animations){
						if (animations.hasOwnProperty(animation)) {
								var anim = animations[animation];
								if (anim.constructor === AnimTrack) {
										hasGlb = true;
								} else {
										hasJson = true;
								}
						}
				}
				var graph = model.getGraph();
				if (hasJson) {
						this.fromSkel = new Skeleton(graph);
						this.toSkel = new Skeleton(graph);
						this.skeleton = new Skeleton(graph);
						this.skeleton.looping = this.loop;
						this.skeleton.setGraph(graph);
				} else if (hasGlb) {
						this.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
				}
		}
		loadAnimationAssets(ids) {
				if (!ids || !ids.length) {
						return;
				}
				var assets = this.system.app.assets;
				var onAssetReady = (asset)=>{
						if (asset.resources.length > 1) {
								for(var i = 0; i < asset.resources.length; i++){
										this.animations[asset.resources[i].name] = asset.resources[i];
										this.animationsIndex[asset.id] = asset.resources[i].name;
								}
						} else {
								this.animations[asset.name] = asset.resource;
								this.animationsIndex[asset.id] = asset.name;
						}
						this.animations = this.animations;
				};
				var onAssetAdd = (asset)=>{
						asset.off('change', this.onAssetChanged, this);
						asset.on('change', this.onAssetChanged, this);
						asset.off('remove', this.onAssetRemoved, this);
						asset.on('remove', this.onAssetRemoved, this);
						if (asset.resource) {
								onAssetReady(asset);
						} else {
								asset.once('load', onAssetReady, this);
								if (this.enabled && this.entity.enabled) {
										assets.load(asset);
								}
						}
				};
				for(var i = 0, l = ids.length; i < l; i++){
						var asset = assets.get(ids[i]);
						if (asset) {
								onAssetAdd(asset);
						} else {
								assets.on("add:" + ids[i], onAssetAdd);
						}
				}
		}
		onAssetChanged(asset, attribute, newValue, oldValue) {
				if (attribute === 'resource' || attribute === 'resources') {
						if (attribute === 'resources' && newValue && newValue.length === 0) {
								newValue = null;
						}
						if (newValue) {
								var restarted = false;
								if (newValue.length > 1) {
										if (oldValue && oldValue.length > 1) {
												for(var i = 0; i < oldValue.length; i++){
														delete this.animations[oldValue[i].name];
												}
										} else {
												delete this.animations[asset.name];
										}
										restarted = false;
										for(var i1 = 0; i1 < newValue.length; i1++){
												this.animations[newValue[i1].name] = newValue[i1];
												if (!restarted && this.currAnim === newValue[i1].name) {
														if (this.playing && this.enabled && this.entity.enabled) {
																restarted = true;
																this.play(newValue[i1].name);
														}
												}
										}
										if (!restarted) {
												this._stopCurrentAnimation();
												this.onSetAnimations();
										}
								} else {
										if (oldValue && oldValue.length > 1) {
												for(var i2 = 0; i2 < oldValue.length; i2++){
														delete this.animations[oldValue[i2].name];
												}
										}
										this.animations[asset.name] = newValue[0] || newValue;
										restarted = false;
										if (this.currAnim === asset.name) {
												if (this.playing && this.enabled && this.entity.enabled) {
														restarted = true;
														this.play(asset.name);
												}
										}
										if (!restarted) {
												this._stopCurrentAnimation();
												this.onSetAnimations();
										}
								}
								this.animationsIndex[asset.id] = asset.name;
						} else {
								if (oldValue.length > 1) {
										for(var i3 = 0; i3 < oldValue.length; i3++){
												delete this.animations[oldValue[i3].name];
												if (this.currAnim === oldValue[i3].name) {
														this._stopCurrentAnimation();
												}
										}
								} else {
										delete this.animations[asset.name];
										if (this.currAnim === asset.name) {
												this._stopCurrentAnimation();
										}
								}
								delete this.animationsIndex[asset.id];
						}
				}
		}
		onAssetRemoved(asset) {
				asset.off('remove', this.onAssetRemoved, this);
				if (this.animations) {
						if (asset.resources.length > 1) {
								for(var i = 0; i < asset.resources.length; i++){
										delete this.animations[asset.resources[i].name];
										if (this.currAnim === asset.resources[i].name) {
												this._stopCurrentAnimation();
										}
								}
						} else {
								delete this.animations[asset.name];
								if (this.currAnim === asset.name) {
										this._stopCurrentAnimation();
								}
						}
						delete this.animationsIndex[asset.id];
				}
		}
		_stopCurrentAnimation() {
				this.currAnim = null;
				this.playing = false;
				if (this.skeleton) {
						this.skeleton.currentTime = 0;
						this.skeleton.animation = null;
				}
				if (this.animEvaluator) {
						for(var i = 0; i < this.animEvaluator.clips.length; ++i){
								this.animEvaluator.clips[i].stop();
						}
						this.animEvaluator.update(0);
						this.animEvaluator.removeClips();
				}
		}
		onEnable() {
				super.onEnable();
				var assets = this.assets;
				var registry = this.system.app.assets;
				if (assets) {
						for(var i = 0, len = assets.length; i < len; i++){
								var asset = assets[i];
								if (!(asset instanceof Asset)) {
										asset = registry.get(asset);
								}
								if (asset && !asset.resource) {
										registry.load(asset);
								}
						}
				}
				if (this.activate && !this.currAnim) {
						var animationNames = Object.keys(this.animations);
						if (animationNames.length > 0) {
								this.play(animationNames[0]);
						}
				}
		}
		onBeforeRemove() {
				for(var i = 0; i < this.assets.length; i++){
						var asset = this.assets[i];
						if (typeof asset === 'number') {
								asset = this.system.app.assets.get(asset);
						}
						if (!asset) continue;
						asset.off('change', this.onAssetChanged, this);
						asset.off('remove', this.onAssetRemoved, this);
				}
				this.skeleton = null;
				this.fromSkel = null;
				this.toSkel = null;
				this.animEvaluator = null;
		}
		update(dt) {
				if (this.blending) {
						this.blend += dt * this.blendSpeed;
						if (this.blend >= 1) {
								this.blend = 1;
						}
				}
				if (this.playing) {
						var skeleton = this.skeleton;
						if (skeleton !== null && this.model !== null) {
								if (this.blending) {
										skeleton.blend(this.fromSkel, this.toSkel, this.blend);
								} else {
										var delta = dt * this.speed;
										skeleton.addTime(delta);
										if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {
												this.playing = false;
										} else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {
												this.playing = false;
										}
								}
								if (this.blending && this.blend === 1) {
										skeleton.animation = this.toSkel.animation;
								}
								skeleton.updateGraph();
						}
				}
				var animEvaluator = this.animEvaluator;
				if (animEvaluator) {
						for(var i = 0; i < animEvaluator.clips.length; ++i){
								var clip = animEvaluator.clips[i];
								clip.speed = this.speed;
								if (!this.playing) {
										clip.pause();
								} else {
										clip.resume();
								}
						}
						if (this.blending && animEvaluator.clips.length > 1) {
								animEvaluator.clips[1].blendWeight = this.blend;
						}
						animEvaluator.update(dt);
				}
				if (this.blending && this.blend === 1) {
						this.blending = false;
				}
		}
		constructor(...args){
				super(...args), this._animations = {}, this._assets = [], this._loop = true, this.animEvaluator = null, this.model = null, this.skeleton = null, this.fromSkel = null, this.toSkel = null, this.animationsIndex = {}, this.prevAnim = null, this.currAnim = null, this.blend = 0, this.blending = false, this.blendSpeed = 0, this.activate = true, this.speed = 1;
		}
}

class AnimationComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$k = [
		'enabled'
];
class AnimationComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				properties = [
						'activate',
						'enabled',
						'loop',
						'speed',
						'assets'
				];
				for (var property of properties){
						if (data.hasOwnProperty(property)) {
								component[property] = data[property];
						}
				}
				super.initializeComponentData(component, data, _schema$k);
		}
		cloneComponent(entity, clone) {
				this.addComponent(clone, {});
				clone.animation.assets = entity.animation.assets.slice();
				clone.animation.speed = entity.animation.speed;
				clone.animation.loop = entity.animation.loop;
				clone.animation.activate = entity.animation.activate;
				clone.animation.enabled = entity.animation.enabled;
				var clonedAnimations = {};
				var animations = entity.animation.animations;
				for(var key in animations){
						if (animations.hasOwnProperty(key)) {
								clonedAnimations[key] = animations[key];
						}
				}
				clone.animation.animations = clonedAnimations;
				var clonedAnimationsIndex = {};
				var animationsIndex = entity.animation.animationsIndex;
				for(var key1 in animationsIndex){
						if (animationsIndex.hasOwnProperty(key1)) {
								clonedAnimationsIndex[key1] = animationsIndex[key1];
						}
				}
				clone.animation.animationsIndex = clonedAnimationsIndex;
				return clone.animation;
		}
		onBeforeRemove(entity, component) {
				component.onBeforeRemove();
		}
		onUpdate(dt) {
				var components = this.store;
				for(var id in components){
						if (components.hasOwnProperty(id)) {
								var component = components[id];
								if (component.data.enabled && component.entity.enabled) {
										component.entity.animation.update(dt);
								}
						}
				}
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'animation';
				this.ComponentType = AnimationComponent;
				this.DataType = AnimationComponentData;
				this.schema = _schema$k;
				this.on('beforeremove', this.onBeforeRemove, this);
				this.app.systems.on('update', this.onUpdate, this);
		}
}
Component._buildAccessors(AnimationComponent.prototype, _schema$k);

class AnimNode {
		get parent() {
				return this._parent;
		}
		get name() {
				return this._name;
		}
		get path() {
				return this._parent ? this._parent.path + "." + this._name : this._name;
		}
		get point() {
				return this._point;
		}
		get pointLength() {
				return this._pointLength;
		}
		set weight(value) {
				this._weight = value;
		}
		get weight() {
				return this._parent ? this._parent.weight * this._weight : this._weight;
		}
		get normalizedWeight() {
				var totalWeight = this._state.totalWeight;
				if (totalWeight === 0.0) return 0.0;
				return this.weight / totalWeight;
		}
		get speed() {
				return this._weightedSpeed * this._speed;
		}
		get absoluteSpeed() {
				return Math.abs(this._speed);
		}
		set weightedSpeed(weightedSpeed) {
				this._weightedSpeed = weightedSpeed;
		}
		get weightedSpeed() {
				return this._weightedSpeed;
		}
		set animTrack(value) {
				this._animTrack = value;
		}
		get animTrack() {
				return this._animTrack;
		}
		constructor(state, parent, name, point, speed = 1){
				this._state = state;
				this._parent = parent;
				this._name = name;
				if (Array.isArray(point)) {
						this._point = new Vec2(point[0], point[1]);
						this._pointLength = this._point.length();
				} else {
						this._point = point;
						this._pointLength = point;
				}
				this._speed = speed;
				this._weightedSpeed = 1.0;
				this._weight = 1.0;
				this._animTrack = null;
		}
}

class AnimBlendTree extends AnimNode {
		get weight() {
				this.calculateWeights();
				return this._parent ? this._parent.weight * this._weight : this._weight;
		}
		get syncAnimations() {
				return this._syncAnimations;
		}
		getChild(name) {
				for(var i = 0; i < this._children.length; i++){
						if (this._children[i].name === name) return this._children[i];
				}
				return null;
		}
		updateParameterValues() {
				var paramsEqual = true;
				for(var i = 0; i < this._parameterValues.length; i++){
						var updatedParameter = this._findParameter(this._parameters[i]).value;
						if (this._parameterValues[i] !== updatedParameter) {
								this._parameterValues[i] = updatedParameter;
								paramsEqual = false;
						}
				}
				return paramsEqual;
		}
		getNodeWeightedDuration(i) {
				return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
		}
		getNodeCount() {
				var count = 0;
				for(var i = 0; i < this._children.length; i++){
						var child = this._children[i];
						if (child.constructor === AnimBlendTree) {
								count += this._children[i].getNodeCount();
						} else {
								count++;
						}
				}
				return count;
		}
		constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter){
				super(state, parent, name, point);
				this._parameters = parameters;
				this._parameterValues = new Array(parameters.length);
				this._children = [];
				this._findParameter = findParameter;
				this._syncAnimations = syncAnimations !== false;
				this._pointCache = {};
				for(var i = 0; i < children.length; i++){
						var child = children[i];
						if (child.children) {
								this._children.push(createTree(child.type, state, this, child.name, 1.0, child.parameter ? [
										child.parameter
								] : child.parameters, child.children, child.syncAnimations, createTree, findParameter));
						} else {
								this._children.push(new AnimNode(state, this, child.name, child.point, child.speed));
						}
				}
		}
}

class AnimBlendTree1D extends AnimBlendTree {
		calculateWeights() {
				if (this.updateParameterValues()) return;
				var weightedDurationSum = 0.0;
				this._children[0].weight = 0.0;
				for(var i = 0; i < this._children.length; i++){
						var c1 = this._children[i];
						if (i !== this._children.length - 1) {
								var c2 = this._children[i + 1];
								if (c1.point === c2.point) {
										c1.weight = 0.5;
										c2.weight = 0.5;
								} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
										var child2Distance = Math.abs(c1.point - c2.point);
										var parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
										var weight = (child2Distance - parameterDistance) / child2Distance;
										c1.weight = weight;
										c2.weight = 1.0 - weight;
								} else {
										c2.weight = 0.0;
								}
						}
						if (this._syncAnimations) {
								weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
						}
				}
				if (this._syncAnimations) {
						for(var i1 = 0; i1 < this._children.length; i1++){
								var child = this._children[i1];
								child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
						}
				}
		}
		constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter){
				children.sort((a, b)=>a.point - b.point);
				super(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
		}
}

class AnimBlendTreeCartesian2D extends AnimBlendTree {
		pointDistanceCache(i, j) {
				var pointKey = "" + i + j;
				if (!this._pointCache[pointKey]) {
						this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
				}
				return this._pointCache[pointKey];
		}
		calculateWeights() {
				if (this.updateParameterValues()) return;
				var weightSum, weightedDurationSum;
				AnimBlendTreeCartesian2D._p.set(...this._parameterValues);
				weightSum = 0.0;
				weightedDurationSum = 0.0;
				for(var i = 0; i < this._children.length; i++){
						var child = this._children[i];
						var pi = child.point;
						AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);
						var minj = Number.MAX_VALUE;
						for(var j = 0; j < this._children.length; j++){
								if (i === j) continue;
								var pipj = this.pointDistanceCache(i, j);
								var result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
								if (result < minj) minj = result;
						}
						child.weight = minj;
						weightSum += minj;
						if (this._syncAnimations) {
								weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
						}
				}
				for(var i1 = 0; i1 < this._children.length; i1++){
						var child1 = this._children[i1];
						child1.weight = child1._weight / weightSum;
						if (this._syncAnimations) {
								child1.weightedSpeed = child1.animTrack.duration / child1.absoluteSpeed / weightedDurationSum;
						}
				}
		}
}
AnimBlendTreeCartesian2D._p = new Vec2();
AnimBlendTreeCartesian2D._pip = new Vec2();

class AnimBlendTreeDirectional2D extends AnimBlendTree {
		pointCache(i, j) {
				var pointKey = "" + i + j;
				if (!this._pointCache[pointKey]) {
						this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
				}
				return this._pointCache[pointKey];
		}
		calculateWeights() {
				if (this.updateParameterValues()) return;
				var weightSum, weightedDurationSum;
				AnimBlendTreeDirectional2D._p.set(...this._parameterValues);
				var pLength = AnimBlendTreeDirectional2D._p.length();
				weightSum = 0.0;
				weightedDurationSum = 0.0;
				for(var i = 0; i < this._children.length; i++){
						var child = this._children[i];
						var pi = child.point;
						var piLength = child.pointLength;
						var minj = Number.MAX_VALUE;
						for(var j = 0; j < this._children.length; j++){
								if (i === j) continue;
								var pipj = this.pointCache(i, j);
								var pjLength = this._children[j].pointLength;
								AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);
								var result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
								if (result < minj) minj = result;
						}
						child.weight = minj;
						weightSum += minj;
						if (this._syncAnimations) {
								weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
						}
				}
				for(var i1 = 0; i1 < this._children.length; i1++){
						var child1 = this._children[i1];
						child1.weight = child1._weight / weightSum;
						if (this._syncAnimations) {
								var weightedChildDuration = child1.animTrack.duration / weightedDurationSum * weightSum;
								child1.weightedSpeed = child1.absoluteSpeed * weightedChildDuration;
						}
				}
		}
}
AnimBlendTreeDirectional2D._p = new Vec2();
AnimBlendTreeDirectional2D._pip = new Vec2();

class AnimBlendTreeDirect extends AnimBlendTree {
		calculateWeights() {
				if (this.updateParameterValues()) return;
				var weightSum = 0.0;
				var weightedDurationSum = 0.0;
				for(var i = 0; i < this._children.length; i++){
						weightSum += Math.max(this._parameterValues[i], 0.0);
						if (this._syncAnimations) {
								var child = this._children[i];
								weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
						}
				}
				for(var i1 = 0; i1 < this._children.length; i1++){
						var child1 = this._children[i1];
						var weight = Math.max(this._parameterValues[i1], 0.0);
						if (weightSum) {
								child1.weight = weight / weightSum;
								if (this._syncAnimations) {
										child1.weightedSpeed = child1.animTrack.duration / child1.absoluteSpeed / weightedDurationSum;
								}
						} else {
								child1.weight = 0.0;
								if (this._syncAnimations) {
										child1.weightedSpeed = 0;
								}
						}
				}
		}
}

class AnimState {
		_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
				switch(type){
						case ANIM_BLEND_1D:
								return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
						case ANIM_BLEND_2D_CARTESIAN:
								return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
						case ANIM_BLEND_2D_DIRECTIONAL:
								return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
						case ANIM_BLEND_DIRECT:
								return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				}
				return undefined;
		}
		_getNodeFromPath(path) {
				var currNode = this._blendTree;
				for(var i = 1; i < path.length; i++){
						currNode = currNode.getChild(path[i]);
				}
				return currNode;
		}
		addAnimation(path, animTrack) {
				var pathString = path.join('.');
				var indexOfAnimation = this._animationList.findIndex((animation)=>{
						return animation.path === pathString;
				});
				if (indexOfAnimation >= 0) {
						this._animationList[indexOfAnimation].animTrack = animTrack;
				} else {
						var node = this._getNodeFromPath(path);
						node.animTrack = animTrack;
						this._animationList.push(node);
				}
				this._updateHasAnimations();
		}
		_updateHasAnimations() {
				this._hasAnimations = this._animationList.length > 0 && this._animationList.every((animation)=>animation.animTrack && animation.animTrack !== AnimTrack.EMPTY);
		}
		get name() {
				return this._name;
		}
		set animations(value) {
				this._animationList = value;
				this._updateHasAnimations();
		}
		get animations() {
				return this._animationList;
		}
		get hasAnimations() {
				return this._hasAnimations;
		}
		set speed(value) {
				this._speed = value;
		}
		get speed() {
				return this._speed;
		}
		set loop(value) {
				this._loop = value;
		}
		get loop() {
				return this._loop;
		}
		get nodeCount() {
				if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
				return this._blendTree.getNodeCount();
		}
		get playable() {
				return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
		}
		get looping() {
				if (this.animations.length > 0) {
						var trackClipName = this.name + "." + this.animations[0].animTrack.name;
						var trackClip = this._controller.animEvaluator.findClip(trackClipName);
						if (trackClip) {
								return trackClip.loop;
						}
				}
				return false;
		}
		get totalWeight() {
				var sum = 0;
				for(var i = 0; i < this.animations.length; i++){
						sum += this.animations[i].weight;
				}
				return sum;
		}
		get timelineDuration() {
				var duration = 0;
				for(var i = 0; i < this.animations.length; i++){
						var animation = this.animations[i];
						if (animation.animTrack.duration > duration) {
								duration = animation.animTrack.duration;
						}
				}
				return duration;
		}
		constructor(controller, name, speed = 1, loop = true, blendTree){
				this._animations = {};
				this._animationList = [];
				this._controller = controller;
				this._name = name;
				this._speed = speed;
				this._loop = loop;
				this._hasAnimations = false;
				if (blendTree) {
						this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [
								blendTree.parameter
						] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, this._controller.findParameter);
				} else {
						this._blendTree = new AnimNode(this, null, name, 1.0, speed);
				}
		}
}

class AnimTransition {
		get from() {
				return this._from;
		}
		set to(value) {
				this._to = value;
		}
		get to() {
				return this._to;
		}
		get time() {
				return this._time;
		}
		get priority() {
				return this._priority;
		}
		get conditions() {
				return this._conditions;
		}
		get exitTime() {
				return this._exitTime;
		}
		get transitionOffset() {
				return this._transitionOffset;
		}
		get interruptionSource() {
				return this._interruptionSource;
		}
		get hasExitTime() {
				return !!this.exitTime;
		}
		constructor({ from, to, time = 0, priority = 0, conditions = [], exitTime = null, transitionOffset = null, interruptionSource = ANIM_INTERRUPTION_NONE }){
				this._from = from;
				this._to = to;
				this._time = time;
				this._priority = priority;
				this._conditions = conditions;
				this._exitTime = exitTime;
				this._transitionOffset = transitionOffset;
				this._interruptionSource = interruptionSource;
		}
}

function _extends$a() {
		_extends$a = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$a.apply(this, arguments);
}
class AnimController {
		get animEvaluator() {
				return this._animEvaluator;
		}
		set activeState(stateName) {
				this._activeStateName = stateName;
		}
		get activeState() {
				return this._findState(this._activeStateName);
		}
		get activeStateName() {
				return this._activeStateName;
		}
		get activeStateAnimations() {
				return this.activeState.animations;
		}
		set previousState(stateName) {
				this._previousStateName = stateName;
		}
		get previousState() {
				return this._findState(this._previousStateName);
		}
		get previousStateName() {
				return this._previousStateName;
		}
		get playable() {
				var playable = true;
				for(var i = 0; i < this._stateNames.length; i++){
						if (!this._states[this._stateNames[i]].playable) {
								playable = false;
						}
				}
				return playable;
		}
		set playing(value) {
				this._playing = value;
		}
		get playing() {
				return this._playing;
		}
		get activeStateProgress() {
				return this._getActiveStateProgressForTime(this._timeInState);
		}
		get activeStateDuration() {
				if (this._activeStateDurationDirty) {
						var maxDuration = 0.0;
						for(var i = 0; i < this.activeStateAnimations.length; i++){
								var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);
								if (activeClip) {
										maxDuration = Math.max(maxDuration, activeClip.track.duration);
								}
						}
						this._activeStateDuration = maxDuration;
						this._activeStateDurationDirty = false;
				}
				return this._activeStateDuration;
		}
		set activeStateCurrentTime(time) {
				this._timeInStateBefore = time;
				this._timeInState = time;
				for(var i = 0; i < this.activeStateAnimations.length; i++){
						var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);
						if (clip) {
								clip.time = time;
						}
				}
		}
		get activeStateCurrentTime() {
				return this._timeInState;
		}
		get transitioning() {
				return this._isTransitioning;
		}
		get transitionProgress() {
				return this._currTransitionTime / this._totalTransitionTime;
		}
		get states() {
				return this._stateNames;
		}
		assignMask(mask) {
				return this._animEvaluator.assignMask(mask);
		}
		_findState(stateName) {
				return this._states[stateName];
		}
		_getActiveStateProgressForTime(time) {
				if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) {
						return 1.0;
				}
				var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
				if (activeClip) {
						return activeClip.progressForTime(time);
				}
				return null;
		}
		_findTransitionsFromState(stateName) {
				var transitions = this._findTransitionsFromStateCache[stateName];
				if (!transitions) {
						transitions = this._transitions.filter((transition)=>{
								return transition.from === stateName;
						});
						sortPriority(transitions);
						this._findTransitionsFromStateCache[stateName] = transitions;
				}
				return transitions;
		}
		_findTransitionsBetweenStates(sourceStateName, destinationStateName) {
				var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + "->" + destinationStateName];
				if (!transitions) {
						transitions = this._transitions.filter((transition)=>{
								return transition.from === sourceStateName && transition.to === destinationStateName;
						});
						sortPriority(transitions);
						this._findTransitionsBetweenStatesCache[sourceStateName + "->" + destinationStateName] = transitions;
				}
				return transitions;
		}
		_transitionHasConditionsMet(transition) {
				var conditions = transition.conditions;
				for(var i = 0; i < conditions.length; i++){
						var condition = conditions[i];
						var parameter = this._findParameter(condition.parameterName);
						switch(condition.predicate){
								case ANIM_GREATER_THAN:
										if (!(parameter.value > condition.value)) return false;
										break;
								case ANIM_LESS_THAN:
										if (!(parameter.value < condition.value)) return false;
										break;
								case ANIM_GREATER_THAN_EQUAL_TO:
										if (!(parameter.value >= condition.value)) return false;
										break;
								case ANIM_LESS_THAN_EQUAL_TO:
										if (!(parameter.value <= condition.value)) return false;
										break;
								case ANIM_EQUAL_TO:
										if (!(parameter.value === condition.value)) return false;
										break;
								case ANIM_NOT_EQUAL_TO:
										if (!(parameter.value !== condition.value)) return false;
										break;
						}
				}
				return true;
		}
		_findTransition(from, to) {
				var transitions = [];
				if (from && to) {
						transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
				} else {
						if (!this._isTransitioning) {
								transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
								transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						} else {
								switch(this._transitionInterruptionSource){
										case ANIM_INTERRUPTION_PREV:
												transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
												break;
										case ANIM_INTERRUPTION_NEXT:
												transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
												break;
										case ANIM_INTERRUPTION_PREV_NEXT:
												transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
												transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
												break;
										case ANIM_INTERRUPTION_NEXT_PREV:
												transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
												transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
												break;
								}
						}
				}
				transitions = transitions.filter((transition)=>{
						if (transition.to === this.activeStateName) {
								return false;
						}
						if (transition.hasExitTime) {
								var progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);
								var progress = this._getActiveStateProgressForTime(this._timeInState);
								if (transition.exitTime < 1.0 && this.activeState.loop) {
										progressBefore -= Math.floor(progressBefore);
										progress -= Math.floor(progress);
								}
								if (progress === progressBefore) {
										if (progress !== transition.exitTime) {
												return null;
										}
								} else if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
										return null;
								}
						}
						return this._transitionHasConditionsMet(transition);
				});
				if (transitions.length > 0) {
						var transition = transitions[0];
						if (transition.to === ANIM_STATE_END) {
								var startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];
								transition.to = startTransition.to;
						}
						return transition;
				}
				return null;
		}
		updateStateFromTransition(transition) {
				var state;
				var animation;
				var clip;
				this.previousState = transition.from ? this.activeStateName : null;
				this.activeState = transition.to;
				this._activeStateDurationDirty = true;
				for(var i = 0; i < transition.conditions.length; i++){
						var condition = transition.conditions[i];
						var parameter = this._findParameter(condition.parameterName);
						if (parameter.type === ANIM_PARAMETER_TRIGGER) {
								this._consumeTrigger(condition.parameterName);
						}
				}
				if (this.previousState) {
						if (!this._isTransitioning) {
								this._transitionPreviousStates = [];
						}
						this._transitionPreviousStates.push({
								name: this._previousStateName,
								weight: 1
						});
						var interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);
						for(var i1 = 0; i1 < this._transitionPreviousStates.length; i1++){
								if (!this._isTransitioning) {
										this._transitionPreviousStates[i1].weight = 1.0;
								} else if (i1 !== this._transitionPreviousStates.length - 1) {
										this._transitionPreviousStates[i1].weight *= 1.0 - interpolatedTime;
								} else {
										this._transitionPreviousStates[i1].weight = interpolatedTime;
								}
								state = this._findState(this._transitionPreviousStates[i1].name);
								for(var j = 0; j < state.animations.length; j++){
										animation = state.animations[j];
										clip = this._animEvaluator.findClip(animation.name + ".previous." + i1);
										if (!clip) {
												clip = this._animEvaluator.findClip(animation.name);
												clip.name = animation.name + ".previous." + i1;
										}
										if (i1 !== this._transitionPreviousStates.length - 1) {
												clip.pause();
										}
								}
						}
				}
				this._isTransitioning = true;
				this._totalTransitionTime = transition.time;
				this._currTransitionTime = 0;
				this._transitionInterruptionSource = transition.interruptionSource;
				var activeState = this.activeState;
				var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
				var timeInState = 0;
				var timeInStateBefore = 0;
				if (hasTransitionOffset) {
						var offsetTime = activeState.timelineDuration * transition.transitionOffset;
						timeInState = offsetTime;
						timeInStateBefore = offsetTime;
				}
				this._timeInState = timeInState;
				this._timeInStateBefore = timeInStateBefore;
				for(var i2 = 0; i2 < activeState.animations.length; i2++){
						clip = this._animEvaluator.findClip(activeState.animations[i2].name);
						if (!clip) {
								var speed = Number.isFinite(activeState.animations[i2].speed) ? activeState.animations[i2].speed : activeState.speed;
								clip = new AnimClip(activeState.animations[i2].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
								clip.name = activeState.animations[i2].name;
								this._animEvaluator.addClip(clip);
						} else {
								clip.reset();
						}
						if (transition.time > 0) {
								clip.blendWeight = 0.0;
						} else {
								clip.blendWeight = activeState.animations[i2].normalizedWeight;
						}
						clip.play();
						if (hasTransitionOffset) {
								clip.time = activeState.timelineDuration * transition.transitionOffset;
						} else {
								var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
								clip.time = startTime;
						}
				}
		}
		_transitionToState(newStateName) {
				if (!this._findState(newStateName)) {
						return;
				}
				var transition = this._findTransition(this._activeStateName, newStateName);
				if (!transition) {
						this._animEvaluator.removeClips();
						transition = new AnimTransition({
								from: null,
								to: newStateName
						});
				}
				this.updateStateFromTransition(transition);
		}
		assignAnimation(pathString, animTrack, speed, loop) {
				var path = pathString.split('.');
				var state = this._findState(path[0]);
				if (!state) {
						state = new AnimState(this, path[0], speed);
						this._states[path[0]] = state;
						this._stateNames.push(path[0]);
				}
				state.addAnimation(path, animTrack);
				this._animEvaluator.updateClipTrack(state.name, animTrack);
				if (speed !== undefined) {
						state.speed = speed;
				}
				if (loop !== undefined) {
						state.loop = loop;
				}
				if (!this._playing && this._activate && this.playable) {
						this.play();
				}
				this._activeStateDurationDirty = true;
		}
		removeNodeAnimations(nodeName) {
				if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
						return false;
				}
				var state = this._findState(nodeName);
				if (!state) {
						return false;
				}
				state.animations = [];
				return true;
		}
		play(stateName) {
				if (stateName) {
						this._transitionToState(stateName);
				}
				this._playing = true;
		}
		pause() {
				this._playing = false;
		}
		reset() {
				this._previousStateName = null;
				this._activeStateName = ANIM_STATE_START;
				this._playing = false;
				this._currTransitionTime = 1.0;
				this._totalTransitionTime = 1.0;
				this._isTransitioning = false;
				this._timeInState = 0;
				this._timeInStateBefore = 0;
				this._animEvaluator.removeClips();
		}
		rebind() {
				this._animEvaluator.rebind();
		}
		update(dt) {
				if (!this._playing) {
						return;
				}
				var state;
				var animation;
				var clip;
				if (this.activeState.loop || this._timeInState < this.activeStateDuration) {
						this._timeInStateBefore = this._timeInState;
						this._timeInState += dt * this.activeState.speed;
						if (!this.activeState.loop && this._timeInState > this.activeStateDuration) {
								this._timeInState = this.activeStateDuration;
								dt = this.activeStateDuration - this._timeInStateBefore;
						}
				}
				var transition = this._findTransition(this._activeStateName);
				if (transition) {
						this.updateStateFromTransition(transition);
				}
				if (this._isTransitioning) {
						this._currTransitionTime += dt;
						if (this._currTransitionTime <= this._totalTransitionTime) {
								var interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
								for(var i = 0; i < this._transitionPreviousStates.length; i++){
										state = this._findState(this._transitionPreviousStates[i].name);
										var stateWeight = this._transitionPreviousStates[i].weight;
										for(var j = 0; j < state.animations.length; j++){
												animation = state.animations[j];
												clip = this._animEvaluator.findClip(animation.name + ".previous." + i);
												if (clip) {
														clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
												}
										}
								}
								state = this.activeState;
								for(var i1 = 0; i1 < state.animations.length; i1++){
										animation = state.animations[i1];
										this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
								}
						} else {
								this._isTransitioning = false;
								var activeClips = this.activeStateAnimations.length;
								var totalClips = this._animEvaluator.clips.length;
								for(var i2 = 0; i2 < totalClips - activeClips; i2++){
										this._animEvaluator.removeClip(0);
								}
								this._transitionPreviousStates = [];
								state = this.activeState;
								for(var i3 = 0; i3 < state.animations.length; i3++){
										animation = state.animations[i3];
										clip = this._animEvaluator.findClip(animation.name);
										if (clip) {
												clip.blendWeight = animation.normalizedWeight;
										}
								}
						}
				} else {
						if (this.activeState._blendTree.constructor !== AnimNode) {
								state = this.activeState;
								for(var i4 = 0; i4 < state.animations.length; i4++){
										animation = state.animations[i4];
										clip = this._animEvaluator.findClip(animation.name);
										if (clip) {
												clip.blendWeight = animation.normalizedWeight;
												if (animation.parent.syncAnimations) {
														clip.speed = animation.speed;
												}
										}
								}
						}
				}
				this._animEvaluator.update(dt, this.activeState.hasAnimations);
		}
		constructor(animEvaluator, states, transitions, activate, eventHandler, findParameter, consumeTrigger){
				this._states = {};
				this._stateNames = [];
				this._findTransitionsFromStateCache = {};
				this._findTransitionsBetweenStatesCache = {};
				this._previousStateName = null;
				this._activeStateName = ANIM_STATE_START;
				this._activeStateDuration = 0;
				this._activeStateDurationDirty = true;
				this._playing = false;
				this._currTransitionTime = 1;
				this._totalTransitionTime = 1;
				this._isTransitioning = false;
				this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
				this._transitionPreviousStates = [];
				this._timeInState = 0;
				this._timeInStateBefore = 0;
				this.findParameter = (name)=>{
						return this._findParameter(name);
				};
				this._animEvaluator = animEvaluator;
				this._eventHandler = eventHandler;
				this._findParameter = findParameter;
				this._consumeTrigger = consumeTrigger;
				for(var i = 0; i < states.length; i++){
						this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);
						this._stateNames.push(states[i].name);
				}
				this._transitions = transitions.map((transition)=>{
						return new AnimTransition(_extends$a({}, transition));
				});
				this._activate = activate;
		}
}

var v2 = new Vec2();
var v3 = new Vec3();
var v4 = new Vec4();
var c = new Color();
var q = new Quat();
class AnimComponentBinder extends DefaultAnimBinder {
		static _packFloat(values) {
				return values[0];
		}
		static _packBoolean(values) {
				return !!values[0];
		}
		static _packVec2(values) {
				v2.x = values[0];
				v2.y = values[1];
				return v2;
		}
		static _packVec3(values) {
				v3.x = values[0];
				v3.y = values[1];
				v3.z = values[2];
				return v3;
		}
		static _packVec4(values) {
				v4.x = values[0];
				v4.y = values[1];
				v4.z = values[2];
				v4.w = values[3];
				return v4;
		}
		static _packColor(values) {
				c.r = values[0];
				c.g = values[1];
				c.b = values[2];
				c.a = values[3];
				return c;
		}
		static _packQuat(values) {
				q.x = values[0];
				q.y = values[1];
				q.z = values[2];
				q.w = values[3];
				return q;
		}
		resolve(path) {
				var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
				var target = this.targetCache[encodedPath];
				if (target) return target;
				var entity;
				var propertyComponent;
				var targetPath;
				switch(path.component){
						case 'entity':
								entity = this._getEntityFromHierarchy(path.entityPath);
								targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
								propertyComponent = entity;
								break;
						case 'graph':
								propertyComponent = this.findNode(path);
								if (!propertyComponent) return null;
								targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
								break;
						default:
								entity = this._getEntityFromHierarchy(path.entityPath);
								propertyComponent = entity.findComponent(path.component);
								if (!propertyComponent) {
										return null;
								}
								targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
								break;
				}
				target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
				this.targetCache[encodedPath] = target;
				return target;
		}
		update(deltaTime) {
				var activeNodes = this.activeNodes;
				if (activeNodes) {
						for(var i = 0; i < activeNodes.length; i++){
								activeNodes[i]._dirtifyLocal();
						}
				}
		}
		_getEntityFromHierarchy(entityHierarchy) {
				if (!this.animComponent.entity.name === entityHierarchy[0]) {
						return null;
				}
				var currEntity = this.animComponent.entity;
				if (entityHierarchy.length === 1) {
						return currEntity;
				}
				return currEntity._parent.findByPath(entityHierarchy);
		}
		_resolvePath(object, path, resolveLeaf) {
				var steps = path.length - (resolveLeaf ? 0 : 1);
				for(var i = 0; i < steps; i++){
						object = object[path[i]];
				}
				return object;
		}
		_setter(object, path, packFunc) {
				var obj = this._resolvePath(object, path);
				var key = path[path.length - 1];
				var setterFuncName = "set" + key.substring(0, 1).toUpperCase() + key.substring(1);
				if (obj[setterFuncName]) {
						var getterFunc = obj["get" + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);
						var baseValues = getterFunc();
						baseValues = [
								baseValues.x,
								baseValues.y,
								baseValues.z,
								baseValues.w
						];
						var setterFunc = obj[setterFuncName].bind(obj);
						return {
								set: (values)=>{
										setterFunc(packFunc(values));
								},
								get: ()=>baseValues
						};
				}
				var prop = obj[key];
				if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
						return function(values) {
								prop.copy(packFunc(values));
						};
				}
				if ([
						Vec2,
						Vec3,
						Vec4,
						Color,
						Quat
				].indexOf(obj.constructor) !== -1 && path.length > 1) {
						var parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
						var objKey = path[path.length - 2];
						return function(values) {
								obj[key] = packFunc(values);
								parent[objKey] = obj;
						};
				}
				return function(values) {
						obj[key] = packFunc(values);
				};
		}
		_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
				if (this.handlers && propertyHierarchy[0].startsWith('weight.')) {
						return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));
				} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
						var materialPropertyName = propertyHierarchy[1];
						if (materialPropertyName.endsWith('Map')) {
								return this.handlers.materialTexture(propertyComponent, materialPropertyName);
						}
				}
				var property = this._resolvePath(propertyComponent, propertyHierarchy, true);
				if (typeof property === 'undefined') {
						return null;
				}
				var setter;
				var animDataType;
				var animDataComponents;
				if (typeof property === 'number') {
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
						animDataType = 'vector';
						animDataComponents = 1;
				} else if (typeof property === 'boolean') {
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
						animDataType = 'vector';
						animDataComponents = 1;
				} else if (typeof property === 'object') {
						switch(property.constructor){
								case Vec2:
										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
										animDataType = 'vector';
										animDataComponents = 2;
										break;
								case Vec3:
										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
										animDataType = 'vector';
										animDataComponents = 3;
										break;
								case Vec4:
										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
										animDataType = 'vector';
										animDataComponents = 4;
										break;
								case Color:
										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
										animDataType = 'vector';
										animDataComponents = 4;
										break;
								case Quat:
										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
										animDataType = 'quaternion';
										animDataComponents = 4;
										break;
								default:
										return null;
						}
				}
				if (propertyHierarchy.indexOf('material') !== -1) {
						return new AnimTarget((values)=>{
								setter(values);
								propertyComponent.material.update();
						}, animDataType, animDataComponents, targetPath);
				}
				return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
		}
		rebind() {
				this.targetCache = {};
				if (this.animComponent.rootBone) {
						this.graph = this.animComponent.rootBone;
				} else {
						this.graph = this.animComponent.entity;
				}
				var nodes = {};
				var flatten = function flatten1(node) {
						nodes[node.name] = node;
						for(var i = 0; i < node.children.length; ++i){
								flatten(node.children[i]);
						}
				};
				flatten(this.graph);
				this.nodes = nodes;
		}
		constructor(animComponent, graph, layerName, mask, layerIndex){
				super(graph);
				this.animComponent = animComponent;
				this._mask = mask;
				this.layerName = layerName;
				this.layerIndex = layerIndex;
		}
}

class AnimComponentLayer {
		get name() {
				return this._name;
		}
		set playing(value) {
				this._controller.playing = value;
		}
		get playing() {
				return this._controller.playing;
		}
		get playable() {
				return this._controller.playable;
		}
		get activeState() {
				return this._controller.activeStateName;
		}
		get previousState() {
				return this._controller.previousStateName;
		}
		get activeStateProgress() {
				return this._controller.activeStateProgress;
		}
		get activeStateDuration() {
				return this._controller.activeStateDuration;
		}
		set activeStateCurrentTime(time) {
				var controller = this._controller;
				var layerPlaying = controller.playing;
				controller.playing = true;
				controller.activeStateCurrentTime = time;
				if (!layerPlaying) {
						controller.update(0);
				}
				controller.playing = layerPlaying;
		}
		get activeStateCurrentTime() {
				return this._controller.activeStateCurrentTime;
		}
		get transitioning() {
				return this._controller.transitioning;
		}
		get transitionProgress() {
				if (this.transitioning) {
						return this._controller.transitionProgress;
				}
				return null;
		}
		get states() {
				return this._controller.states;
		}
		set weight(value) {
				this._weight = value;
				this._component.dirtifyTargets();
		}
		get weight() {
				return this._weight;
		}
		set blendType(value) {
				if (value !== this._blendType) {
						this._blendType = value;
						if (this._controller.normalizeWeights) {
								this._component.rebind();
						}
				}
		}
		get blendType() {
				return this._blendType;
		}
		set mask(value) {
				if (this._controller.assignMask(value)) {
						this._component.rebind();
				}
				this._mask = value;
		}
		get mask() {
				return this._mask;
		}
		play(name) {
				this._controller.play(name);
		}
		pause() {
				this._controller.pause();
		}
		reset() {
				this._controller.reset();
		}
		rebind() {
				this._controller.rebind();
		}
		update(dt) {
				if (this._blendTime) {
						if (this._blendTimeElapsed < this._blendTime) {
								this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
								this._blendTimeElapsed += dt;
						} else {
								this.weight = this._targetWeight;
								this._blendTime = 0;
								this._blendTimeElapsed = 0;
								this._startingWeight = 0;
								this._targetWeight = 0;
						}
				}
				this._controller.update(dt);
		}
		blendToWeight(weight, time) {
				this._startingWeight = this.weight;
				this._targetWeight = weight;
				this._blendTime = Math.max(0, time);
				this._blendTimeElapsed = 0;
		}
		assignAnimation(nodePath, animTrack, speed, loop) {
				if (!(animTrack instanceof AnimTrack)) {
						return;
				}
				this._controller.assignAnimation(nodePath, animTrack, speed, loop);
				if (this._controller._transitions.length === 0) {
						this._controller._transitions.push(new AnimTransition({
								from: 'START',
								to: nodePath
						}));
				}
				if (this._component.activate && this._component.playable) {
						this._component.playing = true;
				}
		}
		removeNodeAnimations(nodeName) {
				if (this._controller.removeNodeAnimations(nodeName)) {
						this._component.playing = false;
				}
		}
		getAnimationAsset(stateName) {
				return this._component.animationAssets[this.name + ":" + stateName];
		}
		transition(to, time, transitionOffset) {
				if (time === void 0) time = 0;
				if (transitionOffset === void 0) transitionOffset = null;
				this._controller.updateStateFromTransition(new AnimTransition({
						from: this._controller.activeStateName,
						to,
						time,
						transitionOffset
				}));
		}
		constructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE){
				this._mask = null;
				this._blendTime = 0;
				this._blendTimeElapsed = 0;
				this._startingWeight = 0;
				this._targetWeight = 0;
				this._name = name;
				this._controller = controller;
				this._component = component;
				this._weight = weight;
				this._blendType = blendType;
		}
}

class AnimStateGraph {
		get parameters() {
				return Object.assign({}, this._parameters);
		}
		get layers() {
				return this._layers;
		}
		constructor(data){
				this._layers = [];
				this._parameters = {};
				if (!Array.isArray(data.layers)) {
						for(var layerId in data.layers){
								var dataLayer = data.layers[layerId];
								var layer = {
										name: dataLayer.name,
										blendType: dataLayer.blendType,
										weight: dataLayer.weight,
										states: [],
										transitions: []
								};
								for(var i = 0; i < dataLayer.states.length; i++){
										layer.states.push(data.states[dataLayer.states[i]]);
								}
								for(var i1 = 0; i1 < dataLayer.transitions.length; i1++){
										var dataLayerTransition = data.transitions[dataLayer.transitions[i1]];
										if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
												var conditionKeys = Object.keys(dataLayerTransition.conditions);
												var conditions = [];
												for(var j = 0; j < conditionKeys.length; j++){
														var condition = dataLayerTransition.conditions[conditionKeys[j]];
														if (condition.parameterName) {
																conditions.push(condition);
														}
												}
												dataLayerTransition.conditions = conditions;
										}
										if (Number.isInteger(dataLayerTransition.from)) {
												dataLayerTransition.from = data.states[dataLayerTransition.from].name;
										}
										if (Number.isInteger(dataLayerTransition.to)) {
												dataLayerTransition.to = data.states[dataLayerTransition.to].name;
										}
										layer.transitions.push(dataLayerTransition);
								}
								this._layers.push(layer);
						}
				} else {
						this._layers = data.layers;
				}
				for(var paramId in data.parameters){
						var param = data.parameters[paramId];
						this._parameters[param.name] = {
								type: param.type,
								value: param.value
						};
				}
		}
}

function _extends$9() {
		_extends$9 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$9.apply(this, arguments);
}
class AnimComponent extends Component {
		set stateGraphAsset(value) {
				if (value === null) {
						this.removeStateGraph();
						return;
				}
				if (this._stateGraphAsset) {
						var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
						stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
				}
				var _id;
				var _asset;
				if (value instanceof Asset) {
						_id = value.id;
						_asset = this.system.app.assets.get(_id);
						if (!_asset) {
								this.system.app.assets.add(value);
								_asset = this.system.app.assets.get(_id);
						}
				} else {
						_id = value;
						_asset = this.system.app.assets.get(_id);
				}
				if (!_asset || this._stateGraphAsset === _id) {
						return;
				}
				if (_asset.resource) {
						this._stateGraph = _asset.resource;
						this.loadStateGraph(this._stateGraph);
						_asset.on('change', this._onStateGraphAssetChangeEvent, this);
				} else {
						_asset.once('load', (asset)=>{
								this._stateGraph = asset.resource;
								this.loadStateGraph(this._stateGraph);
						});
						_asset.on('change', this._onStateGraphAssetChangeEvent, this);
						this.system.app.assets.load(_asset);
				}
				this._stateGraphAsset = _id;
		}
		get stateGraphAsset() {
				return this._stateGraphAsset;
		}
		set normalizeWeights(value) {
				this._normalizeWeights = value;
				this.unbind();
		}
		get normalizeWeights() {
				return this._normalizeWeights;
		}
		set animationAssets(value) {
				this._animationAssets = value;
				this.loadAnimationAssets();
		}
		get animationAssets() {
				return this._animationAssets;
		}
		set speed(value) {
				this._speed = value;
		}
		get speed() {
				return this._speed;
		}
		set activate(value) {
				this._activate = value;
		}
		get activate() {
				return this._activate;
		}
		set playing(value) {
				this._playing = value;
		}
		get playing() {
				return this._playing;
		}
		set rootBone(value) {
				if (typeof value === 'string') {
						var entity = this.entity.root.findByGuid(value);
						this._rootBone = entity;
				} else if (value instanceof Entity) {
						this._rootBone = value;
				} else {
						this._rootBone = null;
				}
				this.rebind();
		}
		get rootBone() {
				return this._rootBone;
		}
		set stateGraph(value) {
				this._stateGraph = value;
		}
		get stateGraph() {
				return this._stateGraph;
		}
		get layers() {
				return this._layers;
		}
		set layerIndices(value) {
				this._layerIndices = value;
		}
		get layerIndices() {
				return this._layerIndices;
		}
		set parameters(value) {
				this._parameters = value;
		}
		get parameters() {
				return this._parameters;
		}
		set targets(value) {
				this._targets = value;
		}
		get targets() {
				return this._targets;
		}
		get playable() {
				for(var i = 0; i < this._layers.length; i++){
						if (!this._layers[i].playable) {
								return false;
						}
				}
				return true;
		}
		get baseLayer() {
				if (this._layers.length > 0) {
						return this._layers[0];
				}
				return null;
		}
		_onStateGraphAssetChangeEvent(asset) {
				var prevAnimationAssets = this.animationAssets;
				var prevMasks = this.layers.map((layer)=>layer.mask);
				this.removeStateGraph();
				this._stateGraph = new AnimStateGraph(asset._data);
				this.loadStateGraph(this._stateGraph);
				this.animationAssets = prevAnimationAssets;
				this.loadAnimationAssets();
				this.layers.forEach((layer, i)=>{
						layer.mask = prevMasks[i];
				});
				this.rebind();
		}
		dirtifyTargets() {
				var targets = Object.values(this._targets);
				for(var i = 0; i < targets.length; i++){
						targets[i].dirty = true;
				}
		}
		_addLayer(param) {
				var { name, states, transitions, weight, mask, blendType } = param;
				var graph;
				if (this.rootBone) {
						graph = this.rootBone;
				} else {
						graph = this.entity;
				}
				var layerIndex = this._layers.length;
				var animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
				var animEvaluator = new AnimEvaluator(animBinder);
				var controller = new AnimController(animEvaluator, states, transitions, this._activate, this, this.findParameter, this.consumeTrigger);
				this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));
				this._layerIndices[name] = layerIndex;
				return this._layers[layerIndex];
		}
		addLayer(name, weight, mask, blendType) {
				var layer = this.findAnimationLayer(name);
				if (layer) return layer;
				var states = [
						{
								'name': 'START',
								'speed': 1
						}
				];
				var transitions = [];
				return this._addLayer({
						name,
						states,
						transitions,
						weight,
						mask,
						blendType
				});
		}
		_assignParameters(stateGraph) {
				this._parameters = {};
				var paramKeys = Object.keys(stateGraph.parameters);
				for(var i = 0; i < paramKeys.length; i++){
						var paramKey = paramKeys[i];
						this._parameters[paramKey] = {
								type: stateGraph.parameters[paramKey].type,
								value: stateGraph.parameters[paramKey].value
						};
				}
		}
		loadStateGraph(stateGraph) {
				this._stateGraph = stateGraph;
				this._assignParameters(stateGraph);
				this._layers = [];
				var containsBlendTree = false;
				for(var i = 0; i < stateGraph.layers.length; i++){
						var layer = stateGraph.layers[i];
						this._addLayer(_extends$9({}, layer));
						if (layer.states.some((state)=>state.blendTree)) {
								containsBlendTree = true;
						}
				}
				if (!containsBlendTree) {
						this.setupAnimationAssets();
				}
		}
		setupAnimationAssets() {
				for(var i = 0; i < this._layers.length; i++){
						var layer = this._layers[i];
						var layerName = layer.name;
						for(var j = 0; j < layer.states.length; j++){
								var stateName = layer.states[j];
								if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
										var stateKey = layerName + ":" + stateName;
										if (!this._animationAssets[stateKey]) {
												this._animationAssets[stateKey] = {
														asset: null
												};
										}
								}
						}
				}
				this.loadAnimationAssets();
		}
		loadAnimationAssets() {
				for(var i = 0; i < this._layers.length; i++){
						var layer = this._layers[i];
						for(var j = 0; j < layer.states.length; j++){
								var stateName = layer.states[j];
								if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
								var animationAsset = this._animationAssets[layer.name + ":" + stateName];
								if (!animationAsset || !animationAsset.asset) {
										this.findAnimationLayer(layer.name).assignAnimation(stateName, AnimTrack.EMPTY);
										continue;
								}
								var assetId = animationAsset.asset;
								var asset = this.system.app.assets.get(assetId);
								if (asset) {
										if (asset.resource) {
												this.onAnimationAssetLoaded(layer.name, stateName, asset);
										} else {
												asset.once('load', (function(layerName, stateName) {
														return (function(asset) {
																this.onAnimationAssetLoaded(layerName, stateName, asset);
														}).bind(this);
												}).bind(this)(layer.name, stateName));
												this.system.app.assets.load(asset);
										}
								}
						}
				}
		}
		onAnimationAssetLoaded(layerName, stateName, asset) {
				this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
		}
		removeStateGraph() {
				this._stateGraph = null;
				this._stateGraphAsset = null;
				this._animationAssets = {};
				this._layers = [];
				this._layerIndices = {};
				this._parameters = {};
				this._playing = false;
				this.unbind();
				this._targets = {};
		}
		reset() {
				this._assignParameters(this._stateGraph);
				for(var i = 0; i < this._layers.length; i++){
						var layerPlaying = this._layers[i].playing;
						this._layers[i].reset();
						this._layers[i].playing = layerPlaying;
				}
		}
		unbind() {
				if (!this._normalizeWeights) {
						Object.keys(this._targets).forEach((targetKey)=>{
								this._targets[targetKey].unbind();
						});
				}
		}
		rebind() {
				this._targets = {};
				for(var i = 0; i < this._layers.length; i++){
						this._layers[i].rebind();
				}
		}
		findAnimationLayer(name) {
				var layerIndex = this._layerIndices[name];
				return this._layers[layerIndex] || null;
		}
		addAnimationState(nodeName, animTrack, speed, loop, layerName) {
				if (speed === void 0) speed = 1;
				if (loop === void 0) loop = true;
				if (layerName === void 0) layerName = 'Base';
				if (!this._stateGraph) {
						this.loadStateGraph(new AnimStateGraph({
								'layers': [
										{
												'name': layerName,
												'states': [
														{
																'name': 'START',
																'speed': 1
														},
														{
																'name': nodeName,
																'speed': speed,
																'loop': loop,
																'defaultState': true
														}
												],
												'transitions': [
														{
																'from': 'START',
																'to': nodeName
														}
												]
										}
								],
								'parameters': {}
						}));
				}
				var layer = this.findAnimationLayer(layerName);
				if (layer) {
						layer.assignAnimation(nodeName, animTrack, speed, loop);
				} else {
						var _this_addLayer;
						(_this_addLayer = this.addLayer(layerName)) == null ? void 0 : _this_addLayer.assignAnimation(nodeName, animTrack, speed, loop);
				}
		}
		assignAnimation(nodePath, animTrack, layerName, speed, loop) {
				if (speed === void 0) speed = 1;
				if (loop === void 0) loop = true;
				if (!this._stateGraph && nodePath.indexOf('.') === -1) {
						this.loadStateGraph(new AnimStateGraph({
								'layers': [
										{
												'name': 'Base',
												'states': [
														{
																'name': 'START',
																'speed': 1
														},
														{
																'name': nodePath,
																'speed': speed,
																'loop': loop,
																'defaultState': true
														}
												],
												'transitions': [
														{
																'from': 'START',
																'to': nodePath
														}
												]
										}
								],
								'parameters': {}
						}));
						this.baseLayer.assignAnimation(nodePath, animTrack);
						return;
				}
				var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
				if (!layer) {
						return;
				}
				layer.assignAnimation(nodePath, animTrack, speed, loop);
		}
		removeNodeAnimations(nodeName, layerName) {
				var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
				if (!layer) {
						return;
				}
				layer.removeNodeAnimations(nodeName);
		}
		getParameterValue(name, type) {
				var param = this._parameters[name];
				if (param && param.type === type) {
						return param.value;
				}
				return undefined;
		}
		setParameterValue(name, type, value) {
				var param = this._parameters[name];
				if (param && param.type === type) {
						param.value = value;
						return;
				}
		}
		getFloat(name) {
				return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
		}
		setFloat(name, value) {
				this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
		}
		getInteger(name) {
				return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
		}
		setInteger(name, value) {
				if (typeof value === 'number' && value % 1 === 0) {
						this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
				}
		}
		getBoolean(name) {
				return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
		}
		setBoolean(name, value) {
				this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
		}
		getTrigger(name) {
				return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
		}
		setTrigger(name, singleFrame) {
				if (singleFrame === void 0) singleFrame = false;
				this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
				if (singleFrame) {
						this._consumedTriggers.add(name);
				}
		}
		resetTrigger(name) {
				this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
		}
		onBeforeRemove() {
				if (Number.isFinite(this._stateGraphAsset)) {
						var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
						stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
				}
		}
		update(dt) {
				for(var i = 0; i < this.layers.length; i++){
						this.layers[i].update(dt * this.speed);
				}
				this._consumedTriggers.forEach((trigger)=>{
						this.parameters[trigger].value = false;
				});
				this._consumedTriggers.clear();
		}
		resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
				if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
						this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
				} else {
						this.rebind();
				}
		}
		constructor(...args){
				super(...args), this._stateGraphAsset = null, this._animationAssets = {}, this._speed = 1, this._activate = true, this._playing = false, this._rootBone = null, this._stateGraph = null, this._layers = [], this._layerIndices = {}, this._parameters = {}, this._targets = {}, this._consumedTriggers = new Set(), this._normalizeWeights = false, this.findParameter = (name)=>{
						return this._parameters[name];
				}, this.consumeTrigger = (name)=>{
						this._consumedTriggers.add(name);
				};
		}
}

class AnimComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$j = [
		'enabled'
];
class AnimComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				super.initializeComponentData(component, data, _schema$j);
				var complexProperties = [
						'animationAssets',
						'stateGraph',
						'layers',
						'masks'
				];
				Object.keys(data).forEach((key)=>{
						if (complexProperties.includes(key)) return;
						component[key] = data[key];
				});
				if (data.stateGraph) {
						component.stateGraph = data.stateGraph;
						component.loadStateGraph(component.stateGraph);
				}
				if (data.layers) {
						data.layers.forEach((layer, i)=>{
								layer._controller.states.forEach((stateKey)=>{
										layer._controller._states[stateKey]._animationList.forEach((node)=>{
												if (!node.animTrack || node.animTrack === AnimTrack.EMPTY) {
														var animationAsset = this.app.assets.get(layer._component._animationAssets[layer.name + ":" + node.name].asset);
														if (animationAsset && !animationAsset.loaded) {
																animationAsset.once('load', ()=>{
																		component.layers[i].assignAnimation(node.name, animationAsset.resource);
																});
														}
												} else {
														component.layers[i].assignAnimation(node.name, node.animTrack);
												}
										});
								});
						});
				}
				if (data.animationAssets) {
						component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
				}
				if (data.masks) {
						Object.keys(data.masks).forEach((key)=>{
								if (component.layers[key]) {
										var maskData = data.masks[key].mask;
										var mask = {};
										Object.keys(maskData).forEach((maskKey)=>{
												mask[decodeURI(maskKey)] = maskData[maskKey];
										});
										component.layers[key].mask = mask;
								}
						});
				}
		}
		onAnimationUpdate(dt) {
				var components = this.store;
				for(var id in components){
						if (components.hasOwnProperty(id)) {
								var component = components[id].entity.anim;
								var componentData = component.data;
								if (componentData.enabled && component.entity.enabled && component.playing) {
										component.update(dt);
								}
						}
				}
		}
		cloneComponent(entity, clone) {
				var masks;
				if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
						masks = {};
						entity.anim.layers.forEach((layer, i)=>{
								if (layer.mask) {
										var mask = {};
										Object.keys(layer.mask).forEach((path)=>{
												var pathArr = path.split('/');
												pathArr.shift();
												var clonePath = [
														clone.name,
														...pathArr
												].join('/');
												mask[clonePath] = layer.mask[path];
										});
										masks[i] = {
												mask
										};
								}
						});
				}
				var data = {
						enabled: entity.anim.enabled,
						stateGraphAsset: entity.anim.stateGraphAsset,
						animationAssets: entity.anim.animationAssets,
						speed: entity.anim.speed,
						activate: entity.anim.activate,
						playing: entity.anim.playing,
						rootBone: entity.anim.rootBone,
						stateGraph: entity.anim.stateGraph,
						layers: entity.anim.layers,
						layerIndices: entity.anim.layerIndices,
						parameters: entity.anim.parameters,
						normalizeWeights: entity.anim.normalizeWeights,
						masks
				};
				return this.addComponent(clone, data);
		}
		onBeforeRemove(entity, component) {
				component.onBeforeRemove();
		}
		destroy() {
				super.destroy();
				this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'anim';
				this.ComponentType = AnimComponent;
				this.DataType = AnimComponentData;
				this.schema = _schema$j;
				this.on('beforeremove', this.onBeforeRemove, this);
				this.app.systems.on('animationUpdate', this.onAnimationUpdate, this);
		}
}
Component._buildAccessors(AnimComponent.prototype, _schema$j);

class AudioListenerComponent extends Component {
		setCurrentListener() {
				if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
						this.system.current = this.entity;
						var position = this.system.current.getPosition();
						this.system.manager.listener.setPosition(position);
				}
		}
		onEnable() {
				this.setCurrentListener();
		}
		onDisable() {
				if (this.system.current === this.entity) {
						this.system.current = null;
				}
		}
}

class AudioListenerComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$i = [
		'enabled'
];
class AudioListenerComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				properties = [
						'enabled'
				];
				super.initializeComponentData(component, data, properties);
		}
		onUpdate(dt) {
				if (this.current) {
						var position = this.current.getPosition();
						this.manager.listener.setPosition(position);
						var wtm = this.current.getWorldTransform();
						this.manager.listener.setOrientation(wtm);
				}
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'audiolistener';
				this.ComponentType = AudioListenerComponent;
				this.DataType = AudioListenerComponentData;
				this.schema = _schema$i;
				this.manager = app.soundManager;
				this.current = null;
				this.app.systems.on('update', this.onUpdate, this);
		}
}
Component._buildAccessors(AudioListenerComponent.prototype, _schema$i);

var BUTTON_TRANSITION_MODE_TINT = 0;
var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

var ELEMENTTYPE_GROUP = 'group';
var ELEMENTTYPE_IMAGE = 'image';
var ELEMENTTYPE_TEXT = 'text';
var FITMODE_STRETCH = 'stretch';
var FITMODE_CONTAIN = 'contain';
var FITMODE_COVER = 'cover';

var VisualState = {
		DEFAULT: 'DEFAULT',
		HOVER: 'HOVER',
		PRESSED: 'PRESSED',
		INACTIVE: 'INACTIVE'
};
var STATES_TO_TINT_NAMES = {};
STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
var STATES_TO_SPRITE_ASSET_NAMES = {};
STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
var STATES_TO_SPRITE_FRAME_NAMES = {};
STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';
class ButtonComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {
				this._setValue('enabled', arg);
		}
		get enabled() {
				return this.data.enabled;
		}
		set active(arg) {
				this._setValue('active', arg);
		}
		get active() {
				return this.data.active;
		}
		set imageEntity(arg) {
				if (this._imageEntity !== arg) {
						var isString = typeof arg === 'string';
						if (this._imageEntity && isString && this._imageEntity.getGuid() === arg) {
								return;
						}
						if (this._imageEntity) {
								this._imageEntityUnsubscribe();
						}
						if (arg instanceof GraphNode) {
								this._imageEntity = arg;
						} else if (isString) {
								this._imageEntity = this.system.app.getEntityFromIndex(arg) || null;
						} else {
								this._imageEntity = null;
						}
						if (this._imageEntity) {
								this._imageEntitySubscribe();
						}
						if (this._imageEntity) {
								this.data.imageEntity = this._imageEntity.getGuid();
						} else if (isString && arg) {
								this.data.imageEntity = arg;
						}
				}
		}
		get imageEntity() {
				return this._imageEntity;
		}
		set hitPadding(arg) {
				this._setValue('hitPadding', arg);
		}
		get hitPadding() {
				return this.data.hitPadding;
		}
		set transitionMode(arg) {
				this._setValue('transitionMode', arg);
		}
		get transitionMode() {
				return this.data.transitionMode;
		}
		set hoverTint(arg) {
				this._setValue('hoverTint', arg);
		}
		get hoverTint() {
				return this.data.hoverTint;
		}
		set pressedTint(arg) {
				this._setValue('pressedTint', arg);
		}
		get pressedTint() {
				return this.data.pressedTint;
		}
		set inactiveTint(arg) {
				this._setValue('inactiveTint', arg);
		}
		get inactiveTint() {
				return this.data.inactiveTint;
		}
		set fadeDuration(arg) {
				this._setValue('fadeDuration', arg);
		}
		get fadeDuration() {
				return this.data.fadeDuration;
		}
		set hoverSpriteAsset(arg) {
				this._setValue('hoverSpriteAsset', arg);
		}
		get hoverSpriteAsset() {
				return this.data.hoverSpriteAsset;
		}
		set hoverSpriteFrame(arg) {
				this._setValue('hoverSpriteFrame', arg);
		}
		get hoverSpriteFrame() {
				return this.data.hoverSpriteFrame;
		}
		set pressedSpriteAsset(arg) {
				this._setValue('pressedSpriteAsset', arg);
		}
		get pressedSpriteAsset() {
				return this.data.pressedSpriteAsset;
		}
		set pressedSpriteFrame(arg) {
				this._setValue('pressedSpriteFrame', arg);
		}
		get pressedSpriteFrame() {
				return this.data.pressedSpriteFrame;
		}
		set inactiveSpriteAsset(arg) {
				this._setValue('inactiveSpriteAsset', arg);
		}
		get inactiveSpriteAsset() {
				return this.data.inactiveSpriteAsset;
		}
		set inactiveSpriteFrame(arg) {
				this._setValue('inactiveSpriteFrame', arg);
		}
		get inactiveSpriteFrame() {
				return this.data.inactiveSpriteFrame;
		}
		_setValue(name, value) {
				var data = this.data;
				var oldValue = data[name];
				data[name] = value;
				this.fire('set', name, oldValue, value);
		}
		_toggleLifecycleListeners(onOrOff, system) {
				this[onOrOff]('set_active', this._onSetActive, this);
				this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
				this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
				this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
				this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
				this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
				this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
				this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
				this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
				this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
				this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
				if (onOrOff === 'on') {
						this._evtElementAdd = this.entity.on('element:add', this._onElementComponentAdd, this);
				} else {
						var _this__evtElementAdd;
						(_this__evtElementAdd = this._evtElementAdd) == null ? void 0 : _this__evtElementAdd.off();
						this._evtElementAdd = null;
				}
		}
		_onSetActive(name, oldValue, newValue) {
				if (oldValue !== newValue) {
						this._updateVisualState();
				}
		}
		_onSetTransitionMode(name, oldValue, newValue) {
				if (oldValue !== newValue) {
						this._cancelTween();
						this._resetToDefaultVisualState(oldValue);
						this._forceReapplyVisualState();
				}
		}
		_onSetTransitionValue(name, oldValue, newValue) {
				if (oldValue !== newValue) {
						this._forceReapplyVisualState();
				}
		}
		_imageEntitySubscribe() {
				this._evtImageEntityElementAdd = this._imageEntity.on('element:add', this._onImageElementGain, this);
				if (this._imageEntity.element) {
						this._onImageElementGain();
				}
		}
		_imageEntityUnsubscribe() {
				var _this__evtImageEntityElementAdd, _this__imageEntity;
				(_this__evtImageEntityElementAdd = this._evtImageEntityElementAdd) == null ? void 0 : _this__evtImageEntityElementAdd.off();
				this._evtImageEntityElementAdd = null;
				if ((_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element) {
						this._onImageElementLose();
				}
		}
		_imageEntityElementSubscribe() {
				var element = this._imageEntity.element;
				this._evtImageEntityElementRemove = element.once('beforeremove', this._onImageElementLose, this);
				this._evtImageEntityElementColor = element.on('set:color', this._onSetColor, this);
				this._evtImageEntityElementOpacity = element.on('set:opacity', this._onSetOpacity, this);
				this._evtImageEntityElementSpriteAsset = element.on('set:spriteAsset', this._onSetSpriteAsset, this);
				this._evtImageEntityElementSpriteFrame = element.on('set:spriteFrame', this._onSetSpriteFrame, this);
		}
		_imageEntityElementUnsubscribe() {
				var _this__evtImageEntityElementRemove, _this__evtImageEntityElementColor, _this__evtImageEntityElementOpacity, _this__evtImageEntityElementSpriteAsset, _this__evtImageEntityElementSpriteFrame;
				(_this__evtImageEntityElementRemove = this._evtImageEntityElementRemove) == null ? void 0 : _this__evtImageEntityElementRemove.off();
				this._evtImageEntityElementRemove = null;
				(_this__evtImageEntityElementColor = this._evtImageEntityElementColor) == null ? void 0 : _this__evtImageEntityElementColor.off();
				this._evtImageEntityElementColor = null;
				(_this__evtImageEntityElementOpacity = this._evtImageEntityElementOpacity) == null ? void 0 : _this__evtImageEntityElementOpacity.off();
				this._evtImageEntityElementOpacity = null;
				(_this__evtImageEntityElementSpriteAsset = this._evtImageEntityElementSpriteAsset) == null ? void 0 : _this__evtImageEntityElementSpriteAsset.off();
				this._evtImageEntityElementSpriteAsset = null;
				(_this__evtImageEntityElementSpriteFrame = this._evtImageEntityElementSpriteFrame) == null ? void 0 : _this__evtImageEntityElementSpriteFrame.off();
				this._evtImageEntityElementSpriteFrame = null;
		}
		_onElementComponentRemove() {
				this._toggleHitElementListeners('off');
		}
		_onElementComponentAdd() {
				this._toggleHitElementListeners('on');
		}
		_onImageElementLose() {
				this._imageEntityElementUnsubscribe();
				this._cancelTween();
				this._resetToDefaultVisualState(this.transitionMode);
		}
		_onImageElementGain() {
				this._imageEntityElementSubscribe();
				this._storeDefaultVisualState();
				this._forceReapplyVisualState();
		}
		_toggleHitElementListeners(onOrOff) {
				if (this.entity.element) {
						var isAdding = onOrOff === 'on';
						if (isAdding && this._hasHitElementListeners) {
								return;
						}
						this.entity.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
						this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
						this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
						this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
						this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
						this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
						this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
						this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
						this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
						this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
						this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
						this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
						this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
						this.entity.element[onOrOff]('click', this._onClick, this);
						this._hasHitElementListeners = isAdding;
				}
		}
		_storeDefaultVisualState() {
				var _this__imageEntity;
				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
				if (!element || element.type === ELEMENTTYPE_GROUP) {
						return;
				}
				this._storeDefaultColor(element.color);
				this._storeDefaultOpacity(element.opacity);
				this._storeDefaultSpriteAsset(element.spriteAsset);
				this._storeDefaultSpriteFrame(element.spriteFrame);
		}
		_storeDefaultColor(color) {
				this._defaultTint.r = color.r;
				this._defaultTint.g = color.g;
				this._defaultTint.b = color.b;
		}
		_storeDefaultOpacity(opacity) {
				this._defaultTint.a = opacity;
		}
		_storeDefaultSpriteAsset(spriteAsset) {
				this._defaultSpriteAsset = spriteAsset;
		}
		_storeDefaultSpriteFrame(spriteFrame) {
				this._defaultSpriteFrame = spriteFrame;
		}
		_onSetColor(color) {
				if (!this._isApplyingTint) {
						this._storeDefaultColor(color);
						this._forceReapplyVisualState();
				}
		}
		_onSetOpacity(opacity) {
				if (!this._isApplyingTint) {
						this._storeDefaultOpacity(opacity);
						this._forceReapplyVisualState();
				}
		}
		_onSetSpriteAsset(spriteAsset) {
				if (!this._isApplyingSprite) {
						this._storeDefaultSpriteAsset(spriteAsset);
						this._forceReapplyVisualState();
				}
		}
		_onSetSpriteFrame(spriteFrame) {
				if (!this._isApplyingSprite) {
						this._storeDefaultSpriteFrame(spriteFrame);
						this._forceReapplyVisualState();
				}
		}
		_onMouseEnter(event) {
				this._isHovering = true;
				this._updateVisualState();
				this._fireIfActive('mouseenter', event);
		}
		_onMouseLeave(event) {
				this._isHovering = false;
				this._isPressed = false;
				this._updateVisualState();
				this._fireIfActive('mouseleave', event);
		}
		_onMouseDown(event) {
				this._isPressed = true;
				this._updateVisualState();
				this._fireIfActive('mousedown', event);
		}
		_onMouseUp(event) {
				this._isPressed = false;
				this._updateVisualState();
				this._fireIfActive('mouseup', event);
		}
		_onTouchStart(event) {
				this._isPressed = true;
				this._updateVisualState();
				this._fireIfActive('touchstart', event);
		}
		_onTouchEnd(event) {
				event.event.preventDefault();
				this._isPressed = false;
				this._updateVisualState();
				this._fireIfActive('touchend', event);
		}
		_onTouchLeave(event) {
				this._isPressed = false;
				this._updateVisualState();
				this._fireIfActive('touchleave', event);
		}
		_onTouchCancel(event) {
				this._isPressed = false;
				this._updateVisualState();
				this._fireIfActive('touchcancel', event);
		}
		_onSelectStart(event) {
				this._isPressed = true;
				this._updateVisualState();
				this._fireIfActive('selectstart', event);
		}
		_onSelectEnd(event) {
				this._isPressed = false;
				this._updateVisualState();
				this._fireIfActive('selectend', event);
		}
		_onSelectEnter(event) {
				this._hoveringCounter++;
				if (this._hoveringCounter === 1) {
						this._isHovering = true;
						this._updateVisualState();
				}
				this._fireIfActive('selectenter', event);
		}
		_onSelectLeave(event) {
				this._hoveringCounter--;
				if (this._hoveringCounter === 0) {
						this._isHovering = false;
						this._isPressed = false;
						this._updateVisualState();
				}
				this._fireIfActive('selectleave', event);
		}
		_onClick(event) {
				this._fireIfActive('click', event);
		}
		_fireIfActive(name, event) {
				if (this.data.active) {
						this.fire(name, event);
				}
		}
		_updateVisualState(force) {
				var oldVisualState = this._visualState;
				var newVisualState = this._determineVisualState();
				if ((oldVisualState !== newVisualState || force) && this.enabled) {
						this._visualState = newVisualState;
						if (oldVisualState === VisualState.HOVER) {
								this._fireIfActive('hoverend');
						}
						if (oldVisualState === VisualState.PRESSED) {
								this._fireIfActive('pressedend');
						}
						if (newVisualState === VisualState.HOVER) {
								this._fireIfActive('hoverstart');
						}
						if (newVisualState === VisualState.PRESSED) {
								this._fireIfActive('pressedstart');
						}
						switch(this.transitionMode){
								case BUTTON_TRANSITION_MODE_TINT:
										{
												var tintName = STATES_TO_TINT_NAMES[this._visualState];
												var tintColor = this[tintName];
												this._applyTint(tintColor);
												break;
										}
								case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
										{
												var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
												var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
												var spriteAsset = this[spriteAssetName];
												var spriteFrame = this[spriteFrameName];
												this._applySprite(spriteAsset, spriteFrame);
												break;
										}
						}
				}
		}
		_forceReapplyVisualState() {
				this._updateVisualState(true);
		}
		_resetToDefaultVisualState(transitionMode) {
				var _this__imageEntity;
				if (!((_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element)) {
						return;
				}
				switch(transitionMode){
						case BUTTON_TRANSITION_MODE_TINT:
								this._cancelTween();
								this._applyTintImmediately(this._defaultTint);
								break;
						case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
								this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
								break;
				}
		}
		_determineVisualState() {
				if (!this.active) {
						return VisualState.INACTIVE;
				} else if (this._isPressed) {
						return VisualState.PRESSED;
				} else if (this._isHovering) {
						return VisualState.HOVER;
				}
				return VisualState.DEFAULT;
		}
		_applySprite(spriteAsset, spriteFrame) {
				var _this__imageEntity;
				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
				if (!element) {
						return;
				}
				spriteFrame = spriteFrame || 0;
				this._isApplyingSprite = true;
				if (element.spriteAsset !== spriteAsset) {
						element.spriteAsset = spriteAsset;
				}
				if (element.spriteFrame !== spriteFrame) {
						element.spriteFrame = spriteFrame;
				}
				this._isApplyingSprite = false;
		}
		_applyTint(tintColor) {
				this._cancelTween();
				if (this.fadeDuration === 0) {
						this._applyTintImmediately(tintColor);
				} else {
						this._applyTintWithTween(tintColor);
				}
		}
		_applyTintImmediately(tintColor) {
				var _this__imageEntity;
				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
				if (!tintColor || !element || element.type === ELEMENTTYPE_GROUP) {
						return;
				}
				var color3 = toColor3(tintColor);
				this._isApplyingTint = true;
				if (!color3.equals(element.color)) {
						element.color = color3;
				}
				if (element.opacity !== tintColor.a) {
						element.opacity = tintColor.a;
				}
				this._isApplyingTint = false;
		}
		_applyTintWithTween(tintColor) {
				var _this__imageEntity;
				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
				if (!tintColor || !element || element.type === ELEMENTTYPE_GROUP) {
						return;
				}
				var color3 = toColor3(tintColor);
				var color = element.color;
				var opacity = element.opacity;
				if (color3.equals(color) && tintColor.a === opacity) return;
				this._tweenInfo = {
						startTime: now(),
						from: new Color(color.r, color.g, color.b, opacity),
						to: tintColor.clone(),
						lerpColor: new Color()
				};
		}
		_updateTintTween() {
				var elapsedTime = now() - this._tweenInfo.startTime;
				var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
				elapsedProportion = math.clamp(elapsedProportion, 0, 1);
				if (Math.abs(elapsedProportion - 1) > 1e-5) {
						var lerpColor = this._tweenInfo.lerpColor;
						lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
						this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
				} else {
						this._applyTintImmediately(this._tweenInfo.to);
						this._cancelTween();
				}
		}
		_cancelTween() {
				delete this._tweenInfo;
		}
		onUpdate() {
				if (this._tweenInfo) {
						this._updateTintTween();
				}
		}
		onEnable() {
				this._isHovering = false;
				this._hoveringCounter = 0;
				this._isPressed = false;
				this._toggleHitElementListeners('on');
				this._forceReapplyVisualState();
		}
		onDisable() {
				this._toggleHitElementListeners('off');
				this._resetToDefaultVisualState(this.transitionMode);
		}
		onRemove() {
				this._imageEntityUnsubscribe();
				this._toggleLifecycleListeners('off', this.system);
				this.onDisable();
		}
		resolveDuplicatedEntityReferenceProperties(oldButton, duplicatedIdsMap) {
				if (oldButton.imageEntity) {
						this.imageEntity = duplicatedIdsMap[oldButton.imageEntity.getGuid()];
				}
		}
		constructor(system, entity){
				super(system, entity), this._visualState = VisualState.DEFAULT, this._isHovering = false, this._hoveringCounter = 0, this._isPressed = false, this._defaultTint = new Color(1, 1, 1, 1), this._defaultSpriteAsset = null, this._defaultSpriteFrame = 0, this._imageEntity = null, this._evtElementAdd = null, this._evtImageEntityElementAdd = null, this._evtImageEntityElementRemove = null, this._evtImageEntityElementColor = null, this._evtImageEntityElementOpacity = null, this._evtImageEntityElementSpriteAsset = null, this._evtImageEntityElementSpriteFrame = null;
				this._visualState = VisualState.DEFAULT;
				this._isHovering = false;
				this._hoveringCounter = 0;
				this._isPressed = false;
				this._defaultTint = new Color(1, 1, 1, 1);
				this._defaultSpriteAsset = null;
				this._defaultSpriteFrame = 0;
				this._toggleLifecycleListeners('on', system);
		}
}
ButtonComponent.EVENT_MOUSEDOWN = 'mousedown';
ButtonComponent.EVENT_MOUSEUP = 'mouseup';
ButtonComponent.EVENT_MOUSEENTER = 'mouseenter';
ButtonComponent.EVENT_MOUSELEAVE = 'mouseleave';
ButtonComponent.EVENT_CLICK = 'click';
ButtonComponent.EVENT_TOUCHSTART = 'touchstart';
ButtonComponent.EVENT_TOUCHEND = 'touchend';
ButtonComponent.EVENT_TOUCHCANCEL = 'touchcancel';
ButtonComponent.EVENT_TOUCHLEAVE = 'touchleave';
ButtonComponent.EVENT_SELECTSTART = 'selectstart';
ButtonComponent.EVENT_SELECTEND = 'selectend';
ButtonComponent.EVENT_SELECTENTER = 'selectenter';
ButtonComponent.EVENT_SELECTLEAVE = 'selectleave';
ButtonComponent.EVENT_HOVERSTART = 'hoverstart';
ButtonComponent.EVENT_HOVEREND = 'hoverend';
ButtonComponent.EVENT_PRESSEDSTART = 'pressedstart';
ButtonComponent.EVENT_PRESSEDEND = 'pressedend';
function toColor3(color4) {
		return new Color(color4.r, color4.g, color4.b);
}

class ButtonComponentData {
		constructor(){
				this.enabled = true;
				this.active = true;
				this.imageEntity = null;
				this.hitPadding = new Vec4();
				this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
				this.hoverTint = new Color(0.75, 0.75, 0.75);
				this.pressedTint = new Color(0.5, 0.5, 0.5);
				this.inactiveTint = new Color(0.25, 0.25, 0.25);
				this.fadeDuration = 0;
				this.hoverSpriteAsset = null;
				this.hoverSpriteFrame = 0;
				this.pressedSpriteAsset = null;
				this.pressedSpriteFrame = 0;
				this.inactiveSpriteAsset = null;
				this.inactiveSpriteFrame = 0;
		}
}

var _schema$h = [
		'enabled',
		'active',
		{
				name: 'hitPadding',
				type: 'vec4'
		},
		'transitionMode',
		{
				name: 'hoverTint',
				type: 'rgba'
		},
		{
				name: 'pressedTint',
				type: 'rgba'
		},
		{
				name: 'inactiveTint',
				type: 'rgba'
		},
		'fadeDuration',
		'hoverSpriteAsset',
		'hoverSpriteFrame',
		'pressedSpriteAsset',
		'pressedSpriteFrame',
		'inactiveSpriteAsset',
		'inactiveSpriteFrame'
];
class ButtonComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				component.imageEntity = data.imageEntity;
				super.initializeComponentData(component, data, _schema$h);
		}
		onUpdate(dt) {
				var components = this.store;
				for(var id in components){
						var entity = components[id].entity;
						var component = entity.button;
						if (component.enabled && entity.enabled) {
								component.onUpdate();
						}
				}
		}
		_onRemoveComponent(entity, component) {
				component.onRemove();
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'button';
				this.ComponentType = ButtonComponent;
				this.DataType = ButtonComponentData;
				this.schema = _schema$h;
				this.on('beforeremove', this._onRemoveComponent, this);
				this.app.systems.on('update', this.onUpdate, this);
		}
}

var _vec3$1 = new Vec3();
var _quat = new Quat();
class CollisionComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {
				this._setValue('enabled', arg);
		}
		get enabled() {
				return this.data.enabled;
		}
		set type(arg) {
				this._setValue('type', arg);
		}
		get type() {
				return this.data.type;
		}
		set halfExtents(arg) {
				this._setValue('halfExtents', arg);
		}
		get halfExtents() {
				return this.data.halfExtents;
		}
		set linearOffset(arg) {
				this._setValue('linearOffset', arg);
		}
		get linearOffset() {
				return this.data.linearOffset;
		}
		set angularOffset(arg) {
				this._setValue('angularOffset', arg);
		}
		get angularOffset() {
				return this.data.angularOffset;
		}
		set radius(arg) {
				this._setValue('radius', arg);
		}
		get radius() {
				return this.data.radius;
		}
		set axis(arg) {
				this._setValue('axis', arg);
		}
		get axis() {
				return this.data.axis;
		}
		set height(arg) {
				this._setValue('height', arg);
		}
		get height() {
				return this.data.height;
		}
		set asset(arg) {
				this._setValue('asset', arg);
		}
		get asset() {
				return this.data.asset;
		}
		set renderAsset(arg) {
				this._setValue('renderAsset', arg);
		}
		get renderAsset() {
				return this.data.renderAsset;
		}
		set convexHull(arg) {
				this._setValue('convexHull', arg);
		}
		get convexHull() {
				return this.data.convexHull;
		}
		set shape(arg) {
				this._setValue('shape', arg);
		}
		get shape() {
				return this.data.shape;
		}
		set model(arg) {
				this._setValue('model', arg);
		}
		get model() {
				return this.data.model;
		}
		set render(arg) {
				this._setValue('render', arg);
		}
		get render() {
				return this.data.render;
		}
		set checkVertexDuplicates(arg) {
				this._setValue('checkVertexDuplicates', arg);
		}
		get checkVertexDuplicates() {
				return this.data.checkVertexDuplicates;
		}
		_setValue(name, value) {
				var data = this.data;
				var oldValue = data[name];
				data[name] = value;
				this.fire('set', name, oldValue, value);
		}
		onSetType(name, oldValue, newValue) {
				if (oldValue !== newValue) {
						this.system.changeType(this, oldValue, newValue);
				}
		}
		onSetHalfExtents(name, oldValue, newValue) {
				var t = this.data.type;
				if (this.data.initialized && t === 'box') {
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetOffset(name, oldValue, newValue) {
				this._hasOffset = !this.data.linearOffset.equals(Vec3.ZERO) || !this.data.angularOffset.equals(Quat.IDENTITY);
				if (this.data.initialized) {
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetRadius(name, oldValue, newValue) {
				var t = this.data.type;
				if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetHeight(name, oldValue, newValue) {
				var t = this.data.type;
				if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetAxis(name, oldValue, newValue) {
				var t = this.data.type;
				if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetAsset(name, oldValue, newValue) {
				var assets = this.system.app.assets;
				if (oldValue) {
						var asset = assets.get(oldValue);
						if (asset) {
								asset.off('remove', this.onAssetRemoved, this);
						}
				}
				if (newValue) {
						if (newValue instanceof Asset) {
								this.data.asset = newValue.id;
						}
						var asset1 = assets.get(this.data.asset);
						if (asset1) {
								asset1.off('remove', this.onAssetRemoved, this);
								asset1.on('remove', this.onAssetRemoved, this);
						}
				}
				if (this.data.initialized && this.data.type === 'mesh') {
						if (!newValue) {
								this.data.model = null;
						}
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetRenderAsset(name, oldValue, newValue) {
				var assets = this.system.app.assets;
				if (oldValue) {
						var asset = assets.get(oldValue);
						if (asset) {
								asset.off('remove', this.onRenderAssetRemoved, this);
						}
				}
				if (newValue) {
						if (newValue instanceof Asset) {
								this.data.renderAsset = newValue.id;
						}
						var asset1 = assets.get(this.data.renderAsset);
						if (asset1) {
								asset1.off('remove', this.onRenderAssetRemoved, this);
								asset1.on('remove', this.onRenderAssetRemoved, this);
						}
				}
				if (this.data.initialized && this.data.type === 'mesh') {
						if (!newValue) {
								this.data.render = null;
						}
						this.system.recreatePhysicalShapes(this);
				}
		}
		onSetModel(name, oldValue, newValue) {
				if (this.data.initialized && this.data.type === 'mesh') {
						this.system.implementations.mesh.doRecreatePhysicalShape(this);
				}
		}
		onSetRender(name, oldValue, newValue) {
				this.onSetModel(name, oldValue, newValue);
		}
		onAssetRemoved(asset) {
				asset.off('remove', this.onAssetRemoved, this);
				if (this.data.asset === asset.id) {
						this.asset = null;
				}
		}
		onRenderAssetRemoved(asset) {
				asset.off('remove', this.onRenderAssetRemoved, this);
				if (this.data.renderAsset === asset.id) {
						this.renderAsset = null;
				}
		}
		getCompoundChildShapeIndex(shape) {
				var compound = this.data.shape;
				var shapes = compound.getNumChildShapes();
				for(var i = 0; i < shapes; i++){
						var childShape = compound.getChildShape(i);
						if (Ammo.getPointer(childShape) === Ammo.getPointer(shape)) {
								return i;
						}
				}
				return null;
		}
		_onInsert(parent) {
				if (typeof Ammo === 'undefined') {
						return;
				}
				if (this._compoundParent) {
						this.system.recreatePhysicalShapes(this);
				} else if (!this.entity.rigidbody) {
						var ancestor = this.entity.parent;
						while(ancestor){
								if (ancestor.collision && ancestor.collision.type === 'compound') {
										if (ancestor.collision.shape.getNumChildShapes() === 0) {
												this.system.recreatePhysicalShapes(ancestor.collision);
										} else {
												this.system.recreatePhysicalShapes(this);
										}
										break;
								}
								ancestor = ancestor.parent;
						}
				}
		}
		_updateCompound() {
				var entity = this.entity;
				if (entity._dirtyWorld) {
						var dirty = entity._dirtyLocal;
						var parent = entity;
						while(parent && !dirty){
								if (parent.collision && parent.collision === this._compoundParent) {
										break;
								}
								if (parent._dirtyLocal) {
										dirty = true;
								}
								parent = parent.parent;
						}
						if (dirty) {
								entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
								var bodyComponent = this._compoundParent.entity.rigidbody;
								if (bodyComponent) {
										bodyComponent.activate();
								}
						}
				}
		}
		getShapePosition() {
				var pos = this.entity.getPosition();
				if (this._hasOffset) {
						var rot = this.entity.getRotation();
						var lo = this.data.linearOffset;
						_quat.copy(rot).transformVector(lo, _vec3$1);
						return _vec3$1.add(pos);
				}
				return pos;
		}
		getShapeRotation() {
				var rot = this.entity.getRotation();
				if (this._hasOffset) {
						return _quat.copy(rot).mul(this.data.angularOffset);
				}
				return rot;
		}
		onEnable() {
				if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
						var asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
						if (asset && (!asset.resource || !this.data.shape)) {
								this.system.recreatePhysicalShapes(this);
								return;
						}
				}
				if (this.entity.rigidbody) {
						if (this.entity.rigidbody.enabled) {
								this.entity.rigidbody.enableSimulation();
						}
				} else if (this._compoundParent && this !== this._compoundParent) {
						if (this._compoundParent.shape.getNumChildShapes() === 0) {
								this.system.recreatePhysicalShapes(this._compoundParent);
						} else {
								var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
								this._compoundParent.shape.addChildShape(transform, this.data.shape);
								Ammo.destroy(transform);
								if (this._compoundParent.entity.rigidbody) {
										this._compoundParent.entity.rigidbody.activate();
								}
						}
				} else if (this.entity.trigger) {
						this.entity.trigger.enable();
				}
		}
		onDisable() {
				if (this.entity.rigidbody) {
						this.entity.rigidbody.disableSimulation();
				} else if (this._compoundParent && this !== this._compoundParent) {
						if (!this._compoundParent.entity._destroying) {
								this.system._removeCompoundChild(this._compoundParent, this.data.shape);
								if (this._compoundParent.entity.rigidbody) {
										this._compoundParent.entity.rigidbody.activate();
								}
						}
				} else if (this.entity.trigger) {
						this.entity.trigger.disable();
				}
		}
		onBeforeRemove() {
				if (this.asset) {
						this.asset = null;
				}
				if (this.renderAsset) {
						this.renderAsset = null;
				}
				this.entity.off('insert', this._onInsert, this);
				this.off();
		}
		constructor(system, entity){
				super(system, entity), this._compoundParent = null, this._hasOffset = false;
				this.entity.on('insert', this._onInsert, this);
				this.on('set_type', this.onSetType, this);
				this.on('set_convexHull', this.onSetModel, this);
				this.on('set_halfExtents', this.onSetHalfExtents, this);
				this.on('set_linearOffset', this.onSetOffset, this);
				this.on('set_angularOffset', this.onSetOffset, this);
				this.on('set_radius', this.onSetRadius, this);
				this.on('set_height', this.onSetHeight, this);
				this.on('set_axis', this.onSetAxis, this);
				this.on('set_asset', this.onSetAsset, this);
				this.on('set_renderAsset', this.onSetRenderAsset, this);
				this.on('set_model', this.onSetModel, this);
				this.on('set_render', this.onSetRender, this);
		}
}
CollisionComponent.EVENT_CONTACT = 'contact';
CollisionComponent.EVENT_COLLISIONSTART = 'collisionstart';
CollisionComponent.EVENT_COLLISIONEND = 'collisionend';
CollisionComponent.EVENT_TRIGGERENTER = 'triggerenter';
CollisionComponent.EVENT_TRIGGERLEAVE = 'triggerleave';

class CollisionComponentData {
		constructor(){
				this.enabled = true;
				this.type = 'box';
				this.halfExtents = new Vec3(0.5, 0.5, 0.5);
				this.linearOffset = new Vec3();
				this.angularOffset = new Quat();
				this.radius = 0.5;
				this.axis = 1;
				this.height = 2;
				this.convexHull = false;
				this.asset = null;
				this.renderAsset = null;
				this.checkVertexDuplicates = true;
				this.shape = null;
				this.model = null;
				this.render = null;
				this.initialized = false;
		}
}

var BODYTYPE_STATIC = 'static';
var BODYTYPE_DYNAMIC = 'dynamic';
var BODYTYPE_KINEMATIC = 'kinematic';
var BODYFLAG_STATIC_OBJECT = 1;
var BODYFLAG_KINEMATIC_OBJECT = 2;
var BODYFLAG_NORESPONSE_OBJECT = 4;
var BODYSTATE_ACTIVE_TAG = 1;
var BODYSTATE_ISLAND_SLEEPING = 2;
var BODYSTATE_WANTS_DEACTIVATION = 3;
var BODYSTATE_DISABLE_DEACTIVATION = 4;
var BODYSTATE_DISABLE_SIMULATION = 5;
var BODYGROUP_NONE = 0;
var BODYGROUP_DEFAULT = 1;
var BODYGROUP_DYNAMIC = 1;
var BODYGROUP_STATIC = 2;
var BODYGROUP_KINEMATIC = 4;
var BODYGROUP_ENGINE_1 = 8;
var BODYGROUP_TRIGGER = 16;
var BODYGROUP_ENGINE_2 = 32;
var BODYGROUP_ENGINE_3 = 64;
var BODYGROUP_USER_1 = 128;
var BODYGROUP_USER_2 = 256;
var BODYGROUP_USER_3 = 512;
var BODYGROUP_USER_4 = 1024;
var BODYGROUP_USER_5 = 2048;
var BODYGROUP_USER_6 = 4096;
var BODYGROUP_USER_7 = 8192;
var BODYGROUP_USER_8 = 16384;
var BODYMASK_NONE = 0;
var BODYMASK_ALL = 65535;
var BODYMASK_STATIC = 2;
var BODYMASK_NOT_STATIC = 65535 ^ 2;
var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

var _ammoVec1$1, _ammoQuat$1, _ammoTransform$1;
class Trigger {
		initialize(data) {
				var entity = this.entity;
				var shape = data.shape;
				if (shape && typeof Ammo !== 'undefined') {
						if (entity.trigger) {
								entity.trigger.destroy();
						}
						var mass = 1;
						var component = this.component;
						if (component) {
								var bodyPos = component.getShapePosition();
								var bodyRot = component.getShapeRotation();
								_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
								_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
						} else {
								var pos = entity.getPosition();
								var rot = entity.getRotation();
								_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
								_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
						}
						_ammoTransform$1.setOrigin(_ammoVec1$1);
						_ammoTransform$1.setRotation(_ammoQuat$1);
						var body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform$1);
						body.setRestitution(0);
						body.setFriction(0);
						body.setDamping(0, 0);
						_ammoVec1$1.setValue(0, 0, 0);
						body.setLinearFactor(_ammoVec1$1);
						body.setAngularFactor(_ammoVec1$1);
						body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
						body.entity = entity;
						this.body = body;
						if (this.component.enabled && entity.enabled) {
								this.enable();
						}
				}
		}
		destroy() {
				if (!this.body) return;
				this.disable();
				this.app.systems.rigidbody.destroyBody(this.body);
				this.body = null;
		}
		_getEntityTransform(transform) {
				var component = this.component;
				if (component) {
						var bodyPos = component.getShapePosition();
						var bodyRot = component.getShapeRotation();
						_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
						_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
				} else {
						var pos = this.entity.getPosition();
						var rot = this.entity.getRotation();
						_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
						_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
				}
				transform.setOrigin(_ammoVec1$1);
				transform.setRotation(_ammoQuat$1);
		}
		updateTransform() {
				this._getEntityTransform(_ammoTransform$1);
				var body = this.body;
				body.setWorldTransform(_ammoTransform$1);
				body.activate();
		}
		enable() {
				var body = this.body;
				if (!body) return;
				var system = this.app.systems.rigidbody;
				var idx = system._triggers.indexOf(this);
				if (idx < 0) {
						system.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
						system._triggers.push(this);
				}
				body.forceActivationState(BODYSTATE_ACTIVE_TAG);
				this.updateTransform();
		}
		disable() {
				var body = this.body;
				if (!body) return;
				var system = this.app.systems.rigidbody;
				var idx = system._triggers.indexOf(this);
				if (idx > -1) {
						system.removeBody(body);
						system._triggers.splice(idx, 1);
				}
				body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
		}
		constructor(app, component, data){
				this.entity = component.entity;
				this.component = component;
				this.app = app;
				if (typeof Ammo !== 'undefined' && !_ammoVec1$1) {
						_ammoVec1$1 = new Ammo.btVector3();
						_ammoQuat$1 = new Ammo.btQuaternion();
						_ammoTransform$1 = new Ammo.btTransform();
				}
				this.initialize(data);
		}
}

var mat4 = new Mat4();
var p1 = new Vec3();
var p2 = new Vec3();
var quat$1 = new Quat();
var tempGraphNode = new GraphNode();
var _schema$g = [
		'enabled',
		'type',
		'halfExtents',
		'linearOffset',
		'angularOffset',
		'radius',
		'axis',
		'height',
		'convexHull',
		'asset',
		'renderAsset',
		'shape',
		'model',
		'render',
		'checkVertexDuplicates'
];
class CollisionSystemImpl {
		beforeInitialize(component, data) {
				data.shape = null;
				data.model = new Model();
				data.model.graph = new GraphNode();
		}
		afterInitialize(component, data) {
				this.recreatePhysicalShapes(component);
				component.data.initialized = true;
		}
		reset(component, data) {
				this.beforeInitialize(component, data);
				this.afterInitialize(component, data);
		}
		recreatePhysicalShapes(component) {
				var entity = component.entity;
				var data = component.data;
				if (typeof Ammo !== 'undefined') {
						if (entity.trigger) {
								entity.trigger.destroy();
								delete entity.trigger;
						}
						if (data.shape) {
								if (component._compoundParent) {
										if (component !== component._compoundParent) {
												this.system._removeCompoundChild(component._compoundParent, data.shape);
										}
										if (component._compoundParent.entity.rigidbody) {
												component._compoundParent.entity.rigidbody.activate();
										}
								}
								this.destroyShape(data);
						}
						data.shape = this.createPhysicalShape(component.entity, data);
						var firstCompoundChild = !component._compoundParent;
						if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
								component._compoundParent = component;
								entity.forEach(this._addEachDescendant, component);
						} else if (data.type !== 'compound') {
								if (!component.rigidbody) {
										component._compoundParent = null;
										var parent = entity.parent;
										while(parent){
												if (parent.collision && parent.collision.type === 'compound') {
														component._compoundParent = parent.collision;
														break;
												}
												parent = parent.parent;
										}
								}
						}
						if (component._compoundParent) {
								if (component !== component._compoundParent) {
										if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
												this.system.recreatePhysicalShapes(component._compoundParent);
										} else {
												this.system.updateCompoundChildTransform(entity, true);
												if (component._compoundParent.entity.rigidbody) {
														component._compoundParent.entity.rigidbody.activate();
												}
										}
								}
						}
						if (entity.rigidbody) {
								entity.rigidbody.disableSimulation();
								entity.rigidbody.createBody();
								if (entity.enabled && entity.rigidbody.enabled) {
										entity.rigidbody.enableSimulation();
								}
						} else if (!component._compoundParent) {
								if (!entity.trigger) {
										entity.trigger = new Trigger(this.system.app, component, data);
								} else {
										entity.trigger.initialize(data);
								}
						}
				}
		}
		createPhysicalShape(entity, data) {
				return undefined;
		}
		updateTransform(component, position, rotation, scale) {
				if (component.entity.trigger) {
						component.entity.trigger.updateTransform();
				}
		}
		destroyShape(data) {
				if (data.shape) {
						Ammo.destroy(data.shape);
						data.shape = null;
				}
		}
		beforeRemove(entity, component) {
				if (component.data.shape) {
						if (component._compoundParent && !component._compoundParent.entity._destroying) {
								this.system._removeCompoundChild(component._compoundParent, component.data.shape);
								if (component._compoundParent.entity.rigidbody) {
										component._compoundParent.entity.rigidbody.activate();
								}
						}
						component._compoundParent = null;
						this.destroyShape(component.data);
				}
		}
		remove(entity, data) {
				if (entity.rigidbody && entity.rigidbody.body) {
						entity.rigidbody.disableSimulation();
				}
				if (entity.trigger) {
						entity.trigger.destroy();
						delete entity.trigger;
				}
		}
		clone(entity, clone) {
				var src = this.system.store[entity.getGuid()];
				var data = {
						enabled: src.data.enabled,
						type: src.data.type,
						halfExtents: [
								src.data.halfExtents.x,
								src.data.halfExtents.y,
								src.data.halfExtents.z
						],
						linearOffset: [
								src.data.linearOffset.x,
								src.data.linearOffset.y,
								src.data.linearOffset.z
						],
						angularOffset: [
								src.data.angularOffset.x,
								src.data.angularOffset.y,
								src.data.angularOffset.z,
								src.data.angularOffset.w
						],
						radius: src.data.radius,
						axis: src.data.axis,
						height: src.data.height,
						convexHull: src.data.convexHull,
						asset: src.data.asset,
						renderAsset: src.data.renderAsset,
						model: src.data.model,
						render: src.data.render,
						checkVertexDuplicates: src.data.checkVertexDuplicates
				};
				return this.system.addComponent(clone, data);
		}
		constructor(system){
				this.system = system;
		}
}
class CollisionBoxSystemImpl extends CollisionSystemImpl {
		createPhysicalShape(entity, data) {
				if (typeof Ammo !== 'undefined') {
						var he = data.halfExtents;
						var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
						var shape = new Ammo.btBoxShape(ammoHe);
						Ammo.destroy(ammoHe);
						return shape;
				}
				return undefined;
		}
}
class CollisionSphereSystemImpl extends CollisionSystemImpl {
		createPhysicalShape(entity, data) {
				if (typeof Ammo !== 'undefined') {
						return new Ammo.btSphereShape(data.radius);
				}
				return undefined;
		}
}
class CollisionCapsuleSystemImpl extends CollisionSystemImpl {
		createPhysicalShape(entity, data) {
				var _data_axis;
				var axis = (_data_axis = data.axis) != null ? _data_axis : 1;
				var _data_radius;
				var radius = (_data_radius = data.radius) != null ? _data_radius : 0.5;
				var _data_height;
				var height = Math.max(((_data_height = data.height) != null ? _data_height : 2) - 2 * radius, 0);
				var shape = null;
				if (typeof Ammo !== 'undefined') {
						switch(axis){
								case 0:
										shape = new Ammo.btCapsuleShapeX(radius, height);
										break;
								case 1:
										shape = new Ammo.btCapsuleShape(radius, height);
										break;
								case 2:
										shape = new Ammo.btCapsuleShapeZ(radius, height);
										break;
						}
				}
				return shape;
		}
}
class CollisionCylinderSystemImpl extends CollisionSystemImpl {
		createPhysicalShape(entity, data) {
				var _data_axis;
				var axis = (_data_axis = data.axis) != null ? _data_axis : 1;
				var _data_radius;
				var radius = (_data_radius = data.radius) != null ? _data_radius : 0.5;
				var _data_height;
				var height = (_data_height = data.height) != null ? _data_height : 1;
				var halfExtents = null;
				var shape = null;
				if (typeof Ammo !== 'undefined') {
						switch(axis){
								case 0:
										halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
										shape = new Ammo.btCylinderShapeX(halfExtents);
										break;
								case 1:
										halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
										shape = new Ammo.btCylinderShape(halfExtents);
										break;
								case 2:
										halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
										shape = new Ammo.btCylinderShapeZ(halfExtents);
										break;
						}
				}
				if (halfExtents) {
						Ammo.destroy(halfExtents);
				}
				return shape;
		}
}
class CollisionConeSystemImpl extends CollisionSystemImpl {
		createPhysicalShape(entity, data) {
				var _data_axis;
				var axis = (_data_axis = data.axis) != null ? _data_axis : 1;
				var _data_radius;
				var radius = (_data_radius = data.radius) != null ? _data_radius : 0.5;
				var _data_height;
				var height = (_data_height = data.height) != null ? _data_height : 1;
				var shape = null;
				if (typeof Ammo !== 'undefined') {
						switch(axis){
								case 0:
										shape = new Ammo.btConeShapeX(radius, height);
										break;
								case 1:
										shape = new Ammo.btConeShape(radius, height);
										break;
								case 2:
										shape = new Ammo.btConeShapeZ(radius, height);
										break;
						}
				}
				return shape;
		}
}
class CollisionMeshSystemImpl extends CollisionSystemImpl {
		beforeInitialize(component, data) {}
		createAmmoHull(mesh, node, shape, scale) {
				var hull = new Ammo.btConvexHullShape();
				var point = new Ammo.btVector3();
				var positions = [];
				mesh.getPositions(positions);
				for(var i = 0; i < positions.length; i += 3){
						point.setValue(positions[i] * scale.x, positions[i + 1] * scale.y, positions[i + 2] * scale.z);
						hull.addPoint(point, false);
				}
				Ammo.destroy(point);
				hull.recalcLocalAabb();
				hull.setMargin(0.01);
				var transform = this.system._getNodeTransform(node);
				shape.addChildShape(transform, hull);
				Ammo.destroy(transform);
		}
		createAmmoMesh(mesh, node, shape, scale, checkDupes) {
				if (checkDupes === void 0) checkDupes = true;
				var system = this.system;
				var triMesh;
				if (system._triMeshCache[mesh.id]) {
						triMesh = system._triMeshCache[mesh.id];
				} else {
						var vb = mesh.vertexBuffer;
						var format = vb.getFormat();
						var stride, positions;
						for(var i = 0; i < format.elements.length; i++){
								var element = format.elements[i];
								if (element.name === SEMANTIC_POSITION) {
										positions = new Float32Array(vb.lock(), element.offset);
										stride = element.stride / 4;
										break;
								}
						}
						var indices = [];
						mesh.getIndices(indices);
						var numTriangles = mesh.primitive[0].count / 3;
						var v1 = new Ammo.btVector3();
						var i1, i2, i3;
						var base = mesh.primitive[0].base;
						triMesh = new Ammo.btTriangleMesh();
						system._triMeshCache[mesh.id] = triMesh;
						var vertexCache = new Map();
						var indexedArray = triMesh.getIndexedMeshArray();
						indexedArray.at(0).m_numTriangles = numTriangles;
						var sx = scale ? scale.x : 1;
						var sy = scale ? scale.y : 1;
						var sz = scale ? scale.z : 1;
						var addVertex = (index)=>{
								var x = positions[index * stride] * sx;
								var y = positions[index * stride + 1] * sy;
								var z = positions[index * stride + 2] * sz;
								var idx;
								if (checkDupes) {
										var str = x + ":" + y + ":" + z;
										idx = vertexCache.get(str);
										if (idx !== undefined) {
												return idx;
										}
										v1.setValue(x, y, z);
										idx = triMesh.findOrAddVertex(v1, false);
										vertexCache.set(str, idx);
								} else {
										v1.setValue(x, y, z);
										idx = triMesh.findOrAddVertex(v1, false);
								}
								return idx;
						};
						for(var i4 = 0; i4 < numTriangles; i4++){
								i1 = addVertex(indices[base + i4 * 3]);
								i2 = addVertex(indices[base + i4 * 3 + 1]);
								i3 = addVertex(indices[base + i4 * 3 + 2]);
								triMesh.addIndex(i1);
								triMesh.addIndex(i2);
								triMesh.addIndex(i3);
						}
						Ammo.destroy(v1);
				}
				var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, true);
				if (!scale) {
						var scaling = system._getNodeScaling(node);
						triMeshShape.setLocalScaling(scaling);
						Ammo.destroy(scaling);
				}
				var transform = system._getNodeTransform(node);
				shape.addChildShape(transform, triMeshShape);
				Ammo.destroy(transform);
		}
		createPhysicalShape(entity, data) {
				if (typeof Ammo === 'undefined') return undefined;
				if (data.model || data.render) {
						var shape = new Ammo.btCompoundShape();
						var entityTransform = entity.getWorldTransform();
						var scale = entityTransform.getScale();
						if (data.render) {
								var meshes = data.render.meshes;
								for(var i = 0; i < meshes.length; i++){
										if (data.convexHull) {
												this.createAmmoHull(meshes[i], tempGraphNode, shape, scale);
										} else {
												this.createAmmoMesh(meshes[i], tempGraphNode, shape, scale, data.checkVertexDuplicates);
										}
								}
						} else if (data.model) {
								var meshInstances = data.model.meshInstances;
								for(var i1 = 0; i1 < meshInstances.length; i1++){
										this.createAmmoMesh(meshInstances[i1].mesh, meshInstances[i1].node, shape, null, data.checkVertexDuplicates);
								}
								var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
								shape.setLocalScaling(vec);
								Ammo.destroy(vec);
						}
						return shape;
				}
				return undefined;
		}
		recreatePhysicalShapes(component) {
				var data = component.data;
				if (data.renderAsset || data.asset) {
						if (component.enabled && component.entity.enabled) {
								this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
								return;
						}
				}
				this.doRecreatePhysicalShape(component);
		}
		loadAsset(component, id, property) {
				var data = component.data;
				var assets = this.system.app.assets;
				var previousPropertyValue = data[property];
				var onAssetFullyReady = (asset)=>{
						if (data[property] !== previousPropertyValue) {
								return;
						}
						data[property] = asset.resource;
						this.doRecreatePhysicalShape(component);
				};
				var loadAndHandleAsset = (asset)=>{
						asset.ready((asset)=>{
								if (asset.data.containerAsset) {
										var containerAsset = assets.get(asset.data.containerAsset);
										if (containerAsset.loaded) {
												onAssetFullyReady(asset);
										} else {
												containerAsset.ready(()=>{
														onAssetFullyReady(asset);
												});
												assets.load(containerAsset);
										}
								} else {
										onAssetFullyReady(asset);
								}
						});
						assets.load(asset);
				};
				var asset = assets.get(id);
				if (asset) {
						loadAndHandleAsset(asset);
				} else {
						assets.once("add:" + id, loadAndHandleAsset);
				}
		}
		doRecreatePhysicalShape(component) {
				var entity = component.entity;
				var data = component.data;
				if (data.model || data.render) {
						this.destroyShape(data);
						data.shape = this.createPhysicalShape(entity, data);
						if (entity.rigidbody) {
								entity.rigidbody.disableSimulation();
								entity.rigidbody.createBody();
								if (entity.enabled && entity.rigidbody.enabled) {
										entity.rigidbody.enableSimulation();
								}
						} else {
								if (!entity.trigger) {
										entity.trigger = new Trigger(this.system.app, component, data);
								} else {
										entity.trigger.initialize(data);
								}
						}
				} else {
						this.beforeRemove(entity, component);
						this.remove(entity, data);
				}
		}
		updateTransform(component, position, rotation, scale) {
				if (component.shape) {
						var entityTransform = component.entity.getWorldTransform();
						var worldScale = entityTransform.getScale();
						var previousScale = component.shape.getLocalScaling();
						if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
								this.doRecreatePhysicalShape(component);
						}
				}
				super.updateTransform(component, position, rotation, scale);
		}
		destroyShape(data) {
				if (!data.shape) {
						return;
				}
				var numShapes = data.shape.getNumChildShapes();
				for(var i = 0; i < numShapes; i++){
						var shape = data.shape.getChildShape(i);
						Ammo.destroy(shape);
				}
				Ammo.destroy(data.shape);
				data.shape = null;
		}
}
class CollisionCompoundSystemImpl extends CollisionSystemImpl {
		createPhysicalShape(entity, data) {
				if (typeof Ammo !== 'undefined') {
						return new Ammo.btCompoundShape();
				}
				return undefined;
		}
		_addEachDescendant(entity) {
				if (!entity.collision || entity.rigidbody) {
						return;
				}
				entity.collision._compoundParent = this;
				if (entity !== this.entity) {
						entity.collision.system.recreatePhysicalShapes(entity.collision);
				}
		}
		_updateEachDescendant(entity) {
				if (!entity.collision) {
						return;
				}
				if (entity.collision._compoundParent !== this) {
						return;
				}
				entity.collision._compoundParent = null;
				if (entity !== this.entity && !entity.rigidbody) {
						entity.collision.system.recreatePhysicalShapes(entity.collision);
				}
		}
		_updateEachDescendantTransform(entity) {
				if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) {
						return;
				}
				this.collision.system.updateCompoundChildTransform(entity, false);
		}
}
class CollisionComponentSystem extends ComponentSystem {
		initializeComponentData(component, _data, properties) {
				properties = [
						'type',
						'halfExtents',
						'radius',
						'axis',
						'height',
						'convexHull',
						'shape',
						'model',
						'asset',
						'render',
						'renderAsset',
						'enabled',
						'linearOffset',
						'angularOffset',
						'checkVertexDuplicates'
				];
				var data = {};
				for(var i = 0, len = properties.length; i < len; i++){
						var property = properties[i];
						data[property] = _data[property];
				}
				var idx;
				if (_data.hasOwnProperty('asset')) {
						idx = properties.indexOf('model');
						if (idx !== -1) {
								properties.splice(idx, 1);
						}
						idx = properties.indexOf('render');
						if (idx !== -1) {
								properties.splice(idx, 1);
						}
				} else if (_data.hasOwnProperty('model')) {
						idx = properties.indexOf('asset');
						if (idx !== -1) {
								properties.splice(idx, 1);
						}
				}
				if (!data.type) {
						data.type = component.data.type;
				}
				component.data.type = data.type;
				if (Array.isArray(data.halfExtents)) {
						data.halfExtents = new Vec3(data.halfExtents);
				}
				if (Array.isArray(data.linearOffset)) {
						data.linearOffset = new Vec3(data.linearOffset);
				}
				if (Array.isArray(data.angularOffset)) {
						var values = data.angularOffset;
						if (values.length === 3) {
								data.angularOffset = new Quat().setFromEulerAngles(values[0], values[1], values[2]);
						} else {
								data.angularOffset = new Quat(data.angularOffset);
						}
				}
				var impl = this._createImplementation(data.type);
				impl.beforeInitialize(component, data);
				super.initializeComponentData(component, data, properties);
				impl.afterInitialize(component, data);
		}
		_createImplementation(type) {
				if (this.implementations[type] === undefined) {
						var impl;
						switch(type){
								case 'box':
										impl = new CollisionBoxSystemImpl(this);
										break;
								case 'sphere':
										impl = new CollisionSphereSystemImpl(this);
										break;
								case 'capsule':
										impl = new CollisionCapsuleSystemImpl(this);
										break;
								case 'cylinder':
										impl = new CollisionCylinderSystemImpl(this);
										break;
								case 'cone':
										impl = new CollisionConeSystemImpl(this);
										break;
								case 'mesh':
										impl = new CollisionMeshSystemImpl(this);
										break;
								case 'compound':
										impl = new CollisionCompoundSystemImpl(this);
										break;
						}
						this.implementations[type] = impl;
				}
				return this.implementations[type];
		}
		_getImplementation(entity) {
				return this.implementations[entity.collision.data.type];
		}
		cloneComponent(entity, clone) {
				return this._getImplementation(entity).clone(entity, clone);
		}
		onBeforeRemove(entity, component) {
				this.implementations[component.data.type].beforeRemove(entity, component);
				component.onBeforeRemove();
		}
		onRemove(entity, data) {
				this.implementations[data.type].remove(entity, data);
		}
		updateCompoundChildTransform(entity, forceUpdate) {
				var parentComponent = entity.collision._compoundParent;
				if (parentComponent === entity.collision) return;
				if (entity.enabled && entity.collision.enabled && (entity._dirtyLocal || forceUpdate)) {
						var transform = this._getNodeTransform(entity, parentComponent.entity);
						var idx = parentComponent.getCompoundChildShapeIndex(entity.collision.shape);
						if (idx === null) {
								parentComponent.shape.addChildShape(transform, entity.collision.data.shape);
						} else {
								parentComponent.shape.updateChildTransform(idx, transform, true);
						}
						Ammo.destroy(transform);
				}
		}
		_removeCompoundChild(collision, shape) {
				if (collision.shape.getNumChildShapes() === 0) {
						return;
				}
				if (collision.shape.removeChildShape) {
						collision.shape.removeChildShape(shape);
				} else {
						var ind = collision.getCompoundChildShapeIndex(shape);
						if (ind !== null) {
								collision.shape.removeChildShapeByIndex(ind);
						}
				}
		}
		onTransformChanged(component, position, rotation, scale) {
				this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
		}
		changeType(component, previousType, newType) {
				this.implementations[previousType].beforeRemove(component.entity, component);
				this.implementations[previousType].remove(component.entity, component.data);
				this._createImplementation(newType).reset(component, component.data);
		}
		recreatePhysicalShapes(component) {
				this.implementations[component.data.type].recreatePhysicalShapes(component);
		}
		_calculateNodeRelativeTransform(node, relative) {
				if (node === relative) {
						var scale = node.getWorldTransform().getScale();
						mat4.setScale(scale.x, scale.y, scale.z);
				} else {
						this._calculateNodeRelativeTransform(node.parent, relative);
						mat4.mul(node.getLocalTransform());
				}
		}
		_getNodeScaling(node) {
				var wtm = node.getWorldTransform();
				var scl = wtm.getScale();
				return new Ammo.btVector3(scl.x, scl.y, scl.z);
		}
		_getNodeTransform(node, relative) {
				var pos, rot;
				if (relative) {
						this._calculateNodeRelativeTransform(node, relative);
						pos = p1;
						rot = quat$1;
						mat4.getTranslation(pos);
						rot.setFromMat4(mat4);
				} else {
						pos = node.getPosition();
						rot = node.getRotation();
				}
				var ammoQuat = new Ammo.btQuaternion();
				var transform = new Ammo.btTransform();
				transform.setIdentity();
				var origin = transform.getOrigin();
				var component = node.collision;
				if (component && component._hasOffset) {
						var lo = component.data.linearOffset;
						var ao = component.data.angularOffset;
						var newOrigin = p2;
						quat$1.copy(rot).transformVector(lo, newOrigin);
						newOrigin.add(pos);
						quat$1.copy(rot).mul(ao);
						origin.setValue(newOrigin.x, newOrigin.y, newOrigin.z);
						ammoQuat.setValue(quat$1.x, quat$1.y, quat$1.z, quat$1.w);
				} else {
						origin.setValue(pos.x, pos.y, pos.z);
						ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
				}
				transform.setRotation(ammoQuat);
				Ammo.destroy(ammoQuat);
				return transform;
		}
		destroy() {
				for(var key in this._triMeshCache){
						Ammo.destroy(this._triMeshCache[key]);
				}
				this._triMeshCache = null;
				super.destroy();
		}
		constructor(app){
				super(app);
				this.id = 'collision';
				this.ComponentType = CollisionComponent;
				this.DataType = CollisionComponentData;
				this.schema = _schema$g;
				this.implementations = {};
				this._triMeshCache = {};
				this.on('beforeremove', this.onBeforeRemove, this);
				this.on('remove', this.onRemove, this);
		}
}

var _tempColor$2 = new Color();
var _vertexFormatDeviceCache = new DeviceCache();
class ImageRenderable {
		destroy() {
				var _this_meshInstance, _this_unmaskMeshInstance;
				this.setMaterial(null);
				this._element.removeModelFromLayers(this.model);
				this.model.destroy();
				this.model = null;
				this.node = null;
				this.mesh = null;
				(_this_meshInstance = this.meshInstance) == null ? void 0 : _this_meshInstance.destroy();
				this.meshInstance = null;
				(_this_unmaskMeshInstance = this.unmaskMeshInstance) == null ? void 0 : _this_unmaskMeshInstance.destroy();
				this.unmaskMeshInstance = null;
				this._entity = null;
				this._element = null;
		}
		setMesh(mesh) {
				if (!this.meshInstance) return;
				this.mesh = mesh;
				this.meshInstance.mesh = mesh;
				this.meshInstance.visible = !!mesh;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.mesh = mesh;
				}
				this.forceUpdateAabb();
		}
		setMask(mask) {
				if (!this.meshInstance) return;
				if (this._entity.enabled && this._element.enabled) {
						this._element.removeModelFromLayers(this.model);
				}
				if (mask) {
						this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
						this.unmaskMeshInstance.name = "Unmask: " + this._entity.name;
						this.unmaskMeshInstance.castShadow = false;
						this.unmaskMeshInstance.receiveShadow = false;
						this.unmaskMeshInstance.pick = false;
						this.model.meshInstances.push(this.unmaskMeshInstance);
						for(var name in this.meshInstance.parameters){
								this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
						}
				} else {
						var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
						if (idx >= 0) {
								this.model.meshInstances.splice(idx, 1);
						}
				}
				if (this._entity.enabled && this._element.enabled) {
						this._element.addModelToLayers(this.model);
				}
				if (!mask) {
						var _this_unmaskMeshInstance;
						(_this_unmaskMeshInstance = this.unmaskMeshInstance) == null ? void 0 : _this_unmaskMeshInstance.destroy();
						this.unmaskMeshInstance = null;
				}
		}
		setMaterial(material) {
				if (!this.meshInstance) return;
				this.meshInstance.material = material;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.material = material;
				}
		}
		setParameter(name, value) {
				if (!this.meshInstance) return;
				this.meshInstance.setParameter(name, value);
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.setParameter(name, value);
				}
		}
		deleteParameter(name) {
				if (!this.meshInstance) return;
				this.meshInstance.deleteParameter(name);
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.deleteParameter(name);
				}
		}
		setUnmaskDrawOrder() {
				if (!this.meshInstance) return;
				var getLastChild = function getLastChild1(e) {
						var last;
						var c = e.children;
						var l = c.length;
						if (l) {
								for(var i = 0; i < l; i++){
										if (c[i].element) {
												last = c[i];
										}
								}
								if (!last) return null;
								var child = getLastChild(last);
								if (child) {
										return child;
								}
								return last;
						}
						return null;
				};
				if (this.unmaskMeshInstance) {
						var lastChild = getLastChild(this._entity);
						if (lastChild && lastChild.element) {
								this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
						} else {
								this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
						}
				}
		}
		setDrawOrder(drawOrder) {
				if (!this.meshInstance) {
						return;
				}
				this.meshInstance.drawOrder = drawOrder;
		}
		setCull(cull) {
				if (!this.meshInstance) return;
				var element = this._element;
				var visibleFn = null;
				if (cull && element._isScreenSpace()) {
						visibleFn = function visibleFn(camera) {
								return element.isVisibleForCamera(camera);
						};
				}
				this.meshInstance.cull = cull;
				this.meshInstance.isVisibleFunc = visibleFn;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.cull = cull;
						this.unmaskMeshInstance.isVisibleFunc = visibleFn;
				}
		}
		setScreenSpace(screenSpace) {
				if (!this.meshInstance) return;
				this.meshInstance.screenSpace = screenSpace;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.screenSpace = screenSpace;
				}
		}
		setLayer(layer) {
				if (!this.meshInstance) return;
				this.meshInstance.layer = layer;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance.layer = layer;
				}
		}
		forceUpdateAabb(mask) {
				if (!this.meshInstance) return;
				this.meshInstance._aabbVer = -1;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance._aabbVer = -1;
				}
		}
		setAabbFunc(fn) {
				if (!this.meshInstance) return;
				this.meshInstance._updateAabbFunc = fn;
				if (this.unmaskMeshInstance) {
						this.unmaskMeshInstance._updateAabbFunc = fn;
				}
		}
		constructor(entity, mesh, material){
				this._entity = entity;
				this._element = entity.element;
				this.model = new Model();
				this.node = new GraphNode();
				this.model.graph = this.node;
				this.mesh = mesh;
				this.meshInstance = new MeshInstance(this.mesh, material, this.node);
				this.meshInstance.name = "ImageElement: " + entity.name;
				this.meshInstance.castShadow = false;
				this.meshInstance.receiveShadow = false;
				this._meshDirty = false;
				this.model.meshInstances.push(this.meshInstance);
				this._entity.addChild(this.model.graph);
				this.model._entity = this._entity;
				this.unmaskMeshInstance = null;
		}
}
class ImageElement {
		destroy() {
				this.textureAsset = null;
				this.spriteAsset = null;
				this.materialAsset = null;
				this._renderable.setMesh(this._defaultMesh);
				this._renderable.destroy();
				this._defaultMesh = null;
				this._element.off('resize', this._onParentResizeOrPivotChange, this);
				this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);
				this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
				this._element.off('set:screen', this._onScreenChange, this);
				this._element.off('set:draworder', this._onDrawOrderChange, this);
				this._element.off('screen:set:resolution', this._onResolutionChange, this);
		}
		_onResolutionChange(res) {}
		_onParentResizeOrPivotChange() {
				if (this._renderable.mesh) {
						this._updateMesh(this._renderable.mesh);
				}
		}
		_onScreenSpaceChange(value) {
				this._updateMaterial(value);
		}
		_onScreenChange(screen, previous) {
				if (screen) {
						this._updateMaterial(screen.screen.screenSpace);
				} else {
						this._updateMaterial(false);
				}
		}
		_onDrawOrderChange(order) {
				this._renderable.setDrawOrder(order);
				if (this.mask && this._element.screen) {
						this._element.screen.screen.once('syncdraworder', function() {
								this._renderable.setUnmaskDrawOrder();
						}, this);
				}
		}
		_hasUserMaterial() {
				return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
		}
		_use9Slicing() {
				return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
		}
		_updateMaterial(screenSpace) {
				var mask = !!this._mask;
				var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
				var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
				if (!this._hasUserMaterial()) {
						this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
				}
				if (this._renderable) {
						this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());
						this._renderable.setMaterial(this._material);
						this._renderable.setScreenSpace(screenSpace);
						this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
				}
		}
		_createMesh() {
				var element = this._element;
				var w = element.calculatedWidth;
				var h = element.calculatedHeight;
				var r = this._rect;
				var device = this._system.app.graphicsDevice;
				var vertexData = new Float32Array([
						w,
						0,
						0,
						0,
						0,
						1,
						r.x + r.z,
						1.0 - r.y,
						w,
						h,
						0,
						0,
						0,
						1,
						r.x + r.z,
						1.0 - (r.y + r.w),
						0,
						0,
						0,
						0,
						0,
						1,
						r.x,
						1.0 - r.y,
						0,
						h,
						0,
						0,
						0,
						1,
						r.x,
						1.0 - (r.y + r.w)
				]);
				var vertexFormat = _vertexFormatDeviceCache.get(device, ()=>{
						return new VertexFormat(device, [
								{
										semantic: SEMANTIC_POSITION,
										components: 3,
										type: TYPE_FLOAT32
								},
								{
										semantic: SEMANTIC_NORMAL,
										components: 3,
										type: TYPE_FLOAT32
								},
								{
										semantic: SEMANTIC_TEXCOORD0,
										components: 2,
										type: TYPE_FLOAT32
								}
						]);
				});
				var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, {
						data: vertexData.buffer
				});
				var mesh = new Mesh(device);
				mesh.vertexBuffer = vertexBuffer;
				mesh.primitive[0].type = PRIMITIVE_TRISTRIP;
				mesh.primitive[0].base = 0;
				mesh.primitive[0].count = 4;
				mesh.primitive[0].indexed = false;
				mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));
				this._updateMesh(mesh);
				return mesh;
		}
		_updateMesh(mesh) {
				var element = this._element;
				var w = element.calculatedWidth;
				var h = element.calculatedHeight;
				if (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {
						var actualRatio = element.calculatedWidth / element.calculatedHeight;
						if (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {
								w = element.calculatedHeight * this._targetAspectRatio;
						} else {
								h = element.calculatedWidth / this._targetAspectRatio;
						}
				}
				var screenSpace = element._isScreenSpace();
				this._updateMaterial(screenSpace);
				if (this._renderable) this._renderable.forceUpdateAabb();
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
						var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
						var borderWidthScale = 2 / frameData.rect.z;
						var borderHeightScale = 2 / frameData.rect.w;
						this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
						var tex = this.sprite.atlas.texture;
						this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
						var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
						var scaleMulX = frameData.rect.z / ppu;
						var scaleMulY = frameData.rect.w / ppu;
						this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));
						var scaleX = scaleMulX;
						var scaleY = scaleMulY;
						this._outerScale.x /= scaleMulX;
						this._outerScale.y /= scaleMulY;
						scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
						scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);
						if (this._renderable) {
								this._innerOffsetUniform[0] = this._innerOffset.x;
								this._innerOffsetUniform[1] = this._innerOffset.y;
								this._innerOffsetUniform[2] = this._innerOffset.z;
								this._innerOffsetUniform[3] = this._innerOffset.w;
								this._renderable.setParameter('innerOffset', this._innerOffsetUniform);
								this._atlasRectUniform[0] = this._atlasRect.x;
								this._atlasRectUniform[1] = this._atlasRect.y;
								this._atlasRectUniform[2] = this._atlasRect.z;
								this._atlasRectUniform[3] = this._atlasRect.w;
								this._renderable.setParameter('atlasRect', this._atlasRectUniform);
								this._outerScaleUniform[0] = this._outerScale.x;
								this._outerScaleUniform[1] = this._outerScale.y;
								this._renderable.setParameter('outerScale', this._outerScaleUniform);
								this._renderable.setAabbFunc(this._updateAabbFunc);
								this._renderable.node.setLocalScale(scaleX, scaleY, 1);
								this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
						}
				} else {
						var vb = mesh.vertexBuffer;
						var vertexDataF32 = new Float32Array(vb.lock());
						var hp = element.pivot.x;
						var vp = element.pivot.y;
						vertexDataF32[0] = w - hp * w;
						vertexDataF32[1] = 0 - vp * h;
						vertexDataF32[8] = w - hp * w;
						vertexDataF32[9] = h - vp * h;
						vertexDataF32[16] = 0 - hp * w;
						vertexDataF32[17] = 0 - vp * h;
						vertexDataF32[24] = 0 - hp * w;
						vertexDataF32[25] = h - vp * h;
						var atlasTextureWidth = 1;
						var atlasTextureHeight = 1;
						var rect = this._rect;
						if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
								var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
								if (frame) {
										rect = frame.rect;
										atlasTextureWidth = this._sprite.atlas.texture.width;
										atlasTextureHeight = this._sprite.atlas.texture.height;
								}
						}
						vertexDataF32[6] = (rect.x + rect.z) / atlasTextureWidth;
						vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
						vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
						vertexDataF32[15] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
						vertexDataF32[22] = rect.x / atlasTextureWidth;
						vertexDataF32[23] = 1.0 - rect.y / atlasTextureHeight;
						vertexDataF32[30] = rect.x / atlasTextureWidth;
						vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
						vb.unlock();
						var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
						var max = new Vec3(w - hp * w, h - vp * h, 0);
						mesh.aabb.setMinMax(min, max);
						if (this._renderable) {
								this._renderable.node.setLocalScale(1, 1, 1);
								this._renderable.node.setLocalPosition(0, 0, 0);
								this._renderable.setAabbFunc(null);
						}
				}
				this._meshDirty = false;
		}
		_updateSprite() {
				var nineSlice = false;
				var mesh = null;
				this._targetAspectRatio = -1;
				if (this._sprite && this._sprite.atlas) {
						mesh = this._sprite.meshes[this.spriteFrame];
						nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
						var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
						if ((frameData == null ? void 0 : frameData.rect.w) > 0) {
								this._targetAspectRatio = frameData.rect.z / frameData.rect.w;
						}
				}
				this.mesh = nineSlice ? mesh : this._defaultMesh;
				this.refreshMesh();
		}
		refreshMesh() {
				if (this.mesh) {
						if (!this._element._beingInitialized) {
								this._updateMesh(this.mesh);
						} else {
								this._meshDirty = true;
						}
				}
		}
		_updateAabb(aabb) {
				aabb.center.set(0, 0, 0);
				aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
				aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
				return aabb;
		}
		_toggleMask() {
				this._element._dirtifyMask();
				var screenSpace = this._element._isScreenSpace();
				this._updateMaterial(screenSpace);
				this._renderable.setMask(!!this._mask);
		}
		_onMaterialLoad(asset) {
				this.material = asset.resource;
		}
		_onMaterialAdded(asset) {
				this._system.app.assets.off("add:" + asset.id, this._onMaterialAdded, this);
				if (this._materialAsset === asset.id) {
						this._bindMaterialAsset(asset);
				}
		}
		_bindMaterialAsset(asset) {
				if (!this._entity.enabled) return;
				asset.on('load', this._onMaterialLoad, this);
				asset.on('change', this._onMaterialChange, this);
				asset.on('remove', this._onMaterialRemove, this);
				if (asset.resource) {
						this._onMaterialLoad(asset);
				} else {
						this._system.app.assets.load(asset);
				}
		}
		_unbindMaterialAsset(asset) {
				asset.off('load', this._onMaterialLoad, this);
				asset.off('change', this._onMaterialChange, this);
				asset.off('remove', this._onMaterialRemove, this);
		}
		_onMaterialChange() {}
		_onMaterialRemove() {}
		_onTextureAdded(asset) {
				this._system.app.assets.off("add:" + asset.id, this._onTextureAdded, this);
				if (this._textureAsset === asset.id) {
						this._bindTextureAsset(asset);
				}
		}
		_bindTextureAsset(asset) {
				if (!this._entity.enabled) return;
				asset.on('load', this._onTextureLoad, this);
				asset.on('change', this._onTextureChange, this);
				asset.on('remove', this._onTextureRemove, this);
				if (asset.resource) {
						this._onTextureLoad(asset);
				} else {
						this._system.app.assets.load(asset);
				}
		}
		_unbindTextureAsset(asset) {
				asset.off('load', this._onTextureLoad, this);
				asset.off('change', this._onTextureChange, this);
				asset.off('remove', this._onTextureRemove, this);
		}
		_onTextureLoad(asset) {
				this.texture = asset.resource;
		}
		_onTextureChange(asset) {}
		_onTextureRemove(asset) {}
		_onSpriteAssetAdded(asset) {
				this._system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
				if (this._spriteAsset === asset.id) {
						this._bindSpriteAsset(asset);
				}
		}
		_bindSpriteAsset(asset) {
				if (!this._entity.enabled) return;
				asset.on('load', this._onSpriteAssetLoad, this);
				asset.on('change', this._onSpriteAssetChange, this);
				asset.on('remove', this._onSpriteAssetRemove, this);
				if (asset.resource) {
						this._onSpriteAssetLoad(asset);
				} else {
						this._system.app.assets.load(asset);
				}
		}
		_unbindSpriteAsset(asset) {
				asset.off('load', this._onSpriteAssetLoad, this);
				asset.off('change', this._onSpriteAssetChange, this);
				asset.off('remove', this._onSpriteAssetRemove, this);
				if (asset.data.textureAtlasAsset) {
						this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
				}
		}
		_onSpriteAssetLoad(asset) {
				if (!asset || !asset.resource) {
						this.sprite = null;
				} else {
						if (!asset.resource.atlas) {
								var atlasAssetId = asset.data.textureAtlasAsset;
								if (atlasAssetId) {
										var assets = this._system.app.assets;
										assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
										assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
								}
						} else {
								this.sprite = asset.resource;
						}
				}
		}
		_onSpriteAssetChange(asset) {
				this._onSpriteAssetLoad(asset);
		}
		_onSpriteAssetRemove(asset) {}
		_bindSprite(sprite) {
				this._evtSetMeshes = sprite.on('set:meshes', this._onSpriteMeshesChange, this);
				sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
				sprite.on('set:atlas', this._onAtlasTextureChange, this);
				if (sprite.atlas) {
						sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
				}
		}
		_unbindSprite(sprite) {
				var _this__evtSetMeshes;
				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
				this._evtSetMeshes = null;
				sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
				sprite.off('set:atlas', this._onAtlasTextureChange, this);
				if (sprite.atlas) {
						sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
				}
		}
		_onSpriteMeshesChange() {
				if (this._sprite) {
						this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
				}
				this._updateSprite();
		}
		_onSpritePpuChange() {
				if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
						this._updateSprite();
				}
		}
		_onAtlasTextureChange() {
				if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
						this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
						this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
				} else {
						this._renderable.deleteParameter('texture_emissiveMap');
						this._renderable.deleteParameter('texture_opacityMap');
				}
		}
		_onTextureAtlasLoad(atlasAsset) {
				var spriteAsset = this._spriteAsset;
				if (spriteAsset instanceof Asset) {
						this._onSpriteAssetLoad(spriteAsset);
				} else {
						this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
				}
		}
		onEnable() {
				if (this._materialAsset) {
						var asset = this._system.app.assets.get(this._materialAsset);
						if (asset && asset.resource !== this._material) {
								this._bindMaterialAsset(asset);
						}
				}
				if (this._textureAsset) {
						var asset1 = this._system.app.assets.get(this._textureAsset);
						if (asset1 && asset1.resource !== this._texture) {
								this._bindTextureAsset(asset1);
						}
				}
				if (this._spriteAsset) {
						var asset2 = this._system.app.assets.get(this._spriteAsset);
						if (asset2 && asset2.resource !== this._sprite) {
								this._bindSpriteAsset(asset2);
						}
				}
				this._element.addModelToLayers(this._renderable.model);
		}
		onDisable() {
				this._element.removeModelFromLayers(this._renderable.model);
		}
		_setStencil(stencilParams) {
				this._renderable.meshInstance.stencilFront = stencilParams;
				this._renderable.meshInstance.stencilBack = stencilParams;
				var ref = 0;
				if (this._element.maskedBy) {
						ref = this._element.maskedBy.element._image._maskRef;
				}
				if (this._renderable.unmaskMeshInstance) {
						var sp = new StencilParameters({
								ref: ref + 1,
								func: FUNC_EQUAL,
								zpass: STENCILOP_DECREMENT
						});
						this._renderable.unmaskMeshInstance.stencilFront = sp;
						this._renderable.unmaskMeshInstance.stencilBack = sp;
				}
		}
		_updateRenderableEmissive() {
				_tempColor$2.linear(this._color);
				this._colorUniform[0] = _tempColor$2.r;
				this._colorUniform[1] = _tempColor$2.g;
				this._colorUniform[2] = _tempColor$2.b;
				this._renderable.setParameter('material_emissive', this._colorUniform);
		}
		set color(value) {
				var { r, g, b } = value;
				if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
						this._color.r = r;
						this._color.g = g;
						this._color.b = b;
						this._updateRenderableEmissive();
				}
				if (this._element) {
						this._element.fire('set:color', this._color);
				}
		}
		get color() {
				return this._color;
		}
		set opacity(value) {
				if (value !== this._color.a) {
						this._color.a = value;
						this._renderable.setParameter('material_opacity', value);
				}
				if (this._element) {
						this._element.fire('set:opacity', value);
				}
		}
		get opacity() {
				return this._color.a;
		}
		set rect(value) {
				var x, y, z, w;
				if (value instanceof Vec4) {
						x = value.x;
						y = value.y;
						z = value.z;
						w = value.w;
				} else {
						x = value[0];
						y = value[1];
						z = value[2];
						w = value[3];
				}
				if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
						return;
				}
				this._rect.set(x, y, z, w);
				if (this._renderable.mesh) {
						if (!this._element._beingInitialized) {
								this._updateMesh(this._renderable.mesh);
						} else {
								this._meshDirty = true;
						}
				}
		}
		get rect() {
				return this._rect;
		}
		_removeMaterialAssetEvents() {
				if (this._materialAsset) {
						var assets = this._system.app.assets;
						assets.off("add:" + this._materialAsset, this._onMaterialAdded, this);
						var asset = assets.get(this._materialAsset);
						if (asset) {
								asset.off('load', this._onMaterialLoad, this);
								asset.off('change', this._onMaterialChange, this);
								asset.off('remove', this._onMaterialRemove, this);
						}
				}
		}
		set material(value) {
				if (this._material === value) return;
				if (!value) {
						var screenSpace = this._element._isScreenSpace();
						if (this.mask) {
								value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
						} else {
								value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
						}
				}
				this._material = value;
				if (this._materialAsset) {
						var asset = this._system.app.assets.get(this._materialAsset);
						if (!asset || asset.resource !== value) {
								this._removeMaterialAssetEvents();
								this._materialAsset = null;
						}
				}
				if (value) {
						this._renderable.setMaterial(value);
						if (this._hasUserMaterial()) {
								this._renderable.deleteParameter('material_opacity');
								this._renderable.deleteParameter('material_emissive');
						} else {
								this._updateRenderableEmissive();
								this._renderable.setParameter('material_opacity', this._color.a);
						}
				}
		}
		get material() {
				return this._material;
		}
		set materialAsset(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
						_id = value.id;
				}
				if (this._materialAsset !== _id) {
						this._removeMaterialAssetEvents();
						this._materialAsset = _id;
						if (this._materialAsset) {
								var asset = assets.get(this._materialAsset);
								if (!asset) {
										this._materialAsset = null;
										this.material = null;
										this._materialAsset = _id;
										assets.on("add:" + this._materialAsset, this._onMaterialAdded, this);
								} else {
										this._bindMaterialAsset(asset);
								}
						} else {
								this._materialAsset = null;
								this.material = null;
								this._materialAsset = _id;
						}
				}
		}
		get materialAsset() {
				return this._materialAsset;
		}
		set texture(value) {
				if (this._texture === value) return;
				if (this._textureAsset) {
						var textureAsset = this._system.app.assets.get(this._textureAsset);
						if (textureAsset && textureAsset.resource !== value) {
								this.textureAsset = null;
						}
				}
				this._texture = value;
				if (value) {
						if (this._spriteAsset) {
								this.spriteAsset = null;
						}
						this._renderable.setParameter('texture_emissiveMap', this._texture);
						this._renderable.setParameter('texture_opacityMap', this._texture);
						this._updateRenderableEmissive();
						this._renderable.setParameter('material_opacity', this._color.a);
						var newAspectRatio = this._texture.width / this._texture.height;
						if (newAspectRatio !== this._targetAspectRatio) {
								this._targetAspectRatio = newAspectRatio;
								if (this._element.fitMode !== FITMODE_STRETCH) {
										this.refreshMesh();
								}
						}
				} else {
						this._renderable.deleteParameter('texture_emissiveMap');
						this._renderable.deleteParameter('texture_opacityMap');
						this._targetAspectRatio = -1;
						if (this._element.fitMode !== FITMODE_STRETCH) {
								this.refreshMesh();
						}
				}
		}
		get texture() {
				return this._texture;
		}
		set textureAsset(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
						_id = value.id;
				}
				if (this._textureAsset !== _id) {
						if (this._textureAsset) {
								assets.off("add:" + this._textureAsset, this._onTextureAdded, this);
								var _prev = assets.get(this._textureAsset);
								if (_prev) {
										_prev.off('load', this._onTextureLoad, this);
										_prev.off('change', this._onTextureChange, this);
										_prev.off('remove', this._onTextureRemove, this);
								}
						}
						this._textureAsset = _id;
						if (this._textureAsset) {
								var asset = assets.get(this._textureAsset);
								if (!asset) {
										this.texture = null;
										assets.on("add:" + this._textureAsset, this._onTextureAdded, this);
								} else {
										this._bindTextureAsset(asset);
								}
						} else {
								this.texture = null;
						}
				}
		}
		get textureAsset() {
				return this._textureAsset;
		}
		set spriteAsset(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
						_id = value.id;
				}
				if (this._spriteAsset !== _id) {
						if (this._spriteAsset) {
								assets.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
								var _prev = assets.get(this._spriteAsset);
								if (_prev) {
										this._unbindSpriteAsset(_prev);
								}
						}
						this._spriteAsset = _id;
						if (this._spriteAsset) {
								var asset = assets.get(this._spriteAsset);
								if (!asset) {
										this.sprite = null;
										assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
								} else {
										this._bindSpriteAsset(asset);
								}
						} else {
								this.sprite = null;
						}
				}
				if (this._element) {
						this._element.fire('set:spriteAsset', _id);
				}
		}
		get spriteAsset() {
				return this._spriteAsset;
		}
		set sprite(value) {
				if (this._sprite === value) return;
				if (this._sprite) {
						this._unbindSprite(this._sprite);
				}
				if (this._spriteAsset) {
						var spriteAsset = this._system.app.assets.get(this._spriteAsset);
						if (spriteAsset && spriteAsset.resource !== value) {
								this.spriteAsset = null;
						}
				}
				this._sprite = value;
				if (this._sprite) {
						this._bindSprite(this._sprite);
						if (this._textureAsset) {
								this.textureAsset = null;
						}
				}
				if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
						this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
						this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
				} else {
						this._renderable.deleteParameter('texture_emissiveMap');
						this._renderable.deleteParameter('texture_opacityMap');
				}
				if (this._sprite) {
						this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
				}
				this._updateSprite();
		}
		get sprite() {
				return this._sprite;
		}
		set spriteFrame(value) {
				var oldValue = this._spriteFrame;
				if (this._sprite) {
						this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
				} else {
						this._spriteFrame = value;
				}
				if (this._spriteFrame !== oldValue) {
						this._updateSprite();
				}
				if (this._element) {
						this._element.fire('set:spriteFrame', value);
				}
		}
		get spriteFrame() {
				return this._spriteFrame;
		}
		set mesh(value) {
				this._renderable.setMesh(value);
				if (this._defaultMesh === value) {
						this._renderable.setAabbFunc(null);
				} else {
						this._renderable.setAabbFunc(this._updateAabbFunc);
				}
		}
		get mesh() {
				return this._renderable.mesh;
		}
		set mask(value) {
				if (this._mask !== value) {
						this._mask = value;
						this._toggleMask();
				}
		}
		get mask() {
				return this._mask;
		}
		set pixelsPerUnit(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
						this._updateSprite();
				}
		}
		get pixelsPerUnit() {
				return this._pixelsPerUnit;
		}
		get aabb() {
				if (this._renderable.meshInstance) {
						return this._renderable.meshInstance.aabb;
				}
				return null;
		}
		constructor(element){
				this._evtSetMeshes = null;
				this._element = element;
				this._entity = element.entity;
				this._system = element.system;
				this._textureAsset = null;
				this._texture = null;
				this._materialAsset = null;
				this._material = null;
				this._spriteAsset = null;
				this._sprite = null;
				this._spriteFrame = 0;
				this._pixelsPerUnit = null;
				this._targetAspectRatio = -1;
				this._rect = new Vec4(0, 0, 1, 1);
				this._mask = false;
				this._maskRef = 0;
				this._outerScale = new Vec2();
				this._outerScaleUniform = new Float32Array(2);
				this._innerOffset = new Vec4();
				this._innerOffsetUniform = new Float32Array(4);
				this._atlasRect = new Vec4();
				this._atlasRectUniform = new Float32Array(4);
				this._defaultMesh = this._createMesh();
				this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
				this._color = new Color(1, 1, 1, 1);
				this._colorUniform = new Float32Array([
						1,
						1,
						1
				]);
				this._updateRenderableEmissive();
				this._renderable.setParameter('material_opacity', 1);
				this._updateAabbFunc = this._updateAabb.bind(this);
				this._onScreenChange(this._element.screen);
				this._element.on('resize', this._onParentResizeOrPivotChange, this);
				this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);
				this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
				this._element.on('set:screen', this._onScreenChange, this);
				this._element.on('set:draworder', this._onDrawOrderChange, this);
				this._element.on('screen:set:resolution', this._onResolutionChange, this);
		}
}

class LocalizedAsset extends EventHandler {
		set defaultAsset(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._defaultAsset === id) return;
				if (this._defaultAsset) {
						this._unbindDefaultAsset();
				}
				this._defaultAsset = id;
				if (this._defaultAsset) {
						this._bindDefaultAsset();
				}
				this._onSetLocale(this._app.i18n.locale);
		}
		get defaultAsset() {
				return this._defaultAsset;
		}
		set localizedAsset(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._localizedAsset === id) {
						return;
				}
				if (this._localizedAsset) {
						this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this);
						this._unbindLocalizedAsset();
				}
				this._localizedAsset = id;
				if (this._localizedAsset) {
						var asset = this._app.assets.get(this._localizedAsset);
						if (!asset) {
								this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this);
						} else {
								this._bindLocalizedAsset();
						}
				}
		}
		get localizedAsset() {
				return this._localizedAsset;
		}
		set autoLoad(value) {
				if (this._autoLoad === value) return;
				this._autoLoad = value;
				if (this._autoLoad && this._localizedAsset) {
						this._unbindLocalizedAsset();
						this._bindLocalizedAsset();
				}
		}
		get autoLoad() {
				return this._autoLoad;
		}
		set disableLocalization(value) {
				if (this._disableLocalization === value) return;
				this._disableLocalization = value;
				this._onSetLocale(this._app.i18n.locale);
		}
		get disableLocalization() {
				return this._disableLocalization;
		}
		_bindDefaultAsset() {
				var asset = this._app.assets.get(this._defaultAsset);
				if (!asset) {
						this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
				} else {
						this._onDefaultAssetAdd(asset);
				}
		}
		_unbindDefaultAsset() {
				if (!this._defaultAsset) return;
				this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
				var asset = this._app.assets.get(this._defaultAsset);
				if (!asset) return;
				asset.off('add:localized', this._onLocaleAdd, this);
				asset.off('remove:localized', this._onLocaleRemove, this);
				asset.off('remove', this._onDefaultAssetRemove, this);
		}
		_onDefaultAssetAdd(asset) {
				if (this._defaultAsset !== asset.id) return;
				asset.on('add:localized', this._onLocaleAdd, this);
				asset.on('remove:localized', this._onLocaleRemove, this);
				asset.once('remove', this._onDefaultAssetRemove, this);
		}
		_onDefaultAssetRemove(asset) {
				if (this._defaultAsset !== asset.id) return;
				asset.off('add:localized', this._onLocaleAdd, this);
				asset.off('remove:localized', this._onLocaleAdd, this);
				this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
		}
		_bindLocalizedAsset() {
				if (!this._autoLoad) return;
				var asset = this._app.assets.get(this._localizedAsset);
				if (!asset) return;
				asset.on('load', this._onLocalizedAssetLoad, this);
				asset.on('change', this._onLocalizedAssetChange, this);
				asset.on('remove', this._onLocalizedAssetRemove, this);
				if (asset.resource) {
						this._onLocalizedAssetLoad(asset);
				} else {
						this._app.assets.load(asset);
				}
		}
		_unbindLocalizedAsset() {
				var asset = this._app.assets.get(this._localizedAsset);
				if (!asset) return;
				asset.off('load', this._onLocalizedAssetLoad, this);
				asset.off('change', this._onLocalizedAssetChange, this);
				asset.off('remove', this._onLocalizedAssetRemove, this);
		}
		_onLocalizedAssetAdd(asset) {
				if (this._localizedAsset !== asset.id) return;
				this._bindLocalizedAsset();
		}
		_onLocalizedAssetLoad(asset) {
				this.fire('load', asset);
		}
		_onLocalizedAssetChange(asset, name, newValue, oldValue) {
				this.fire('change', asset, name, newValue, oldValue);
		}
		_onLocalizedAssetRemove(asset) {
				if (this._localizedAsset === asset.id) {
						this.localizedAsset = this._defaultAsset;
				}
				this.fire('remove', asset);
		}
		_onLocaleAdd(locale, assetId) {
				if (this._app.i18n.locale !== locale) return;
				this._onSetLocale(locale);
		}
		_onLocaleRemove(locale, assetId) {
				if (this._app.i18n.locale !== locale) return;
				this._onSetLocale(locale);
		}
		_onSetLocale(locale) {
				if (!this._defaultAsset) {
						this.localizedAsset = null;
						return;
				}
				var asset = this._app.assets.get(this._defaultAsset);
				if (!asset || this._disableLocalization) {
						this.localizedAsset = this._defaultAsset;
						return;
				}
				var localizedAssetId = asset.getLocalizedAssetId(locale);
				if (!localizedAssetId) {
						this.localizedAsset = this._defaultAsset;
						return;
				}
				this.localizedAsset = localizedAssetId;
		}
		destroy() {
				this.defaultAsset = null;
				this._app.i18n.off('set:locale', this._onSetLocale, this);
				this.off();
		}
		constructor(app){
				super();
				this._app = app;
				app.i18n.on('set:locale', this._onSetLocale, this);
				this._autoLoad = false;
				this._disableLocalization = false;
				this._defaultAsset = null;
				this._localizedAsset = null;
		}
}

var FONT_MSDF = 'msdf';
var FONT_BITMAP = 'bitmap';

var EOF_TOKEN = 0;
var ERROR_TOKEN = 1;
var TEXT_TOKEN = 2;
var OPEN_BRACKET_TOKEN = 3;
var CLOSE_BRACKET_TOKEN = 4;
var EQUALS_TOKEN = 5;
var STRING_TOKEN = 6;
var IDENTIFIER_TOKEN = 7;
var WHITESPACE_TOKEN = 8;
var WHITESPACE_CHARS = ' \t\n\r\v\f';
var IDENTIFIER_REGEX = /[\w|/]/;
class Scanner {
		read() {
				var token = this._read();
				while(token === WHITESPACE_TOKEN){
						token = this._read();
				}
				if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
						this._last = this._index;
				}
				return token;
		}
		buf() {
				return this._buf;
		}
		last() {
				return this._last;
		}
		error() {
				return this._error;
		}
		debugPrint() {
				var tokenStrings = [
						'EOF',
						'ERROR',
						'TEXT',
						'OPEN_BRACKET',
						'CLOSE_BRACKET',
						'EQUALS',
						'STRING',
						'IDENTIFIER',
						'WHITESPACE'
				];
				var token = this.read();
				var result = '';
				while(true){
						result += (result.length > 0 ? '\n' : '') + tokenStrings[token] + " '" + this.buf().join('') + "'";
						if (token === EOF_TOKEN || token === ERROR_TOKEN) {
								break;
						}
						token = this.read();
				}
				return result;
		}
		_read() {
				this._buf = [];
				if (this._eof()) {
						return EOF_TOKEN;
				}
				return this._mode === 'text' ? this._text() : this._tag();
		}
		_text() {
				while(true){
						switch(this._cur){
								case null:
										return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;
								case '[':
										this._mode = 'tag';
										return this._buf.length > 0 ? TEXT_TOKEN : this._tag();
								case '\\':
										this._next();
										switch(this._cur){
												case '[':
														this._store();
														break;
												default:
														this._output('\\');
														break;
										}
										break;
								default:
										this._store();
										break;
						}
				}
		}
		_tag() {
				switch(this._cur){
						case null:
								this._error = 'unexpected end of input reading tag';
								return ERROR_TOKEN;
						case '[':
								this._store();
								return OPEN_BRACKET_TOKEN;
						case ']':
								this._store();
								this._mode = 'text';
								return CLOSE_BRACKET_TOKEN;
						case '=':
								this._store();
								return EQUALS_TOKEN;
						case ' ':
						case '\t':
						case '\n':
						case '\r':
						case '\v':
						case '\f':
								return this._whitespace();
						case '"':
								return this._string();
						default:
								if (!this._isIdentifierSymbol(this._cur)) {
										this._error = 'unrecognized character';
										return ERROR_TOKEN;
								}
								return this._identifier();
				}
		}
		_whitespace() {
				this._store();
				while(WHITESPACE_CHARS.indexOf(this._cur) !== -1){
						this._store();
				}
				return WHITESPACE_TOKEN;
		}
		_string() {
				this._next();
				while(true){
						switch(this._cur){
								case null:
										this._error = 'unexpected end of input reading string';
										return ERROR_TOKEN;
								case '"':
										this._next();
										return STRING_TOKEN;
								default:
										this._store();
										break;
						}
				}
		}
		_identifier() {
				this._store();
				while(this._cur !== null && this._isIdentifierSymbol(this._cur)){
						this._store();
				}
				return IDENTIFIER_TOKEN;
		}
		_isIdentifierSymbol(s) {
				return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
		}
		_eof() {
				return this._cur === null;
		}
		_next() {
				if (!this._eof()) {
						this._index++;
						this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
				}
				return this._cur;
		}
		_store() {
				this._buf.push(this._cur);
				return this._next();
		}
		_output(c) {
				this._buf.push(c);
		}
		constructor(symbols){
				this._symbols = symbols;
				this._index = 0;
				this._last = 0;
				this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
				this._buf = [];
				this._mode = 'text';
				this._error = null;
		}
}
class Parser {
		parse(symbols, tags) {
				while(true){
						var token = this._scanner.read();
						switch(token){
								case EOF_TOKEN:
										return true;
								case ERROR_TOKEN:
										return false;
								case TEXT_TOKEN:
										Array.prototype.push.apply(symbols, this._scanner.buf());
										break;
								case OPEN_BRACKET_TOKEN:
										if (!this._parseTag(symbols, tags)) {
												return false;
										}
										break;
								default:
										return false;
						}
				}
		}
		error() {
				return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
		}
		_parseTag(symbols, tags) {
				var token = this._scanner.read();
				if (token !== IDENTIFIER_TOKEN) {
						this._error = 'expected identifier';
						return false;
				}
				var name = this._scanner.buf().join('');
				if (name[0] === '/') {
						for(var index = tags.length - 1; index >= 0; --index){
								if (name === "/" + tags[index].name && tags[index].end === null) {
										tags[index].end = symbols.length;
										token = this._scanner.read();
										if (token !== CLOSE_BRACKET_TOKEN) {
												this._error = 'expected close bracket';
												return false;
										}
										return true;
								}
						}
						this._error = 'failed to find matching tag';
						return false;
				}
				var tag = {
						name: name,
						value: null,
						attributes: {},
						start: symbols.length,
						end: null
				};
				token = this._scanner.read();
				if (token === EQUALS_TOKEN) {
						token = this._scanner.read();
						if (token !== STRING_TOKEN) {
								this._error = 'expected string';
								return false;
						}
						tag.value = this._scanner.buf().join('');
						token = this._scanner.read();
				}
				while(true){
						switch(token){
								case CLOSE_BRACKET_TOKEN:
										tags.push(tag);
										return true;
								case IDENTIFIER_TOKEN:
										{
												var identifier = this._scanner.buf().join('');
												token = this._scanner.read();
												if (token !== EQUALS_TOKEN) {
														this._error = 'expected equals';
														return false;
												}
												token = this._scanner.read();
												if (token !== STRING_TOKEN) {
														this._error = 'expected string';
														return false;
												}
												var value = this._scanner.buf().join('');
												tag.attributes[identifier] = value;
												break;
										}
								default:
										this._error = 'expected close bracket or identifier';
										return false;
						}
						token = this._scanner.read();
				}
		}
		constructor(symbols){
				this._scanner = new Scanner(symbols);
				this._error = null;
		}
}
function merge(target, source) {
		for(var key in source){
				if (!source.hasOwnProperty(key)) {
						continue;
				}
				var value = source[key];
				if (value instanceof Object) {
						if (!target.hasOwnProperty(key)) {
								target[key] = {};
						}
						merge(target[key], source[key]);
				} else {
						target[key] = value;
				}
		}
}
function combineTags(tags) {
		if (tags.length === 0) {
				return null;
		}
		var result = {};
		for(var index = 0; index < tags.length; ++index){
				var tag = tags[index];
				var tmp = {};
				tmp[tag.name] = {
						value: tag.value,
						attributes: tag.attributes
				};
				merge(result, tmp);
		}
		return result;
}
function resolveMarkupTags(tags, numSymbols) {
		if (tags.length === 0) {
				return null;
		}
		var edges = {};
		for(var index = 0; index < tags.length; ++index){
				var tag = tags[index];
				if (!edges.hasOwnProperty(tag.start)) {
						edges[tag.start] = {
								open: [
										tag
								],
								close: null
						};
				} else {
						if (edges[tag.start].open === null) {
								edges[tag.start].open = [
										tag
								];
						} else {
								edges[tag.start].open.push(tag);
						}
				}
				if (!edges.hasOwnProperty(tag.end)) {
						edges[tag.end] = {
								open: null,
								close: [
										tag
								]
						};
				} else {
						if (edges[tag.end].close === null) {
								edges[tag.end].close = [
										tag
								];
						} else {
								edges[tag.end].close.push(tag);
						}
				}
		}
		var tagStack = [];
		function removeTags(tags) {
				tagStack = tagStack.filter((tag)=>{
						return tags.find((t)=>{
								return t === tag;
						}) === undefined;
				});
		}
		function addTags(tags) {
				for(var index = 0; index < tags.length; ++index){
						tagStack.push(tags[index]);
				}
		}
		var edgeKeys = Object.keys(edges).sort((a, b)=>{
				return a - b;
		});
		var resolvedTags = [];
		for(var index1 = 0; index1 < edgeKeys.length; ++index1){
				var edge = edges[edgeKeys[index1]];
				if (edge.close !== null) {
						removeTags(edge.close);
				}
				if (edge.open !== null) {
						addTags(edge.open);
				}
				resolvedTags.push({
						start: edgeKeys[index1],
						tags: combineTags(tagStack)
				});
		}
		var result = [];
		var prevTag = null;
		for(var index2 = 0; index2 < resolvedTags.length; ++index2){
				var resolvedTag = resolvedTags[index2];
				while(result.length < resolvedTag.start){
						result.push(prevTag ? prevTag.tags : null);
				}
				prevTag = resolvedTag;
		}
		while(result.length < numSymbols){
				result.push(null);
		}
		return result;
}
function evaluateMarkup(symbols) {
		var parser = new Parser(symbols);
		var stripped_symbols = [];
		var tags = [];
		if (!parser.parse(stripped_symbols, tags)) {
				console.warn(parser.error());
				return {
						symbols: symbols,
						tags: null
				};
		}
		var invalidTag = tags.find((t)=>{
				return t.end === null;
		});
		if (invalidTag) {
				console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
				return {
						symbols: symbols,
						tags: null
				};
		}
		var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
		return {
				symbols: stripped_symbols,
				tags: resolved_tags
		};
}
class Markup {
		static evaluate(symbols) {
				return evaluateMarkup(symbols);
		}
}

class MeshInfo {
		constructor(){
				this.count = 0;
				this.quad = 0;
				this.lines = {};
				this.positions = [];
				this.normals = [];
				this.uvs = [];
				this.colors = [];
				this.indices = [];
				this.outlines = [];
				this.shadows = [];
				this.meshInstance = null;
		}
}
function createTextMesh(device, meshInfo) {
		var mesh = new Mesh(device);
		mesh.setPositions(meshInfo.positions);
		mesh.setNormals(meshInfo.normals);
		mesh.setColors32(meshInfo.colors);
		mesh.setUvs(0, meshInfo.uvs);
		mesh.setIndices(meshInfo.indices);
		mesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, TYPE_FLOAT32, false);
		mesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, TYPE_FLOAT32, false);
		mesh.update();
		return mesh;
}
var LINE_BREAK_CHAR = /^[\r\n]$/;
var WHITESPACE_CHAR = /^[ \t]$/;
var WORD_BOUNDARY_CHAR = /^[ \t\-]|\u200b$/;
var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff\ua960-\ua97f]|[\uac00-\ud7ff]$/;
var NO_LINE_BREAK_CJK_CHAR = /^[]$/;
var CONTROL_CHARS = [
		'\u200B',
		'\u061C',
		'\u200E',
		'\u200F',
		'\u202A',
		'\u202B',
		'\u202C',
		'\u202D',
		'\u202E',
		'\u2066',
		'\u2067',
		'\u2068',
		'\u2069'
];
var CONTROL_GLYPH_DATA = {
		width: 0,
		height: 0,
		xadvance: 0,
		xoffset: 0,
		yoffset: 0
};
var colorTmp = new Color();
var vec2Tmp = new Vec2();
var _tempColor$1 = new Color();
class TextElement {
		destroy() {
				this._setMaterial(null);
				if (this._model) {
						this._element.removeModelFromLayers(this._model);
						this._model.destroy();
						this._model = null;
				}
				this._fontAsset.destroy();
				this.font = null;
				this._element.off('resize', this._onParentResize, this);
				this._element.off('set:screen', this._onScreenChange, this);
				this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
				this._element.off('set:draworder', this._onDrawOrderChange, this);
				this._element.off('set:pivot', this._onPivotChange, this);
				this._system.app.i18n.off('set:locale', this._onLocaleSet, this);
				this._system.app.i18n.off('data:add', this._onLocalizationData, this);
				this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
		}
		_onParentResize(width, height) {
				if (this._noResize) return;
				if (this._font) this._updateText();
		}
		_onScreenChange(screen) {
				if (screen) {
						this._updateMaterial(screen.screen.screenSpace);
				} else {
						this._updateMaterial(false);
				}
		}
		_onScreenSpaceChange(value) {
				this._updateMaterial(value);
		}
		_onDrawOrderChange(order) {
				this._drawOrder = order;
				if (this._model) {
						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
								this._model.meshInstances[i].drawOrder = order;
						}
				}
		}
		_onPivotChange(pivot) {
				if (this._font) {
						this._updateText();
				}
		}
		_onLocaleSet(locale) {
				if (!this._i18nKey) return;
				if (this.fontAsset) {
						var asset = this._system.app.assets.get(this.fontAsset);
						if (!asset || !asset.resource || asset.resource !== this._font) {
								this.font = null;
						}
				}
				this._resetLocalizedText();
		}
		_onLocalizationData(locale, messages) {
				if (this._i18nKey && messages[this._i18nKey]) {
						this._resetLocalizedText();
				}
		}
		_resetLocalizedText() {
				this._setText(this._system.app.i18n.getText(this._i18nKey));
		}
		_setText(text) {
				if (this.unicodeConverter) {
						var unicodeConverterFunc = this._system.getUnicodeConverter();
						if (unicodeConverterFunc) {
								text = unicodeConverterFunc(text);
						} else {
								console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
						}
				}
				if (this._text !== text) {
						if (this._font) {
								this._updateText(text);
						}
						this._text = text;
				}
		}
		_updateText(text) {
				var tags;
				if (text === undefined) text = this._text;
				this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);
				if (this._symbols.length === 0) {
						this._symbols = [
								' '
						];
				}
				if (this._enableMarkup) {
						var results = Markup.evaluate(this._symbols);
						this._symbols = results.symbols;
						tags = results.tags || [];
				}
				if (this._rtlReorder) {
						var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
						if (rtlReorderFunc) {
								var results1 = rtlReorderFunc(this._symbols);
								this._rtl = results1.rtl;
								this._symbols = results1.mapping.map(function(v) {
										return this._symbols[v];
								}, this);
								if (tags) {
										tags = results1.mapping.map((v)=>{
												return tags[v];
										});
								}
						} else {
								console.warn('Element created with rtlReorder option but no rtlReorder function registered');
						}
				} else {
						this._rtl = false;
				}
				var getColorThicknessHash = (color, thickness)=>{
						return color.toString(true).toLowerCase() + ":" + thickness.toFixed(2);
				};
				var getColorOffsetHash = (color, offset)=>{
						return color.toString(true).toLowerCase() + ":" + offset.x.toFixed(2) + ":" + offset.y.toFixed(2);
				};
				if (tags) {
						var paletteMap = {};
						var outlinePaletteMap = {};
						var shadowPaletteMap = {};
						this._colorPalette = [
								Math.round(this._color.r * 255),
								Math.round(this._color.g * 255),
								Math.round(this._color.b * 255)
						];
						this._outlinePalette = [
								Math.round(this._outlineColor.r * 255),
								Math.round(this._outlineColor.g * 255),
								Math.round(this._outlineColor.b * 255),
								Math.round(this._outlineColor.a * 255),
								Math.round(this._outlineThickness * 255)
						];
						this._shadowPalette = [
								Math.round(this._shadowColor.r * 255),
								Math.round(this._shadowColor.g * 255),
								Math.round(this._shadowColor.b * 255),
								Math.round(this._shadowColor.a * 255),
								Math.round(this._shadowOffset.x * 127),
								Math.round(this._shadowOffset.y * 127)
						];
						this._symbolColors = [];
						this._symbolOutlineParams = [];
						this._symbolShadowParams = [];
						paletteMap[this._color.toString(false).toLowerCase()] = 0;
						outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;
						shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;
						for(var i = 0, len = this._symbols.length; i < len; ++i){
								var tag = tags[i];
								var color = 0;
								if (tag && tag.color && tag.color.value) {
										var c = tag.color.value;
										if (c.length === 7 && c[0] === '#') {
												var hex = c.substring(1).toLowerCase();
												if (paletteMap.hasOwnProperty(hex)) {
														color = paletteMap[hex];
												} else {
														if (/^[0-9a-f]{6}$/.test(hex)) {
																color = this._colorPalette.length / 3;
																paletteMap[hex] = color;
																this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
																this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
																this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
														}
												}
										}
								}
								this._symbolColors.push(color);
								var outline = 0;
								if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {
										var color1 = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;
										var thickness = Number(tag.outline.attributes.thickness);
										if (Number.isNaN(color1.r) || Number.isNaN(color1.g) || Number.isNaN(color1.b) || Number.isNaN(color1.a)) {
												color1 = this._outlineColor;
										}
										if (Number.isNaN(thickness)) {
												thickness = this._outlineThickness;
										}
										var outlineHash = getColorThicknessHash(color1, thickness);
										if (outlinePaletteMap.hasOwnProperty(outlineHash)) {
												outline = outlinePaletteMap[outlineHash];
										} else {
												outline = this._outlinePalette.length / 5;
												outlinePaletteMap[outlineHash] = outline;
												this._outlinePalette.push(Math.round(color1.r * 255), Math.round(color1.g * 255), Math.round(color1.b * 255), Math.round(color1.a * 255), Math.round(thickness * 255));
										}
								}
								this._symbolOutlineParams.push(outline);
								var shadow = 0;
								if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {
										var color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;
										var off = Number(tag.shadow.attributes.offset);
										var offX = Number(tag.shadow.attributes.offsetX);
										var offY = Number(tag.shadow.attributes.offsetY);
										if (Number.isNaN(color2.r) || Number.isNaN(color2.g) || Number.isNaN(color2.b) || Number.isNaN(color2.a)) {
												color2 = this._shadowColor;
										}
										var offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);
										var shadowHash = getColorOffsetHash(color2, offset);
										if (shadowPaletteMap.hasOwnProperty(shadowHash)) {
												shadow = shadowPaletteMap[shadowHash];
										} else {
												shadow = this._shadowPalette.length / 6;
												shadowPaletteMap[shadowHash] = shadow;
												this._shadowPalette.push(Math.round(color2.r * 255), Math.round(color2.g * 255), Math.round(color2.b * 255), Math.round(color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));
										}
								}
								this._symbolShadowParams.push(shadow);
						}
				} else {
						this._colorPalette = [];
						this._symbolColors = null;
						this._symbolOutlineParams = null;
						this._symbolShadowParams = null;
				}
				this._updateMaterialEmissive();
				this._updateMaterialOutline();
				this._updateMaterialShadow();
				var charactersPerTexture = this._calculateCharsPerTexture();
				var removedModel = false;
				var element = this._element;
				var screenSpace = element._isScreenSpace();
				var screenCulled = element._isScreenCulled();
				var visibleFn = function visibleFn(camera) {
						return element.isVisibleForCamera(camera);
				};
				for(var i1 = 0, len1 = this._meshInfo.length; i1 < len1; i1++){
						var l = charactersPerTexture[i1] || 0;
						var meshInfo = this._meshInfo[i1];
						if (meshInfo.count !== l) {
								if (!removedModel) {
										element.removeModelFromLayers(this._model);
										removedModel = true;
								}
								meshInfo.count = l;
								meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
								meshInfo.indices.length = l * 3 * 2;
								meshInfo.uvs.length = l * 2 * 4;
								meshInfo.colors.length = l * 4 * 4;
								meshInfo.outlines.length = l * 4 * 3;
								meshInfo.shadows.length = l * 4 * 3;
								if (meshInfo.meshInstance) {
										this._removeMeshInstance(meshInfo.meshInstance);
								}
								if (l === 0) {
										meshInfo.meshInstance = null;
										continue;
								}
								for(var v = 0; v < l; v++){
										meshInfo.indices[v * 3 * 2 + 0] = v * 4;
										meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
										meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
										meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
										meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
										meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
										meshInfo.normals[v * 4 * 3 + 0] = 0;
										meshInfo.normals[v * 4 * 3 + 1] = 0;
										meshInfo.normals[v * 4 * 3 + 2] = -1;
										meshInfo.normals[v * 4 * 3 + 3] = 0;
										meshInfo.normals[v * 4 * 3 + 4] = 0;
										meshInfo.normals[v * 4 * 3 + 5] = -1;
										meshInfo.normals[v * 4 * 3 + 6] = 0;
										meshInfo.normals[v * 4 * 3 + 7] = 0;
										meshInfo.normals[v * 4 * 3 + 8] = -1;
										meshInfo.normals[v * 4 * 3 + 9] = 0;
										meshInfo.normals[v * 4 * 3 + 10] = 0;
										meshInfo.normals[v * 4 * 3 + 11] = -1;
								}
								var mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);
								var mi = new MeshInstance(mesh, this._material, this._node);
								mi.name = "Text Element: " + this._entity.name;
								mi.castShadow = false;
								mi.receiveShadow = false;
								mi.cull = !screenSpace;
								mi.screenSpace = screenSpace;
								mi.drawOrder = this._drawOrder;
								if (screenCulled) {
										mi.cull = true;
										mi.isVisibleFunc = visibleFn;
								}
								this._setTextureParams(mi, this._font.textures[i1]);
								mi.setParameter('material_emissive', this._colorUniform);
								mi.setParameter('material_opacity', this._color.a);
								mi.setParameter('font_sdfIntensity', this._font.intensity);
								mi.setParameter('font_pxrange', this._getPxRange(this._font));
								mi.setParameter('font_textureWidth', this._font.data.info.maps[i1].width);
								mi.setParameter('outline_color', this._outlineColorUniform);
								mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
								mi.setParameter('shadow_color', this._shadowColorUniform);
								if (this._symbolShadowParams) {
										this._shadowOffsetUniform[0] = 0;
										this._shadowOffsetUniform[1] = 0;
								} else {
										var ratio = -this._font.data.info.maps[i1].width / this._font.data.info.maps[i1].height;
										this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
										this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
								}
								mi.setParameter('shadow_offset', this._shadowOffsetUniform);
								meshInfo.meshInstance = mi;
								this._model.meshInstances.push(mi);
						}
				}
				if (this._element.maskedBy) {
						this._element._setMaskedBy(this._element.maskedBy);
				}
				if (removedModel && this._element.enabled && this._entity.enabled) {
						this._element.addModelToLayers(this._model);
				}
				this._updateMeshes();
				this._rangeStart = 0;
				this._rangeEnd = this._symbols.length;
				this._updateRenderRange();
		}
		_removeMeshInstance(meshInstance) {
				meshInstance.destroy();
				var idx = this._model.meshInstances.indexOf(meshInstance);
				if (idx !== -1) {
						this._model.meshInstances.splice(idx, 1);
				}
		}
		_setMaterial(material) {
				this._material = material;
				if (this._model) {
						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
								var mi = this._model.meshInstances[i];
								mi.material = material;
						}
				}
		}
		_updateMaterial(screenSpace) {
				var element = this._element;
				var screenCulled = element._isScreenCulled();
				var visibleFn = function visibleFn(camera) {
						return element.isVisibleForCamera(camera);
				};
				var msdf = this._font && this._font.type === FONT_MSDF;
				this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);
				if (this._model) {
						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
								var mi = this._model.meshInstances[i];
								mi.cull = !screenSpace;
								mi.material = this._material;
								mi.screenSpace = screenSpace;
								if (screenCulled) {
										mi.cull = true;
										mi.isVisibleFunc = visibleFn;
								} else {
										mi.isVisibleFunc = null;
								}
						}
				}
		}
		_updateMaterialEmissive() {
				if (this._symbolColors) {
						this._colorUniform[0] = 1;
						this._colorUniform[1] = 1;
						this._colorUniform[2] = 1;
				} else {
						_tempColor$1.linear(this._color);
						this._colorUniform[0] = _tempColor$1.r;
						this._colorUniform[1] = _tempColor$1.g;
						this._colorUniform[2] = _tempColor$1.b;
				}
		}
		_updateMaterialOutline() {
				if (this._symbolOutlineParams) {
						this._outlineColorUniform[0] = 0;
						this._outlineColorUniform[1] = 0;
						this._outlineColorUniform[2] = 0;
						this._outlineColorUniform[3] = 1;
				} else {
						_tempColor$1.linear(this._outlineColor);
						this._outlineColorUniform[0] = _tempColor$1.r;
						this._outlineColorUniform[1] = _tempColor$1.g;
						this._outlineColorUniform[2] = _tempColor$1.b;
						this._outlineColorUniform[3] = _tempColor$1.a;
				}
		}
		_updateMaterialShadow() {
				if (this._symbolOutlineParams) {
						this._shadowColorUniform[0] = 0;
						this._shadowColorUniform[1] = 0;
						this._shadowColorUniform[2] = 0;
						this._shadowColorUniform[3] = 0;
				} else {
						_tempColor$1.linear(this._shadowColor);
						this._shadowColorUniform[0] = _tempColor$1.r;
						this._shadowColorUniform[1] = _tempColor$1.g;
						this._shadowColorUniform[2] = _tempColor$1.b;
						this._shadowColorUniform[3] = _tempColor$1.a;
				}
		}
		_isWordBoundary(char) {
				return WORD_BOUNDARY_CHAR.test(char);
		}
		_isValidNextChar(nextchar) {
				return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
		}
		_isNextCJKBoundary(char, nextchar) {
				return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
		}
		_isNextCJKWholeWord(nextchar) {
				return CJK_CHAR.test(nextchar);
		}
		_updateMeshes() {
				var json = this._font.data;
				var self = this;
				var minFont = Math.min(this._minFontSize, this._maxFontSize);
				var maxFont = this._maxFontSize;
				var autoFit = this._shouldAutoFit();
				if (autoFit) {
						this._fontSize = this._maxFontSize;
				}
				var MAGIC = 32;
				var l = this._symbols.length;
				var _x = 0;
				var _y = 0;
				var _z = 0;
				var _xMinusTrailingWhitespace = 0;
				var lines = 1;
				var wordStartX = 0;
				var wordStartIndex = 0;
				var lineStartIndex = 0;
				var numWordsThisLine = 0;
				var numCharsThisLine = 0;
				var numBreaksThisLine = 0;
				var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
				var maxLineWidth = this._element.calculatedWidth;
				if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
						maxLineWidth = Number.POSITIVE_INFINITY;
				}
				var fontMinY = 0;
				var fontMaxY = 0;
				var char, data, quad, nextchar;
				function breakLine(symbols, lineBreakIndex, lineBreakX) {
						self._lineWidths.push(Math.abs(lineBreakX));
						var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
						var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
						var chars = symbols.slice(sliceStart, sliceEnd);
						if (numBreaksThisLine) {
								var i = chars.length;
								while(i-- && numBreaksThisLine > 0){
										if (LINE_BREAK_CHAR.test(chars[i])) {
												chars.splice(i, 1);
												numBreaksThisLine--;
										}
								}
						}
						self._lineContents.push(chars.join(''));
						_x = 0;
						_y -= self._scaledLineHeight;
						lines++;
						numWordsThisLine = 0;
						numCharsThisLine = 0;
						numBreaksThisLine = 0;
						wordStartX = 0;
						lineStartIndex = lineBreakIndex;
				}
				var retryUpdateMeshes = true;
				while(retryUpdateMeshes){
						retryUpdateMeshes = false;
						if (autoFit) {
								this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
						} else {
								this._scaledLineHeight = this._lineHeight;
						}
						this.width = 0;
						this.height = 0;
						this._lineWidths = [];
						this._lineContents = [];
						_x = 0;
						_y = 0;
						_z = 0;
						_xMinusTrailingWhitespace = 0;
						lines = 1;
						wordStartX = 0;
						wordStartIndex = 0;
						lineStartIndex = 0;
						numWordsThisLine = 0;
						numCharsThisLine = 0;
						numBreaksThisLine = 0;
						var scale = this._fontSize / MAGIC;
						fontMinY = this._fontMinY * scale;
						fontMaxY = this._fontMaxY * scale;
						for(var i = 0; i < this._meshInfo.length; i++){
								this._meshInfo[i].quad = 0;
								this._meshInfo[i].lines = {};
						}
						var color_r = 255;
						var color_g = 255;
						var color_b = 255;
						var outline_color_rg = 255 + 255 * 256;
						var outline_color_ba = 255 + 255 * 256;
						var outline_thickness = 0;
						var shadow_color_rg = 255 + 255 * 256;
						var shadow_color_ba = 255 + 255 * 256;
						var shadow_offset_xy = 127 + 127 * 256;
						for(var i1 = 0; i1 < l; i1++){
								char = this._symbols[i1];
								nextchar = i1 + 1 >= l ? null : this._symbols[i1 + 1];
								var isLineBreak = LINE_BREAK_CHAR.test(char);
								if (isLineBreak) {
										numBreaksThisLine++;
										if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
												breakLine(this._symbols, i1, _xMinusTrailingWhitespace);
												wordStartIndex = i1 + 1;
												lineStartIndex = i1 + 1;
										}
										continue;
								}
								var x = 0;
								var y = 0;
								var advance = 0;
								var quadsize = 1;
								var dataScale = void 0, size = void 0;
								data = json.chars[char];
								if (!data) {
										if (CONTROL_CHARS.indexOf(char) !== -1) {
												data = CONTROL_GLYPH_DATA;
										} else {
												if (json.chars[' ']) {
														data = json.chars[' '];
												} else {
														for(var key in json.chars){
																data = json.chars[key];
																break;
														}
												}
										}
								}
								if (data) {
										var kerning = 0;
										if (numCharsThisLine > 0) {
												var kernTable = this._font.data.kerning;
												if (kernTable) {
														var kernLeft = kernTable[string.getCodePoint(this._symbols[i1 - 1]) || 0];
														if (kernLeft) {
																kerning = kernLeft[string.getCodePoint(this._symbols[i1]) || 0] || 0;
														}
												}
										}
										dataScale = data.scale || 1;
										size = (data.width + data.height) / 2;
										quadsize = scale * size / dataScale;
										advance = (data.xadvance + kerning) * scale;
										x = (data.xoffset - kerning) * scale;
										y = data.yoffset * scale;
								} else {
										console.error("Couldn't substitute missing character: '" + char + "'");
								}
								var isWhitespace = WHITESPACE_CHAR.test(char);
								var meshInfoId = data && data.map || 0;
								var ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;
								var meshInfo = this._meshInfo[meshInfoId];
								var candidateLineWidth = _x + this._spacing * advance;
								if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
										if (this._maxLines < 0 || lines < this._maxLines) {
												if (numWordsThisLine === 0) {
														wordStartIndex = i1;
														breakLine(this._symbols, i1, _xMinusTrailingWhitespace);
												} else {
														var backtrack = Math.max(i1 - wordStartIndex, 0);
														if (this._meshInfo.length <= 1) {
																meshInfo.lines[lines - 1] -= backtrack;
																meshInfo.quad -= backtrack;
														} else {
																var backtrackStart = wordStartIndex;
																var backtrackEnd = i1;
																for(var j = backtrackStart; j < backtrackEnd; j++){
																		var backChar = this._symbols[j];
																		var backCharData = json.chars[backChar];
																		var backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
																		backMeshInfo.lines[lines - 1] -= 1;
																		backMeshInfo.quad -= 1;
																}
														}
														i1 -= backtrack + 1;
														breakLine(this._symbols, wordStartIndex, wordStartX);
														continue;
												}
										}
								}
								quad = meshInfo.quad;
								meshInfo.lines[lines - 1] = quad;
								var left = _x - x;
								var right = left + quadsize;
								var bottom = _y - y;
								var top = bottom + quadsize;
								if (this._rtl) {
										var shift = quadsize - x - this._spacing * advance - x;
										left -= shift;
										right -= shift;
								}
								meshInfo.positions[quad * 4 * 3 + 0] = left;
								meshInfo.positions[quad * 4 * 3 + 1] = bottom;
								meshInfo.positions[quad * 4 * 3 + 2] = _z;
								meshInfo.positions[quad * 4 * 3 + 3] = right;
								meshInfo.positions[quad * 4 * 3 + 4] = bottom;
								meshInfo.positions[quad * 4 * 3 + 5] = _z;
								meshInfo.positions[quad * 4 * 3 + 6] = right;
								meshInfo.positions[quad * 4 * 3 + 7] = top;
								meshInfo.positions[quad * 4 * 3 + 8] = _z;
								meshInfo.positions[quad * 4 * 3 + 9] = left;
								meshInfo.positions[quad * 4 * 3 + 10] = top;
								meshInfo.positions[quad * 4 * 3 + 11] = _z;
								this.width = Math.max(this.width, candidateLineWidth);
								var fontSize = void 0;
								if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
										fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
										fontSize = math.clamp(fontSize, minFont, maxFont);
										if (fontSize !== this._element.fontSize) {
												this._fontSize = fontSize;
												retryUpdateMeshes = true;
												break;
										}
								}
								this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
								if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
										fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
										if (fontSize !== this._element.fontSize) {
												this._fontSize = fontSize;
												retryUpdateMeshes = true;
												break;
										}
								}
								_x += this._spacing * advance;
								if (!isWhitespace) {
										_xMinusTrailingWhitespace = _x;
								}
								if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
										numWordsThisLine++;
										wordStartX = _xMinusTrailingWhitespace;
										wordStartIndex = i1 + 1;
								}
								numCharsThisLine++;
								var uv = this._getUv(char);
								meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
								meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
								meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
								meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
								meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
								meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
								meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
								meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];
								if (this._symbolColors) {
										var colorIdx = this._symbolColors[i1] * 3;
										color_r = this._colorPalette[colorIdx];
										color_g = this._colorPalette[colorIdx + 1];
										color_b = this._colorPalette[colorIdx + 2];
								}
								meshInfo.colors[quad * 4 * 4 + 0] = color_r;
								meshInfo.colors[quad * 4 * 4 + 1] = color_g;
								meshInfo.colors[quad * 4 * 4 + 2] = color_b;
								meshInfo.colors[quad * 4 * 4 + 3] = 255;
								meshInfo.colors[quad * 4 * 4 + 4] = color_r;
								meshInfo.colors[quad * 4 * 4 + 5] = color_g;
								meshInfo.colors[quad * 4 * 4 + 6] = color_b;
								meshInfo.colors[quad * 4 * 4 + 7] = 255;
								meshInfo.colors[quad * 4 * 4 + 8] = color_r;
								meshInfo.colors[quad * 4 * 4 + 9] = color_g;
								meshInfo.colors[quad * 4 * 4 + 10] = color_b;
								meshInfo.colors[quad * 4 * 4 + 11] = 255;
								meshInfo.colors[quad * 4 * 4 + 12] = color_r;
								meshInfo.colors[quad * 4 * 4 + 13] = color_g;
								meshInfo.colors[quad * 4 * 4 + 14] = color_b;
								meshInfo.colors[quad * 4 * 4 + 15] = 255;
								if (this._symbolOutlineParams) {
										var outlineIdx = this._symbolOutlineParams[i1] * 5;
										outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;
										outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;
										outline_thickness = this._outlinePalette[outlineIdx + 4];
								}
								meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;
								meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;
								meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;
								meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;
								meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;
								meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;
								meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;
								meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;
								meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;
								meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;
								meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;
								meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;
								if (this._symbolShadowParams) {
										var shadowIdx = this._symbolShadowParams[i1] * 6;
										shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;
										shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;
										shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;
								}
								meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;
								meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;
								meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;
								meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;
								meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;
								meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;
								meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;
								meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;
								meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;
								meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;
								meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;
								meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;
								meshInfo.quad++;
						}
						if (retryUpdateMeshes) {
								continue;
						}
						if (lineStartIndex < l) {
								breakLine(this._symbols, l, _x);
						}
				}
				this._noResize = true;
				this.autoWidth = this._autoWidth;
				this.autoHeight = this._autoHeight;
				this._noResize = false;
				var hp = this._element.pivot.x;
				var vp = this._element.pivot.y;
				var ha = this._alignment.x;
				var va = this._alignment.y;
				for(var i2 = 0; i2 < this._meshInfo.length; i2++){
						if (this._meshInfo[i2].count === 0) continue;
						var prevQuad = 0;
						for(var line in this._meshInfo[i2].lines){
								var index = this._meshInfo[i2].lines[line];
								var lw = this._lineWidths[parseInt(line, 10)];
								var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
								var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
								for(var quad1 = prevQuad; quad1 <= index; quad1++){
										this._meshInfo[i2].positions[quad1 * 4 * 3] += hoffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 3] += hoffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 6] += hoffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 9] += hoffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 1] += voffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 4] += voffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 7] += voffset;
										this._meshInfo[i2].positions[quad1 * 4 * 3 + 10] += voffset;
								}
								if (this._rtl) {
										for(var quad2 = prevQuad; quad2 <= index; quad2++){
												var idx = quad2 * 4 * 3;
												for(var vert = 0; vert < 4; ++vert){
														this._meshInfo[i2].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i2].positions[idx + vert * 3] + hoffset * 2;
												}
												var tmp0 = this._meshInfo[i2].positions[idx + 3];
												var tmp1 = this._meshInfo[i2].positions[idx + 6];
												this._meshInfo[i2].positions[idx + 3] = this._meshInfo[i2].positions[idx + 0];
												this._meshInfo[i2].positions[idx + 6] = this._meshInfo[i2].positions[idx + 9];
												this._meshInfo[i2].positions[idx + 0] = tmp0;
												this._meshInfo[i2].positions[idx + 9] = tmp1;
										}
								}
								prevQuad = index + 1;
						}
						var numVertices = this._meshInfo[i2].count * 4;
						var vertMax = this._meshInfo[i2].quad * 4;
						var it = new VertexIterator(this._meshInfo[i2].meshInstance.mesh.vertexBuffer);
						for(var v = 0; v < numVertices; v++){
								if (v >= vertMax) {
										it.element[SEMANTIC_POSITION].set(0, 0, 0);
										it.element[SEMANTIC_TEXCOORD0].set(0, 0);
										it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
										it.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);
										it.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);
								} else {
										it.element[SEMANTIC_POSITION].set(this._meshInfo[i2].positions[v * 3 + 0], this._meshInfo[i2].positions[v * 3 + 1], this._meshInfo[i2].positions[v * 3 + 2]);
										it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i2].uvs[v * 2 + 0], this._meshInfo[i2].uvs[v * 2 + 1]);
										it.element[SEMANTIC_COLOR].set(this._meshInfo[i2].colors[v * 4 + 0], this._meshInfo[i2].colors[v * 4 + 1], this._meshInfo[i2].colors[v * 4 + 2], this._meshInfo[i2].colors[v * 4 + 3]);
										it.element[SEMANTIC_ATTR8].set(this._meshInfo[i2].outlines[v * 3 + 0], this._meshInfo[i2].outlines[v * 3 + 1], this._meshInfo[i2].outlines[v * 3 + 2]);
										it.element[SEMANTIC_ATTR9].set(this._meshInfo[i2].shadows[v * 3 + 0], this._meshInfo[i2].shadows[v * 3 + 1], this._meshInfo[i2].shadows[v * 3 + 2]);
								}
								it.next();
						}
						it.end();
						this._meshInfo[i2].meshInstance.mesh.aabb.compute(this._meshInfo[i2].positions);
						this._meshInfo[i2].meshInstance._aabbVer = -1;
				}
				this._aabbDirty = true;
		}
		_onFontRender() {
				this.font = this._font;
		}
		_onFontLoad(asset) {
				if (this.font !== asset.resource) {
						this.font = asset.resource;
				}
		}
		_onFontChange(asset, name, _new, _old) {
				if (name === 'data') {
						this._font.data = _new;
						var maps = this._font.data.info.maps.length;
						for(var i = 0; i < maps; i++){
								if (!this._meshInfo[i]) continue;
								var mi = this._meshInfo[i].meshInstance;
								if (mi) {
										mi.setParameter('font_sdfIntensity', this._font.intensity);
										mi.setParameter('font_pxrange', this._getPxRange(this._font));
										mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
								}
						}
				}
		}
		_onFontRemove(asset) {}
		_setTextureParams(mi, texture) {
				if (this._font) {
						if (this._font.type === FONT_MSDF) {
								mi.deleteParameter('texture_emissiveMap');
								mi.deleteParameter('texture_opacityMap');
								mi.setParameter('texture_msdfMap', texture);
						} else if (this._font.type === FONT_BITMAP) {
								mi.deleteParameter('texture_msdfMap');
								mi.setParameter('texture_emissiveMap', texture);
								mi.setParameter('texture_opacityMap', texture);
						}
				}
		}
		_getPxRange(font) {
				var keys = Object.keys(this._font.data.chars);
				for(var i = 0; i < keys.length; i++){
						var char = this._font.data.chars[keys[i]];
						if (char.range) {
								return (char.scale || 1) * char.range;
						}
				}
				return 2;
		}
		_getUv(char) {
				var data = this._font.data;
				if (!data.chars[char]) {
						var space = ' ';
						if (data.chars[space]) {
								return this._getUv(space);
						}
						return [
								0,
								0,
								0,
								0
						];
				}
				var map = data.chars[char].map;
				var width = data.info.maps[map].width;
				var height = data.info.maps[map].height;
				var x = data.chars[char].x;
				var y = data.chars[char].y;
				var x1 = x;
				var y1 = y;
				var x2 = x + data.chars[char].width;
				var y2 = y - data.chars[char].height;
				var edge = 1 - data.chars[char].height / height;
				return [
						x1 / width,
						edge - y1 / height,
						x2 / width,
						edge - y2 / height
				];
		}
		onEnable() {
				this._fontAsset.autoLoad = true;
				if (this._model) {
						this._element.addModelToLayers(this._model);
				}
		}
		onDisable() {
				this._fontAsset.autoLoad = false;
				if (this._model) {
						this._element.removeModelFromLayers(this._model);
				}
		}
		_setStencil(stencilParams) {
				if (this._model) {
						var instances = this._model.meshInstances;
						for(var i = 0; i < instances.length; i++){
								instances[i].stencilFront = stencilParams;
								instances[i].stencilBack = stencilParams;
						}
				}
		}
		_shouldAutoFitWidth() {
				return this._autoFitWidth && !this._autoWidth;
		}
		_shouldAutoFitHeight() {
				return this._autoFitHeight && !this._autoHeight;
		}
		_shouldAutoFit() {
				return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
		}
		_calculateCharsPerTexture(symbolIndex) {
				var charactersPerTexture = {};
				if (symbolIndex === undefined) {
						symbolIndex = this._symbols.length;
				}
				for(var i = 0, len = symbolIndex; i < len; i++){
						var char = this._symbols[i];
						var info = this._font.data.chars[char];
						if (!info) {
								info = this._font.data.chars[' '];
								if (!info) {
										info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
								}
						}
						var map = info.map;
						if (!charactersPerTexture[map]) {
								charactersPerTexture[map] = 1;
						} else {
								charactersPerTexture[map]++;
						}
				}
				return charactersPerTexture;
		}
		_updateRenderRange() {
				var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
				var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
				for(var i = 0, len = this._meshInfo.length; i < len; i++){
						var start = startChars[i] || 0;
						var end = endChars[i] || 0;
						var instance = this._meshInfo[i].meshInstance;
						if (instance) {
								var mesh = instance.mesh;
								if (mesh) {
										mesh.primitive[0].base = start * 3 * 2;
										mesh.primitive[0].count = (end - start) * 3 * 2;
								}
						}
				}
		}
		set text(value) {
				this._i18nKey = null;
				var str = value != null && value.toString() || '';
				this._setText(str);
		}
		get text() {
				return this._text;
		}
		set key(value) {
				var str = value !== null ? value.toString() : null;
				if (this._i18nKey === str) {
						return;
				}
				this._i18nKey = str;
				if (str) {
						this._fontAsset.disableLocalization = false;
						this._resetLocalizedText();
				} else {
						this._fontAsset.disableLocalization = true;
				}
		}
		get key() {
				return this._i18nKey;
		}
		set color(value) {
				var r = value.r;
				var g = value.g;
				var b = value.b;
				if (this._color.r === r && this._color.g === g && this._color.b === b) {
						return;
				}
				this._color.r = r;
				this._color.g = g;
				this._color.b = b;
				if (!this._model) {
						return;
				}
				if (this._symbolColors) {
						if (this._font) {
								this._updateText();
						}
				} else {
						_tempColor$1.linear(this._color);
						this._colorUniform[0] = _tempColor$1.r;
						this._colorUniform[1] = _tempColor$1.g;
						this._colorUniform[2] = _tempColor$1.b;
						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
								var mi = this._model.meshInstances[i];
								mi.setParameter('material_emissive', this._colorUniform);
						}
				}
				if (this._element) {
						this._element.fire('set:color', this._color);
				}
		}
		get color() {
				return this._color;
		}
		set opacity(value) {
				if (this._color.a !== value) {
						this._color.a = value;
						if (this._model) {
								for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
										var mi = this._model.meshInstances[i];
										mi.setParameter('material_opacity', value);
								}
						}
				}
				if (this._element) {
						this._element.fire('set:opacity', value);
				}
		}
		get opacity() {
				return this._color.a;
		}
		set lineHeight(value) {
				var _prev = this._lineHeight;
				this._lineHeight = value;
				this._scaledLineHeight = value;
				if (_prev !== value && this._font) {
						this._updateText();
				}
		}
		get lineHeight() {
				return this._lineHeight;
		}
		set wrapLines(value) {
				var _prev = this._wrapLines;
				this._wrapLines = value;
				if (_prev !== value && this._font) {
						this._updateText();
				}
		}
		get wrapLines() {
				return this._wrapLines;
		}
		get lines() {
				return this._lineContents;
		}
		set spacing(value) {
				var _prev = this._spacing;
				this._spacing = value;
				if (_prev !== value && this._font) {
						this._updateText();
				}
		}
		get spacing() {
				return this._spacing;
		}
		set fontSize(value) {
				var _prev = this._fontSize;
				this._fontSize = value;
				this._originalFontSize = value;
				if (_prev !== value && this._font) {
						this._updateText();
				}
		}
		get fontSize() {
				return this._fontSize;
		}
		set fontAsset(value) {
				this._fontAsset.defaultAsset = value;
		}
		get fontAsset() {
				return this._fontAsset.localizedAsset;
		}
		set font(value) {
				var previousFontType;
				if (this._font) {
						previousFontType = this._font.type;
						if (this._font.off) this._font.off('render', this._onFontRender, this);
				}
				this._font = value;
				this._fontMinY = 0;
				this._fontMaxY = 0;
				if (!value) return;
				var json = this._font.data;
				for(var charId in json.chars){
						var data = json.chars[charId];
						if (data.bounds) {
								this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
								this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
						}
				}
				if (this._font.on) this._font.on('render', this._onFontRender, this);
				if (this._fontAsset.localizedAsset) {
						var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
						if (asset.resource !== this._font) {
								this._fontAsset.defaultAsset = null;
						}
				}
				if (value.type !== previousFontType) {
						var screenSpace = this._element._isScreenSpace();
						this._updateMaterial(screenSpace);
				}
				for(var i = 0, len = this._font.textures.length; i < len; i++){
						if (!this._meshInfo[i]) {
								this._meshInfo[i] = new MeshInfo();
						} else {
								var mi = this._meshInfo[i].meshInstance;
								if (mi) {
										mi.setParameter('font_sdfIntensity', this._font.intensity);
										mi.setParameter('font_pxrange', this._getPxRange(this._font));
										mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
										this._setTextureParams(mi, this._font.textures[i]);
								}
						}
				}
				var removedModel = false;
				for(var i1 = this._font.textures.length; i1 < this._meshInfo.length; i1++){
						if (this._meshInfo[i1].meshInstance) {
								if (!removedModel) {
										this._element.removeModelFromLayers(this._model);
										removedModel = true;
								}
								this._removeMeshInstance(this._meshInfo[i1].meshInstance);
						}
				}
				if (this._meshInfo.length > this._font.textures.length) {
						this._meshInfo.length = this._font.textures.length;
				}
				this._updateText();
		}
		get font() {
				return this._font;
		}
		set alignment(value) {
				if (value instanceof Vec2) {
						this._alignment.set(value.x, value.y);
				} else {
						this._alignment.set(value[0], value[1]);
				}
				if (this._font) {
						this._updateText();
				}
		}
		get alignment() {
				return this._alignment;
		}
		set autoWidth(value) {
				var old = this._autoWidth;
				this._autoWidth = value;
				if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
						this._element.width = this.width;
				}
				if (old !== value) {
						var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
						if (newFontSize !== this._fontSize) {
								this._fontSize = newFontSize;
								if (this._font) {
										this._updateText();
								}
						}
				}
		}
		get autoWidth() {
				return this._autoWidth;
		}
		set autoHeight(value) {
				var old = this._autoHeight;
				this._autoHeight = value;
				if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
						this._element.height = this.height;
				}
				if (old !== value) {
						var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
						if (newFontSize !== this._fontSize) {
								this._fontSize = newFontSize;
								if (this._font) {
										this._updateText();
								}
						}
				}
		}
		get autoHeight() {
				return this._autoHeight;
		}
		set rtlReorder(value) {
				if (this._rtlReorder !== value) {
						this._rtlReorder = value;
						if (this._font) {
								this._updateText();
						}
				}
		}
		get rtlReorder() {
				return this._rtlReorder;
		}
		set unicodeConverter(value) {
				if (this._unicodeConverter !== value) {
						this._unicodeConverter = value;
						this._setText(this._text);
				}
		}
		get unicodeConverter() {
				return this._unicodeConverter;
		}
		get aabb() {
				if (this._aabbDirty) {
						var initialized = false;
						for(var i = 0; i < this._meshInfo.length; i++){
								if (!this._meshInfo[i].meshInstance) continue;
								if (!initialized) {
										this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
										initialized = true;
								} else {
										this._aabb.add(this._meshInfo[i].meshInstance.aabb);
								}
						}
						this._aabbDirty = false;
				}
				return this._aabb;
		}
		set outlineColor(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];
				if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
						return;
				}
				this._outlineColor.r = r;
				this._outlineColor.g = g;
				this._outlineColor.b = b;
				this._outlineColor.a = a;
				if (!this._model) {
						return;
				}
				if (this._symbolOutlineParams) {
						if (this._font) {
								this._updateText();
						}
				} else {
						_tempColor$1.linear(this._outlineColor);
						this._outlineColorUniform[0] = _tempColor$1.r;
						this._outlineColorUniform[1] = _tempColor$1.g;
						this._outlineColorUniform[2] = _tempColor$1.b;
						this._outlineColorUniform[3] = _tempColor$1.a;
						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
								var mi = this._model.meshInstances[i];
								mi.setParameter('outline_color', this._outlineColorUniform);
						}
				}
				if (this._element) {
						this._element.fire('set:outline', this._color);
				}
		}
		get outlineColor() {
				return this._outlineColor;
		}
		set outlineThickness(value) {
				var _prev = this._outlineThickness;
				this._outlineThickness = value;
				if (_prev !== value && this._font) {
						if (!this._model) {
								return;
						}
						if (this._symbolOutlineParams) {
								if (this._font) {
										this._updateText();
								}
						} else {
								for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
										var mi = this._model.meshInstances[i];
										mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
								}
						}
				}
		}
		get outlineThickness() {
				return this._outlineThickness;
		}
		set shadowColor(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];
				if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
						return;
				}
				this._shadowColor.r = r;
				this._shadowColor.g = g;
				this._shadowColor.b = b;
				this._shadowColor.a = a;
				if (!this._model) {
						return;
				}
				if (this._symbolShadowParams) {
						if (this._font) {
								this._updateText();
						}
				} else {
						_tempColor$1.linear(this._shadowColor);
						this._shadowColorUniform[0] = _tempColor$1.r;
						this._shadowColorUniform[1] = _tempColor$1.g;
						this._shadowColorUniform[2] = _tempColor$1.b;
						this._shadowColorUniform[3] = _tempColor$1.a;
						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
								var mi = this._model.meshInstances[i];
								mi.setParameter('shadow_color', this._shadowColorUniform);
						}
				}
		}
		get shadowColor() {
				return this._shadowColor;
		}
		set shadowOffset(value) {
				var x = value instanceof Vec2 ? value.x : value[0], y = value instanceof Vec2 ? value.y : value[1];
				if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
						return;
				}
				this._shadowOffset.set(x, y);
				if (this._font && this._model) {
						if (this._symbolShadowParams) {
								this._updateText();
						} else {
								for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
										var ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
										this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
										this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
										var mi = this._model.meshInstances[i];
										mi.setParameter('shadow_offset', this._shadowOffsetUniform);
								}
						}
				}
		}
		get shadowOffset() {
				return this._shadowOffset;
		}
		set minFontSize(value) {
				if (this._minFontSize === value) return;
				this._minFontSize = value;
				if (this.font && this._shouldAutoFit()) {
						this._updateText();
				}
		}
		get minFontSize() {
				return this._minFontSize;
		}
		set maxFontSize(value) {
				if (this._maxFontSize === value) return;
				this._maxFontSize = value;
				if (this.font && this._shouldAutoFit()) {
						this._updateText();
				}
		}
		get maxFontSize() {
				return this._maxFontSize;
		}
		set autoFitWidth(value) {
				if (this._autoFitWidth === value) return;
				this._autoFitWidth = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (this.font) {
						this._updateText();
				}
		}
		get autoFitWidth() {
				return this._autoFitWidth;
		}
		set autoFitHeight(value) {
				if (this._autoFitHeight === value) return;
				this._autoFitHeight = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (this.font) {
						this._updateText();
				}
		}
		get autoFitHeight() {
				return this._autoFitHeight;
		}
		set maxLines(value) {
				if (this._maxLines === value) return;
				if (value === null && this._maxLines === -1) return;
				this._maxLines = value === null ? -1 : value;
				if (this.font && this._wrapLines) {
						this._updateText();
				}
		}
		get maxLines() {
				return this._maxLines;
		}
		set enableMarkup(value) {
				value = !!value;
				if (this._enableMarkup === value) return;
				this._enableMarkup = value;
				if (this.font) {
						this._updateText();
				}
				var screenSpace = this._element._isScreenSpace();
				this._updateMaterial(screenSpace);
		}
		get enableMarkup() {
				return this._enableMarkup;
		}
		get symbols() {
				return this._symbols;
		}
		get symbolColors() {
				if (this._symbolColors === null) {
						return null;
				}
				return this._symbolColors.map(function(c) {
						return this._colorPalette.slice(c * 3, c * 3 + 3);
				}, this);
		}
		get symbolOutlineParams() {
				if (this._symbolOutlineParams === null) {
						return null;
				}
				return this._symbolOutlineParams.map(function(paramId) {
						return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);
				}, this);
		}
		get symbolShadowParams() {
				if (this._symbolShadowParams === null) {
						return null;
				}
				return this._symbolShadowParams.map(function(paramId) {
						return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);
				}, this);
		}
		get rtl() {
				return this._rtl;
		}
		set rangeStart(rangeStart) {
				rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));
				if (rangeStart !== this._rangeStart) {
						this._rangeStart = rangeStart;
						this._updateRenderRange();
				}
		}
		get rangeStart() {
				return this._rangeStart;
		}
		set rangeEnd(rangeEnd) {
				rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));
				if (rangeEnd !== this._rangeEnd) {
						this._rangeEnd = rangeEnd;
						this._updateRenderRange();
				}
		}
		get rangeEnd() {
				return this._rangeEnd;
		}
		constructor(element){
				this._element = element;
				this._system = element.system;
				this._entity = element.entity;
				this._text = '';
				this._symbols = [];
				this._colorPalette = [];
				this._outlinePalette = [];
				this._shadowPalette = [];
				this._symbolColors = null;
				this._symbolOutlineParams = null;
				this._symbolShadowParams = null;
				this._i18nKey = null;
				this._fontAsset = new LocalizedAsset(this._system.app);
				this._fontAsset.disableLocalization = true;
				this._fontAsset.on('load', this._onFontLoad, this);
				this._fontAsset.on('change', this._onFontChange, this);
				this._fontAsset.on('remove', this._onFontRemove, this);
				this._font = null;
				this._color = new Color(1, 1, 1, 1);
				this._colorUniform = new Float32Array(3);
				this._spacing = 1;
				this._fontSize = 32;
				this._fontMinY = 0;
				this._fontMaxY = 0;
				this._originalFontSize = 32;
				this._maxFontSize = 32;
				this._minFontSize = 8;
				this._autoFitWidth = false;
				this._autoFitHeight = false;
				this._maxLines = -1;
				this._lineHeight = 32;
				this._scaledLineHeight = 32;
				this._wrapLines = false;
				this._drawOrder = 0;
				this._alignment = new Vec2(0.5, 0.5);
				this._autoWidth = true;
				this._autoHeight = true;
				this.width = 0;
				this.height = 0;
				this._node = new GraphNode();
				this._model = new Model();
				this._model.graph = this._node;
				this._entity.addChild(this._node);
				this._meshInfo = [];
				this._material = null;
				this._aabbDirty = true;
				this._aabb = new BoundingBox();
				this._noResize = false;
				this._currentMaterialType = null;
				this._maskedMaterialSrc = null;
				this._rtlReorder = false;
				this._unicodeConverter = false;
				this._rtl = false;
				this._outlineColor = new Color(0, 0, 0, 1);
				this._outlineColorUniform = new Float32Array(4);
				this._outlineThicknessScale = 0.2;
				this._outlineThickness = 0.0;
				this._shadowColor = new Color(0, 0, 0, 1);
				this._shadowColorUniform = new Float32Array(4);
				this._shadowOffsetScale = 0.005;
				this._shadowOffset = new Vec2(0, 0);
				this._shadowOffsetUniform = new Float32Array(2);
				this._enableMarkup = false;
				this._onScreenChange(this._element.screen);
				element.on('resize', this._onParentResize, this);
				element.on('set:screen', this._onScreenChange, this);
				element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
				element.on('set:draworder', this._onDrawOrderChange, this);
				element.on('set:pivot', this._onPivotChange, this);
				this._system.app.i18n.on('set:locale', this._onLocaleSet, this);
				this._system.app.i18n.on('data:add', this._onLocalizationData, this);
				this._system.app.i18n.on('data:remove', this._onLocalizationData, this);
				this._rangeStart = 0;
				this._rangeEnd = 0;
		}
}

var position = new Vec3();
var invParentWtm = new Mat4();
var vecA$2 = new Vec3();
var vecB$2 = new Vec3();
var matA = new Mat4();
var matB = new Mat4();
var matC = new Mat4();
var matD = new Mat4();
class ElementComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(value) {
				var data = this.data;
				var oldValue = data.enabled;
				data.enabled = value;
				this.fire('set', 'enabled', oldValue, value);
		}
		get enabled() {
				return this.data.enabled;
		}
		get _absLeft() {
				return this._localAnchor.x + this._margin.x;
		}
		get _absRight() {
				return this._localAnchor.z - this._margin.z;
		}
		get _absTop() {
				return this._localAnchor.w - this._margin.w;
		}
		get _absBottom() {
				return this._localAnchor.y + this._margin.y;
		}
		get _hasSplitAnchorsX() {
				return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
		}
		get _hasSplitAnchorsY() {
				return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
		}
		get aabb() {
				if (this._image) {
						return this._image.aabb;
				}
				if (this._text) {
						return this._text.aabb;
				}
				return null;
		}
		set anchor(value) {
				if (value instanceof Vec4) {
						this._anchor.copy(value);
				} else {
						this._anchor.set(...value);
				}
				if (!this.entity._parent && !this.screen) {
						this._calculateLocalAnchors();
				} else {
						this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
				}
				this._anchorDirty = true;
				if (!this.entity._dirtyLocal) {
						this.entity._dirtifyLocal();
				}
				this.fire('set:anchor', this._anchor);
		}
		get anchor() {
				return this._anchor;
		}
		set batchGroupId(value) {
				if (this._batchGroupId === value) {
						return;
				}
				if (this.entity.enabled && this._batchGroupId >= 0) {
						var _this_system_app_batcher;
						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
						var _this_system_app_batcher1;
						(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.ELEMENT, value, this.entity);
				}
				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
						if (this._image && this._image._renderable.model) {
								this.addModelToLayers(this._image._renderable.model);
						} else if (this._text && this._text._model) {
								this.addModelToLayers(this._text._model);
						}
				}
				this._batchGroupId = value;
		}
		get batchGroupId() {
				return this._batchGroupId;
		}
		set bottom(value) {
				this._margin.y = value;
				var p = this.entity.getLocalPosition();
				var wt = this._absTop;
				var wb = this._localAnchor.y + value;
				this._setHeight(wt - wb);
				p.y = value + this._calculatedHeight * this._pivot.y;
				this.entity.setLocalPosition(p);
		}
		get bottom() {
				return this._margin.y;
		}
		set calculatedWidth(value) {
				this._setCalculatedWidth(value, true);
		}
		get calculatedWidth() {
				return this._calculatedWidth;
		}
		set calculatedHeight(value) {
				this._setCalculatedHeight(value, true);
		}
		get calculatedHeight() {
				return this._calculatedHeight;
		}
		get canvasCorners() {
				if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) {
						return this._canvasCorners;
				}
				var device = this.system.app.graphicsDevice;
				var screenCorners = this.screenCorners;
				var sx = device.canvas.clientWidth / device.width;
				var sy = device.canvas.clientHeight / device.height;
				for(var i = 0; i < 4; i++){
						this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
				}
				this._canvasCornersDirty = false;
				return this._canvasCorners;
		}
		set drawOrder(value) {
				var priority = 0;
				if (this.screen) {
						priority = this.screen.screen.priority;
				}
				if (value > 0xFFFFFF) {
						value = 0xFFFFFF;
				}
				this._drawOrder = (priority << 24) + value;
				this.fire('set:draworder', this._drawOrder);
		}
		get drawOrder() {
				return this._drawOrder;
		}
		set height(value) {
				this._height = value;
				if (!this._hasSplitAnchorsY) {
						this._setCalculatedHeight(value, true);
				}
				this.fire('set:height', this._height);
		}
		get height() {
				return this._height;
		}
		set layers(value) {
				if (this._addedModels.length) {
						for(var i = 0; i < this._layers.length; i++){
								var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
								if (layer) {
										for(var j = 0; j < this._addedModels.length; j++){
												layer.removeMeshInstances(this._addedModels[j].meshInstances);
										}
								}
						}
				}
				this._layers = value;
				if (!this.enabled || !this.entity.enabled || !this._addedModels.length) {
						return;
				}
				for(var i1 = 0; i1 < this._layers.length; i1++){
						var layer1 = this.system.app.scene.layers.getLayerById(this._layers[i1]);
						if (layer1) {
								for(var j1 = 0; j1 < this._addedModels.length; j1++){
										layer1.addMeshInstances(this._addedModels[j1].meshInstances);
								}
						}
				}
		}
		get layers() {
				return this._layers;
		}
		set left(value) {
				this._margin.x = value;
				var p = this.entity.getLocalPosition();
				var wr = this._absRight;
				var wl = this._localAnchor.x + value;
				this._setWidth(wr - wl);
				p.x = value + this._calculatedWidth * this._pivot.x;
				this.entity.setLocalPosition(p);
		}
		get left() {
				return this._margin.x;
		}
		set margin(value) {
				this._margin.copy(value);
				this._calculateSize(true, true);
				this.fire('set:margin', this._margin);
		}
		get margin() {
				return this._margin;
		}
		get maskedBy() {
				return this._maskedBy;
		}
		set pivot(value) {
				var { pivot, margin } = this;
				var prevX = pivot.x;
				var prevY = pivot.y;
				if (value instanceof Vec2) {
						pivot.copy(value);
				} else {
						pivot.set(...value);
				}
				var mx = margin.x + margin.z;
				var dx = pivot.x - prevX;
				margin.x += mx * dx;
				margin.z -= mx * dx;
				var my = margin.y + margin.w;
				var dy = pivot.y - prevY;
				margin.y += my * dy;
				margin.w -= my * dy;
				this._anchorDirty = true;
				this._cornersDirty = true;
				this._worldCornersDirty = true;
				this._calculateSize(false, false);
				this._flagChildrenAsDirty();
				this.fire('set:pivot', pivot);
		}
		get pivot() {
				return this._pivot;
		}
		set right(value) {
				this._margin.z = value;
				var p = this.entity.getLocalPosition();
				var wl = this._absLeft;
				var wr = this._localAnchor.z - value;
				this._setWidth(wr - wl);
				p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
				this.entity.setLocalPosition(p);
		}
		get right() {
				return this._margin.z;
		}
		get screenCorners() {
				if (!this._cornersDirty || !this.screen) {
						return this._screenCorners;
				}
				var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
				this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
				this._screenCorners[1].set(this._absRight, this._absBottom, 0);
				this._screenCorners[2].set(this._absRight, this._absTop, 0);
				this._screenCorners[3].set(this._absLeft, this._absTop, 0);
				var screenSpace = this.screen.screen.screenSpace;
				for(var i = 0; i < 4; i++){
						this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
						if (screenSpace) {
								this._screenCorners[i].mulScalar(this.screen.screen.scale);
						}
						if (parentBottomLeft) {
								this._screenCorners[i].add(parentBottomLeft);
						}
				}
				this._cornersDirty = false;
				this._canvasCornersDirty = true;
				this._worldCornersDirty = true;
				return this._screenCorners;
		}
		get textWidth() {
				return this._text ? this._text.width : 0;
		}
		get textHeight() {
				return this._text ? this._text.height : 0;
		}
		set top(value) {
				this._margin.w = value;
				var p = this.entity.getLocalPosition();
				var wb = this._absBottom;
				var wt = this._localAnchor.w - value;
				this._setHeight(wt - wb);
				p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
				this.entity.setLocalPosition(p);
		}
		get top() {
				return this._margin.w;
		}
		set type(value) {
				if (value !== this._type) {
						this._type = value;
						if (this._image) {
								this._image.destroy();
								this._image = null;
						}
						if (this._text) {
								this._text.destroy();
								this._text = null;
						}
						if (value === ELEMENTTYPE_IMAGE) {
								this._image = new ImageElement(this);
						} else if (value === ELEMENTTYPE_TEXT) {
								this._text = new TextElement(this);
						}
				}
		}
		get type() {
				return this._type;
		}
		set useInput(value) {
				if (this._useInput === value) {
						return;
				}
				this._useInput = value;
				if (this.system.app.elementInput) {
						if (value) {
								if (this.enabled && this.entity.enabled) {
										this.system.app.elementInput.addElement(this);
								}
						} else {
								this.system.app.elementInput.removeElement(this);
						}
				} else {
						if (this._useInput === true) ;
				}
				this.fire('set:useInput', value);
		}
		get useInput() {
				return this._useInput;
		}
		set fitMode(value) {
				this._fitMode = value;
				this._calculateSize(true, true);
				if (this._image) {
						this._image.refreshMesh();
				}
		}
		get fitMode() {
				return this._fitMode;
		}
		set width(value) {
				this._width = value;
				if (!this._hasSplitAnchorsX) {
						this._setCalculatedWidth(value, true);
				}
				this.fire('set:width', this._width);
		}
		get width() {
				return this._width;
		}
		get worldCorners() {
				if (!this._worldCornersDirty) {
						return this._worldCorners;
				}
				if (this.screen) {
						var screenCorners = this.screenCorners;
						if (!this.screen.screen.screenSpace) {
								matA.copy(this.screen.screen._screenMatrix);
								matA.data[13] = -matA.data[13];
								matA.mul2(this.screen.getWorldTransform(), matA);
								for(var i = 0; i < 4; i++){
										matA.transformPoint(screenCorners[i], this._worldCorners[i]);
								}
						}
				} else {
						var localPos = this.entity.getLocalPosition();
						matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
						matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
						matC.setTranslate(localPos.x, localPos.y, localPos.z);
						var entity = this.entity.parent ? this.entity.parent : this.entity;
						matD.copy(entity.getWorldTransform());
						matD.mul(matC).mul(matB).mul(matA);
						vecA$2.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
						matD.transformPoint(vecA$2, this._worldCorners[0]);
						vecA$2.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
						matD.transformPoint(vecA$2, this._worldCorners[1]);
						vecA$2.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
						matD.transformPoint(vecA$2, this._worldCorners[2]);
						vecA$2.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
						matD.transformPoint(vecA$2, this._worldCorners[3]);
				}
				this._worldCornersDirty = false;
				return this._worldCorners;
		}
		set fontSize(arg) {
				this._setValue('fontSize', arg);
		}
		get fontSize() {
				if (this._text) {
						return this._text.fontSize;
				}
				return null;
		}
		set minFontSize(arg) {
				this._setValue('minFontSize', arg);
		}
		get minFontSize() {
				if (this._text) {
						return this._text.minFontSize;
				}
				return null;
		}
		set maxFontSize(arg) {
				this._setValue('maxFontSize', arg);
		}
		get maxFontSize() {
				if (this._text) {
						return this._text.maxFontSize;
				}
				return null;
		}
		set maxLines(arg) {
				this._setValue('maxLines', arg);
		}
		get maxLines() {
				if (this._text) {
						return this._text.maxLines;
				}
				return null;
		}
		set autoFitWidth(arg) {
				this._setValue('autoFitWidth', arg);
		}
		get autoFitWidth() {
				if (this._text) {
						return this._text.autoFitWidth;
				}
				return null;
		}
		set autoFitHeight(arg) {
				this._setValue('autoFitHeight', arg);
		}
		get autoFitHeight() {
				if (this._text) {
						return this._text.autoFitHeight;
				}
				return null;
		}
		set color(arg) {
				this._setValue('color', arg);
		}
		get color() {
				if (this._text) {
						return this._text.color;
				}
				if (this._image) {
						return this._image.color;
				}
				return null;
		}
		set font(arg) {
				this._setValue('font', arg);
		}
		get font() {
				if (this._text) {
						return this._text.font;
				}
				return null;
		}
		set fontAsset(arg) {
				this._setValue('fontAsset', arg);
		}
		get fontAsset() {
				if (this._text && typeof this._text.fontAsset === 'number') {
						return this._text.fontAsset;
				}
				return null;
		}
		set spacing(arg) {
				this._setValue('spacing', arg);
		}
		get spacing() {
				if (this._text) {
						return this._text.spacing;
				}
				return null;
		}
		set lineHeight(arg) {
				this._setValue('lineHeight', arg);
		}
		get lineHeight() {
				if (this._text) {
						return this._text.lineHeight;
				}
				return null;
		}
		set wrapLines(arg) {
				this._setValue('wrapLines', arg);
		}
		get wrapLines() {
				if (this._text) {
						return this._text.wrapLines;
				}
				return null;
		}
		set lines(arg) {
				this._setValue('lines', arg);
		}
		get lines() {
				if (this._text) {
						return this._text.lines;
				}
				return null;
		}
		set alignment(arg) {
				this._setValue('alignment', arg);
		}
		get alignment() {
				if (this._text) {
						return this._text.alignment;
				}
				return null;
		}
		set autoWidth(arg) {
				this._setValue('autoWidth', arg);
		}
		get autoWidth() {
				if (this._text) {
						return this._text.autoWidth;
				}
				return null;
		}
		set autoHeight(arg) {
				this._setValue('autoHeight', arg);
		}
		get autoHeight() {
				if (this._text) {
						return this._text.autoHeight;
				}
				return null;
		}
		set rtlReorder(arg) {
				this._setValue('rtlReorder', arg);
		}
		get rtlReorder() {
				if (this._text) {
						return this._text.rtlReorder;
				}
				return null;
		}
		set unicodeConverter(arg) {
				this._setValue('unicodeConverter', arg);
		}
		get unicodeConverter() {
				if (this._text) {
						return this._text.unicodeConverter;
				}
				return null;
		}
		set text(arg) {
				this._setValue('text', arg);
		}
		get text() {
				if (this._text) {
						return this._text.text;
				}
				return null;
		}
		set key(arg) {
				this._setValue('key', arg);
		}
		get key() {
				if (this._text) {
						return this._text.key;
				}
				return null;
		}
		set texture(arg) {
				this._setValue('texture', arg);
		}
		get texture() {
				if (this._image) {
						return this._image.texture;
				}
				return null;
		}
		set textureAsset(arg) {
				this._setValue('textureAsset', arg);
		}
		get textureAsset() {
				if (this._image) {
						return this._image.textureAsset;
				}
				return null;
		}
		set material(arg) {
				this._setValue('material', arg);
		}
		get material() {
				if (this._image) {
						return this._image.material;
				}
				return null;
		}
		set materialAsset(arg) {
				this._setValue('materialAsset', arg);
		}
		get materialAsset() {
				if (this._image) {
						return this._image.materialAsset;
				}
				return null;
		}
		set sprite(arg) {
				this._setValue('sprite', arg);
		}
		get sprite() {
				if (this._image) {
						return this._image.sprite;
				}
				return null;
		}
		set spriteAsset(arg) {
				this._setValue('spriteAsset', arg);
		}
		get spriteAsset() {
				if (this._image) {
						return this._image.spriteAsset;
				}
				return null;
		}
		set spriteFrame(arg) {
				this._setValue('spriteFrame', arg);
		}
		get spriteFrame() {
				if (this._image) {
						return this._image.spriteFrame;
				}
				return null;
		}
		set pixelsPerUnit(arg) {
				this._setValue('pixelsPerUnit', arg);
		}
		get pixelsPerUnit() {
				if (this._image) {
						return this._image.pixelsPerUnit;
				}
				return null;
		}
		set opacity(arg) {
				this._setValue('opacity', arg);
		}
		get opacity() {
				if (this._text) {
						return this._text.opacity;
				}
				if (this._image) {
						return this._image.opacity;
				}
				return null;
		}
		set rect(arg) {
				this._setValue('rect', arg);
		}
		get rect() {
				if (this._image) {
						return this._image.rect;
				}
				return null;
		}
		set mask(arg) {
				this._setValue('mask', arg);
		}
		get mask() {
				if (this._image) {
						return this._image.mask;
				}
				return null;
		}
		set outlineColor(arg) {
				this._setValue('outlineColor', arg);
		}
		get outlineColor() {
				if (this._text) {
						return this._text.outlineColor;
				}
				return null;
		}
		set outlineThickness(arg) {
				this._setValue('outlineThickness', arg);
		}
		get outlineThickness() {
				if (this._text) {
						return this._text.outlineThickness;
				}
				return null;
		}
		set shadowColor(arg) {
				this._setValue('shadowColor', arg);
		}
		get shadowColor() {
				if (this._text) {
						return this._text.shadowColor;
				}
				return null;
		}
		set shadowOffset(arg) {
				this._setValue('shadowOffset', arg);
		}
		get shadowOffset() {
				if (this._text) {
						return this._text.shadowOffset;
				}
				return null;
		}
		set enableMarkup(arg) {
				this._setValue('enableMarkup', arg);
		}
		get enableMarkup() {
				if (this._text) {
						return this._text.enableMarkup;
				}
				return null;
		}
		set rangeStart(arg) {
				this._setValue('rangeStart', arg);
		}
		get rangeStart() {
				if (this._text) {
						return this._text.rangeStart;
				}
				return null;
		}
		set rangeEnd(arg) {
				this._setValue('rangeEnd', arg);
		}
		get rangeEnd() {
				if (this._text) {
						return this._text.rangeEnd;
				}
				return null;
		}
		_setValue(name, value) {
				if (this._text) {
						if (this._text[name] !== value) {
								this._dirtyBatch();
						}
						this._text[name] = value;
				} else if (this._image) {
						if (this._image[name] !== value) {
								this._dirtyBatch();
						}
						this._image[name] = value;
				}
		}
		_patch() {
				this.entity._sync = this._sync;
				this.entity.setPosition = this._setPosition;
				this.entity.setLocalPosition = this._setLocalPosition;
		}
		_unpatch() {
				this.entity._sync = Entity.prototype._sync;
				this.entity.setPosition = Entity.prototype.setPosition;
				this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
		}
		_setPosition(x, y, z) {
				if (!this.element.screen) {
						Entity.prototype.setPosition.call(this, x, y, z);
						return;
				}
				if (x instanceof Vec3) {
						position.copy(x);
				} else {
						position.set(x, y, z);
				}
				this.getWorldTransform();
				invParentWtm.copy(this.element._screenToWorld).invert();
				invParentWtm.transformPoint(position, this.localPosition);
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		_setLocalPosition(x, y, z) {
				if (x instanceof Vec3) {
						this.localPosition.copy(x);
				} else {
						this.localPosition.set(x, y, z);
				}
				var element = this.element;
				var p = this.localPosition;
				var pvt = element._pivot;
				element._margin.x = p.x - element._calculatedWidth * pvt.x;
				element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
				element._margin.y = p.y - element._calculatedHeight * pvt.y;
				element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
				if (!this._dirtyLocal) {
						this._dirtifyLocal();
				}
		}
		_sync() {
				var element = this.element;
				var screen = element.screen;
				if (screen) {
						if (element._anchorDirty) {
								var resx = 0;
								var resy = 0;
								var px = 0;
								var py = 1;
								if (this._parent && this._parent.element) {
										resx = this._parent.element.calculatedWidth;
										resy = this._parent.element.calculatedHeight;
										px = this._parent.element.pivot.x;
										py = this._parent.element.pivot.y;
								} else {
										var resolution = screen.screen.resolution;
										resx = resolution.x / screen.screen.scale;
										resy = resolution.y / screen.screen.scale;
								}
								element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);
								element._anchorDirty = false;
								element._calculateLocalAnchors();
						}
						if (element._sizeDirty) {
								element._calculateSize(false, false);
						}
				}
				if (this._dirtyLocal) {
						this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
						var p = this.localPosition;
						var pvt = element._pivot;
						element._margin.x = p.x - element._calculatedWidth * pvt.x;
						element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
						element._margin.y = p.y - element._calculatedHeight * pvt.y;
						element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
						this._dirtyLocal = false;
				}
				if (!screen) {
						if (this._dirtyWorld) {
								element._cornersDirty = true;
								element._canvasCornersDirty = true;
								element._worldCornersDirty = true;
						}
						Entity.prototype._sync.call(this);
						return;
				}
				if (this._dirtyWorld) {
						if (this._parent === null) {
								this.worldTransform.copy(this.localTransform);
						} else {
								if (this._parent.element) {
										element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
								} else {
										element._screenToWorld.copy(element._anchorTransform);
								}
								element._modelTransform.mul2(element._screenToWorld, this.localTransform);
								if (screen) {
										element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
										if (!screen.screen.screenSpace) {
												element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
										}
										this.worldTransform.mul2(element._screenToWorld, this.localTransform);
										var parentWorldTransform = element._parentWorldTransform;
										parentWorldTransform.setIdentity();
										var parent = this._parent;
										if (parent && parent.element && parent !== screen) {
												matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
												parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
										}
										var depthOffset = vecA$2;
										depthOffset.set(0, 0, this.localPosition.z);
										var pivotOffset = vecB$2;
										pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
										matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
										matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
										matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
										element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
										element._cornersDirty = true;
										element._canvasCornersDirty = true;
										element._worldCornersDirty = true;
								} else {
										this.worldTransform.copy(element._modelTransform);
								}
						}
						this._dirtyWorld = false;
				}
		}
		_onInsert(parent) {
				var result = this._parseUpToScreen();
				this.entity._dirtifyWorld();
				this._updateScreen(result.screen);
				this._dirtifyMask();
		}
		_dirtifyMask() {
				var current = this.entity;
				while(current){
						var next = current.parent;
						if ((next === null || next.screen) && current.element) {
								if (!this.system._prerender || !this.system._prerender.length) {
										this.system._prerender = [];
										this.system.app.once('prerender', this._onPrerender, this);
								}
								var i = this.system._prerender.indexOf(this.entity);
								if (i >= 0) {
										this.system._prerender.splice(i, 1);
								}
								var j = this.system._prerender.indexOf(current);
								if (j < 0) {
										this.system._prerender.push(current);
								}
						}
						current = next;
				}
		}
		_onPrerender() {
				for(var i = 0; i < this.system._prerender.length; i++){
						var mask = this.system._prerender[i];
						if (mask.element) {
								var depth = 1;
								mask.element.syncMask(depth);
						}
				}
				this.system._prerender.length = 0;
		}
		_bindScreen(screen) {
				screen._bindElement(this);
		}
		_unbindScreen(screen) {
				screen._unbindElement(this);
		}
		_updateScreen(screen) {
				if (this.screen && this.screen !== screen) {
						this._unbindScreen(this.screen.screen);
				}
				var previousScreen = this.screen;
				this.screen = screen;
				if (this.screen) {
						this._bindScreen(this.screen.screen);
				}
				this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
				this.fire('set:screen', this.screen, previousScreen);
				this._anchorDirty = true;
				var children = this.entity.children;
				for(var i = 0, l = children.length; i < l; i++){
						if (children[i].element) {
								children[i].element._updateScreen(screen);
						}
				}
				if (this.screen) {
						this.screen.screen.syncDrawOrder();
				}
		}
		syncMask(depth) {
				var result = this._parseUpToScreen();
				this._updateMask(result.mask, depth);
		}
		_setMaskedBy(mask) {
				var renderableElement = this._image || this._text;
				if (mask) {
						var ref = mask.element._image._maskRef;
						renderableElement == null ? void 0 : renderableElement._setStencil(new StencilParameters({
								ref: ref,
								func: FUNC_EQUAL
						}));
						this._maskedBy = mask;
				} else {
						renderableElement == null ? void 0 : renderableElement._setStencil(null);
						this._maskedBy = null;
				}
		}
		_updateMask(currentMask, depth) {
				if (currentMask) {
						this._setMaskedBy(currentMask);
						if (this.mask) {
								var ref = currentMask.element._image._maskRef;
								var sp = new StencilParameters({
										ref: ref,
										func: FUNC_EQUAL,
										zpass: STENCILOP_INCREMENT
								});
								this._image._setStencil(sp);
								this._image._maskRef = depth;
								depth++;
								currentMask = this.entity;
						}
						var children = this.entity.children;
						for(var i = 0, l = children.length; i < l; i++){
								var _children_i_element;
								(_children_i_element = children[i].element) == null ? void 0 : _children_i_element._updateMask(currentMask, depth);
						}
						if (this.mask) depth--;
				} else {
						this._setMaskedBy(null);
						if (this.mask) {
								var sp1 = new StencilParameters({
										ref: depth,
										func: FUNC_ALWAYS,
										zpass: STENCILOP_REPLACE
								});
								this._image._setStencil(sp1);
								this._image._maskRef = depth;
								depth++;
								currentMask = this.entity;
						}
						var children1 = this.entity.children;
						for(var i1 = 0, l1 = children1.length; i1 < l1; i1++){
								var _children_i_element1;
								(_children_i_element1 = children1[i1].element) == null ? void 0 : _children_i_element1._updateMask(currentMask, depth);
						}
						if (this.mask) {
								depth--;
						}
				}
		}
		_parseUpToScreen() {
				var result = {
						screen: null,
						mask: null
				};
				var parent = this.entity._parent;
				while(parent && !parent.screen){
						if (parent.element && parent.element.mask) {
								if (!result.mask) result.mask = parent;
						}
						parent = parent.parent;
				}
				if (parent && parent.screen) {
						result.screen = parent;
				}
				return result;
		}
		_onScreenResize(res) {
				this._anchorDirty = true;
				this._cornersDirty = true;
				this._worldCornersDirty = true;
				this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
				this.fire('screen:set:resolution', res);
		}
		_onScreenSpaceChange() {
				this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
		}
		_onScreenRemove() {
				if (this.screen) {
						if (this.screen._destroying) {
								this.screen = null;
						} else {
								this._updateScreen(null);
						}
				}
		}
		_calculateLocalAnchors() {
				var resx = 1000;
				var resy = 1000;
				var parent = this.entity._parent;
				if (parent && parent.element) {
						resx = parent.element.calculatedWidth;
						resy = parent.element.calculatedHeight;
				} else if (this.screen) {
						var res = this.screen.screen.resolution;
						var scale = this.screen.screen.scale;
						resx = res.x / scale;
						resy = res.y / scale;
				}
				this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
		}
		getOffsetPosition(x, y) {
				var p = this.entity.getLocalPosition().clone();
				p.x += x;
				p.y += y;
				this._screenToWorld.transformPoint(p, p);
				return p;
		}
		onLayersChanged(oldComp, newComp) {
				this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				if (this._image) {
						layer.addMeshInstances(this._image._renderable.model.meshInstances);
				} else if (this._text) {
						layer.addMeshInstances(this._text._model.meshInstances);
				}
		}
		onLayerRemoved(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				if (this._image) {
						layer.removeMeshInstances(this._image._renderable.model.meshInstances);
				} else if (this._text) {
						layer.removeMeshInstances(this._text._model.meshInstances);
				}
		}
		onEnable() {
				var scene = this.system.app.scene;
				var layers = scene.layers;
				if (this._image) {
						this._image.onEnable();
				}
				if (this._text) {
						this._text.onEnable();
				}
				if (this._group) {
						this._group.onEnable();
				}
				if (this.useInput && this.system.app.elementInput) {
						this.system.app.elementInput.addElement(this);
				}
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				if (this._batchGroupId >= 0) {
						var _this_system_app_batcher;
						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
				}
				this.fire('enableelement');
		}
		onDisable() {
				var _this__evtLayersChanged;
				var scene = this.system.app.scene;
				var layers = scene.layers;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				if (this._image) this._image.onDisable();
				if (this._text) this._text.onDisable();
				if (this._group) this._group.onDisable();
				if (this.system.app.elementInput && this.useInput) {
						this.system.app.elementInput.removeElement(this);
				}
				if (this._batchGroupId >= 0) {
						var _this_system_app_batcher;
						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
				}
				this.fire('disableelement');
		}
		onRemove() {
				this.entity.off('insert', this._onInsert, this);
				this._unpatch();
				if (this._image) {
						this._image.destroy();
				}
				if (this._text) {
						this._text.destroy();
				}
				if (this.system.app.elementInput && this.useInput) {
						this.system.app.elementInput.removeElement(this);
				}
				if (this.screen && this.screen.screen) {
						this._unbindScreen(this.screen.screen);
						this.screen.screen.syncDrawOrder();
				}
				this.off();
		}
		_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
				if (!this.entity._parent && !this.screen) {
						return;
				}
				this._calculateLocalAnchors();
				var newWidth = this._absRight - this._absLeft;
				var newHeight = this._absTop - this._absBottom;
				if (propagateCalculatedWidth) {
						this._setWidth(newWidth);
				} else {
						this._setCalculatedWidth(newWidth, false);
				}
				if (propagateCalculatedHeight) {
						this._setHeight(newHeight);
				} else {
						this._setCalculatedHeight(newHeight, false);
				}
				var p = this.entity.getLocalPosition();
				p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
				p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
				this.entity.setLocalPosition(p);
				this._sizeDirty = false;
		}
		_setWidth(w) {
				this._width = w;
				this._setCalculatedWidth(w, false);
				this.fire('set:width', this._width);
		}
		_setHeight(h) {
				this._height = h;
				this._setCalculatedHeight(h, false);
				this.fire('set:height', this._height);
		}
		_setCalculatedWidth(value, updateMargins) {
				if (Math.abs(value - this._calculatedWidth) <= 1e-4) {
						return;
				}
				this._calculatedWidth = value;
				this.entity._dirtifyLocal();
				if (updateMargins) {
						var p = this.entity.getLocalPosition();
						var pvt = this._pivot;
						this._margin.x = p.x - this._calculatedWidth * pvt.x;
						this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
				}
				this._flagChildrenAsDirty();
				this.fire('set:calculatedWidth', this._calculatedWidth);
				this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		}
		_setCalculatedHeight(value, updateMargins) {
				if (Math.abs(value - this._calculatedHeight) <= 1e-4) {
						return;
				}
				this._calculatedHeight = value;
				this.entity._dirtifyLocal();
				if (updateMargins) {
						var p = this.entity.getLocalPosition();
						var pvt = this._pivot;
						this._margin.y = p.y - this._calculatedHeight * pvt.y;
						this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
				}
				this._flagChildrenAsDirty();
				this.fire('set:calculatedHeight', this._calculatedHeight);
				this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		}
		_flagChildrenAsDirty() {
				var c = this.entity._children;
				for(var i = 0, l = c.length; i < l; i++){
						if (c[i].element) {
								c[i].element._anchorDirty = true;
								c[i].element._sizeDirty = true;
						}
				}
		}
		addModelToLayers(model) {
				this._addedModels.push(model);
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (!layer) continue;
						layer.addMeshInstances(model.meshInstances);
				}
		}
		removeModelFromLayers(model) {
				var idx = this._addedModels.indexOf(model);
				if (idx >= 0) {
						this._addedModels.splice(idx, 1);
				}
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (!layer) {
								continue;
						}
						layer.removeMeshInstances(model.meshInstances);
				}
		}
		getMaskOffset() {
				var frame = this.system.app.frame;
				if (this._offsetReadAt !== frame) {
						this._maskOffset = 0.5;
						this._offsetReadAt = frame;
				}
				var mo = this._maskOffset;
				this._maskOffset -= 0.001;
				return mo;
		}
		isVisibleForCamera(camera) {
				var clipL, clipR, clipT, clipB;
				if (this.maskedBy) {
						var corners = this.maskedBy.element.screenCorners;
						clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
						clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
						clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
						clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
				} else {
						var sw = this.system.app.graphicsDevice.width;
						var sh = this.system.app.graphicsDevice.height;
						var cameraWidth = camera._rect.z * sw;
						var cameraHeight = camera._rect.w * sh;
						clipL = camera._rect.x * sw;
						clipR = clipL + cameraWidth;
						clipT = (1 - camera._rect.y) * sh;
						clipB = clipT - cameraHeight;
				}
				var hitCorners = this.screenCorners;
				var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
				var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
				var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
				var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));
				if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
						return false;
				}
				return true;
		}
		_isScreenSpace() {
				if (this.screen && this.screen.screen) {
						return this.screen.screen.screenSpace;
				}
				return false;
		}
		_isScreenCulled() {
				if (this.screen && this.screen.screen) {
						return this.screen.screen.cull;
				}
				return false;
		}
		_dirtyBatch() {
				if (this.batchGroupId !== -1) {
						var _this_system_app_batcher;
						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.markGroupDirty(this.batchGroupId);
				}
		}
		constructor(system, entity){
				super(system, entity), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
				this._beingInitialized = false;
				this._anchor = new Vec4();
				this._localAnchor = new Vec4();
				this._pivot = new Vec2();
				this._width = this._calculatedWidth = 32;
				this._height = this._calculatedHeight = 32;
				this._margin = new Vec4(0, 0, -32, -32);
				this._modelTransform = new Mat4();
				this._screenToWorld = new Mat4();
				this._anchorTransform = new Mat4();
				this._anchorDirty = true;
				this._parentWorldTransform = new Mat4();
				this._screenTransform = new Mat4();
				this._screenCorners = [
						new Vec3(),
						new Vec3(),
						new Vec3(),
						new Vec3()
				];
				this._canvasCorners = [
						new Vec2(),
						new Vec2(),
						new Vec2(),
						new Vec2()
				];
				this._worldCorners = [
						new Vec3(),
						new Vec3(),
						new Vec3(),
						new Vec3()
				];
				this._cornersDirty = true;
				this._canvasCornersDirty = true;
				this._worldCornersDirty = true;
				this.entity.on('insert', this._onInsert, this);
				this._patch();
				this.screen = null;
				this._type = ELEMENTTYPE_GROUP;
				this._image = null;
				this._text = null;
				this._group = null;
				this._drawOrder = 0;
				this._fitMode = FITMODE_STRETCH;
				this._useInput = false;
				this._layers = [
						LAYERID_UI
				];
				this._addedModels = [];
				this._batchGroupId = -1;
				this._offsetReadAt = 0;
				this._maskOffset = 0.5;
				this._maskedBy = null;
		}
}
ElementComponent.EVENT_MOUSEDOWN = 'mousedown';
ElementComponent.EVENT_MOUSEUP = 'mouseup';
ElementComponent.EVENT_MOUSEENTER = 'mouseenter';
ElementComponent.EVENT_MOUSELEAVE = 'mouseleave';
ElementComponent.EVENT_MOUSEMOVE = 'mousemove';
ElementComponent.EVENT_MOUSEWHEEL = 'mousewheel';
ElementComponent.EVENT_CLICK = 'click';
ElementComponent.EVENT_TOUCHSTART = 'touchstart';
ElementComponent.EVENT_TOUCHEND = 'touchend';
ElementComponent.EVENT_TOUCHMOVE = 'touchmove';
ElementComponent.EVENT_TOUCHCANCEL = 'touchcancel';

class ElementComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$f = [
		'enabled'
];
class ElementComponentSystem extends ComponentSystem {
		destroy() {
				super.destroy();
				this._defaultTexture.destroy();
		}
		initializeComponentData(component, data, properties) {
				component._beingInitialized = true;
				if (data.anchor !== undefined) {
						if (data.anchor instanceof Vec4) {
								component.anchor.copy(data.anchor);
						} else {
								component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
						}
				}
				if (data.pivot !== undefined) {
						if (data.pivot instanceof Vec2) {
								component.pivot.copy(data.pivot);
						} else {
								component.pivot.set(data.pivot[0], data.pivot[1]);
						}
				}
				var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
				var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
				var _marginChange = false;
				var color;
				if (data.margin !== undefined) {
						if (data.margin instanceof Vec4) {
								component.margin.copy(data.margin);
						} else {
								component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
						}
						_marginChange = true;
				}
				if (data.left !== undefined) {
						component._margin.x = data.left;
						_marginChange = true;
				}
				if (data.bottom !== undefined) {
						component._margin.y = data.bottom;
						_marginChange = true;
				}
				if (data.right !== undefined) {
						component._margin.z = data.right;
						_marginChange = true;
				}
				if (data.top !== undefined) {
						component._margin.w = data.top;
						_marginChange = true;
				}
				if (_marginChange) {
						component.margin = component._margin;
				}
				var shouldForceSetAnchor = false;
				if (data.width !== undefined && !splitHorAnchors) {
						component.width = data.width;
				} else if (splitHorAnchors) {
						shouldForceSetAnchor = true;
				}
				if (data.height !== undefined && !splitVerAnchors) {
						component.height = data.height;
				} else if (splitVerAnchors) {
						shouldForceSetAnchor = true;
				}
				if (shouldForceSetAnchor) {
						component.anchor = component.anchor;
				}
				if (data.enabled !== undefined) {
						component.enabled = data.enabled;
				}
				if (data.useInput !== undefined) {
						component.useInput = data.useInput;
				}
				if (data.fitMode !== undefined) {
						component.fitMode = data.fitMode;
				}
				component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
				if (data.layers && Array.isArray(data.layers)) {
						component.layers = data.layers.slice(0);
				}
				if (data.type !== undefined) {
						component.type = data.type;
				}
				if (component.type === ELEMENTTYPE_IMAGE) {
						if (data.rect !== undefined) {
								component.rect = data.rect;
						}
						if (data.color !== undefined) {
								color = data.color;
								if (!(color instanceof Color)) {
										color = new Color(data.color[0], data.color[1], data.color[2]);
								}
								component.color = color;
						}
						if (data.opacity !== undefined) component.opacity = data.opacity;
						if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
						if (data.texture) component.texture = data.texture;
						if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
						if (data.sprite) component.sprite = data.sprite;
						if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
						if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
						if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
						if (data.material) component.material = data.material;
						if (data.mask !== undefined) {
								component.mask = data.mask;
						}
				} else if (component.type === ELEMENTTYPE_TEXT) {
						if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
						if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
						if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
						if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;
						if (data.text !== null && data.text !== undefined) {
								component.text = data.text;
						} else if (data.key !== null && data.key !== undefined) {
								component.key = data.key;
						}
						if (data.color !== undefined) {
								color = data.color;
								if (!(color instanceof Color)) {
										color = new Color(color[0], color[1], color[2]);
								}
								component.color = color;
						}
						if (data.opacity !== undefined) {
								component.opacity = data.opacity;
						}
						if (data.spacing !== undefined) component.spacing = data.spacing;
						if (data.fontSize !== undefined) {
								component.fontSize = data.fontSize;
								if (!data.lineHeight) component.lineHeight = data.fontSize;
						}
						if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
						if (data.maxLines !== undefined) component.maxLines = data.maxLines;
						if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
						if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
						if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
						if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
						if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
						if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
						if (data.font !== undefined) component.font = data.font;
						if (data.alignment !== undefined) component.alignment = data.alignment;
						if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
						if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
						if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
						if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
						if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
				}
				var result = component._parseUpToScreen();
				if (result.screen) {
						component._updateScreen(result.screen);
				}
				super.initializeComponentData(component, data, properties);
				component._beingInitialized = false;
				if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
						component._image._updateMesh(component._image.mesh);
				}
		}
		onAddComponent(entity, component) {
				entity.fire('element:add');
		}
		onRemoveComponent(entity, component) {
				component.onRemove();
		}
		cloneComponent(entity, clone) {
				var source = entity.element;
				var data = {
						enabled: source.enabled,
						width: source.width,
						height: source.height,
						anchor: source.anchor.clone(),
						pivot: source.pivot.clone(),
						margin: source.margin.clone(),
						alignment: source.alignment && source.alignment.clone() || source.alignment,
						autoWidth: source.autoWidth,
						autoHeight: source.autoHeight,
						type: source.type,
						rect: source.rect && source.rect.clone() || source.rect,
						rtlReorder: source.rtlReorder,
						unicodeConverter: source.unicodeConverter,
						materialAsset: source.materialAsset,
						material: source.material,
						color: source.color && source.color.clone() || source.color,
						opacity: source.opacity,
						textureAsset: source.textureAsset,
						texture: source.texture,
						spriteAsset: source.spriteAsset,
						sprite: source.sprite,
						spriteFrame: source.spriteFrame,
						pixelsPerUnit: source.pixelsPerUnit,
						spacing: source.spacing,
						lineHeight: source.lineHeight,
						wrapLines: source.wrapLines,
						layers: source.layers,
						fontSize: source.fontSize,
						minFontSize: source.minFontSize,
						maxFontSize: source.maxFontSize,
						autoFitWidth: source.autoFitWidth,
						autoFitHeight: source.autoFitHeight,
						maxLines: source.maxLines,
						fontAsset: source.fontAsset,
						font: source.font,
						useInput: source.useInput,
						fitMode: source.fitMode,
						batchGroupId: source.batchGroupId,
						mask: source.mask,
						outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
						outlineThickness: source.outlineThickness,
						shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
						shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
						enableMarkup: source.enableMarkup
				};
				if (source.key !== undefined && source.key !== null) {
						data.key = source.key;
				} else {
						data.text = source.text;
				}
				return this.addComponent(clone, data);
		}
		getTextElementMaterial(screenSpace, msdf, textAttibutes) {
				var hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);
				var material = this._defaultTextMaterials[hash];
				if (material) {
						return material;
				}
				var name = 'TextMaterial';
				material = new StandardMaterial();
				if (msdf) {
						material.msdfMap = this._defaultTexture;
						material.msdfTextAttribute = textAttibutes;
						material.emissive.set(1, 1, 1);
				} else {
						name = "Bitmap" + name;
						material.emissive.set(1, 1, 1);
						material.emissiveMap = this._defaultTexture;
						material.opacityMap = this._defaultTexture;
						material.opacityMapChannel = 'a';
				}
				if (screenSpace) {
						name = "ScreenSpace" + name;
						material.depthTest = false;
				}
				material.name = "default" + name;
				material.useLighting = false;
				material.useTonemap = false;
				material.useFog = false;
				material.useSkybox = false;
				material.diffuse.set(0, 0, 0);
				material.opacity = 0.5;
				material.blendType = BLEND_PREMULTIPLIED;
				material.depthWrite = false;
				material.emissiveVertexColor = true;
				material.update();
				this._defaultTextMaterials[hash] = material;
				return material;
		}
		_createBaseImageMaterial() {
				var material = new StandardMaterial();
				material.diffuse.set(0, 0, 0);
				material.emissive.set(1, 1, 1);
				material.emissiveMap = this._defaultTexture;
				material.opacityMap = this._defaultTexture;
				material.opacityMapChannel = 'a';
				material.useLighting = false;
				material.useTonemap = false;
				material.useFog = false;
				material.useSkybox = false;
				material.blendType = BLEND_PREMULTIPLIED;
				material.depthWrite = false;
				return material;
		}
		getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
				if (screenSpace) {
						if (mask) {
								if (nineSliced) {
										if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
												this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
												this.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';
												this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
												this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
												this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
												this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
												this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
												this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
												this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
												this.defaultScreenSpaceImageMask9SlicedMaterial.update();
												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
										}
										return this.defaultScreenSpaceImageMask9SlicedMaterial;
								} else if (nineSliceTiled) {
										if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
												this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
												this.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';
												this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
												this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
												this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
												this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
												this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
												this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
												this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
												this.defaultScreenSpaceImageMask9TiledMaterial.update();
												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
										}
										return this.defaultScreenSpaceImageMask9TiledMaterial;
								} else {
										if (!this.defaultScreenSpaceImageMaskMaterial) {
												this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
												this.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';
												this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
												this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
												this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
												this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
												this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
												this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
												this.defaultScreenSpaceImageMaskMaterial.update();
												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
										}
										return this.defaultScreenSpaceImageMaskMaterial;
								}
						} else {
								if (nineSliced) {
										if (!this.defaultScreenSpaceImage9SlicedMaterial) {
												this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
												this.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';
												this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
												this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
												this.defaultScreenSpaceImage9SlicedMaterial.update();
												this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
										}
										return this.defaultScreenSpaceImage9SlicedMaterial;
								} else if (nineSliceTiled) {
										if (!this.defaultScreenSpaceImage9TiledMaterial) {
												this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
												this.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';
												this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
												this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
												this.defaultScreenSpaceImage9TiledMaterial.update();
												this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
										}
										return this.defaultScreenSpaceImage9TiledMaterial;
								} else {
										if (!this.defaultScreenSpaceImageMaterial) {
												this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
												this.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';
												this.defaultScreenSpaceImageMaterial.depthTest = false;
												this.defaultScreenSpaceImageMaterial.update();
												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
										}
										return this.defaultScreenSpaceImageMaterial;
								}
						}
				} else {
						if (mask) {
								if (nineSliced) {
										if (!this.defaultImage9SlicedMaskMaterial) {
												this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
												this.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';
												this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
												this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
												this.defaultImage9SlicedMaskMaterial.redWrite = false;
												this.defaultImage9SlicedMaskMaterial.greenWrite = false;
												this.defaultImage9SlicedMaskMaterial.blueWrite = false;
												this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
												this.defaultImage9SlicedMaskMaterial.update();
												this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
										}
										return this.defaultImage9SlicedMaskMaterial;
								} else if (nineSliceTiled) {
										if (!this.defaultImage9TiledMaskMaterial) {
												this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
												this.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';
												this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
												this.defaultImage9TiledMaskMaterial.alphaTest = 1;
												this.defaultImage9TiledMaskMaterial.redWrite = false;
												this.defaultImage9TiledMaskMaterial.greenWrite = false;
												this.defaultImage9TiledMaskMaterial.blueWrite = false;
												this.defaultImage9TiledMaskMaterial.alphaWrite = false;
												this.defaultImage9TiledMaskMaterial.update();
												this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
										}
										return this.defaultImage9TiledMaskMaterial;
								} else {
										if (!this.defaultImageMaskMaterial) {
												this.defaultImageMaskMaterial = this._createBaseImageMaterial();
												this.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';
												this.defaultImageMaskMaterial.alphaTest = 1;
												this.defaultImageMaskMaterial.redWrite = false;
												this.defaultImageMaskMaterial.greenWrite = false;
												this.defaultImageMaskMaterial.blueWrite = false;
												this.defaultImageMaskMaterial.alphaWrite = false;
												this.defaultImageMaskMaterial.update();
												this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
										}
										return this.defaultImageMaskMaterial;
								}
						} else {
								if (nineSliced) {
										if (!this.defaultImage9SlicedMaterial) {
												this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
												this.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';
												this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
												this.defaultImage9SlicedMaterial.update();
												this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
										}
										return this.defaultImage9SlicedMaterial;
								} else if (nineSliceTiled) {
										if (!this.defaultImage9TiledMaterial) {
												this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
												this.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';
												this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
												this.defaultImage9TiledMaterial.update();
												this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
										}
										return this.defaultImage9TiledMaterial;
								} else {
										if (!this.defaultImageMaterial) {
												this.defaultImageMaterial = this._createBaseImageMaterial();
												this.defaultImageMaterial.name = 'defaultImageMaterial';
												this.defaultImageMaterial.update();
												this.defaultImageMaterials.push(this.defaultImageMaterial);
										}
										return this.defaultImageMaterial;
								}
						}
				}
		}
		registerUnicodeConverter(func) {
				this._unicodeConverter = func;
		}
		registerRtlReorder(func) {
				this._rtlReorder = func;
		}
		getUnicodeConverter() {
				return this._unicodeConverter;
		}
		getRtlReorder() {
				return this._rtlReorder;
		}
		constructor(app){
				super(app);
				this.id = 'element';
				this.ComponentType = ElementComponent;
				this.DataType = ElementComponentData;
				this.schema = _schema$f;
				this._unicodeConverter = null;
				this._rtlReorder = null;
				this._defaultTexture = new Texture(app.graphicsDevice, {
						width: 1,
						height: 1,
						format: PIXELFORMAT_SRGBA8,
						name: 'element-system'
				});
				var pixels = this._defaultTexture.lock();
				var pixelData = new Uint8Array(4);
				pixelData[0] = 255.0;
				pixelData[1] = 255.0;
				pixelData[2] = 255.0;
				pixelData[3] = 255.0;
				pixels.set(pixelData);
				this._defaultTexture.unlock();
				this.defaultImageMaterial = null;
				this.defaultImage9SlicedMaterial = null;
				this.defaultImage9TiledMaterial = null;
				this.defaultImageMaskMaterial = null;
				this.defaultImage9SlicedMaskMaterial = null;
				this.defaultImage9TiledMaskMaterial = null;
				this.defaultScreenSpaceImageMaterial = null;
				this.defaultScreenSpaceImage9SlicedMaterial = null;
				this.defaultScreenSpaceImage9TiledMaterial = null;
				this.defaultScreenSpaceImageMask9SlicedMaterial = null;
				this.defaultScreenSpaceImageMask9TiledMaterial = null;
				this.defaultScreenSpaceImageMaskMaterial = null;
				this._defaultTextMaterials = {};
				this.defaultImageMaterials = [];
				this.on('add', this.onAddComponent, this);
				this.on('beforeremove', this.onRemoveComponent, this);
		}
}

var MOTION_FREE = 'free';
var MOTION_LIMITED = 'limited';
var MOTION_LOCKED = 'locked';

var properties$1 = [
		'angularDampingX',
		'angularDampingY',
		'angularDampingZ',
		'angularEquilibriumX',
		'angularEquilibriumY',
		'angularEquilibriumZ',
		'angularLimitsX',
		'angularLimitsY',
		'angularLimitsZ',
		'angularMotionX',
		'angularMotionY',
		'angularMotionZ',
		'angularSpringX',
		'angularSpringY',
		'angularSpringZ',
		'angularStiffnessX',
		'angularStiffnessY',
		'angularStiffnessZ',
		'breakForce',
		'enableCollision',
		'enabled',
		'entityA',
		'entityB',
		'linearDampingX',
		'linearDampingY',
		'linearDampingZ',
		'linearEquilibriumX',
		'linearEquilibriumY',
		'linearEquilibriumZ',
		'linearLimitsX',
		'linearLimitsY',
		'linearLimitsZ',
		'linearMotionX',
		'linearMotionY',
		'linearMotionZ',
		'linearSpringX',
		'linearSpringY',
		'linearSpringZ',
		'linearStiffnessX',
		'linearStiffnessY',
		'linearStiffnessZ'
];
class JointComponent extends Component {
		set entityA(body) {
				this._destroyConstraint();
				this._entityA = body;
				this._createConstraint();
		}
		get entityA() {
				return this._entityA;
		}
		set entityB(body) {
				this._destroyConstraint();
				this._entityB = body;
				this._createConstraint();
		}
		get entityB() {
				return this._entityB;
		}
		set breakForce(force) {
				if (this._constraint && this._breakForce !== force) {
						this._constraint.setBreakingImpulseThreshold(force);
						this._breakForce = force;
				}
		}
		get breakForce() {
				return this._breakForce;
		}
		set enableCollision(enableCollision) {
				this._destroyConstraint();
				this._enableCollision = enableCollision;
				this._createConstraint();
		}
		get enableCollision() {
				return this._enableCollision;
		}
		set angularLimitsX(limits) {
				if (!this._angularLimitsX.equals(limits)) {
						this._angularLimitsX.copy(limits);
						this._updateAngularLimits();
				}
		}
		get angularLimitsX() {
				return this._angularLimitsX;
		}
		set angularMotionX(value) {
				if (this._angularMotionX !== value) {
						this._angularMotionX = value;
						this._updateAngularLimits();
				}
		}
		get angularMotionX() {
				return this._angularMotionX;
		}
		set angularLimitsY(limits) {
				if (!this._angularLimitsY.equals(limits)) {
						this._angularLimitsY.copy(limits);
						this._updateAngularLimits();
				}
		}
		get angularLimitsY() {
				return this._angularLimitsY;
		}
		set angularMotionY(value) {
				if (this._angularMotionY !== value) {
						this._angularMotionY = value;
						this._updateAngularLimits();
				}
		}
		get angularMotionY() {
				return this._angularMotionY;
		}
		set angularLimitsZ(limits) {
				if (!this._angularLimitsZ.equals(limits)) {
						this._angularLimitsZ.copy(limits);
						this._updateAngularLimits();
				}
		}
		get angularLimitsZ() {
				return this._angularLimitsZ;
		}
		set angularMotionZ(value) {
				if (this._angularMotionZ !== value) {
						this._angularMotionZ = value;
						this._updateAngularLimits();
				}
		}
		get angularMotionZ() {
				return this._angularMotionZ;
		}
		set linearLimitsX(limits) {
				if (!this._linearLimitsX.equals(limits)) {
						this._linearLimitsX.copy(limits);
						this._updateLinearLimits();
				}
		}
		get linearLimitsX() {
				return this._linearLimitsX;
		}
		set linearMotionX(value) {
				if (this._linearMotionX !== value) {
						this._linearMotionX = value;
						this._updateLinearLimits();
				}
		}
		get linearMotionX() {
				return this._linearMotionX;
		}
		set linearLimitsY(limits) {
				if (!this._linearLimitsY.equals(limits)) {
						this._linearLimitsY.copy(limits);
						this._updateLinearLimits();
				}
		}
		get linearLimitsY() {
				return this._linearLimitsY;
		}
		set linearMotionY(value) {
				if (this._linearMotionY !== value) {
						this._linearMotionY = value;
						this._updateLinearLimits();
				}
		}
		get linearMotionY() {
				return this._linearMotionY;
		}
		set linearLimitsZ(limits) {
				if (!this._linearLimitsZ.equals(limits)) {
						this._linearLimitsZ.copy(limits);
						this._updateLinearLimits();
				}
		}
		get linearLimitsZ() {
				return this._linearLimitsZ;
		}
		set linearMotionZ(value) {
				if (this._linearMotionZ !== value) {
						this._linearMotionZ = value;
						this._updateLinearLimits();
				}
		}
		get linearMotionZ() {
				return this._linearMotionZ;
		}
		_convertTransform(pcTransform, ammoTransform) {
				var pos = pcTransform.getTranslation();
				var rot = new Quat();
				rot.setFromMat4(pcTransform);
				var ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
				var ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
				ammoTransform.setOrigin(ammoVec);
				ammoTransform.setRotation(ammoQuat);
				Ammo.destroy(ammoVec);
				Ammo.destroy(ammoQuat);
		}
		_updateAngularLimits() {
				var constraint = this._constraint;
				if (constraint) {
						var lx, ly, lz, ux, uy, uz;
						if (this._angularMotionX === MOTION_LIMITED) {
								lx = this._angularLimitsX.x * math.DEG_TO_RAD;
								ux = this._angularLimitsX.y * math.DEG_TO_RAD;
						} else if (this._angularMotionX === MOTION_FREE) {
								lx = 1;
								ux = 0;
						} else {
								lx = ux = 0;
						}
						if (this._angularMotionY === MOTION_LIMITED) {
								ly = this._angularLimitsY.x * math.DEG_TO_RAD;
								uy = this._angularLimitsY.y * math.DEG_TO_RAD;
						} else if (this._angularMotionY === MOTION_FREE) {
								ly = 1;
								uy = 0;
						} else {
								ly = uy = 0;
						}
						if (this._angularMotionZ === MOTION_LIMITED) {
								lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
								uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
						} else if (this._angularMotionZ === MOTION_FREE) {
								lz = 1;
								uz = 0;
						} else {
								lz = uz = 0;
						}
						var limits = new Ammo.btVector3(lx, ly, lz);
						constraint.setAngularLowerLimit(limits);
						limits.setValue(ux, uy, uz);
						constraint.setAngularUpperLimit(limits);
						Ammo.destroy(limits);
				}
		}
		_updateLinearLimits() {
				var constraint = this._constraint;
				if (constraint) {
						var lx, ly, lz, ux, uy, uz;
						if (this._linearMotionX === MOTION_LIMITED) {
								lx = this._linearLimitsX.x;
								ux = this._linearLimitsX.y;
						} else if (this._linearMotionX === MOTION_FREE) {
								lx = 1;
								ux = 0;
						} else {
								lx = ux = 0;
						}
						if (this._linearMotionY === MOTION_LIMITED) {
								ly = this._linearLimitsY.x;
								uy = this._linearLimitsY.y;
						} else if (this._linearMotionY === MOTION_FREE) {
								ly = 1;
								uy = 0;
						} else {
								ly = uy = 0;
						}
						if (this._linearMotionZ === MOTION_LIMITED) {
								lz = this._linearLimitsZ.x;
								uz = this._linearLimitsZ.y;
						} else if (this._linearMotionZ === MOTION_FREE) {
								lz = 1;
								uz = 0;
						} else {
								lz = uz = 0;
						}
						var limits = new Ammo.btVector3(lx, ly, lz);
						constraint.setLinearLowerLimit(limits);
						limits.setValue(ux, uy, uz);
						constraint.setLinearUpperLimit(limits);
						Ammo.destroy(limits);
				}
		}
		_createConstraint() {
				if (this._entityA && this._entityA.rigidbody) {
						this._destroyConstraint();
						var mat = new Mat4();
						var bodyA = this._entityA.rigidbody.body;
						bodyA.activate();
						var jointWtm = this.entity.getWorldTransform();
						var entityAWtm = this._entityA.getWorldTransform();
						var invEntityAWtm = entityAWtm.clone().invert();
						mat.mul2(invEntityAWtm, jointWtm);
						var frameA = new Ammo.btTransform();
						this._convertTransform(mat, frameA);
						if (this._entityB && this._entityB.rigidbody) {
								var bodyB = this._entityB.rigidbody.body;
								bodyB.activate();
								var entityBWtm = this._entityB.getWorldTransform();
								var invEntityBWtm = entityBWtm.clone().invert();
								mat.mul2(invEntityBWtm, jointWtm);
								var frameB = new Ammo.btTransform();
								this._convertTransform(mat, frameB);
								this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
								Ammo.destroy(frameB);
						} else {
								this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
						}
						Ammo.destroy(frameA);
						var axis = [
								'X',
								'Y',
								'Z',
								'X',
								'Y',
								'Z'
						];
						for(var i = 0; i < 6; i++){
								var type = i < 3 ? '_linear' : '_angular';
								this._constraint.enableSpring(i, this[type + "Spring" + axis[i]]);
								this._constraint.setDamping(i, this[type + "Damping" + axis[i]]);
								this._constraint.setEquilibriumPoint(i, this[type + "Equilibrium" + axis[i]]);
								this._constraint.setStiffness(i, this[type + "Stiffness" + axis[i]]);
						}
						this._constraint.setBreakingImpulseThreshold(this._breakForce);
						this._updateLinearLimits();
						this._updateAngularLimits();
						var app = this.system.app;
						var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
						dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
				}
		}
		_destroyConstraint() {
				if (this._constraint) {
						var app = this.system.app;
						var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
						dynamicsWorld.removeConstraint(this._constraint);
						Ammo.destroy(this._constraint);
						this._constraint = null;
				}
		}
		initFromData(data) {
				for (var prop of properties$1){
						if (data.hasOwnProperty(prop)) {
								if (data[prop] instanceof Vec2) {
										this["_" + prop].copy(data[prop]);
								} else {
										this["_" + prop] = data[prop];
								}
						}
				}
				this._createConstraint();
		}
		onEnable() {
				this._createConstraint();
		}
		onDisable() {
				this._destroyConstraint();
		}
		_onSetEnabled(prop, old, value) {}
		_onBeforeRemove() {
				this.fire('remove');
		}
		constructor(system, entity){
				super(system, entity);
				this._constraint = null;
				this._entityA = null;
				this._entityB = null;
				this._breakForce = 3.4e+38;
				this._enableCollision = true;
				this._linearMotionX = MOTION_LOCKED;
				this._linearLimitsX = new Vec2(0, 0);
				this._linearSpringX = false;
				this._linearStiffnessX = 0;
				this._linearDampingX = 1;
				this._linearEquilibriumX = 0;
				this._linearMotionY = MOTION_LOCKED;
				this._linearLimitsY = new Vec2(0, 0);
				this._linearSpringY = false;
				this._linearStiffnessY = 0;
				this._linearDampingY = 1;
				this._linearEquilibriumY = 0;
				this._linearMotionZ = MOTION_LOCKED;
				this._linearLimitsZ = new Vec2(0, 0);
				this._linearSpringZ = false;
				this._linearStiffnessZ = 0;
				this._linearDampingZ = 1;
				this._linearEquilibriumZ = 0;
				this._angularMotionX = MOTION_LOCKED;
				this._angularLimitsX = new Vec2(0, 0);
				this._angularSpringX = false;
				this._angularStiffnessX = 0;
				this._angularDampingX = 1;
				this._angularEquilibriumX = 0;
				this._angularMotionY = MOTION_LOCKED;
				this._angularLimitsY = new Vec2(0, 0);
				this._angularSpringY = false;
				this._angularStiffnessY = 0;
				this._angularDampingY = 1;
				this._angularEquilibriumY = 0;
				this._angularMotionZ = MOTION_LOCKED;
				this._angularLimitsZ = new Vec2(0, 0);
				this._angularSpringZ = false;
				this._angularEquilibriumZ = 0;
				this._angularDampingZ = 1;
				this._angularStiffnessZ = 0;
				this.on('set_enabled', this._onSetEnabled, this);
		}
}
var functionMap = {
		Damping: 'setDamping',
		Equilibrium: 'setEquilibriumPoint',
		Spring: 'enableSpring',
		Stiffness: 'setStiffness'
};
[
		'linear',
		'angular'
].forEach((type)=>{
		[
				'Damping',
				'Equilibrium',
				'Spring',
				'Stiffness'
		].forEach((name)=>{
				[
						'X',
						'Y',
						'Z'
				].forEach((axis)=>{
						var prop = type + name + axis;
						var propInternal = "_" + prop;
						var index = type === 'linear' ? 0 : 3;
						if (axis === 'Y') index += 1;
						if (axis === 'Z') index += 2;
						Object.defineProperty(JointComponent.prototype, prop, {
								get: function get() {
										return this[propInternal];
								},
								set: function set(value) {
										if (this[propInternal] !== value) {
												this[propInternal] = value;
												this._constraint[functionMap[name]](index, value);
										}
								}
						});
				});
		});
});

class JointComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$e = [
		'enabled'
];
class JointComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				component.initFromData(data);
				super.initializeComponentData(component, data, _schema$e);
		}
		constructor(app){
				super(app);
				this.id = 'joint';
				this.app = app;
				this.ComponentType = JointComponent;
				this.DataType = JointComponentData;
				this.schema = _schema$e;
		}
}
Component._buildAccessors(JointComponent.prototype, _schema$e);

class LayoutChildComponent extends Component {
		set minWidth(value) {
				if (value !== this._minWidth) {
						this._minWidth = value;
						this.fire('resize');
				}
		}
		get minWidth() {
				return this._minWidth;
		}
		set minHeight(value) {
				if (value !== this._minHeight) {
						this._minHeight = value;
						this.fire('resize');
				}
		}
		get minHeight() {
				return this._minHeight;
		}
		set maxWidth(value) {
				if (value !== this._maxWidth) {
						this._maxWidth = value;
						this.fire('resize');
				}
		}
		get maxWidth() {
				return this._maxWidth;
		}
		set maxHeight(value) {
				if (value !== this._maxHeight) {
						this._maxHeight = value;
						this.fire('resize');
				}
		}
		get maxHeight() {
				return this._maxHeight;
		}
		set fitWidthProportion(value) {
				if (value !== this._fitWidthProportion) {
						this._fitWidthProportion = value;
						this.fire('resize');
				}
		}
		get fitWidthProportion() {
				return this._fitWidthProportion;
		}
		set fitHeightProportion(value) {
				if (value !== this._fitHeightProportion) {
						this._fitHeightProportion = value;
						this.fire('resize');
				}
		}
		get fitHeightProportion() {
				return this._fitHeightProportion;
		}
		set excludeFromLayout(value) {
				if (value !== this._excludeFromLayout) {
						this._excludeFromLayout = value;
						this.fire('resize');
				}
		}
		get excludeFromLayout() {
				return this._excludeFromLayout;
		}
		constructor(...args){
				super(...args), this._minWidth = 0, this._minHeight = 0, this._maxWidth = null, this._maxHeight = null, this._fitWidthProportion = 0, this._fitHeightProportion = 0, this._excludeFromLayout = false;
		}
}

class LayoutChildComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$d = [
		'enabled'
];
class LayoutChildComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				if (data.enabled !== undefined) component.enabled = data.enabled;
				if (data.minWidth !== undefined) component.minWidth = data.minWidth;
				if (data.minHeight !== undefined) component.minHeight = data.minHeight;
				if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
				if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
				if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
				if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
				if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
				super.initializeComponentData(component, data, properties);
		}
		cloneComponent(entity, clone) {
				var layoutChild = entity.layoutchild;
				return this.addComponent(clone, {
						enabled: layoutChild.enabled,
						minWidth: layoutChild.minWidth,
						minHeight: layoutChild.minHeight,
						maxWidth: layoutChild.maxWidth,
						maxHeight: layoutChild.maxHeight,
						fitWidthProportion: layoutChild.fitWidthProportion,
						fitHeightProportion: layoutChild.fitHeightProportion,
						excludeFromLayout: layoutChild.excludeFromLayout
				});
		}
		constructor(app){
				super(app);
				this.id = 'layoutchild';
				this.ComponentType = LayoutChildComponent;
				this.DataType = LayoutChildComponentData;
				this.schema = _schema$d;
		}
}
Component._buildAccessors(LayoutChildComponent.prototype, _schema$d);

var FITTING_NONE = 0;
var FITTING_STRETCH = 1;
var FITTING_SHRINK = 2;
var FITTING_BOTH = 3;

var AXIS_MAPPINGS = {};
AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
		axis: 'x',
		size: 'width',
		calculatedSize: 'calculatedWidth',
		minSize: 'minWidth',
		maxSize: 'maxWidth',
		fitting: 'widthFitting',
		fittingProportion: 'fitWidthProportion'
};
AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
		axis: 'y',
		size: 'height',
		calculatedSize: 'calculatedHeight',
		minSize: 'minHeight',
		maxSize: 'maxHeight',
		fitting: 'heightFitting',
		fittingProportion: 'fitHeightProportion'
};
var OPPOSITE_ORIENTATION = {};
OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
var PROPERTY_DEFAULTS = {
		minWidth: 0,
		minHeight: 0,
		maxWidth: Number.POSITIVE_INFINITY,
		maxHeight: Number.POSITIVE_INFINITY,
		width: null,
		height: null,
		fitWidthProportion: 0,
		fitHeightProportion: 0
};
var FITTING_ACTION = {
		NONE: 'NONE',
		APPLY_STRETCHING: 'APPLY_STRETCHING',
		APPLY_SHRINKING: 'APPLY_SHRINKING'
};
var availableSpace = new Vec2();
function createCalculator(orientation) {
		var options;
		var a = AXIS_MAPPINGS[orientation];
		var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
		function minExtentA(element, size) {
				return -size[a.size] * element.pivot[a.axis];
		}
		function minExtentB(element, size) {
				return -size[b.size] * element.pivot[b.axis];
		}
		function maxExtentA(element, size) {
				return size[a.size] * (1 - element.pivot[a.axis]);
		}
		function calculateAll(allElements, layoutOptions) {
				allElements = allElements.filter(shouldIncludeInLayout);
				options = layoutOptions;
				availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
				availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
				resetAnchors(allElements);
				var lines = reverseLinesIfRequired(splitLines(allElements));
				var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
				var positions = calculateBasePositions(lines, sizes);
				applyAlignmentAndPadding(lines, sizes, positions);
				applySizesAndPositions(lines, sizes, positions);
				return createLayoutInfo(lines);
		}
		function shouldIncludeInLayout(element) {
				var layoutChildComponent = element.entity.layoutchild;
				return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
		}
		function resetAnchors(allElements) {
				for(var i = 0; i < allElements.length; ++i){
						var element = allElements[i];
						var anchor = element.anchor;
						if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
								element.anchor = Vec4.ZERO;
						}
				}
		}
		function splitLines(allElements) {
				if (!options.wrap) {
						return [
								allElements
						];
				}
				var lines = [
						[]
				];
				var sizes = getElementSizeProperties(allElements);
				var runningSize = 0;
				var allowOverrun = options[a.fitting] === FITTING_SHRINK;
				for(var i = 0; i < allElements.length; ++i){
						if (lines[lines.length - 1].length > 0) {
								runningSize += options.spacing[a.axis];
						}
						var idealElementSize = sizes[i][a.size];
						runningSize += idealElementSize;
						if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
								runningSize = idealElementSize;
								lines.push([]);
						}
						lines[lines.length - 1].push(allElements[i]);
						if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
								runningSize = 0;
								lines.push([]);
						}
				}
				return lines;
		}
		function reverseLinesIfRequired(lines) {
				var reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
				var reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;
				if (reverseAxisA) {
						for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
								if (reverseAxisA) {
										lines[lineIndex].reverse();
								}
						}
				}
				if (reverseAxisB) {
						lines.reverse();
				}
				return lines;
		}
		function calculateSizesOnAxisA(lines) {
				var sizesAllLines = [];
				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
						var line = lines[lineIndex];
						var sizesThisLine = getElementSizeProperties(line);
						var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
						var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
						if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
								stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
						} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
								shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
						}
						sizesAllLines.push(sizesThisLine);
				}
				return sizesAllLines;
		}
		function calculateSizesOnAxisB(lines, sizesAllLines) {
				var largestElementsForEachLine = [];
				var largestSizesForEachLine = [];
				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
						var line = lines[lineIndex];
						line.largestElement = null;
						line.largestSize = {
								width: Number.NEGATIVE_INFINITY,
								height: Number.NEGATIVE_INFINITY
						};
						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
								var sizesThisElement = sizesAllLines[lineIndex][elementIndex];
								if (sizesThisElement[b.size] > line.largestSize[b.size]) {
										line.largestElement = line[elementIndex];
										line.largestSize = sizesThisElement;
								}
						}
						largestElementsForEachLine.push(line.largestElement);
						largestSizesForEachLine.push(line.largestSize);
				}
				var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
				var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
				if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
						stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
				} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
						shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
				}
				for(var lineIndex1 = 0; lineIndex1 < lines.length; ++lineIndex1){
						var line1 = lines[lineIndex1];
						for(var elementIndex1 = 0; elementIndex1 < line1.length; ++elementIndex1){
								var sizesForThisElement = sizesAllLines[lineIndex1][elementIndex1];
								var currentSize = sizesForThisElement[b.size];
								var availableSize = lines.length === 1 ? availableSpace[b.axis] : line1.largestSize[b.size];
								var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);
								if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
										sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
								} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
										sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
								}
						}
				}
				return sizesAllLines;
		}
		function determineFittingAction(fittingMode, currentSize, availableSize) {
				switch(fittingMode){
						case FITTING_NONE:
								return FITTING_ACTION.NONE;
						case FITTING_STRETCH:
								if (currentSize < availableSize) {
										return FITTING_ACTION.APPLY_STRETCHING;
								}
								return FITTING_ACTION.NONE;
						case FITTING_SHRINK:
								if (currentSize >= availableSize) {
										return FITTING_ACTION.APPLY_SHRINKING;
								}
								return FITTING_ACTION.NONE;
						case FITTING_BOTH:
								if (currentSize < availableSize) {
										return FITTING_ACTION.APPLY_STRETCHING;
								}
								return FITTING_ACTION.APPLY_SHRINKING;
						default:
								throw new Error("Unrecognized fitting mode: " + fittingMode);
				}
		}
		function calculateTotalSpace(sizes, axis) {
				var totalSizes = sumValues(sizes, axis.size);
				var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
				return totalSizes + totalSpacing;
		}
		function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
				var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
				var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
				var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
				var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
				for(var i = 0; i < sizesThisLine.length; ++i){
						var index = ascendingMaxSizeOrder[i];
						var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
						var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
						var maxSize = sizesThisLine[index][axis.maxSize];
						var actualSize = Math.min(targetSize, maxSize);
						sizesThisLine[index][axis.size] = actualSize;
						var actualIncrease = Math.max(targetSize - actualSize, 0);
						var appliedIncrease = targetIncrease - actualIncrease;
						remainingUndershoot -= appliedIncrease;
				}
		}
		function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
				var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
				var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
				var inverseFittingProportions = invertNormalizedValues(fittingProportions);
				var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
				var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
				for(var i = 0; i < sizesThisLine.length; ++i){
						var index = descendingMinSizeOrder[i];
						var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
						var targetSize = sizesThisLine[index][axis.size] - targetReduction;
						var minSize = sizesThisLine[index][axis.minSize];
						var actualSize = Math.max(targetSize, minSize);
						sizesThisLine[index][axis.size] = actualSize;
						var actualReduction = Math.max(actualSize - targetSize, 0);
						var appliedReduction = targetReduction - actualReduction;
						remainingOvershoot -= appliedReduction;
				}
		}
		function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
				var proportion = fittingProportions[index];
				var sumOfRemainingProportions = fittingProportionSums[index];
				if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
						return remainingAdjustment;
				}
				return remainingAdjustment * proportion / sumOfRemainingProportions;
		}
		function calculateBasePositions(lines, sizes) {
				var cursor = {};
				cursor[a.axis] = 0;
				cursor[b.axis] = 0;
				lines[a.size] = Number.NEGATIVE_INFINITY;
				var positionsAllLines = [];
				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
						var line = lines[lineIndex];
						if (line.length === 0) {
								positionsAllLines.push([]);
								continue;
						}
						var positionsThisLine = [];
						var sizesThisLine = sizes[lineIndex];
						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
								var element = line[elementIndex];
								var sizesThisElement = sizesThisLine[elementIndex];
								cursor[b.axis] -= minExtentB(element, sizesThisElement);
								cursor[a.axis] -= minExtentA(element, sizesThisElement);
								positionsThisLine[elementIndex] = {};
								positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
								positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
								cursor[b.axis] += minExtentB(element, sizesThisElement);
								cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
						}
						line[a.size] = cursor[a.axis] - options.spacing[a.axis];
						line[b.size] = line.largestSize[b.size];
						lines[a.size] = Math.max(lines[a.size], line[a.size]);
						cursor[a.axis] = 0;
						cursor[b.axis] += line[b.size] + options.spacing[b.axis];
						positionsAllLines.push(positionsThisLine);
				}
				lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
				return positionsAllLines;
		}
		function applyAlignmentAndPadding(lines, sizes, positions) {
				var alignmentA = options.alignment[a.axis];
				var alignmentB = options.alignment[b.axis];
				var paddingA = options.padding[a.axis];
				var paddingB = options.padding[b.axis];
				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
						var line = lines[lineIndex];
						var sizesThisLine = sizes[lineIndex];
						var positionsThisLine = positions[lineIndex];
						var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
						var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
								var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
								positionsThisLine[elementIndex][a.axis] += axisAOffset;
								positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
						}
				}
		}
		function applySizesAndPositions(lines, sizes, positions) {
				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
						var line = lines[lineIndex];
						var sizesThisLine = sizes[lineIndex];
						var positionsThisLine = positions[lineIndex];
						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
								var element = line[elementIndex];
								element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
								element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
								if (options.orientation === ORIENTATION_HORIZONTAL) {
										element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
								} else {
										element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
								}
						}
				}
		}
		function createLayoutInfo(lines) {
				var layoutWidth = lines.width;
				var layoutHeight = lines.height;
				var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
				var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
				return {
						bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
				};
		}
		function getElementSizeProperties(elements) {
				var sizeProperties = [];
				for(var i = 0; i < elements.length; ++i){
						var element = elements[i];
						var minWidth = Math.max(getProperty(element, 'minWidth'), 0);
						var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
						var maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
						var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
						var width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
						var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
						var fitWidthProportion = getProperty(element, 'fitWidthProportion');
						var fitHeightProportion = getProperty(element, 'fitHeightProportion');
						sizeProperties.push({
								minWidth: minWidth,
								minHeight: minHeight,
								maxWidth: maxWidth,
								maxHeight: maxHeight,
								width: width,
								height: height,
								fitWidthProportion: fitWidthProportion,
								fitHeightProportion: fitHeightProportion
						});
				}
				return sizeProperties;
		}
		function getProperty(element, propertyName) {
				var layoutChildComponent = element.entity.layoutchild;
				if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
						return layoutChildComponent[propertyName];
				} else if (element[propertyName] !== undefined) {
						return element[propertyName];
				}
				return PROPERTY_DEFAULTS[propertyName];
		}
		function clamp(value, min, max) {
				return Math.min(Math.max(value, min), max);
		}
		function sumValues(items, propertyName) {
				return items.reduce((accumulator, current)=>{
						return accumulator + current[propertyName];
				}, 0);
		}
		function getNormalizedValues(items, propertyName) {
				var sum = sumValues(items, propertyName);
				var normalizedValues = [];
				var numItems = items.length;
				if (sum === 0) {
						for(var i = 0; i < numItems; ++i){
								normalizedValues.push(1 / numItems);
						}
				} else {
						for(var i1 = 0; i1 < numItems; ++i1){
								normalizedValues.push(items[i1][propertyName] / sum);
						}
				}
				return normalizedValues;
		}
		function invertNormalizedValues(values) {
				if (values.length === 1) {
						return [
								1
						];
				}
				var invertedValues = [];
				var numValues = values.length;
				for(var i = 0; i < numValues; ++i){
						invertedValues.push((1 - values[i]) / (numValues - 1));
				}
				return invertedValues;
		}
		function getTraversalOrder(items, orderBy, descending) {
				items.forEach(assignIndex);
				return items.slice().sort((itemA, itemB)=>{
						return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
				}).map(getIndex);
		}
		function assignIndex(item, index) {
				item.index = index;
		}
		function getIndex(item) {
				return item.index;
		}
		function createSumArray(values, order) {
				var sumArray = [];
				sumArray[order[values.length - 1]] = values[order[values.length - 1]];
				for(var i = values.length - 2; i >= 0; --i){
						sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
				}
				return sumArray;
		}
		return calculateAll;
}
var CALCULATE_FNS = {};
CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);
class LayoutCalculator {
		calculateLayout(elements, options) {
				var calculateFn = CALCULATE_FNS[options.orientation];
				if (!calculateFn) {
						throw new Error("Unrecognized orientation value: " + options.orientation);
				} else {
						return calculateFn(elements, options);
				}
		}
}

function getElement(entity) {
		return entity.element;
}
function isEnabledAndHasEnabledElement(entity) {
		return entity.enabled && entity.element && entity.element.enabled;
}
class LayoutGroupComponent extends Component {
		set orientation(value) {
				if (value !== this._orientation) {
						this._orientation = value;
						this._scheduleReflow();
				}
		}
		get orientation() {
				return this._orientation;
		}
		set reverseX(value) {
				if (value !== this._reverseX) {
						this._reverseX = value;
						this._scheduleReflow();
				}
		}
		get reverseX() {
				return this._reverseX;
		}
		set reverseY(value) {
				if (value !== this._reverseY) {
						this._reverseY = value;
						this._scheduleReflow();
				}
		}
		get reverseY() {
				return this._reverseY;
		}
		set alignment(value) {
				if (!value.equals(this._alignment)) {
						this._alignment.copy(value);
						this._scheduleReflow();
				}
		}
		get alignment() {
				return this._alignment;
		}
		set padding(value) {
				if (!value.equals(this._padding)) {
						this._padding.copy(value);
						this._scheduleReflow();
				}
		}
		get padding() {
				return this._padding;
		}
		set spacing(value) {
				if (!value.equals(this._spacing)) {
						this._spacing.copy(value);
						this._scheduleReflow();
				}
		}
		get spacing() {
				return this._spacing;
		}
		set widthFitting(value) {
				if (value !== this._widthFitting) {
						this._widthFitting = value;
						this._scheduleReflow();
				}
		}
		get widthFitting() {
				return this._widthFitting;
		}
		set heightFitting(value) {
				if (value !== this._heightFitting) {
						this._heightFitting = value;
						this._scheduleReflow();
				}
		}
		get heightFitting() {
				return this._heightFitting;
		}
		set wrap(value) {
				if (value !== this._wrap) {
						this._wrap = value;
						this._scheduleReflow();
				}
		}
		get wrap() {
				return this._wrap;
		}
		_isSelfOrChild(entity) {
				return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
		}
		_listenForReflowEvents(target, onOff) {
				if (target.element) {
						target.element[onOff]('enableelement', this._scheduleReflow, this);
						target.element[onOff]('disableelement', this._scheduleReflow, this);
						target.element[onOff]('resize', this._scheduleReflow, this);
						target.element[onOff]('set:pivot', this._scheduleReflow, this);
				}
				if (target.layoutchild) {
						target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
						target.layoutchild[onOff]('resize', this._scheduleReflow, this);
				}
		}
		_onElementOrLayoutComponentAdd(entity) {
				if (this._isSelfOrChild(entity)) {
						this._listenForReflowEvents(entity, 'on');
						this._scheduleReflow();
				}
		}
		_onElementOrLayoutComponentRemove(entity) {
				if (this._isSelfOrChild(entity)) {
						this._listenForReflowEvents(entity, 'off');
						this._scheduleReflow();
				}
		}
		_onChildInsert(child) {
				this._listenForReflowEvents(child, 'on');
				this._scheduleReflow();
		}
		_onChildRemove(child) {
				this._listenForReflowEvents(child, 'off');
				this._scheduleReflow();
		}
		_scheduleReflow() {
				if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
						this.system.scheduleReflow(this);
				}
		}
		reflow() {
				var container = getElement(this.entity);
				var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
				if (!container || elements.length === 0) {
						return;
				}
				var containerWidth = Math.max(container.calculatedWidth, 0);
				var containerHeight = Math.max(container.calculatedHeight, 0);
				var options = {
						orientation: this._orientation,
						reverseX: this._reverseX,
						reverseY: this._reverseY,
						alignment: this._alignment,
						padding: this._padding,
						spacing: this._spacing,
						widthFitting: this._widthFitting,
						heightFitting: this._heightFitting,
						wrap: this._wrap,
						containerSize: new Vec2(containerWidth, containerHeight)
				};
				this._isPerformingReflow = true;
				var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
				this._isPerformingReflow = false;
				this.fire('reflow', layoutInfo);
		}
		onEnable() {
				this._scheduleReflow();
		}
		onRemove() {
				this.entity.off('childinsert', this._onChildInsert, this);
				this.entity.off('childremove', this._onChildRemove, this);
				this._listenForReflowEvents(this.entity, 'off');
				this.entity.children.forEach((child)=>{
						this._listenForReflowEvents(child, 'off');
				});
				this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
				this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
				this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
				this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		}
		constructor(system, entity){
				super(system, entity), this._orientation = ORIENTATION_HORIZONTAL, this._reverseX = false, this._reverseY = true, this._alignment = new Vec2(0, 1), this._padding = new Vec4(), this._spacing = new Vec2(), this._widthFitting = FITTING_NONE, this._heightFitting = FITTING_NONE, this._wrap = false, this._layoutCalculator = new LayoutCalculator();
				this._listenForReflowEvents(this.entity, 'on');
				this.entity.children.forEach((child)=>{
						this._listenForReflowEvents(child, 'on');
				});
				this.entity.on('childinsert', this._onChildInsert, this);
				this.entity.on('childremove', this._onChildRemove, this);
				system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);
				system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
				system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);
				system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
		}
}

class LayoutGroupComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$c = [
		'enabled'
];
var MAX_ITERATIONS = 100;
class LayoutGroupComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				if (data.enabled !== undefined) component.enabled = data.enabled;
				if (data.orientation !== undefined) component.orientation = data.orientation;
				if (data.reverseX !== undefined) component.reverseX = data.reverseX;
				if (data.reverseY !== undefined) component.reverseY = data.reverseY;
				if (data.alignment !== undefined) {
						component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
				}
				if (data.padding !== undefined) {
						component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
				}
				if (data.spacing !== undefined) {
						component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
				}
				if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
				if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
				if (data.wrap !== undefined) component.wrap = data.wrap;
				super.initializeComponentData(component, data, properties);
		}
		cloneComponent(entity, clone) {
				var layoutGroup = entity.layoutgroup;
				return this.addComponent(clone, {
						enabled: layoutGroup.enabled,
						orientation: layoutGroup.orientation,
						reverseX: layoutGroup.reverseX,
						reverseY: layoutGroup.reverseY,
						alignment: layoutGroup.alignment,
						padding: layoutGroup.padding,
						spacing: layoutGroup.spacing,
						widthFitting: layoutGroup.widthFitting,
						heightFitting: layoutGroup.heightFitting,
						wrap: layoutGroup.wrap
				});
		}
		scheduleReflow(component) {
				if (this._reflowQueue.indexOf(component) === -1) {
						this._reflowQueue.push(component);
				}
		}
		_onPostUpdate() {
				this._processReflowQueue();
		}
		_processReflowQueue() {
				if (this._reflowQueue.length === 0) {
						return;
				}
				var iterationCount = 0;
				while(this._reflowQueue.length > 0){
						var queue = this._reflowQueue.slice();
						this._reflowQueue.length = 0;
						queue.sort((componentA, componentB)=>{
								return componentA.entity.graphDepth - componentB.entity.graphDepth;
						});
						for(var i = 0; i < queue.length; ++i){
								queue[i].reflow();
						}
						if (++iterationCount >= MAX_ITERATIONS) {
								console.warn('Max reflow iterations limit reached, bailing.');
								break;
						}
				}
		}
		_onRemoveComponent(entity, component) {
				component.onRemove();
		}
		destroy() {
				super.destroy();
				this.app.systems.off('postUpdate', this._onPostUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'layoutgroup';
				this.ComponentType = LayoutGroupComponent;
				this.DataType = LayoutGroupComponentData;
				this.schema = _schema$c;
				this._reflowQueue = [];
				this.on('beforeremove', this._onRemoveComponent, this);
				this.app.systems.on('postUpdate', this._onPostUpdate, this);
		}
}
Component._buildAccessors(LayoutGroupComponent.prototype, _schema$c);

class PrimitivesCache {
		destroy(device) {
				this.map.forEach((primData)=>primData.mesh.destroy());
		}
		constructor(){
				this.map = new Map();
		}
}
var _primitivesCache = new DeviceCache();
var getShapePrimitive = (device, type)=>{
		var cache = _primitivesCache.get(device, ()=>{
				return new PrimitivesCache();
		});
		var primData = cache.map.get(type);
		if (!primData) {
				var mesh, area;
				switch(type){
						case 'box':
								mesh = Mesh.fromGeometry(device, new BoxGeometry());
								area = {
										x: 2,
										y: 2,
										z: 2,
										uv: 2.0 / 3
								};
								break;
						case 'capsule':
								mesh = Mesh.fromGeometry(device, new CapsuleGeometry({
										radius: 0.5,
										height: 2
								}));
								area = {
										x: Math.PI * 2,
										y: Math.PI,
										z: Math.PI * 2,
										uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
								};
								break;
						case 'cone':
								mesh = Mesh.fromGeometry(device, new ConeGeometry({
										baseRadius: 0.5,
										peakRadius: 0,
										height: 1
								}));
								area = {
										x: 2.54,
										y: 2.54,
										z: 2.54,
										uv: 1.0 / 3 + 1.0 / 3 / 3
								};
								break;
						case 'cylinder':
								mesh = Mesh.fromGeometry(device, new CylinderGeometry({
										radius: 0.5,
										height: 1
								}));
								area = {
										x: Math.PI,
										y: 0.79 * 2,
										z: Math.PI,
										uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
								};
								break;
						case 'plane':
								mesh = Mesh.fromGeometry(device, new PlaneGeometry({
										halfExtents: new Vec2(0.5, 0.5),
										widthSegments: 1,
										lengthSegments: 1
								}));
								area = {
										x: 0,
										y: 1,
										z: 0,
										uv: 1
								};
								break;
						case 'sphere':
								mesh = Mesh.fromGeometry(device, new SphereGeometry({
										radius: 0.5
								}));
								area = {
										x: Math.PI,
										y: Math.PI,
										z: Math.PI,
										uv: 1
								};
								break;
						case 'torus':
								mesh = Mesh.fromGeometry(device, new TorusGeometry({
										tubeRadius: 0.2,
										ringRadius: 0.3
								}));
								area = {
										x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
										y: 0.4,
										z: 0.4,
										uv: 1
								};
								break;
						default:
								throw new Error("Invalid primitive type: " + type);
				}
				mesh.incRefCount();
				primData = {
						mesh: mesh,
						area: area
				};
				cache.map.set(type, primData);
		}
		return primData;
};

class ModelComponent extends Component {
		set meshInstances(value) {
				if (!this._model) {
						return;
				}
				this._model.meshInstances = value;
		}
		get meshInstances() {
				if (!this._model) {
						return null;
				}
				return this._model.meshInstances;
		}
		set customAabb(value) {
				this._customAabb = value;
				if (this._model) {
						var mi = this._model.meshInstances;
						if (mi) {
								for(var i = 0; i < mi.length; i++){
										mi[i].setCustomAabb(this._customAabb);
								}
						}
				}
		}
		get customAabb() {
				return this._customAabb;
		}
		set type(value) {
				if (this._type === value) return;
				this._area = null;
				this._type = value;
				if (value === 'asset') {
						if (this._asset !== null) {
								this._bindModelAsset(this._asset);
						} else {
								this.model = null;
						}
				} else {
						var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
						this._area = primData.area;
						var mesh = primData.mesh;
						var node = new GraphNode();
						var model = new Model();
						model.graph = node;
						model.meshInstances = [
								new MeshInstance(mesh, this._material, node)
						];
						this.model = model;
						this._asset = null;
				}
		}
		get type() {
				return this._type;
		}
		set asset(value) {
				var assets = this.system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
						_id = value.id;
				}
				if (this._asset !== _id) {
						if (this._asset) {
								assets.off("add:" + this._asset, this._onModelAssetAdded, this);
								var _prev = assets.get(this._asset);
								if (_prev) {
										this._unbindModelAsset(_prev);
								}
						}
						this._asset = _id;
						if (this._asset) {
								var asset = assets.get(this._asset);
								if (!asset) {
										this.model = null;
										assets.on("add:" + this._asset, this._onModelAssetAdded, this);
								} else {
										this._bindModelAsset(asset);
								}
						} else {
								this.model = null;
						}
				}
		}
		get asset() {
				return this._asset;
		}
		set model(value) {
				if (this._model === value) {
						return;
				}
				if (value && value._immutable) {
						return;
				}
				if (this._model) {
						this._model._immutable = false;
						this.removeModelFromLayers();
						this._model.getGraph().destroy();
						delete this._model._entity;
						if (this._clonedModel) {
								this._model.destroy();
								this._clonedModel = false;
						}
				}
				this._model = value;
				if (this._model) {
						this._model._immutable = true;
						var meshInstances = this._model.meshInstances;
						for(var i = 0; i < meshInstances.length; i++){
								meshInstances[i].castShadow = this._castShadows;
								meshInstances[i].receiveShadow = this._receiveShadows;
								meshInstances[i].setCustomAabb(this._customAabb);
						}
						this.lightmapped = this._lightmapped;
						this.entity.addChild(this._model.graph);
						if (this.enabled && this.entity.enabled) {
								this.addModelToLayers();
						}
						this._model._entity = this.entity;
						if (this.entity.animation) {
								this.entity.animation.setModel(this._model);
						}
						if (this.entity.anim) {
								this.entity.anim.rebind();
						}
						if (this.type === 'asset') {
								this.mapping = this._mapping;
						} else {
								this._unsetMaterialEvents();
						}
				}
		}
		get model() {
				return this._model;
		}
		set lightmapped(value) {
				if (value !== this._lightmapped) {
						this._lightmapped = value;
						if (this._model) {
								var mi = this._model.meshInstances;
								for(var i = 0; i < mi.length; i++){
										mi[i].setLightmapped(value);
								}
						}
				}
		}
		get lightmapped() {
				return this._lightmapped;
		}
		set castShadows(value) {
				if (this._castShadows === value) return;
				var model = this._model;
				if (model) {
						var layers = this.layers;
						var scene = this.system.app.scene;
						if (this._castShadows && !value) {
								for(var i = 0; i < layers.length; i++){
										var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
										if (!layer) continue;
										layer.removeShadowCasters(model.meshInstances);
								}
						}
						var meshInstances = model.meshInstances;
						for(var i1 = 0; i1 < meshInstances.length; i1++){
								meshInstances[i1].castShadow = value;
						}
						if (!this._castShadows && value) {
								for(var i2 = 0; i2 < layers.length; i2++){
										var layer1 = scene.layers.getLayerById(layers[i2]);
										if (!layer1) continue;
										layer1.addShadowCasters(model.meshInstances);
								}
						}
				}
				this._castShadows = value;
		}
		get castShadows() {
				return this._castShadows;
		}
		set receiveShadows(value) {
				if (this._receiveShadows === value) return;
				this._receiveShadows = value;
				if (this._model) {
						var meshInstances = this._model.meshInstances;
						for(var i = 0, len = meshInstances.length; i < len; i++){
								meshInstances[i].receiveShadow = value;
						}
				}
		}
		get receiveShadows() {
				return this._receiveShadows;
		}
		set castShadowsLightmap(value) {
				this._castShadowsLightmap = value;
		}
		get castShadowsLightmap() {
				return this._castShadowsLightmap;
		}
		set lightmapSizeMultiplier(value) {
				this._lightmapSizeMultiplier = value;
		}
		get lightmapSizeMultiplier() {
				return this._lightmapSizeMultiplier;
		}
		set layers(value) {
				var layers = this.system.app.scene.layers;
				if (this.meshInstances) {
						for(var i = 0; i < this._layers.length; i++){
								var layer = layers.getLayerById(this._layers[i]);
								if (!layer) continue;
								layer.removeMeshInstances(this.meshInstances);
						}
				}
				this._layers.length = 0;
				for(var i1 = 0; i1 < value.length; i1++){
						this._layers[i1] = value[i1];
				}
				if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;
				for(var i2 = 0; i2 < this._layers.length; i2++){
						var layer1 = layers.getLayerById(this._layers[i2]);
						if (!layer1) continue;
						layer1.addMeshInstances(this.meshInstances);
				}
		}
		get layers() {
				return this._layers;
		}
		set batchGroupId(value) {
				if (this._batchGroupId === value) return;
				if (this.entity.enabled && this._batchGroupId >= 0) {
						var _this_system_app_batcher;
						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
						var _this_system_app_batcher1;
						(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.MODEL, value, this.entity);
				}
				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
						this.addModelToLayers();
				}
				this._batchGroupId = value;
		}
		get batchGroupId() {
				return this._batchGroupId;
		}
		set materialAsset(value) {
				var _id = value;
				if (value instanceof Asset) {
						_id = value.id;
				}
				var assets = this.system.app.assets;
				if (_id !== this._materialAsset) {
						if (this._materialAsset) {
								assets.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
								var _prev = assets.get(this._materialAsset);
								if (_prev) {
										this._unbindMaterialAsset(_prev);
								}
						}
						this._materialAsset = _id;
						if (this._materialAsset) {
								var asset = assets.get(this._materialAsset);
								if (!asset) {
										this._setMaterial(this.system.defaultMaterial);
										assets.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
								} else {
										this._bindMaterialAsset(asset);
								}
						} else {
								this._setMaterial(this.system.defaultMaterial);
						}
				}
		}
		get materialAsset() {
				return this._materialAsset;
		}
		set material(value) {
				if (this._material === value) {
						return;
				}
				this.materialAsset = null;
				this._setMaterial(value);
		}
		get material() {
				return this._material;
		}
		set mapping(value) {
				if (this._type !== 'asset') {
						return;
				}
				this._unsetMaterialEvents();
				if (!value) {
						value = {};
				}
				this._mapping = value;
				if (!this._model) return;
				var meshInstances = this._model.meshInstances;
				var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
				var assetMapping = modelAsset ? modelAsset.data.mapping : null;
				var asset = null;
				for(var i = 0, len = meshInstances.length; i < len; i++){
						if (value[i] !== undefined) {
								if (value[i]) {
										asset = this.system.app.assets.get(value[i]);
										this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
								} else {
										meshInstances[i].material = this.system.defaultMaterial;
								}
						} else if (assetMapping) {
								if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
										if (assetMapping[i].material !== undefined) {
												asset = this.system.app.assets.get(assetMapping[i].material);
										} else if (assetMapping[i].path !== undefined) {
												var url = this._getMaterialAssetUrl(assetMapping[i].path);
												if (url) {
														asset = this.system.app.assets.getByUrl(url);
												}
										}
										this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
								} else {
										meshInstances[i].material = this.system.defaultMaterial;
								}
						}
				}
		}
		get mapping() {
				return this._mapping;
		}
		addModelToLayers() {
				var layers = this.system.app.scene.layers;
				for(var i = 0; i < this._layers.length; i++){
						var layer = layers.getLayerById(this._layers[i]);
						if (layer) {
								layer.addMeshInstances(this.meshInstances);
						}
				}
		}
		removeModelFromLayers() {
				var layers = this.system.app.scene.layers;
				for(var i = 0; i < this._layers.length; i++){
						var layer = layers.getLayerById(this._layers[i]);
						if (!layer) continue;
						layer.removeMeshInstances(this.meshInstances);
				}
		}
		onRemoveChild() {
				if (this._model) {
						this.removeModelFromLayers();
				}
		}
		onInsertChild() {
				if (this._model && this.enabled && this.entity.enabled) {
						this.addModelToLayers();
				}
		}
		onRemove() {
				this.asset = null;
				this.model = null;
				this.materialAsset = null;
				this._unsetMaterialEvents();
				this.entity.off('remove', this.onRemoveChild, this);
				this.entity.off('insert', this.onInsertChild, this);
		}
		onLayersChanged(oldComp, newComp) {
				this.addModelToLayers();
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.addMeshInstances(this.meshInstances);
		}
		onLayerRemoved(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.removeMeshInstances(this.meshInstances);
		}
		_setMaterialEvent(index, event, id, handler) {
				var evt = event + ":" + id;
				this.system.app.assets.on(evt, handler, this);
				if (!this._materialEvents) {
						this._materialEvents = [];
				}
				if (!this._materialEvents[index]) {
						this._materialEvents[index] = {};
				}
				this._materialEvents[index][evt] = {
						id: id,
						handler: handler
				};
		}
		_unsetMaterialEvents() {
				var assets = this.system.app.assets;
				var events = this._materialEvents;
				if (!events) {
						return;
				}
				for(var i = 0, len = events.length; i < len; i++){
						if (!events[i]) continue;
						var evt = events[i];
						for(var key in evt){
								assets.off(key, evt[key].handler, this);
						}
				}
				this._materialEvents = null;
		}
		_getAssetByIdOrPath(idOrPath) {
				var asset = null;
				var isPath = isNaN(parseInt(idOrPath, 10));
				if (!isPath) {
						asset = this.system.app.assets.get(idOrPath);
				} else if (this.asset) {
						var url = this._getMaterialAssetUrl(idOrPath);
						if (url) {
								asset = this.system.app.assets.getByUrl(url);
						}
				}
				return asset;
		}
		_getMaterialAssetUrl(path) {
				if (!this.asset) return null;
				var modelAsset = this.system.app.assets.get(this.asset);
				return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
		}
		_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
				var assets = this.system.app.assets;
				if (!materialAsset) {
						return;
				}
				if (materialAsset.resource) {
						meshInstance.material = materialAsset.resource;
						this._setMaterialEvent(index, 'remove', materialAsset.id, function() {
								meshInstance.material = this.system.defaultMaterial;
						});
				} else {
						this._setMaterialEvent(index, 'load', materialAsset.id, function(asset) {
								meshInstance.material = asset.resource;
								this._setMaterialEvent(index, 'remove', materialAsset.id, function() {
										meshInstance.material = this.system.defaultMaterial;
								});
						});
						if (this.enabled && this.entity.enabled) {
								assets.load(materialAsset);
						}
				}
		}
		onEnable() {
				var app = this.system.app;
				var scene = app.scene;
				var layers = scene == null ? void 0 : scene.layers;
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				var isAsset = this._type === 'asset';
				var asset;
				if (this._model) {
						this.addModelToLayers();
				} else if (isAsset && this._asset) {
						asset = app.assets.get(this._asset);
						if (asset && asset.resource !== this._model) {
								this._bindModelAsset(asset);
						}
				}
				if (this._materialAsset) {
						asset = app.assets.get(this._materialAsset);
						if (asset && asset.resource !== this._material) {
								this._bindMaterialAsset(asset);
						}
				}
				if (isAsset) {
						if (this._mapping) {
								for(var index in this._mapping){
										if (this._mapping[index]) {
												asset = this._getAssetByIdOrPath(this._mapping[index]);
												if (asset && !asset.resource) {
														app.assets.load(asset);
												}
										}
								}
						}
				}
				if (this._batchGroupId >= 0) {
						var _app_batcher;
						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
				}
		}
		onDisable() {
				var _this__evtLayersChanged;
				var app = this.system.app;
				var scene = app.scene;
				var layers = scene.layers;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				if (this._batchGroupId >= 0) {
						var _app_batcher;
						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
				}
				if (this._model) {
						this.removeModelFromLayers();
				}
		}
		hide() {
				if (this._model) {
						var instances = this._model.meshInstances;
						for(var i = 0, l = instances.length; i < l; i++){
								instances[i].visible = false;
						}
				}
		}
		show() {
				if (this._model) {
						var instances = this._model.meshInstances;
						for(var i = 0, l = instances.length; i < l; i++){
								instances[i].visible = true;
						}
				}
		}
		_bindMaterialAsset(asset) {
				asset.on('load', this._onMaterialAssetLoad, this);
				asset.on('unload', this._onMaterialAssetUnload, this);
				asset.on('remove', this._onMaterialAssetRemove, this);
				asset.on('change', this._onMaterialAssetChange, this);
				if (asset.resource) {
						this._onMaterialAssetLoad(asset);
				} else {
						if (!this.enabled || !this.entity.enabled) return;
						this.system.app.assets.load(asset);
				}
		}
		_unbindMaterialAsset(asset) {
				asset.off('load', this._onMaterialAssetLoad, this);
				asset.off('unload', this._onMaterialAssetUnload, this);
				asset.off('remove', this._onMaterialAssetRemove, this);
				asset.off('change', this._onMaterialAssetChange, this);
		}
		_onMaterialAssetAdd(asset) {
				this.system.app.assets.off("add:" + asset.id, this._onMaterialAssetAdd, this);
				if (this._materialAsset === asset.id) {
						this._bindMaterialAsset(asset);
				}
		}
		_onMaterialAssetLoad(asset) {
				this._setMaterial(asset.resource);
		}
		_onMaterialAssetUnload(asset) {
				this._setMaterial(this.system.defaultMaterial);
		}
		_onMaterialAssetRemove(asset) {
				this._onMaterialAssetUnload(asset);
		}
		_onMaterialAssetChange(asset) {}
		_bindModelAsset(asset) {
				this._unbindModelAsset(asset);
				asset.on('load', this._onModelAssetLoad, this);
				asset.on('unload', this._onModelAssetUnload, this);
				asset.on('change', this._onModelAssetChange, this);
				asset.on('remove', this._onModelAssetRemove, this);
				if (asset.resource) {
						this._onModelAssetLoad(asset);
				} else {
						if (!this.enabled || !this.entity.enabled) return;
						this.system.app.assets.load(asset);
				}
		}
		_unbindModelAsset(asset) {
				asset.off('load', this._onModelAssetLoad, this);
				asset.off('unload', this._onModelAssetUnload, this);
				asset.off('change', this._onModelAssetChange, this);
				asset.off('remove', this._onModelAssetRemove, this);
		}
		_onModelAssetAdded(asset) {
				this.system.app.assets.off("add:" + asset.id, this._onModelAssetAdded, this);
				if (asset.id === this._asset) {
						this._bindModelAsset(asset);
				}
		}
		_onModelAssetLoad(asset) {
				this.model = asset.resource.clone();
				this._clonedModel = true;
		}
		_onModelAssetUnload(asset) {
				this.model = null;
		}
		_onModelAssetChange(asset, attr, _new, _old) {
				if (attr === 'data') {
						this.mapping = this._mapping;
				}
		}
		_onModelAssetRemove(asset) {
				this.model = null;
		}
		_setMaterial(material) {
				if (this._material === material) {
						return;
				}
				this._material = material;
				var model = this._model;
				if (model && this._type !== 'asset') {
						var meshInstances = model.meshInstances;
						for(var i = 0, len = meshInstances.length; i < len; i++){
								meshInstances[i].material = material;
						}
				}
		}
		constructor(system, entity){
				super(system, entity), this._type = 'asset', this._asset = null, this._model = null, this._mapping = {}, this._castShadows = true, this._receiveShadows = true, this._materialAsset = null, this._castShadowsLightmap = true, this._lightmapped = false, this._lightmapSizeMultiplier = 1, this.isStatic = false, this._layers = [
						LAYERID_WORLD
				], this._batchGroupId = -1, this._customAabb = null, this._area = null, this._materialEvents = null, this._clonedModel = false, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
				this._material = system.defaultMaterial;
				entity.on('remove', this.onRemoveChild, this);
				entity.on('removehierarchy', this.onRemoveChild, this);
				entity.on('insert', this.onInsertChild, this);
				entity.on('inserthierarchy', this.onInsertChild, this);
		}
}

class ModelComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$b = [
		'enabled'
];
class ModelComponentSystem extends ComponentSystem {
		initializeComponentData(component, _data, properties) {
				properties = [
						'material',
						'materialAsset',
						'asset',
						'castShadows',
						'receiveShadows',
						'castShadowsLightmap',
						'lightmapped',
						'lightmapSizeMultiplier',
						'type',
						'mapping',
						'layers',
						'isStatic',
						'batchGroupId'
				];
				if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
						_data.batchGroupId = -1;
				}
				if (_data.layers && _data.layers.length) {
						_data.layers = _data.layers.slice(0);
				}
				for(var i = 0; i < properties.length; i++){
						if (_data.hasOwnProperty(properties[i])) {
								component[properties[i]] = _data[properties[i]];
						}
				}
				if (_data.aabbCenter && _data.aabbHalfExtents) {
						component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
				}
				super.initializeComponentData(component, _data, [
						'enabled'
				]);
		}
		cloneComponent(entity, clone) {
				var data = {
						type: entity.model.type,
						asset: entity.model.asset,
						castShadows: entity.model.castShadows,
						receiveShadows: entity.model.receiveShadows,
						castShadowsLightmap: entity.model.castShadowsLightmap,
						lightmapped: entity.model.lightmapped,
						lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
						isStatic: entity.model.isStatic,
						enabled: entity.model.enabled,
						layers: entity.model.layers,
						batchGroupId: entity.model.batchGroupId,
						mapping: extend({}, entity.model.mapping)
				};
				var materialAsset = entity.model.materialAsset;
				if (!(materialAsset instanceof Asset) && materialAsset != null) {
						materialAsset = this.app.assets.get(materialAsset);
				}
				var material = entity.model.material;
				if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
						data.materialAsset = materialAsset;
				}
				var component = this.addComponent(clone, data);
				if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
						component.model = entity.model.model.clone();
						component._clonedModel = true;
				}
				if (!data.materialAsset) {
						component.material = material;
				}
				if (entity.model.model) {
						var meshInstances = entity.model.model.meshInstances;
						var meshInstancesClone = component.model.meshInstances;
						for(var i = 0; i < meshInstances.length; i++){
								meshInstancesClone[i].mask = meshInstances[i].mask;
								meshInstancesClone[i].material = meshInstances[i].material;
								meshInstancesClone[i].layer = meshInstances[i].layer;
								meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
						}
				}
				if (entity.model.customAabb) {
						component.customAabb = entity.model.customAabb.clone();
				}
				return component;
		}
		onRemove(entity, component) {
				component.onRemove();
		}
		constructor(app){
				super(app);
				this.id = 'model';
				this.ComponentType = ModelComponent;
				this.DataType = ModelComponentData;
				this.schema = _schema$b;
				this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
				this.on('beforeremove', this.onRemove, this);
		}
}
Component._buildAccessors(ModelComponent.prototype, _schema$b);

var SIMPLE_PROPERTIES = [
		'emitterExtents',
		'emitterRadius',
		'emitterExtentsInner',
		'emitterRadiusInner',
		'loop',
		'initialVelocity',
		'animSpeed',
		'normalMap',
		'particleNormal'
];
var COMPLEX_PROPERTIES = [
		'numParticles',
		'lifetime',
		'rate',
		'rate2',
		'startAngle',
		'startAngle2',
		'lighting',
		'halfLambert',
		'intensity',
		'wrap',
		'wrapBounds',
		'depthWrite',
		'noFog',
		'sort',
		'stretch',
		'alignToMotion',
		'preWarm',
		'emitterShape',
		'animTilesX',
		'animTilesY',
		'animStartFrame',
		'animNumFrames',
		'animNumAnimations',
		'animIndex',
		'randomizeAnimIndex',
		'animLoop',
		'colorMap',
		'localSpace',
		'screenSpace',
		'orientation'
];
var GRAPH_PROPERTIES = [
		'scaleGraph',
		'scaleGraph2',
		'colorGraph',
		'colorGraph2',
		'alphaGraph',
		'alphaGraph2',
		'velocityGraph',
		'velocityGraph2',
		'localVelocityGraph',
		'localVelocityGraph2',
		'rotationSpeedGraph',
		'rotationSpeedGraph2',
		'radialSpeedGraph',
		'radialSpeedGraph2'
];
var ASSET_PROPERTIES = [
		'colorMapAsset',
		'normalMapAsset',
		'meshAsset',
		'renderAsset'
];
var depthLayer;
class ParticleSystemComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {
				this._setValue('enabled', arg);
		}
		get enabled() {
				return this.data.enabled;
		}
		set autoPlay(arg) {
				this._setValue('autoPlay', arg);
		}
		get autoPlay() {
				return this.data.autoPlay;
		}
		set numParticles(arg) {
				this._setValue('numParticles', arg);
		}
		get numParticles() {
				return this.data.numParticles;
		}
		set lifetime(arg) {
				this._setValue('lifetime', arg);
		}
		get lifetime() {
				return this.data.lifetime;
		}
		set rate(arg) {
				this._setValue('rate', arg);
		}
		get rate() {
				return this.data.rate;
		}
		set rate2(arg) {
				this._setValue('rate2', arg);
		}
		get rate2() {
				return this.data.rate2;
		}
		set startAngle(arg) {
				this._setValue('startAngle', arg);
		}
		get startAngle() {
				return this.data.startAngle;
		}
		set startAngle2(arg) {
				this._setValue('startAngle2', arg);
		}
		get startAngle2() {
				return this.data.startAngle2;
		}
		set loop(arg) {
				this._setValue('loop', arg);
		}
		get loop() {
				return this.data.loop;
		}
		set preWarm(arg) {
				this._setValue('preWarm', arg);
		}
		get preWarm() {
				return this.data.preWarm;
		}
		set lighting(arg) {
				this._setValue('lighting', arg);
		}
		get lighting() {
				return this.data.lighting;
		}
		set halfLambert(arg) {
				this._setValue('halfLambert', arg);
		}
		get halfLambert() {
				return this.data.halfLambert;
		}
		set intensity(arg) {
				this._setValue('intensity', arg);
		}
		get intensity() {
				return this.data.intensity;
		}
		set depthWrite(arg) {
				this._setValue('depthWrite', arg);
		}
		get depthWrite() {
				return this.data.depthWrite;
		}
		set noFog(arg) {
				this._setValue('noFog', arg);
		}
		get noFog() {
				return this.data.noFog;
		}
		set depthSoftening(arg) {
				this._setValue('depthSoftening', arg);
		}
		get depthSoftening() {
				return this.data.depthSoftening;
		}
		set sort(arg) {
				this._setValue('sort', arg);
		}
		get sort() {
				return this.data.sort;
		}
		set blendType(arg) {
				this._setValue('blendType', arg);
		}
		get blendType() {
				return this.data.blendType;
		}
		set stretch(arg) {
				this._setValue('stretch', arg);
		}
		get stretch() {
				return this.data.stretch;
		}
		set alignToMotion(arg) {
				this._setValue('alignToMotion', arg);
		}
		get alignToMotion() {
				return this.data.alignToMotion;
		}
		set emitterShape(arg) {
				this._setValue('emitterShape', arg);
		}
		get emitterShape() {
				return this.data.emitterShape;
		}
		set emitterExtents(arg) {
				this._setValue('emitterExtents', arg);
		}
		get emitterExtents() {
				return this.data.emitterExtents;
		}
		set emitterExtentsInner(arg) {
				this._setValue('emitterExtentsInner', arg);
		}
		get emitterExtentsInner() {
				return this.data.emitterExtentsInner;
		}
		set emitterRadius(arg) {
				this._setValue('emitterRadius', arg);
		}
		get emitterRadius() {
				return this.data.emitterRadius;
		}
		set emitterRadiusInner(arg) {
				this._setValue('emitterRadiusInner', arg);
		}
		get emitterRadiusInner() {
				return this.data.emitterRadiusInner;
		}
		set initialVelocity(arg) {
				this._setValue('initialVelocity', arg);
		}
		get initialVelocity() {
				return this.data.initialVelocity;
		}
		set wrap(arg) {
				this._setValue('wrap', arg);
		}
		get wrap() {
				return this.data.wrap;
		}
		set wrapBounds(arg) {
				this._setValue('wrapBounds', arg);
		}
		get wrapBounds() {
				return this.data.wrapBounds;
		}
		set localSpace(arg) {
				this._setValue('localSpace', arg);
		}
		get localSpace() {
				return this.data.localSpace;
		}
		set screenSpace(arg) {
				this._setValue('screenSpace', arg);
		}
		get screenSpace() {
				return this.data.screenSpace;
		}
		set colorMapAsset(arg) {
				this._setValue('colorMapAsset', arg);
		}
		get colorMapAsset() {
				return this.data.colorMapAsset;
		}
		set normalMapAsset(arg) {
				this._setValue('normalMapAsset', arg);
		}
		get normalMapAsset() {
				return this.data.normalMapAsset;
		}
		set mesh(arg) {
				this._setValue('mesh', arg);
		}
		get mesh() {
				return this.data.mesh;
		}
		set meshAsset(arg) {
				this._setValue('meshAsset', arg);
		}
		get meshAsset() {
				return this.data.meshAsset;
		}
		set renderAsset(arg) {
				this._setValue('renderAsset', arg);
		}
		get renderAsset() {
				return this.data.renderAsset;
		}
		set orientation(arg) {
				this._setValue('orientation', arg);
		}
		get orientation() {
				return this.data.orientation;
		}
		set particleNormal(arg) {
				this._setValue('particleNormal', arg);
		}
		get particleNormal() {
				return this.data.particleNormal;
		}
		set localVelocityGraph(arg) {
				this._setValue('localVelocityGraph', arg);
		}
		get localVelocityGraph() {
				return this.data.localVelocityGraph;
		}
		set localVelocityGraph2(arg) {
				this._setValue('localVelocityGraph2', arg);
		}
		get localVelocityGraph2() {
				return this.data.localVelocityGraph2;
		}
		set velocityGraph(arg) {
				this._setValue('velocityGraph', arg);
		}
		get velocityGraph() {
				return this.data.velocityGraph;
		}
		set velocityGraph2(arg) {
				this._setValue('velocityGraph2', arg);
		}
		get velocityGraph2() {
				return this.data.velocityGraph2;
		}
		set rotationSpeedGraph(arg) {
				this._setValue('rotationSpeedGraph', arg);
		}
		get rotationSpeedGraph() {
				return this.data.rotationSpeedGraph;
		}
		set rotationSpeedGraph2(arg) {
				this._setValue('rotationSpeedGraph2', arg);
		}
		get rotationSpeedGraph2() {
				return this.data.rotationSpeedGraph2;
		}
		set radialSpeedGraph(arg) {
				this._setValue('radialSpeedGraph', arg);
		}
		get radialSpeedGraph() {
				return this.data.radialSpeedGraph;
		}
		set radialSpeedGraph2(arg) {
				this._setValue('radialSpeedGraph2', arg);
		}
		get radialSpeedGraph2() {
				return this.data.radialSpeedGraph2;
		}
		set scaleGraph(arg) {
				this._setValue('scaleGraph', arg);
		}
		get scaleGraph() {
				return this.data.scaleGraph;
		}
		set scaleGraph2(arg) {
				this._setValue('scaleGraph2', arg);
		}
		get scaleGraph2() {
				return this.data.scaleGraph2;
		}
		set colorGraph(arg) {
				this._setValue('colorGraph', arg);
		}
		get colorGraph() {
				return this.data.colorGraph;
		}
		set colorGraph2(arg) {
				this._setValue('colorGraph2', arg);
		}
		get colorGraph2() {
				return this.data.colorGraph2;
		}
		set alphaGraph(arg) {
				this._setValue('alphaGraph', arg);
		}
		get alphaGraph() {
				return this.data.alphaGraph;
		}
		set alphaGraph2(arg) {
				this._setValue('alphaGraph2', arg);
		}
		get alphaGraph2() {
				return this.data.alphaGraph2;
		}
		set colorMap(arg) {
				this._setValue('colorMap', arg);
		}
		get colorMap() {
				return this.data.colorMap;
		}
		set normalMap(arg) {
				this._setValue('normalMap', arg);
		}
		get normalMap() {
				return this.data.normalMap;
		}
		set animTilesX(arg) {
				this._setValue('animTilesX', arg);
		}
		get animTilesX() {
				return this.data.animTilesX;
		}
		set animTilesY(arg) {
				this._setValue('animTilesY', arg);
		}
		get animTilesY() {
				return this.data.animTilesY;
		}
		set animStartFrame(arg) {
				this._setValue('animStartFrame', arg);
		}
		get animStartFrame() {
				return this.data.animStartFrame;
		}
		set animNumFrames(arg) {
				this._setValue('animNumFrames', arg);
		}
		get animNumFrames() {
				return this.data.animNumFrames;
		}
		set animNumAnimations(arg) {
				this._setValue('animNumAnimations', arg);
		}
		get animNumAnimations() {
				return this.data.animNumAnimations;
		}
		set animIndex(arg) {
				this._setValue('animIndex', arg);
		}
		get animIndex() {
				return this.data.animIndex;
		}
		set randomizeAnimIndex(arg) {
				this._setValue('randomizeAnimIndex', arg);
		}
		get randomizeAnimIndex() {
				return this.data.randomizeAnimIndex;
		}
		set animSpeed(arg) {
				this._setValue('animSpeed', arg);
		}
		get animSpeed() {
				return this.data.animSpeed;
		}
		set animLoop(arg) {
				this._setValue('animLoop', arg);
		}
		get animLoop() {
				return this.data.animLoop;
		}
		set layers(arg) {
				this._setValue('layers', arg);
		}
		get layers() {
				return this.data.layers;
		}
		set drawOrder(drawOrder) {
				this._drawOrder = drawOrder;
				if (this.emitter) {
						this.emitter.drawOrder = drawOrder;
				}
		}
		get drawOrder() {
				return this._drawOrder;
		}
		_setValue(name, value) {
				var data = this.data;
				var oldValue = data[name];
				data[name] = value;
				this.fire('set', name, oldValue, value);
		}
		addMeshInstanceToLayers() {
				if (!this.emitter) return;
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (!layer) continue;
						layer.addMeshInstances([
								this.emitter.meshInstance
						]);
						this.emitter._layer = layer;
				}
		}
		removeMeshInstanceFromLayers() {
				if (!this.emitter) return;
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (!layer) continue;
						layer.removeMeshInstances([
								this.emitter.meshInstance
						]);
				}
		}
		onSetLayers(name, oldValue, newValue) {
				if (!this.emitter) return;
				for(var i = 0; i < oldValue.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
						if (!layer) continue;
						layer.removeMeshInstances([
								this.emitter.meshInstance
						]);
				}
				if (!this.enabled || !this.entity.enabled) return;
				for(var i1 = 0; i1 < newValue.length; i1++){
						var layer1 = this.system.app.scene.layers.getLayerById(newValue[i1]);
						if (!layer1) continue;
						layer1.addMeshInstances([
								this.emitter.meshInstance
						]);
				}
		}
		onLayersChanged(oldComp, newComp) {
				this.addMeshInstanceToLayers();
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				if (!this.emitter) return;
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.addMeshInstances([
						this.emitter.meshInstance
				]);
		}
		onLayerRemoved(layer) {
				if (!this.emitter) return;
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.removeMeshInstances([
						this.emitter.meshInstance
				]);
		}
		_bindColorMapAsset(asset) {
				asset.on('load', this._onColorMapAssetLoad, this);
				asset.on('unload', this._onColorMapAssetUnload, this);
				asset.on('remove', this._onColorMapAssetRemove, this);
				asset.on('change', this._onColorMapAssetChange, this);
				if (asset.resource) {
						this._onColorMapAssetLoad(asset);
				} else {
						if (!this.enabled || !this.entity.enabled) return;
						this.system.app.assets.load(asset);
				}
		}
		_unbindColorMapAsset(asset) {
				asset.off('load', this._onColorMapAssetLoad, this);
				asset.off('unload', this._onColorMapAssetUnload, this);
				asset.off('remove', this._onColorMapAssetRemove, this);
				asset.off('change', this._onColorMapAssetChange, this);
		}
		_onColorMapAssetLoad(asset) {
				this.colorMap = asset.resource;
		}
		_onColorMapAssetUnload(asset) {
				this.colorMap = null;
		}
		_onColorMapAssetRemove(asset) {
				this._onColorMapAssetUnload(asset);
		}
		_onColorMapAssetChange(asset) {}
		onSetColorMapAsset(name, oldValue, newValue) {
				var assets = this.system.app.assets;
				if (oldValue) {
						var asset = assets.get(oldValue);
						if (asset) {
								this._unbindColorMapAsset(asset);
						}
				}
				if (newValue) {
						if (newValue instanceof Asset) {
								this.data.colorMapAsset = newValue.id;
								newValue = newValue.id;
						}
						var asset1 = assets.get(newValue);
						if (asset1) {
								this._bindColorMapAsset(asset1);
						} else {
								assets.once("add:" + newValue, (asset)=>{
										this._bindColorMapAsset(asset);
								});
						}
				} else {
						this.colorMap = null;
				}
		}
		_bindNormalMapAsset(asset) {
				asset.on('load', this._onNormalMapAssetLoad, this);
				asset.on('unload', this._onNormalMapAssetUnload, this);
				asset.on('remove', this._onNormalMapAssetRemove, this);
				asset.on('change', this._onNormalMapAssetChange, this);
				if (asset.resource) {
						this._onNormalMapAssetLoad(asset);
				} else {
						if (!this.enabled || !this.entity.enabled) return;
						this.system.app.assets.load(asset);
				}
		}
		_unbindNormalMapAsset(asset) {
				asset.off('load', this._onNormalMapAssetLoad, this);
				asset.off('unload', this._onNormalMapAssetUnload, this);
				asset.off('remove', this._onNormalMapAssetRemove, this);
				asset.off('change', this._onNormalMapAssetChange, this);
		}
		_onNormalMapAssetLoad(asset) {
				this.normalMap = asset.resource;
		}
		_onNormalMapAssetUnload(asset) {
				this.normalMap = null;
		}
		_onNormalMapAssetRemove(asset) {
				this._onNormalMapAssetUnload(asset);
		}
		_onNormalMapAssetChange(asset) {}
		onSetNormalMapAsset(name, oldValue, newValue) {
				var assets = this.system.app.assets;
				if (oldValue) {
						var asset = assets.get(oldValue);
						if (asset) {
								this._unbindNormalMapAsset(asset);
						}
				}
				if (newValue) {
						if (newValue instanceof Asset) {
								this.data.normalMapAsset = newValue.id;
								newValue = newValue.id;
						}
						var asset1 = assets.get(newValue);
						if (asset1) {
								this._bindNormalMapAsset(asset1);
						} else {
								assets.once("add:" + newValue, (asset)=>{
										this._bindNormalMapAsset(asset);
								});
						}
				} else {
						this.normalMap = null;
				}
		}
		_bindMeshAsset(asset) {
				asset.on('load', this._onMeshAssetLoad, this);
				asset.on('unload', this._onMeshAssetUnload, this);
				asset.on('remove', this._onMeshAssetRemove, this);
				asset.on('change', this._onMeshAssetChange, this);
				if (asset.resource) {
						this._onMeshAssetLoad(asset);
				} else {
						if (!this.enabled || !this.entity.enabled) return;
						this.system.app.assets.load(asset);
				}
		}
		_unbindMeshAsset(asset) {
				asset.off('load', this._onMeshAssetLoad, this);
				asset.off('unload', this._onMeshAssetUnload, this);
				asset.off('remove', this._onMeshAssetRemove, this);
				asset.off('change', this._onMeshAssetChange, this);
		}
		_onMeshAssetLoad(asset) {
				this._onMeshChanged(asset.resource);
		}
		_onMeshAssetUnload(asset) {
				this.mesh = null;
		}
		_onMeshAssetRemove(asset) {
				this._onMeshAssetUnload(asset);
		}
		_onMeshAssetChange(asset) {}
		onSetMeshAsset(name, oldValue, newValue) {
				var assets = this.system.app.assets;
				if (oldValue) {
						var asset = assets.get(oldValue);
						if (asset) {
								this._unbindMeshAsset(asset);
						}
				}
				if (newValue) {
						if (newValue instanceof Asset) {
								this.data.meshAsset = newValue.id;
								newValue = newValue.id;
						}
						var asset1 = assets.get(newValue);
						if (asset1) {
								this._bindMeshAsset(asset1);
						}
				} else {
						this._onMeshChanged(null);
				}
		}
		onSetMesh(name, oldValue, newValue) {
				if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
						this.meshAsset = newValue;
				} else {
						this._onMeshChanged(newValue);
				}
		}
		_onMeshChanged(mesh) {
				if (mesh && !(mesh instanceof Mesh)) {
						if (mesh.meshInstances[0]) {
								mesh = mesh.meshInstances[0].mesh;
						} else {
								mesh = null;
						}
				}
				this.data.mesh = mesh;
				if (this.emitter) {
						this.emitter.mesh = mesh;
						this.emitter.resetMaterial();
						this.rebuild();
				}
		}
		onSetRenderAsset(name, oldValue, newValue) {
				var assets = this.system.app.assets;
				if (oldValue) {
						var asset = assets.get(oldValue);
						if (asset) {
								this._unbindRenderAsset(asset);
						}
				}
				if (newValue) {
						if (newValue instanceof Asset) {
								this.data.renderAsset = newValue.id;
								newValue = newValue.id;
						}
						var asset1 = assets.get(newValue);
						if (asset1) {
								this._bindRenderAsset(asset1);
						}
				} else {
						this._onRenderChanged(null);
				}
		}
		_bindRenderAsset(asset) {
				asset.on('load', this._onRenderAssetLoad, this);
				asset.on('unload', this._onRenderAssetUnload, this);
				asset.on('remove', this._onRenderAssetRemove, this);
				if (asset.resource) {
						this._onRenderAssetLoad(asset);
				} else {
						if (!this.enabled || !this.entity.enabled) return;
						this.system.app.assets.load(asset);
				}
		}
		_unbindRenderAsset(asset) {
				var _this__evtSetMeshes;
				asset.off('load', this._onRenderAssetLoad, this);
				asset.off('unload', this._onRenderAssetUnload, this);
				asset.off('remove', this._onRenderAssetRemove, this);
				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
				this._evtSetMeshes = null;
		}
		_onRenderAssetLoad(asset) {
				this._onRenderChanged(asset.resource);
		}
		_onRenderAssetUnload(asset) {
				this._onRenderChanged(null);
		}
		_onRenderAssetRemove(asset) {
				this._onRenderAssetUnload(asset);
		}
		_onRenderChanged(render) {
				var _this__evtSetMeshes;
				if (!render) {
						this._onMeshChanged(null);
						return;
				}
				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
				this._evtSetMeshes = render.on('set:meshes', this._onRenderSetMeshes, this);
				if (render.meshes) {
						this._onRenderSetMeshes(render.meshes);
				}
		}
		_onRenderSetMeshes(meshes) {
				this._onMeshChanged(meshes && meshes[0]);
		}
		onSetLoop(name, oldValue, newValue) {
				if (this.emitter) {
						this.emitter[name] = newValue;
						this.emitter.resetTime();
				}
		}
		onSetBlendType(name, oldValue, newValue) {
				if (this.emitter) {
						this.emitter[name] = newValue;
						this.emitter.material.blendType = newValue;
						this.emitter.resetMaterial();
						this.rebuild();
				}
		}
		_requestDepth() {
				if (this._requestedDepth) return;
				if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
				if (depthLayer) {
						depthLayer.incrementCounter();
						this._requestedDepth = true;
				}
		}
		_releaseDepth() {
				if (!this._requestedDepth) return;
				if (depthLayer) {
						depthLayer.decrementCounter();
						this._requestedDepth = false;
				}
		}
		onSetDepthSoftening(name, oldValue, newValue) {
				if (oldValue !== newValue) {
						if (newValue) {
								if (this.enabled && this.entity.enabled) this._requestDepth();
								if (this.emitter) this.emitter[name] = newValue;
						} else {
								if (this.enabled && this.entity.enabled) this._releaseDepth();
								if (this.emitter) this.emitter[name] = newValue;
						}
						if (this.emitter) {
								this.reset();
								this.emitter.resetMaterial();
								this.rebuild();
						}
				}
		}
		onSetSimpleProperty(name, oldValue, newValue) {
				if (this.emitter) {
						this.emitter[name] = newValue;
						this.emitter.resetMaterial();
				}
		}
		onSetComplexProperty(name, oldValue, newValue) {
				if (this.emitter) {
						this.emitter[name] = newValue;
						this.emitter.resetMaterial();
						this.rebuild();
						this.reset();
				}
		}
		onSetGraphProperty(name, oldValue, newValue) {
				if (this.emitter) {
						this.emitter[name] = newValue;
						this.emitter.rebuildGraphs();
						this.emitter.resetMaterial();
				}
		}
		onEnable() {
				var scene = this.system.app.scene;
				var layers = scene.layers;
				var data = this.data;
				for(var i = 0, len = ASSET_PROPERTIES.length; i < len; i++){
						var asset = data[ASSET_PROPERTIES[i]];
						if (asset) {
								if (!(asset instanceof Asset)) {
										var id = parseInt(asset, 10);
										if (id >= 0) {
												asset = this.system.app.assets.get(asset);
										} else {
												continue;
										}
								}
								if (asset && !asset.resource) {
										this.system.app.assets.load(asset);
								}
						}
				}
				if (this.system.app.graphicsDevice.disableParticleSystem) {
						return;
				}
				if (!this.emitter) {
						var mesh = data.mesh;
						if (!(mesh instanceof Mesh)) {
								mesh = null;
						}
						this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
								numParticles: data.numParticles,
								emitterExtents: data.emitterExtents,
								emitterExtentsInner: data.emitterExtentsInner,
								emitterRadius: data.emitterRadius,
								emitterRadiusInner: data.emitterRadiusInner,
								emitterShape: data.emitterShape,
								initialVelocity: data.initialVelocity,
								wrap: data.wrap,
								localSpace: data.localSpace,
								screenSpace: data.screenSpace,
								wrapBounds: data.wrapBounds,
								lifetime: data.lifetime,
								rate: data.rate,
								rate2: data.rate2,
								orientation: data.orientation,
								particleNormal: data.particleNormal,
								animTilesX: data.animTilesX,
								animTilesY: data.animTilesY,
								animStartFrame: data.animStartFrame,
								animNumFrames: data.animNumFrames,
								animNumAnimations: data.animNumAnimations,
								animIndex: data.animIndex,
								randomizeAnimIndex: data.randomizeAnimIndex,
								animSpeed: data.animSpeed,
								animLoop: data.animLoop,
								startAngle: data.startAngle,
								startAngle2: data.startAngle2,
								scaleGraph: data.scaleGraph,
								scaleGraph2: data.scaleGraph2,
								colorGraph: data.colorGraph,
								colorGraph2: data.colorGraph2,
								alphaGraph: data.alphaGraph,
								alphaGraph2: data.alphaGraph2,
								localVelocityGraph: data.localVelocityGraph,
								localVelocityGraph2: data.localVelocityGraph2,
								velocityGraph: data.velocityGraph,
								velocityGraph2: data.velocityGraph2,
								rotationSpeedGraph: data.rotationSpeedGraph,
								rotationSpeedGraph2: data.rotationSpeedGraph2,
								radialSpeedGraph: data.radialSpeedGraph,
								radialSpeedGraph2: data.radialSpeedGraph2,
								colorMap: data.colorMap,
								normalMap: data.normalMap,
								loop: data.loop,
								preWarm: data.preWarm,
								sort: data.sort,
								stretch: data.stretch,
								alignToMotion: data.alignToMotion,
								lighting: data.lighting,
								halfLambert: data.halfLambert,
								intensity: data.intensity,
								depthSoftening: data.depthSoftening,
								scene: this.system.app.scene,
								mesh: mesh,
								depthWrite: data.depthWrite,
								noFog: data.noFog,
								node: this.entity,
								blendType: data.blendType
						});
						this.emitter.meshInstance.node = this.entity;
						this.emitter.drawOrder = this.drawOrder;
						if (!data.autoPlay) {
								this.pause();
								this.emitter.meshInstance.visible = false;
						}
				}
				if (this.emitter.colorMap) {
						this.addMeshInstanceToLayers();
				}
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				if (this.enabled && this.entity.enabled && data.depthSoftening) {
						this._requestDepth();
				}
		}
		onDisable() {
				var _this__evtLayersChanged;
				var scene = this.system.app.scene;
				var layers = scene.layers;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				if (this.emitter) {
						this.removeMeshInstanceFromLayers();
						if (this.data.depthSoftening) this._releaseDepth();
						this.emitter.camera = null;
				}
		}
		onBeforeRemove() {
				if (this.enabled) {
						this.enabled = false;
				}
				if (this.emitter) {
						this.emitter.destroy();
						this.emitter = null;
				}
				for(var i = 0; i < ASSET_PROPERTIES.length; i++){
						var prop = ASSET_PROPERTIES[i];
						if (this.data[prop]) {
								this[prop] = null;
						}
				}
				this.off();
		}
		reset() {
				if (this.emitter) {
						this.emitter.reset();
				}
		}
		stop() {
				if (this.emitter) {
						this.emitter.loop = false;
						this.emitter.resetTime();
						this.emitter.addTime(0, true);
				}
		}
		pause() {
				this.data.paused = true;
		}
		unpause() {
				this.data.paused = false;
		}
		play() {
				this.data.paused = false;
				if (this.emitter) {
						this.emitter.meshInstance.visible = true;
						this.emitter.loop = this.data.loop;
						this.emitter.resetTime();
				}
		}
		isPlaying() {
				if (this.data.paused) {
						return false;
				}
				if (this.emitter && this.emitter.loop) {
						return true;
				}
				return Date.now() <= this.emitter.endTime;
		}
		setInTools() {
				var { emitter } = this;
				if (emitter && !emitter.inTools) {
						emitter.inTools = true;
						this.rebuild();
				}
		}
		rebuild() {
				var enabled = this.enabled;
				this.enabled = false;
				if (this.emitter) {
						this.emitter.rebuild();
				}
				this.enabled = enabled;
		}
		constructor(system, entity){
				super(system, entity), this._requestedDepth = false, this._drawOrder = 0, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._evtSetMeshes = null;
				this.on('set_colorMapAsset', this.onSetColorMapAsset, this);
				this.on('set_normalMapAsset', this.onSetNormalMapAsset, this);
				this.on('set_meshAsset', this.onSetMeshAsset, this);
				this.on('set_mesh', this.onSetMesh, this);
				this.on('set_renderAsset', this.onSetRenderAsset, this);
				this.on('set_loop', this.onSetLoop, this);
				this.on('set_blendType', this.onSetBlendType, this);
				this.on('set_depthSoftening', this.onSetDepthSoftening, this);
				this.on('set_layers', this.onSetLayers, this);
				SIMPLE_PROPERTIES.forEach((prop)=>{
						this.on("set_" + prop, this.onSetSimpleProperty, this);
				});
				COMPLEX_PROPERTIES.forEach((prop)=>{
						this.on("set_" + prop, this.onSetComplexProperty, this);
				});
				GRAPH_PROPERTIES.forEach((prop)=>{
						this.on("set_" + prop, this.onSetGraphProperty, this);
				});
		}
}

class ParticleSystemComponentData {
		constructor(){
				this.numParticles = 1;
				this.rate = 1;
				this.rate2 = null;
				this.startAngle = 0;
				this.startAngle2 = null;
				this.lifetime = 50;
				this.emitterExtents = new Vec3();
				this.emitterExtentsInner = new Vec3();
				this.emitterRadius = 0;
				this.emitterRadiusInner = 0;
				this.emitterShape = EMITTERSHAPE_BOX;
				this.initialVelocity = 0;
				this.wrap = false;
				this.wrapBounds = new Vec3();
				this.localSpace = false;
				this.screenSpace = false;
				this.colorMap = null;
				this.colorMapAsset = null;
				this.normalMap = null;
				this.normalMapAsset = null;
				this.loop = true;
				this.preWarm = false;
				this.sort = 0;
				this.mode = PARTICLEMODE_GPU;
				this.scene = null;
				this.lighting = false;
				this.halfLambert = false;
				this.intensity = 1;
				this.stretch = 0.0;
				this.alignToMotion = false;
				this.depthSoftening = 0;
				this.renderAsset = null;
				this.meshAsset = null;
				this.mesh = null;
				this.depthWrite = false;
				this.noFog = false;
				this.orientation = PARTICLEORIENTATION_SCREEN;
				this.particleNormal = new Vec3(0, 1, 0);
				this.animTilesX = 1;
				this.animTilesY = 1;
				this.animStartFrame = 0;
				this.animNumFrames = 1;
				this.animNumAnimations = 1;
				this.animIndex = 0;
				this.randomizeAnimIndex = false;
				this.animSpeed = 1;
				this.animLoop = true;
				this.scaleGraph = null;
				this.scaleGraph2 = null;
				this.colorGraph = null;
				this.colorGraph2 = null;
				this.alphaGraph = null;
				this.alphaGraph2 = null;
				this.localVelocityGraph = null;
				this.localVelocityGraph2 = null;
				this.velocityGraph = null;
				this.velocityGraph2 = null;
				this.rotationSpeedGraph = null;
				this.rotationSpeedGraph2 = null;
				this.radialSpeedGraph = null;
				this.radialSpeedGraph2 = null;
				this.blendType = BLEND_NORMAL;
				this.enabled = true;
				this.paused = false;
				this.autoPlay = true;
				this.layers = [
						LAYERID_WORLD
				];
		}
}

var _schema$a = [
		'enabled',
		'autoPlay',
		'numParticles',
		'lifetime',
		'rate',
		'rate2',
		'startAngle',
		'startAngle2',
		'loop',
		'preWarm',
		'lighting',
		'halfLambert',
		'intensity',
		'depthWrite',
		'noFog',
		'depthSoftening',
		'sort',
		'blendType',
		'stretch',
		'alignToMotion',
		'emitterShape',
		'emitterExtents',
		'emitterExtentsInner',
		'emitterRadius',
		'emitterRadiusInner',
		'initialVelocity',
		'wrap',
		'wrapBounds',
		'localSpace',
		'screenSpace',
		'colorMapAsset',
		'normalMapAsset',
		'mesh',
		'meshAsset',
		'renderAsset',
		'orientation',
		'particleNormal',
		'localVelocityGraph',
		'localVelocityGraph2',
		'velocityGraph',
		'velocityGraph2',
		'rotationSpeedGraph',
		'rotationSpeedGraph2',
		'radialSpeedGraph',
		'radialSpeedGraph2',
		'scaleGraph',
		'scaleGraph2',
		'colorGraph',
		'colorGraph2',
		'alphaGraph',
		'alphaGraph2',
		'colorMap',
		'normalMap',
		'animTilesX',
		'animTilesY',
		'animStartFrame',
		'animNumFrames',
		'animNumAnimations',
		'animIndex',
		'randomizeAnimIndex',
		'animSpeed',
		'animLoop',
		'layers'
];
class ParticleSystemComponentSystem extends ComponentSystem {
		initializeComponentData(component, _data, properties) {
				var data = {};
				properties = [];
				var types = this.propertyTypes;
				if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
						_data.meshAsset = _data.mesh;
						delete _data.mesh;
				}
				for(var prop in _data){
						if (_data.hasOwnProperty(prop)) {
								properties.push(prop);
								data[prop] = _data[prop];
						}
						if (types[prop] === 'vec3') {
								if (Array.isArray(data[prop])) {
										data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
								}
						} else if (types[prop] === 'curve') {
								if (!(data[prop] instanceof Curve)) {
										var t = data[prop].type;
										data[prop] = new Curve(data[prop].keys);
										data[prop].type = t;
								}
						} else if (types[prop] === 'curveset') {
								if (!(data[prop] instanceof CurveSet)) {
										var t1 = data[prop].type;
										data[prop] = new CurveSet(data[prop].keys);
										data[prop].type = t1;
								}
						}
						if (data.layers && Array.isArray(data.layers)) {
								data.layers = data.layers.slice(0);
						}
				}
				super.initializeComponentData(component, data, properties);
		}
		cloneComponent(entity, clone) {
				var source = entity.particlesystem.data;
				var schema = this.schema;
				var data = {};
				for(var i = 0, len = schema.length; i < len; i++){
						var prop = schema[i];
						var sourceProp = source[prop];
						if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
								sourceProp = sourceProp.clone();
								data[prop] = sourceProp;
						} else if (prop === 'layers') {
								data.layers = source.layers.slice(0);
						} else {
								if (sourceProp !== null && sourceProp !== undefined) {
										data[prop] = sourceProp;
								}
						}
				}
				return this.addComponent(clone, data);
		}
		onUpdate(dt) {
				var components = this.store;
				var numSteps;
				var stats = this.app.stats.particles;
				var composition = this.app.scene.layers;
				for(var i = 0; i < composition.layerList.length; i++){
						composition.layerList[i].requiresLightCube = false;
				}
				for(var id in components){
						if (components.hasOwnProperty(id)) {
								var component = components[id];
								var entity = component.entity;
								var data = component.data;
								if (data.enabled && entity.enabled) {
										var emitter = entity.particlesystem.emitter;
										if (!(emitter == null ? void 0 : emitter.meshInstance.visible)) continue;
										if (emitter.lighting) {
												var layers = data.layers;
												for(var i1 = 0; i1 < layers.length; i1++){
														var layer = composition.getLayerById(layers[i1]);
														if (layer) {
																layer.requiresLightCube = true;
														}
												}
										}
										if (!data.paused) {
												emitter.simTime += dt;
												if (emitter.simTime > emitter.fixedTimeStep) {
														numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
														emitter.simTime -= numSteps * emitter.fixedTimeStep;
												}
												if (numSteps) {
														numSteps = Math.min(numSteps, emitter.maxSubSteps);
														for(var i2 = 0; i2 < numSteps; i2++){
																emitter.addTime(emitter.fixedTimeStep, false);
														}
														stats._updatesPerFrame += numSteps;
														stats._frameTime += emitter._addTimeTime;
														emitter._addTimeTime = 0;
												}
												emitter.finishFrame();
										}
								}
						}
				}
		}
		onBeforeRemove(entity, component) {
				component.onBeforeRemove();
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'particlesystem';
				this.ComponentType = ParticleSystemComponent;
				this.DataType = ParticleSystemComponentData;
				this.schema = _schema$a;
				this.propertyTypes = {
						emitterExtents: 'vec3',
						emitterExtentsInner: 'vec3',
						particleNormal: 'vec3',
						wrapBounds: 'vec3',
						localVelocityGraph: 'curveset',
						localVelocityGraph2: 'curveset',
						velocityGraph: 'curveset',
						velocityGraph2: 'curveset',
						colorGraph: 'curveset',
						colorGraph2: 'curveset',
						alphaGraph: 'curve',
						alphaGraph2: 'curve',
						rotationSpeedGraph: 'curve',
						rotationSpeedGraph2: 'curve',
						radialSpeedGraph: 'curve',
						radialSpeedGraph2: 'curve',
						scaleGraph: 'curve',
						scaleGraph2: 'curve'
				};
				this.on('beforeremove', this.onBeforeRemove, this);
				this.app.systems.on('update', this.onUpdate, this);
		}
}

class SkinInstanceCachedObject extends RefCountedObject {
		constructor(skin, skinInstance){
				super();
				this.skin = skin;
				this.skinInstance = skinInstance;
		}
}
class SkinInstanceCache {
		static createCachedSkinInstance(skin, rootBone, entity) {
				var skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);
				if (!skinInst) {
						skinInst = new SkinInstance(skin);
						skinInst.resolve(rootBone, entity);
						SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
				}
				return skinInst;
		}
		static getCachedSkinInstance(skin, rootBone) {
				var skinInstance = null;
				var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
				if (cachedObjArray) {
						var cachedObj = cachedObjArray.find((element)=>element.skin === skin);
						if (cachedObj) {
								cachedObj.incRefCount();
								skinInstance = cachedObj.skinInstance;
						}
				}
				return skinInstance;
		}
		static addCachedSkinInstance(skin, rootBone, skinInstance) {
				var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
				if (!cachedObjArray) {
						cachedObjArray = [];
						SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
				}
				var cachedObj = cachedObjArray.find((element)=>element.skin === skin);
				if (!cachedObj) {
						cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
						cachedObjArray.push(cachedObj);
				}
				cachedObj.incRefCount();
		}
		static removeCachedSkinInstance(skinInstance) {
				if (skinInstance) {
						var rootBone = skinInstance.rootBone;
						if (rootBone) {
								var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
								if (cachedObjArray) {
										var cachedObjIndex = cachedObjArray.findIndex((element)=>element.skinInstance === skinInstance);
										if (cachedObjIndex >= 0) {
												var cachedObj = cachedObjArray[cachedObjIndex];
												cachedObj.decRefCount();
												if (cachedObj.refCount === 0) {
														cachedObjArray.splice(cachedObjIndex, 1);
														if (!cachedObjArray.length) {
																SkinInstanceCache._skinInstanceCache.delete(rootBone);
														}
														if (skinInstance) {
																skinInstance.destroy();
																cachedObj.skinInstance = null;
														}
												}
										}
								}
						}
				}
		}
}
SkinInstanceCache._skinInstanceCache = new Map();

class AssetReference {
		set id(value) {
				if (this.url) throw Error('Can\'t set id and url');
				this._unbind();
				this._id = value;
				this.asset = this._registry.get(this._id);
				this._bind();
		}
		get id() {
				return this._id;
		}
		set url(value) {
				if (this.id) throw Error('Can\'t set id and url');
				this._unbind();
				this._url = value;
				this.asset = this._registry.getByUrl(this._url);
				this._bind();
		}
		get url() {
				return this._url;
		}
		_bind() {
				if (this.id) {
						if (this._onAssetLoad) this._evtLoadById = this._registry.on("load:" + this.id, this._onLoad, this);
						if (this._onAssetAdd) this._evtAddById = this._registry.once("add:" + this.id, this._onAdd, this);
						if (this._onAssetRemove) this._evtRemoveById = this._registry.on("remove:" + this.id, this._onRemove, this);
						if (this._onAssetUnload) this._evtUnloadById = this._registry.on("unload:" + this.id, this._onUnload, this);
				}
				if (this.url) {
						if (this._onAssetLoad) this._evtLoadByUrl = this._registry.on("load:url:" + this.url, this._onLoad, this);
						if (this._onAssetAdd) this._evtAddByUrl = this._registry.once("add:url:" + this.url, this._onAdd, this);
						if (this._onAssetRemove) this._evtRemoveByUrl = this._registry.on("remove:url:" + this.url, this._onRemove, this);
				}
		}
		_unbind() {
				if (this.id) {
						var _this__evtLoadById, _this__evtAddById, _this__evtRemoveById, _this__evtUnloadById;
						(_this__evtLoadById = this._evtLoadById) == null ? void 0 : _this__evtLoadById.off();
						this._evtLoadById = null;
						(_this__evtAddById = this._evtAddById) == null ? void 0 : _this__evtAddById.off();
						this._evtAddById = null;
						(_this__evtRemoveById = this._evtRemoveById) == null ? void 0 : _this__evtRemoveById.off();
						this._evtRemoveById = null;
						(_this__evtUnloadById = this._evtUnloadById) == null ? void 0 : _this__evtUnloadById.off();
						this._evtUnloadById = null;
				}
				if (this.url) {
						var _this__evtLoadByUrl, _this__evtAddByUrl, _this__evtRemoveByUrl;
						(_this__evtLoadByUrl = this._evtLoadByUrl) == null ? void 0 : _this__evtLoadByUrl.off();
						this._evtLoadByUrl = null;
						(_this__evtAddByUrl = this._evtAddByUrl) == null ? void 0 : _this__evtAddByUrl.off();
						this._evtAddByUrl = null;
						(_this__evtRemoveByUrl = this._evtRemoveByUrl) == null ? void 0 : _this__evtRemoveByUrl.off();
						this._evtRemoveByUrl = null;
				}
		}
		_onLoad(asset) {
				this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
		}
		_onAdd(asset) {
				this.asset = asset;
				this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
		}
		_onRemove(asset) {
				this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
				this.asset = null;
		}
		_onUnload(asset) {
				this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
		}
		constructor(propertyName, parent, registry, callbacks, scope){
				this._evtLoadById = null;
				this._evtUnloadById = null;
				this._evtAddById = null;
				this._evtRemoveById = null;
				this._evtLoadByUrl = null;
				this._evtAddByUrl = null;
				this._evtRemoveByUrl = null;
				this.propertyName = propertyName;
				this.parent = parent;
				this._scope = scope;
				this._registry = registry;
				this.id = null;
				this.url = null;
				this.asset = null;
				this._onAssetLoad = callbacks.load;
				this._onAssetAdd = callbacks.add;
				this._onAssetRemove = callbacks.remove;
				this._onAssetUnload = callbacks.unload;
		}
}

class RenderComponent extends Component {
		set renderStyle(renderStyle) {
				if (this._renderStyle !== renderStyle) {
						this._renderStyle = renderStyle;
						MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
				}
		}
		get renderStyle() {
				return this._renderStyle;
		}
		set customAabb(value) {
				this._customAabb = value;
				var mi = this._meshInstances;
				if (mi) {
						for(var i = 0; i < mi.length; i++){
								mi[i].setCustomAabb(this._customAabb);
						}
				}
		}
		get customAabb() {
				return this._customAabb;
		}
		set type(value) {
				if (this._type !== value) {
						this._area = null;
						this._type = value;
						this.destroyMeshInstances();
						if (value !== 'asset') {
								var material = this._material;
								if (!material || material === this.system.defaultMaterial) {
										material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
								}
								var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
								this._area = primData.area;
								this.meshInstances = [
										new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)
								];
						}
				}
		}
		get type() {
				return this._type;
		}
		set meshInstances(value) {
				this.destroyMeshInstances();
				this._meshInstances = value;
				if (this._meshInstances) {
						var mi = this._meshInstances;
						for(var i = 0; i < mi.length; i++){
								if (!mi[i].node) {
										mi[i].node = this.entity;
								}
								mi[i].castShadow = this._castShadows;
								mi[i].receiveShadow = this._receiveShadows;
								mi[i].renderStyle = this._renderStyle;
								mi[i].setLightmapped(this._lightmapped);
								mi[i].setCustomAabb(this._customAabb);
						}
						if (this.enabled && this.entity.enabled) {
								this.addToLayers();
						}
				}
		}
		get meshInstances() {
				return this._meshInstances;
		}
		set lightmapped(value) {
				if (value !== this._lightmapped) {
						this._lightmapped = value;
						var mi = this._meshInstances;
						if (mi) {
								for(var i = 0; i < mi.length; i++){
										mi[i].setLightmapped(value);
								}
						}
				}
		}
		get lightmapped() {
				return this._lightmapped;
		}
		set castShadows(value) {
				if (this._castShadows !== value) {
						var mi = this._meshInstances;
						if (mi) {
								var layers = this.layers;
								var scene = this.system.app.scene;
								if (this._castShadows && !value) {
										for(var i = 0; i < layers.length; i++){
												var layer = scene.layers.getLayerById(this.layers[i]);
												if (layer) {
														layer.removeShadowCasters(mi);
												}
										}
								}
								for(var i1 = 0; i1 < mi.length; i1++){
										mi[i1].castShadow = value;
								}
								if (!this._castShadows && value) {
										for(var i2 = 0; i2 < layers.length; i2++){
												var layer1 = scene.layers.getLayerById(layers[i2]);
												if (layer1) {
														layer1.addShadowCasters(mi);
												}
										}
								}
						}
						this._castShadows = value;
				}
		}
		get castShadows() {
				return this._castShadows;
		}
		set receiveShadows(value) {
				if (this._receiveShadows !== value) {
						this._receiveShadows = value;
						var mi = this._meshInstances;
						if (mi) {
								for(var i = 0; i < mi.length; i++){
										mi[i].receiveShadow = value;
								}
						}
				}
		}
		get receiveShadows() {
				return this._receiveShadows;
		}
		set castShadowsLightmap(value) {
				this._castShadowsLightmap = value;
		}
		get castShadowsLightmap() {
				return this._castShadowsLightmap;
		}
		set lightmapSizeMultiplier(value) {
				this._lightmapSizeMultiplier = value;
		}
		get lightmapSizeMultiplier() {
				return this._lightmapSizeMultiplier;
		}
		set layers(value) {
				var layers = this.system.app.scene.layers;
				var layer;
				if (this._meshInstances) {
						for(var i = 0; i < this._layers.length; i++){
								layer = layers.getLayerById(this._layers[i]);
								if (layer) {
										layer.removeMeshInstances(this._meshInstances);
								}
						}
				}
				this._layers.length = 0;
				for(var i1 = 0; i1 < value.length; i1++){
						this._layers[i1] = value[i1];
				}
				if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;
				for(var i2 = 0; i2 < this._layers.length; i2++){
						layer = layers.getLayerById(this._layers[i2]);
						if (layer) {
								layer.addMeshInstances(this._meshInstances);
						}
				}
		}
		get layers() {
				return this._layers;
		}
		set batchGroupId(value) {
				if (this._batchGroupId !== value) {
						if (this.entity.enabled && this._batchGroupId >= 0) {
								var _this_system_app_batcher;
								(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
						}
						if (this.entity.enabled && value >= 0) {
								var _this_system_app_batcher1;
								(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.RENDER, value, this.entity);
						}
						if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
								this.addToLayers();
						}
						this._batchGroupId = value;
				}
		}
		get batchGroupId() {
				return this._batchGroupId;
		}
		set material(value) {
				if (this._material !== value) {
						this._material = value;
						if (this._meshInstances && this._type !== 'asset') {
								for(var i = 0; i < this._meshInstances.length; i++){
										this._meshInstances[i].material = value;
								}
						}
				}
		}
		get material() {
				return this._material;
		}
		set materialAssets(value) {
				if (value === void 0) value = [];
				if (this._materialReferences.length > value.length) {
						for(var i = value.length; i < this._materialReferences.length; i++){
								this._materialReferences[i].id = null;
						}
						this._materialReferences.length = value.length;
				}
				for(var i1 = 0; i1 < value.length; i1++){
						if (!this._materialReferences[i1]) {
								this._materialReferences.push(new AssetReference(i1, this, this.system.app.assets, {
										add: this._onMaterialAdded,
										load: this._onMaterialLoad,
										remove: this._onMaterialRemove,
										unload: this._onMaterialUnload
								}, this));
						}
						if (value[i1]) {
								var id = value[i1] instanceof Asset ? value[i1].id : value[i1];
								if (this._materialReferences[i1].id !== id) {
										this._materialReferences[i1].id = id;
								}
								if (this._materialReferences[i1].asset) {
										this._onMaterialAdded(i1, this, this._materialReferences[i1].asset);
								}
						} else {
								this._materialReferences[i1].id = null;
								if (this._meshInstances[i1]) {
										this._meshInstances[i1].material = this.system.defaultMaterial;
								}
						}
				}
		}
		get materialAssets() {
				return this._materialReferences.map((ref)=>{
						return ref.id;
				});
		}
		set asset(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._assetReference.id === id) return;
				if (this._assetReference.asset && this._assetReference.asset.resource) {
						this._onRenderAssetRemove();
				}
				this._assetReference.id = id;
				if (this._assetReference.asset) {
						this._onRenderAssetAdded();
				}
		}
		get asset() {
				return this._assetReference.id;
		}
		assignAsset(asset) {
				var id = asset instanceof Asset ? asset.id : asset;
				this._assetReference.id = id;
		}
		set rootBone(value) {
				if (this._rootBone !== value) {
						var isString = typeof value === 'string';
						if (this._rootBone && isString && this._rootBone.getGuid() === value) {
								return;
						}
						if (this._rootBone) {
								this._clearSkinInstances();
						}
						if (value instanceof GraphNode) {
								this._rootBone = value;
						} else if (isString) {
								this._rootBone = this.system.app.getEntityFromIndex(value) || null;
								if (!this._rootBone) ;
						} else {
								this._rootBone = null;
						}
						if (this._rootBone) {
								this._cloneSkinInstances();
						}
				}
		}
		get rootBone() {
				return this._rootBone;
		}
		destroyMeshInstances() {
				var meshInstances = this._meshInstances;
				if (meshInstances) {
						this.removeFromLayers();
						this._clearSkinInstances();
						for(var i = 0; i < meshInstances.length; i++){
								meshInstances[i].destroy();
						}
						this._meshInstances.length = 0;
				}
		}
		addToLayers() {
				var layers = this.system.app.scene.layers;
				for(var i = 0; i < this._layers.length; i++){
						var layer = layers.getLayerById(this._layers[i]);
						if (layer) {
								layer.addMeshInstances(this._meshInstances);
						}
				}
		}
		removeFromLayers() {
				if (this._meshInstances && this._meshInstances.length) {
						var layers = this.system.app.scene.layers;
						for(var i = 0; i < this._layers.length; i++){
								var layer = layers.getLayerById(this._layers[i]);
								if (layer) {
										layer.removeMeshInstances(this._meshInstances);
								}
						}
				}
		}
		onRemoveChild() {
				this.removeFromLayers();
		}
		onInsertChild() {
				if (this._meshInstances && this.enabled && this.entity.enabled) {
						this.addToLayers();
				}
		}
		onRemove() {
				this.destroyMeshInstances();
				this.asset = null;
				this.materialAsset = null;
				this._assetReference.id = null;
				for(var i = 0; i < this._materialReferences.length; i++){
						this._materialReferences[i].id = null;
				}
				this.entity.off('remove', this.onRemoveChild, this);
				this.entity.off('insert', this.onInsertChild, this);
		}
		onLayersChanged(oldComp, newComp) {
				this.addToLayers();
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.addMeshInstances(this._meshInstances);
		}
		onLayerRemoved(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.removeMeshInstances(this._meshInstances);
		}
		onEnable() {
				var app = this.system.app;
				var scene = app.scene;
				var layers = scene.layers;
				if (this._rootBone) {
						this._cloneSkinInstances();
				}
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				var isAsset = this._type === 'asset';
				if (this._meshInstances && this._meshInstances.length) {
						this.addToLayers();
				} else if (isAsset && this.asset) {
						this._onRenderAssetAdded();
				}
				for(var i = 0; i < this._materialReferences.length; i++){
						if (this._materialReferences[i].asset) {
								this.system.app.assets.load(this._materialReferences[i].asset);
						}
				}
				if (this._batchGroupId >= 0) {
						var _app_batcher;
						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
				}
		}
		onDisable() {
				var _this__evtLayersChanged;
				var app = this.system.app;
				var scene = app.scene;
				var layers = scene.layers;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (this._rootBone) {
						this._clearSkinInstances();
				}
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				if (this._batchGroupId >= 0) {
						var _app_batcher;
						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
				}
				this.removeFromLayers();
		}
		hide() {
				if (this._meshInstances) {
						for(var i = 0; i < this._meshInstances.length; i++){
								this._meshInstances[i].visible = false;
						}
				}
		}
		show() {
				if (this._meshInstances) {
						for(var i = 0; i < this._meshInstances.length; i++){
								this._meshInstances[i].visible = true;
						}
				}
		}
		_onRenderAssetAdded() {
				if (!this._assetReference.asset) return;
				if (this._assetReference.asset.resource) {
						this._onRenderAssetLoad();
				} else if (this.enabled && this.entity.enabled) {
						this.system.app.assets.load(this._assetReference.asset);
				}
		}
		_onRenderAssetLoad() {
				this.destroyMeshInstances();
				if (this._assetReference.asset) {
						var _this__evtSetMeshes;
						var render = this._assetReference.asset.resource;
						(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
						this._evtSetMeshes = render.on('set:meshes', this._onSetMeshes, this);
						if (render.meshes) {
								this._onSetMeshes(render.meshes);
						}
				}
		}
		_onSetMeshes(meshes) {
				this._cloneMeshes(meshes);
		}
		_clearSkinInstances() {
				for(var i = 0; i < this._meshInstances.length; i++){
						var meshInstance = this._meshInstances[i];
						SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
						meshInstance.skinInstance = null;
				}
		}
		_cloneSkinInstances() {
				if (this._meshInstances.length && this._rootBone instanceof GraphNode) {
						for(var i = 0; i < this._meshInstances.length; i++){
								var meshInstance = this._meshInstances[i];
								var mesh = meshInstance.mesh;
								if (mesh.skin && !meshInstance.skinInstance) {
										meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone, this.entity);
								}
						}
				}
		}
		_cloneMeshes(meshes) {
				if (meshes && meshes.length) {
						var meshInstances = [];
						for(var i = 0; i < meshes.length; i++){
								var mesh = meshes[i];
								var material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
								var meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
								meshInstances.push(meshInst);
								if (mesh.morph) {
										meshInst.morphInstance = new MorphInstance(mesh.morph);
								}
						}
						this.meshInstances = meshInstances;
						this._cloneSkinInstances();
				}
		}
		_onRenderAssetUnload() {
				if (this._type === 'asset') {
						this.destroyMeshInstances();
				}
		}
		_onRenderAssetRemove() {
				var _this__evtSetMeshes;
				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
				this._evtSetMeshes = null;
				this._onRenderAssetUnload();
		}
		_onMaterialAdded(index, component, asset) {
				if (asset.resource) {
						this._onMaterialLoad(index, component, asset);
				} else {
						if (this.enabled && this.entity.enabled) {
								this.system.app.assets.load(asset);
						}
				}
		}
		_updateMainMaterial(index, material) {
				if (index === 0) {
						this.material = material;
				}
		}
		_onMaterialLoad(index, component, asset) {
				if (this._meshInstances[index]) {
						this._meshInstances[index].material = asset.resource;
				}
				this._updateMainMaterial(index, asset.resource);
		}
		_onMaterialRemove(index, component, asset) {
				if (this._meshInstances[index]) {
						this._meshInstances[index].material = this.system.defaultMaterial;
				}
				this._updateMainMaterial(index, this.system.defaultMaterial);
		}
		_onMaterialUnload(index, component, asset) {
				if (this._meshInstances[index]) {
						this._meshInstances[index].material = this.system.defaultMaterial;
				}
				this._updateMainMaterial(index, this.system.defaultMaterial);
		}
		resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
				if (oldRender.rootBone) {
						this.rootBone = duplicatedIdsMap[oldRender.rootBone.getGuid()];
				}
		}
		constructor(system, entity){
				super(system, entity), this._type = 'asset', this._castShadows = true, this._receiveShadows = true, this._castShadowsLightmap = true, this._lightmapped = false, this._lightmapSizeMultiplier = 1, this.isStatic = false, this._batchGroupId = -1, this._layers = [
						LAYERID_WORLD
				], this._renderStyle = RENDERSTYLE_SOLID, this._meshInstances = [], this._customAabb = null, this._area = null, this._materialReferences = [], this._rootBone = null, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._evtSetMeshes = null;
				this._assetReference = new AssetReference('asset', this, system.app.assets, {
						add: this._onRenderAssetAdded,
						load: this._onRenderAssetLoad,
						remove: this._onRenderAssetRemove,
						unload: this._onRenderAssetUnload
				}, this);
				this._material = system.defaultMaterial;
				entity.on('remove', this.onRemoveChild, this);
				entity.on('removehierarchy', this.onRemoveChild, this);
				entity.on('insert', this.onInsertChild, this);
				entity.on('inserthierarchy', this.onInsertChild, this);
		}
}

class RenderComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$9 = [
		'enabled'
];
var _properties$1 = [
		'material',
		'meshInstances',
		'asset',
		'materialAssets',
		'castShadows',
		'receiveShadows',
		'castShadowsLightmap',
		'lightmapped',
		'lightmapSizeMultiplier',
		'renderStyle',
		'type',
		'layers',
		'isStatic',
		'batchGroupId',
		'rootBone'
];
class RenderComponentSystem extends ComponentSystem {
		initializeComponentData(component, _data, properties) {
				if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
						_data.batchGroupId = -1;
				}
				if (_data.layers && _data.layers.length) {
						_data.layers = _data.layers.slice(0);
				}
				for(var i = 0; i < _properties$1.length; i++){
						if (_data.hasOwnProperty(_properties$1[i])) {
								component[_properties$1[i]] = _data[_properties$1[i]];
						}
				}
				if (_data.aabbCenter && _data.aabbHalfExtents) {
						component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
				}
				super.initializeComponentData(component, _data, _schema$9);
		}
		cloneComponent(entity, clone) {
				var data = {};
				for(var i = 0; i < _properties$1.length; i++){
						data[_properties$1[i]] = entity.render[_properties$1[i]];
				}
				data.enabled = entity.render.enabled;
				delete data.meshInstances;
				var component = this.addComponent(clone, data);
				var srcMeshInstances = entity.render.meshInstances;
				var meshes = srcMeshInstances.map((mi)=>mi.mesh);
				component._onSetMeshes(meshes);
				for(var m = 0; m < srcMeshInstances.length; m++){
						component.meshInstances[m].material = srcMeshInstances[m].material;
				}
				if (entity.render.customAabb) {
						component.customAabb = entity.render.customAabb.clone();
				}
				return component;
		}
		onRemove(entity, component) {
				component.onRemove();
		}
		constructor(app){
				super(app);
				this.id = 'render';
				this.ComponentType = RenderComponent;
				this.DataType = RenderComponentData;
				this.schema = _schema$9;
				this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
				this.on('beforeremove', this.onRemove, this);
		}
}
Component._buildAccessors(RenderComponent.prototype, _schema$9);

class ObjectPool {
		_resize(size) {
				if (size > this._pool.length) {
						for(var i = this._pool.length; i < size; i++){
								this._pool[i] = new this._constructor();
						}
				}
		}
		allocate() {
				if (this._count >= this._pool.length) {
						this._resize(this._pool.length * 2);
				}
				return this._pool[this._count++];
		}
		freeAll() {
				this._count = 0;
		}
		constructor(constructorFunc, size){
				this._pool = [];
				this._count = 0;
				this._constructor = constructorFunc;
				this._resize(size);
		}
}

var _ammoTransform;
var _ammoVec1, _ammoVec2, _ammoQuat;
var _quat1 = new Quat();
var _quat2 = new Quat();
var _vec3 = new Vec3();
class RigidBodyComponent extends Component {
		static onLibraryLoaded() {
				if (typeof Ammo !== 'undefined') {
						_ammoTransform = new Ammo.btTransform();
						_ammoVec1 = new Ammo.btVector3();
						_ammoVec2 = new Ammo.btVector3();
						_ammoQuat = new Ammo.btQuaternion();
				}
		}
		static onAppDestroy() {
				Ammo.destroy(_ammoTransform);
				Ammo.destroy(_ammoVec1);
				Ammo.destroy(_ammoVec2);
				Ammo.destroy(_ammoQuat);
				_ammoTransform = null;
				_ammoVec1 = null;
				_ammoVec2 = null;
				_ammoQuat = null;
		}
		set angularDamping(damping) {
				if (this._angularDamping !== damping) {
						this._angularDamping = damping;
						if (this._body) {
								this._body.setDamping(this._linearDamping, damping);
						}
				}
		}
		get angularDamping() {
				return this._angularDamping;
		}
		set angularFactor(factor) {
				if (!this._angularFactor.equals(factor)) {
						this._angularFactor.copy(factor);
						if (this._body && this._type === BODYTYPE_DYNAMIC) {
								_ammoVec1.setValue(factor.x, factor.y, factor.z);
								this._body.setAngularFactor(_ammoVec1);
						}
				}
		}
		get angularFactor() {
				return this._angularFactor;
		}
		set angularVelocity(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
						this._body.activate();
						_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
						this._body.setAngularVelocity(_ammoVec1);
						this._angularVelocity.copy(velocity);
				}
		}
		get angularVelocity() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
						var velocity = this._body.getAngularVelocity();
						this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}
				return this._angularVelocity;
		}
		set body(body) {
				if (this._body !== body) {
						this._body = body;
						if (body && this._simulationEnabled) {
								body.activate();
						}
				}
		}
		get body() {
				return this._body;
		}
		set friction(friction) {
				if (this._friction !== friction) {
						this._friction = friction;
						if (this._body) {
								this._body.setFriction(friction);
						}
				}
		}
		get friction() {
				return this._friction;
		}
		set group(group) {
				if (this._group !== group) {
						this._group = group;
						if (this.enabled && this.entity.enabled) {
								this.disableSimulation();
								this.enableSimulation();
						}
				}
		}
		get group() {
				return this._group;
		}
		set linearDamping(damping) {
				if (this._linearDamping !== damping) {
						this._linearDamping = damping;
						if (this._body) {
								this._body.setDamping(damping, this._angularDamping);
						}
				}
		}
		get linearDamping() {
				return this._linearDamping;
		}
		set linearFactor(factor) {
				if (!this._linearFactor.equals(factor)) {
						this._linearFactor.copy(factor);
						if (this._body && this._type === BODYTYPE_DYNAMIC) {
								_ammoVec1.setValue(factor.x, factor.y, factor.z);
								this._body.setLinearFactor(_ammoVec1);
						}
				}
		}
		get linearFactor() {
				return this._linearFactor;
		}
		set linearVelocity(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
						this._body.activate();
						_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
						this._body.setLinearVelocity(_ammoVec1);
						this._linearVelocity.copy(velocity);
				}
		}
		get linearVelocity() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
						var velocity = this._body.getLinearVelocity();
						this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}
				return this._linearVelocity;
		}
		set mask(mask) {
				if (this._mask !== mask) {
						this._mask = mask;
						if (this.enabled && this.entity.enabled) {
								this.disableSimulation();
								this.enableSimulation();
						}
				}
		}
		get mask() {
				return this._mask;
		}
		set mass(mass) {
				if (this._mass !== mass) {
						this._mass = mass;
						if (this._body && this._type === BODYTYPE_DYNAMIC) {
								var enabled = this.enabled && this.entity.enabled;
								if (enabled) {
										this.disableSimulation();
								}
								this._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec1);
								this._body.setMassProps(mass, _ammoVec1);
								this._body.updateInertiaTensor();
								if (enabled) {
										this.enableSimulation();
								}
						}
				}
		}
		get mass() {
				return this._mass;
		}
		set restitution(restitution) {
				if (this._restitution !== restitution) {
						this._restitution = restitution;
						if (this._body) {
								this._body.setRestitution(restitution);
						}
				}
		}
		get restitution() {
				return this._restitution;
		}
		set rollingFriction(friction) {
				if (this._rollingFriction !== friction) {
						this._rollingFriction = friction;
						if (this._body) {
								this._body.setRollingFriction(friction);
						}
				}
		}
		get rollingFriction() {
				return this._rollingFriction;
		}
		set type(type) {
				if (this._type !== type) {
						this._type = type;
						this.disableSimulation();
						switch(type){
								case BODYTYPE_DYNAMIC:
										this._group = BODYGROUP_DYNAMIC;
										this._mask = BODYMASK_ALL;
										break;
								case BODYTYPE_KINEMATIC:
										this._group = BODYGROUP_KINEMATIC;
										this._mask = BODYMASK_ALL;
										break;
								case BODYTYPE_STATIC:
								default:
										this._group = BODYGROUP_STATIC;
										this._mask = BODYMASK_NOT_STATIC;
										break;
						}
						this.createBody();
				}
		}
		get type() {
				return this._type;
		}
		createBody() {
				var entity = this.entity;
				var shape;
				if (entity.collision) {
						shape = entity.collision.shape;
						if (entity.trigger) {
								entity.trigger.destroy();
								delete entity.trigger;
						}
				}
				if (shape) {
						if (this._body) {
								this.system.removeBody(this._body);
								this.system.destroyBody(this._body);
								this._body = null;
						}
						var mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;
						this._getEntityTransform(_ammoTransform);
						var body = this.system.createBody(mass, shape, _ammoTransform);
						body.setRestitution(this._restitution);
						body.setFriction(this._friction);
						body.setRollingFriction(this._rollingFriction);
						body.setDamping(this._linearDamping, this._angularDamping);
						if (this._type === BODYTYPE_DYNAMIC) {
								var linearFactor = this._linearFactor;
								_ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
								body.setLinearFactor(_ammoVec1);
								var angularFactor = this._angularFactor;
								_ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
								body.setAngularFactor(_ammoVec1);
						} else if (this._type === BODYTYPE_KINEMATIC) {
								body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
								body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
						}
						body.entity = entity;
						this.body = body;
						if (this.enabled && entity.enabled) {
								this.enableSimulation();
						}
				}
		}
		isActive() {
				return this._body ? this._body.isActive() : false;
		}
		activate() {
				if (this._body) {
						this._body.activate();
				}
		}
		enableSimulation() {
				var entity = this.entity;
				if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
						var body = this._body;
						if (body) {
								this.system.addBody(body, this._group, this._mask);
								switch(this._type){
										case BODYTYPE_DYNAMIC:
												this.system._dynamic.push(this);
												body.forceActivationState(BODYSTATE_ACTIVE_TAG);
												this.syncEntityToBody();
												break;
										case BODYTYPE_KINEMATIC:
												this.system._kinematic.push(this);
												body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
												break;
										case BODYTYPE_STATIC:
												body.forceActivationState(BODYSTATE_ACTIVE_TAG);
												this.syncEntityToBody();
												break;
								}
								if (entity.collision.type === 'compound') {
										this.system._compounds.push(entity.collision);
								}
								body.activate();
								this._simulationEnabled = true;
						}
				}
		}
		disableSimulation() {
				var body = this._body;
				if (body && this._simulationEnabled) {
						var system = this.system;
						var idx = system._compounds.indexOf(this.entity.collision);
						if (idx > -1) {
								system._compounds.splice(idx, 1);
						}
						idx = system._dynamic.indexOf(this);
						if (idx > -1) {
								system._dynamic.splice(idx, 1);
						}
						idx = system._kinematic.indexOf(this);
						if (idx > -1) {
								system._kinematic.splice(idx, 1);
						}
						system.removeBody(body);
						body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
						this._simulationEnabled = false;
				}
		}
		applyForce(x, y, z, px, py, pz) {
				var body = this._body;
				if (body) {
						body.activate();
						if (x instanceof Vec3) {
								_ammoVec1.setValue(x.x, x.y, x.z);
						} else {
								_ammoVec1.setValue(x, y, z);
						}
						if (y instanceof Vec3) {
								_ammoVec2.setValue(y.x, y.y, y.z);
						} else if (px !== undefined) {
								_ammoVec2.setValue(px, py, pz);
						} else {
								_ammoVec2.setValue(0, 0, 0);
						}
						body.applyForce(_ammoVec1, _ammoVec2);
				}
		}
		applyTorque(x, y, z) {
				var body = this._body;
				if (body) {
						body.activate();
						if (x instanceof Vec3) {
								_ammoVec1.setValue(x.x, x.y, x.z);
						} else {
								_ammoVec1.setValue(x, y, z);
						}
						body.applyTorque(_ammoVec1);
				}
		}
		applyImpulse(x, y, z, px, py, pz) {
				var body = this._body;
				if (body) {
						body.activate();
						if (x instanceof Vec3) {
								_ammoVec1.setValue(x.x, x.y, x.z);
						} else {
								_ammoVec1.setValue(x, y, z);
						}
						if (y instanceof Vec3) {
								_ammoVec2.setValue(y.x, y.y, y.z);
						} else if (px !== undefined) {
								_ammoVec2.setValue(px, py, pz);
						} else {
								_ammoVec2.setValue(0, 0, 0);
						}
						body.applyImpulse(_ammoVec1, _ammoVec2);
				}
		}
		applyTorqueImpulse(x, y, z) {
				var body = this._body;
				if (body) {
						body.activate();
						if (x instanceof Vec3) {
								_ammoVec1.setValue(x.x, x.y, x.z);
						} else {
								_ammoVec1.setValue(x, y, z);
						}
						body.applyTorqueImpulse(_ammoVec1);
				}
		}
		isStatic() {
				return this._type === BODYTYPE_STATIC;
		}
		isStaticOrKinematic() {
				return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
		}
		isKinematic() {
				return this._type === BODYTYPE_KINEMATIC;
		}
		_getEntityTransform(transform) {
				var entity = this.entity;
				var component = entity.collision;
				if (component) {
						var bodyPos = component.getShapePosition();
						var bodyRot = component.getShapeRotation();
						_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
						_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
				} else {
						var pos = entity.getPosition();
						var rot = entity.getRotation();
						_ammoVec1.setValue(pos.x, pos.y, pos.z);
						_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
				}
				transform.setOrigin(_ammoVec1);
				transform.setRotation(_ammoQuat);
		}
		syncEntityToBody() {
				var body = this._body;
				if (body) {
						this._getEntityTransform(_ammoTransform);
						body.setWorldTransform(_ammoTransform);
						if (this._type === BODYTYPE_KINEMATIC) {
								var motionState = body.getMotionState();
								if (motionState) {
										motionState.setWorldTransform(_ammoTransform);
								}
						}
						body.activate();
				}
		}
		_updateDynamic() {
				var body = this._body;
				if (body.isActive()) {
						var motionState = body.getMotionState();
						if (motionState) {
								var entity = this.entity;
								motionState.getWorldTransform(_ammoTransform);
								var p = _ammoTransform.getOrigin();
								var q = _ammoTransform.getRotation();
								var component = entity.collision;
								if (component && component._hasOffset) {
										var lo = component.data.linearOffset;
										var ao = component.data.angularOffset;
										var invertedAo = _quat2.copy(ao).invert();
										var entityRot = _quat1.set(q.x(), q.y(), q.z(), q.w()).mul(invertedAo);
										entityRot.transformVector(lo, _vec3);
										entity.setPosition(p.x() - _vec3.x, p.y() - _vec3.y, p.z() - _vec3.z);
										entity.setRotation(entityRot);
								} else {
										entity.setPosition(p.x(), p.y(), p.z());
										entity.setRotation(q.x(), q.y(), q.z(), q.w());
								}
						}
				}
		}
		_updateKinematic() {
				var motionState = this._body.getMotionState();
				if (motionState) {
						this._getEntityTransform(_ammoTransform);
						motionState.setWorldTransform(_ammoTransform);
				}
		}
		teleport(x, y, z, rx, ry, rz) {
				if (x instanceof Vec3) {
						this.entity.setPosition(x);
				} else {
						this.entity.setPosition(x, y, z);
				}
				if (y instanceof Quat) {
						this.entity.setRotation(y);
				} else if (y instanceof Vec3) {
						this.entity.setEulerAngles(y);
				} else if (rx !== undefined) {
						this.entity.setEulerAngles(rx, ry, rz);
				}
				this.syncEntityToBody();
		}
		onEnable() {
				if (!this._body) {
						this.createBody();
				}
				this.enableSimulation();
		}
		onDisable() {
				this.disableSimulation();
		}
		constructor(...args){
				super(...args), this._angularDamping = 0, this._angularFactor = new Vec3(1, 1, 1), this._angularVelocity = new Vec3(), this._body = null, this._friction = 0.5, this._group = BODYGROUP_STATIC, this._linearDamping = 0, this._linearFactor = new Vec3(1, 1, 1), this._linearVelocity = new Vec3(), this._mask = BODYMASK_NOT_STATIC, this._mass = 1, this._restitution = 0, this._rollingFriction = 0, this._simulationEnabled = false, this._type = BODYTYPE_STATIC;
		}
}
RigidBodyComponent.EVENT_CONTACT = 'contact';
RigidBodyComponent.EVENT_COLLISIONSTART = 'collisionstart';
RigidBodyComponent.EVENT_COLLISIONEND = 'collisionend';
RigidBodyComponent.EVENT_TRIGGERENTER = 'triggerenter';
RigidBodyComponent.EVENT_TRIGGERLEAVE = 'triggerleave';
RigidBodyComponent.order = -1;

class RigidBodyComponentData {
		constructor(){
				this.enabled = true;
		}
}

var ammoRayStart, ammoRayEnd;
class RaycastResult {
		constructor(entity, point, normal, hitFraction){
				this.entity = entity;
				this.point = point;
				this.normal = normal;
				this.hitFraction = hitFraction;
		}
}
class SingleContactResult {
		constructor(a, b, contactPoint){
				if (arguments.length !== 0) {
						this.a = a;
						this.b = b;
						this.impulse = contactPoint.impulse;
						this.localPointA = contactPoint.localPoint;
						this.localPointB = contactPoint.localPointOther;
						this.pointA = contactPoint.point;
						this.pointB = contactPoint.pointOther;
						this.normal = contactPoint.normal;
				} else {
						this.a = null;
						this.b = null;
						this.impulse = 0;
						this.localPointA = new Vec3();
						this.localPointB = new Vec3();
						this.pointA = new Vec3();
						this.pointB = new Vec3();
						this.normal = new Vec3();
				}
		}
}
class ContactPoint {
		constructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0){
				this.localPoint = localPoint;
				this.localPointOther = localPointOther;
				this.point = point;
				this.pointOther = pointOther;
				this.normal = normal;
				this.impulse = impulse;
		}
}
class ContactResult {
		constructor(other, contacts){
				this.other = other;
				this.contacts = contacts;
		}
}
var _schema$8 = [
		'enabled'
];
class RigidBodyComponentSystem extends ComponentSystem {
		onLibraryLoaded() {
				if (typeof Ammo !== 'undefined') {
						this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
						this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
						this.overlappingPairCache = new Ammo.btDbvtBroadphase();
						this.solver = new Ammo.btSequentialImpulseConstraintSolver();
						this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);
						if (this.dynamicsWorld.setInternalTickCallback) {
								var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
								this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
						}
						ammoRayStart = new Ammo.btVector3();
						ammoRayEnd = new Ammo.btVector3();
						RigidBodyComponent.onLibraryLoaded();
						this.contactPointPool = new ObjectPool(ContactPoint, 1);
						this.contactResultPool = new ObjectPool(ContactResult, 1);
						this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
						this.app.systems.on('update', this.onUpdate, this);
				} else {
						this.app.systems.off('update', this.onUpdate, this);
				}
		}
		initializeComponentData(component, data, properties) {
				var props = [
						'mass',
						'linearDamping',
						'angularDamping',
						'linearFactor',
						'angularFactor',
						'friction',
						'rollingFriction',
						'restitution',
						'type',
						'group',
						'mask'
				];
				for (var property of props){
						if (data.hasOwnProperty(property)) {
								var value = data[property];
								if (Array.isArray(value)) {
										component[property] = new Vec3(value[0], value[1], value[2]);
								} else {
										component[property] = value;
								}
						}
				}
				super.initializeComponentData(component, data, [
						'enabled'
				]);
		}
		cloneComponent(entity, clone) {
				var rigidbody = entity.rigidbody;
				var data = {
						enabled: rigidbody.enabled,
						mass: rigidbody.mass,
						linearDamping: rigidbody.linearDamping,
						angularDamping: rigidbody.angularDamping,
						linearFactor: [
								rigidbody.linearFactor.x,
								rigidbody.linearFactor.y,
								rigidbody.linearFactor.z
						],
						angularFactor: [
								rigidbody.angularFactor.x,
								rigidbody.angularFactor.y,
								rigidbody.angularFactor.z
						],
						friction: rigidbody.friction,
						rollingFriction: rigidbody.rollingFriction,
						restitution: rigidbody.restitution,
						type: rigidbody.type,
						group: rigidbody.group,
						mask: rigidbody.mask
				};
				return this.addComponent(clone, data);
		}
		onBeforeRemove(entity, component) {
				if (component.enabled) {
						component.enabled = false;
				}
				if (component.body) {
						this.destroyBody(component.body);
						component.body = null;
				}
		}
		addBody(body, group, mask) {
				if (group !== undefined && mask !== undefined) {
						this.dynamicsWorld.addRigidBody(body, group, mask);
				} else {
						this.dynamicsWorld.addRigidBody(body);
				}
		}
		removeBody(body) {
				this.dynamicsWorld.removeRigidBody(body);
		}
		createBody(mass, shape, transform) {
				var localInertia = new Ammo.btVector3(0, 0, 0);
				if (mass !== 0) {
						shape.calculateLocalInertia(mass, localInertia);
				}
				var motionState = new Ammo.btDefaultMotionState(transform);
				var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
				var body = new Ammo.btRigidBody(bodyInfo);
				Ammo.destroy(bodyInfo);
				Ammo.destroy(localInertia);
				return body;
		}
		destroyBody(body) {
				var motionState = body.getMotionState();
				if (motionState) {
						Ammo.destroy(motionState);
				}
				Ammo.destroy(body);
		}
		raycastFirst(start, end, options) {
				if (options === void 0) options = {};
				if (options.filterTags || options.filterCallback) {
						options.sort = true;
						return this.raycastAll(start, end, options)[0] || null;
				}
				var result = null;
				ammoRayStart.setValue(start.x, start.y, start.z);
				ammoRayEnd.setValue(end.x, end.y, end.z);
				var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
				if (typeof options.filterCollisionGroup === 'number') {
						rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
				}
				if (typeof options.filterCollisionMask === 'number') {
						rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
				}
				this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
				if (rayCallback.hasHit()) {
						var collisionObj = rayCallback.get_m_collisionObject();
						var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
						if (body) {
								var point = rayCallback.get_m_hitPointWorld();
								var normal = rayCallback.get_m_hitNormalWorld();
								result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), rayCallback.get_m_closestHitFraction());
						}
				}
				Ammo.destroy(rayCallback);
				return result;
		}
		raycastAll(start, end, options) {
				if (options === void 0) options = {};
				var results = [];
				ammoRayStart.setValue(start.x, start.y, start.z);
				ammoRayEnd.setValue(end.x, end.y, end.z);
				var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
				if (typeof options.filterCollisionGroup === 'number') {
						rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
				}
				if (typeof options.filterCollisionMask === 'number') {
						rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
				}
				this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
				if (rayCallback.hasHit()) {
						var collisionObjs = rayCallback.get_m_collisionObjects();
						var points = rayCallback.get_m_hitPointWorld();
						var normals = rayCallback.get_m_hitNormalWorld();
						var hitFractions = rayCallback.get_m_hitFractions();
						var numHits = collisionObjs.size();
						for(var i = 0; i < numHits; i++){
								var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
								if (body && body.entity) {
										if (options.filterTags && !body.entity.tags.has(...options.filterTags) || options.filterCallback && !options.filterCallback(body.entity)) {
												continue;
										}
										var point = points.at(i);
										var normal = normals.at(i);
										var result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), hitFractions.at(i));
										results.push(result);
								}
						}
						if (options.sort) {
								results.sort((a, b)=>a.hitFraction - b.hitFraction);
						}
				}
				Ammo.destroy(rayCallback);
				return results;
		}
		_storeCollision(entity, other) {
				var isNewCollision = false;
				var guid = entity.getGuid();
				this.collisions[guid] = this.collisions[guid] || {
						others: [],
						entity: entity
				};
				if (this.collisions[guid].others.indexOf(other) < 0) {
						this.collisions[guid].others.push(other);
						isNewCollision = true;
				}
				this.frameCollisions[guid] = this.frameCollisions[guid] || {
						others: [],
						entity: entity
				};
				this.frameCollisions[guid].others.push(other);
				return isNewCollision;
		}
		_createContactPointFromAmmo(contactPoint) {
				var localPointA = contactPoint.get_m_localPointA();
				var localPointB = contactPoint.get_m_localPointB();
				var positionWorldOnA = contactPoint.getPositionWorldOnA();
				var positionWorldOnB = contactPoint.getPositionWorldOnB();
				var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
				var contact = this.contactPointPool.allocate();
				contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
				contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
				contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
				contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
				contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
				contact.impulse = contactPoint.getAppliedImpulse();
				return contact;
		}
		_createReverseContactPointFromAmmo(contactPoint) {
				var localPointA = contactPoint.get_m_localPointA();
				var localPointB = contactPoint.get_m_localPointB();
				var positionWorldOnA = contactPoint.getPositionWorldOnA();
				var positionWorldOnB = contactPoint.getPositionWorldOnB();
				var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
				var contact = this.contactPointPool.allocate();
				contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
				contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
				contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
				contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
				contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
				contact.impulse = contactPoint.getAppliedImpulse();
				return contact;
		}
		_createSingleContactResult(a, b, contactPoint) {
				var result = this.singleContactResultPool.allocate();
				result.a = a;
				result.b = b;
				result.localPointA = contactPoint.localPoint;
				result.localPointB = contactPoint.localPointOther;
				result.pointA = contactPoint.point;
				result.pointB = contactPoint.pointOther;
				result.normal = contactPoint.normal;
				result.impulse = contactPoint.impulse;
				return result;
		}
		_createContactResult(other, contacts) {
				var result = this.contactResultPool.allocate();
				result.other = other;
				result.contacts = contacts;
				return result;
		}
		_cleanOldCollisions() {
				for(var guid in this.collisions){
						if (this.collisions.hasOwnProperty(guid)) {
								var frameCollision = this.frameCollisions[guid];
								var collision = this.collisions[guid];
								var entity = collision.entity;
								var entityCollision = entity.collision;
								var entityRigidbody = entity.rigidbody;
								var others = collision.others;
								var length = others.length;
								var i = length;
								while(i--){
										var other = others[i];
										if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
												others.splice(i, 1);
												if (entity.trigger) {
														if (entityCollision) {
																entityCollision.fire('triggerleave', other);
														}
														if (other.rigidbody) {
																other.rigidbody.fire('triggerleave', entity);
														}
												} else if (!other.trigger) {
														if (entityRigidbody) {
																entityRigidbody.fire('collisionend', other);
														}
														if (entityCollision) {
																entityCollision.fire('collisionend', other);
														}
												}
										}
								}
								if (others.length === 0) {
										delete this.collisions[guid];
								}
						}
				}
		}
		_hasContactEvent(entity) {
				var c = entity.collision;
				if (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {
						return true;
				}
				var r = entity.rigidbody;
				return r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));
		}
		_checkForCollisions(world, timeStep) {
				var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
				var dispatcher = dynamicsWorld.getDispatcher();
				var numManifolds = dispatcher.getNumManifolds();
				this.frameCollisions = {};
				for(var i = 0; i < numManifolds; i++){
						var manifold = dispatcher.getManifoldByIndexInternal(i);
						var body0 = manifold.getBody0();
						var body1 = manifold.getBody1();
						var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
						var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
						var e0 = wb0.entity;
						var e1 = wb1.entity;
						if (!e0 || !e1) {
								continue;
						}
						var flags0 = wb0.getCollisionFlags();
						var flags1 = wb1.getCollisionFlags();
						var numContacts = manifold.getNumContacts();
						var forwardContacts = [];
						var reverseContacts = [];
						var newCollision = void 0;
						if (numContacts > 0) {
								if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
										var e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));
										var e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));
										var e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));
										var e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));
										if (e0Events) {
												newCollision = this._storeCollision(e0, e1);
												if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
														e0.collision.fire('triggerenter', e1);
												}
										}
										if (e1Events) {
												newCollision = this._storeCollision(e1, e0);
												if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
														e1.collision.fire('triggerenter', e0);
												}
										}
										if (e0BodyEvents) {
												if (!newCollision) {
														newCollision = this._storeCollision(e1, e0);
												}
												if (newCollision) {
														e0.rigidbody.fire('triggerenter', e1);
												}
										}
										if (e1BodyEvents) {
												if (!newCollision) {
														newCollision = this._storeCollision(e0, e1);
												}
												if (newCollision) {
														e1.rigidbody.fire('triggerenter', e0);
												}
										}
								} else {
										var e0Events1 = this._hasContactEvent(e0);
										var e1Events1 = this._hasContactEvent(e1);
										var globalEvents = this.hasEvent('contact');
										if (globalEvents || e0Events1 || e1Events1) {
												for(var j = 0; j < numContacts; j++){
														var btContactPoint = manifold.getContactPoint(j);
														var contactPoint = this._createContactPointFromAmmo(btContactPoint);
														if (e0Events1 || e1Events1) {
																forwardContacts.push(contactPoint);
																var reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
																reverseContacts.push(reverseContactPoint);
														}
														if (globalEvents) {
																var result = this._createSingleContactResult(e0, e1, contactPoint);
																this.fire('contact', result);
														}
												}
												if (e0Events1) {
														var forwardResult = this._createContactResult(e1, forwardContacts);
														newCollision = this._storeCollision(e0, e1);
														if (e0.collision) {
																e0.collision.fire('contact', forwardResult);
																if (newCollision) {
																		e0.collision.fire('collisionstart', forwardResult);
																}
														}
														if (e0.rigidbody) {
																e0.rigidbody.fire('contact', forwardResult);
																if (newCollision) {
																		e0.rigidbody.fire('collisionstart', forwardResult);
																}
														}
												}
												if (e1Events1) {
														var reverseResult = this._createContactResult(e0, reverseContacts);
														newCollision = this._storeCollision(e1, e0);
														if (e1.collision) {
																e1.collision.fire('contact', reverseResult);
																if (newCollision) {
																		e1.collision.fire('collisionstart', reverseResult);
																}
														}
														if (e1.rigidbody) {
																e1.rigidbody.fire('contact', reverseResult);
																if (newCollision) {
																		e1.rigidbody.fire('collisionstart', reverseResult);
																}
														}
												}
										}
								}
						}
				}
				this._cleanOldCollisions();
				this.contactPointPool.freeAll();
				this.contactResultPool.freeAll();
				this.singleContactResultPool.freeAll();
		}
		onUpdate(dt) {
				var i, len;
				this._gravityFloat32[0] = this.gravity.x;
				this._gravityFloat32[1] = this.gravity.y;
				this._gravityFloat32[2] = this.gravity.z;
				var gravity = this.dynamicsWorld.getGravity();
				if (gravity.x() !== this._gravityFloat32[0] || gravity.y() !== this._gravityFloat32[1] || gravity.z() !== this._gravityFloat32[2]) {
						gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
						this.dynamicsWorld.setGravity(gravity);
				}
				var triggers = this._triggers;
				for(i = 0, len = triggers.length; i < len; i++){
						triggers[i].updateTransform();
				}
				var compounds = this._compounds;
				for(i = 0, len = compounds.length; i < len; i++){
						compounds[i]._updateCompound();
				}
				var kinematic = this._kinematic;
				for(i = 0, len = kinematic.length; i < len; i++){
						kinematic[i]._updateKinematic();
				}
				this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
				var dynamic = this._dynamic;
				for(i = 0, len = dynamic.length; i < len; i++){
						dynamic[i]._updateDynamic();
				}
				if (!this.dynamicsWorld.setInternalTickCallback) {
						this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
				}
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
				if (typeof Ammo !== 'undefined') {
						Ammo.destroy(this.dynamicsWorld);
						Ammo.destroy(this.solver);
						Ammo.destroy(this.overlappingPairCache);
						Ammo.destroy(this.dispatcher);
						Ammo.destroy(this.collisionConfiguration);
						Ammo.destroy(ammoRayStart);
						Ammo.destroy(ammoRayEnd);
						this.dynamicsWorld = null;
						this.solver = null;
						this.overlappingPairCache = null;
						this.dispatcher = null;
						this.collisionConfiguration = null;
						ammoRayStart = null;
						ammoRayEnd = null;
						RigidBodyComponent.onAppDestroy();
				}
		}
		constructor(app){
				super(app), this.maxSubSteps = 10, this.fixedTimeStep = 1 / 60, this.gravity = new Vec3(0, -9.81, 0), this._gravityFloat32 = new Float32Array(3), this._dynamic = [], this._kinematic = [], this._triggers = [], this._compounds = [];
				this.id = 'rigidbody';
				this._stats = app.stats.frame;
				this.ComponentType = RigidBodyComponent;
				this.DataType = RigidBodyComponentData;
				this.contactPointPool = null;
				this.contactResultPool = null;
				this.singleContactResultPool = null;
				this.schema = _schema$8;
				this.collisions = {};
				this.frameCollisions = {};
				this.on('beforeremove', this.onBeforeRemove, this);
		}
}
RigidBodyComponentSystem.EVENT_CONTACT = 'contact';
Component._buildAccessors(RigidBodyComponent.prototype, _schema$8);

var SCALEMODE_NONE = 'none';
var SCALEMODE_BLEND = 'blend';

var _transform = new Mat4();
class ScreenComponent extends Component {
		syncDrawOrder() {
				this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
		}
		_recurseDrawOrderSync(e, i) {
				if (!(e instanceof Entity)) {
						return i;
				}
				if (e.element) {
						var prevDrawOrder = e.element.drawOrder;
						e.element.drawOrder = i++;
						if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
								var _this_system_app_batcher;
								(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.markGroupDirty(e.element._batchGroupId);
						}
				}
				if (e.particlesystem) {
						e.particlesystem.drawOrder = i++;
				}
				var children = e.children;
				for(var j = 0; j < children.length; j++){
						i = this._recurseDrawOrderSync(children[j], i);
				}
				return i;
		}
		_processDrawOrderSync() {
				var i = 1;
				this._recurseDrawOrderSync(this.entity, i);
				this.fire('syncdraworder');
		}
		_calcProjectionMatrix() {
				var w = this._resolution.x / this.scale;
				var h = this._resolution.y / this.scale;
				var left = 0;
				var right = w;
				var bottom = -h;
				var top = 0;
				var near = 1;
				var far = -1;
				this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
				if (!this._screenSpace) {
						_transform.setScale(0.5 * w, 0.5 * h, 1);
						this._screenMatrix.mul2(_transform, this._screenMatrix);
				}
		}
		_updateScale() {
				this.scale = this._calcScale(this._resolution, this.referenceResolution);
		}
		_calcScale(resolution, referenceResolution) {
				var lx = Math.log2((resolution.x || 1) / referenceResolution.x);
				var ly = Math.log2((resolution.y || 1) / referenceResolution.y);
				return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
		}
		_onResize(width, height) {
				if (this._screenSpace) {
						this._resolution.set(width, height);
						this.resolution = this._resolution;
				}
		}
		_bindElement(element) {
				this._elements.add(element);
		}
		_unbindElement(element) {
				this._elements.delete(element);
		}
		onRemove() {
				this.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);
				this.fire('remove');
				this._elements.forEach((element)=>element._onScreenRemove());
				this._elements.clear();
				this.off();
		}
		set resolution(value) {
				if (!this._screenSpace) {
						this._resolution.set(value.x, value.y);
				} else {
						this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) {
						this.entity._dirtifyLocal();
				}
				this.fire('set:resolution', this._resolution);
				this._elements.forEach((element)=>element._onScreenResize(this._resolution));
		}
		get resolution() {
				return this._resolution;
		}
		set referenceResolution(value) {
				this._referenceResolution.set(value.x, value.y);
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) {
						this.entity._dirtifyLocal();
				}
				this.fire('set:referenceresolution', this._resolution);
				this._elements.forEach((element)=>element._onScreenResize(this._resolution));
		}
		get referenceResolution() {
				if (this._scaleMode === SCALEMODE_NONE) {
						return this._resolution;
				}
				return this._referenceResolution;
		}
		set screenSpace(value) {
				this._screenSpace = value;
				if (this._screenSpace) {
						this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}
				this.resolution = this._resolution;
				if (!this.entity._dirtyLocal) {
						this.entity._dirtifyLocal();
				}
				this.fire('set:screenspace', this._screenSpace);
				this._elements.forEach((element)=>element._onScreenSpaceChange());
		}
		get screenSpace() {
				return this._screenSpace;
		}
		set scaleMode(value) {
				if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
						value = SCALEMODE_NONE;
				}
				if (!this._screenSpace && value !== SCALEMODE_NONE) {
						value = SCALEMODE_NONE;
				}
				this._scaleMode = value;
				this.resolution = this._resolution;
				this.fire('set:scalemode', this._scaleMode);
		}
		get scaleMode() {
				return this._scaleMode;
		}
		set scaleBlend(value) {
				this._scaleBlend = value;
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) {
						this.entity._dirtifyLocal();
				}
				this.fire('set:scaleblend', this._scaleBlend);
				this._elements.forEach((element)=>element._onScreenResize(this._resolution));
		}
		get scaleBlend() {
				return this._scaleBlend;
		}
		set priority(value) {
				if (value > 0xFF) {
						value = 0xFF;
				}
				if (this._priority === value) {
						return;
				}
				this._priority = value;
				this.syncDrawOrder();
		}
		get priority() {
				return this._priority;
		}
		constructor(system, entity){
				super(system, entity);
				this._resolution = new Vec2(640, 320);
				this._referenceResolution = new Vec2(640, 320);
				this._scaleMode = SCALEMODE_NONE;
				this.scale = 1;
				this._scaleBlend = 0.5;
				this._priority = 0;
				this._screenSpace = false;
				this.cull = this._screenSpace;
				this._screenMatrix = new Mat4();
				this._elements = new Set();
				system.app.graphicsDevice.on('resizecanvas', this._onResize, this);
		}
}

class ScreenComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$7 = [
		'enabled'
];
class ScreenComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				if (data.priority !== undefined) component.priority = data.priority;
				if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
				component.cull = component.screenSpace;
				if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
				if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;
				if (data.resolution !== undefined) {
						if (data.resolution instanceof Vec2) {
								component._resolution.copy(data.resolution);
						} else {
								component._resolution.set(data.resolution[0], data.resolution[1]);
						}
						component.resolution = component._resolution;
				}
				if (data.referenceResolution !== undefined) {
						if (data.referenceResolution instanceof Vec2) {
								component._referenceResolution.copy(data.referenceResolution);
						} else {
								component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
						}
						component.referenceResolution = component._referenceResolution;
				}
				component.syncDrawOrder();
				super.initializeComponentData(component, data, _schema$7);
		}
		destroy() {
				super.destroy();
				this.app.graphicsDevice.off('resizecanvas', this._onResize, this);
				this.app.systems.off('update', this._onUpdate, this);
		}
		_onUpdate(dt) {
				var components = this.store;
				for(var id in components){
						if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
				}
		}
		_onResize(width, height) {
				this.windowResolution.x = width;
				this.windowResolution.y = height;
		}
		cloneComponent(entity, clone) {
				var screen = entity.screen;
				return this.addComponent(clone, {
						enabled: screen.enabled,
						screenSpace: screen.screenSpace,
						scaleMode: screen.scaleMode,
						resolution: screen.resolution.clone(),
						referenceResolution: screen.referenceResolution.clone()
				});
		}
		onRemoveComponent(entity, component) {
				component.onRemove();
		}
		processDrawOrderSyncQueue() {
				var list = this._drawOrderSyncQueue.list();
				for(var i = 0; i < list.length; i++){
						var item = list[i];
						item.callback.call(item.scope);
				}
				this._drawOrderSyncQueue.clear();
		}
		queueDrawOrderSync(id, fn, scope) {
				if (!this._drawOrderSyncQueue.list().length) {
						this.app.once('prerender', this.processDrawOrderSyncQueue, this);
				}
				if (!this._drawOrderSyncQueue.has(id)) {
						this._drawOrderSyncQueue.push(id, {
								callback: fn,
								scope: scope
						});
				}
		}
		constructor(app){
				super(app);
				this.id = 'screen';
				this.ComponentType = ScreenComponent;
				this.DataType = ScreenComponentData;
				this.schema = _schema$7;
				this.windowResolution = new Vec2();
				this._drawOrderSyncQueue = new IndexedList();
				this.app.graphicsDevice.on('resizecanvas', this._onResize, this);
				this.app.systems.on('update', this._onUpdate, this);
				this.on('beforeremove', this.onRemoveComponent, this);
		}
}
Component._buildAccessors(ScreenComponent.prototype, _schema$7);

var _inputScreenPosition = new Vec2();
var _inputWorldPosition = new Vec3();
var _ray = new Ray();
var _plane = new Plane();
var _normal = new Vec3();
var _point = new Vec3();
var _entityRotation = new Quat();
var OPPOSITE_AXIS = {
		x: 'y',
		y: 'x'
};
class ElementDragHelper extends EventHandler {
		_toggleLifecycleListeners(onOrOff) {
				this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);
				this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
				this._element[onOrOff]('selectstart', this._onMouseDownOrTouchStart, this);
		}
		_toggleDragListeners(onOrOff) {
				var isOn = onOrOff === 'on';
				if (this._hasDragListeners && isOn) {
						return;
				}
				if (this._app.mouse) {
						this._element[onOrOff]('mousemove', this._onMove, this);
						this._element[onOrOff]('mouseup', this._onMouseUpOrTouchEnd, this);
				}
				if (platform.touch) {
						this._element[onOrOff]('touchmove', this._onMove, this);
						this._element[onOrOff]('touchend', this._onMouseUpOrTouchEnd, this);
						this._element[onOrOff]('touchcancel', this._onMouseUpOrTouchEnd, this);
				}
				this._element[onOrOff]('selectmove', this._onMove, this);
				this._element[onOrOff]('selectend', this._onMouseUpOrTouchEnd, this);
				this._hasDragListeners = isOn;
		}
		_onMouseDownOrTouchStart(event) {
				if (this._element && !this._isDragging && this.enabled) {
						this._dragCamera = event.camera;
						this._calculateDragScale();
						var currentMousePosition = this._screenToLocal(event);
						if (currentMousePosition) {
								this._toggleDragListeners('on');
								this._isDragging = true;
								this._dragStartMousePosition.copy(currentMousePosition);
								this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
								this.fire('drag:start');
						}
				}
		}
		_onMouseUpOrTouchEnd() {
				if (this._isDragging) {
						this._isDragging = false;
						this._toggleDragListeners('off');
						this.fire('drag:end');
				}
		}
		_screenToLocal(event) {
				if (event.inputSource) {
						_ray.set(event.inputSource.getOrigin(), event.inputSource.getDirection());
				} else {
						this._determineInputPosition(event);
						this._chooseRayOriginAndDirection();
				}
				_normal.copy(this._element.entity.forward).mulScalar(-1);
				_plane.setFromPointNormal(this._element.entity.getPosition(), _normal);
				if (_plane.intersectsRay(_ray, _point)) {
						_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point, _point);
						_point.mul(this._dragScale);
						return _point;
				}
				return null;
		}
		_determineInputPosition(event) {
				var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;
				if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
						_inputScreenPosition.x = event.x * devicePixelRatio;
						_inputScreenPosition.y = event.y * devicePixelRatio;
				} else if (event.changedTouches) {
						_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
						_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
				} else {
						console.warn('Could not determine position from input event');
				}
		}
		_chooseRayOriginAndDirection() {
				if (this._element.screen && this._element.screen.screen.screenSpace) {
						_ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
						_ray.direction.copy(Vec3.FORWARD);
				} else {
						_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
						_ray.origin.copy(this._dragCamera.entity.getPosition());
						_ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();
				}
		}
		_calculateDragScale() {
				var current = this._element.entity.parent;
				var screen = this._element.screen && this._element.screen.screen;
				var isWithin2DScreen = screen && screen.screenSpace;
				var screenScale = isWithin2DScreen ? screen.scale : 1;
				var dragScale = this._dragScale;
				dragScale.set(screenScale, screenScale, screenScale);
				while(current){
						dragScale.mul(current.getLocalScale());
						current = current.parent;
						if (isWithin2DScreen && current.screen) {
								break;
						}
				}
				dragScale.x = 1 / dragScale.x;
				dragScale.y = 1 / dragScale.y;
				dragScale.z = 0;
		}
		_onMove(event) {
				var { _element: element, _deltaMousePosition: deltaMousePosition, _deltaHandlePosition: deltaHandlePosition, _axis: axis } = this;
				if (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {
						var currentMousePosition = this._screenToLocal(event);
						if (currentMousePosition) {
								deltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);
								deltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);
								if (axis) {
										var currentPosition = element.entity.getLocalPosition();
										var constrainedAxis = OPPOSITE_AXIS[axis];
										deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
								}
								element.entity.setLocalPosition(deltaHandlePosition);
								this.fire('drag:move', deltaHandlePosition);
						}
				}
		}
		destroy() {
				this._toggleLifecycleListeners('off');
				this._toggleDragListeners('off');
		}
		set enabled(value) {
				this._enabled = value;
		}
		get enabled() {
				return this._enabled;
		}
		get isDragging() {
				return this._isDragging;
		}
		constructor(element, axis){
				super();
				if (!element || !(element instanceof ElementComponent)) {
						throw new Error('Element was null or not an ElementComponent');
				}
				if (axis && axis !== 'x' && axis !== 'y') {
						throw new Error("Unrecognized axis: " + axis);
				}
				this._element = element;
				this._app = element.system.app;
				this._axis = axis || null;
				this._enabled = true;
				this._dragScale = new Vec3();
				this._dragStartMousePosition = new Vec3();
				this._dragStartHandlePosition = new Vec3();
				this._deltaMousePosition = new Vec3();
				this._deltaHandlePosition = new Vec3();
				this._isDragging = false;
				this._toggleLifecycleListeners('on');
		}
}
ElementDragHelper.EVENT_DRAGSTART = 'drag:start';
ElementDragHelper.EVENT_DRAGEND = 'drag:end';
ElementDragHelper.EVENT_DRAGMOVE = 'drag:move';

var SCROLL_MODE_CLAMP = 0;
var SCROLL_MODE_BOUNCE = 1;
var SCROLL_MODE_INFINITE = 2;
var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

var _tempScrollValue = new Vec2();
class ScrollViewComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {
				this._setValue('enabled', arg);
		}
		get enabled() {
				return this.data.enabled;
		}
		set horizontal(arg) {
				this._setValue('horizontal', arg);
		}
		get horizontal() {
				return this.data.horizontal;
		}
		set vertical(arg) {
				this._setValue('vertical', arg);
		}
		get vertical() {
				return this.data.vertical;
		}
		set scrollMode(arg) {
				this._setValue('scrollMode', arg);
		}
		get scrollMode() {
				return this.data.scrollMode;
		}
		set bounceAmount(arg) {
				this._setValue('bounceAmount', arg);
		}
		get bounceAmount() {
				return this.data.bounceAmount;
		}
		set friction(arg) {
				this._setValue('friction', arg);
		}
		get friction() {
				return this.data.friction;
		}
		set dragThreshold(arg) {
				this._setValue('dragThreshold', arg);
		}
		get dragThreshold() {
				return this.data.dragThreshold;
		}
		set useMouseWheel(arg) {
				this._setValue('useMouseWheel', arg);
		}
		get useMouseWheel() {
				return this.data.useMouseWheel;
		}
		set mouseWheelSensitivity(arg) {
				this._setValue('mouseWheelSensitivity', arg);
		}
		get mouseWheelSensitivity() {
				return this.data.mouseWheelSensitivity;
		}
		set horizontalScrollbarVisibility(arg) {
				this._setValue('horizontalScrollbarVisibility', arg);
		}
		get horizontalScrollbarVisibility() {
				return this.data.horizontalScrollbarVisibility;
		}
		set verticalScrollbarVisibility(arg) {
				this._setValue('verticalScrollbarVisibility', arg);
		}
		get verticalScrollbarVisibility() {
				return this.data.verticalScrollbarVisibility;
		}
		set viewportEntity(arg) {
				if (this._viewportEntity === arg) {
						return;
				}
				var isString = typeof arg === 'string';
				if (this._viewportEntity && isString && this._viewportEntity.getGuid() === arg) {
						return;
				}
				if (this._viewportEntity) {
						this._viewportEntityUnsubscribe();
				}
				if (arg instanceof GraphNode) {
						this._viewportEntity = arg;
				} else if (isString) {
						this._viewportEntity = this.system.app.getEntityFromIndex(arg) || null;
				} else {
						this._viewportEntity = null;
				}
				if (this._viewportEntity) {
						this._viewportEntitySubscribe();
				}
				if (this._viewportEntity) {
						this.data.viewportEntity = this._viewportEntity.getGuid();
				} else if (isString && arg) {
						this.data.viewportEntity = arg;
				}
		}
		get viewportEntity() {
				return this._viewportEntity;
		}
		set contentEntity(arg) {
				if (this._contentEntity === arg) {
						return;
				}
				var isString = typeof arg === 'string';
				if (this._contentEntity && isString && this._contentEntity.getGuid() === arg) {
						return;
				}
				if (this._contentEntity) {
						this._contentEntityUnsubscribe();
				}
				if (arg instanceof GraphNode) {
						this._contentEntity = arg;
				} else if (isString) {
						this._contentEntity = this.system.app.getEntityFromIndex(arg) || null;
				} else {
						this._contentEntity = null;
				}
				if (this._contentEntity) {
						this._contentEntitySubscribe();
				}
				if (this._contentEntity) {
						this.data.contentEntity = this._contentEntity.getGuid();
				} else if (isString && arg) {
						this.data.contentEntity = arg;
				}
		}
		get contentEntity() {
				return this._contentEntity;
		}
		set horizontalScrollbarEntity(arg) {
				if (this._horizontalScrollbarEntity === arg) {
						return;
				}
				var isString = typeof arg === 'string';
				if (this._horizontalScrollbarEntity && isString && this._horizontalScrollbarEntity.getGuid() === arg) {
						return;
				}
				if (this._horizontalScrollbarEntity) {
						this._horizontalScrollbarEntityUnsubscribe();
				}
				if (arg instanceof GraphNode) {
						this._horizontalScrollbarEntity = arg;
				} else if (isString) {
						this._horizontalScrollbarEntity = this.system.app.getEntityFromIndex(arg) || null;
				} else {
						this._horizontalScrollbarEntity = null;
				}
				this._scrollbarEntities[ORIENTATION_HORIZONTAL] = this._horizontalScrollbarEntity;
				if (this._horizontalScrollbarEntity) {
						this._horizontalScrollbarEntitySubscribe();
				}
				if (this._horizontalScrollbarEntity) {
						this.data.horizontalScrollbarEntity = this._horizontalScrollbarEntity.getGuid();
				} else if (isString && arg) {
						this.data.horizontalScrollbarEntity = arg;
				}
		}
		get horizontalScrollbarEntity() {
				return this._horizontalScrollbarEntity;
		}
		set verticalScrollbarEntity(arg) {
				if (this._verticalScrollbarEntity === arg) {
						return;
				}
				var isString = typeof arg === 'string';
				if (this._verticalScrollbarEntity && isString && this._verticalScrollbarEntity.getGuid() === arg) {
						return;
				}
				if (this._verticalScrollbarEntity) {
						this._verticalScrollbarEntityUnsubscribe();
				}
				if (arg instanceof GraphNode) {
						this._verticalScrollbarEntity = arg;
				} else if (isString) {
						this._verticalScrollbarEntity = this.system.app.getEntityFromIndex(arg) || null;
				} else {
						this._verticalScrollbarEntity = null;
				}
				this._scrollbarEntities[ORIENTATION_VERTICAL] = this._verticalScrollbarEntity;
				if (this._verticalScrollbarEntity) {
						this._verticalScrollbarEntitySubscribe();
				}
				if (this._verticalScrollbarEntity) {
						this.data.verticalScrollbarEntity = this._verticalScrollbarEntity.getGuid();
				} else if (isString && arg) {
						this.data.verticalScrollbarEntity = arg;
				}
		}
		get verticalScrollbarEntity() {
				return this._verticalScrollbarEntity;
		}
		set scroll(value) {
				this._onSetScroll(value.x, value.y);
		}
		get scroll() {
				return this._scroll;
		}
		_setValue(name, value) {
				var data = this.data;
				var oldValue = data[name];
				data[name] = value;
				this.fire('set', name, oldValue, value);
		}
		_toggleLifecycleListeners(onOrOff) {
				this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
				this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
				this.entity[onOrOff]('element:add', this._onElementComponentAdd, this);
		}
		_toggleElementListeners(onOrOff) {
				if (this.entity.element) {
						if (onOrOff === 'on' && this._hasElementListeners) {
								return;
						}
						this.entity.element[onOrOff]('resize', this._syncAll, this);
						this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
						this._hasElementListeners = onOrOff === 'on';
				}
		}
		_onElementComponentAdd(entity) {
				this._evtElementRemove = this.entity.element.once('beforeremove', this._onElementComponentRemove, this);
				this._toggleElementListeners('on');
		}
		_onElementComponentRemove(entity) {
				var _this__evtElementRemove;
				(_this__evtElementRemove = this._evtElementRemove) == null ? void 0 : _this__evtElementRemove.off();
				this._evtElementRemove = null;
				this._toggleElementListeners('off');
		}
		_viewportEntitySubscribe() {
				this._evtViewportEntityElementAdd = this._viewportEntity.on('element:add', this._onViewportElementGain, this);
				if (this._viewportEntity.element) {
						this._onViewportElementGain();
				}
		}
		_viewportEntityUnsubscribe() {
				var _this__evtViewportEntityElementAdd, _this__viewportEntity;
				(_this__evtViewportEntityElementAdd = this._evtViewportEntityElementAdd) == null ? void 0 : _this__evtViewportEntityElementAdd.off();
				this._evtViewportEntityElementAdd = null;
				if ((_this__viewportEntity = this._viewportEntity) == null ? void 0 : _this__viewportEntity.element) {
						this._onViewportElementLose();
				}
		}
		_viewportEntityElementSubscribe() {
				var element = this._viewportEntity.element;
				this._evtViewportElementRemove = element.once('beforeremove', this._onViewportElementLose, this);
				this._evtViewportResize = element.on('resize', this._syncAll, this);
		}
		_viewportEntityElementUnsubscribe() {
				var _this__evtViewportElementRemove, _this__evtViewportResize;
				(_this__evtViewportElementRemove = this._evtViewportElementRemove) == null ? void 0 : _this__evtViewportElementRemove.off();
				this._evtViewportElementRemove = null;
				(_this__evtViewportResize = this._evtViewportResize) == null ? void 0 : _this__evtViewportResize.off();
				this._evtViewportResize = null;
		}
		_onViewportElementGain() {
				this._viewportEntityElementSubscribe();
				this._syncAll();
		}
		_onViewportElementLose() {
				this._viewportEntityElementUnsubscribe();
		}
		_contentEntitySubscribe() {
				this._evtContentEntityElementAdd = this._contentEntity.on('element:add', this._onContentElementGain, this);
				if (this._contentEntity.element) {
						this._onContentElementGain();
				}
		}
		_contentEntityUnsubscribe() {
				var _this__evtContentEntityElementAdd, _this__contentEntity;
				(_this__evtContentEntityElementAdd = this._evtContentEntityElementAdd) == null ? void 0 : _this__evtContentEntityElementAdd.off();
				this._evtContentEntityElementAdd = null;
				if ((_this__contentEntity = this._contentEntity) == null ? void 0 : _this__contentEntity.element) {
						this._onContentElementLose();
				}
		}
		_contentEntityElementSubscribe() {
				var element = this._contentEntity.element;
				this._evtContentElementRemove = element.once('beforeremove', this._onContentElementLose, this);
				this._evtContentResize = element.on('resize', this._syncAll, this);
		}
		_contentEntityElementUnsubscribe() {
				var _this__evtContentElementRemove, _this__evtContentResize;
				(_this__evtContentElementRemove = this._evtContentElementRemove) == null ? void 0 : _this__evtContentElementRemove.off();
				this._evtContentElementRemove = null;
				(_this__evtContentResize = this._evtContentResize) == null ? void 0 : _this__evtContentResize.off();
				this._evtContentResize = null;
		}
		_onContentElementGain() {
				this._contentEntityElementSubscribe();
				this._destroyDragHelper();
				this._contentDragHelper = new ElementDragHelper(this._contentEntity.element);
				this._contentDragHelper.on('drag:start', this._onContentDragStart, this);
				this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);
				this._contentDragHelper.on('drag:move', this._onContentDragMove, this);
				this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
				this._prevContentSizes[ORIENTATION_VERTICAL] = null;
				this._syncAll();
		}
		_onContentElementLose() {
				this._contentEntityElementUnsubscribe();
				this._destroyDragHelper();
		}
		_onContentDragStart() {
				if (this._contentEntity && this.enabled && this.entity.enabled) {
						this._dragStartPosition.copy(this._contentEntity.getLocalPosition());
				}
		}
		_onContentDragEnd() {
				this._prevContentDragPosition = null;
				this._enableContentInput();
		}
		_onContentDragMove(position) {
				if (this._contentEntity && this.enabled && this.entity.enabled) {
						this._wasDragged = true;
						this._setScrollFromContentPosition(position);
						this._setVelocityFromContentPositionDelta(position);
						if (!this._disabledContentInput) {
								var dx = position.x - this._dragStartPosition.x;
								var dy = position.y - this._dragStartPosition.y;
								if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
										this._disableContentInput();
								}
						}
				}
		}
		_horizontalScrollbarEntitySubscribe() {
				this._evtHorizontalScrollbarAdd = this._horizontalScrollbarEntity.on('scrollbar:add', this._onHorizontalScrollbarGain, this);
				if (this._horizontalScrollbarEntity.scrollbar) {
						this._onHorizontalScrollbarGain();
				}
		}
		_verticalScrollbarEntitySubscribe() {
				this._evtVerticalScrollbarAdd = this._verticalScrollbarEntity.on('scrollbar:add', this._onVerticalScrollbarGain, this);
				if (this._verticalScrollbarEntity.scrollbar) {
						this._onVerticalScrollbarGain();
				}
		}
		_horizontalScrollbarEntityUnsubscribe() {
				var _this__evtHorizontalScrollbarAdd;
				(_this__evtHorizontalScrollbarAdd = this._evtHorizontalScrollbarAdd) == null ? void 0 : _this__evtHorizontalScrollbarAdd.off();
				this._evtHorizontalScrollbarAdd = null;
				if (this._horizontalScrollbarEntity.scrollbar) {
						this._onHorizontalScrollbarLose();
				}
		}
		_verticalScrollbarEntityUnsubscribe() {
				var _this__evtVerticalScrollbarAdd;
				(_this__evtVerticalScrollbarAdd = this._evtVerticalScrollbarAdd) == null ? void 0 : _this__evtVerticalScrollbarAdd.off();
				this._evtVerticalScrollbarAdd = null;
				if (this._verticalScrollbarEntity.scrollbar) {
						this._onVerticalScrollbarLose();
				}
		}
		_onSetHorizontalScrollbarValue(scrollValueX) {
				if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
						this._onSetScroll(scrollValueX, null);
				}
		}
		_onSetVerticalScrollbarValue(scrollValueY) {
				if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
						this._onSetScroll(null, scrollValueY);
				}
		}
		_onHorizontalScrollbarGain() {
				var _this__horizontalScrollbarEntity;
				var scrollbar = (_this__horizontalScrollbarEntity = this._horizontalScrollbarEntity) == null ? void 0 : _this__horizontalScrollbarEntity.scrollbar;
				this._evtHorizontalScrollbarRemove = scrollbar.on('beforeremove', this._onHorizontalScrollbarLose, this);
				this._evtHorizontalScrollbarValue = scrollbar.on('set:value', this._onSetHorizontalScrollbarValue, this);
				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
				this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
		}
		_onVerticalScrollbarGain() {
				var _this__verticalScrollbarEntity;
				var scrollbar = (_this__verticalScrollbarEntity = this._verticalScrollbarEntity) == null ? void 0 : _this__verticalScrollbarEntity.scrollbar;
				this._evtVerticalScrollbarRemove = scrollbar.on('beforeremove', this._onVerticalScrollbarLose, this);
				this._evtVerticalScrollbarValue = scrollbar.on('set:value', this._onSetVerticalScrollbarValue, this);
				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
				this._syncScrollbarPosition(ORIENTATION_VERTICAL);
		}
		_onHorizontalScrollbarLose() {
				var _this__evtHorizontalScrollbarRemove, _this__evtHorizontalScrollbarValue;
				(_this__evtHorizontalScrollbarRemove = this._evtHorizontalScrollbarRemove) == null ? void 0 : _this__evtHorizontalScrollbarRemove.off();
				this._evtHorizontalScrollbarRemove = null;
				(_this__evtHorizontalScrollbarValue = this._evtHorizontalScrollbarValue) == null ? void 0 : _this__evtHorizontalScrollbarValue.off();
				this._evtHorizontalScrollbarValue = null;
		}
		_onVerticalScrollbarLose() {
				var _this__evtVerticalScrollbarRemove, _this__evtVerticalScrollbarValue;
				(_this__evtVerticalScrollbarRemove = this._evtVerticalScrollbarRemove) == null ? void 0 : _this__evtVerticalScrollbarRemove.off();
				this._evtVerticalScrollbarRemove = null;
				(_this__evtVerticalScrollbarValue = this._evtVerticalScrollbarValue) == null ? void 0 : _this__evtVerticalScrollbarValue.off();
				this._evtVerticalScrollbarValue = null;
		}
		_onSetHorizontalScrollingEnabled() {
				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
		}
		_onSetVerticalScrollingEnabled() {
				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		}
		_onSetScroll(x, y, resetVelocity) {
				if (resetVelocity !== false) {
						this._velocity.set(0, 0, 0);
				}
				var xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
				var yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);
				if (xChanged || yChanged) {
						this.fire('set:scroll', this._scroll);
				}
		}
		_updateAxis(scrollValue, axis, orientation) {
				var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;
				if (hasChanged || this._isDragging() || scrollValue === 0) {
						this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
						this._syncContentPosition(orientation);
						this._syncScrollbarPosition(orientation);
				}
				return hasChanged;
		}
		_determineNewScrollValue(scrollValue, axis, orientation) {
				if (!this._getScrollingEnabled(orientation)) {
						return this._scroll[axis];
				}
				switch(this.scrollMode){
						case SCROLL_MODE_CLAMP:
								return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
						case SCROLL_MODE_BOUNCE:
								this._setVelocityFromOvershoot(scrollValue, axis, orientation);
								return scrollValue;
						case SCROLL_MODE_INFINITE:
								return scrollValue;
						default:
								console.warn("Unhandled scroll mode:" + this.scrollMode);
								return scrollValue;
				}
		}
		_syncAll() {
				this._syncContentPosition(ORIENTATION_HORIZONTAL);
				this._syncContentPosition(ORIENTATION_VERTICAL);
				this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
				this._syncScrollbarPosition(ORIENTATION_VERTICAL);
				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		}
		_syncContentPosition(orientation) {
				if (!this._contentEntity) {
						return;
				}
				var axis = this._getAxis(orientation);
				var sign = this._getSign(orientation);
				var prevContentSize = this._prevContentSizes[orientation];
				var currContentSize = this._getContentSize(orientation);
				if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
						var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
						var currMaxOffset = this._getMaxOffset(orientation, currContentSize);
						if (currMaxOffset === 0) {
								this._scroll[axis] = 1;
						} else {
								this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
						}
				}
				var offset = this._scroll[axis] * this._getMaxOffset(orientation);
				var contentPosition = this._contentEntity.getLocalPosition();
				contentPosition[axis] = offset * sign;
				this._contentEntity.setLocalPosition(contentPosition);
				this._prevContentSizes[orientation] = currContentSize;
		}
		_syncScrollbarPosition(orientation) {
				var scrollbarEntity = this._scrollbarEntities[orientation];
				if (!(scrollbarEntity == null ? void 0 : scrollbarEntity.scrollbar)) {
						return;
				}
				var axis = this._getAxis(orientation);
				this._scrollbarUpdateFlags[orientation] = true;
				scrollbarEntity.scrollbar.value = this._scroll[axis];
				scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
				this._scrollbarUpdateFlags[orientation] = false;
		}
		_syncScrollbarEnabledState(orientation) {
				var entity = this._scrollbarEntities[orientation];
				if (!entity) {
						return;
				}
				var isScrollingEnabled = this._getScrollingEnabled(orientation);
				var requestedVisibility = this._getScrollbarVisibility(orientation);
				switch(requestedVisibility){
						case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
								entity.enabled = isScrollingEnabled;
								return;
						case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
								entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
								return;
						default:
								console.warn("Unhandled scrollbar visibility:" + requestedVisibility);
								entity.enabled = isScrollingEnabled;
				}
		}
		_contentIsLargerThanViewport(orientation) {
				return this._getContentSize(orientation) > this._getViewportSize(orientation);
		}
		_contentPositionToScrollValue(contentPosition) {
				var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
				var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);
				if (maxOffsetH === 0) {
						_tempScrollValue.x = 0;
				} else {
						_tempScrollValue.x = contentPosition.x / maxOffsetH;
				}
				if (maxOffsetV === 0) {
						_tempScrollValue.y = 0;
				} else {
						_tempScrollValue.y = contentPosition.y / -maxOffsetV;
				}
				return _tempScrollValue;
		}
		_getMaxOffset(orientation, contentSize) {
				contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;
				var viewportSize = this._getViewportSize(orientation);
				if (contentSize < viewportSize) {
						return -this._getViewportSize(orientation);
				}
				return viewportSize - contentSize;
		}
		_getMaxScrollValue(orientation) {
				return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
		}
		_getScrollbarHandleSize(axis, orientation) {
				var viewportSize = this._getViewportSize(orientation);
				var contentSize = this._getContentSize(orientation);
				if (Math.abs(contentSize) < 0.001) {
						return 1;
				}
				var handleSize = Math.min(viewportSize / contentSize, 1);
				var overshoot = this._toOvershoot(this._scroll[axis], orientation);
				if (overshoot === 0) {
						return handleSize;
				}
				return handleSize / (1 + Math.abs(overshoot));
		}
		_getViewportSize(orientation) {
				return this._getSize(orientation, this._viewportEntity);
		}
		_getContentSize(orientation) {
				return this._getSize(orientation, this._contentEntity);
		}
		_getSize(orientation, entity) {
				if (entity == null ? void 0 : entity.element) {
						return entity.element[this._getCalculatedDimension(orientation)];
				}
				return 0;
		}
		_getScrollingEnabled(orientation) {
				if (orientation === ORIENTATION_HORIZONTAL) {
						return this.horizontal;
				} else if (orientation === ORIENTATION_VERTICAL) {
						return this.vertical;
				}
				return undefined;
		}
		_getScrollbarVisibility(orientation) {
				if (orientation === ORIENTATION_HORIZONTAL) {
						return this.horizontalScrollbarVisibility;
				} else if (orientation === ORIENTATION_VERTICAL) {
						return this.verticalScrollbarVisibility;
				}
				return undefined;
		}
		_getSign(orientation) {
				return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		}
		_getAxis(orientation) {
				return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		}
		_getCalculatedDimension(orientation) {
				return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
		}
		_destroyDragHelper() {
				if (this._contentDragHelper) {
						this._contentDragHelper.destroy();
				}
		}
		onUpdate() {
				if (this._contentEntity) {
						this._updateVelocity();
						this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
						this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
				}
		}
		_updateVelocity() {
				if (!this._isDragging()) {
						if (this.scrollMode === SCROLL_MODE_BOUNCE) {
								if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
										this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
								}
								if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
										this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
								}
						}
						if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
								var position = this._contentEntity.getLocalPosition();
								position.x += this._velocity.x;
								position.y += this._velocity.y;
								this._contentEntity.setLocalPosition(position);
								this._setScrollFromContentPosition(position);
						}
						this._velocity.x *= 1 - this.friction;
						this._velocity.y *= 1 - this.friction;
				}
		}
		_hasOvershoot(axis, orientation) {
				return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
		}
		_toOvershoot(scrollValue, orientation) {
				var maxScrollValue = this._getMaxScrollValue(orientation);
				if (scrollValue < 0) {
						return scrollValue;
				} else if (scrollValue > maxScrollValue) {
						return scrollValue - maxScrollValue;
				}
				return 0;
		}
		_setVelocityFromOvershoot(scrollValue, axis, orientation) {
				var overshootValue = this._toOvershoot(scrollValue, orientation);
				var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
				if (Math.abs(overshootPixels) > 0) {
						this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
				}
		}
		_setVelocityFromContentPositionDelta(position) {
				if (this._prevContentDragPosition) {
						this._velocity.sub2(position, this._prevContentDragPosition);
						this._prevContentDragPosition.copy(position);
				} else {
						this._velocity.set(0, 0, 0);
						this._prevContentDragPosition = position.clone();
				}
		}
		_setScrollFromContentPosition(position) {
				var scrollValue = this._contentPositionToScrollValue(position);
				if (this._isDragging()) {
						scrollValue = this._applyScrollValueTension(scrollValue);
				}
				this._onSetScroll(scrollValue.x, scrollValue.y, false);
		}
		_applyScrollValueTension(scrollValue) {
				var factor = 1;
				var max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
				var overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
				if (overshoot > 0) {
						scrollValue.x = max + factor * Math.log10(1 + overshoot);
				} else if (overshoot < 0) {
						scrollValue.x = -1 * Math.log10(1 - overshoot);
				}
				max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
				overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);
				if (overshoot > 0) {
						scrollValue.y = max + factor * Math.log10(1 + overshoot);
				} else if (overshoot < 0) {
						scrollValue.y = -1 * Math.log10(1 - overshoot);
				}
				return scrollValue;
		}
		_isDragging() {
				return this._contentDragHelper && this._contentDragHelper.isDragging;
		}
		_setScrollbarComponentsEnabled(enabled) {
				var _this__horizontalScrollbarEntity, _this__verticalScrollbarEntity;
				if ((_this__horizontalScrollbarEntity = this._horizontalScrollbarEntity) == null ? void 0 : _this__horizontalScrollbarEntity.scrollbar) {
						this._horizontalScrollbarEntity.scrollbar.enabled = enabled;
				}
				if ((_this__verticalScrollbarEntity = this._verticalScrollbarEntity) == null ? void 0 : _this__verticalScrollbarEntity.scrollbar) {
						this._verticalScrollbarEntity.scrollbar.enabled = enabled;
				}
		}
		_setContentDraggingEnabled(enabled) {
				if (this._contentDragHelper) {
						this._contentDragHelper.enabled = enabled;
				}
		}
		_onMouseWheel(event) {
				var _this__contentEntity;
				if (!this.useMouseWheel || !((_this__contentEntity = this._contentEntity) == null ? void 0 : _this__contentEntity.element)) {
						return;
				}
				var wheelEvent = event.event;
				var normalizedDeltaX = wheelEvent.deltaX / this._contentEntity.element.calculatedWidth * this.mouseWheelSensitivity.x;
				var normalizedDeltaY = wheelEvent.deltaY / this._contentEntity.element.calculatedHeight * this.mouseWheelSensitivity.y;
				var scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
				var scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
				this.scroll = new Vec2(scrollX, scrollY);
		}
		_enableContentInput() {
				while(this._disabledContentInputEntities.length){
						var e = this._disabledContentInputEntities.pop();
						if (e.element) {
								e.element.useInput = true;
						}
				}
				this._disabledContentInput = false;
		}
		_disableContentInput() {
				var _disableInput = (e)=>{
						if (e.element && e.element.useInput) {
								this._disabledContentInputEntities.push(e);
								e.element.useInput = false;
						}
						var children = e.children;
						for(var i = 0, l = children.length; i < l; i++){
								_disableInput(children[i]);
						}
				};
				if (this._contentEntity) {
						var children = this._contentEntity.children;
						for(var i = 0, l = children.length; i < l; i++){
								_disableInput(children[i]);
						}
				}
				this._disabledContentInput = true;
		}
		onEnable() {
				this._setScrollbarComponentsEnabled(true);
				this._setContentDraggingEnabled(true);
				this._syncAll();
		}
		onDisable() {
				this._setScrollbarComponentsEnabled(false);
				this._setContentDraggingEnabled(false);
		}
		onRemove() {
				this._toggleLifecycleListeners('off');
				this._toggleElementListeners('off');
				this._destroyDragHelper();
		}
		resolveDuplicatedEntityReferenceProperties(oldScrollView, duplicatedIdsMap) {
				if (oldScrollView.viewportEntity) {
						this.viewportEntity = duplicatedIdsMap[oldScrollView.viewportEntity.getGuid()];
				}
				if (oldScrollView.contentEntity) {
						this.contentEntity = duplicatedIdsMap[oldScrollView.contentEntity.getGuid()];
				}
				if (oldScrollView.horizontalScrollbarEntity) {
						this.horizontalScrollbarEntity = duplicatedIdsMap[oldScrollView.horizontalScrollbarEntity.getGuid()];
				}
				if (oldScrollView.verticalScrollbarEntity) {
						this.verticalScrollbarEntity = duplicatedIdsMap[oldScrollView.verticalScrollbarEntity.getGuid()];
				}
		}
		constructor(system, entity){
				super(system, entity), this._viewportEntity = null, this._contentEntity = null, this._horizontalScrollbarEntity = null, this._verticalScrollbarEntity = null, this._evtElementRemove = null, this._evtViewportElementRemove = null, this._evtViewportResize = null, this._evtContentEntityElementAdd = null, this._evtContentElementRemove = null, this._evtContentResize = null, this._evtHorizontalScrollbarAdd = null, this._evtHorizontalScrollbarRemove = null, this._evtHorizontalScrollbarValue = null, this._evtVerticalScrollbarAdd = null, this._evtVerticalScrollbarRemove = null, this._evtVerticalScrollbarValue = null;
				this._scrollbarUpdateFlags = {};
				this._scrollbarEntities = {};
				this._prevContentSizes = {};
				this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
				this._prevContentSizes[ORIENTATION_VERTICAL] = null;
				this._scroll = new Vec2();
				this._velocity = new Vec3();
				this._dragStartPosition = new Vec3();
				this._disabledContentInput = false;
				this._disabledContentInputEntities = [];
				this._toggleLifecycleListeners('on');
				this._toggleElementListeners('on');
		}
}
ScrollViewComponent.EVENT_SETSCROLL = 'set:scroll';

var DEFAULT_DRAG_THRESHOLD$1 = 10;
class ScrollViewComponentData {
		constructor(){
				this.enabled = true;
				this.dragThreshold = DEFAULT_DRAG_THRESHOLD$1;
				this.useMouseWheel = true;
				this.mouseWheelSensitivity = new Vec2(1, 1);
				this.horizontalScrollbarVisibility = 0;
				this.verticalScrollbarVisibility = 0;
				this.viewportEntity = null;
				this.contentEntity = null;
				this.horizontalScrollbarEntity = null;
				this.verticalScrollbarEntity = null;
		}
}

var _schema$6 = [
		{
				name: 'enabled',
				type: 'boolean'
		},
		{
				name: 'horizontal',
				type: 'boolean'
		},
		{
				name: 'vertical',
				type: 'boolean'
		},
		{
				name: 'scrollMode',
				type: 'number'
		},
		{
				name: 'bounceAmount',
				type: 'number'
		},
		{
				name: 'friction',
				type: 'number'
		},
		{
				name: 'dragThreshold',
				type: 'number'
		},
		{
				name: 'useMouseWheel',
				type: 'boolean'
		},
		{
				name: 'mouseWheelSensitivity',
				type: 'vec2'
		},
		{
				name: 'horizontalScrollbarVisibility',
				type: 'number'
		},
		{
				name: 'verticalScrollbarVisibility',
				type: 'number'
		}
];
var DEFAULT_DRAG_THRESHOLD = 10;
class ScrollViewComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				if (data.dragThreshold === undefined) {
						data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
				}
				if (data.useMouseWheel === undefined) {
						data.useMouseWheel = true;
				}
				if (data.mouseWheelSensitivity === undefined) {
						data.mouseWheelSensitivity = new Vec2(1, 1);
				}
				super.initializeComponentData(component, data, _schema$6);
				component.viewportEntity = data.viewportEntity;
				component.contentEntity = data.contentEntity;
				component.horizontalScrollbarEntity = data.horizontalScrollbarEntity;
				component.verticalScrollbarEntity = data.verticalScrollbarEntity;
		}
		onUpdate(dt) {
				var components = this.store;
				for(var id in components){
						var entity = components[id].entity;
						var component = entity.scrollview;
						if (component.enabled && entity.enabled) {
								component.onUpdate();
						}
				}
		}
		_onRemoveComponent(entity, component) {
				component.onRemove();
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'scrollview';
				this.ComponentType = ScrollViewComponent;
				this.DataType = ScrollViewComponentData;
				this.schema = _schema$6;
				this.on('beforeremove', this._onRemoveComponent, this);
				this.app.systems.on('update', this.onUpdate, this);
		}
}

class ScrollbarComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {
				this._setValue('enabled', arg);
		}
		get enabled() {
				return this.data.enabled;
		}
		set orientation(arg) {
				this._setValue('orientation', arg);
		}
		get orientation() {
				return this.data.orientation;
		}
		set value(arg) {
				this._setValue('value', arg);
		}
		get value() {
				return this.data.value;
		}
		set handleSize(arg) {
				this._setValue('handleSize', arg);
		}
		get handleSize() {
				return this.data.handleSize;
		}
		set handleEntity(arg) {
				if (this._handleEntity === arg) {
						return;
				}
				var isString = typeof arg === 'string';
				if (this._handleEntity && isString && this._handleEntity.getGuid() === arg) {
						return;
				}
				if (this._handleEntity) {
						this._handleEntityUnsubscribe();
				}
				if (arg instanceof GraphNode) {
						this._handleEntity = arg;
				} else if (isString) {
						this._handleEntity = this.system.app.getEntityFromIndex(arg) || null;
				} else {
						this._handleEntity = null;
				}
				if (this._handleEntity) {
						this._handleEntitySubscribe();
				}
				if (this._handleEntity) {
						this.data.handleEntity = this._handleEntity.getGuid();
				} else if (isString && arg) {
						this.data.handleEntity = arg;
				}
		}
		get handleEntity() {
				return this._handleEntity;
		}
		_setValue(name, value) {
				var data = this.data;
				var oldValue = data[name];
				data[name] = value;
				this.fire('set', name, oldValue, value);
		}
		_toggleLifecycleListeners(onOrOff) {
				this[onOrOff]('set_value', this._onSetValue, this);
				this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
				this[onOrOff]('set_orientation', this._onSetOrientation, this);
		}
		_handleEntitySubscribe() {
				this._evtHandleEntityElementAdd = this._handleEntity.on('element:add', this._onHandleElementGain, this);
				if (this._handleEntity.element) {
						this._onHandleElementGain();
				}
		}
		_handleEntityUnsubscribe() {
				var _this__evtHandleEntityElementAdd, _this__handleEntity;
				(_this__evtHandleEntityElementAdd = this._evtHandleEntityElementAdd) == null ? void 0 : _this__evtHandleEntityElementAdd.off();
				this._evtHandleEntityElementAdd = null;
				if ((_this__handleEntity = this._handleEntity) == null ? void 0 : _this__handleEntity.element) {
						this._onHandleElementLose();
				}
		}
		_handleEntityElementSubscribe() {
				var element = this._handleEntity.element;
				var handles = this._evtHandleEntityChanges;
				handles.push(element.once('beforeremove', this._onHandleElementLose, this));
				handles.push(element.on('set:anchor', this._onSetHandleAlignment, this));
				handles.push(element.on('set:margin', this._onSetHandleAlignment, this));
				handles.push(element.on('set:pivot', this._onSetHandleAlignment, this));
		}
		_handleEntityElementUnsubscribe() {
				for(var i = 0; i < this._evtHandleEntityChanges.length; i++){
						this._evtHandleEntityChanges[i].off();
				}
				this._evtHandleEntityChanges.length = 0;
		}
		_onHandleElementGain() {
				this._handleEntityElementSubscribe();
				this._destroyDragHelper();
				this._handleDragHelper = new ElementDragHelper(this._handleEntity.element, this._getAxis());
				this._handleDragHelper.on('drag:move', this._onHandleDrag, this);
				this._updateHandlePositionAndSize();
		}
		_onHandleElementLose() {
				this._handleEntityElementUnsubscribe();
				this._destroyDragHelper();
		}
		_onHandleDrag(position) {
				if (this._handleEntity && this.enabled && this.entity.enabled) {
						this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
				}
		}
		_onSetValue(name, oldValue, newValue) {
				if (Math.abs(newValue - oldValue) > 1e-5) {
						this.data.value = math.clamp(newValue, 0, 1);
						this._updateHandlePositionAndSize();
						this.fire('set:value', this.data.value);
				}
		}
		_onSetHandleSize(name, oldValue, newValue) {
				if (Math.abs(newValue - oldValue) > 1e-5) {
						this.data.handleSize = math.clamp(newValue, 0, 1);
						this._updateHandlePositionAndSize();
				}
		}
		_onSetHandleAlignment() {
				this._updateHandlePositionAndSize();
		}
		_onSetOrientation(name, oldValue, newValue) {
				var _this__handleEntity;
				if (newValue !== oldValue && ((_this__handleEntity = this._handleEntity) == null ? void 0 : _this__handleEntity.element)) {
						this._handleEntity.element[this._getOppositeDimension()] = 0;
				}
		}
		_updateHandlePositionAndSize() {
				var handleEntity = this._handleEntity;
				var handleElement = handleEntity == null ? void 0 : handleEntity.element;
				if (handleEntity) {
						var position = handleEntity.getLocalPosition();
						position[this._getAxis()] = this._getHandlePosition();
						handleEntity.setLocalPosition(position);
				}
				if (handleElement) {
						handleElement[this._getDimension()] = this._getHandleLength();
				}
		}
		_handlePositionToScrollValue(handlePosition) {
				return handlePosition * this._getSign() / this._getUsableTrackLength();
		}
		_scrollValueToHandlePosition(value) {
				return value * this._getSign() * this._getUsableTrackLength();
		}
		_getUsableTrackLength() {
				return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
		}
		_getTrackLength() {
				if (this.entity.element) {
						return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
				}
				return 0;
		}
		_getHandleLength() {
				return this._getTrackLength() * this.handleSize;
		}
		_getHandlePosition() {
				return this._scrollValueToHandlePosition(this.value);
		}
		_getSign() {
				return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		}
		_getAxis() {
				return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		}
		_getDimension() {
				return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
		}
		_getOppositeDimension() {
				return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
		}
		_destroyDragHelper() {
				if (this._handleDragHelper) {
						this._handleDragHelper.destroy();
				}
		}
		_setHandleDraggingEnabled(enabled) {
				if (this._handleDragHelper) {
						this._handleDragHelper.enabled = enabled;
				}
		}
		onEnable() {
				this._setHandleDraggingEnabled(true);
		}
		onDisable() {
				this._setHandleDraggingEnabled(false);
		}
		onRemove() {
				this._destroyDragHelper();
				this._toggleLifecycleListeners('off');
		}
		resolveDuplicatedEntityReferenceProperties(oldScrollbar, duplicatedIdsMap) {
				if (oldScrollbar.handleEntity) {
						this.handleEntity = duplicatedIdsMap[oldScrollbar.handleEntity.getGuid()];
				}
		}
		constructor(system, entity){
				super(system, entity), this._handleEntity = null, this._evtHandleEntityElementAdd = null, this._evtHandleEntityChanges = [];
				this._toggleLifecycleListeners('on');
		}
}
ScrollbarComponent.EVENT_SETVALUE = 'set:value';

class ScrollbarComponentData {
		constructor(){
				this.enabled = true;
				this.orientation = ORIENTATION_HORIZONTAL;
				this.value = 0;
				this.handleSize = 0;
				this.handleEntity = null;
		}
}

var _schema$5 = [
		{
				name: 'enabled',
				type: 'boolean'
		},
		{
				name: 'orientation',
				type: 'number'
		},
		{
				name: 'value',
				type: 'number'
		},
		{
				name: 'handleSize',
				type: 'number'
		}
];
class ScrollbarComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				super.initializeComponentData(component, data, _schema$5);
				component.handleEntity = data.handleEntity;
		}
		_onAddComponent(entity) {
				entity.fire('scrollbar:add');
		}
		_onRemoveComponent(entity, component) {
				component.onRemove();
		}
		constructor(app){
				super(app);
				this.id = 'scrollbar';
				this.ComponentType = ScrollbarComponent;
				this.DataType = ScrollbarComponentData;
				this.schema = _schema$5;
				this.on('add', this._onAddComponent, this);
				this.on('beforeremove', this._onRemoveComponent, this);
		}
}

var instanceOptions = {
		volume: 0,
		pitch: 0,
		loop: false,
		startTime: 0,
		duration: 0,
		position: new Vec3(),
		maxDistance: 0,
		refDistance: 0,
		rollOffFactor: 0,
		distanceModel: 0,
		onPlay: null,
		onPause: null,
		onResume: null,
		onStop: null,
		onEnd: null
};
class SoundSlot extends EventHandler {
		play() {
				if (!this.overlap) {
						this.stop();
				}
				if (!this.isLoaded && !this._hasAsset()) {
						return undefined;
				}
				var instance = this._createInstance();
				this.instances.push(instance);
				if (!this.isLoaded) {
						var onLoad = function onLoad(sound) {
								var playWhenLoaded = instance._playWhenLoaded;
								instance.sound = sound;
								if (playWhenLoaded) {
										instance.play();
								}
						};
						this.off('load', onLoad);
						this.once('load', onLoad);
						this.load();
				} else {
						instance.play();
				}
				return instance;
		}
		pause() {
				var paused = false;
				var instances = this.instances;
				for(var i = 0, len = instances.length; i < len; i++){
						if (instances[i].pause()) {
								paused = true;
						}
				}
				return paused;
		}
		resume() {
				var resumed = false;
				var instances = this.instances;
				for(var i = 0, len = instances.length; i < len; i++){
						if (instances[i].resume()) {
								resumed = true;
						}
				}
				return resumed;
		}
		stop() {
				var stopped = false;
				var instances = this.instances;
				var i = instances.length;
				while(i--){
						instances[i].stop();
						stopped = true;
				}
				instances.length = 0;
				return stopped;
		}
		load() {
				if (!this._hasAsset()) {
						return;
				}
				var asset = this._assets.get(this._asset);
				if (!asset) {
						this._assets.off("add:" + this._asset, this._onAssetAdd, this);
						this._assets.once("add:" + this._asset, this._onAssetAdd, this);
						return;
				}
				asset.off('remove', this._onAssetRemoved, this);
				asset.on('remove', this._onAssetRemoved, this);
				if (!asset.resource) {
						asset.off('load', this._onAssetLoad, this);
						asset.once('load', this._onAssetLoad, this);
						this._assets.load(asset);
						return;
				}
				this.fire('load', asset.resource);
		}
		setExternalNodes(firstNode, lastNode) {
				if (!firstNode) {
						console.error('The firstNode must have a valid AudioNode');
						return;
				}
				if (!lastNode) {
						lastNode = firstNode;
				}
				this._firstNode = firstNode;
				this._lastNode = lastNode;
				if (!this._overlap) {
						var instances = this.instances;
						for(var i = 0, len = instances.length; i < len; i++){
								instances[i].setExternalNodes(firstNode, lastNode);
						}
				}
		}
		clearExternalNodes() {
				this._firstNode = null;
				this._lastNode = null;
				if (!this._overlap) {
						var instances = this.instances;
						for(var i = 0, len = instances.length; i < len; i++){
								instances[i].clearExternalNodes();
						}
				}
		}
		getExternalNodes() {
				return [
						this._firstNode,
						this._lastNode
				];
		}
		_hasAsset() {
				return this._asset != null;
		}
		_createInstance() {
				var instance = null;
				var component = this._component;
				var sound = null;
				if (this._hasAsset()) {
						var asset = this._assets.get(this._asset);
						if (asset) {
								sound = asset.resource;
						}
				}
				var data = instanceOptions;
				data.volume = this._volume * component.volume;
				data.pitch = this._pitch * component.pitch;
				data.loop = this._loop;
				data.startTime = this._startTime;
				data.duration = this._duration;
				data.onPlay = this._onInstancePlayHandler;
				data.onPause = this._onInstancePauseHandler;
				data.onResume = this._onInstanceResumeHandler;
				data.onStop = this._onInstanceStopHandler;
				data.onEnd = this._onInstanceEndHandler;
				if (component.positional) {
						data.position.copy(component.entity.getPosition());
						data.maxDistance = component.maxDistance;
						data.refDistance = component.refDistance;
						data.rollOffFactor = component.rollOffFactor;
						data.distanceModel = component.distanceModel;
						instance = new SoundInstance3d(this._manager, sound, data);
				} else {
						instance = new SoundInstance(this._manager, sound, data);
				}
				if (this._firstNode) {
						instance.setExternalNodes(this._firstNode, this._lastNode);
				}
				return instance;
		}
		_onInstancePlay(instance) {
				this.fire('play', instance);
				this._component.fire('play', this, instance);
		}
		_onInstancePause(instance) {
				this.fire('pause', instance);
				this._component.fire('pause', this, instance);
		}
		_onInstanceResume(instance) {
				this.fire('resume', instance);
				this._component.fire('resume', this, instance);
		}
		_onInstanceStop(instance) {
				var idx = this.instances.indexOf(instance);
				if (idx !== -1) {
						this.instances.splice(idx, 1);
				}
				this.fire('stop', instance);
				this._component.fire('stop', this, instance);
		}
		_onInstanceEnd(instance) {
				var idx = this.instances.indexOf(instance);
				if (idx !== -1) {
						this.instances.splice(idx, 1);
				}
				this.fire('end', instance);
				this._component.fire('end', this, instance);
		}
		_onAssetAdd(asset) {
				this.load();
		}
		_onAssetLoad(asset) {
				this.load();
		}
		_onAssetRemoved(asset) {
				asset.off('remove', this._onAssetRemoved, this);
				this._assets.off("add:" + asset.id, this._onAssetAdd, this);
				this.stop();
		}
		updatePosition(position) {
				var instances = this.instances;
				for(var i = 0, len = instances.length; i < len; i++){
						instances[i].position = position;
				}
		}
		set asset(value) {
				var old = this._asset;
				if (old) {
						this._assets.off("add:" + old, this._onAssetAdd, this);
						var oldAsset = this._assets.get(old);
						if (oldAsset) {
								oldAsset.off('remove', this._onAssetRemoved, this);
						}
				}
				this._asset = value;
				if (this._asset instanceof Asset) {
						this._asset = this._asset.id;
				}
				if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
						this.load();
				}
		}
		get asset() {
				return this._asset;
		}
		set autoPlay(value) {
				this._autoPlay = !!value;
		}
		get autoPlay() {
				return this._autoPlay;
		}
		set duration(value) {
				this._duration = Math.max(0, Number(value) || 0) || null;
				if (!this._overlap) {
						var instances = this.instances;
						for(var i = 0, len = instances.length; i < len; i++){
								instances[i].duration = this._duration;
						}
				}
		}
		get duration() {
				var assetDuration = 0;
				if (this._hasAsset()) {
						var asset = this._assets.get(this._asset);
						assetDuration = (asset == null ? void 0 : asset.resource) ? asset.resource.duration : 0;
				}
				if (this._duration != null) {
						return this._duration % (assetDuration || 1);
				}
				return assetDuration;
		}
		get isLoaded() {
				if (this._hasAsset()) {
						var asset = this._assets.get(this._asset);
						if (asset) {
								return !!asset.resource;
						}
				}
				return false;
		}
		get isPaused() {
				var instances = this.instances;
				var len = instances.length;
				if (len === 0) {
						return false;
				}
				for(var i = 0; i < len; i++){
						if (!instances[i].isPaused) {
								return false;
						}
				}
				return true;
		}
		get isPlaying() {
				var instances = this.instances;
				for(var i = 0, len = instances.length; i < len; i++){
						if (instances[i].isPlaying) {
								return true;
						}
				}
				return false;
		}
		get isStopped() {
				var instances = this.instances;
				for(var i = 0, len = instances.length; i < len; i++){
						if (!instances[i].isStopped) {
								return false;
						}
				}
				return true;
		}
		set loop(value) {
				this._loop = !!value;
				var instances = this.instances;
				for(var i = 0, len = instances.length; i < len; i++){
						instances[i].loop = this._loop;
				}
		}
		get loop() {
				return this._loop;
		}
		set overlap(value) {
				this._overlap = !!value;
		}
		get overlap() {
				return this._overlap;
		}
		set pitch(value) {
				this._pitch = Math.max(Number(value) || 0, 0.01);
				if (!this._overlap) {
						var instances = this.instances;
						for(var i = 0, len = instances.length; i < len; i++){
								instances[i].pitch = this.pitch * this._component.pitch;
						}
				}
		}
		get pitch() {
				return this._pitch;
		}
		set startTime(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				if (!this._overlap) {
						var instances = this.instances;
						for(var i = 0, len = instances.length; i < len; i++){
								instances[i].startTime = this._startTime;
						}
				}
		}
		get startTime() {
				return this._startTime;
		}
		set volume(value) {
				this._volume = math.clamp(Number(value) || 0, 0, 1);
				if (!this._overlap) {
						var instances = this.instances;
						for(var i = 0, len = instances.length; i < len; i++){
								instances[i].volume = this._volume * this._component.volume;
						}
				}
		}
		get volume() {
				return this._volume;
		}
		constructor(component, name = 'Untitled', options = {}){
				super(), this.instances = [];
				this._component = component;
				this._assets = component.system.app.assets;
				this._manager = component.system.manager;
				this.name = name;
				this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
				this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
				this._loop = !!(options.loop !== undefined ? options.loop : false);
				this._duration = options.duration > 0 ? options.duration : null;
				this._startTime = Math.max(0, Number(options.startTime) || 0);
				this._overlap = !!options.overlap;
				this._autoPlay = !!options.autoPlay;
				this._firstNode = null;
				this._lastNode = null;
				this._asset = options.asset;
				if (this._asset instanceof Asset) {
						this._asset = this._asset.id;
				}
				this._onInstancePlayHandler = this._onInstancePlay.bind(this);
				this._onInstancePauseHandler = this._onInstancePause.bind(this);
				this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
				this._onInstanceStopHandler = this._onInstanceStop.bind(this);
				this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
		}
}
SoundSlot.EVENT_PLAY = 'play';
SoundSlot.EVENT_PAUSE = 'pause';
SoundSlot.EVENT_RESUME = 'resume';
SoundSlot.EVENT_STOP = 'stop';
SoundSlot.EVENT_LOAD = 'load';

class SoundComponent extends Component {
		_updateSoundInstances(property, value, isFactor) {
				var slots = this._slots;
				for(var key in slots){
						var slot = slots[key];
						if (!slot.overlap) {
								var instances = slot.instances;
								for(var i = 0, len = instances.length; i < len; i++){
										instances[i][property] = isFactor ? slot[property] * value : value;
								}
						}
				}
		}
		set distanceModel(value) {
				this._distanceModel = value;
				this._updateSoundInstances('distanceModel', value, false);
		}
		get distanceModel() {
				return this._distanceModel;
		}
		set maxDistance(value) {
				this._maxDistance = value;
				this._updateSoundInstances('maxDistance', value, false);
		}
		get maxDistance() {
				return this._maxDistance;
		}
		set refDistance(value) {
				this._refDistance = value;
				this._updateSoundInstances('refDistance', value, false);
		}
		get refDistance() {
				return this._refDistance;
		}
		set rollOffFactor(value) {
				this._rollOffFactor = value;
				this._updateSoundInstances('rollOffFactor', value, false);
		}
		get rollOffFactor() {
				return this._rollOffFactor;
		}
		set pitch(value) {
				this._pitch = value;
				this._updateSoundInstances('pitch', value, true);
		}
		get pitch() {
				return this._pitch;
		}
		set volume(value) {
				this._volume = value;
				this._updateSoundInstances('volume', value, true);
		}
		get volume() {
				return this._volume;
		}
		set positional(newValue) {
				this._positional = newValue;
				var slots = this._slots;
				for(var key in slots){
						var slot = slots[key];
						if (!slot.overlap) {
								var instances = slot.instances;
								var oldLength = instances.length;
								for(var i = oldLength - 1; i >= 0; i--){
										var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
										var currentTime = instances[i].currentTime;
										if (isPlaying) {
												instances[i].stop();
										}
										var instance = slot._createInstance();
										if (isPlaying) {
												instance.play();
												instance.currentTime = currentTime;
										}
										instances.push(instance);
								}
						}
				}
		}
		get positional() {
				return this._positional;
		}
		set slots(newValue) {
				var oldValue = this._slots;
				if (oldValue) {
						for(var key in oldValue){
								oldValue[key].stop();
						}
				}
				var slots = {};
				for(var key1 in newValue){
						if (!(newValue[key1] instanceof SoundSlot)) {
								if (newValue[key1].name) {
										slots[newValue[key1].name] = new SoundSlot(this, newValue[key1].name, newValue[key1]);
								}
						} else {
								slots[newValue[key1].name] = newValue[key1];
						}
				}
				this._slots = slots;
				if (this.enabled && this.entity.enabled) {
						this.onEnable();
				}
		}
		get slots() {
				return this._slots;
		}
		onEnable() {
				if (this.system._inTools) {
						return;
				}
				var slots = this._slots;
				var playingBeforeDisable = this._playingBeforeDisable;
				for(var key in slots){
						var slot = slots[key];
						if (slot.autoPlay && slot.isStopped) {
								slot.play();
						} else if (playingBeforeDisable[key]) {
								slot.resume();
						} else if (!slot.isLoaded) {
								slot.load();
						}
				}
		}
		onDisable() {
				var slots = this._slots;
				var playingBeforeDisable = {};
				for(var key in slots){
						if (!slots[key].overlap) {
								if (slots[key].isPlaying) {
										slots[key].pause();
										playingBeforeDisable[key] = true;
								}
						}
				}
				this._playingBeforeDisable = playingBeforeDisable;
		}
		onRemove() {
				this.off();
		}
		addSlot(name, options) {
				var slots = this._slots;
				if (slots[name]) {
						return null;
				}
				var slot = new SoundSlot(this, name, options);
				slots[name] = slot;
				if (slot.autoPlay && this.enabled && this.entity.enabled) {
						slot.play();
				}
				return slot;
		}
		removeSlot(name) {
				var slots = this._slots;
				if (slots[name]) {
						slots[name].stop();
						delete slots[name];
				}
		}
		slot(name) {
				return this._slots[name];
		}
		_getSlotProperty(name, property) {
				if (!this.enabled || !this.entity.enabled) {
						return undefined;
				}
				var slot = this._slots[name];
				if (!slot) {
						return undefined;
				}
				return slot[property];
		}
		isPlaying(name) {
				return this._getSlotProperty(name, 'isPlaying') || false;
		}
		isLoaded(name) {
				return this._getSlotProperty(name, 'isLoaded') || false;
		}
		isPaused(name) {
				return this._getSlotProperty(name, 'isPaused') || false;
		}
		isStopped(name) {
				return this._getSlotProperty(name, 'isStopped') || false;
		}
		play(name) {
				if (!this.enabled || !this.entity.enabled) {
						return null;
				}
				var slot = this._slots[name];
				if (!slot) {
						return null;
				}
				return slot.play();
		}
		pause(name) {
				var slots = this._slots;
				if (name) {
						var slot = slots[name];
						if (!slot) {
								return;
						}
						slot.pause();
				} else {
						for(var key in slots){
								slots[key].pause();
						}
				}
		}
		resume(name) {
				var slots = this._slots;
				if (name) {
						var slot = slots[name];
						if (!slot) {
								return;
						}
						if (slot.isPaused) {
								slot.resume();
						}
				} else {
						for(var key in slots){
								slots[key].resume();
						}
				}
		}
		stop(name) {
				var slots = this._slots;
				if (name) {
						var slot = slots[name];
						if (!slot) {
								return;
						}
						slot.stop();
				} else {
						for(var key in slots){
								slots[key].stop();
						}
				}
		}
		constructor(...args){
				super(...args), this._volume = 1, this._pitch = 1, this._positional = true, this._refDistance = 1, this._maxDistance = 10000, this._rollOffFactor = 1, this._distanceModel = DISTANCE_LINEAR, this._slots = {}, this._playingBeforeDisable = {};
		}
}
SoundComponent.EVENT_PLAY = 'play';
SoundComponent.EVENT_PAUSE = 'pause';
SoundComponent.EVENT_RESUME = 'resume';
SoundComponent.EVENT_STOP = 'stop';
SoundComponent.EVENT_END = 'end';

class SoundComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$4 = [
		'enabled'
];
class SoundComponentSystem extends ComponentSystem {
		set volume(volume) {
				this.manager.volume = volume;
		}
		get volume() {
				return this.manager.volume;
		}
		get context() {
				if (!hasAudioContext()) {
						return null;
				}
				return this.manager.context;
		}
		initializeComponentData(component, data, properties) {
				properties = [
						'volume',
						'pitch',
						'positional',
						'refDistance',
						'maxDistance',
						'rollOffFactor',
						'distanceModel',
						'slots'
				];
				for(var i = 0; i < properties.length; i++){
						if (data.hasOwnProperty(properties[i])) {
								component[properties[i]] = data[properties[i]];
						}
				}
				super.initializeComponentData(component, data, [
						'enabled'
				]);
		}
		cloneComponent(entity, clone) {
				var srcComponent = entity.sound;
				var srcSlots = srcComponent.slots;
				var slots = {};
				for(var key in srcSlots){
						var srcSlot = srcSlots[key];
						slots[key] = {
								name: srcSlot.name,
								volume: srcSlot.volume,
								pitch: srcSlot.pitch,
								loop: srcSlot.loop,
								duration: srcSlot.duration,
								startTime: srcSlot.startTime,
								overlap: srcSlot.overlap,
								autoPlay: srcSlot.autoPlay,
								asset: srcSlot.asset
						};
				}
				var cloneData = {
						distanceModel: srcComponent.distanceModel,
						enabled: srcComponent.enabled,
						maxDistance: srcComponent.maxDistance,
						pitch: srcComponent.pitch,
						positional: srcComponent.positional,
						refDistance: srcComponent.refDistance,
						rollOffFactor: srcComponent.rollOffFactor,
						slots: slots,
						volume: srcComponent.volume
				};
				return this.addComponent(clone, cloneData);
		}
		onUpdate(dt) {
				var store = this.store;
				for(var id in store){
						if (store.hasOwnProperty(id)) {
								var item = store[id];
								var entity = item.entity;
								if (entity.enabled) {
										var component = entity.sound;
										if (component.enabled && component.positional) {
												var position = entity.getPosition();
												var slots = component.slots;
												for(var key in slots){
														slots[key].updatePosition(position);
												}
										}
								}
						}
				}
		}
		onBeforeRemove(entity, component) {
				var slots = component.slots;
				for(var key in slots){
						if (!slots[key].overlap) {
								slots[key].stop();
						}
				}
				component.onRemove();
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = 'sound';
				this.ComponentType = SoundComponent;
				this.DataType = SoundComponentData;
				this.schema = _schema$4;
				this.manager = app.soundManager;
				this.app.systems.on('update', this.onUpdate, this);
				this.on('beforeremove', this.onBeforeRemove, this);
		}
}
Component._buildAccessors(SoundComponent.prototype, _schema$4);

var SPRITETYPE_SIMPLE = 'simple';
var SPRITETYPE_ANIMATED = 'animated';

class SpriteAnimationClip extends EventHandler {
		get duration() {
				if (this._sprite) {
						var fps = this.fps || Number.MIN_VALUE;
						return this._sprite.frameKeys.length / Math.abs(fps);
				}
				return 0;
		}
		set frame(value) {
				this._setFrame(value);
				var fps = this.fps || Number.MIN_VALUE;
				this._setTime(this._frame / fps);
		}
		get frame() {
				return this._frame;
		}
		get isPaused() {
				return this._paused;
		}
		get isPlaying() {
				return this._playing;
		}
		set sprite(value) {
				if (this._sprite) {
						var _this__evtSetMeshes;
						(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
						this._evtSetMeshes = null;
						this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);
						this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);
						if (this._sprite.atlas) {
								this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
						}
				}
				this._sprite = value;
				if (this._sprite) {
						this._evtSetMeshes = this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);
						this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);
						this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);
						if (this._sprite.atlas) {
								this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
						}
				}
				if (this._component.currentClip === this) {
						var mi;
						if (!value || !value.atlas) {
								mi = this._component._meshInstance;
								if (mi) {
										mi.deleteParameter('texture_emissiveMap');
										mi.deleteParameter('texture_opacityMap');
								}
								this._component._hideModel();
						} else {
								if (value.atlas.texture) {
										mi = this._component._meshInstance;
										if (mi) {
												mi.setParameter('texture_emissiveMap', value.atlas.texture);
												mi.setParameter('texture_opacityMap', value.atlas.texture);
										}
										if (this._component.enabled && this._component.entity.enabled) {
												this._component._showModel();
										}
								}
								if (this.time && this.fps) {
										this.time = this.time;
								} else {
										this.frame = this.frame;
								}
						}
				}
		}
		get sprite() {
				return this._sprite;
		}
		set spriteAsset(value) {
				var assets = this._component.system.app.assets;
				var id = value;
				if (value instanceof Asset) {
						id = value.id;
				}
				if (this._spriteAsset !== id) {
						if (this._spriteAsset) {
								var prev = assets.get(this._spriteAsset);
								if (prev) {
										this._unbindSpriteAsset(prev);
								}
						}
						this._spriteAsset = id;
						if (this._spriteAsset) {
								var asset = assets.get(this._spriteAsset);
								if (!asset) {
										this.sprite = null;
										assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
								} else {
										this._bindSpriteAsset(asset);
								}
						} else {
								this.sprite = null;
						}
				}
		}
		get spriteAsset() {
				return this._spriteAsset;
		}
		set time(value) {
				this._setTime(value);
				if (this._sprite) {
						this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
				} else {
						this.frame = 0;
				}
		}
		get time() {
				return this._time;
		}
		_onSpriteAssetAdded(asset) {
				this._component.system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
				if (this._spriteAsset === asset.id) {
						this._bindSpriteAsset(asset);
				}
		}
		_bindSpriteAsset(asset) {
				asset.on('load', this._onSpriteAssetLoad, this);
				asset.on('remove', this._onSpriteAssetRemove, this);
				if (asset.resource) {
						this._onSpriteAssetLoad(asset);
				} else {
						this._component.system.app.assets.load(asset);
				}
		}
		_unbindSpriteAsset(asset) {
				if (!asset) {
						return;
				}
				asset.off('load', this._onSpriteAssetLoad, this);
				asset.off('remove', this._onSpriteAssetRemove, this);
				if (asset.resource && !asset.resource.atlas) {
						this._component.system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
				}
		}
		_onSpriteAssetLoad(asset) {
				if (!asset.resource) {
						this.sprite = null;
				} else {
						if (!asset.resource.atlas) {
								var atlasAssetId = asset.data.textureAtlasAsset;
								var assets = this._component.system.app.assets;
								assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
								assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
						} else {
								this.sprite = asset.resource;
						}
				}
		}
		_onTextureAtlasLoad(atlasAsset) {
				var spriteAsset = this._spriteAsset;
				if (spriteAsset instanceof Asset) {
						this._onSpriteAssetLoad(spriteAsset);
				} else {
						this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
				}
		}
		_onSpriteAssetRemove(asset) {
				this.sprite = null;
		}
		_onSpriteMeshesChange() {
				if (this._component.currentClip === this) {
						this._component._showFrame(this.frame);
				}
		}
		_onSpritePpuChanged() {
				if (this._component.currentClip === this) {
						if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
								this._component._showFrame(this.frame);
						}
				}
		}
		_update(dt) {
				if (this.fps === 0) return;
				if (!this._playing || this._paused || !this._sprite) return;
				var dir = this.fps < 0 ? -1 : 1;
				var time = this._time + dt * this._component.speed * dir;
				var duration = this.duration;
				var end = time > duration || time < 0;
				this._setTime(time);
				var frame = this.frame;
				if (this._sprite) {
						frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
				} else {
						frame = 0;
				}
				if (frame !== this._frame) {
						this._setFrame(frame);
				}
				if (end) {
						if (this.loop) {
								this.fire('loop');
								this._component.fire('loop', this);
						} else {
								this._playing = false;
								this._paused = false;
								this.fire('end');
								this._component.fire('end', this);
						}
				}
		}
		_setTime(value) {
				this._time = value;
				var duration = this.duration;
				if (this._time < 0) {
						if (this.loop) {
								this._time = this._time % duration + duration;
						} else {
								this._time = 0;
						}
				} else if (this._time > duration) {
						if (this.loop) {
								this._time %= duration;
						} else {
								this._time = duration;
						}
				}
		}
		_setFrame(value) {
				if (this._sprite) {
						this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
				} else {
						this._frame = value;
				}
				if (this._component.currentClip === this) {
						this._component._showFrame(this._frame);
				}
		}
		_destroy() {
				if (this._spriteAsset) {
						var assets = this._component.system.app.assets;
						this._unbindSpriteAsset(assets.get(this._spriteAsset));
				}
				if (this._sprite) {
						this.sprite = null;
				}
				if (this._spriteAsset) {
						this.spriteAsset = null;
				}
		}
		play() {
				if (this._playing) {
						return;
				}
				this._playing = true;
				this._paused = false;
				this.frame = 0;
				this.fire('play');
				this._component.fire('play', this);
		}
		pause() {
				if (!this._playing || this._paused) {
						return;
				}
				this._paused = true;
				this.fire('pause');
				this._component.fire('pause', this);
		}
		resume() {
				if (!this._paused) return;
				this._paused = false;
				this.fire('resume');
				this._component.fire('resume', this);
		}
		stop() {
				if (!this._playing) return;
				this._playing = false;
				this._paused = false;
				this._time = 0;
				this.frame = 0;
				this.fire('stop');
				this._component.fire('stop', this);
		}
		constructor(component, data){
				super(), this._evtSetMeshes = null;
				this._component = component;
				this._frame = 0;
				this._sprite = null;
				this._spriteAsset = null;
				this.spriteAsset = data.spriteAsset;
				this.name = data.name;
				this.fps = data.fps || 0;
				this.loop = data.loop || false;
				this._playing = false;
				this._paused = false;
				this._time = 0;
		}
}
SpriteAnimationClip.EVENT_PLAY = 'play';
SpriteAnimationClip.EVENT_PAUSE = 'pause';
SpriteAnimationClip.EVENT_RESUME = 'resume';
SpriteAnimationClip.EVENT_STOP = 'stop';
SpriteAnimationClip.EVENT_END = 'end';
SpriteAnimationClip.EVENT_LOOP = 'loop';

var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
var PARAM_OPACITY_MAP = 'texture_opacityMap';
var PARAM_EMISSIVE = 'material_emissive';
var PARAM_OPACITY = 'material_opacity';
var PARAM_INNER_OFFSET = 'innerOffset';
var PARAM_OUTER_SCALE = 'outerScale';
var PARAM_ATLAS_RECT = 'atlasRect';
class SpriteComponent extends Component {
		set type(value) {
				if (this._type === value) {
						return;
				}
				this._type = value;
				if (this._type === SPRITETYPE_SIMPLE) {
						this.stop();
						this._currentClip = this._defaultClip;
						if (this.enabled && this.entity.enabled) {
								this._currentClip.frame = this.frame;
								if (this._currentClip.sprite) {
										this._showModel();
								} else {
										this._hideModel();
								}
						}
				} else if (this._type === SPRITETYPE_ANIMATED) {
						this.stop();
						if (this._autoPlayClip) {
								this._tryAutoPlay();
						}
						if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
								this._showModel();
						} else {
								this._hideModel();
						}
				}
		}
		get type() {
				return this._type;
		}
		set frame(value) {
				this._currentClip.frame = value;
		}
		get frame() {
				return this._currentClip.frame;
		}
		set spriteAsset(value) {
				this._defaultClip.spriteAsset = value;
		}
		get spriteAsset() {
				return this._defaultClip._spriteAsset;
		}
		set sprite(value) {
				this._currentClip.sprite = value;
		}
		get sprite() {
				return this._currentClip.sprite;
		}
		set material(value) {
				this._material = value;
				if (this._meshInstance) {
						this._meshInstance.material = value;
				}
		}
		get material() {
				return this._material;
		}
		set color(value) {
				this._color.r = value.r;
				this._color.g = value.g;
				this._color.b = value.b;
				if (this._meshInstance) {
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;
						this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				}
		}
		get color() {
				return this._color;
		}
		set opacity(value) {
				this._color.a = value;
				if (this._meshInstance) {
						this._meshInstance.setParameter(PARAM_OPACITY, value);
				}
		}
		get opacity() {
				return this._color.a;
		}
		set clips(value) {
				if (!value) {
						for(var name in this._clips){
								this.removeClip(name);
						}
						return;
				}
				for(var name1 in this._clips){
						var found = false;
						for(var key in value){
								if (value[key].name === name1) {
										found = true;
										this._clips[name1].fps = value[key].fps;
										this._clips[name1].loop = value[key].loop;
										if (value[key].hasOwnProperty('sprite')) {
												this._clips[name1].sprite = value[key].sprite;
										} else if (value[key].hasOwnProperty('spriteAsset')) {
												this._clips[name1].spriteAsset = value[key].spriteAsset;
										}
										break;
								}
						}
						if (!found) {
								this.removeClip(name1);
						}
				}
				for(var key1 in value){
						if (this._clips[value[key1].name]) continue;
						this.addClip(value[key1]);
				}
				if (this._autoPlayClip) {
						this._tryAutoPlay();
				}
				if (!this._currentClip || !this._currentClip.sprite) {
						this._hideModel();
				}
		}
		get clips() {
				return this._clips;
		}
		get currentClip() {
				return this._currentClip;
		}
		set speed(value) {
				this._speed = value;
		}
		get speed() {
				return this._speed;
		}
		set flipX(value) {
				if (this._flipX === value) return;
				this._flipX = value;
				this._updateTransform();
		}
		get flipX() {
				return this._flipX;
		}
		set flipY(value) {
				if (this._flipY === value) return;
				this._flipY = value;
				this._updateTransform();
		}
		get flipY() {
				return this._flipY;
		}
		set width(value) {
				if (value === this._width) return;
				this._width = value;
				this._outerScale.x = this._width;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
						this._updateTransform();
				}
		}
		get width() {
				return this._width;
		}
		set height(value) {
				if (value === this._height) return;
				this._height = value;
				this._outerScale.y = this.height;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
						this._updateTransform();
				}
		}
		get height() {
				return this._height;
		}
		set batchGroupId(value) {
				if (this._batchGroupId === value) {
						return;
				}
				var prev = this._batchGroupId;
				this._batchGroupId = value;
				if (this.entity.enabled && prev >= 0) {
						var _this_system_app_batcher;
						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.SPRITE, prev, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
						var _this_system_app_batcher1;
						(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.SPRITE, value, this.entity);
				} else {
						if (prev >= 0) {
								if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
										this._showModel();
								}
						}
				}
		}
		get batchGroupId() {
				return this._batchGroupId;
		}
		set autoPlayClip(value) {
				this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
				this._tryAutoPlay();
		}
		get autoPlayClip() {
				return this._autoPlayClip;
		}
		set drawOrder(value) {
				this._drawOrder = value;
				if (this._meshInstance) {
						this._meshInstance.drawOrder = value;
				}
		}
		get drawOrder() {
				return this._drawOrder;
		}
		set layers(value) {
				if (this._addedModel) {
						this._hideModel();
				}
				this._layers = value;
				if (!this._meshInstance) {
						return;
				}
				if (this.enabled && this.entity.enabled) {
						this._showModel();
				}
		}
		get layers() {
				return this._layers;
		}
		get aabb() {
				if (this._meshInstance) {
						return this._meshInstance.aabb;
				}
				return null;
		}
		onEnable() {
				var app = this.system.app;
				var scene = app.scene;
				var layers = scene.layers;
				this._evtLayersChanged = scene.on('set:layers', this._onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this._onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this._onLayerRemoved, this);
				}
				this._showModel();
				if (this._autoPlayClip) {
						this._tryAutoPlay();
				}
				if (this._batchGroupId >= 0) {
						var _app_batcher;
						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
				}
		}
		onDisable() {
				var _this__evtLayersChanged;
				var app = this.system.app;
				var scene = app.scene;
				var layers = scene.layers;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				this.stop();
				this._hideModel();
				if (this._batchGroupId >= 0) {
						var _app_batcher;
						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
				}
		}
		onDestroy() {
				var _this__node;
				this._currentClip = null;
				if (this._defaultClip) {
						this._defaultClip._destroy();
						this._defaultClip = null;
				}
				for(var key in this._clips){
						this._clips[key]._destroy();
				}
				this._clips = null;
				this._hideModel();
				this._model = null;
				(_this__node = this._node) == null ? void 0 : _this__node.remove();
				this._node = null;
				if (this._meshInstance) {
						this._meshInstance.material = null;
						this._meshInstance.mesh = null;
						this._meshInstance = null;
				}
		}
		_showModel() {
				if (this._addedModel) return;
				if (!this._meshInstance) return;
				var meshInstances = [
						this._meshInstance
				];
				for(var i = 0, len = this._layers.length; i < len; i++){
						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
						if (layer) {
								layer.addMeshInstances(meshInstances);
						}
				}
				this._addedModel = true;
		}
		_hideModel() {
				if (!this._addedModel || !this._meshInstance) return;
				var meshInstances = [
						this._meshInstance
				];
				for(var i = 0, len = this._layers.length; i < len; i++){
						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
						if (layer) {
								layer.removeMeshInstances(meshInstances);
						}
				}
				this._addedModel = false;
		}
		_showFrame(frame) {
				if (!this.sprite) return;
				var mesh = this.sprite.meshes[frame];
				if (!mesh) {
						if (this._meshInstance) {
								this._meshInstance.mesh = null;
								this._meshInstance.visible = false;
						}
						return;
				}
				var material;
				if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
						material = this.system.default9SlicedMaterialSlicedMode;
				} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
						material = this.system.default9SlicedMaterialTiledMode;
				} else {
						material = this.system.defaultMaterial;
				}
				if (!this._meshInstance) {
						this._meshInstance = new MeshInstance(mesh, this._material, this._node);
						this._meshInstance.castShadow = false;
						this._meshInstance.receiveShadow = false;
						this._meshInstance.drawOrder = this._drawOrder;
						this._model.meshInstances.push(this._meshInstance);
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;
						this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
						this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
						if (this.enabled && this.entity.enabled) {
								this._showModel();
						}
				}
				if (this._meshInstance.material !== material) {
						this._meshInstance.material = material;
				}
				if (this._meshInstance.mesh !== mesh) {
						this._meshInstance.mesh = mesh;
						this._meshInstance.visible = true;
						this._meshInstance._aabbVer = -1;
				}
				if (this.sprite.atlas && this.sprite.atlas.texture) {
						this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
						this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
				} else {
						this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
						this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
				}
				if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
						this._meshInstance._updateAabbFunc = this._updateAabbFunc;
						var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
						if (frameData) {
								var borderWidthScale = 2 / frameData.rect.z;
								var borderHeightScale = 2 / frameData.rect.w;
								this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
								var tex = this.sprite.atlas.texture;
								this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
						} else {
								this._innerOffset.set(0, 0, 0, 0);
						}
						this._innerOffsetUniform[0] = this._innerOffset.x;
						this._innerOffsetUniform[1] = this._innerOffset.y;
						this._innerOffsetUniform[2] = this._innerOffset.z;
						this._innerOffsetUniform[3] = this._innerOffset.w;
						this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
						this._atlasRectUniform[0] = this._atlasRect.x;
						this._atlasRectUniform[1] = this._atlasRect.y;
						this._atlasRectUniform[2] = this._atlasRect.z;
						this._atlasRectUniform[3] = this._atlasRect.w;
						this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
				} else {
						this._meshInstance._updateAabbFunc = null;
				}
				this._updateTransform();
		}
		_updateTransform() {
				var scaleX = this.flipX ? -1 : 1;
				var scaleY = this.flipY ? -1 : 1;
				var posX = 0;
				var posY = 0;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
						var w = 1;
						var h = 1;
						if (this.sprite.atlas) {
								var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
								if (frameData) {
										w = frameData.rect.z;
										h = frameData.rect.w;
										posX = (0.5 - frameData.pivot.x) * this._width;
										posY = (0.5 - frameData.pivot.y) * this._height;
								}
						}
						var scaleMulX = w / this.sprite.pixelsPerUnit;
						var scaleMulY = h / this.sprite.pixelsPerUnit;
						this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
						scaleX *= scaleMulX;
						scaleY *= scaleMulY;
						this._outerScale.x /= scaleMulX;
						this._outerScale.y /= scaleMulY;
						scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
						scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
						if (this._meshInstance) {
								this._outerScaleUniform[0] = this._outerScale.x;
								this._outerScaleUniform[1] = this._outerScale.y;
								this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
						}
				}
				this._node.setLocalScale(scaleX, scaleY, 1);
				this._node.setLocalPosition(posX, posY, 0);
		}
		_updateAabb(aabb) {
				aabb.center.set(0, 0, 0);
				aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
				aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
				return aabb;
		}
		_tryAutoPlay() {
				if (!this._autoPlayClip) return;
				if (this.type !== SPRITETYPE_ANIMATED) return;
				var clip = this._clips[this._autoPlayClip];
				if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
						if (this.enabled && this.entity.enabled) {
								this.play(clip.name);
						}
				}
		}
		_onLayersChanged(oldComp, newComp) {
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
				if (this.enabled && this.entity.enabled) {
						this._showModel();
				}
		}
		_onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
						layer.addMeshInstances([
								this._meshInstance
						]);
				}
		}
		_onLayerRemoved(layer) {
				if (!this._meshInstance) return;
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.removeMeshInstances([
						this._meshInstance
				]);
		}
		removeModelFromLayers() {
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (!layer) continue;
						layer.removeMeshInstances([
								this._meshInstance
						]);
				}
		}
		addClip(data) {
				var clip = new SpriteAnimationClip(this, {
						name: data.name,
						fps: data.fps,
						loop: data.loop,
						spriteAsset: data.spriteAsset
				});
				this._clips[data.name] = clip;
				if (clip.name && clip.name === this._autoPlayClip) {
						this._tryAutoPlay();
				}
				return clip;
		}
		removeClip(name) {
				delete this._clips[name];
		}
		clip(name) {
				return this._clips[name];
		}
		play(name) {
				var clip = this._clips[name];
				var current = this._currentClip;
				if (current && current !== clip) {
						current._playing = false;
				}
				this._currentClip = clip;
				if (this._currentClip) {
						this._currentClip = clip;
						this._currentClip.play();
				}
				return clip;
		}
		pause() {
				if (this._currentClip === this._defaultClip) return;
				if (this._currentClip.isPlaying) {
						this._currentClip.pause();
				}
		}
		resume() {
				if (this._currentClip === this._defaultClip) return;
				if (this._currentClip.isPaused) {
						this._currentClip.resume();
				}
		}
		stop() {
				if (this._currentClip === this._defaultClip) return;
				this._currentClip.stop();
		}
		constructor(system, entity){
				super(system, entity), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
				this._type = SPRITETYPE_SIMPLE;
				this._material = system.defaultMaterial;
				this._color = new Color(1, 1, 1, 1);
				this._colorUniform = new Float32Array(3);
				this._speed = 1;
				this._flipX = false;
				this._flipY = false;
				this._width = 1;
				this._height = 1;
				this._drawOrder = 0;
				this._layers = [
						LAYERID_WORLD
				];
				this._outerScale = new Vec2(1, 1);
				this._outerScaleUniform = new Float32Array(2);
				this._innerOffset = new Vec4();
				this._innerOffsetUniform = new Float32Array(4);
				this._atlasRect = new Vec4();
				this._atlasRectUniform = new Float32Array(4);
				this._batchGroupId = -1;
				this._batchGroup = null;
				this._node = new GraphNode();
				this._model = new Model();
				this._model.graph = this._node;
				this._meshInstance = null;
				entity.addChild(this._model.graph);
				this._model._entity = entity;
				this._updateAabbFunc = this._updateAabb.bind(this);
				this._addedModel = false;
				this._autoPlayClip = null;
				this._clips = {};
				this._defaultClip = new SpriteAnimationClip(this, {
						name: this.entity.name,
						fps: 0,
						loop: false,
						spriteAsset: null
				});
				this._currentClip = this._defaultClip;
		}
}
SpriteComponent.EVENT_PLAY = 'play';
SpriteComponent.EVENT_PAUSE = 'pause';
SpriteComponent.EVENT_RESUME = 'resume';
SpriteComponent.EVENT_STOP = 'stop';
SpriteComponent.EVENT_END = 'end';
SpriteComponent.EVENT_LOOP = 'loop';

class SpriteComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$3 = [
		'enabled'
];
class SpriteComponentSystem extends ComponentSystem {
		set defaultMaterial(material) {
				this._defaultMaterial = material;
		}
		get defaultMaterial() {
				if (!this._defaultMaterial) {
						var texture = new Texture(this.app.graphicsDevice, {
								width: 1,
								height: 1,
								format: PIXELFORMAT_SRGBA8,
								name: 'sprite'
						});
						var pixels = new Uint8Array(texture.lock());
						pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
						texture.unlock();
						var material = new StandardMaterial();
						material.diffuse.set(0, 0, 0);
						material.emissive.set(1, 1, 1);
						material.emissiveMap = texture;
						material.opacityMap = texture;
						material.opacityMapChannel = 'a';
						material.useLighting = false;
						material.useTonemap = false;
						material.useFog = false;
						material.useSkybox = false;
						material.blendType = BLEND_PREMULTIPLIED;
						material.depthWrite = false;
						material.pixelSnap = false;
						material.cull = CULLFACE_NONE;
						material.update();
						this._defaultTexture = texture;
						this._defaultMaterial = material;
				}
				return this._defaultMaterial;
		}
		set default9SlicedMaterialSlicedMode(material) {
				this._default9SlicedMaterialSlicedMode = material;
		}
		get default9SlicedMaterialSlicedMode() {
				if (!this._default9SlicedMaterialSlicedMode) {
						var material = this.defaultMaterial.clone();
						material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						material.update();
						this._default9SlicedMaterialSlicedMode = material;
				}
				return this._default9SlicedMaterialSlicedMode;
		}
		set default9SlicedMaterialTiledMode(material) {
				this._default9SlicedMaterialTiledMode = material;
		}
		get default9SlicedMaterialTiledMode() {
				if (!this._default9SlicedMaterialTiledMode) {
						var material = this.defaultMaterial.clone();
						material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						material.update();
						this._default9SlicedMaterialTiledMode = material;
				}
				return this._default9SlicedMaterialTiledMode;
		}
		destroy() {
				super.destroy();
				this.app.systems.off('update', this.onUpdate, this);
				if (this._defaultTexture) {
						this._defaultTexture.destroy();
						this._defaultTexture = null;
				}
		}
		initializeComponentData(component, data, properties) {
				if (data.enabled !== undefined) {
						component.enabled = data.enabled;
				}
				component.type = data.type;
				if (data.layers && Array.isArray(data.layers)) {
						component.layers = data.layers.slice(0);
				}
				if (data.drawOrder !== undefined) {
						component.drawOrder = data.drawOrder;
				}
				if (data.color !== undefined) {
						if (data.color instanceof Color) {
								var _data_opacity;
								component.color.set(data.color.r, data.color.g, data.color.b, (_data_opacity = data.opacity) != null ? _data_opacity : 1);
						} else {
								var _data_opacity1;
								component.color.set(data.color[0], data.color[1], data.color[2], (_data_opacity1 = data.opacity) != null ? _data_opacity1 : 1);
						}
						component.color = component.color;
				}
				if (data.opacity !== undefined) {
						component.opacity = data.opacity;
				}
				if (data.flipX !== undefined) {
						component.flipX = data.flipX;
				}
				if (data.flipY !== undefined) {
						component.flipY = data.flipY;
				}
				if (data.width !== undefined) {
						component.width = data.width;
				}
				if (data.height !== undefined) {
						component.height = data.height;
				}
				if (data.spriteAsset !== undefined) {
						component.spriteAsset = data.spriteAsset;
				}
				if (data.sprite) {
						component.sprite = data.sprite;
				}
				if (data.frame !== undefined) {
						component.frame = data.frame;
				}
				if (data.clips) {
						for(var name in data.clips){
								component.addClip(data.clips[name]);
						}
				}
				if (data.speed !== undefined) {
						component.speed = data.speed;
				}
				if (data.autoPlayClip) {
						component.autoPlayClip = data.autoPlayClip;
				}
				component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
				super.initializeComponentData(component, data, properties);
		}
		cloneComponent(entity, clone) {
				var source = entity.sprite;
				return this.addComponent(clone, {
						enabled: source.enabled,
						type: source.type,
						spriteAsset: source.spriteAsset,
						sprite: source.sprite,
						width: source.width,
						height: source.height,
						frame: source.frame,
						color: source.color.clone(),
						opacity: source.opacity,
						flipX: source.flipX,
						flipY: source.flipY,
						speed: source.speed,
						clips: source.clips,
						autoPlayClip: source.autoPlayClip,
						batchGroupId: source.batchGroupId,
						drawOrder: source.drawOrder,
						layers: source.layers.slice(0)
				});
		}
		onUpdate(dt) {
				var components = this.store;
				for(var id in components){
						if (components.hasOwnProperty(id)) {
								var component = components[id];
								if (component.data.enabled && component.entity.enabled) {
										var sprite = component.entity.sprite;
										if (sprite._currentClip) {
												sprite._currentClip._update(dt);
										}
								}
						}
				}
		}
		onBeforeRemove(entity, component) {
				component.onDestroy();
		}
		constructor(app){
				super(app);
				this.id = 'sprite';
				this.ComponentType = SpriteComponent;
				this.DataType = SpriteComponentData;
				this.schema = _schema$3;
				this._defaultTexture = null;
				this._defaultMaterial = null;
				this._default9SlicedMaterialSlicedMode = null;
				this._default9SlicedMaterialTiledMode = null;
				this.app.systems.on('update', this.onUpdate, this);
				this.on('beforeremove', this.onBeforeRemove, this);
		}
}
Component._buildAccessors(SpriteComponent.prototype, _schema$3);

class ZoneComponent extends Component {
		set size(data) {
				if (data instanceof Vec3) {
						this._size.copy(data);
				} else if (data instanceof Array && data.length >= 3) {
						this.size.set(data[0], data[1], data[2]);
				}
		}
		get size() {
				return this._size;
		}
		onEnable() {
				this._checkState();
		}
		onDisable() {
				this._checkState();
		}
		_onSetEnabled(prop, old, value) {
				this._checkState();
		}
		_checkState() {
				var state = this.enabled && this.entity.enabled;
				if (state === this._oldState) {
						return;
				}
				this._oldState = state;
				this.fire('enable');
				this.fire('state', this.enabled);
		}
		_onBeforeRemove() {
				this.fire('remove');
		}
		constructor(system, entity){
				super(system, entity);
				this._oldState = true;
				this._size = new Vec3();
				this.on('set_enabled', this._onSetEnabled, this);
		}
}
ZoneComponent.EVENT_ENABLE = 'enable';
ZoneComponent.EVENT_DISABLE = 'disable';
ZoneComponent.EVENT_STATE = 'state';
ZoneComponent.EVENT_REMOVE = 'remove';

class ZoneComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$2 = [
		'enabled'
];
class ZoneComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
				if (data.size) {
						if (data.size instanceof Vec3) {
								component.size.copy(data.size);
						} else if (data.size instanceof Array && data.size.length >= 3) {
								component.size.set(data.size[0], data.size[1], data.size[2]);
						}
				}
		}
		cloneComponent(entity, clone) {
				var data = {
						enabled: entity.zone.enabled,
						size: entity.zone.size
				};
				return this.addComponent(clone, data);
		}
		_onBeforeRemove(entity, component) {
				component._onBeforeRemove();
		}
		constructor(app){
				super(app);
				this.id = 'zone';
				this.ComponentType = ZoneComponent;
				this.DataType = ZoneComponentData;
				this.schema = _schema$2;
				this.on('beforeremove', this._onBeforeRemove, this);
		}
}
Component._buildAccessors(ZoneComponent.prototype, _schema$2);

class PostEffectEntry {
		constructor(effect, inputTarget){
				this.effect = effect;
				this.inputTarget = inputTarget;
				this.outputTarget = null;
				this.name = effect.constructor.name;
		}
}
class PostEffectQueue {
		_allocateColorBuffer(format, name) {
				var rect = this.camera.rect;
				var renderTarget = this.destinationRenderTarget;
				var device = this.app.graphicsDevice;
				var _renderTarget_width;
				var width = Math.floor(rect.z * ((_renderTarget_width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget_width : device.width));
				var _renderTarget_height;
				var height = Math.floor(rect.w * ((_renderTarget_height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget_height : device.height));
				var colorBuffer = new Texture(device, {
						name: name,
						format: format,
						width: width,
						height: height,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				return colorBuffer;
		}
		_createOffscreenTarget(useDepth, hdr) {
				var device = this.app.graphicsDevice;
				var _this_destinationRenderTarget;
				var outputRt = (_this_destinationRenderTarget = this.destinationRenderTarget) != null ? _this_destinationRenderTarget : device.backBuffer;
				var srgb = outputRt.isColorBufferSrgb(0);
				var _ref;
				var format = (_ref = hdr && device.getRenderableHdrFormat([
						PIXELFORMAT_RGBA16F,
						PIXELFORMAT_RGBA32F
				], true)) != null ? _ref : srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8;
				var name = this.camera.entity.name + "-posteffect-" + this.effects.length;
				var colorBuffer = this._allocateColorBuffer(format, name);
				return new RenderTarget({
						colorBuffer: colorBuffer,
						depth: useDepth,
						stencil: useDepth && this.app.graphicsDevice.supportsStencil,
						samples: useDepth ? device.samples : 1
				});
		}
		_resizeOffscreenTarget(rt) {
				var format = rt.colorBuffer.format;
				var name = rt.colorBuffer.name;
				rt.destroyFrameBuffers();
				rt.destroyTextureBuffers();
				rt._colorBuffer = this._allocateColorBuffer(format, name);
				rt._colorBuffers = [
						rt._colorBuffer
				];
		}
		_destroyOffscreenTarget(rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
		}
		addEffect(effect) {
				var effects = this.effects;
				var isFirstEffect = effects.length === 0;
				var inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);
				var newEntry = new PostEffectEntry(effect, inputTarget);
				effects.push(newEntry);
				this._sourceTarget = newEntry.inputTarget;
				if (effects.length > 1) {
						effects[effects.length - 2].outputTarget = newEntry.inputTarget;
				}
				this._newPostEffect = effect;
				if (effect.needsDepthBuffer) {
						this._requestDepthMap();
				}
				this.enable();
				this._newPostEffect = undefined;
		}
		removeEffect(effect) {
				var index = -1;
				for(var i = 0, len = this.effects.length; i < len; i++){
						if (this.effects[i].effect === effect) {
								index = i;
								break;
						}
				}
				if (index >= 0) {
						if (index > 0) {
								this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
						} else {
								if (this.effects.length > 1) {
										if (!this.effects[1].inputTarget._depth) {
												this._destroyOffscreenTarget(this.effects[1].inputTarget);
												this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
												this._sourceTarget = this.effects[1].inputTarget;
										}
										this.camera.renderTarget = this.effects[1].inputTarget;
								}
						}
						this._destroyOffscreenTarget(this.effects[index].inputTarget);
						this.effects.splice(index, 1);
				}
				if (this.enabled) {
						if (effect.needsDepthBuffer) {
								this._releaseDepthMap();
						}
				}
				if (this.effects.length === 0) {
						this.disable();
				}
		}
		_requestDepthMaps() {
				for(var i = 0, len = this.effects.length; i < len; i++){
						var effect = this.effects[i].effect;
						if (this._newPostEffect === effect) {
								continue;
						}
						if (effect.needsDepthBuffer) {
								this._requestDepthMap();
						}
				}
		}
		_releaseDepthMaps() {
				for(var i = 0, len = this.effects.length; i < len; i++){
						var effect = this.effects[i].effect;
						if (effect.needsDepthBuffer) {
								this._releaseDepthMap();
						}
				}
		}
		_requestDepthMap() {
				var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
				if (depthLayer) {
						depthLayer.incrementCounter();
						this.camera.requestSceneDepthMap(true);
				}
		}
		_releaseDepthMap() {
				var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
				if (depthLayer) {
						depthLayer.decrementCounter();
						this.camera.requestSceneDepthMap(false);
				}
		}
		destroy() {
				for(var i = 0, len = this.effects.length; i < len; i++){
						this.effects[i].inputTarget.destroy();
				}
				this.effects.length = 0;
				this.disable();
		}
		enable() {
				if (!this.enabled && this.effects.length) {
						this.enabled = true;
						this._requestDepthMaps();
						this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
						this.destinationRenderTarget = this.camera.renderTarget;
						this.camera.renderTarget = this.effects[0].inputTarget;
						this.camera.onPostprocessing = ()=>{
								if (this.enabled) {
										var rect = null;
										var len = this.effects.length;
										if (len) {
												for(var i = 0; i < len; i++){
														var fx = this.effects[i];
														var destTarget = fx.outputTarget;
														if (i === len - 1) {
																rect = this.camera.rect;
																if (this.destinationRenderTarget) {
																		destTarget = this.destinationRenderTarget;
																}
														}
														fx.effect.render(fx.inputTarget, destTarget, rect);
												}
										}
								}
						};
				}
		}
		disable() {
				if (this.enabled) {
						this.enabled = false;
						this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);
						this._releaseDepthMaps();
						this._destroyOffscreenTarget(this._sourceTarget);
						this.camera.renderTarget = this.destinationRenderTarget;
						this.camera.onPostprocessing = null;
				}
		}
		_onCanvasResized(width, height) {
				var rect = this.camera.rect;
				var renderTarget = this.destinationRenderTarget;
				var _renderTarget_width;
				width = (_renderTarget_width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget_width : width;
				var _renderTarget_height;
				height = (_renderTarget_height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget_height : height;
				this.camera.camera.aspectRatio = width * rect.z / (height * rect.w);
				this.resizeRenderTargets();
		}
		resizeRenderTargets() {
				var device = this.app.graphicsDevice;
				var renderTarget = this.destinationRenderTarget;
				var _renderTarget_width;
				var width = (_renderTarget_width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget_width : device.width;
				var _renderTarget_height;
				var height = (_renderTarget_height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget_height : device.height;
				var rect = this.camera.rect;
				var desiredWidth = Math.floor(rect.z * width);
				var desiredHeight = Math.floor(rect.w * height);
				var effects = this.effects;
				for(var i = 0, len = effects.length; i < len; i++){
						var fx = effects[i];
						if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
								this._resizeOffscreenTarget(fx.inputTarget);
						}
				}
		}
		onCameraRectChanged(name, oldValue, newValue) {
				if (this.enabled) {
						this.resizeRenderTargets();
				}
		}
		constructor(app, camera){
				this.app = app;
				this.camera = camera;
				this.destinationRenderTarget = null;
				this.effects = [];
				this.enabled = false;
				this.depthTarget = null;
				camera.on('set:rect', this.onCameraRectChanged, this);
		}
}

class CameraComponent extends Component {
		setShaderPass(name) {
				var shaderPass = ShaderPass.get(this.system.app.graphicsDevice);
				var shaderPassInfo = name ? shaderPass.allocate(name, {
						isForward: true
				}) : null;
				this._camera.shaderPassInfo = shaderPassInfo;
				return shaderPassInfo.index;
		}
		getShaderPass() {
				var _this__camera_shaderPassInfo;
				return (_this__camera_shaderPassInfo = this._camera.shaderPassInfo) == null ? void 0 : _this__camera_shaderPassInfo.name;
		}
		set renderPasses(passes) {
				this._camera.renderPasses = passes || [];
				this.dirtyLayerCompositionCameras();
				this.system.app.scene.updateShaders = true;
		}
		get renderPasses() {
				return this._camera.renderPasses;
		}
		get shaderParams() {
				return this._camera.shaderParams;
		}
		set gammaCorrection(value) {
				this.camera.shaderParams.gammaCorrection = value;
		}
		get gammaCorrection() {
				return this.camera.shaderParams.gammaCorrection;
		}
		set toneMapping(value) {
				this.camera.shaderParams.toneMapping = value;
		}
		get toneMapping() {
				return this.camera.shaderParams.toneMapping;
		}
		set fog(value) {
				this._camera.fogParams = value;
		}
		get fog() {
				return this._camera.fogParams;
		}
		set aperture(value) {
				this._camera.aperture = value;
		}
		get aperture() {
				return this._camera.aperture;
		}
		set aspectRatio(value) {
				this._camera.aspectRatio = value;
		}
		get aspectRatio() {
				return this._camera.aspectRatio;
		}
		set aspectRatioMode(value) {
				this._camera.aspectRatioMode = value;
		}
		get aspectRatioMode() {
				return this._camera.aspectRatioMode;
		}
		set calculateProjection(value) {
				this._camera.calculateProjection = value;
		}
		get calculateProjection() {
				return this._camera.calculateProjection;
		}
		set calculateTransform(value) {
				this._camera.calculateTransform = value;
		}
		get calculateTransform() {
				return this._camera.calculateTransform;
		}
		get camera() {
				return this._camera;
		}
		set clearColor(value) {
				this._camera.clearColor = value;
		}
		get clearColor() {
				return this._camera.clearColor;
		}
		set clearColorBuffer(value) {
				this._camera.clearColorBuffer = value;
				this.dirtyLayerCompositionCameras();
		}
		get clearColorBuffer() {
				return this._camera.clearColorBuffer;
		}
		set clearDepthBuffer(value) {
				this._camera.clearDepthBuffer = value;
				this.dirtyLayerCompositionCameras();
		}
		get clearDepthBuffer() {
				return this._camera.clearDepthBuffer;
		}
		set clearStencilBuffer(value) {
				this._camera.clearStencilBuffer = value;
				this.dirtyLayerCompositionCameras();
		}
		get clearStencilBuffer() {
				return this._camera.clearStencilBuffer;
		}
		set cullFaces(value) {
				this._camera.cullFaces = value;
		}
		get cullFaces() {
				return this._camera.cullFaces;
		}
		set disablePostEffectsLayer(layer) {
				this._disablePostEffectsLayer = layer;
				this.dirtyLayerCompositionCameras();
		}
		get disablePostEffectsLayer() {
				return this._disablePostEffectsLayer;
		}
		set farClip(value) {
				this._camera.farClip = value;
		}
		get farClip() {
				return this._camera.farClip;
		}
		set flipFaces(value) {
				this._camera.flipFaces = value;
		}
		get flipFaces() {
				return this._camera.flipFaces;
		}
		set fov(value) {
				this._camera.fov = value;
		}
		get fov() {
				return this._camera.fov;
		}
		get frustum() {
				return this._camera.frustum;
		}
		set frustumCulling(value) {
				this._camera.frustumCulling = value;
		}
		get frustumCulling() {
				return this._camera.frustumCulling;
		}
		set horizontalFov(value) {
				this._camera.horizontalFov = value;
		}
		get horizontalFov() {
				return this._camera.horizontalFov;
		}
		set layers(newValue) {
				var oldLayers = this._camera.layers;
				var scene = this.system.app.scene;
				oldLayers.forEach((layerId)=>{
						var layer = scene.layers.getLayerById(layerId);
						layer == null ? void 0 : layer.removeCamera(this);
				});
				this._camera.layers = newValue;
				if (this.enabled && this.entity.enabled) {
						newValue.forEach((layerId)=>{
								var layer = scene.layers.getLayerById(layerId);
								layer == null ? void 0 : layer.addCamera(this);
						});
				}
		}
		get layers() {
				return this._camera.layers;
		}
		get layersSet() {
				return this._camera.layersSet;
		}
		set jitter(value) {
				this._camera.jitter = value;
		}
		get jitter() {
				return this._camera.jitter;
		}
		set nearClip(value) {
				this._camera.nearClip = value;
		}
		get nearClip() {
				return this._camera.nearClip;
		}
		set orthoHeight(value) {
				this._camera.orthoHeight = value;
		}
		get orthoHeight() {
				return this._camera.orthoHeight;
		}
		get postEffects() {
				return this._postEffects;
		}
		get postEffectsEnabled() {
				return this._postEffects.enabled;
		}
		set priority(newValue) {
				this._priority = newValue;
				this.dirtyLayerCompositionCameras();
		}
		get priority() {
				return this._priority;
		}
		set projection(value) {
				this._camera.projection = value;
		}
		get projection() {
				return this._camera.projection;
		}
		get projectionMatrix() {
				return this._camera.projectionMatrix;
		}
		set rect(value) {
				this._camera.rect = value;
				this.fire('set:rect', this._camera.rect);
		}
		get rect() {
				return this._camera.rect;
		}
		set renderSceneColorMap(value) {
				if (value && !this._sceneColorMapRequested) {
						this.requestSceneColorMap(true);
						this._sceneColorMapRequested = true;
				} else if (this._sceneColorMapRequested) {
						this.requestSceneColorMap(false);
						this._sceneColorMapRequested = false;
				}
		}
		get renderSceneColorMap() {
				return this._renderSceneColorMap > 0;
		}
		set renderSceneDepthMap(value) {
				if (value && !this._sceneDepthMapRequested) {
						this.requestSceneDepthMap(true);
						this._sceneDepthMapRequested = true;
				} else if (this._sceneDepthMapRequested) {
						this.requestSceneDepthMap(false);
						this._sceneDepthMapRequested = false;
				}
		}
		get renderSceneDepthMap() {
				return this._renderSceneDepthMap > 0;
		}
		set renderTarget(value) {
				this._camera.renderTarget = value;
				this.dirtyLayerCompositionCameras();
		}
		get renderTarget() {
				return this._camera.renderTarget;
		}
		set scissorRect(value) {
				this._camera.scissorRect = value;
		}
		get scissorRect() {
				return this._camera.scissorRect;
		}
		set sensitivity(value) {
				this._camera.sensitivity = value;
		}
		get sensitivity() {
				return this._camera.sensitivity;
		}
		set shutter(value) {
				this._camera.shutter = value;
		}
		get shutter() {
				return this._camera.shutter;
		}
		get viewMatrix() {
				return this._camera.viewMatrix;
		}
		_enableDepthLayer(value) {
				var hasDepthLayer = this.layers.find((layerId)=>layerId === LAYERID_DEPTH);
				if (hasDepthLayer) {
						var depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
						if (value) {
								depthLayer == null ? void 0 : depthLayer.incrementCounter();
						} else {
								depthLayer == null ? void 0 : depthLayer.decrementCounter();
						}
				} else if (value) {
						return false;
				}
				return true;
		}
		requestSceneColorMap(enabled) {
				this._renderSceneColorMap += enabled ? 1 : -1;
				this._enableDepthLayer(enabled);
				this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap);
		}
		requestSceneDepthMap(enabled) {
				this._renderSceneDepthMap += enabled ? 1 : -1;
				this._enableDepthLayer(enabled);
				this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap);
		}
		dirtyLayerCompositionCameras() {
				var layerComp = this.system.app.scene.layers;
				layerComp._dirty = true;
		}
		screenToWorld(screenx, screeny, cameraz, worldCoord) {
				var device = this.system.app.graphicsDevice;
				var { width, height } = device.clientRect;
				return this._camera.screenToWorld(screenx, screeny, cameraz, width, height, worldCoord);
		}
		worldToScreen(worldCoord, screenCoord) {
				var device = this.system.app.graphicsDevice;
				var { width, height } = device.clientRect;
				return this._camera.worldToScreen(worldCoord, width, height, screenCoord);
		}
		onAppPrerender() {
				this._camera._viewMatDirty = true;
				this._camera._viewProjMatDirty = true;
		}
		addCameraToLayers() {
				var layers = this.layers;
				for(var i = 0; i < layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(layers[i]);
						if (layer) {
								layer.addCamera(this);
						}
				}
		}
		removeCameraFromLayers() {
				var layers = this.layers;
				for(var i = 0; i < layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(layers[i]);
						if (layer) {
								layer.removeCamera(this);
						}
				}
		}
		onLayersChanged(oldComp, newComp) {
				this.addCameraToLayers();
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.addCamera(this);
		}
		onLayerRemoved(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				layer.removeCamera(this);
		}
		onEnable() {
				var _this__evtLayersChanged;
				var scene = this.system.app.scene;
				var layers = scene.layers;
				this.system.addCamera(this);
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				if (this.enabled && this.entity.enabled) {
						this.addCameraToLayers();
				}
				this.postEffects.enable();
		}
		onDisable() {
				var _this__evtLayersChanged;
				var scene = this.system.app.scene;
				var layers = scene.layers;
				this.postEffects.disable();
				this.removeCameraFromLayers();
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				this.system.removeCamera(this);
		}
		onRemove() {
				this.onDisable();
				this.off();
				this.camera.destroy();
		}
		calculateAspectRatio(rt) {
				var device = this.system.app.graphicsDevice;
				var width = rt ? rt.width : device.width;
				var height = rt ? rt.height : device.height;
				return width * this.rect.z / (height * this.rect.w);
		}
		frameUpdate(rt) {
				if (this.aspectRatioMode === ASPECT_AUTO) {
						this.aspectRatio = this.calculateAspectRatio(rt);
				}
		}
		startXr(type, spaceType, options) {
				this.system.app.xr.start(this, type, spaceType, options);
		}
		endXr(callback) {
				if (!this._camera.xr) {
						if (callback) callback(new Error('Camera is not in XR'));
						return;
				}
				this._camera.xr.end(callback);
		}
		copy(source) {
				this.aperture = source.aperture;
				this.aspectRatio = source.aspectRatio;
				this.aspectRatioMode = source.aspectRatioMode;
				this.calculateProjection = source.calculateProjection;
				this.calculateTransform = source.calculateTransform;
				this.clearColor = source.clearColor;
				this.clearColorBuffer = source.clearColorBuffer;
				this.clearDepthBuffer = source.clearDepthBuffer;
				this.clearStencilBuffer = source.clearStencilBuffer;
				this.cullFaces = source.cullFaces;
				this.disablePostEffectsLayer = source.disablePostEffectsLayer;
				this.farClip = source.farClip;
				this.flipFaces = source.flipFaces;
				this.fov = source.fov;
				this.frustumCulling = source.frustumCulling;
				this.horizontalFov = source.horizontalFov;
				this.layers = source.layers;
				this.nearClip = source.nearClip;
				this.orthoHeight = source.orthoHeight;
				this.priority = source.priority;
				this.projection = source.projection;
				this.rect = source.rect;
				this.renderTarget = source.renderTarget;
				this.scissorRect = source.scissorRect;
				this.sensitivity = source.sensitivity;
				this.shutter = source.shutter;
		}
		constructor(system, entity){
				super(system, entity), this.onPostprocessing = null, this._renderSceneDepthMap = 0, this._renderSceneColorMap = 0, this._sceneDepthMapRequested = false, this._sceneColorMapRequested = false, this._priority = 0, this._disablePostEffectsLayer = LAYERID_UI, this._camera = new Camera(), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
				this._camera.node = entity;
				this._postEffects = new PostEffectQueue(system.app, this);
		}
}

class CameraComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema$1 = [
		'enabled'
];
class CameraComponentSystem extends ComponentSystem {
		initializeComponentData(component, data, properties) {
				properties = [
						'aspectRatio',
						'aspectRatioMode',
						'calculateProjection',
						'calculateTransform',
						'clearColor',
						'clearColorBuffer',
						'clearDepthBuffer',
						'clearStencilBuffer',
						'renderSceneColorMap',
						'renderSceneDepthMap',
						'cullFaces',
						'farClip',
						'flipFaces',
						'fov',
						'frustumCulling',
						'horizontalFov',
						'layers',
						'renderTarget',
						'nearClip',
						'orthoHeight',
						'projection',
						'priority',
						'rect',
						'scissorRect',
						'aperture',
						'shutter',
						'sensitivity',
						'gammaCorrection',
						'toneMapping'
				];
				for(var i = 0; i < properties.length; i++){
						var property = properties[i];
						if (data.hasOwnProperty(property)) {
								var value = data[property];
								switch(property){
										case 'rect':
										case 'scissorRect':
												if (Array.isArray(value)) {
														component[property] = new Vec4(value[0], value[1], value[2], value[3]);
												} else {
														component[property] = value;
												}
												break;
										case 'clearColor':
												if (Array.isArray(value)) {
														component[property] = new Color(value[0], value[1], value[2], value[3]);
												} else {
														component[property] = value;
												}
												break;
										default:
												component[property] = value;
												break;
								}
						}
				}
				super.initializeComponentData(component, data, [
						'enabled'
				]);
		}
		cloneComponent(entity, clone) {
				var c = entity.camera;
				return this.addComponent(clone, {
						aspectRatio: c.aspectRatio,
						aspectRatioMode: c.aspectRatioMode,
						calculateProjection: c.calculateProjection,
						calculateTransform: c.calculateTransform,
						clearColor: c.clearColor,
						clearColorBuffer: c.clearColorBuffer,
						clearDepthBuffer: c.clearDepthBuffer,
						clearStencilBuffer: c.clearStencilBuffer,
						renderSceneDepthMap: c.renderSceneDepthMap,
						renderSceneColorMap: c.renderSceneColorMap,
						cullFaces: c.cullFaces,
						enabled: c.enabled,
						farClip: c.farClip,
						flipFaces: c.flipFaces,
						fov: c.fov,
						frustumCulling: c.frustumCulling,
						horizontalFov: c.horizontalFov,
						layers: c.layers,
						renderTarget: c.renderTarget,
						nearClip: c.nearClip,
						orthoHeight: c.orthoHeight,
						projection: c.projection,
						priority: c.priority,
						rect: c.rect,
						scissorRect: c.scissorRect,
						aperture: c.aperture,
						sensitivity: c.sensitivity,
						shutter: c.shutter,
						gammaCorrection: c.gammaCorrection,
						toneMapping: c.toneMapping
				});
		}
		onBeforeRemove(entity, component) {
				this.removeCamera(component);
				component.onRemove();
		}
		onAppPrerender() {
				for(var i = 0, len = this.cameras.length; i < len; i++){
						this.cameras[i].onAppPrerender();
				}
		}
		addCamera(camera) {
				this.cameras.push(camera);
				sortPriority(this.cameras);
		}
		removeCamera(camera) {
				var index = this.cameras.indexOf(camera);
				if (index >= 0) {
						this.cameras.splice(index, 1);
						sortPriority(this.cameras);
				}
		}
		destroy() {
				this.app.off('prerender', this.onAppPrerender, this);
				super.destroy();
		}
		constructor(app){
				super(app), this.cameras = [];
				this.id = 'camera';
				this.ComponentType = CameraComponent;
				this.DataType = CameraComponentData;
				this.schema = _schema$1;
				this.on('beforeremove', this.onBeforeRemove, this);
				this.app.on('prerender', this.onAppPrerender, this);
		}
}
Component._buildAccessors(CameraComponent.prototype, _schema$1);

class LightComponentData {
		constructor(){
				this.enabled = true;
				this.type = 'directional';
				this.color = new Color(1, 1, 1);
				this.intensity = 1;
				this.luminance = 0;
				this.shape = LIGHTSHAPE_PUNCTUAL;
				this.affectSpecularity = true;
				this.castShadows = false;
				this.shadowDistance = 40;
				this.shadowIntensity = 1;
				this.shadowResolution = 1024;
				this.shadowBias = 0.05;
				this.numCascades = 1;
				this.cascadeBlend = 0;
				this.bakeNumSamples = 1;
				this.bakeArea = 0;
				this.cascadeDistribution = 0.5;
				this.normalOffsetBias = 0;
				this.range = 10;
				this.innerConeAngle = 40;
				this.outerConeAngle = 45;
				this.falloffMode = LIGHTFALLOFF_LINEAR;
				this.shadowType = SHADOW_PCF3_32F;
				this.vsmBlurSize = 11;
				this.vsmBlurMode = BLUR_GAUSSIAN;
				this.vsmBias = 0.01 * 0.25;
				this.cookieAsset = null;
				this.cookie = null;
				this.cookieIntensity = 1;
				this.cookieFalloff = true;
				this.cookieChannel = 'rgb';
				this.cookieAngle = 0;
				this.cookieScale = null;
				this.cookieOffset = null;
				this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
				this.mask = 1;
				this.affectDynamic = true;
				this.affectLightmapped = false;
				this.bake = false;
				this.bakeDir = true;
				this.isStatic = false;
				this.layers = [
						LAYERID_WORLD
				];
				this.penumbraSize = 1;
				this.penumbraFalloff = 1;
				this.shadowSamples = 16;
				this.shadowBlockerSamples = 16;
		}
}
var properties = Object.keys(new LightComponentData());

class LightComponent extends Component {
		get data() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
		}
		set enabled(arg) {
				this._setValue('enabled', arg, function(newValue, oldValue) {
						this.onSetEnabled(null, oldValue, newValue);
				});
		}
		get enabled() {
				return this.data.enabled;
		}
		set light(arg) {
				this._setValue('light', arg);
		}
		get light() {
				return this.data.light;
		}
		set type(arg) {
				this._setValue('type', arg, function(newValue, oldValue) {
						this.system.changeType(this, oldValue, newValue);
						this.refreshProperties();
				});
		}
		get type() {
				return this.data.type;
		}
		set color(arg) {
				this._setValue('color', arg, function(newValue, oldValue) {
						this.light.setColor(newValue);
				}, true);
		}
		get color() {
				return this.data.color;
		}
		set intensity(arg) {
				this._setValue('intensity', arg, function(newValue, oldValue) {
						this.light.intensity = newValue;
				});
		}
		get intensity() {
				return this.data.intensity;
		}
		set luminance(arg) {
				this._setValue('luminance', arg, function(newValue, oldValue) {
						this.light.luminance = newValue;
				});
		}
		get luminance() {
				return this.data.luminance;
		}
		set shape(arg) {
				this._setValue('shape', arg, function(newValue, oldValue) {
						this.light.shape = newValue;
				});
		}
		get shape() {
				return this.data.shape;
		}
		set affectSpecularity(arg) {
				this._setValue('affectSpecularity', arg, function(newValue, oldValue) {
						this.light.affectSpecularity = newValue;
				});
		}
		get affectSpecularity() {
				return this.data.affectSpecularity;
		}
		set castShadows(arg) {
				this._setValue('castShadows', arg, function(newValue, oldValue) {
						this.light.castShadows = newValue;
				});
		}
		get castShadows() {
				return this.data.castShadows;
		}
		set shadowDistance(arg) {
				this._setValue('shadowDistance', arg, function(newValue, oldValue) {
						this.light.shadowDistance = newValue;
				});
		}
		get shadowDistance() {
				return this.data.shadowDistance;
		}
		set shadowIntensity(arg) {
				this._setValue('shadowIntensity', arg, function(newValue, oldValue) {
						this.light.shadowIntensity = newValue;
				});
		}
		get shadowIntensity() {
				return this.data.shadowIntensity;
		}
		set shadowResolution(arg) {
				this._setValue('shadowResolution', arg, function(newValue, oldValue) {
						this.light.shadowResolution = newValue;
				});
		}
		get shadowResolution() {
				return this.data.shadowResolution;
		}
		set shadowBias(arg) {
				this._setValue('shadowBias', arg, function(newValue, oldValue) {
						this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
				});
		}
		get shadowBias() {
				return this.data.shadowBias;
		}
		set numCascades(arg) {
				this._setValue('numCascades', arg, function(newValue, oldValue) {
						this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
				});
		}
		get numCascades() {
				return this.data.numCascades;
		}
		set cascadeBlend(value) {
				this._setValue('cascadeBlend', value, function(newValue, oldValue) {
						this.light.cascadeBlend = math.clamp(newValue, 0, 1);
				});
		}
		get cascadeBlend() {
				return this.data.cascadeBlend;
		}
		set bakeNumSamples(arg) {
				this._setValue('bakeNumSamples', arg, function(newValue, oldValue) {
						this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
				});
		}
		get bakeNumSamples() {
				return this.data.bakeNumSamples;
		}
		set bakeArea(arg) {
				this._setValue('bakeArea', arg, function(newValue, oldValue) {
						this.light.bakeArea = math.clamp(newValue, 0, 180);
				});
		}
		get bakeArea() {
				return this.data.bakeArea;
		}
		set cascadeDistribution(arg) {
				this._setValue('cascadeDistribution', arg, function(newValue, oldValue) {
						this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
				});
		}
		get cascadeDistribution() {
				return this.data.cascadeDistribution;
		}
		set normalOffsetBias(arg) {
				this._setValue('normalOffsetBias', arg, function(newValue, oldValue) {
						this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
				});
		}
		get normalOffsetBias() {
				return this.data.normalOffsetBias;
		}
		set range(arg) {
				this._setValue('range', arg, function(newValue, oldValue) {
						this.light.attenuationEnd = newValue;
				});
		}
		get range() {
				return this.data.range;
		}
		set innerConeAngle(arg) {
				this._setValue('innerConeAngle', arg, function(newValue, oldValue) {
						this.light.innerConeAngle = newValue;
				});
		}
		get innerConeAngle() {
				return this.data.innerConeAngle;
		}
		set outerConeAngle(arg) {
				this._setValue('outerConeAngle', arg, function(newValue, oldValue) {
						this.light.outerConeAngle = newValue;
				});
		}
		get outerConeAngle() {
				return this.data.outerConeAngle;
		}
		set falloffMode(arg) {
				this._setValue('falloffMode', arg, function(newValue, oldValue) {
						this.light.falloffMode = newValue;
				});
		}
		get falloffMode() {
				return this.data.falloffMode;
		}
		set shadowType(arg) {
				this._setValue('shadowType', arg, function(newValue, oldValue) {
						this.light.shadowType = newValue;
				});
		}
		get shadowType() {
				return this.data.shadowType;
		}
		set vsmBlurSize(arg) {
				this._setValue('vsmBlurSize', arg, function(newValue, oldValue) {
						this.light.vsmBlurSize = newValue;
				});
		}
		get vsmBlurSize() {
				return this.data.vsmBlurSize;
		}
		set vsmBlurMode(arg) {
				this._setValue('vsmBlurMode', arg, function(newValue, oldValue) {
						this.light.vsmBlurMode = newValue;
				});
		}
		get vsmBlurMode() {
				return this.data.vsmBlurMode;
		}
		set vsmBias(arg) {
				this._setValue('vsmBias', arg, function(newValue, oldValue) {
						this.light.vsmBias = math.clamp(newValue, 0, 1);
				});
		}
		get vsmBias() {
				return this.data.vsmBias;
		}
		set cookieAsset(arg) {
				this._setValue('cookieAsset', arg, function(newValue, oldValue) {
						if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {
								return;
						}
						this.onCookieAssetRemove();
						this._cookieAssetId = null;
						if (newValue instanceof Asset) {
								this.data.cookieAsset = newValue.id;
								this._cookieAssetId = newValue.id;
								this.onCookieAssetAdd(newValue);
						} else if (typeof newValue === 'number') {
								this._cookieAssetId = newValue;
								var asset = this.system.app.assets.get(newValue);
								if (asset) {
										this.onCookieAssetAdd(asset);
								} else {
										this._cookieAssetAdd = true;
										this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
								}
						}
				});
		}
		get cookieAsset() {
				return this.data.cookieAsset;
		}
		set cookie(arg) {
				this._setValue('cookie', arg, function(newValue, oldValue) {
						this.light.cookie = newValue;
				});
		}
		get cookie() {
				return this.data.cookie;
		}
		set cookieIntensity(arg) {
				this._setValue('cookieIntensity', arg, function(newValue, oldValue) {
						this.light.cookieIntensity = math.clamp(newValue, 0, 1);
				});
		}
		get cookieIntensity() {
				return this.data.cookieIntensity;
		}
		set cookieFalloff(arg) {
				this._setValue('cookieFalloff', arg, function(newValue, oldValue) {
						this.light.cookieFalloff = newValue;
				});
		}
		get cookieFalloff() {
				return this.data.cookieFalloff;
		}
		set cookieChannel(arg) {
				this._setValue('cookieChannel', arg, function(newValue, oldValue) {
						this.light.cookieChannel = newValue;
				});
		}
		get cookieChannel() {
				return this.data.cookieChannel;
		}
		set cookieAngle(arg) {
				this._setValue('cookieAngle', arg, function(newValue, oldValue) {
						if (newValue !== 0 || this.cookieScale !== null) {
								if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
								var scx = 1;
								var scy = 1;
								if (this.cookieScale) {
										scx = this.cookieScale.x;
										scy = this.cookieScale.y;
								}
								var c = Math.cos(newValue * math.DEG_TO_RAD);
								var s = Math.sin(newValue * math.DEG_TO_RAD);
								this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
								this.light.cookieTransform = this._cookieMatrix;
						} else {
								this.light.cookieTransform = null;
						}
				});
		}
		get cookieAngle() {
				return this.data.cookieAngle;
		}
		set cookieScale(arg) {
				this._setValue('cookieScale', arg, function(newValue, oldValue) {
						if (newValue !== null || this.cookieAngle !== 0) {
								if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
								var scx = newValue.x;
								var scy = newValue.y;
								var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
								var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
								this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
								this.light.cookieTransform = this._cookieMatrix;
						} else {
								this.light.cookieTransform = null;
						}
				}, true);
		}
		get cookieScale() {
				return this.data.cookieScale;
		}
		set cookieOffset(arg) {
				this._setValue('cookieOffset', arg, function(newValue, oldValue) {
						this.light.cookieOffset = newValue;
				}, true);
		}
		get cookieOffset() {
				return this.data.cookieOffset;
		}
		set shadowUpdateMode(arg) {
				this._setValue('shadowUpdateMode', arg, function(newValue, oldValue) {
						this.light.shadowUpdateMode = newValue;
				}, true);
		}
		get shadowUpdateMode() {
				return this.data.shadowUpdateMode;
		}
		set mask(arg) {
				this._setValue('mask', arg, function(newValue, oldValue) {
						this.light.mask = newValue;
				});
		}
		get mask() {
				return this.data.mask;
		}
		set affectDynamic(arg) {
				this._setValue('affectDynamic', arg, function(newValue, oldValue) {
						if (newValue) {
								this.light.mask |= MASK_AFFECT_DYNAMIC;
						} else {
								this.light.mask &= -2;
						}
						this.light.layersDirty();
				});
		}
		get affectDynamic() {
				return this.data.affectDynamic;
		}
		set affectLightmapped(arg) {
				this._setValue('affectLightmapped', arg, function(newValue, oldValue) {
						if (newValue) {
								this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
								if (this.bake) this.light.mask &= -5;
						} else {
								this.light.mask &= -3;
								if (this.bake) this.light.mask |= MASK_BAKE;
						}
				});
		}
		get affectLightmapped() {
				return this.data.affectLightmapped;
		}
		set bake(arg) {
				this._setValue('bake', arg, function(newValue, oldValue) {
						if (newValue) {
								this.light.mask |= MASK_BAKE;
								if (this.affectLightmapped) this.light.mask &= -3;
						} else {
								this.light.mask &= -5;
								if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
						}
						this.light.layersDirty();
				});
		}
		get bake() {
				return this.data.bake;
		}
		set bakeDir(arg) {
				this._setValue('bakeDir', arg, function(newValue, oldValue) {
						this.light.bakeDir = newValue;
				});
		}
		get bakeDir() {
				return this.data.bakeDir;
		}
		set isStatic(arg) {
				this._setValue('isStatic', arg, function(newValue, oldValue) {
						this.light.isStatic = newValue;
				});
		}
		get isStatic() {
				return this.data.isStatic;
		}
		set layers(arg) {
				this._setValue('layers', arg, function(newValue, oldValue) {
						for(var i = 0; i < oldValue.length; i++){
								var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
								if (!layer) continue;
								layer.removeLight(this);
								this.light.removeLayer(layer);
						}
						for(var i1 = 0; i1 < newValue.length; i1++){
								var layer1 = this.system.app.scene.layers.getLayerById(newValue[i1]);
								if (!layer1) continue;
								if (this.enabled && this.entity.enabled) {
										layer1.addLight(this);
										this.light.addLayer(layer1);
								}
						}
				});
		}
		get layers() {
				return this.data.layers;
		}
		set shadowUpdateOverrides(values) {
				this.light.shadowUpdateOverrides = values;
		}
		get shadowUpdateOverrides() {
				return this.light.shadowUpdateOverrides;
		}
		set shadowSamples(value) {
				this.light.shadowSamples = value;
		}
		get shadowSamples() {
				return this.light.shadowSamples;
		}
		set shadowBlockerSamples(value) {
				this.light.shadowBlockerSamples = value;
		}
		get shadowBlockerSamples() {
				return this.light.shadowBlockerSamples;
		}
		set penumbraSize(value) {
				this.light.penumbraSize = value;
		}
		get penumbraSize() {
				return this.light.penumbraSize;
		}
		set penumbraFalloff(value) {
				this.light.penumbraFalloff = value;
		}
		get penumbraFalloff() {
				return this.light.penumbraFalloff;
		}
		_setValue(name, value, setFunc, skipEqualsCheck) {
				var data = this.data;
				var oldValue = data[name];
				if (!skipEqualsCheck && oldValue === value) return;
				data[name] = value;
				if (setFunc) setFunc.call(this, value, oldValue);
		}
		addLightToLayers() {
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (layer) {
								layer.addLight(this);
								this.light.addLayer(layer);
						}
				}
		}
		removeLightFromLayers() {
				for(var i = 0; i < this.layers.length; i++){
						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
						if (layer) {
								layer.removeLight(this);
								this.light.removeLayer(layer);
						}
				}
		}
		onLayersChanged(oldComp, newComp) {
				if (this.enabled && this.entity.enabled) {
						this.addLightToLayers();
				}
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index >= 0 && this.enabled && this.entity.enabled) {
						layer.addLight(this);
						this.light.addLayer(layer);
				}
		}
		onLayerRemoved(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index >= 0) {
						layer.removeLight(this);
						this.light.removeLayer(layer);
				}
		}
		refreshProperties() {
				for(var i = 0; i < properties.length; i++){
						var name = properties[i];
						this[name] = this[name];
				}
				if (this.enabled && this.entity.enabled) {
						this.onEnable();
				}
		}
		onCookieAssetSet() {
				var forceLoad = false;
				if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
						this._cookieAsset.loadFaces = true;
						forceLoad = true;
				}
				if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
				if (this._cookieAsset.resource) {
						this.onCookieAssetLoad();
				}
		}
		onCookieAssetAdd(asset) {
				if (this._cookieAssetId !== asset.id) return;
				this._cookieAsset = asset;
				if (this.light.enabled) {
						this.onCookieAssetSet();
				}
				this._cookieAsset.on('load', this.onCookieAssetLoad, this);
				this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
		}
		onCookieAssetLoad() {
				if (!this._cookieAsset || !this._cookieAsset.resource) {
						return;
				}
				this.cookie = this._cookieAsset.resource;
		}
		onCookieAssetRemove() {
				if (!this._cookieAssetId) {
						return;
				}
				if (this._cookieAssetAdd) {
						this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
						this._cookieAssetAdd = false;
				}
				if (this._cookieAsset) {
						this._cookieAsset.off('load', this.onCookieAssetLoad, this);
						this._cookieAsset.off('remove', this.onCookieAssetRemove, this);
						this._cookieAsset = null;
				}
				this.cookie = null;
		}
		onEnable() {
				var scene = this.system.app.scene;
				var layers = scene.layers;
				this.light.enabled = true;
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				if (this.enabled && this.entity.enabled) {
						this.addLightToLayers();
				}
				if (this._cookieAsset && !this.cookie) {
						this.onCookieAssetSet();
				}
		}
		onDisable() {
				var _this__evtLayersChanged;
				var scene = this.system.app.scene;
				var layers = scene.layers;
				this.light.enabled = false;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				this.removeLightFromLayers();
		}
		onRemove() {
				this.onDisable();
				this.light.destroy();
				this.cookieAsset = null;
		}
		constructor(...args){
				super(...args), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._cookieAsset = null, this._cookieAssetId = null, this._cookieAssetAdd = false, this._cookieMatrix = null;
		}
}

function _extends$8() {
		_extends$8 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$8.apply(this, arguments);
}
class LightComponentSystem extends ComponentSystem {
		initializeComponentData(component, _data) {
				var data = _extends$8({}, _data);
				if (!data.type) {
						data.type = component.data.type;
				}
				component.data.type = data.type;
				if (data.layers && Array.isArray(data.layers)) {
						data.layers = data.layers.slice(0);
				}
				if (data.color && Array.isArray(data.color)) {
						data.color = new Color(data.color[0], data.color[1], data.color[2]);
				}
				if (data.cookieOffset && data.cookieOffset instanceof Array) {
						data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
				}
				if (data.cookieScale && data.cookieScale instanceof Array) {
						data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);
				}
				if (data.enable) {
						console.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');
						data.enabled = data.enable;
				}
				if (!data.shape) {
						data.shape = LIGHTSHAPE_PUNCTUAL;
				}
				var light = new Light(this.app.graphicsDevice, this.app.scene.clusteredLightingEnabled);
				light.type = lightTypes[data.type];
				light._node = component.entity;
				component.data.light = light;
				super.initializeComponentData(component, data, properties);
		}
		_onRemoveComponent(entity, component) {
				component.onRemove();
		}
		cloneComponent(entity, clone) {
				var light = entity.light;
				var data = [];
				var name;
				for(var i = 0; i < properties.length; i++){
						name = properties[i];
						if (name === 'light') {
								continue;
						}
						if (light[name] && light[name].clone) {
								data[name] = light[name].clone();
						} else {
								data[name] = light[name];
						}
				}
				return this.addComponent(clone, data);
		}
		changeType(component, oldValue, newValue) {
				if (oldValue !== newValue) {
						component.light.type = lightTypes[newValue];
				}
		}
		constructor(app){
				super(app);
				this.id = 'light';
				this.ComponentType = LightComponent;
				this.DataType = LightComponentData;
				this.on('beforeremove', this._onRemoveComponent, this);
		}
}

var components = [
		'x',
		'y',
		'z',
		'w'
];
var vecLookup = [
		undefined,
		undefined,
		Vec2,
		Vec3,
		Vec4
];
function rawToValue(app, args, value, old) {
		switch(args.type){
				case 'boolean':
						return !!value;
				case 'number':
						if (typeof value === 'number') {
								return value;
						} else if (typeof value === 'string') {
								var v = parseInt(value, 10);
								if (isNaN(v)) return null;
								return v;
						} else if (typeof value === 'boolean') {
								return 0 + value;
						}
						return null;
				case 'json':
						{
								var result = {};
								if (Array.isArray(args.schema)) {
										if (!value || typeof value !== 'object') {
												value = {};
										}
										for(var i = 0; i < args.schema.length; i++){
												var field = args.schema[i];
												if (!field.name) continue;
												if (field.array) {
														result[field.name] = [];
														var arr = Array.isArray(value[field.name]) ? value[field.name] : [];
														for(var j = 0; j < arr.length; j++){
																result[field.name].push(rawToValue(app, field, arr[j]));
														}
												} else {
														var val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
														result[field.name] = rawToValue(app, field, val);
												}
										}
								}
								return result;
						}
				case 'asset':
						if (value instanceof Asset) {
								return value;
						} else if (typeof value === 'number') {
								return app.assets.get(value) || null;
						} else if (typeof value === 'string') {
								return app.assets.get(parseInt(value, 10)) || null;
						}
						return null;
				case 'entity':
						if (value instanceof GraphNode) {
								return value;
						} else if (typeof value === 'string') {
								return app.getEntityFromIndex(value);
						}
						return null;
				case 'rgb':
				case 'rgba':
						if (value instanceof Color) {
								if (old instanceof Color) {
										old.copy(value);
										return old;
								}
								return value.clone();
						} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
								for(var i1 = 0; i1 < value.length; i1++){
										if (typeof value[i1] !== 'number') {
												return null;
										}
								}
								if (!old) old = new Color();
								old.r = value[0];
								old.g = value[1];
								old.b = value[2];
								old.a = value.length === 3 ? 1 : value[3];
								return old;
						} else if (typeof value === 'string' && /#(?:[0-9a-f]{2}){3,4}/i.test(value)) {
								if (!old) {
										old = new Color();
								}
								old.fromString(value);
								return old;
						}
						return null;
				case 'vec2':
				case 'vec3':
				case 'vec4':
						{
								var len = parseInt(args.type.slice(3), 10);
								var vecType = vecLookup[len];
								if (value instanceof vecType) {
										if (old instanceof vecType) {
												old.copy(value);
												return old;
										}
										return value.clone();
								} else if (value instanceof Array && value.length === len) {
										for(var i2 = 0; i2 < value.length; i2++){
												if (typeof value[i2] !== 'number') {
														return null;
												}
										}
										if (!old) old = new vecType();
										for(var i3 = 0; i3 < len; i3++){
												old[components[i3]] = value[i3];
										}
										return old;
								}
								return null;
						}
				case 'curve':
						if (value) {
								var curve;
								if (value instanceof Curve || value instanceof CurveSet) {
										curve = value.clone();
								} else {
										var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
										curve = new CurveType(value.keys);
										curve.type = value.type;
								}
								return curve;
						}
						break;
		}
		return value;
}
function attributeToValue(app, schema, value, current) {
		if (schema.array) {
				return value.map((item, index)=>rawToValue(app, schema, item, current ? current[index] : null));
		}
		return rawToValue(app, schema, value, current);
}
function assignAttributesToScript(app, attributeSchemaMap, data, script) {
		if (!data) return;
		for(var attributeName in attributeSchemaMap){
				var attributeSchema = attributeSchemaMap[attributeName];
				var dataToAssign = data[attributeName];
				if (dataToAssign === undefined) continue;
				script[attributeName] = attributeToValue(app, attributeSchema, dataToAssign, script[attributeName]);
		}
}
class ScriptAttributes {
		add(name, args) {
				if (this.index[name]) {
						return;
				} else if (ScriptAttributes.reservedNames.has(name)) {
						return;
				}
				this.index[name] = args;
				Object.defineProperty(this.scriptType.prototype, name, {
						get: function get() {
								return this.__attributes[name];
						},
						set: function set(raw) {
								var evt = 'attr';
								var evtName = "attr:" + name;
								var old = this.__attributes[name];
								var oldCopy = old;
								if (old && args.type !== 'json' && args.type !== 'entity' && old.clone) {
										if (this.hasEvent(evt) || this.hasEvent(evtName)) {
												oldCopy = old.clone();
										}
								}
								if (args.array) {
										this.__attributes[name] = [];
										if (raw) {
												for(var i = 0, len = raw.length; i < len; i++){
														this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
												}
										}
								} else {
										this.__attributes[name] = rawToValue(this.app, args, raw, old);
								}
								this.fire(evt, name, this.__attributes[name], oldCopy);
								this.fire(evtName, this.__attributes[name], oldCopy);
						}
				});
		}
		remove(name) {
				if (!this.index[name]) {
						return false;
				}
				delete this.index[name];
				delete this.scriptType.prototype[name];
				return true;
		}
		has(name) {
				return !!this.index[name];
		}
		get(name) {
				return this.index[name] || null;
		}
		constructor(scriptType){
				this.scriptType = scriptType;
				this.index = {};
		}
}
ScriptAttributes.assignAttributesToScript = assignAttributesToScript;
ScriptAttributes.attributeToValue = attributeToValue;
ScriptAttributes.reservedNames = new Set([
		'app',
		'entity',
		'enabled',
		'_enabled',
		'_enabledOld',
		'_destroyed',
		'__attributes',
		'__attributesRaw',
		"__scriptType",
		'__executionOrder',
		'_callbacks',
		'_callbackActive',
		'has',
		'get',
		'on',
		'off',
		'fire',
		'once',
		'hasEvent'
]);

var SCRIPT_INITIALIZE = 'initialize';
var SCRIPT_POST_INITIALIZE = 'postInitialize';
var SCRIPT_UPDATE = 'update';
var SCRIPT_POST_UPDATE = 'postUpdate';
var SCRIPT_SWAP = 'swap';

class Script extends EventHandler {
		set enabled(value) {
				this._enabled = !!value;
				if (this.enabled === this._enabledOld) return;
				this._enabledOld = this.enabled;
				this.fire(this.enabled ? 'enable' : 'disable');
				this.fire('state', this.enabled);
				if (!this._initialized && this.enabled) {
						this._initialized = true;
						this.fire('preInitialize');
						if (this.initialize) {
								this.entity.script._scriptMethod(this, SCRIPT_INITIALIZE);
						}
				}
				if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
						this._postInitialized = true;
						if (this.postInitialize) {
								this.entity.script._scriptMethod(this, SCRIPT_POST_INITIALIZE);
						}
				}
		}
		get enabled() {
				return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
		}
		initScript(args) {
				var script = this.constructor;
				this.app = args.app;
				this.entity = args.entity;
				this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
				this._enabledOld = this.enabled;
				this.__destroyed = false;
				this.__scriptType = script;
				this.__executionOrder = -1;
		}
		static get scriptName() {
				return this.__name;
		}
		constructor(args){
				super();
				this.initScript(args);
		}
}
Script.EVENT_ENABLE = 'enable';
Script.EVENT_DISABLE = 'disable';
Script.EVENT_STATE = 'state';
Script.EVENT_DESTROY = 'destroy';
Script.EVENT_ATTR = 'attr';
Script.EVENT_ERROR = 'error';
Script.__name = null;
Script.__getScriptName = getScriptName;
var funcNameRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s\/]*)\s*/;
function getScriptName(constructorFn) {
		if (typeof constructorFn !== 'function') return undefined;
		if ('name' in Function.prototype) return constructorFn.name;
		if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
		var match = ("" + constructorFn).match(funcNameRegex);
		return match ? match[1] : undefined;
}

class ScriptType extends Script {
		static get attributes() {
				if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
				return this.__attributes;
		}
		initScript(args) {
				Script.prototype.initScript.call(this, args);
				this.__attributes = {};
				this.__attributesRaw = args.attributes || {};
		}
		initScriptType(args) {
				this.initScript(args);
		}
		__initializeAttributes(force) {
				if (!force && !this.__attributesRaw) {
						return;
				}
				for(var key in this.__scriptType.attributes.index){
						if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
								this[key] = this.__attributesRaw[key];
						} else if (!this.__attributes.hasOwnProperty(key)) {
								if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
										this[key] = this.__scriptType.attributes.index[key].default;
								} else {
										this[key] = null;
								}
						}
				}
				this.__attributesRaw = null;
		}
		static extend(methods) {
				for(var key in methods){
						if (!methods.hasOwnProperty(key)) {
								continue;
						}
						this.prototype[key] = methods[key];
				}
		}
		constructor(args){
				super(args);
				this.initScriptType(args);
		}
}

var toLowerCamelCase$1 = (str)=>str[0].toLowerCase() + str.substring(1);
class ScriptComponent extends Component {
		set scripts(value) {
				var _this, _loop = function(key) {
						if (!value.hasOwnProperty(key)) {
								return "continue";
						}
						var script = _this._scriptsIndex[key];
						if (script) {
								if (typeof value[key].enabled === 'boolean') {
										script.once('preInitialize', ()=>{
												_this.initializeAttributes(script);
										});
										script.enabled = !!value[key].enabled;
								}
								if (typeof value[key].attributes === 'object') {
										for(var attr in value[key].attributes){
												if (ScriptAttributes.reservedNames.has(attr)) {
														continue;
												}
												if (!script.__attributes.hasOwnProperty(attr)) {
														var scriptType = _this.system.app.scripts.get(key);
														if (scriptType) {
																scriptType.attributes.add(attr, {});
														}
												}
												script[attr] = value[key].attributes[attr];
										}
								}
						} else {
								console.log(_this.order);
						}
				};
				this._scriptsData = value;
				for(var key in value)_this = this, _loop(key);
		}
		get scripts() {
				return this._scripts;
		}
		set enabled(value) {
				var oldValue = this._enabled;
				this._enabled = value;
				this.fire('set', 'enabled', oldValue, value);
		}
		get enabled() {
				return this._enabled;
		}
		onEnable() {
				this._beingEnabled = true;
				this._checkState();
				if (!this.entity._beingEnabled) {
						this.onPostStateChange();
				}
				this._beingEnabled = false;
		}
		onDisable() {
				this._checkState();
		}
		onPostStateChange() {
				var wasLooping = this._beginLooping();
				for(var i = 0, len = this.scripts.length; i < len; i++){
						var script = this.scripts[i];
						if (script._initialized && !script._postInitialized && script.enabled) {
								script._postInitialized = true;
								if (script.postInitialize) {
										this._scriptMethod(script, SCRIPT_POST_INITIALIZE);
								}
						}
				}
				this._endLooping(wasLooping);
		}
		_beginLooping() {
				var looping = this._isLoopingThroughScripts;
				this._isLoopingThroughScripts = true;
				return looping;
		}
		_endLooping(wasLoopingBefore) {
				this._isLoopingThroughScripts = wasLoopingBefore;
				if (!this._isLoopingThroughScripts) {
						this._removeDestroyedScripts();
				}
		}
		_onSetEnabled(prop, old, value) {
				this._beingEnabled = true;
				this._checkState();
				this._beingEnabled = false;
		}
		_checkState() {
				var _this, _loop = function(i, len) {
						var script = _this.scripts[i];
						script.once('preInitialize', ()=>{
								_this.initializeAttributes(script);
						});
						script.enabled = script._enabled;
				};
				var state = this.enabled && this.entity.enabled;
				if (state === this._oldState) {
						return;
				}
				this._oldState = state;
				this.fire(state ? 'enable' : 'disable');
				this.fire('state', state);
				if (state) {
						this.system._addComponentToEnabled(this);
				} else {
						this.system._removeComponentFromEnabled(this);
				}
				var wasLooping = this._beginLooping();
				for(var i = 0, len = this.scripts.length; i < len; i++)_this = this, _loop(i);
				this._endLooping(wasLooping);
		}
		_onBeforeRemove() {
				this.fire('remove');
				var wasLooping = this._beginLooping();
				for(var i = 0; i < this.scripts.length; i++){
						var script = this.scripts[i];
						if (!script) continue;
						this.destroy(script.__scriptType.__name);
				}
				this._endLooping(wasLooping);
		}
		_removeDestroyedScripts() {
				var len = this._destroyedScripts.length;
				if (!len) return;
				for(var i = 0; i < len; i++){
						var script = this._destroyedScripts[i];
						this._removeScriptInstance(script);
				}
				this._destroyedScripts.length = 0;
				this._resetExecutionOrder(0, this._scripts.length);
		}
		_onInitializeAttributes() {
				for(var i = 0, len = this.scripts.length; i < len; i++){
						var script = this.scripts[i];
						this.initializeAttributes(script);
				}
		}
		initializeAttributes(script) {
				if (script instanceof ScriptType) {
						script.__initializeAttributes();
				} else {
						var _this_system_app_scripts;
						var name = script.__scriptType.__name;
						var data = this._attributeDataMap.get(name);
						if (!data) {
								return;
						}
						var schema = (_this_system_app_scripts = this.system.app.scripts) == null ? void 0 : _this_system_app_scripts.getSchema(name);
						assignAttributesToScript(this.system.app, schema.attributes, data, script);
				}
		}
		_scriptMethod(script, method, arg) {
				script[method](arg);
		}
		_onInitialize() {
				var scripts = this._scripts;
				var wasLooping = this._beginLooping();
				for(var i = 0, len = scripts.length; i < len; i++){
						var script = scripts[i];
						if (!script._initialized && script.enabled) {
								script._initialized = true;
								if (script.initialize) {
										this._scriptMethod(script, SCRIPT_INITIALIZE);
								}
						}
				}
				this._endLooping(wasLooping);
		}
		_onPostInitialize() {
				this.onPostStateChange();
		}
		_onUpdate(dt) {
				var list = this._updateList;
				if (!list.length) return;
				var wasLooping = this._beginLooping();
				for(list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++){
						var script = list.items[list.loopIndex];
						if (script.enabled) {
								this._scriptMethod(script, SCRIPT_UPDATE, dt);
						}
				}
				this._endLooping(wasLooping);
		}
		_onPostUpdate(dt) {
				var list = this._postUpdateList;
				if (!list.length) return;
				var wasLooping = this._beginLooping();
				for(list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++){
						var script = list.items[list.loopIndex];
						if (script.enabled) {
								this._scriptMethod(script, SCRIPT_POST_UPDATE, dt);
						}
				}
				this._endLooping(wasLooping);
		}
		_insertScriptInstance(scriptInstance, index, scriptsLength) {
				if (index === -1) {
						this._scripts.push(scriptInstance);
						scriptInstance.__executionOrder = scriptsLength;
						if (scriptInstance.update) {
								this._updateList.append(scriptInstance);
						}
						if (scriptInstance.postUpdate) {
								this._postUpdateList.append(scriptInstance);
						}
				} else {
						this._scripts.splice(index, 0, scriptInstance);
						scriptInstance.__executionOrder = index;
						this._resetExecutionOrder(index + 1, scriptsLength + 1);
						if (scriptInstance.update) {
								this._updateList.insert(scriptInstance);
						}
						if (scriptInstance.postUpdate) {
								this._postUpdateList.insert(scriptInstance);
						}
				}
		}
		_removeScriptInstance(scriptInstance) {
				var idx = this._scripts.indexOf(scriptInstance);
				if (idx === -1) return idx;
				this._scripts.splice(idx, 1);
				if (scriptInstance.update) {
						this._updateList.remove(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
						this._postUpdateList.remove(scriptInstance);
				}
				return idx;
		}
		_resetExecutionOrder(startIndex, scriptsLength) {
				for(var i = startIndex; i < scriptsLength; i++){
						this._scripts[i].__executionOrder = i;
				}
		}
		_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
				if (attribute.array) {
						var len = oldValue.length;
						if (!len) {
								return;
						}
						var newGuidArray = oldValue.slice();
						for(var i = 0; i < len; i++){
								var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
								if (duplicatedIdsMap[guid]) {
										newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
								}
						}
						newAttributes[attributeName] = newGuidArray;
				} else {
						if (oldValue instanceof Entity) {
								oldValue = oldValue.getGuid();
						} else if (typeof oldValue !== 'string') {
								return;
						}
						if (duplicatedIdsMap[oldValue]) {
								newAttributes[attributeName] = duplicatedIdsMap[oldValue];
						}
				}
		}
		has(nameOrType) {
				if (typeof nameOrType === 'string') {
						return !!this._scriptsIndex[nameOrType];
				}
				if (!nameOrType) return false;
				var scriptType = nameOrType;
				var scriptName = scriptType.__name;
				var scriptData = this._scriptsIndex[scriptName];
				var scriptInstance = scriptData && scriptData.instance;
				return scriptInstance instanceof scriptType;
		}
		get(nameOrType) {
				if (typeof nameOrType === 'string') {
						var data = this._scriptsIndex[nameOrType];
						return data ? data.instance : null;
				}
				if (!nameOrType) return null;
				var scriptType = nameOrType;
				var scriptName = scriptType.__name;
				var scriptData = this._scriptsIndex[scriptName];
				var scriptInstance = scriptData && scriptData.instance;
				return scriptInstance instanceof scriptType ? scriptInstance : null;
		}
		create(nameOrType, args) {
				if (args === void 0) args = {};
				var self = this;
				var scriptType = nameOrType;
				var scriptName = nameOrType;
				if (typeof scriptType === 'string') {
						scriptType = this.system.app.scripts.get(scriptType);
				} else if (scriptType) {
						var _scriptType;
						var ___name;
						scriptName = (___name = (_scriptType = scriptType).__name) != null ? ___name : _scriptType.__name = toLowerCamelCase$1(getScriptName(scriptType));
				}
				if (scriptType) {
						if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
								var scriptInstance = new scriptType({
										app: this.system.app,
										entity: this.entity,
										enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
										attributes: args.attributes || {}
								});
								if (args.properties && typeof args.properties === 'object') {
										Object.assign(scriptInstance, args.properties);
								}
								if (!(scriptInstance instanceof ScriptType)) {
										this._attributeDataMap.set(scriptName, args.attributes);
								}
								var len = this._scripts.length;
								var ind = -1;
								if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) {
										ind = args.ind;
								}
								this._insertScriptInstance(scriptInstance, ind, len);
								this._scriptsIndex[scriptName] = {
										instance: scriptInstance,
										onSwap: function onSwap() {
												self.swap(scriptName);
										}
								};
								this[scriptName] = scriptInstance;
								if (!args.preloading) {
										this.initializeAttributes(scriptInstance);
								}
								this.fire('create', scriptName, scriptInstance);
								this.fire("create:" + scriptName, scriptInstance);
								this.system.app.scripts.on("swap:" + scriptName, this._scriptsIndex[scriptName].onSwap);
								if (!args.preloading) {
										if (scriptInstance.enabled && !scriptInstance._initialized) {
												scriptInstance._initialized = true;
												if (scriptInstance.initialize) {
														this._scriptMethod(scriptInstance, SCRIPT_INITIALIZE);
												}
										}
										if (scriptInstance.enabled && !scriptInstance._postInitialized) {
												scriptInstance._postInitialized = true;
												if (scriptInstance.postInitialize) {
														this._scriptMethod(scriptInstance, SCRIPT_POST_INITIALIZE);
												}
										}
								}
								return scriptInstance;
						}
				} else {
						this._scriptsIndex[scriptName] = {
								awaiting: true,
								ind: this._scripts.length
						};
				}
				return null;
		}
		destroy(nameOrType) {
				var scriptName = nameOrType;
				var scriptType = nameOrType;
				if (typeof scriptType === 'string') {
						scriptType = this.system.app.scripts.get(scriptType);
				} else if (scriptType) {
						scriptName = scriptType.__name;
				}
				var scriptData = this._scriptsIndex[scriptName];
				delete this._scriptsIndex[scriptName];
				if (!scriptData) return false;
				this._attributeDataMap.delete(scriptName);
				var scriptInstance = scriptData.instance;
				if (scriptInstance && !scriptInstance._destroyed) {
						scriptInstance.enabled = false;
						scriptInstance._destroyed = true;
						if (!this._isLoopingThroughScripts) {
								var ind = this._removeScriptInstance(scriptInstance);
								if (ind >= 0) {
										this._resetExecutionOrder(ind, this._scripts.length);
								}
						} else {
								this._destroyedScripts.push(scriptInstance);
						}
				}
				this.system.app.scripts.off("swap:" + scriptName, scriptData.onSwap);
				delete this[scriptName];
				this.fire('destroy', scriptName, scriptInstance || null);
				this.fire("destroy:" + scriptName, scriptInstance || null);
				if (scriptInstance) {
						scriptInstance.fire('destroy');
				}
				return true;
		}
		swap(nameOrType) {
				var scriptName = nameOrType;
				var scriptType = nameOrType;
				if (typeof scriptType === 'string') {
						scriptType = this.system.app.scripts.get(scriptType);
				} else if (scriptType) {
						scriptName = scriptType.__name;
				}
				var old = this._scriptsIndex[scriptName];
				if (!old || !old.instance) return false;
				var scriptInstanceOld = old.instance;
				var ind = this._scripts.indexOf(scriptInstanceOld);
				var scriptInstance = new scriptType({
						app: this.system.app,
						entity: this.entity,
						enabled: scriptInstanceOld.enabled,
						attributes: scriptInstanceOld.__attributes
				});
				if (!scriptInstance.swap) {
						return false;
				}
				this.initializeAttributes(scriptInstance);
				this._scripts[ind] = scriptInstance;
				this._scriptsIndex[scriptName].instance = scriptInstance;
				this[scriptName] = scriptInstance;
				scriptInstance.__executionOrder = ind;
				if (scriptInstanceOld.update) {
						this._updateList.remove(scriptInstanceOld);
				}
				if (scriptInstanceOld.postUpdate) {
						this._postUpdateList.remove(scriptInstanceOld);
				}
				if (scriptInstance.update) {
						this._updateList.insert(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
						this._postUpdateList.insert(scriptInstance);
				}
				this._scriptMethod(scriptInstance, SCRIPT_SWAP, scriptInstanceOld);
				this.fire('swap', scriptName, scriptInstance);
				this.fire("swap:" + scriptName, scriptInstance);
				return true;
		}
		resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
				var newScriptComponent = this.entity.script;
				for(var scriptName in oldScriptComponent._scriptsIndex){
						var scriptType = this.system.app.scripts.get(scriptName);
						if (!scriptType) {
								continue;
						}
						var script = oldScriptComponent._scriptsIndex[scriptName];
						if (!script || !script.instance) {
								continue;
						}
						var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
						var newAttributes = newScriptComponent[scriptName].__attributes;
						if (!newAttributesRaw && !newAttributes) {
								continue;
						}
						var useGuid = !!newAttributesRaw;
						var oldAttributes = script.instance.__attributes;
						for(var attributeName in oldAttributes){
								if (!oldAttributes[attributeName]) {
										continue;
								}
								var attribute = scriptType.attributes.get(attributeName);
								if (!attribute) {
										continue;
								}
								if (attribute.type === 'entity') {
										this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
								} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
										var oldValue = oldAttributes[attributeName];
										var newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];
										for(var i = 0; i < attribute.schema.length; i++){
												var field = attribute.schema[i];
												if (field.type !== 'entity') {
														continue;
												}
												if (attribute.array) {
														for(var j = 0; j < oldValue.length; j++){
																this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
														}
												} else {
														this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
												}
										}
								}
						}
				}
		}
		move(nameOrType, ind) {
				var len = this._scripts.length;
				if (ind >= len || ind < 0) {
						return false;
				}
				var scriptType = nameOrType;
				var scriptName = nameOrType;
				if (typeof scriptName !== 'string') {
						scriptName = nameOrType.__name;
				} else {
						scriptType = null;
				}
				var scriptData = this._scriptsIndex[scriptName];
				if (!scriptData || !scriptData.instance) {
						return false;
				}
				var scriptInstance = scriptData.instance;
				if (scriptType && !(scriptInstance instanceof scriptType)) {
						return false;
				}
				var indOld = this._scripts.indexOf(scriptInstance);
				if (indOld === -1 || indOld === ind) {
						return false;
				}
				this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
				this._resetExecutionOrder(0, len);
				this._updateList.sort();
				this._postUpdateList.sort();
				this.fire('move', scriptName, scriptInstance, ind, indOld);
				this.fire("move:" + scriptName, scriptInstance, ind, indOld);
				return true;
		}
		constructor(system, entity){
				super(system, entity), this._attributeDataMap = new Map();
				this._scripts = [];
				this._updateList = new SortedLoopArray({
						sortBy: '__executionOrder'
				});
				this._postUpdateList = new SortedLoopArray({
						sortBy: '__executionOrder'
				});
				this._scriptsIndex = {};
				this._destroyedScripts = [];
				this._destroyed = false;
				this._scriptsData = null;
				this._oldState = true;
				this._enabled = true;
				this._beingEnabled = false;
				this._isLoopingThroughScripts = false;
				this._executionOrder = -1;
				this.on('set_enabled', this._onSetEnabled, this);
		}
}
ScriptComponent.EVENT_CREATE = 'create';
ScriptComponent.EVENT_DESTROY = 'destroy';
ScriptComponent.EVENT_ENABLE = 'enable';
ScriptComponent.EVENT_DISABLE = 'disable';
ScriptComponent.EVENT_REMOVE = 'remove';
ScriptComponent.EVENT_STATE = 'state';
ScriptComponent.EVENT_MOVE = 'move';
ScriptComponent.EVENT_ERROR = 'error';

class ScriptComponentData {
		constructor(){
				this.enabled = true;
		}
}

var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
var METHOD_INITIALIZE = '_onInitialize';
var METHOD_POST_INITIALIZE = '_onPostInitialize';
var METHOD_UPDATE = '_onUpdate';
var METHOD_POST_UPDATE = '_onPostUpdate';
var executionOrderCounter = 0;
class ScriptComponentSystem extends ComponentSystem {
		initializeComponentData(component, data) {
				component._executionOrder = executionOrderCounter++;
				this._components.append(component);
				if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
						this._resetExecutionOrder();
				}
				component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
				if (component.enabled && component.entity.enabled) {
						this._enabledComponents.append(component);
				}
				if (data.hasOwnProperty('order') && data.hasOwnProperty("scripts")) {
						component._scriptsData = data.scripts;
						for(var i = 0; i < data.order.length; i++){
								component.create(data.order[i], {
										enabled: data.scripts[data.order[i]].enabled,
										attributes: data.scripts[data.order[i]].attributes,
										preloading: this.preloading
								});
						}
				}
		}
		cloneComponent(entity, clone) {
				var order = [];
				var scripts = {};
				for(var i = 0; i < entity.script._scripts.length; i++){
						var _entity_script__attributeDataMap;
						var scriptInstance = entity.script._scripts[i];
						var scriptName = scriptInstance.__scriptType.__name;
						order.push(scriptName);
						var attributes = ((_entity_script__attributeDataMap = entity.script._attributeDataMap) == null ? void 0 : _entity_script__attributeDataMap.get(scriptName)) || {};
						for(var key in scriptInstance.__attributes){
								attributes[key] = scriptInstance.__attributes[key];
						}
						scripts[scriptName] = {
								enabled: scriptInstance._enabled,
								attributes: attributes
						};
				}
				for(var key1 in entity.script._scriptsIndex){
						if (key1.awaiting) {
								order.splice(key1.ind, 0, key1);
						}
				}
				var data = {
						enabled: entity.script.enabled,
						order: order,
						scripts: scripts
				};
				return this.addComponent(clone, data);
		}
		_resetExecutionOrder() {
				executionOrderCounter = 0;
				for(var i = 0, len = this._components.length; i < len; i++){
						this._components.items[i]._executionOrder = executionOrderCounter++;
				}
		}
		_callComponentMethod(components, name, dt) {
				for(components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++){
						components.items[components.loopIndex][name](dt);
				}
		}
		_onInitialize() {
				this.preloading = false;
				this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
				this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
		}
		_onPostInitialize() {
				this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
		}
		_onUpdate(dt) {
				this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
		}
		_onPostUpdate(dt) {
				this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
		}
		_addComponentToEnabled(component) {
				this._enabledComponents.insert(component);
		}
		_removeComponentFromEnabled(component) {
				this._enabledComponents.remove(component);
		}
		_onBeforeRemove(entity, component) {
				var ind = this._components.items.indexOf(component);
				if (ind >= 0) {
						component._onBeforeRemove();
				}
				this._removeComponentFromEnabled(component);
				this._components.remove(component);
		}
		destroy() {
				super.destroy();
				this.app.systems.off('initialize', this._onInitialize, this);
				this.app.systems.off('postInitialize', this._onPostInitialize, this);
				this.app.systems.off('update', this._onUpdate, this);
				this.app.systems.off('postUpdate', this._onPostUpdate, this);
		}
		constructor(app){
				super(app);
				this.id = "script";
				this.ComponentType = ScriptComponent;
				this.DataType = ScriptComponentData;
				this._components = new SortedLoopArray({
						sortBy: '_executionOrder'
				});
				this._enabledComponents = new SortedLoopArray({
						sortBy: '_executionOrder'
				});
				this.preloading = true;
				this.on('beforeremove', this._onBeforeRemove, this);
				this.app.systems.on('initialize', this._onInitialize, this);
				this.app.systems.on('postInitialize', this._onPostInitialize, this);
				this.app.systems.on('update', this._onUpdate, this);
				this.app.systems.on('postUpdate', this._onPostUpdate, this);
		}
}

class GSplatComponent extends Component {
		set customAabb(value) {
				var _this__instance_meshInstance, _this__instance;
				this._customAabb = value;
				(_this__instance = this._instance) == null ? void 0 : (_this__instance_meshInstance = _this__instance.meshInstance) == null ? void 0 : _this__instance_meshInstance.setCustomAabb(this._customAabb);
		}
		get customAabb() {
				return this._customAabb;
		}
		set instance(value) {
				var _this__instance;
				this.destroyInstance();
				this._instance = value;
				if ((_this__instance = this._instance) == null ? void 0 : _this__instance.meshInstance) {
						var mi = this._instance.meshInstance;
						if (!mi.node) {
								mi.node = this.entity;
						}
						mi.castShadow = this._castShadows;
						mi.setCustomAabb(this._customAabb);
						if (this._materialOptions) {
								this._instance.createMaterial(this._materialOptions);
						}
						if (this.enabled && this.entity.enabled) {
								this.addToLayers();
						}
				}
		}
		get instance() {
				return this._instance;
		}
		set materialOptions(value) {
				this._materialOptions = Object.assign({}, value);
				if (this._instance) {
						this._instance.createMaterial(this._materialOptions);
				}
		}
		get materialOptions() {
				return this._materialOptions;
		}
		get material() {
				var _this__instance;
				return (_this__instance = this._instance) == null ? void 0 : _this__instance.material;
		}
		set castShadows(value) {
				if (this._castShadows !== value) {
						var _this_instance;
						var mi = (_this_instance = this.instance) == null ? void 0 : _this_instance.meshInstance;
						if (mi) {
								var layers = this.layers;
								var scene = this.system.app.scene;
								if (this._castShadows && !value) {
										for(var i = 0; i < layers.length; i++){
												var layer = scene.layers.getLayerById(this.layers[i]);
												if (layer) {
														layer.removeShadowCasters([
																mi
														]);
												}
										}
								}
								mi.castShadow = value;
								if (!this._castShadows && value) {
										for(var i1 = 0; i1 < layers.length; i1++){
												var layer1 = scene.layers.getLayerById(layers[i1]);
												if (layer1) {
														layer1.addShadowCasters([
																mi
														]);
												}
										}
								}
						}
						this._castShadows = value;
				}
		}
		get castShadows() {
				return this._castShadows;
		}
		set layers(value) {
				this.removeFromLayers();
				this._layers.length = 0;
				for(var i = 0; i < value.length; i++){
						this._layers[i] = value[i];
				}
				if (!this.enabled || !this.entity.enabled) {
						return;
				}
				this.addToLayers();
		}
		get layers() {
				return this._layers;
		}
		set asset(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._assetReference.id === id) return;
				if (this._assetReference.asset && this._assetReference.asset.resource) {
						this._onGSplatAssetRemove();
				}
				this._assetReference.id = id;
				if (this._assetReference.asset) {
						this._onGSplatAssetAdded();
				}
		}
		get asset() {
				return this._assetReference.id;
		}
		assignAsset(asset) {
				var id = asset instanceof Asset ? asset.id : asset;
				this._assetReference.id = id;
		}
		destroyInstance() {
				if (this._instance) {
						var _this__instance;
						this.removeFromLayers();
						(_this__instance = this._instance) == null ? void 0 : _this__instance.destroy();
						this._instance = null;
				}
		}
		addToLayers() {
				var _this_instance;
				var meshInstance = (_this_instance = this.instance) == null ? void 0 : _this_instance.meshInstance;
				if (meshInstance) {
						var layers = this.system.app.scene.layers;
						for(var i = 0; i < this._layers.length; i++){
								var _layers_getLayerById;
								(_layers_getLayerById = layers.getLayerById(this._layers[i])) == null ? void 0 : _layers_getLayerById.addMeshInstances([
										meshInstance
								]);
						}
				}
		}
		removeFromLayers() {
				var _this_instance;
				var meshInstance = (_this_instance = this.instance) == null ? void 0 : _this_instance.meshInstance;
				if (meshInstance) {
						var layers = this.system.app.scene.layers;
						for(var i = 0; i < this._layers.length; i++){
								var _layers_getLayerById;
								(_layers_getLayerById = layers.getLayerById(this._layers[i])) == null ? void 0 : _layers_getLayerById.removeMeshInstances([
										meshInstance
								]);
						}
				}
		}
		onRemoveChild() {
				this.removeFromLayers();
		}
		onInsertChild() {
				if (this._instance && this.enabled && this.entity.enabled) {
						this.addToLayers();
				}
		}
		onRemove() {
				this.destroyInstance();
				this.asset = null;
				this._assetReference.id = null;
				this.entity.off('remove', this.onRemoveChild, this);
				this.entity.off('insert', this.onInsertChild, this);
		}
		onLayersChanged(oldComp, newComp) {
				this.addToLayers();
				oldComp.off('add', this.onLayerAdded, this);
				oldComp.off('remove', this.onLayerRemoved, this);
				newComp.on('add', this.onLayerAdded, this);
				newComp.on('remove', this.onLayerRemoved, this);
		}
		onLayerAdded(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				if (this._instance) {
						layer.addMeshInstances(this._instance.meshInstance);
				}
		}
		onLayerRemoved(layer) {
				var index = this.layers.indexOf(layer.id);
				if (index < 0) return;
				if (this._instance) {
						layer.removeMeshInstances(this._instance.meshInstance);
				}
		}
		onEnable() {
				var scene = this.system.app.scene;
				var layers = scene.layers;
				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
				if (layers) {
						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
				}
				if (this._instance) {
						this.addToLayers();
				} else if (this.asset) {
						this._onGSplatAssetAdded();
				}
		}
		onDisable() {
				var _this__evtLayersChanged;
				var scene = this.system.app.scene;
				var layers = scene.layers;
				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
				this._evtLayersChanged = null;
				if (layers) {
						var _this__evtLayerAdded, _this__evtLayerRemoved;
						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
						this._evtLayerAdded = null;
						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
						this._evtLayerRemoved = null;
				}
				this.removeFromLayers();
		}
		hide() {
				if (this._instance) {
						this._instance.meshInstance.visible = false;
				}
		}
		show() {
				if (this._instance) {
						this._instance.meshInstance.visible = true;
				}
		}
		_onGSplatAssetAdded() {
				if (!this._assetReference.asset) {
						return;
				}
				if (this._assetReference.asset.resource) {
						this._onGSplatAssetLoad();
				} else if (this.enabled && this.entity.enabled) {
						this.system.app.assets.load(this._assetReference.asset);
				}
		}
		_onGSplatAssetLoad() {
				this.destroyInstance();
				var asset = this._assetReference.asset;
				if (asset) {
						this.instance = asset.resource.createInstance();
				}
		}
		_onGSplatAssetUnload() {
				this.destroyInstance();
		}
		_onGSplatAssetRemove() {
				this._onGSplatAssetUnload();
		}
		constructor(system, entity){
				super(system, entity), this._layers = [
						LAYERID_WORLD
				], this._instance = null, this._customAabb = null, this._materialOptions = null, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._castShadows = false;
				this._assetReference = new AssetReference('asset', this, system.app.assets, {
						add: this._onGSplatAssetAdded,
						load: this._onGSplatAssetLoad,
						remove: this._onGSplatAssetRemove,
						unload: this._onGSplatAssetUnload
				}, this);
				entity.on('remove', this.onRemoveChild, this);
				entity.on('removehierarchy', this.onRemoveChild, this);
				entity.on('insert', this.onInsertChild, this);
				entity.on('inserthierarchy', this.onInsertChild, this);
		}
}

class GSplatComponentData {
		constructor(){
				this.enabled = true;
		}
}

var _schema = [
		'enabled'
];
var _properties = [
		'castShadows',
		'instance',
		'asset',
		'layers'
];
class GSplatComponentSystem extends ComponentSystem {
		initializeComponentData(component, _data, properties) {
				if (_data.layers && _data.layers.length) {
						_data.layers = _data.layers.slice(0);
				}
				for(var i = 0; i < _properties.length; i++){
						if (_data.hasOwnProperty(_properties[i])) {
								component[_properties[i]] = _data[_properties[i]];
						}
				}
				if (_data.aabbCenter && _data.aabbHalfExtents) {
						component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
				}
				super.initializeComponentData(component, _data, _schema);
		}
		cloneComponent(entity, clone) {
				var gSplatComponent = entity.gsplat;
				var data = {};
				for(var i = 0; i < _properties.length; i++){
						data[_properties[i]] = gSplatComponent[_properties[i]];
				}
				data.enabled = gSplatComponent.enabled;
				delete data.instance;
				var component = this.addComponent(clone, data);
				if (gSplatComponent.instance) {
						component.instance = gSplatComponent.instance.clone();
				}
				if (gSplatComponent.customAabb) {
						component.customAabb = gSplatComponent.customAabb.clone();
				}
				return component;
		}
		onRemove(entity, component) {
				component.onRemove();
		}
		constructor(app){
				super(app);
				this.id = 'gsplat';
				this.ComponentType = GSplatComponent;
				this.DataType = GSplatComponentData;
				this.schema = _schema;
				this.on('beforeremove', this.onRemove, this);
		}
}
Component._buildAccessors(GSplatComponent.prototype, _schema);

class Render extends EventHandler {
		set meshes(value) {
				this.decRefMeshes();
				this._meshes = value;
				this.incRefMeshes();
				this.fire('set:meshes', value);
		}
		get meshes() {
				return this._meshes;
		}
		destroy() {
				this.meshes = null;
		}
		decRefMeshes() {
				var _this__meshes;
				(_this__meshes = this._meshes) == null ? void 0 : _this__meshes.forEach((mesh, index)=>{
						if (mesh) {
								mesh.decRefCount();
								if (mesh.refCount < 1) {
										mesh.destroy();
										this._meshes[index] = null;
								}
						}
				});
		}
		incRefMeshes() {
				var _this__meshes;
				(_this__meshes = this._meshes) == null ? void 0 : _this__meshes.forEach((mesh)=>{
						mesh == null ? void 0 : mesh.incRefCount();
				});
		}
		constructor(...args){
				super(...args), this._meshes = null;
		}
}
Render.EVENT_SETMESHES = 'set:meshes';

function onContainerAssetLoaded(containerAsset) {
		var renderAsset = this;
		if (!renderAsset.resource) return;
		var containerResource = containerAsset.resource;
		var render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];
		if (render) {
				renderAsset.resource.meshes = render.resource.meshes;
		}
}
function onContainerAssetAdded(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.on("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.off("remove:" + containerAsset.id, onContainerAssetRemoved, renderAsset);
		renderAsset.registry.once("remove:" + containerAsset.id, onContainerAssetRemoved, renderAsset);
		if (!containerAsset.resource) {
				renderAsset.registry.load(containerAsset);
		} else {
				onContainerAssetLoaded.call(renderAsset, containerAsset);
		}
}
function onContainerAssetRemoved(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
		if (renderAsset.resource) {
				renderAsset.resource.destroy();
		}
}
class RenderHandler extends ResourceHandler {
		open(url, data) {
				return new Render();
		}
		patch(asset, registry) {
				if (!asset.data.containerAsset) {
						return;
				}
				var containerAsset = registry.get(asset.data.containerAsset);
				if (!containerAsset) {
						registry.once("add:" + asset.data.containerAsset, onContainerAssetAdded, asset);
						return;
				}
				onContainerAssetAdded.call(asset, containerAsset);
		}
		constructor(app){
				super(app, 'render');
				this._registry = app.assets;
		}
}

class AnimCurve {
		get paths() {
				return this._paths;
		}
		get input() {
				return this._input;
		}
		get output() {
				return this._output;
		}
		get interpolation() {
				return this._interpolation;
		}
		constructor(paths, input, output, interpolation){
				this._paths = paths;
				this._input = input;
				this._output = output;
				this._interpolation = interpolation;
		}
}

class AnimData {
		get components() {
				return this._components;
		}
		get data() {
				return this._data;
		}
		constructor(components, data){
				this._components = components;
				this._data = data;
		}
}

function DracoWorker(jsUrl, wasmUrl) {
		var draco;
		var POSITION_ATTRIBUTE = 0;
		var NORMAL_ATTRIBUTE = 1;
		var wrap = (typedArray, dataType)=>{
				switch(dataType){
						case draco.DT_INT8:
								return new Int8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
						case draco.DT_INT16:
								return new Int16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
						case draco.DT_INT32:
								return new Int32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
						case draco.DT_UINT8:
								return new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
						case draco.DT_UINT16:
								return new Uint16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
						case draco.DT_UINT32:
								return new Uint32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
						case draco.DT_FLOAT32:
								return new Float32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
				}
				return null;
		};
		var componentSizeInBytes = (dataType)=>{
				switch(dataType){
						case draco.DT_INT8:
								return 1;
						case draco.DT_INT16:
								return 2;
						case draco.DT_INT32:
								return 4;
						case draco.DT_UINT8:
								return 1;
						case draco.DT_UINT16:
								return 2;
						case draco.DT_UINT32:
								return 4;
						case draco.DT_FLOAT32:
								return 4;
				}
				return 1;
		};
		var attributeSizeInBytes = (attribute)=>{
				return attribute.num_components() * componentSizeInBytes(attribute.data_type());
		};
		var attributeOrder = {
				0: 0,
				1: 1,
				5: 2,
				2: 3,
				7: 4,
				8: 5,
				4: 6,
				3: 7
		};
		var generateNormals = (vertices, indices)=>{
				var subtract = (dst, a, b)=>{
						dst[0] = a[0] - b[0];
						dst[1] = a[1] - b[1];
						dst[2] = a[2] - b[2];
				};
				var cross = (dst, a, b)=>{
						dst[0] = a[1] * b[2] - b[1] * a[2];
						dst[1] = a[2] * b[0] - b[2] * a[0];
						dst[2] = a[0] * b[1] - b[0] * a[1];
				};
				var normalize = (dst, offset)=>{
						var a = dst[offset + 0];
						var b = dst[offset + 1];
						var c = dst[offset + 2];
						var l = 1.0 / Math.sqrt(a * a + b * b + c * c);
						dst[offset + 0] *= l;
						dst[offset + 1] *= l;
						dst[offset + 2] *= l;
				};
				var copy = (dst, src, srcOffset)=>{
						for(var i = 0; i < 3; ++i){
								dst[i] = src[srcOffset + i];
						}
				};
				var numTriangles = indices.length / 3;
				var numVertices = vertices.length / 3;
				var result = new Float32Array(vertices.length);
				var a = [
						0,
						0,
						0
				], b = [
						0,
						0,
						0
				], c = [
						0,
						0,
						0
				], t1 = [
						0,
						0,
						0
				], t2 = [
						0,
						0,
						0
				], n = [
						0,
						0,
						0
				];
				for(var i = 0; i < numTriangles; ++i){
						var v0 = indices[i * 3 + 0] * 3;
						var v1 = indices[i * 3 + 1] * 3;
						var v2 = indices[i * 3 + 2] * 3;
						copy(a, vertices, v0);
						copy(b, vertices, v1);
						copy(c, vertices, v2);
						subtract(t1, b, a);
						subtract(t2, c, a);
						cross(n, t1, t2);
						normalize(n, 0);
						for(var j = 0; j < 3; ++j){
								result[v0 + j] += n[j];
								result[v1 + j] += n[j];
								result[v2 + j] += n[j];
						}
				}
				for(var i1 = 0; i1 < numVertices; ++i1){
						normalize(result, i1 * 3);
				}
				return new Uint8Array(result.buffer);
		};
		var decodeMesh = (inputBuffer)=>{
				var result = {};
				var buffer = new draco.DecoderBuffer();
				buffer.Init(inputBuffer, inputBuffer.length);
				var decoder = new draco.Decoder();
				if (decoder.GetEncodedGeometryType(buffer) !== draco.TRIANGULAR_MESH) {
						result.error = 'Failed to decode draco mesh: not a mesh';
						return result;
				}
				var mesh = new draco.Mesh();
				var status = decoder.DecodeBufferToMesh(buffer, mesh);
				if (!status || !status.ok() || draco.getPointer(mesh) === 0) {
						result.error = 'Failed to decode draco asset';
						return result;
				}
				var numIndices = mesh.num_faces() * 3;
				var shortIndices = mesh.num_points() <= 65535;
				var indicesSize = numIndices * (shortIndices ? 2 : 4);
				var indicesPtr = draco._malloc(indicesSize);
				if (shortIndices) {
						decoder.GetTrianglesUInt16Array(mesh, indicesSize, indicesPtr);
						result.indices = new Uint16Array(draco.HEAPU16.buffer, indicesPtr, numIndices).slice().buffer;
				} else {
						decoder.GetTrianglesUInt32Array(mesh, indicesSize, indicesPtr);
						result.indices = new Uint32Array(draco.HEAPU32.buffer, indicesPtr, numIndices).slice().buffer;
				}
				draco._free(indicesPtr);
				var attributes = [];
				for(var i = 0; i < mesh.num_attributes(); ++i){
						attributes.push(decoder.GetAttribute(mesh, i));
				}
				attributes.sort((a, b)=>{
						var _attributeOrder_a_attribute_type, _attributeOrder_b_attribute_type;
						return ((_attributeOrder_a_attribute_type = attributeOrder[a.attribute_type()]) != null ? _attributeOrder_a_attribute_type : attributeOrder.length) - ((_attributeOrder_b_attribute_type = attributeOrder[b.attribute_type()]) != null ? _attributeOrder_b_attribute_type : attributeOrder.length);
				});
				result.attributes = attributes.map((a)=>a.unique_id());
				var totalVertexSize = 0;
				var offsets = attributes.map((a)=>{
						var offset = totalVertexSize;
						totalVertexSize += Math.ceil(attributeSizeInBytes(a) / 4) * 4;
						return offset;
				});
				var hasNormals = attributes.some((a)=>a.attribute_type() === NORMAL_ATTRIBUTE);
				var normalOffset = offsets[1];
				if (!hasNormals) {
						for(var i1 = 1; i1 < offsets.length; ++i1){
								offsets[i1] += 12;
						}
						totalVertexSize += 12;
				}
				result.vertices = new ArrayBuffer(mesh.num_points() * totalVertexSize);
				var dst = new Uint8Array(result.vertices);
				for(var i2 = 0; i2 < mesh.num_attributes(); ++i2){
						var attribute = attributes[i2];
						var sizeInBytes = attributeSizeInBytes(attribute);
						var ptrSize = mesh.num_points() * sizeInBytes;
						var ptr = draco._malloc(ptrSize);
						decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, attribute.data_type(), ptrSize, ptr);
						var src = new Uint8Array(draco.HEAPU8.buffer, ptr, ptrSize);
						for(var j = 0; j < mesh.num_points(); ++j){
								for(var c = 0; c < sizeInBytes; ++c){
										dst[j * totalVertexSize + offsets[i2] + c] = src[j * sizeInBytes + c];
								}
						}
						if (!hasNormals && attribute.attribute_type() === POSITION_ATTRIBUTE) {
								var normals = generateNormals(wrap(src, attribute.data_type()), shortIndices ? new Uint16Array(result.indices) : new Uint32Array(result.indices));
								for(var j1 = 0; j1 < mesh.num_points(); ++j1){
										for(var c1 = 0; c1 < 12; ++c1){
												dst[j1 * totalVertexSize + normalOffset + c1] = normals[j1 * 12 + c1];
										}
								}
						}
						draco._free(ptr);
				}
				draco.destroy(mesh);
				draco.destroy(decoder);
				draco.destroy(buffer);
				return result;
		};
		var decode = (data)=>{
				var result = decodeMesh(new Uint8Array(data.buffer));
				self.postMessage({
						jobId: data.jobId,
						error: result.error,
						indices: result.indices,
						vertices: result.vertices,
						attributes: result.attributes
				}, [
						result.indices,
						result.vertices
				].filter((t)=>t != null));
		};
		var workQueue = [];
		self.onmessage = (message)=>{
				var data = message.data;
				switch(data.type){
						case 'init':
								self.DracoDecoderModule({
										instantiateWasm: (imports, successCallback)=>{
												WebAssembly.instantiate(data.module, imports).then((result)=>successCallback(result)).catch((reason)=>console.error("instantiate failed + " + reason));
												return {};
										}
								}).then((instance)=>{
										draco = instance;
										workQueue.forEach((data)=>decode(data));
								});
								break;
						case 'decodeMesh':
								if (draco) {
										decode(data);
								} else {
										workQueue.push(data);
								}
								break;
				}
		};
}

var downloadMaxRetries = 3;
class JobQueue {
		init(workers) {
				workers.forEach((worker)=>{
						worker.addEventListener('message', (message)=>{
								var data = message.data;
								var callback = this.jobCallbacks.get(data.jobId);
								if (callback) {
										callback(data.error, {
												indices: data.indices,
												vertices: data.vertices,
												attributes: data.attributes
										});
								}
								this.jobCallbacks.delete(data.jobId);
								if (this.jobQueue.length > 0) {
										var job = this.jobQueue.shift();
										this.run(worker, job);
								} else {
										var index2 = this.workers[2].indexOf(worker);
										if (index2 !== -1) {
												this.workers[2].splice(index2, 1);
												this.workers[1].push(worker);
										} else {
												var index1 = this.workers[1].indexOf(worker);
												if (index1 !== -1) {
														this.workers[1].splice(index1, 1);
														this.workers[0].push(worker);
												}
										}
								}
						});
				});
				this.workers[0] = workers;
				while(this.jobQueue.length && (this.workers[0].length || this.workers[1].length)){
						var job = this.jobQueue.shift();
						if (this.workers[0].length > 0) {
								var worker = this.workers[0].shift();
								this.workers[1].push(worker);
								this.run(worker, job);
						} else {
								var worker1 = this.workers[1].shift();
								this.workers[2].push(worker1);
								this.run(worker1, job);
						}
				}
		}
		enqueueJob(buffer, callback) {
				var job = {
						jobId: this.jobId++,
						buffer: buffer
				};
				this.jobCallbacks.set(job.jobId, callback);
				if (this.workers[0].length > 0) {
						var worker = this.workers[0].shift();
						this.workers[1].push(worker);
						this.run(worker, job);
				} else if (this.workers[1].length > 0) {
						var worker1 = this.workers[1].shift();
						this.workers[2].push(worker1);
						this.run(worker1, job);
				} else {
						this.jobQueue.push(job);
				}
		}
		constructor(){
				this.workers = [
						[],
						[],
						[]
				];
				this.jobId = 0;
				this.jobQueue = [];
				this.jobCallbacks = new Map();
				this.run = (worker, job)=>{
						worker.postMessage({
								type: 'decodeMesh',
								jobId: job.jobId,
								buffer: job.buffer
						}, [
								job.buffer
						]);
				};
		}
}
var downloadScript = (url)=>{
		return new Promise((resolve, reject)=>{
				var options = {
						cache: true,
						responseType: 'text',
						retry: downloadMaxRetries > 0,
						maxRetries: downloadMaxRetries
				};
				http.get(url, options, (err, response)=>{
						if (err) {
								reject(err);
						} else {
								resolve(response);
						}
				});
		});
};
var compileModule = (url)=>{
		var compileManual = ()=>{
				return fetch(url).then((result)=>result.arrayBuffer()).then((buffer)=>WebAssembly.compile(buffer));
		};
		var compileStreaming = ()=>{
				return WebAssembly.compileStreaming(fetch(url)).catch((err)=>{
						return compileManual();
				});
		};
		return WebAssembly.compileStreaming ? compileStreaming() : compileManual();
};
var defaultNumWorkers$1 = 1;
var jobQueue;
var lazyConfig$1;
var initializeWorkers = (config)=>{
		if (jobQueue) {
				return true;
		}
		if (!config) {
				if (lazyConfig$1) {
						config = lazyConfig$1;
				} else {
						var moduleConfig = WasmModule.getConfig('DracoDecoderModule');
						if (moduleConfig) {
								config = {
										jsUrl: moduleConfig.glueUrl,
										wasmUrl: moduleConfig.wasmUrl,
										numWorkers: moduleConfig.numWorkers
								};
						} else {
								config = {
										jsUrl: 'draco.wasm.js',
										wasmUrl: 'draco.wasm.wasm',
										numWorkers: defaultNumWorkers$1
								};
						}
				}
		}
		if (!config.jsUrl || !config.wasmUrl) {
				return false;
		}
		jobQueue = new JobQueue();
		Promise.all([
				downloadScript(config.jsUrl),
				compileModule(config.wasmUrl)
		]).then((param)=>{
				var [dracoSource, dracoModule] = param;
				var code = [
						'/* draco */',
						dracoSource,
						'/* worker */',
						"(\n" + DracoWorker.toString() + "\n)()\n\n"
				].join('\n');
				var blob = new Blob([
						code
				], {
						type: "application/javascript"
				});
				var workerUrl = URL.createObjectURL(blob);
				var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers$1));
				var workers = [];
				for(var i = 0; i < numWorkers; ++i){
						var worker = new Worker(workerUrl);
						worker.postMessage({
								type: 'init',
								module: dracoModule
						});
						workers.push(worker);
				}
				jobQueue.init(workers);
		});
		return true;
};
var dracoInitialize = (config)=>{
		if (config == null ? void 0 : config.lazyInit) {
				lazyConfig$1 = config;
		} else {
				initializeWorkers(config);
		}
};
var dracoDecode = (buffer, callback)=>{
		if (!initializeWorkers()) {
				return false;
		}
		jobQueue.enqueueJob(buffer, callback);
		return true;
};

function asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, key, arg) {
		try {
				var info = gen[key](arg);
				var value = info.value;
		} catch (error) {
				reject(error);
				return;
		}
		if (info.done) {
				resolve(value);
		} else {
				Promise.resolve(value).then(_next, _throw);
		}
}
function _async_to_generator$2(fn) {
		return function() {
				var self = this, args = arguments;
				return new Promise(function(resolve, reject) {
						var gen = fn.apply(self, args);
						function _next(value) {
								asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "next", value);
						}
						function _throw(err) {
								asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "throw", err);
						}
						_next(undefined);
				});
		};
}
class GlbResources {
		destroy() {
				if (this.renders) {
						this.renders.forEach((render)=>{
								render.meshes = null;
						});
				}
		}
}
var isDataURI = (uri)=>{
		return /^data:[^\n\r,\u2028\u2029]*,.*$/i.test(uri);
};
var getDataURIMimeType = (uri)=>{
		return uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));
};
var getNumComponents = (accessorType)=>{
		switch(accessorType){
				case 'SCALAR':
						return 1;
				case 'VEC2':
						return 2;
				case 'VEC3':
						return 3;
				case 'VEC4':
						return 4;
				case 'MAT2':
						return 4;
				case 'MAT3':
						return 9;
				case 'MAT4':
						return 16;
				default:
						return 3;
		}
};
var getComponentType$1 = (componentType)=>{
		switch(componentType){
				case 5120:
						return TYPE_INT8;
				case 5121:
						return TYPE_UINT8;
				case 5122:
						return TYPE_INT16;
				case 5123:
						return TYPE_UINT16;
				case 5124:
						return TYPE_INT32;
				case 5125:
						return TYPE_UINT32;
				case 5126:
						return TYPE_FLOAT32;
				default:
						return 0;
		}
};
var getComponentSizeInBytes = (componentType)=>{
		switch(componentType){
				case 5120:
						return 1;
				case 5121:
						return 1;
				case 5122:
						return 2;
				case 5123:
						return 2;
				case 5124:
						return 4;
				case 5125:
						return 4;
				case 5126:
						return 4;
				default:
						return 0;
		}
};
var getComponentDataType = (componentType)=>{
		switch(componentType){
				case 5120:
						return Int8Array;
				case 5121:
						return Uint8Array;
				case 5122:
						return Int16Array;
				case 5123:
						return Uint16Array;
				case 5124:
						return Int32Array;
				case 5125:
						return Uint32Array;
				case 5126:
						return Float32Array;
				default:
						return null;
		}
};
var gltfToEngineSemanticMap = {
		'POSITION': SEMANTIC_POSITION,
		'NORMAL': SEMANTIC_NORMAL,
		'TANGENT': SEMANTIC_TANGENT,
		'COLOR_0': SEMANTIC_COLOR,
		'JOINTS_0': SEMANTIC_BLENDINDICES,
		'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
		'TEXCOORD_0': SEMANTIC_TEXCOORD0,
		'TEXCOORD_1': SEMANTIC_TEXCOORD1,
		'TEXCOORD_2': SEMANTIC_TEXCOORD2,
		'TEXCOORD_3': SEMANTIC_TEXCOORD3,
		'TEXCOORD_4': SEMANTIC_TEXCOORD4,
		'TEXCOORD_5': SEMANTIC_TEXCOORD5,
		'TEXCOORD_6': SEMANTIC_TEXCOORD6,
		'TEXCOORD_7': SEMANTIC_TEXCOORD7
};
var attributeOrder = {
		[SEMANTIC_POSITION]: 0,
		[SEMANTIC_NORMAL]: 1,
		[SEMANTIC_TANGENT]: 2,
		[SEMANTIC_COLOR]: 3,
		[SEMANTIC_BLENDINDICES]: 4,
		[SEMANTIC_BLENDWEIGHT]: 5,
		[SEMANTIC_TEXCOORD0]: 6,
		[SEMANTIC_TEXCOORD1]: 7,
		[SEMANTIC_TEXCOORD2]: 8,
		[SEMANTIC_TEXCOORD3]: 9,
		[SEMANTIC_TEXCOORD4]: 10,
		[SEMANTIC_TEXCOORD5]: 11,
		[SEMANTIC_TEXCOORD6]: 12,
		[SEMANTIC_TEXCOORD7]: 13
};
var getDequantizeFunc = (srcType)=>{
		switch(srcType){
				case TYPE_INT8:
						return (x)=>Math.max(x / 127.0, -1);
				case TYPE_UINT8:
						return (x)=>x / 255.0;
				case TYPE_INT16:
						return (x)=>Math.max(x / 32767.0, -1);
				case TYPE_UINT16:
						return (x)=>x / 65535.0;
				default:
						return (x)=>x;
		}
};
var dequantizeArray = (dstArray, srcArray, srcType)=>{
		var convFunc = getDequantizeFunc(srcType);
		var len = srcArray.length;
		for(var i = 0; i < len; ++i){
				dstArray[i] = convFunc(srcArray[i]);
		}
		return dstArray;
};
var getAccessorData = (gltfAccessor, bufferViews, flatten)=>{
		if (flatten === void 0) flatten = false;
		var numComponents = getNumComponents(gltfAccessor.type);
		var dataType = getComponentDataType(gltfAccessor.componentType);
		if (!dataType) {
				return null;
		}
		var result;
		if (gltfAccessor.sparse) {
				var sparse = gltfAccessor.sparse;
				var indicesAccessor = {
						count: sparse.count,
						type: 'SCALAR'
				};
				var indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
				var valuesAccessor = {
						count: sparse.count,
						type: gltfAccessor.type,
						componentType: gltfAccessor.componentType
				};
				var values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);
				if (gltfAccessor.hasOwnProperty('bufferView')) {
						var baseAccessor = {
								bufferView: gltfAccessor.bufferView,
								byteOffset: gltfAccessor.byteOffset,
								componentType: gltfAccessor.componentType,
								count: gltfAccessor.count,
								type: gltfAccessor.type
						};
						result = getAccessorData(baseAccessor, bufferViews, true).slice();
				} else {
						result = new dataType(gltfAccessor.count * numComponents);
				}
				for(var i = 0; i < sparse.count; ++i){
						var targetIndex = indices[i];
						for(var j = 0; j < numComponents; ++j){
								result[targetIndex * numComponents + j] = values[i * numComponents + j];
						}
				}
		} else {
				if (gltfAccessor.hasOwnProperty('bufferView')) {
						var bufferView = bufferViews[gltfAccessor.bufferView];
						if (flatten && bufferView.hasOwnProperty('byteStride')) {
								var bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
								var storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
								var tmpArray = new Uint8Array(storage);
								var dstOffset = 0;
								for(var i1 = 0; i1 < gltfAccessor.count; ++i1){
										var srcOffset = (gltfAccessor.byteOffset || 0) + i1 * bufferView.byteStride;
										for(var b = 0; b < bytesPerElement; ++b){
												tmpArray[dstOffset++] = bufferView[srcOffset++];
										}
								}
								result = new dataType(storage);
						} else {
								result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
						}
				} else {
						result = new dataType(gltfAccessor.count * numComponents);
				}
		}
		return result;
};
var getAccessorDataFloat32 = (gltfAccessor, bufferViews)=>{
		var data = getAccessorData(gltfAccessor, bufferViews, true);
		if (data instanceof Float32Array || !gltfAccessor.normalized) {
				return data;
		}
		var float32Data = new Float32Array(data.length);
		dequantizeArray(float32Data, data, getComponentType$1(gltfAccessor.componentType));
		return float32Data;
};
var getAccessorBoundingBox = (gltfAccessor)=>{
		var min = gltfAccessor.min;
		var max = gltfAccessor.max;
		if (!min || !max) {
				return null;
		}
		if (gltfAccessor.normalized) {
				var ctype = getComponentType$1(gltfAccessor.componentType);
				min = dequantizeArray([], min, ctype);
				max = dequantizeArray([], max, ctype);
		}
		return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
};
var getPrimitiveType = (primitive)=>{
		if (!primitive.hasOwnProperty('mode')) {
				return PRIMITIVE_TRIANGLES;
		}
		switch(primitive.mode){
				case 0:
						return PRIMITIVE_POINTS;
				case 1:
						return PRIMITIVE_LINES;
				case 2:
						return PRIMITIVE_LINELOOP;
				case 3:
						return PRIMITIVE_LINESTRIP;
				case 4:
						return PRIMITIVE_TRIANGLES;
				case 5:
						return PRIMITIVE_TRISTRIP;
				case 6:
						return PRIMITIVE_TRIFAN;
				default:
						return PRIMITIVE_TRIANGLES;
		}
};
var generateIndices = (numVertices)=>{
		var dummyIndices = new Uint16Array(numVertices);
		for(var i = 0; i < numVertices; i++){
				dummyIndices[i] = i;
		}
		return dummyIndices;
};
var generateNormals = (sourceDesc, indices)=>{
		var p = sourceDesc[SEMANTIC_POSITION];
		if (!p || p.components !== 3) {
				return;
		}
		var positions;
		if (p.size !== p.stride) {
				var srcStride = p.stride / typedArrayTypesByteSize[p.type];
				var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
				positions = new typedArrayTypes[p.type](p.count * 3);
				for(var i = 0; i < p.count; ++i){
						positions[i * 3 + 0] = src[i * srcStride + 0];
						positions[i * 3 + 1] = src[i * srcStride + 1];
						positions[i * 3 + 2] = src[i * srcStride + 2];
				}
		} else {
				positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
		}
		var numVertices = p.count;
		if (!indices) {
				indices = generateIndices(numVertices);
		}
		var normalsTemp = calculateNormals(positions, indices);
		var normals = new Float32Array(normalsTemp.length);
		normals.set(normalsTemp);
		sourceDesc[SEMANTIC_NORMAL] = {
				buffer: normals.buffer,
				size: 12,
				offset: 0,
				stride: 12,
				count: numVertices,
				components: 3,
				type: TYPE_FLOAT32
		};
};
var cloneTexture = (texture)=>{
		var shallowCopyLevels = (texture)=>{
				var result = [];
				for(var mip = 0; mip < texture._levels.length; ++mip){
						var level = [];
						if (texture.cubemap) {
								for(var face = 0; face < 6; ++face){
										level.push(texture._levels[mip][face]);
								}
						} else {
								level = texture._levels[mip];
						}
						result.push(level);
				}
				return result;
		};
		var result = new Texture(texture.device, texture);
		result._levels = shallowCopyLevels(texture);
		return result;
};
var cloneTextureAsset = (src)=>{
		var result = new Asset("" + src.name + "_clone", src.type, src.file, src.data, src.options);
		result.loaded = true;
		result.resource = cloneTexture(src.resource);
		src.registry.add(result);
		return result;
};
var createVertexBufferInternal = (device, sourceDesc)=>{
		var positionDesc = sourceDesc[SEMANTIC_POSITION];
		if (!positionDesc) {
				return null;
		}
		var numVertices = positionDesc.count;
		var vertexDesc = [];
		for(var semantic in sourceDesc){
				if (sourceDesc.hasOwnProperty(semantic)) {
						var element = {
								semantic: semantic,
								components: sourceDesc[semantic].components,
								type: sourceDesc[semantic].type,
								normalize: !!sourceDesc[semantic].normalize
						};
						if (!VertexFormat.isElementValid(device, element)) {
								element.components++;
						}
						vertexDesc.push(element);
				}
		}
		vertexDesc.sort((lhs, rhs)=>{
				return attributeOrder[lhs.semantic] - attributeOrder[rhs.semantic];
		});
		var i, j, k;
		var source, target, sourceOffset;
		var vertexFormat = new VertexFormat(device, vertexDesc);
		var isCorrectlyInterleaved = true;
		for(i = 0; i < vertexFormat.elements.length; ++i){
				target = vertexFormat.elements[i];
				source = sourceDesc[target.name];
				sourceOffset = source.offset - positionDesc.offset;
				if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
						isCorrectlyInterleaved = false;
						break;
				}
		}
		var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);
		var vertexData = vertexBuffer.lock();
		var targetArray = new Uint32Array(vertexData);
		var sourceArray;
		if (isCorrectlyInterleaved) {
				sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
				targetArray.set(sourceArray);
		} else {
				var targetStride, sourceStride;
				for(i = 0; i < vertexBuffer.format.elements.length; ++i){
						target = vertexBuffer.format.elements[i];
						targetStride = target.stride / 4;
						source = sourceDesc[target.name];
						sourceStride = source.stride / 4;
						sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
						var src = 0;
						var dst = target.offset / 4;
						var kend = Math.floor((source.size + 3) / 4);
						for(j = 0; j < numVertices; ++j){
								for(k = 0; k < kend; ++k){
										targetArray[dst + k] = sourceArray[src + k];
								}
								src += sourceStride;
								dst += targetStride;
						}
				}
		}
		vertexBuffer.unlock();
		return vertexBuffer;
};
var createVertexBuffer = (device, attributes, indices, accessors, bufferViews, vertexBufferDict)=>{
		var useAttributes = {};
		var attribIds = [];
		for(var attrib in attributes){
				if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
						useAttributes[attrib] = attributes[attrib];
						attribIds.push(attrib + ":" + attributes[attrib]);
				}
		}
		attribIds.sort();
		var vbKey = attribIds.join();
		var vb = vertexBufferDict[vbKey];
		if (!vb) {
				var sourceDesc = {};
				for(var attrib1 in useAttributes){
						var accessor = accessors[attributes[attrib1]];
						var accessorData = getAccessorData(accessor, bufferViews);
						var bufferView = bufferViews[accessor.bufferView];
						var semantic = gltfToEngineSemanticMap[attrib1];
						var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
						var stride = bufferView && bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
						sourceDesc[semantic] = {
								buffer: accessorData.buffer,
								size: size,
								offset: accessorData.byteOffset,
								stride: stride,
								count: accessor.count,
								components: getNumComponents(accessor.type),
								type: getComponentType$1(accessor.componentType),
								normalize: accessor.normalized
						};
				}
				if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
						generateNormals(sourceDesc, indices);
				}
				vb = createVertexBufferInternal(device, sourceDesc);
				vertexBufferDict[vbKey] = vb;
		}
		return vb;
};
var createSkin = (device, gltfSkin, accessors, bufferViews, nodes, glbSkins)=>{
		var i, j, bindMatrix;
		var joints = gltfSkin.joints;
		var numJoints = joints.length;
		var ibp = [];
		if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
				var inverseBindMatrices = gltfSkin.inverseBindMatrices;
				var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
				var ibmValues = [];
				for(i = 0; i < numJoints; i++){
						for(j = 0; j < 16; j++){
								ibmValues[j] = ibmData[i * 16 + j];
						}
						bindMatrix = new Mat4();
						bindMatrix.set(ibmValues);
						ibp.push(bindMatrix);
				}
		} else {
				for(i = 0; i < numJoints; i++){
						bindMatrix = new Mat4();
						ibp.push(bindMatrix);
				}
		}
		var boneNames = [];
		for(i = 0; i < numJoints; i++){
				boneNames[i] = nodes[joints[i]].name;
		}
		var key = boneNames.join('#');
		var skin = glbSkins.get(key);
		if (!skin) {
				skin = new Skin(device, ibp, boneNames);
				glbSkins.set(key, skin);
		}
		return skin;
};
var createDracoMesh = (device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises)=>{
		var _primitive_extensions;
		var result = new Mesh(device);
		result.aabb = getAccessorBoundingBox(accessors[primitive.attributes.POSITION]);
		var vertexDesc = [];
		for (var [name, index] of Object.entries(primitive.attributes)){
				var accessor = accessors[index];
				var semantic = gltfToEngineSemanticMap[name];
				var componentType = getComponentType$1(accessor.componentType);
				var _accessor_normalized;
				vertexDesc.push({
						semantic: semantic,
						components: getNumComponents(accessor.type),
						type: componentType,
						normalize: (_accessor_normalized = accessor.normalized) != null ? _accessor_normalized : semantic === SEMANTIC_COLOR && (componentType === TYPE_UINT8 || componentType === TYPE_UINT16)
				});
		}
		promises.push(new Promise((resolve, reject)=>{
				var dracoExt = primitive.extensions.KHR_draco_mesh_compression;
				dracoDecode(bufferViews[dracoExt.bufferView].slice().buffer, (err, decompressedData)=>{
						if (err) {
								console.log(err);
								reject(err);
						} else {
								var _primitive_attributes;
								var order = {};
								for (var [name, index] of Object.entries(dracoExt.attributes)){
										order[gltfToEngineSemanticMap[name]] = decompressedData.attributes.indexOf(index);
								}
								vertexDesc.sort((a, b)=>{
										return order[a.semantic] - order[b.semantic];
								});
								if (!((_primitive_attributes = primitive.attributes) == null ? void 0 : _primitive_attributes.NORMAL)) {
										vertexDesc.splice(1, 0, {
												semantic: 'NORMAL',
												components: 3,
												type: TYPE_FLOAT32
										});
								}
								var vertexFormat = new VertexFormat(device, vertexDesc);
								var numVertices = decompressedData.vertices.byteLength / vertexFormat.size;
								var indexFormat = numVertices <= 65535 ? INDEXFORMAT_UINT16 : INDEXFORMAT_UINT32;
								var numIndices = decompressedData.indices.byteLength / (numVertices <= 65535 ? 2 : 4);
								var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, {
										data: decompressedData.vertices
								});
								var indexBuffer = new IndexBuffer(device, indexFormat, numIndices, BUFFER_STATIC, decompressedData.indices);
								result.vertexBuffer = vertexBuffer;
								result.indexBuffer[0] = indexBuffer;
								result.primitive[0].type = getPrimitiveType(primitive);
								result.primitive[0].base = 0;
								result.primitive[0].count = indexBuffer ? numIndices : numVertices;
								result.primitive[0].indexed = !!indexBuffer;
								resolve();
						}
				});
		}));
		if (primitive == null ? void 0 : (_primitive_extensions = primitive.extensions) == null ? void 0 : _primitive_extensions.KHR_materials_variants) {
				var variants = primitive.extensions.KHR_materials_variants;
				var tempMapping = {};
				variants.mappings.forEach((mapping)=>{
						mapping.variants.forEach((variant)=>{
								tempMapping[variant] = mapping.material;
						});
				});
				meshVariants[result.id] = tempMapping;
		}
		meshDefaultMaterials[result.id] = primitive.material;
		return result;
};
var createMesh$1 = (device, gltfMesh, accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions, promises)=>{
		var meshes = [];
		gltfMesh.primitives.forEach((primitive)=>{
				var _primitive_extensions;
				if ((_primitive_extensions = primitive.extensions) == null ? void 0 : _primitive_extensions.KHR_draco_mesh_compression) {
						meshes.push(createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises));
				} else {
						var indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
						var vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, vertexBufferDict);
						var primitiveType = getPrimitiveType(primitive);
						var mesh = new Mesh(device);
						mesh.vertexBuffer = vertexBuffer;
						mesh.primitive[0].type = primitiveType;
						mesh.primitive[0].base = 0;
						mesh.primitive[0].indexed = indices !== null;
						if (indices !== null) {
								var indexFormat;
								if (indices instanceof Uint8Array) {
										indexFormat = INDEXFORMAT_UINT8;
								} else if (indices instanceof Uint16Array) {
										indexFormat = INDEXFORMAT_UINT16;
								} else {
										indexFormat = INDEXFORMAT_UINT32;
								}
								if (indexFormat === INDEXFORMAT_UINT8 && device.isWebGPU) {
										indexFormat = INDEXFORMAT_UINT16;
										indices = new Uint16Array(indices);
								}
								var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
								mesh.indexBuffer[0] = indexBuffer;
								mesh.primitive[0].count = indices.length;
						} else {
								mesh.primitive[0].count = vertexBuffer.numVertices;
						}
						if (primitive.hasOwnProperty('extensions') && primitive.extensions.hasOwnProperty('KHR_materials_variants')) {
								var variants = primitive.extensions.KHR_materials_variants;
								var tempMapping = {};
								variants.mappings.forEach((mapping)=>{
										mapping.variants.forEach((variant)=>{
												tempMapping[variant] = mapping.material;
										});
								});
								meshVariants[mesh.id] = tempMapping;
						}
						meshDefaultMaterials[mesh.id] = primitive.material;
						var accessor = accessors[primitive.attributes.POSITION];
						mesh.aabb = getAccessorBoundingBox(accessor);
						if (primitive.hasOwnProperty('targets')) {
								var targets = [];
								primitive.targets.forEach((target, index)=>{
										var options = {};
										if (target.hasOwnProperty('POSITION')) {
												accessor = accessors[target.POSITION];
												options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
												options.aabb = getAccessorBoundingBox(accessor);
										}
										if (target.hasOwnProperty('NORMAL')) {
												accessor = accessors[target.NORMAL];
												options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
										}
										if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
												options.name = gltfMesh.extras.targetNames[index];
										} else {
												options.name = index.toString(10);
										}
										if (gltfMesh.hasOwnProperty('weights')) {
												options.defaultWeight = gltfMesh.weights[index];
										}
										options.preserveData = assetOptions.morphPreserveData;
										targets.push(new MorphTarget(options));
								});
								mesh.morph = new Morph(targets, device, {
										preferHighPrecision: assetOptions.morphPreferHighPrecision
								});
						}
						meshes.push(mesh);
				}
		});
		return meshes;
};
var extractTextureTransform = (source, material, maps)=>{
		var _source_extensions;
		var map;
		var texCoord = source.texCoord;
		if (texCoord) {
				for(map = 0; map < maps.length; ++map){
						material["" + maps[map] + "MapUv"] = texCoord;
				}
		}
		var zeros = [
				0,
				0
		];
		var ones = [
				1,
				1
		];
		var textureTransform = (_source_extensions = source.extensions) == null ? void 0 : _source_extensions.KHR_texture_transform;
		if (textureTransform) {
				var offset = textureTransform.offset || zeros;
				var scale = textureTransform.scale || ones;
				var rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
				var tilingVec = new Vec2(scale[0], scale[1]);
				var offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);
				for(map = 0; map < maps.length; ++map){
						material["" + maps[map] + "MapTiling"] = tilingVec;
						material["" + maps[map] + "MapOffset"] = offsetVec;
						material["" + maps[map] + "MapRotation"] = rotation;
				}
		}
};
var extensionPbrSpecGlossiness = (data, material, textures)=>{
		var color, texture;
		if (data.hasOwnProperty('diffuseFactor')) {
				color = data.diffuseFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = color[3];
		} else {
				material.diffuse.set(1, 1, 1);
				material.opacity = 1;
		}
		if (data.hasOwnProperty('diffuseTexture')) {
				var diffuseTexture = data.diffuseTexture;
				texture = textures[diffuseTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(diffuseTexture, material, [
						'diffuse',
						'opacity'
				]);
		}
		material.useMetalness = false;
		if (data.hasOwnProperty('specularFactor')) {
				color = data.specularFactor;
				material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
				material.specular.set(1, 1, 1);
		}
		if (data.hasOwnProperty('glossinessFactor')) {
				material.gloss = data.glossinessFactor;
		} else {
				material.gloss = 1.0;
		}
		if (data.hasOwnProperty('specularGlossinessTexture')) {
				var specularGlossinessTexture = data.specularGlossinessTexture;
				material.specularEncoding = 'srgb';
				material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
				material.specularMapChannel = 'rgb';
				material.glossMapChannel = 'a';
				extractTextureTransform(specularGlossinessTexture, material, [
						'gloss',
						'metalness'
				]);
		}
};
var extensionClearCoat = (data, material, textures)=>{
		if (data.hasOwnProperty('clearcoatFactor')) {
				material.clearCoat = data.clearcoatFactor * 0.25;
		} else {
				material.clearCoat = 0;
		}
		if (data.hasOwnProperty('clearcoatTexture')) {
				var clearcoatTexture = data.clearcoatTexture;
				material.clearCoatMap = textures[clearcoatTexture.index];
				material.clearCoatMapChannel = 'r';
				extractTextureTransform(clearcoatTexture, material, [
						'clearCoat'
				]);
		}
		if (data.hasOwnProperty('clearcoatRoughnessFactor')) {
				material.clearCoatGloss = data.clearcoatRoughnessFactor;
		} else {
				material.clearCoatGloss = 0;
		}
		if (data.hasOwnProperty('clearcoatRoughnessTexture')) {
				var clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;
				material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
				material.clearCoatGlossMapChannel = 'g';
				extractTextureTransform(clearcoatRoughnessTexture, material, [
						'clearCoatGloss'
				]);
		}
		if (data.hasOwnProperty('clearcoatNormalTexture')) {
				var clearcoatNormalTexture = data.clearcoatNormalTexture;
				material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
				extractTextureTransform(clearcoatNormalTexture, material, [
						'clearCoatNormal'
				]);
				if (clearcoatNormalTexture.hasOwnProperty('scale')) {
						material.clearCoatBumpiness = clearcoatNormalTexture.scale;
				}
		}
		material.clearCoatGlossInvert = true;
};
var extensionUnlit = (data, material, textures)=>{
		material.useLighting = false;
		material.emissive.copy(material.diffuse);
		material.emissiveMap = material.diffuseMap;
		material.emissiveMapUv = material.diffuseMapUv;
		material.emissiveMapTiling.copy(material.diffuseMapTiling);
		material.emissiveMapOffset.copy(material.diffuseMapOffset);
		material.emissiveMapRotation = material.diffuseMapRotation;
		material.emissiveMapChannel = material.diffuseMapChannel;
		material.emissiveVertexColor = material.diffuseVertexColor;
		material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
		material.useLighting = false;
		material.useSkybox = false;
		material.diffuse.set(1, 1, 1);
		material.diffuseMap = null;
		material.diffuseVertexColor = false;
};
var extensionSpecular = (data, material, textures)=>{
		material.useMetalnessSpecularColor = true;
		if (data.hasOwnProperty('specularColorTexture')) {
				material.specularEncoding = 'srgb';
				material.specularMap = textures[data.specularColorTexture.index];
				material.specularMapChannel = 'rgb';
				extractTextureTransform(data.specularColorTexture, material, [
						'specular'
				]);
		}
		if (data.hasOwnProperty('specularColorFactor')) {
				var color = data.specularColorFactor;
				material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
				material.specular.set(1, 1, 1);
		}
		if (data.hasOwnProperty('specularFactor')) {
				material.specularityFactor = data.specularFactor;
		} else {
				material.specularityFactor = 1;
		}
		if (data.hasOwnProperty('specularTexture')) {
				material.specularityFactorMapChannel = 'a';
				material.specularityFactorMap = textures[data.specularTexture.index];
				extractTextureTransform(data.specularTexture, material, [
						'specularityFactor'
				]);
		}
};
var extensionIor = (data, material, textures)=>{
		if (data.hasOwnProperty('ior')) {
				material.refractionIndex = 1.0 / data.ior;
		}
};
var extensionDispersion = (data, material, textures)=>{
		if (data.hasOwnProperty('dispersion')) {
				material.dispersion = data.dispersion;
		}
};
var extensionTransmission = (data, material, textures)=>{
		material.blendType = BLEND_NORMAL;
		material.useDynamicRefraction = true;
		if (data.hasOwnProperty('transmissionFactor')) {
				material.refraction = data.transmissionFactor;
		}
		if (data.hasOwnProperty('transmissionTexture')) {
				material.refractionMapChannel = 'r';
				material.refractionMap = textures[data.transmissionTexture.index];
				extractTextureTransform(data.transmissionTexture, material, [
						'refraction'
				]);
		}
};
var extensionSheen = (data, material, textures)=>{
		material.useSheen = true;
		if (data.hasOwnProperty('sheenColorFactor')) {
				var color = data.sheenColorFactor;
				material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
				material.sheen.set(1, 1, 1);
		}
		if (data.hasOwnProperty('sheenColorTexture')) {
				material.sheenMap = textures[data.sheenColorTexture.index];
				material.sheenEncoding = 'srgb';
				extractTextureTransform(data.sheenColorTexture, material, [
						'sheen'
				]);
		}
		material.sheenGloss = data.hasOwnProperty('sheenRoughnessFactor') ? data.sheenRoughnessFactor : 0.0;
		if (data.hasOwnProperty('sheenRoughnessTexture')) {
				material.sheenGlossMap = textures[data.sheenRoughnessTexture.index];
				material.sheenGlossMapChannel = 'a';
				extractTextureTransform(data.sheenRoughnessTexture, material, [
						'sheenGloss'
				]);
		}
		material.sheenGlossInvert = true;
};
var extensionVolume = (data, material, textures)=>{
		material.blendType = BLEND_NORMAL;
		material.useDynamicRefraction = true;
		if (data.hasOwnProperty('thicknessFactor')) {
				material.thickness = data.thicknessFactor;
		}
		if (data.hasOwnProperty('thicknessTexture')) {
				material.thicknessMap = textures[data.thicknessTexture.index];
				material.thicknessMapChannel = 'g';
				extractTextureTransform(data.thicknessTexture, material, [
						'thickness'
				]);
		}
		if (data.hasOwnProperty('attenuationDistance')) {
				material.attenuationDistance = data.attenuationDistance;
		}
		if (data.hasOwnProperty('attenuationColor')) {
				var color = data.attenuationColor;
				material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		}
};
var extensionEmissiveStrength = (data, material, textures)=>{
		if (data.hasOwnProperty('emissiveStrength')) {
				material.emissiveIntensity = data.emissiveStrength;
		}
};
var extensionIridescence = (data, material, textures)=>{
		material.useIridescence = true;
		if (data.hasOwnProperty('iridescenceFactor')) {
				material.iridescence = data.iridescenceFactor;
		}
		if (data.hasOwnProperty('iridescenceTexture')) {
				material.iridescenceMapChannel = 'r';
				material.iridescenceMap = textures[data.iridescenceTexture.index];
				extractTextureTransform(data.iridescenceTexture, material, [
						'iridescence'
				]);
		}
		if (data.hasOwnProperty('iridescenceIor')) {
				material.iridescenceRefractionIndex = data.iridescenceIor;
		}
		if (data.hasOwnProperty('iridescenceThicknessMinimum')) {
				material.iridescenceThicknessMin = data.iridescenceThicknessMinimum;
		}
		if (data.hasOwnProperty('iridescenceThicknessMaximum')) {
				material.iridescenceThicknessMax = data.iridescenceThicknessMaximum;
		}
		if (data.hasOwnProperty('iridescenceThicknessTexture')) {
				material.iridescenceThicknessMapChannel = 'g';
				material.iridescenceThicknessMap = textures[data.iridescenceThicknessTexture.index];
				extractTextureTransform(data.iridescenceThicknessTexture, material, [
						'iridescenceThickness'
				]);
		}
};
var createMaterial = (gltfMaterial, textures)=>{
		var material = new StandardMaterial();
		if (gltfMaterial.hasOwnProperty('name')) {
				material.name = gltfMaterial.name;
		}
		material.occludeSpecular = SPECOCC_AO;
		material.diffuseVertexColor = true;
		material.specularTint = true;
		material.specularVertexColor = true;
		material.specular.set(1, 1, 1);
		material.gloss = 1;
		material.glossInvert = true;
		material.useMetalness = true;
		var color, texture;
		if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
				var pbrData = gltfMaterial.pbrMetallicRoughness;
				if (pbrData.hasOwnProperty('baseColorFactor')) {
						color = pbrData.baseColorFactor;
						material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
						material.opacity = color[3];
				}
				if (pbrData.hasOwnProperty('baseColorTexture')) {
						var baseColorTexture = pbrData.baseColorTexture;
						texture = textures[baseColorTexture.index];
						material.diffuseMap = texture;
						material.diffuseMapChannel = 'rgb';
						material.opacityMap = texture;
						material.opacityMapChannel = 'a';
						extractTextureTransform(baseColorTexture, material, [
								'diffuse',
								'opacity'
						]);
				}
				if (pbrData.hasOwnProperty('metallicFactor')) {
						material.metalness = pbrData.metallicFactor;
				}
				if (pbrData.hasOwnProperty('roughnessFactor')) {
						material.gloss = pbrData.roughnessFactor;
				}
				if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
						var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
						material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
						material.metalnessMapChannel = 'b';
						material.glossMapChannel = 'g';
						extractTextureTransform(metallicRoughnessTexture, material, [
								'gloss',
								'metalness'
						]);
				}
		}
		if (gltfMaterial.hasOwnProperty('normalTexture')) {
				var normalTexture = gltfMaterial.normalTexture;
				material.normalMap = textures[normalTexture.index];
				extractTextureTransform(normalTexture, material, [
						'normal'
				]);
				if (normalTexture.hasOwnProperty('scale')) {
						material.bumpiness = normalTexture.scale;
				}
		}
		if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
				var occlusionTexture = gltfMaterial.occlusionTexture;
				material.aoMap = textures[occlusionTexture.index];
				material.aoMapChannel = 'r';
				extractTextureTransform(occlusionTexture, material, [
						'ao'
				]);
		}
		if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
				color = gltfMaterial.emissiveFactor;
				material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		}
		if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
				var emissiveTexture = gltfMaterial.emissiveTexture;
				material.emissiveMap = textures[emissiveTexture.index];
				extractTextureTransform(emissiveTexture, material, [
						'emissive'
				]);
		}
		if (gltfMaterial.hasOwnProperty('alphaMode')) {
				switch(gltfMaterial.alphaMode){
						case 'MASK':
								material.blendType = BLEND_NONE;
								if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
										material.alphaTest = gltfMaterial.alphaCutoff;
								} else {
										material.alphaTest = 0.5;
								}
								break;
						case 'BLEND':
								material.blendType = BLEND_NORMAL;
								material.depthWrite = false;
								break;
						default:
						case 'OPAQUE':
								material.blendType = BLEND_NONE;
								break;
				}
		} else {
				material.blendType = BLEND_NONE;
		}
		if (gltfMaterial.hasOwnProperty('doubleSided')) {
				material.twoSidedLighting = gltfMaterial.doubleSided;
				material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
		} else {
				material.twoSidedLighting = false;
				material.cull = CULLFACE_BACK;
		}
		var extensions = {
				'KHR_materials_clearcoat': extensionClearCoat,
				'KHR_materials_emissive_strength': extensionEmissiveStrength,
				'KHR_materials_ior': extensionIor,
				'KHR_materials_dispersion': extensionDispersion,
				'KHR_materials_iridescence': extensionIridescence,
				'KHR_materials_pbrSpecularGlossiness': extensionPbrSpecGlossiness,
				'KHR_materials_sheen': extensionSheen,
				'KHR_materials_specular': extensionSpecular,
				'KHR_materials_transmission': extensionTransmission,
				'KHR_materials_unlit': extensionUnlit,
				'KHR_materials_volume': extensionVolume
		};
		if (gltfMaterial.hasOwnProperty('extensions')) {
				for(var key in gltfMaterial.extensions){
						var extensionFunc = extensions[key];
						if (extensionFunc !== undefined) {
								extensionFunc(gltfMaterial.extensions[key], material, textures);
						}
				}
		}
		material.update();
		return material;
};
var createAnimation = (gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes, gltfNodes)=>{
		var createAnimData = (gltfAccessor)=>{
				return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
		};
		var interpMap = {
				'STEP': INTERPOLATION_STEP,
				'LINEAR': INTERPOLATION_LINEAR,
				'CUBICSPLINE': INTERPOLATION_CUBIC
		};
		var inputMap = {};
		var outputMap = {};
		var curveMap = {};
		var outputCounter = 1;
		var i;
		for(i = 0; i < gltfAnimation.samplers.length; ++i){
				var sampler = gltfAnimation.samplers[i];
				if (!inputMap.hasOwnProperty(sampler.input)) {
						inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);
				}
				if (!outputMap.hasOwnProperty(sampler.output)) {
						outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);
				}
				var interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
				var curve = {
						paths: [],
						input: sampler.input,
						output: sampler.output,
						interpolation: interpolation
				};
				curveMap[i] = curve;
		}
		var quatArrays = [];
		var transformSchema = {
				'translation': 'localPosition',
				'rotation': 'localRotation',
				'scale': 'localScale'
		};
		var constructNodePath = (node)=>{
				var path = [];
				while(node){
						path.unshift(node.name);
						node = node.parent;
				}
				return path;
		};
		var createMorphTargetCurves = (curve, gltfNode, entityPath)=>{
				var out = outputMap[curve.output];
				if (!out) {
						return;
				}
				var targetNames;
				if (meshes && meshes[gltfNode.mesh]) {
						var mesh = meshes[gltfNode.mesh];
						if (mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames')) {
								targetNames = mesh.extras.targetNames;
						}
				}
				var outData = out.data;
				var morphTargetCount = outData.length / inputMap[curve.input].data.length;
				var keyframeCount = outData.length / morphTargetCount;
				var singleBufferSize = keyframeCount * 4;
				var buffer = new ArrayBuffer(singleBufferSize * morphTargetCount);
				for(var j = 0; j < morphTargetCount; j++){
						var morphTargetOutput = new Float32Array(buffer, singleBufferSize * j, keyframeCount);
						for(var k = 0; k < keyframeCount; k++){
								morphTargetOutput[k] = outData[k * morphTargetCount + j];
						}
						var output = new AnimData(1, morphTargetOutput);
						var weightName = (targetNames == null ? void 0 : targetNames[j]) ? "name." + targetNames[j] : j;
						outputMap[-outputCounter] = output;
						var morphCurve = {
								paths: [
										{
												entityPath: entityPath,
												component: 'graph',
												propertyPath: [
														"weight." + weightName
												]
										}
								],
								input: curve.input,
								output: -outputCounter,
								interpolation: curve.interpolation
						};
						outputCounter++;
						curveMap["morphCurve-" + i + "-" + j] = morphCurve;
				}
		};
		for(i = 0; i < gltfAnimation.channels.length; ++i){
				var channel = gltfAnimation.channels[i];
				var target = channel.target;
				var curve1 = curveMap[channel.sampler];
				var node = nodes[target.node];
				var gltfNode = gltfNodes[target.node];
				var entityPath = constructNodePath(node);
				if (target.path.startsWith('weights')) {
						createMorphTargetCurves(curve1, gltfNode, entityPath);
						curveMap[channel.sampler].morphCurve = true;
				} else {
						curve1.paths.push({
								entityPath: entityPath,
								component: 'graph',
								propertyPath: [
										transformSchema[target.path]
								]
						});
				}
		}
		var inputs = [];
		var outputs = [];
		var curves = [];
		for(var inputKey in inputMap){
				inputs.push(inputMap[inputKey]);
				inputMap[inputKey] = inputs.length - 1;
		}
		for(var outputKey in outputMap){
				outputs.push(outputMap[outputKey]);
				outputMap[outputKey] = outputs.length - 1;
		}
		for(var curveKey in curveMap){
				var curveData = curveMap[curveKey];
				if (curveData.morphCurve) {
						continue;
				}
				curves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));
				if (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== INTERPOLATION_CUBIC) {
						quatArrays.push(curves[curves.length - 1].output);
				}
		}
		quatArrays.sort();
		var prevIndex = null;
		var data;
		for(i = 0; i < quatArrays.length; ++i){
				var index = quatArrays[i];
				if (i === 0 || index !== prevIndex) {
						data = outputs[index];
						if (data.components === 4) {
								var d = data.data;
								var len = d.length - 4;
								for(var j = 0; j < len; j += 4){
										var dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];
										if (dp < 0) {
												d[j + 4] *= -1;
												d[j + 5] *= -1;
												d[j + 6] *= -1;
												d[j + 7] *= -1;
										}
								}
						}
						prevIndex = index;
				}
		}
		var duration = 0;
		for(i = 0; i < inputs.length; i++){
				data = inputs[i]._data;
				duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
		}
		return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : "animation_" + animationIndex, duration, inputs, outputs, curves);
};
var tempMat = new Mat4();
var tempVec = new Vec3();
var createNode = (gltfNode, nodeIndex, nodeInstancingMap)=>{
		var entity = new GraphNode();
		if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
				entity.name = gltfNode.name;
		} else {
				entity.name = "node_" + nodeIndex;
		}
		if (gltfNode.hasOwnProperty('matrix')) {
				tempMat.data.set(gltfNode.matrix);
				tempMat.getTranslation(tempVec);
				entity.setLocalPosition(tempVec);
				tempMat.getEulerAngles(tempVec);
				entity.setLocalEulerAngles(tempVec);
				tempMat.getScale(tempVec);
				entity.setLocalScale(tempVec);
		}
		if (gltfNode.hasOwnProperty('rotation')) {
				var r = gltfNode.rotation;
				entity.setLocalRotation(r[0], r[1], r[2], r[3]);
		}
		if (gltfNode.hasOwnProperty('translation')) {
				var t = gltfNode.translation;
				entity.setLocalPosition(t[0], t[1], t[2]);
		}
		if (gltfNode.hasOwnProperty('scale')) {
				var s = gltfNode.scale;
				entity.setLocalScale(s[0], s[1], s[2]);
		}
		if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.EXT_mesh_gpu_instancing) {
				nodeInstancingMap.set(gltfNode, {
						ext: gltfNode.extensions.EXT_mesh_gpu_instancing
				});
		}
		return entity;
};
var createCamera = (gltfCamera, node)=>{
		var projection = gltfCamera.type === 'orthographic' ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
		var gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
		var componentData = {
				enabled: false,
				projection: projection,
				nearClip: gltfProperties.znear,
				aspectRatioMode: ASPECT_AUTO
		};
		if (gltfProperties.zfar) {
				componentData.farClip = gltfProperties.zfar;
		}
		if (projection === PROJECTION_ORTHOGRAPHIC) {
				componentData.orthoHeight = 0.5 * gltfProperties.ymag;
				if (gltfProperties.ymag) {
						componentData.aspectRatioMode = ASPECT_MANUAL;
						componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
				}
		} else {
				componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;
				if (gltfProperties.aspectRatio) {
						componentData.aspectRatioMode = ASPECT_MANUAL;
						componentData.aspectRatio = gltfProperties.aspectRatio;
				}
		}
		var cameraEntity = new Entity(gltfCamera.name);
		cameraEntity.addComponent('camera', componentData);
		return cameraEntity;
};
var createLight = (gltfLight, node)=>{
		var lightProps = {
				enabled: false,
				type: gltfLight.type === 'point' ? 'omni' : gltfLight.type,
				color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
				range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
				falloffMode: LIGHTFALLOFF_INVERSESQUARED,
				intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
		};
		if (gltfLight.hasOwnProperty('spot')) {
				lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
				lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
		}
		if (gltfLight.hasOwnProperty('intensity')) {
				lightProps.luminance = gltfLight.intensity * Light.getLightUnitConversion(lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);
		}
		var lightEntity = new Entity(node.name);
		lightEntity.rotateLocal(90, 0, 0);
		lightEntity.addComponent('light', lightProps);
		return lightEntity;
};
var createSkins = (device, gltf, nodes, bufferViews)=>{
		if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
				return [];
		}
		var glbSkins = new Map();
		return gltf.skins.map((gltfSkin)=>{
				return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
		});
};
var createMeshes = (device, gltf, bufferViews, options)=>{
		var _gltf_meshes, _gltf_accessors, _gltf_bufferViews;
		var vertexBufferDict = {};
		var meshVariants = {};
		var meshDefaultMaterials = {};
		var promises = [];
		var valid = !options.skipMeshes && (gltf == null ? void 0 : (_gltf_meshes = gltf.meshes) == null ? void 0 : _gltf_meshes.length) && (gltf == null ? void 0 : (_gltf_accessors = gltf.accessors) == null ? void 0 : _gltf_accessors.length) && (gltf == null ? void 0 : (_gltf_bufferViews = gltf.bufferViews) == null ? void 0 : _gltf_bufferViews.length);
		var meshes = valid ? gltf.meshes.map((gltfMesh)=>{
				return createMesh$1(device, gltfMesh, gltf.accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, options, promises);
		}) : [];
		return {
				meshes,
				meshVariants,
				meshDefaultMaterials,
				promises
		};
};
var createMaterials = (gltf, textures, options)=>{
		var _options_material, _options_material1, _options_material2;
		if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
				return [];
		}
		var preprocess = options == null ? void 0 : (_options_material = options.material) == null ? void 0 : _options_material.preprocess;
		var _options_material_process;
		var process = (_options_material_process = options == null ? void 0 : (_options_material1 = options.material) == null ? void 0 : _options_material1.process) != null ? _options_material_process : createMaterial;
		var postprocess = options == null ? void 0 : (_options_material2 = options.material) == null ? void 0 : _options_material2.postprocess;
		return gltf.materials.map((gltfMaterial)=>{
				if (preprocess) {
						preprocess(gltfMaterial);
				}
				var material = process(gltfMaterial, textures);
				if (postprocess) {
						postprocess(gltfMaterial, material);
				}
				return material;
		});
};
var createVariants = (gltf)=>{
		if (!gltf.hasOwnProperty('extensions') || !gltf.extensions.hasOwnProperty('KHR_materials_variants')) {
				return null;
		}
		var data = gltf.extensions.KHR_materials_variants.variants;
		var variants = {};
		for(var i = 0; i < data.length; i++){
				variants[data[i].name] = i;
		}
		return variants;
};
var createAnimations = (gltf, nodes, bufferViews, options)=>{
		var _options_animation, _options_animation1;
		if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
				return [];
		}
		var preprocess = options == null ? void 0 : (_options_animation = options.animation) == null ? void 0 : _options_animation.preprocess;
		var postprocess = options == null ? void 0 : (_options_animation1 = options.animation) == null ? void 0 : _options_animation1.postprocess;
		return gltf.animations.map((gltfAnimation, index)=>{
				if (preprocess) {
						preprocess(gltfAnimation);
				}
				var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes, gltf.nodes);
				if (postprocess) {
						postprocess(gltfAnimation, animation);
				}
				return animation;
		});
};
var createInstancing = (device, gltf, nodeInstancingMap, bufferViews)=>{
		var accessors = gltf.accessors;
		nodeInstancingMap.forEach((data, entity)=>{
				var attributes = data.ext.attributes;
				var translations;
				if (attributes.hasOwnProperty('TRANSLATION')) {
						var accessor = accessors[attributes.TRANSLATION];
						translations = getAccessorDataFloat32(accessor, bufferViews);
				}
				var rotations;
				if (attributes.hasOwnProperty('ROTATION')) {
						var accessor1 = accessors[attributes.ROTATION];
						rotations = getAccessorDataFloat32(accessor1, bufferViews);
				}
				var scales;
				if (attributes.hasOwnProperty('SCALE')) {
						var accessor2 = accessors[attributes.SCALE];
						scales = getAccessorDataFloat32(accessor2, bufferViews);
				}
				var instanceCount = (translations ? translations.length / 3 : 0) || (rotations ? rotations.length / 4 : 0) || (scales ? scales.length / 3 : 0);
				if (instanceCount) {
						var matrices = new Float32Array(instanceCount * 16);
						var pos = new Vec3();
						var rot = new Quat();
						var scl = new Vec3(1, 1, 1);
						var matrix = new Mat4();
						var matrixIndex = 0;
						for(var i = 0; i < instanceCount; i++){
								var i3 = i * 3;
								if (translations) {
										pos.set(translations[i3], translations[i3 + 1], translations[i3 + 2]);
								}
								if (rotations) {
										var i4 = i * 4;
										rot.set(rotations[i4], rotations[i4 + 1], rotations[i4 + 2], rotations[i4 + 3]);
								}
								if (scales) {
										scl.set(scales[i3], scales[i3 + 1], scales[i3 + 2]);
								}
								matrix.setTRS(pos, rot, scl);
								for(var m = 0; m < 16; m++){
										matrices[matrixIndex++] = matrix.data[m];
								}
						}
						data.matrices = matrices;
				}
		});
};
var createNodes = (gltf, options, nodeInstancingMap)=>{
		var _options_node, _options_node1, _options_node2;
		if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
				return [];
		}
		var preprocess = options == null ? void 0 : (_options_node = options.node) == null ? void 0 : _options_node.preprocess;
		var _options_node_process;
		var process = (_options_node_process = options == null ? void 0 : (_options_node1 = options.node) == null ? void 0 : _options_node1.process) != null ? _options_node_process : createNode;
		var postprocess = options == null ? void 0 : (_options_node2 = options.node) == null ? void 0 : _options_node2.postprocess;
		var nodes = gltf.nodes.map((gltfNode, index)=>{
				if (preprocess) {
						preprocess(gltfNode);
				}
				var node = process(gltfNode, index, nodeInstancingMap);
				if (postprocess) {
						postprocess(gltfNode, node);
				}
				return node;
		});
		for(var i = 0; i < gltf.nodes.length; ++i){
				var gltfNode = gltf.nodes[i];
				if (gltfNode.hasOwnProperty('children')) {
						var parent = nodes[i];
						var uniqueNames = {};
						for(var j = 0; j < gltfNode.children.length; ++j){
								var child = nodes[gltfNode.children[j]];
								if (!child.parent) {
										if (uniqueNames.hasOwnProperty(child.name)) {
												child.name += uniqueNames[child.name]++;
										} else {
												uniqueNames[child.name] = 1;
										}
										parent.addChild(child);
								}
						}
				}
		}
		return nodes;
};
var createScenes = (gltf, nodes)=>{
		var _gltf_scenes__nodes;
		var scenes = [];
		var count = gltf.scenes.length;
		if (count === 1 && ((_gltf_scenes__nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf_scenes__nodes.length) === 1) {
				var nodeIndex = gltf.scenes[0].nodes[0];
				scenes.push(nodes[nodeIndex]);
		} else {
				for(var i = 0; i < count; i++){
						var scene = gltf.scenes[i];
						if (scene.nodes) {
								var sceneRoot = new GraphNode(scene.name);
								for(var n = 0; n < scene.nodes.length; n++){
										var childNode = nodes[scene.nodes[n]];
										sceneRoot.addChild(childNode);
								}
								scenes.push(sceneRoot);
						}
				}
		}
		return scenes;
};
var createCameras = (gltf, nodes, options)=>{
		var cameras = null;
		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
				var _options_camera, _options_camera1, _options_camera2;
				var preprocess = options == null ? void 0 : (_options_camera = options.camera) == null ? void 0 : _options_camera.preprocess;
				var _options_camera_process;
				var process = (_options_camera_process = options == null ? void 0 : (_options_camera1 = options.camera) == null ? void 0 : _options_camera1.process) != null ? _options_camera_process : createCamera;
				var postprocess = options == null ? void 0 : (_options_camera2 = options.camera) == null ? void 0 : _options_camera2.postprocess;
				gltf.nodes.forEach((gltfNode, nodeIndex)=>{
						if (gltfNode.hasOwnProperty('camera')) {
								var gltfCamera = gltf.cameras[gltfNode.camera];
								if (gltfCamera) {
										if (preprocess) {
												preprocess(gltfCamera);
										}
										var camera = process(gltfCamera, nodes[nodeIndex]);
										if (postprocess) {
												postprocess(gltfCamera, camera);
										}
										if (camera) {
												if (!cameras) cameras = new Map();
												cameras.set(gltfNode, camera);
										}
								}
						}
				});
		}
		return cameras;
};
var createLights = (gltf, nodes, options)=>{
		var lights = null;
		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
				var gltfLights = gltf.extensions.KHR_lights_punctual.lights;
				if (gltfLights.length) {
						var _options_light, _options_light1, _options_light2;
						var preprocess = options == null ? void 0 : (_options_light = options.light) == null ? void 0 : _options_light.preprocess;
						var _options_light_process;
						var process = (_options_light_process = options == null ? void 0 : (_options_light1 = options.light) == null ? void 0 : _options_light1.process) != null ? _options_light_process : createLight;
						var postprocess = options == null ? void 0 : (_options_light2 = options.light) == null ? void 0 : _options_light2.postprocess;
						gltf.nodes.forEach((gltfNode, nodeIndex)=>{
								if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
										var lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
										var gltfLight = gltfLights[lightIndex];
										if (gltfLight) {
												if (preprocess) {
														preprocess(gltfLight);
												}
												var light = process(gltfLight, nodes[nodeIndex]);
												if (postprocess) {
														postprocess(gltfLight, light);
												}
												if (light) {
														if (!lights) lights = new Map();
														lights.set(gltfNode, light);
												}
										}
								}
						});
				}
		}
		return lights;
};
var linkSkins = (gltf, renders, skins)=>{
		gltf.nodes.forEach((gltfNode)=>{
				if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
						var meshGroup = renders[gltfNode.mesh].meshes;
						meshGroup.forEach((mesh)=>{
								mesh.skin = skins[gltfNode.skin];
						});
				}
		});
};
var createResources = /*#__PURE__*/ _async_to_generator$2(function*(device, gltf, bufferViews, textures, options) {
		var _options_global, _options_global1;
		var preprocess = options == null ? void 0 : (_options_global = options.global) == null ? void 0 : _options_global.preprocess;
		var postprocess = options == null ? void 0 : (_options_global1 = options.global) == null ? void 0 : _options_global1.postprocess;
		if (preprocess) {
				preprocess(gltf);
		}
		if (gltf.asset && gltf.asset.generator === 'PlayCanvas') ;
		var nodeInstancingMap = new Map();
		var nodes = createNodes(gltf, options, nodeInstancingMap);
		var scenes = createScenes(gltf, nodes);
		var lights = createLights(gltf, nodes, options);
		var cameras = createCameras(gltf, nodes, options);
		var variants = createVariants(gltf);
		var bufferViewData = yield Promise.all(bufferViews);
		var { meshes, meshVariants, meshDefaultMaterials, promises } = createMeshes(device, gltf, bufferViewData, options);
		var animations = createAnimations(gltf, nodes, bufferViewData, options);
		createInstancing(device, gltf, nodeInstancingMap, bufferViewData);
		var textureAssets = yield Promise.all(textures);
		var textureInstances = textureAssets.map((t)=>t.resource);
		var materials = createMaterials(gltf, textureInstances, options);
		var skins = createSkins(device, gltf, nodes, bufferViewData);
		var renders = [];
		for(var i = 0; i < meshes.length; i++){
				renders[i] = new Render();
				renders[i].meshes = meshes[i];
		}
		linkSkins(gltf, renders, skins);
		var result = new GlbResources();
		result.gltf = gltf;
		result.nodes = nodes;
		result.scenes = scenes;
		result.animations = animations;
		result.textures = textureAssets;
		result.materials = materials;
		result.variants = variants;
		result.meshVariants = meshVariants;
		result.meshDefaultMaterials = meshDefaultMaterials;
		result.renders = renders;
		result.skins = skins;
		result.lights = lights;
		result.cameras = cameras;
		result.nodeInstancingMap = nodeInstancingMap;
		if (postprocess) {
				postprocess(gltf, result);
		}
		yield Promise.all(promises);
		return result;
});
var applySampler = (texture, gltfSampler)=>{
		var getFilter = (filter, defaultValue)=>{
				switch(filter){
						case 9728:
								return FILTER_NEAREST;
						case 9729:
								return FILTER_LINEAR;
						case 9984:
								return FILTER_NEAREST_MIPMAP_NEAREST;
						case 9985:
								return FILTER_LINEAR_MIPMAP_NEAREST;
						case 9986:
								return FILTER_NEAREST_MIPMAP_LINEAR;
						case 9987:
								return FILTER_LINEAR_MIPMAP_LINEAR;
						default:
								return defaultValue;
				}
		};
		var getWrap = (wrap, defaultValue)=>{
				switch(wrap){
						case 33071:
								return ADDRESS_CLAMP_TO_EDGE;
						case 33648:
								return ADDRESS_MIRRORED_REPEAT;
						case 10497:
								return ADDRESS_REPEAT;
						default:
								return defaultValue;
				}
		};
		if (texture) {
				gltfSampler = gltfSampler != null ? gltfSampler : {};
				texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
				texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
				texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
				texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
		}
};
var gltfTextureUniqueId = 0;
var getTextureSource = (gltfTexture)=>{
		var _gltfTexture_extensions_KHR_texture_basisu, _gltfTexture_extensions, _gltfTexture_extensions_EXT_texture_webp, _gltfTexture_extensions1;
		var _gltfTexture_extensions_KHR_texture_basisu_source, _ref;
		return (_ref = (_gltfTexture_extensions_KHR_texture_basisu_source = (_gltfTexture_extensions = gltfTexture.extensions) == null ? void 0 : (_gltfTexture_extensions_KHR_texture_basisu = _gltfTexture_extensions.KHR_texture_basisu) == null ? void 0 : _gltfTexture_extensions_KHR_texture_basisu.source) != null ? _gltfTexture_extensions_KHR_texture_basisu_source : (_gltfTexture_extensions1 = gltfTexture.extensions) == null ? void 0 : (_gltfTexture_extensions_EXT_texture_webp = _gltfTexture_extensions1.EXT_texture_webp) == null ? void 0 : _gltfTexture_extensions_EXT_texture_webp.source) != null ? _ref : gltfTexture.source;
};
var createImages = (gltf, bufferViews, urlBase, registry, options)=>{
		var _options_image, _options_image1, _options_image2;
		if (!gltf.images || gltf.images.length === 0) {
				return [];
		}
		var preprocess = options == null ? void 0 : (_options_image = options.image) == null ? void 0 : _options_image.preprocess;
		var processAsync = options == null ? void 0 : (_options_image1 = options.image) == null ? void 0 : _options_image1.processAsync;
		var postprocess = options == null ? void 0 : (_options_image2 = options.image) == null ? void 0 : _options_image2.postprocess;
		var mimeTypeFileExtensions = {
				'image/png': 'png',
				'image/jpeg': 'jpg',
				'image/basis': 'basis',
				'image/ktx': 'ktx',
				'image/ktx2': 'ktx2',
				'image/vnd-ms.dds': 'dds'
		};
		var getGammaTextures = (gltf)=>{
				var set = new Set();
				if (gltf.hasOwnProperty('materials')) {
						gltf.materials.forEach((gltfMaterial)=>{
								if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
										var pbrData = gltfMaterial.pbrMetallicRoughness;
										if (pbrData.hasOwnProperty('baseColorTexture')) {
												var gltfTexture = gltf.textures[pbrData.baseColorTexture.index];
												set.add(getTextureSource(gltfTexture));
										}
								}
								if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
										var gltfTexture1 = gltf.textures[gltfMaterial.emissiveTexture.index];
										set.add(getTextureSource(gltfTexture1));
								}
						});
				}
				return set;
		};
		var loadTexture = (gltfImage, url, bufferView, mimeType, options, srgb)=>{
				return new Promise((resolve, reject)=>{
						var continuation = (bufferViewData)=>{
								var name = (gltfImage.name || 'gltf-texture') + "-" + gltfTextureUniqueId++;
								var file = {
										url: url || name
								};
								if (bufferViewData) {
										file.contents = bufferViewData.slice(0).buffer;
								}
								if (mimeType) {
										var extension = mimeTypeFileExtensions[mimeType];
										if (extension) {
												file.filename = file.url + "." + extension;
										}
								}
								var data = {
										srgb
								};
								var asset = new Asset(name, 'texture', file, data, options);
								asset.on('load', (asset)=>resolve(asset));
								asset.on('error', (err)=>reject(err));
								registry.add(asset);
								registry.load(asset);
						};
						if (bufferView) {
								bufferView.then((bufferViewData)=>continuation(bufferViewData));
						} else {
								continuation(null);
						}
				});
		};
		var gammaTextures = getGammaTextures(gltf);
		return gltf.images.map((gltfImage, i)=>{
				if (preprocess) {
						preprocess(gltfImage);
				}
				var promise;
				if (processAsync) {
						promise = new Promise((resolve, reject)=>{
								processAsync(gltfImage, (err, textureAsset)=>{
										if (err) {
												reject(err);
										} else {
												resolve(textureAsset);
										}
								});
						});
				} else {
						promise = new Promise((resolve)=>{
								resolve(null);
						});
				}
				promise = promise.then((textureAsset)=>{
						var srgb = gammaTextures.has(i);
						if (textureAsset) {
								return textureAsset;
						} else if (gltfImage.hasOwnProperty('uri')) {
								if (isDataURI(gltfImage.uri)) {
										return loadTexture(gltfImage, gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null, srgb);
								}
								return loadTexture(gltfImage, ABSOLUTE_URL.test(gltfImage.uri) ? gltfImage.uri : path.join(urlBase, gltfImage.uri), null, null, {
										crossOrigin: 'anonymous'
								}, srgb);
						} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
								return loadTexture(gltfImage, null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null, srgb);
						}
						return Promise.reject(new Error("Invalid image found in gltf (neither uri or bufferView found). index=" + i));
				});
				if (postprocess) {
						promise = promise.then((textureAsset)=>{
								postprocess(gltfImage, textureAsset);
								return textureAsset;
						});
				}
				return promise;
		});
};
var createTextures = (gltf, images, options)=>{
		var _gltf_images, _gltf_textures, _options_texture, _options_texture1, _options_texture2;
		if (!(gltf == null ? void 0 : (_gltf_images = gltf.images) == null ? void 0 : _gltf_images.length) || !(gltf == null ? void 0 : (_gltf_textures = gltf.textures) == null ? void 0 : _gltf_textures.length)) {
				return [];
		}
		var preprocess = options == null ? void 0 : (_options_texture = options.texture) == null ? void 0 : _options_texture.preprocess;
		var processAsync = options == null ? void 0 : (_options_texture1 = options.texture) == null ? void 0 : _options_texture1.processAsync;
		var postprocess = options == null ? void 0 : (_options_texture2 = options.texture) == null ? void 0 : _options_texture2.postprocess;
		var seenImages = new Set();
		return gltf.textures.map((gltfTexture)=>{
				if (preprocess) {
						preprocess(gltfTexture);
				}
				var promise;
				if (processAsync) {
						promise = new Promise((resolve, reject)=>{
								processAsync(gltfTexture, gltf.images, (err, gltfImageIndex)=>{
										if (err) {
												reject(err);
										} else {
												resolve(gltfImageIndex);
										}
								});
						});
				} else {
						promise = new Promise((resolve)=>{
								resolve(null);
						});
				}
				promise = promise.then((gltfImageIndex)=>{
						gltfImageIndex = gltfImageIndex != null ? gltfImageIndex : getTextureSource(gltfTexture);
						var cloneAsset = seenImages.has(gltfImageIndex);
						seenImages.add(gltfImageIndex);
						return images[gltfImageIndex].then((imageAsset)=>{
								var asset = cloneAsset ? cloneTextureAsset(imageAsset) : imageAsset;
								var _gltf_samplers;
								applySampler(asset.resource, ((_gltf_samplers = gltf.samplers) != null ? _gltf_samplers : [])[gltfTexture.sampler]);
								return asset;
						});
				});
				if (postprocess) {
						promise = promise.then((textureAsset)=>{
								postprocess(gltfTexture, textureAsset);
								return textureAsset;
						});
				}
				return promise;
		});
};
var loadBuffers = (gltf, binaryChunk, urlBase, options)=>{
		var _options_buffer, _options_buffer1, _options_buffer2;
		if (!gltf.buffers || gltf.buffers.length === 0) {
				return [];
		}
		var preprocess = options == null ? void 0 : (_options_buffer = options.buffer) == null ? void 0 : _options_buffer.preprocess;
		var processAsync = options == null ? void 0 : (_options_buffer1 = options.buffer) == null ? void 0 : _options_buffer1.processAsync;
		var postprocess = options == null ? void 0 : (_options_buffer2 = options.buffer) == null ? void 0 : _options_buffer2.postprocess;
		return gltf.buffers.map((gltfBuffer, i)=>{
				if (preprocess) {
						preprocess(gltfBuffer);
				}
				var promise;
				if (processAsync) {
						promise = new Promise((resolve, reject)=>{
								processAsync(gltfBuffer, (err, arrayBuffer)=>{
										if (err) {
												reject(err);
										} else {
												resolve(arrayBuffer);
										}
								});
						});
				} else {
						promise = new Promise((resolve)=>{
								resolve(null);
						});
				}
				promise = promise.then((arrayBuffer)=>{
						if (arrayBuffer) {
								return arrayBuffer;
						} else if (gltfBuffer.hasOwnProperty('uri')) {
								if (isDataURI(gltfBuffer.uri)) {
										var byteString = atob(gltfBuffer.uri.split(',')[1]);
										var binaryArray = new Uint8Array(byteString.length);
										for(var j = 0; j < byteString.length; j++){
												binaryArray[j] = byteString.charCodeAt(j);
										}
										return binaryArray;
								}
								return new Promise((resolve, reject)=>{
										http.get(ABSOLUTE_URL.test(gltfBuffer.uri) ? gltfBuffer.uri : path.join(urlBase, gltfBuffer.uri), {
												cache: true,
												responseType: 'arraybuffer',
												retry: false
										}, (err, result)=>{
												if (err) {
														reject(err);
												} else {
														resolve(new Uint8Array(result));
												}
										});
								});
						}
						return binaryChunk;
				});
				if (postprocess) {
						promise = promise.then((buffer)=>{
								postprocess(gltf.buffers[i], buffer);
								return buffer;
						});
				}
				return promise;
		});
};
var parseGltf = (gltfChunk, callback)=>{
		var decodeBinaryUtf8 = (array)=>{
				if (typeof TextDecoder !== 'undefined') {
						return new TextDecoder().decode(array);
				}
				var str = '';
				for(var i = 0; i < array.length; i++){
						str += String.fromCharCode(array[i]);
				}
				return decodeURIComponent(escape(str));
		};
		var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));
		if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
				callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
				return;
		}
		callback(null, gltf);
};
var parseGlb = (glbData, callback)=>{
		var data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
		var magic = data.getUint32(0, true);
		var version = data.getUint32(4, true);
		var length = data.getUint32(8, true);
		if (magic !== 0x46546C67) {
				callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
				return;
		}
		if (version !== 2) {
				callback("Invalid version number found in glb header. Expected 2, found " + version);
				return;
		}
		if (length <= 0 || length > data.byteLength) {
				callback("Invalid length found in glb header. Found " + length);
				return;
		}
		var chunks = [];
		var offset = 12;
		while(offset < length){
				var chunkLength = data.getUint32(offset, true);
				if (offset + chunkLength + 8 > data.byteLength) {
						callback("Invalid chunk length found in glb. Found " + chunkLength);
				}
				var chunkType = data.getUint32(offset + 4, true);
				var chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
				chunks.push({
						length: chunkLength,
						type: chunkType,
						data: chunkData
				});
				offset += chunkLength + 8;
		}
		if (chunks.length !== 1 && chunks.length !== 2) {
				callback('Invalid number of chunks found in glb file.');
				return;
		}
		if (chunks[0].type !== 0x4E4F534A) {
				callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
				return;
		}
		if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
				callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
				return;
		}
		callback(null, {
				gltfChunk: chunks[0].data,
				binaryChunk: chunks.length === 2 ? chunks[1].data : null
		});
};
var parseChunk = (filename, data, callback)=>{
		var hasGlbHeader = ()=>{
				var u8 = new Uint8Array(data);
				return u8[0] === 103 && u8[1] === 108 && u8[2] === 84 && u8[3] === 70;
		};
		if (filename && filename.toLowerCase().endsWith('.glb') || hasGlbHeader()) {
				parseGlb(data, callback);
		} else {
				callback(null, {
						gltfChunk: data,
						binaryChunk: null
				});
		}
};
var createBufferViews = (gltf, buffers, options)=>{
		var _loop = function(i) {
				var gltfBufferView = gltf.bufferViews[i];
				if (preprocess) {
						preprocess(gltfBufferView);
				}
				var promise = void 0;
				if (processAsync) {
						promise = new Promise((resolve, reject)=>{
								processAsync(gltfBufferView, buffers, (err, result)=>{
										if (err) {
												reject(err);
										} else {
												resolve(result);
										}
								});
						});
				} else {
						promise = new Promise((resolve)=>{
								resolve(null);
						});
				}
				promise = promise.then((buffer)=>{
						if (buffer) {
								return buffer;
						}
						return buffers[gltfBufferView.buffer].then((buffer)=>{
								return new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
						});
				});
				if (gltfBufferView.hasOwnProperty('byteStride')) {
						promise = promise.then((typedArray)=>{
								typedArray.byteStride = gltfBufferView.byteStride;
								return typedArray;
						});
				}
				if (postprocess) {
						promise = promise.then((typedArray)=>{
								postprocess(gltfBufferView, typedArray);
								return typedArray;
						});
				}
				result.push(promise);
		};
		var _options_bufferView, _options_bufferView1, _options_bufferView2, _gltf_bufferViews;
		var result = [];
		var preprocess = options == null ? void 0 : (_options_bufferView = options.bufferView) == null ? void 0 : _options_bufferView.preprocess;
		var processAsync = options == null ? void 0 : (_options_bufferView1 = options.bufferView) == null ? void 0 : _options_bufferView1.processAsync;
		var postprocess = options == null ? void 0 : (_options_bufferView2 = options.bufferView) == null ? void 0 : _options_bufferView2.postprocess;
		if (!((_gltf_bufferViews = gltf.bufferViews) == null ? void 0 : _gltf_bufferViews.length)) {
				return result;
		}
		for(var i = 0; i < gltf.bufferViews.length; ++i)_loop(i);
		return result;
};
class GlbParser {
		static parse(filename, urlBase, data, device, registry, options, callback) {
				parseChunk(filename, data, (err, chunks)=>{
						if (err) {
								callback(err);
								return;
						}
						parseGltf(chunks.gltfChunk, (err, gltf)=>{
								if (err) {
										callback(err);
										return;
								}
								var buffers = loadBuffers(gltf, chunks.binaryChunk, urlBase, options);
								var bufferViews = createBufferViews(gltf, buffers, options);
								var images = createImages(gltf, bufferViews, urlBase, registry, options);
								var textures = createTextures(gltf, images, options);
								createResources(device, gltf, bufferViews, textures, options).then((result)=>callback(null, result)).catch((err)=>callback(err));
						});
				});
		}
		static createDefaultMaterial() {
				return createMaterial({
						name: 'defaultGlbMaterial'
				}, []);
		}
}

class AnimationHandler extends ResourceHandler {
		load(url, callback, asset) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var options = {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
						if (path.getExtension(url.original).toLowerCase() === '.glb') {
								options.responseType = Http.ResponseType.ARRAY_BUFFER;
						} else {
								options.responseType = Http.ResponseType.JSON;
						}
				}
				http.get(url.load, options, (err, response)=>{
						if (err) {
								callback("Error loading animation resource: " + url.original + " [" + err + "]");
						} else {
								if (path.getExtension(url.original).toLowerCase() === '.glb') {
										var _asset_options;
										GlbParser.parse('filename.glb', '', response, this.device, this.assets, (_asset_options = asset == null ? void 0 : asset.options) != null ? _asset_options : {}, (err, parseResult)=>{
												if (err) {
														callback(err);
												} else {
														var _asset_data;
														var animations = parseResult.animations;
														if (asset == null ? void 0 : (_asset_data = asset.data) == null ? void 0 : _asset_data.events) {
																for(var i = 0; i < animations.length; i++){
																		animations[i].events = new AnimEvents(Object.values(asset.data.events));
																}
														}
														parseResult.destroy();
														callback(null, animations);
												}
										});
								} else {
										callback(null, this["_parseAnimationV" + response.animation.version](response));
								}
						}
				});
		}
		open(url, data, asset) {
				return data;
		}
		_parseAnimationV3(data) {
				var animData = data.animation;
				var anim = new Animation();
				anim.name = animData.name;
				anim.duration = animData.duration;
				for(var i = 0; i < animData.nodes.length; i++){
						var node = new Node();
						var n = animData.nodes[i];
						node._name = n.name;
						for(var j = 0; j < n.keys.length; j++){
								var k = n.keys[j];
								var t = k.time;
								var p = k.pos;
								var r = k.rot;
								var s = k.scale;
								var pos = new Vec3(p[0], p[1], p[2]);
								var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
								var scl = new Vec3(s[0], s[1], s[2]);
								var key = new Key(t, pos, rot, scl);
								node._keys.push(key);
						}
						anim.addNode(node);
				}
				return anim;
		}
		_parseAnimationV4(data) {
				var animData = data.animation;
				var anim = new Animation();
				anim.name = animData.name;
				anim.duration = animData.duration;
				for(var i = 0; i < animData.nodes.length; i++){
						var node = new Node();
						var n = animData.nodes[i];
						node._name = n.name;
						var defPos = n.defaults.p;
						var defRot = n.defaults.r;
						var defScl = n.defaults.s;
						for(var j = 0; j < n.keys.length; j++){
								var k = n.keys[j];
								var t = k.t;
								var p = defPos ? defPos : k.p;
								var r = defRot ? defRot : k.r;
								var s = defScl ? defScl : k.s;
								var pos = new Vec3(p[0], p[1], p[2]);
								var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
								var scl = new Vec3(s[0], s[1], s[2]);
								var key = new Key(t, pos, rot, scl);
								node._keys.push(key);
						}
						anim.addNode(node);
				}
				return anim;
		}
		constructor(app){
				super(app, 'animation');
				this.device = app.graphicsDevice;
				this.assets = app.assets;
		}
}

class AnimClipHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var options = {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				if (url.load.startsWith('blob:')) {
						options.responseType = Http.ResponseType.JSON;
				}
				http.get(url.load, options, (err, response)=>{
						if (err) {
								callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
						} else {
								callback(null, response);
						}
				});
		}
		open(url, data) {
				var name = data.name;
				var duration = data.duration;
				var inputs = data.inputs.map((input)=>{
						return new AnimData(1, input);
				});
				var outputs = data.outputs.map((output)=>{
						return new AnimData(output.components, output.data);
				});
				var curves = data.curves.map((curve)=>{
						return new AnimCurve([
								curve.path
						], curve.inputIndex, curve.outputIndex, curve.interpolation);
				});
				return new AnimTrack(name, duration, inputs, outputs, curves);
		}
		constructor(app){
				super(app, 'animclip');
		}
}

class AnimStateGraphHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var options = {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				if (url.load.startsWith('blob:')) {
						options.responseType = Http.ResponseType.JSON;
				}
				http.get(url.load, options, (err, response)=>{
						if (err) {
								callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
						} else {
								callback(null, response);
						}
				});
		}
		open(url, data) {
				return new AnimStateGraph(data);
		}
		constructor(app){
				super(app, 'animstategraph');
		}
}

var ie = function() {
		if (typeof window === 'undefined') {
				return false;
		}
		var ua = window.navigator.userAgent;
		var msie = ua.indexOf('MSIE ');
		if (msie > 0) {
				return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		}
		var trident = ua.indexOf('Trident/');
		if (trident > 0) {
				var rv = ua.indexOf('rv:');
				return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		}
		return false;
}();
var supportedExtensions = [
		'.ogg',
		'.mp3',
		'.wav',
		'.mp4a',
		'.m4a',
		'.mp4',
		'.aac',
		'.opus'
];
class AudioHandler extends ResourceHandler {
		_isSupported(url) {
				var ext = path.getExtension(url);
				return supportedExtensions.indexOf(ext) > -1;
		}
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var success = function success(resource) {
						callback(null, new Sound(resource));
				};
				var error = function error(err) {
						var msg = "Error loading audio url: " + url.original;
						if (err) {
								msg += ": " + (err.message || err);
						}
						console.warn(msg);
						callback(msg);
				};
				if (this._createSound) {
						if (!this._isSupported(url.original)) {
								error("Audio format for " + url.original + " not supported");
								return;
						}
						this._createSound(url.load, success, error);
				} else {
						error(null);
				}
		}
		_createSound(url, success, error) {
				if (hasAudioContext()) {
						var manager = this.manager;
						if (!manager.context) {
								error('Audio manager has no audio context');
								return;
						}
						var options = {
								retry: this.maxRetries > 0,
								maxRetries: this.maxRetries
						};
						if (url.startsWith('blob:') || url.startsWith('data:')) {
								options.responseType = Http.ResponseType.ARRAY_BUFFER;
						}
						http.get(url, options, (err, response)=>{
								if (err) {
										error(err);
										return;
								}
								manager.context.decodeAudioData(response, success, error);
						});
				} else {
						var audio = null;
						try {
								audio = new Audio();
						} catch (e) {
								error('No support for Audio element');
								return;
						}
						if (ie) {
								document.body.appendChild(audio);
						}
						var onReady = function onReady1() {
								audio.removeEventListener('canplaythrough', onReady);
								if (ie) {
										document.body.removeChild(audio);
								}
								success(audio);
						};
						audio.onerror = function() {
								audio.onerror = null;
								if (ie) {
										document.body.removeChild(audio);
								}
								error();
						};
						audio.addEventListener('canplaythrough', onReady);
						audio.src = url;
				}
		}
		constructor(app){
				super(app, 'audio');
				this.manager = app.soundManager;
		}
}

class BinaryHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						responseType: Http.ResponseType.ARRAY_BUFFER,
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				}, (err, response)=>{
						if (!err) {
								callback(null, response);
						} else {
								callback("Error loading binary resource: " + url.original + " [" + err + "]");
						}
				});
		}
		openBinary(data) {
				return data.buffer;
		}
		constructor(app){
				super(app, 'binary');
		}
}

class GlbContainerResource {
		get model() {
				if (!this._model) {
						var model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
						var modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);
						this._assets.add(modelAsset);
						this._model = modelAsset;
				}
				return this._model;
		}
		static createAsset(assetName, type, resource, index) {
				var subAsset = new Asset(assetName + "/" + type + "/" + index, type, {
						url: ''
				});
				subAsset.resource = resource;
				subAsset.loaded = true;
				return subAsset;
		}
		instantiateModelEntity(options) {
				var entity = new Entity();
				entity.addComponent('model', Object.assign({
						type: 'asset',
						asset: this.model
				}, options));
				return entity;
		}
		instantiateRenderEntity(options) {
				var defaultMaterial = this._defaultMaterial;
				var skinnedMeshInstances = [];
				var createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode, nodeInstancingMap) {
						var materialIndex = meshDefaultMaterials[mesh.id];
						var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
						var meshInstance = new MeshInstance(mesh, material);
						if (mesh.morph) {
								meshInstance.morphInstance = new MorphInstance(mesh.morph);
						}
						if (gltfNode.hasOwnProperty('skin')) {
								skinnedMeshInstances.push({
										meshInstance: meshInstance,
										rootBone: root,
										entity: entity
								});
						}
						var instData = nodeInstancingMap.get(gltfNode);
						if (instData) {
								var matrices = instData.matrices;
								var vbFormat = VertexFormat.getDefaultInstancingFormat(mesh.device);
								var vb = new VertexBuffer(mesh.device, vbFormat, matrices.length / 16, {
										data: matrices
								});
								meshInstance.setInstancing(vb);
								meshInstance.instancingData._destroyVertexBuffer = true;
						}
						return meshInstance;
				};
				var cloneHierarchy = (root, node, glb)=>{
						var entity = new Entity();
						node._cloneInternal(entity);
						if (!root) root = entity;
						var attachedMi = null;
						var renderAsset = null;
						for(var i = 0; i < glb.nodes.length; i++){
								var glbNode = glb.nodes[i];
								if (glbNode === node) {
										var gltfNode = glb.gltf.nodes[i];
										if (gltfNode.hasOwnProperty('mesh')) {
												var meshGroup = glb.renders[gltfNode.mesh].meshes;
												renderAsset = this.renders[gltfNode.mesh];
												for(var mi = 0; mi < meshGroup.length; mi++){
														var mesh = meshGroup[mi];
														if (mesh) {
																var cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode, glb.nodeInstancingMap);
																if (!attachedMi) {
																		attachedMi = [];
																}
																attachedMi.push(cloneMi);
														}
												}
										}
										if (glb.lights) {
												var lightEntity = glb.lights.get(gltfNode);
												if (lightEntity) {
														entity.addChild(lightEntity.clone());
												}
										}
										if (glb.cameras) {
												var cameraEntity = glb.cameras.get(gltfNode);
												if (cameraEntity) {
														cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
												}
										}
								}
						}
						if (attachedMi) {
								entity.addComponent('render', Object.assign({
										type: 'asset',
										meshInstances: attachedMi
								}, options));
								entity.render.assignAsset(renderAsset);
						}
						var children = node.children;
						for(var i1 = 0; i1 < children.length; i1++){
								var childClone = cloneHierarchy(root, children[i1], glb);
								entity.addChild(childClone);
						}
						return entity;
				};
				var sceneClones = [];
				for (var scene of this.data.scenes){
						sceneClones.push(cloneHierarchy(null, scene, this.data));
				}
				skinnedMeshInstances.forEach((data)=>{
						data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
						data.meshInstance.node.render.rootBone = data.rootBone;
				});
				return GlbContainerResource.createSceneHierarchy(sceneClones, Entity);
		}
		getMaterialVariants() {
				return this.data.variants ? Object.keys(this.data.variants) : [];
		}
		applyMaterialVariant(entity, name) {
				var variant = name ? this.data.variants[name] : null;
				if (variant === undefined) {
						return;
				}
				var renders = entity.findComponents('render');
				for(var i = 0; i < renders.length; i++){
						var renderComponent = renders[i];
						this._applyMaterialVariant(variant, renderComponent.meshInstances);
				}
		}
		applyMaterialVariantInstances(instances, name) {
				var variant = name ? this.data.variants[name] : null;
				if (variant === undefined) {
						return;
				}
				this._applyMaterialVariant(variant, instances);
		}
		_applyMaterialVariant(variant, instances) {
				instances.forEach((instance)=>{
						if (variant === null) {
								instance.material = this._defaultMaterial;
						} else {
								var meshVariants = this.data.meshVariants[instance.mesh.id];
								if (meshVariants) {
										instance.material = this.data.materials[meshVariants[variant]];
								}
						}
				});
		}
		static createSceneHierarchy(sceneNodes, nodeType) {
				var root = null;
				if (sceneNodes.length === 1) {
						root = sceneNodes[0];
				} else {
						root = new nodeType('SceneGroup');
						for (var scene of sceneNodes){
								root.addChild(scene);
						}
				}
				return root;
		}
		static createModel(glb, defaultMaterial) {
				var createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
						var materialIndex = glb.meshDefaultMaterials[mesh.id];
						var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
						var meshInstance = new MeshInstance(mesh, material, node);
						if (mesh.morph) {
								var morphInstance = new MorphInstance(mesh.morph);
								meshInstance.morphInstance = morphInstance;
								model.morphInstances.push(morphInstance);
						}
						if (gltfNode.hasOwnProperty('skin')) {
								var skinIndex = gltfNode.skin;
								var skin = skins[skinIndex];
								mesh.skin = skin;
								var skinInstance = skinInstances[skinIndex];
								meshInstance.skinInstance = skinInstance;
								model.skinInstances.push(skinInstance);
						}
						model.meshInstances.push(meshInstance);
				};
				var model = new Model();
				var skinInstances = [];
				for (var skin of glb.skins){
						var skinInstance = new SkinInstance(skin);
						skinInstance.bones = skin.bones;
						skinInstances.push(skinInstance);
				}
				model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, GraphNode);
				for(var i = 0; i < glb.nodes.length; i++){
						var node = glb.nodes[i];
						if (node.root === model.graph) {
								var gltfNode = glb.gltf.nodes[i];
								if (gltfNode.hasOwnProperty('mesh')) {
										var meshGroup = glb.renders[gltfNode.mesh].meshes;
										for(var mi = 0; mi < meshGroup.length; mi++){
												var mesh = meshGroup[mi];
												if (mesh) {
														createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
												}
										}
								}
						}
				}
				return model;
		}
		destroy() {
				var registry = this._assets;
				var destroyAsset = function destroyAsset(asset) {
						registry.remove(asset);
						asset.unload();
				};
				var destroyAssets = function destroyAssets(assets) {
						assets.forEach((asset)=>{
								destroyAsset(asset);
						});
				};
				if (this.animations) {
						destroyAssets(this.animations);
						this.animations = null;
				}
				if (this.textures) {
						destroyAssets(this.textures);
						this.textures = null;
				}
				if (this.materials) {
						destroyAssets(this.materials);
						this.materials = null;
				}
				if (this.renders) {
						destroyAssets(this.renders);
						this.renders = null;
				}
				if (this._model) {
						destroyAsset(this._model);
						this._model = null;
				}
				this.data = null;
				this.assets = null;
		}
		constructor(data, asset, assets, defaultMaterial){
				var createAsset = function createAsset(type, resource, index) {
						var subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
						assets.add(subAsset);
						return subAsset;
				};
				var renders = [];
				for(var i = 0; i < data.renders.length; ++i){
						renders.push(createAsset('render', data.renders[i], i));
				}
				var materials = [];
				for(var i1 = 0; i1 < data.materials.length; ++i1){
						materials.push(createAsset('material', data.materials[i1], i1));
				}
				var animations = [];
				for(var i2 = 0; i2 < data.animations.length; ++i2){
						animations.push(createAsset('animation', data.animations[i2], i2));
				}
				this.data = data;
				this._model = null;
				this._assetName = asset.name;
				this._assets = assets;
				this._defaultMaterial = defaultMaterial;
				this.renders = renders;
				this.materials = materials;
				this.textures = data.textures;
				this.animations = animations;
		}
}

class GlbContainerParser {
		_getUrlWithoutParams(url) {
				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		}
		load(url, callback, asset) {
				Asset.fetchArrayBuffer(url.load, (err, result)=>{
						if (err) {
								callback(err);
						} else {
								GlbParser.parse(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result)=>{
										if (err) {
												callback(err);
										} else {
												callback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));
										}
								});
						}
				}, asset, this.maxRetries);
		}
		open(url, data, asset) {
				return data;
		}
		patch(asset, assets) {}
		constructor(device, assets, maxRetries){
				this._device = device;
				this._assets = assets;
				this._defaultMaterial = GlbParser.createDefaultMaterial();
				this.maxRetries = maxRetries;
		}
}

class ContainerResource {
		instantiateModelEntity(options) {
				return null;
		}
		instantiateRenderEntity(options) {
				return null;
		}
		getMaterialVariants() {
				return null;
		}
		applyMaterialVariant(entity, name) {}
		applyMaterialVariantInstances(instances, name) {}
}
class ContainerHandler extends ResourceHandler {
		set maxRetries(value) {
				this.glbContainerParser.maxRetries = value;
				for(var parser in this.parsers){
						if (this.parsers.hasOwnProperty(parser)) {
								this.parsers[parser].maxRetries = value;
						}
				}
		}
		get maxRetries() {
				return this.glbContainerParser.maxRetries;
		}
		_getUrlWithoutParams(url) {
				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		}
		_getParser(url) {
				var ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
				return this.parsers[ext] || this.glbContainerParser;
		}
		load(url, callback, asset) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				this._getParser(url.original).load(url, callback, asset);
		}
		open(url, data, asset) {
				return this._getParser(url).open(url, data, asset);
		}
		constructor(app){
				super(app, 'container');
				this.glbContainerParser = new GlbContainerParser(app.graphicsDevice, app.assets, 0);
				this.parsers = {};
		}
}

class CssHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				}, (err, response)=>{
						if (!err) {
								callback(null, response);
						} else {
								callback("Error loading css resource: " + url.original + " [" + err + "]");
						}
				});
		}
		openBinary(data) {
				var _this_decoder;
				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
				return this.decoder.decode(data);
		}
		constructor(app){
				super(app, 'css'), this.decoder = null;
		}
}

class CubemapHandler extends ResourceHandler {
		load(url, callback, asset) {
				this.loadAssets(asset, callback);
		}
		open(url, data, asset) {
				return asset ? asset.resource : null;
		}
		patch(asset, registry) {
				this.loadAssets(asset, (err, result)=>{
						if (err) {
								registry.fire('error', asset);
								registry.fire("error:" + asset.id, err, asset);
								asset.fire('error', asset);
						}
				});
		}
		getAssetIds(cubemapAsset) {
				var result = [];
				result[0] = cubemapAsset.file;
				if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
						for(var i = 0; i < 6; ++i){
								result[i + 1] = cubemapAsset.data.textures[i];
						}
				} else {
						result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
				}
				return result;
		}
		compareAssetIds(assetIdA, assetIdB) {
				if (assetIdA && assetIdB) {
						if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {
								return assetIdA === assetIdB;
						}
						return assetIdA.url === assetIdB.url;
				}
				return assetIdA !== null === (assetIdB !== null);
		}
		update(cubemapAsset, assetIds, assets) {
				var assetData = cubemapAsset.data || {};
				var oldAssets = cubemapAsset._handlerState.assets;
				var oldResources = cubemapAsset._resources;
				var tex, mip, i;
				var resources = [
						null,
						null,
						null,
						null,
						null,
						null,
						null
				];
				var getType = function getType() {
						if (assetData.hasOwnProperty('type')) {
								return assetData.type;
						}
						if (assetData.hasOwnProperty('rgbm')) {
								return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
						}
						return null;
				};
				if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
						if (assets[0]) {
								tex = assets[0].resource;
								if (tex.cubemap) {
										for(i = 0; i < 6; ++i){
												resources[i + 1] = new Texture(this._device, {
														name: cubemapAsset.name + "_prelitCubemap" + (tex.width >> i),
														cubemap: true,
														type: getType() || tex.type,
														width: tex.width >> i,
														height: tex.height >> i,
														format: tex.format,
														levels: [
																tex._levels[i]
														],
														addressU: ADDRESS_CLAMP_TO_EDGE,
														addressV: ADDRESS_CLAMP_TO_EDGE,
														mipmaps: i === 0
												});
										}
								} else {
										resources[1] = tex;
								}
						}
				} else {
						resources[1] = oldResources[1] || null;
						resources[2] = oldResources[2] || null;
						resources[3] = oldResources[3] || null;
						resources[4] = oldResources[4] || null;
						resources[5] = oldResources[5] || null;
						resources[6] = oldResources[6] || null;
				}
				var faceAssets = assets.slice(1);
				if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
						if (faceAssets.indexOf(null) === -1) {
								var faceTextures = faceAssets.map((asset)=>{
										return asset.resource;
								});
								var faceLevels = [];
								for(mip = 0; mip < faceTextures[0]._levels.length; ++mip){
										faceLevels.push(faceTextures.map((faceTexture)=>{
												return faceTexture._levels[mip];
										}));
								}
								var format = faceTextures[0].format;
								var _assetData_mipmaps;
								var faces = new Texture(this._device, {
										name: "" + cubemapAsset.name + "_faces",
										cubemap: true,
										type: getType() || faceTextures[0].type,
										width: faceTextures[0].width,
										height: faceTextures[0].height,
										format: format === PIXELFORMAT_RGB8 ? PIXELFORMAT_RGBA8 : format,
										mipmaps: (_assetData_mipmaps = assetData.mipmaps) != null ? _assetData_mipmaps : true,
										levels: faceLevels,
										minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
										magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
										anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
										addressU: ADDRESS_CLAMP_TO_EDGE,
										addressV: ADDRESS_CLAMP_TO_EDGE
								});
								resources[0] = faces;
						}
				} else {
						resources[0] = oldResources[0] || null;
				}
				if (!this.cmpArrays(resources, oldResources)) {
						cubemapAsset.resources = resources;
						cubemapAsset._handlerState.assetIds = assetIds;
						cubemapAsset._handlerState.assets = assets;
						for(i = 0; i < oldResources.length; ++i){
								if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
										oldResources[i].destroy();
								}
						}
				}
				for(i = 0; i < oldAssets.length; ++i){
						if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
								oldAssets[i].unload();
						}
				}
		}
		cmpArrays(arr1, arr2) {
				if (arr1.length !== arr2.length) {
						return false;
				}
				for(var i = 0; i < arr1.length; ++i){
						if (arr1[i] !== arr2[i]) {
								return false;
						}
				}
				return true;
		}
		resolveId(value) {
				var valueInt = parseInt(value, 10);
				return valueInt === value || valueInt.toString() === value ? valueInt : value;
		}
		loadAssets(cubemapAsset, callback) {
				if (!cubemapAsset.hasOwnProperty('_handlerState')) {
						cubemapAsset._handlerState = {
								assetIds: [
										null,
										null,
										null,
										null,
										null,
										null,
										null
								],
								assets: [
										null,
										null,
										null,
										null,
										null,
										null,
										null
								]
						};
				}
				var self = this;
				var assetIds = self.getAssetIds(cubemapAsset);
				var assets = [
						null,
						null,
						null,
						null,
						null,
						null,
						null
				];
				var loadedAssetIds = cubemapAsset._handlerState.assetIds;
				var loadedAssets = cubemapAsset._handlerState.assets;
				var registry = self._registry;
				var awaiting = 7;
				var onLoad = function onLoad(index, asset) {
						assets[index] = asset;
						awaiting--;
						if (awaiting === 0) {
								self.update(cubemapAsset, assetIds, assets);
								callback(null, cubemapAsset.resources);
						}
				};
				var onError = function onError(index, err, asset) {
						callback(err);
				};
				var processTexAsset = function processTexAsset(index, texAsset) {
						if (texAsset.loaded) {
								onLoad(index, texAsset);
						} else {
								registry.once("load:" + texAsset.id, onLoad.bind(self, index));
								registry.once("error:" + texAsset.id, onError.bind(self, index));
								if (!texAsset.loading) {
										registry.load(texAsset);
								}
						}
				};
				var texAsset;
				for(var i = 0; i < 7; ++i){
						var assetId = this.resolveId(assetIds[i]);
						if (!assetId) {
								onLoad(i, null);
						} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
								processTexAsset(i, loadedAssets[i]);
						} else if (parseInt(assetId, 10) === assetId) {
								texAsset = registry.get(assetId);
								if (texAsset) {
										processTexAsset(i, texAsset);
								} else {
										setTimeout(((index, assetId_)=>{
												var texAsset = registry.get(assetId_);
												if (texAsset) {
														processTexAsset(index, texAsset);
												} else {
														onError(index, "failed to find dependent cubemap asset=" + assetId_);
												}
										}).bind(null, i, assetId));
								}
						} else {
								var file = typeof assetId === 'string' ? {
										url: assetId,
										filename: assetId
								} : assetId;
								var data = file.url.search('.dds') === -1 ? {
										type: 'rgbp',
										addressu: 'clamp',
										addressv: 'clamp',
										mipmaps: false
								} : null;
								texAsset = new Asset(cubemapAsset.name + "_part_" + i, 'texture', file, data);
								registry.add(texAsset);
								processTexAsset(i, texAsset);
						}
				}
		}
		constructor(app){
				super(app, 'cubemap');
				this._device = app.graphicsDevice;
				this._registry = app.assets;
				this._loader = app.loader;
		}
}

class FolderHandler extends ResourceHandler {
		load(url, callback) {
				callback(null, null);
		}
		constructor(app){
				super(app, 'folder');
		}
}

class Font {
		set data(value) {
				this._data = value;
				if (!value) {
						return;
				}
				if (this._data.intensity !== undefined) {
						this.intensity = this._data.intensity;
				}
				if (!this._data.info) {
						this._data.info = {};
				}
				if (!this._data.version || this._data.version < 2) {
						this._data.info.maps = [
								{
										width: this._data.info.width,
										height: this._data.info.height
								}
						];
						if (this._data.chars) {
								for(var key in this._data.chars){
										this._data.chars[key].map = 0;
								}
						}
				}
		}
		get data() {
				return this._data;
		}
		constructor(textures, data){
				this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
				this.em = 1;
				this.textures = textures;
				this.intensity = 0.0;
				this._data = null;
				this.data = data;
		}
}

function upgradeDataSchema(data) {
		if (data.version < 3) {
				if (data.version < 2) {
						data.info.maps = data.info.maps || [
								{
										width: data.info.width,
										height: data.info.height
								}
						];
				}
				data.chars = Object.keys(data.chars || {}).reduce((newChars, key)=>{
						var existing = data.chars[key];
						var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);
						if (data.version < 2) {
								existing.map = existing.map || 0;
						}
						newChars[newKey] = existing;
						return newChars;
				}, {});
				data.version = 3;
		}
		return data;
}
class FontHandler extends ResourceHandler {
		load(url, callback, asset) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var self = this;
				if (path.getExtension(url.original) === '.json') {
						http.get(url.load, {
								retry: this.maxRetries > 0,
								maxRetries: this.maxRetries
						}, (err, response)=>{
								if (!err) {
										var data = upgradeDataSchema(response);
										self._loadTextures(url.load.replace('.json', '.png'), data, (err, textures)=>{
												if (err) {
														callback(err);
												} else {
														callback(null, {
																data: data,
																textures: textures
														});
												}
										});
								} else {
										callback("Error loading font resource: " + url.original + " [" + err + "]");
								}
						});
				} else {
						if (asset && asset.data) {
								asset.data = upgradeDataSchema(asset.data);
						}
						this._loadTextures(url.load, asset && asset.data, callback);
				}
		}
		_loadTextures(url, data, callback) {
				var numTextures = data.info.maps.length;
				var numLoaded = 0;
				var error = null;
				var textures = new Array(numTextures);
				var loader = this._loader;
				var loadTexture = function loadTexture(index) {
						var onLoaded = function onLoaded(err, texture) {
								if (error) return;
								if (err) {
										error = err;
										callback(err);
										return;
								}
								texture.upload();
								textures[index] = texture;
								numLoaded++;
								if (numLoaded === numTextures) {
										callback(null, textures);
								}
						};
						if (index === 0) {
								loader.load(url, 'texture', onLoaded);
						} else {
								loader.load(url.replace('.png', "" + index + ".png"), 'texture', onLoaded);
						}
				};
				for(var i = 0; i < numTextures; i++){
						loadTexture(i);
				}
		}
		open(url, data, asset) {
				var font;
				if (data.textures) {
						font = new Font(data.textures, data.data);
				} else {
						font = new Font(data, null);
				}
				return font;
		}
		patch(asset, assets) {
				var font = asset.resource;
				if (!font.data && asset.data) {
						font.data = asset.data;
				} else if (!asset.data && font.data) {
						asset.data = font.data;
				}
				if (asset.data) {
						asset.data = upgradeDataSchema(asset.data);
				}
		}
		constructor(app){
				super(app, 'font');
				this._loader = app.loader;
				this.maxRetries = 0;
		}
}

var SH_C0 = 0.28209479177387814;
class SplatCompressedIterator {
		constructor(gsplatData, p, r, s, c, sh){
				var unpackUnorm = (value, bits)=>{
						var t = (1 << bits) - 1;
						return (value & t) / t;
				};
				var unpack111011 = (result, value)=>{
						result.x = unpackUnorm(value >>> 21, 11);
						result.y = unpackUnorm(value >>> 11, 10);
						result.z = unpackUnorm(value, 11);
				};
				var unpack8888 = (result, value)=>{
						result.x = unpackUnorm(value >>> 24, 8);
						result.y = unpackUnorm(value >>> 16, 8);
						result.z = unpackUnorm(value >>> 8, 8);
						result.w = unpackUnorm(value, 8);
				};
				var unpackRot = (result, value)=>{
						var norm = 1.0 / (Math.sqrt(2) * 0.5);
						var a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;
						var b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;
						var c = (unpackUnorm(value, 10) - 0.5) * norm;
						var m = Math.sqrt(1.0 - (a * a + b * b + c * c));
						switch(value >>> 30){
								case 0:
										result.set(a, b, c, m);
										break;
								case 1:
										result.set(m, b, c, a);
										break;
								case 2:
										result.set(b, m, c, a);
										break;
								case 3:
										result.set(b, c, m, a);
										break;
						}
				};
				var lerp = (a, b, t)=>a * (1 - t) + b * t;
				var { chunkData, chunkSize, vertexData, shData0, shData1, shData2, shBands } = gsplatData;
				var shCoeffs = [
						3,
						8,
						15
				][shBands - 1];
				this.read = (i)=>{
						var ci = Math.floor(i / 256) * chunkSize;
						if (p) {
								unpack111011(p, vertexData[i * 4 + 0]);
								p.x = lerp(chunkData[ci + 0], chunkData[ci + 3], p.x);
								p.y = lerp(chunkData[ci + 1], chunkData[ci + 4], p.y);
								p.z = lerp(chunkData[ci + 2], chunkData[ci + 5], p.z);
						}
						if (r) {
								unpackRot(r, vertexData[i * 4 + 1]);
						}
						if (s) {
								unpack111011(s, vertexData[i * 4 + 2]);
								s.x = lerp(chunkData[ci + 6], chunkData[ci + 9], s.x);
								s.y = lerp(chunkData[ci + 7], chunkData[ci + 10], s.y);
								s.z = lerp(chunkData[ci + 8], chunkData[ci + 11], s.z);
						}
						if (c) {
								unpack8888(c, vertexData[i * 4 + 3]);
								if (chunkSize > 12) {
										c.x = lerp(chunkData[ci + 12], chunkData[ci + 15], c.x);
										c.y = lerp(chunkData[ci + 13], chunkData[ci + 16], c.y);
										c.z = lerp(chunkData[ci + 14], chunkData[ci + 17], c.z);
								}
						}
						if (sh && shBands > 0) {
								var shData = [
										shData0,
										shData1,
										shData2
								];
								for(var j = 0; j < 3; ++j){
										for(var k = 0; k < 15; ++k){
												sh[j * 15 + k] = k < shCoeffs ? shData[j][i * 16 + k] * (8 / 255) - 4 : 0;
										}
								}
						}
				};
		}
}
class GSplatCompressedData {
		createIter(p, r, s, c, sh) {
				return new SplatCompressedIterator(this, p, r, s, c, sh);
		}
		calcAabb(result) {
				var { chunkData, numChunks, chunkSize } = this;
				var s = Math.exp(Math.max(chunkData[9], chunkData[10], chunkData[11]));
				var mx = chunkData[0] - s;
				var my = chunkData[1] - s;
				var mz = chunkData[2] - s;
				var Mx = chunkData[3] + s;
				var My = chunkData[4] + s;
				var Mz = chunkData[5] + s;
				for(var i = 1; i < numChunks; ++i){
						var off = i * chunkSize;
						s = Math.exp(Math.max(chunkData[off + 9], chunkData[off + 10], chunkData[off + 11]));
						mx = Math.min(mx, chunkData[off + 0] - s);
						my = Math.min(my, chunkData[off + 1] - s);
						mz = Math.min(mz, chunkData[off + 2] - s);
						Mx = Math.max(Mx, chunkData[off + 3] + s);
						My = Math.max(My, chunkData[off + 4] + s);
						Mz = Math.max(Mz, chunkData[off + 5] + s);
				}
				result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
				result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
				return true;
		}
		getCenters(result) {
				var { vertexData, chunkData, numChunks, chunkSize } = this;
				var mx, my, mz, Mx, My, Mz;
				for(var c = 0; c < numChunks; ++c){
						var off = c * chunkSize;
						mx = chunkData[off + 0];
						my = chunkData[off + 1];
						mz = chunkData[off + 2];
						Mx = chunkData[off + 3];
						My = chunkData[off + 4];
						Mz = chunkData[off + 5];
						var end = Math.min(this.numSplats, (c + 1) * 256);
						for(var i = c * 256; i < end; ++i){
								var p = vertexData[i * 4];
								var px = (p >>> 21) / 2047;
								var py = (p >>> 11 & 0x3ff) / 1023;
								var pz = (p & 0x7ff) / 2047;
								result[i * 3 + 0] = (1 - px) * mx + px * Mx;
								result[i * 3 + 1] = (1 - py) * my + py * My;
								result[i * 3 + 2] = (1 - pz) * mz + pz * Mz;
						}
				}
		}
		getChunks(result) {
				var { chunkData, numChunks, chunkSize } = this;
				var mx, my, mz, Mx, My, Mz;
				for(var c = 0; c < numChunks; ++c){
						var off = c * chunkSize;
						mx = chunkData[off + 0];
						my = chunkData[off + 1];
						mz = chunkData[off + 2];
						Mx = chunkData[off + 3];
						My = chunkData[off + 4];
						Mz = chunkData[off + 5];
						result[c * 6 + 0] = mx;
						result[c * 6 + 1] = my;
						result[c * 6 + 2] = mz;
						result[c * 6 + 3] = Mx;
						result[c * 6 + 4] = My;
						result[c * 6 + 5] = Mz;
				}
		}
		calcFocalPoint(result) {
				var { chunkData, numChunks, chunkSize } = this;
				result.x = 0;
				result.y = 0;
				result.z = 0;
				for(var i = 0; i < numChunks; ++i){
						var off = i * chunkSize;
						result.x += chunkData[off + 0] + chunkData[off + 3];
						result.y += chunkData[off + 1] + chunkData[off + 4];
						result.z += chunkData[off + 2] + chunkData[off + 5];
				}
				result.mulScalar(0.5 / numChunks);
		}
		get isCompressed() {
				return true;
		}
		get numChunks() {
				return Math.ceil(this.numSplats / 256);
		}
		get chunkSize() {
				return this.chunkData.length / this.numChunks;
		}
		decompress() {
				var members = [
						'x',
						'y',
						'z',
						'f_dc_0',
						'f_dc_1',
						'f_dc_2',
						'opacity',
						'scale_0',
						'scale_1',
						'scale_2',
						'rot_0',
						'rot_1',
						'rot_2',
						'rot_3'
				];
				var { shBands } = this;
				if (shBands > 0) {
						var shMembers = [];
						for(var i = 0; i < 45; ++i){
								shMembers.push("f_rest_" + i);
						}
						members.splice(members.indexOf('f_dc_0') + 1, 0, ...shMembers);
				}
				var data = {};
				members.forEach((name)=>{
						data[name] = new Float32Array(this.numSplats);
				});
				var p = new Vec3();
				var r = new Quat();
				var s = new Vec3();
				var c = new Vec4();
				var sh = shBands > 0 ? new Float32Array(45) : null;
				var iter = this.createIter(p, r, s, c, sh);
				for(var i1 = 0; i1 < this.numSplats; ++i1){
						iter.read(i1);
						data.x[i1] = p.x;
						data.y[i1] = p.y;
						data.z[i1] = p.z;
						data.rot_1[i1] = r.x;
						data.rot_2[i1] = r.y;
						data.rot_3[i1] = r.z;
						data.rot_0[i1] = r.w;
						data.scale_0[i1] = s.x;
						data.scale_1[i1] = s.y;
						data.scale_2[i1] = s.z;
						data.f_dc_0[i1] = (c.x - 0.5) / SH_C0;
						data.f_dc_1[i1] = (c.y - 0.5) / SH_C0;
						data.f_dc_2[i1] = (c.z - 0.5) / SH_C0;
						data.opacity[i1] = c.w <= 0 ? -40 : c.w >= 1 ? 40 : -Math.log(1 / c.w - 1);
						if (sh) {
								for(var c1 = 0; c1 < 45; ++c1){
										data["f_rest_" + c1][i1] = sh[c1];
								}
						}
				}
				return new GSplatData([
						{
								name: 'vertex',
								count: this.numSplats,
								properties: members.map((name)=>{
										return {
												name: name,
												type: 'float',
												byteSize: 4,
												storage: data[name]
										};
								})
						}
				]);
		}
}

function _extends$7() {
		_extends$7 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$7.apply(this, arguments);
}
var strideCopy = (target, targetStride, src, srcStride, numEntries)=>{
		for(var i = 0; i < numEntries; ++i){
				for(var j = 0; j < srcStride; ++j){
						target[i * targetStride + j] = src[i * srcStride + j];
				}
		}
};
class GSplatCompressed {
		destroy() {
				var _this_packedTexture, _this_chunkTexture, _this_shTexture0, _this_shTexture1, _this_shTexture2;
				(_this_packedTexture = this.packedTexture) == null ? void 0 : _this_packedTexture.destroy();
				(_this_chunkTexture = this.chunkTexture) == null ? void 0 : _this_chunkTexture.destroy();
				(_this_shTexture0 = this.shTexture0) == null ? void 0 : _this_shTexture0.destroy();
				(_this_shTexture1 = this.shTexture1) == null ? void 0 : _this_shTexture1.destroy();
				(_this_shTexture2 = this.shTexture2) == null ? void 0 : _this_shTexture2.destroy();
		}
		createMaterial(options) {
				var result = createGSplatMaterial(options);
				result.setDefine('GSPLAT_COMPRESSED_DATA', true);
				result.setParameter('packedTexture', this.packedTexture);
				result.setParameter('chunkTexture', this.chunkTexture);
				result.setParameter('numSplats', this.numSplatsVisible);
				if (this.shTexture0) {
						result.setDefine('SH_BANDS', 3);
						result.setParameter('shTexture0', this.shTexture0);
						result.setParameter('shTexture1', this.shTexture1);
						result.setParameter('shTexture2', this.shTexture2);
				} else {
						result.setDefine('SH_BANDS', 0);
				}
				return result;
		}
		evalTextureSize(count) {
				var width = Math.ceil(Math.sqrt(count));
				var height = Math.ceil(count / width);
				return new Vec2(width, height);
		}
		createTexture(name, format, size, data) {
				return new Texture(this.device, _extends$7({
						name: name,
						width: size.x,
						height: size.y,
						format: format,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				}, data ? {
						levels: [
								data
						]
				} : {}));
		}
		constructor(device, gsplatData){
				var { chunkData, chunkSize, numChunks, numSplats, vertexData, shBands } = gsplatData;
				this.device = device;
				this.numSplats = numSplats;
				this.numSplatsVisible = numSplats;
				this.aabb = new BoundingBox();
				gsplatData.calcAabb(this.aabb);
				this.centers = new Float32Array(numSplats * 3);
				gsplatData.getCenters(this.centers);
				this.chunks = new Float32Array(numChunks * 6);
				gsplatData.getChunks(this.chunks);
				this.packedTexture = this.createTexture('packedData', PIXELFORMAT_RGBA32U, this.evalTextureSize(numSplats), vertexData);
				var chunkTextureSize = this.evalTextureSize(numChunks);
				chunkTextureSize.x *= 5;
				this.chunkTexture = this.createTexture('chunkData', PIXELFORMAT_RGBA32F, chunkTextureSize);
				var chunkTextureData = this.chunkTexture.lock();
				strideCopy(chunkTextureData, 20, chunkData, chunkSize, numChunks);
				if (chunkSize === 12) {
						for(var i = 0; i < numChunks; ++i){
								chunkTextureData[i * 20 + 15] = 1;
								chunkTextureData[i * 20 + 16] = 1;
								chunkTextureData[i * 20 + 17] = 1;
						}
				}
				this.chunkTexture.unlock();
				if (shBands > 0) {
						var size = this.evalTextureSize(numSplats);
						this.shTexture0 = this.createTexture('shTexture0', PIXELFORMAT_RGBA32U, size, new Uint32Array(gsplatData.shData0.buffer));
						this.shTexture1 = this.createTexture('shTexture1', PIXELFORMAT_RGBA32U, size, new Uint32Array(gsplatData.shData1.buffer));
						this.shTexture2 = this.createTexture('shTexture2', PIXELFORMAT_RGBA32U, size, new Uint32Array(gsplatData.shData2.buffer));
				} else {
						this.shTexture0 = null;
						this.shTexture1 = null;
						this.shTexture2 = null;
				}
		}
}

class GSplatResource {
		destroy() {
				var _this_splat;
				this.device = null;
				this.splatData = null;
				(_this_splat = this.splat) == null ? void 0 : _this_splat.destroy();
				this.splat = null;
		}
		createSplat() {
				if (!this.splat) {
						this.splat = this.splatData.isCompressed ? new GSplatCompressed(this.device, this.splatData) : new GSplat(this.device, this.splatData);
				}
				return this.splat;
		}
		instantiate(options) {
				if (options === void 0) options = {};
				var splatInstance = this.createInstance(options);
				var entity = new Entity();
				var component = entity.addComponent('gsplat', {
						instance: splatInstance
				});
				entity.setLocalEulerAngles(0, 0, 180);
				component.customAabb = splatInstance.splat.aabb.clone();
				return entity;
		}
		createInstance(options) {
				if (options === void 0) options = {};
				var splat = this.createSplat();
				return new GSplatInstance(splat, options);
		}
		constructor(device, splatData, comments){
				this.splat = null;
				this.comments = null;
				this.device = device;
				this.splatData = splatData;
				this.comments = comments;
		}
}

function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
		try {
				var info = gen[key](arg);
				var value = info.value;
		} catch (error) {
				reject(error);
				return;
		}
		if (info.done) {
				resolve(value);
		} else {
				Promise.resolve(value).then(_next, _throw);
		}
}
function _async_to_generator$1(fn) {
		return function() {
				var self = this, args = arguments;
				return new Promise(function(resolve, reject) {
						var gen = fn.apply(self, args);
						function _next(value) {
								asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
						}
						function _throw(err) {
								asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
						}
						_next(undefined);
				});
		};
}
var magicBytes = new Uint8Array([
		112,
		108,
		121,
		10
]);
var endHeaderBytes = new Uint8Array([
		10,
		101,
		110,
		100,
		95,
		104,
		101,
		97,
		100,
		101,
		114,
		10
]);
var dataTypeMap = new Map([
		[
				'char',
				Int8Array
		],
		[
				'uchar',
				Uint8Array
		],
		[
				'short',
				Int16Array
		],
		[
				'ushort',
				Uint16Array
		],
		[
				'int',
				Int32Array
		],
		[
				'uint',
				Uint32Array
		],
		[
				'float',
				Float32Array
		],
		[
				'double',
				Float64Array
		]
]);
class StreamBuf {
		read() {
				var _this = this;
				return _async_to_generator$1(function*() {
						var { value, done } = yield _this.reader.read();
						if (done) {
								throw new Error('Stream finished before end of header');
						}
						_this.push(value);
						_this.progressFunc == null ? void 0 : _this.progressFunc.call(_this, value.byteLength);
				})();
		}
		push(data) {
				if (!this.data) {
						this.data = data;
						this.view = new DataView(this.data.buffer);
						this.tail = data.length;
				} else {
						var remaining = this.tail - this.head;
						var newSize = remaining + data.length;
						if (this.data.length >= newSize) {
								if (this.head > 0) {
										this.data.copyWithin(0, this.head, this.tail);
										this.data.set(data, remaining);
										this.head = 0;
										this.tail = newSize;
								} else {
										this.data.set(data, this.tail);
										this.tail += data.length;
								}
						} else {
								var tmp = new Uint8Array(newSize);
								if (this.head > 0 || this.tail < this.data.length) {
										tmp.set(this.data.subarray(this.head, this.tail), 0);
								} else {
										tmp.set(this.data, 0);
								}
								tmp.set(data, remaining);
								this.data = tmp;
								this.view = new DataView(this.data.buffer);
								this.head = 0;
								this.tail = newSize;
						}
				}
		}
		compact() {
				if (this.head > 0) {
						this.data.copyWithin(0, this.head, this.tail);
						this.tail -= this.head;
						this.head = 0;
				}
		}
		get remaining() {
				return this.tail - this.head;
		}
		getInt8() {
				var result = this.view.getInt8(this.head);
				this.head++;
				return result;
		}
		getUint8() {
				var result = this.view.getUint8(this.head);
				this.head++;
				return result;
		}
		getInt16() {
				var result = this.view.getInt16(this.head, true);
				this.head += 2;
				return result;
		}
		getUint16() {
				var result = this.view.getUint16(this.head, true);
				this.head += 2;
				return result;
		}
		getInt32() {
				var result = this.view.getInt32(this.head, true);
				this.head += 4;
				return result;
		}
		getUint32() {
				var result = this.view.getUint32(this.head, true);
				this.head += 4;
				return result;
		}
		getFloat32() {
				var result = this.view.getFloat32(this.head, true);
				this.head += 4;
				return result;
		}
		getFloat64() {
				var result = this.view.getFloat64(this.head, true);
				this.head += 8;
				return result;
		}
		constructor(reader, progressFunc){
				this.head = 0;
				this.tail = 0;
				this.reader = reader;
				this.progressFunc = progressFunc;
		}
}
var parseHeader = (lines)=>{
		var elements = [];
		var comments = [];
		var format;
		for(var i = 1; i < lines.length; ++i){
				var words = lines[i].split(' ');
				switch(words[0]){
						case 'comment':
								comments.push(words.slice(1).join(' '));
								break;
						case 'format':
								format = words[1];
								break;
						case 'element':
								elements.push({
										name: words[1],
										count: parseInt(words[2], 10),
										properties: []
								});
								break;
						case 'property':
								{
										if (!dataTypeMap.has(words[1])) {
												throw new Error("Unrecognized property data type '" + words[1] + "' in ply header");
										}
										var element = elements[elements.length - 1];
										element.properties.push({
												type: words[1],
												name: words[2],
												storage: null,
												byteSize: dataTypeMap.get(words[1]).BYTES_PER_ELEMENT
										});
										break;
								}
						default:
								throw new Error("Unrecognized header value '" + words[0] + "' in ply header");
				}
		}
		return {
				elements,
				format,
				comments
		};
};
var isCompressedPly = (elements)=>{
		var chunkProperties = [
				'min_x',
				'min_y',
				'min_z',
				'max_x',
				'max_y',
				'max_z',
				'min_scale_x',
				'min_scale_y',
				'min_scale_z',
				'max_scale_x',
				'max_scale_y',
				'max_scale_z',
				'min_r',
				'min_g',
				'min_b',
				'max_r',
				'max_g',
				'max_b'
		];
		var vertexProperties = [
				'packed_position',
				'packed_rotation',
				'packed_scale',
				'packed_color'
		];
		var shProperties = new Array(45).fill('').map((_, i)=>"f_rest_" + i);
		var hasBaseElements = ()=>{
				return elements[0].name === 'chunk' && elements[0].properties.every((p, i)=>p.name === chunkProperties[i] && p.type === 'float') && elements[1].name === 'vertex' && elements[1].properties.every((p, i)=>p.name === vertexProperties[i] && p.type === 'uint');
		};
		var hasSHElements = ()=>{
				return elements[2].name === 'sh' && [
						9,
						24,
						45
				].indexOf(elements[2].properties.length) !== -1 && elements[2].properties.every((p, i)=>p.name === shProperties[i] && p.type === 'uchar');
		};
		return elements.length === 2 && hasBaseElements() || elements.length === 3 && hasBaseElements() && hasSHElements();
};
var isFloatPly = (elements)=>{
		return elements.length === 1 && elements[0].name === 'vertex' && elements[0].properties.every((p)=>p.type === 'float');
};
var readCompressedPly = /*#__PURE__*/ _async_to_generator$1(function*(streamBuf, elements) {
		var result = new GSplatCompressedData();
		var numChunks = elements[0].count;
		var numChunkProperties = elements[0].properties.length;
		var numVertices = elements[1].count;
		var evalStorageSize = (count)=>{
				var width = Math.ceil(Math.sqrt(count));
				var height = Math.ceil(count / width);
				return width * height;
		};
		var storageSize = evalStorageSize(numVertices);
		result.numSplats = numVertices;
		result.chunkData = new Float32Array(numChunks * numChunkProperties);
		result.vertexData = new Uint32Array(storageSize * 4);
		var read = /*#__PURE__*/ _async_to_generator$1(function*(buffer, length) {
				var target = new Uint8Array(buffer);
				var cursor = 0;
				while(cursor < length){
						while(streamBuf.remaining === 0){
								yield streamBuf.read();
						}
						var toCopy = Math.min(length - cursor, streamBuf.remaining);
						var src = streamBuf.data;
						for(var i = 0; i < toCopy; ++i){
								target[cursor++] = src[streamBuf.head++];
						}
				}
		});
		yield read(result.chunkData.buffer, numChunks * numChunkProperties * 4);
		yield read(result.vertexData.buffer, numVertices * 4 * 4);
		if (elements.length === 3) {
				var texStorageSize = storageSize * 16;
				var shData0 = new Uint8Array(texStorageSize);
				var shData1 = new Uint8Array(texStorageSize);
				var shData2 = new Uint8Array(texStorageSize);
				var chunkSize = 1024;
				var srcCoeffs = elements[2].properties.length / 3;
				var tmpBuf = new Uint8Array(chunkSize * srcCoeffs * 3);
				for(var i = 0; i < result.numSplats; i += chunkSize){
						var toRead = Math.min(chunkSize, result.numSplats - i);
						yield read(tmpBuf.buffer, toRead * srcCoeffs * 3);
						for(var j = 0; j < toRead; ++j){
								for(var k = 0; k < 15; ++k){
										var tidx = (i + j) * 16 + k;
										if (k < srcCoeffs) {
												shData0[tidx] = tmpBuf[(j * 3 + 0) * srcCoeffs + k];
												shData1[tidx] = tmpBuf[(j * 3 + 1) * srcCoeffs + k];
												shData2[tidx] = tmpBuf[(j * 3 + 2) * srcCoeffs + k];
										} else {
												shData0[tidx] = 127;
												shData1[tidx] = 127;
												shData2[tidx] = 127;
										}
								}
						}
				}
				result.shData0 = shData0;
				result.shData1 = shData1;
				result.shData2 = shData2;
				result.shBands = ({
						3: 1,
						8: 2,
						15: 3
				})[srcCoeffs];
		} else {
				result.shBands = 0;
		}
		return result;
});
var readFloatPly = /*#__PURE__*/ _async_to_generator$1(function*(streamBuf, elements) {
		var element = elements[0];
		var properties = element.properties;
		var numProperties = properties.length;
		var storage = properties.map((p)=>p.storage);
		var inputSize = properties.reduce((a, p)=>a + p.byteSize, 0);
		var vertexIdx = 0;
		var floatData;
		var checkFloatData = ()=>{
				var buffer = streamBuf.data.buffer;
				if ((floatData == null ? void 0 : floatData.buffer) !== buffer) {
						floatData = new Float32Array(buffer, 0, buffer.byteLength / 4);
				}
		};
		checkFloatData();
		while(vertexIdx < element.count){
				while(streamBuf.remaining < inputSize){
						yield streamBuf.read();
						checkFloatData();
				}
				var toRead = Math.min(element.count - vertexIdx, Math.floor(streamBuf.remaining / inputSize));
				for(var j = 0; j < numProperties; ++j){
						var s = storage[j];
						for(var n = 0; n < toRead; ++n){
								s[n + vertexIdx] = floatData[n * numProperties + j];
						}
				}
				vertexIdx += toRead;
				streamBuf.head += toRead * inputSize;
		}
		return new GSplatData(elements);
});
var readGeneralPly = /*#__PURE__*/ _async_to_generator$1(function*(streamBuf, elements) {
		for(var i = 0; i < elements.length; ++i){
				var element = elements[i];
				var inputSize = element.properties.reduce((a, p)=>a + p.byteSize, 0);
				var propertyParsingFunctions = element.properties.map((p)=>{
						if (p.storage) {
								switch(p.type){
										case 'char':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getInt8();
												};
										case 'uchar':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getUint8();
												};
										case 'short':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getInt16();
												};
										case 'ushort':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getUint16();
												};
										case 'int':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getInt32();
												};
										case 'uint':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getUint32();
												};
										case 'float':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getFloat32();
												};
										case 'double':
												return (streamBuf, c)=>{
														p.storage[c] = streamBuf.getFloat64();
												};
										default:
												throw new Error("Unsupported property data type '" + p.type + "' in ply header");
								}
						} else {
								return (streamBuf)=>{
										streamBuf.head += p.byteSize;
								};
						}
				});
				var c = 0;
				while(c < element.count){
						while(streamBuf.remaining < inputSize){
								yield streamBuf.read();
						}
						var toRead = Math.min(element.count - c, Math.floor(streamBuf.remaining / inputSize));
						for(var n = 0; n < toRead; ++n){
								for(var j = 0; j < element.properties.length; ++j){
										propertyParsingFunctions[j](streamBuf, c);
								}
								c++;
						}
				}
		}
		return new GSplatData(elements);
});
var readPly = /*#__PURE__*/ _async_to_generator$1(function*(reader, propertyFilter, progressFunc) {
		if (propertyFilter === void 0) propertyFilter = null;
		if (progressFunc === void 0) progressFunc = null;
		var find = (buf, search)=>{
				var endIndex = buf.length - search.length;
				var i, j;
				for(i = 0; i <= endIndex; ++i){
						for(j = 0; j < search.length; ++j){
								if (buf[i + j] !== search[j]) {
										break;
								}
						}
						if (j === search.length) {
								return i;
						}
				}
				return -1;
		};
		var startsWith = (a, b)=>{
				if (a.length < b.length) {
						return false;
				}
				for(var i = 0; i < b.length; ++i){
						if (a[i] !== b[i]) {
								return false;
						}
				}
				return true;
		};
		var streamBuf = new StreamBuf(reader, progressFunc);
		var headerLength;
		while(true){
				yield streamBuf.read();
				if (streamBuf.tail >= magicBytes.length && !startsWith(streamBuf.data, magicBytes)) {
						throw new Error('Invalid ply header');
				}
				headerLength = find(streamBuf.data, endHeaderBytes);
				if (headerLength !== -1) {
						break;
				}
		}
		var lines = new TextDecoder('ascii').decode(streamBuf.data.subarray(0, headerLength)).split('\n');
		var { elements, format, comments } = parseHeader(lines);
		if (format !== 'binary_little_endian') {
				throw new Error('Unsupported ply format');
		}
		streamBuf.head = headerLength + endHeaderBytes.length;
		streamBuf.compact();
		var readData = /*#__PURE__*/ _async_to_generator$1(function*() {
				if (isCompressedPly(elements)) {
						return yield readCompressedPly(streamBuf, elements);
				}
				elements.forEach((e)=>{
						e.properties.forEach((p)=>{
								var storageType = dataTypeMap.get(p.type);
								if (storageType) {
										var storage = !propertyFilter || propertyFilter(p.name) ? new storageType(e.count) : null;
										p.storage = storage;
								}
						});
				});
				if (isFloatPly(elements)) {
						return yield readFloatPly(streamBuf, elements);
				}
				return yield readGeneralPly(streamBuf, elements);
		});
		return {
				data: yield readData(),
				comments
		};
});
var defaultElementFilter = (val)=>true;
class PlyParser {
		load(url, callback, asset) {
				var _this = this;
				return _async_to_generator$1(function*() {
						try {
								var response = yield fetch(url.load);
								if (!response || !response.body) {
										callback('Error loading resource', null);
								} else {
										var _response_headers_get;
										var totalLength = parseInt((_response_headers_get = response.headers.get('content-length')) != null ? _response_headers_get : '0', 10);
										var totalReceived = 0;
										var _asset_data_elementFilter;
										var { data, comments } = yield readPly(response.body.getReader(), (_asset_data_elementFilter = asset.data.elementFilter) != null ? _asset_data_elementFilter : defaultElementFilter, (bytes)=>{
												totalReceived += bytes;
												if (asset) {
														asset.fire('progress', totalReceived, totalLength);
												}
										});
										if (!data.isCompressed) {
												var _asset_data_reorder;
												if ((_asset_data_reorder = asset.data.reorder) != null ? _asset_data_reorder : true) {
														data.reorderData();
												}
										}
										var resource = new GSplatResource(_this.device, data.isCompressed && asset.data.decompress ? data.decompress() : data, comments);
										callback(null, resource);
								}
						} catch (err) {
								callback(err, null);
						}
				})();
		}
		open(url, data) {
				return data;
		}
		constructor(device, assets, maxRetries){
				this.device = device;
				this.assets = assets;
				this.maxRetries = maxRetries;
		}
}

class GSplatHandler extends ResourceHandler {
		load(url, callback, asset) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				this.parser.load(url, callback, asset);
		}
		open(url, data, asset) {
				return this.parser.open(url, data, asset);
		}
		constructor(app){
				super(app, 'gsplat');
				this.parser = new PlyParser(app.graphicsDevice, app.assets, 3);
		}
}

class CompressUtils {
		static setCompressedPRS(entity, data, compressed) {
				var a = compressed.singleVecs;
				var b, i;
				var v = data.___1;
				if (!v) {
						b = compressed.tripleVecs;
						i = data.___2;
				}
				var n = v ? v[0] : b[i];
				entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
				n = v ? v[1] : b[i + 1];
				entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
				n = v ? v[2] : b[i + 2];
				entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
		}
		static oneCharToKey(s, data) {
				var i = s.charCodeAt(0) - data.fieldFirstCode;
				return data.fieldArray[i];
		}
		static multCharToKey(s, data) {
				var ind = 0;
				for(var i = 0; i < s.length; i++){
						ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
				}
				return data.fieldArray[ind];
		}
}

class Decompress {
		run() {
				var type = Object.prototype.toString.call(this._node);
				if (type === '[object Object]') {
						this._handleMap();
				} else if (type === '[object Array]') {
						this._handleArray();
				} else {
						this._result = this._node;
				}
				return this._result;
		}
		_handleMap() {
				this._result = {};
				var a = Object.keys(this._node);
				a.forEach(this._handleKey, this);
		}
		_handleKey(origKey) {
				var newKey = origKey;
				var len = origKey.length;
				if (len === 1) {
						newKey = CompressUtils.oneCharToKey(origKey, this._data);
				} else if (len === 2) {
						newKey = CompressUtils.multCharToKey(origKey, this._data);
				}
				this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
		}
		_handleArray() {
				this._result = [];
				this._node.forEach(this._handleArElt, this);
		}
		_handleArElt(elt) {
				var v = new Decompress(elt, this._data).run();
				this._result.push(v);
		}
		constructor(node, data){
				this._node = node;
				this._data = data;
		}
}

class SceneParser {
		parse(data) {
				var entities = {};
				var parent = null;
				var compressed = data.compressedFormat;
				if (compressed && !data.entDecompressed) {
						data.entDecompressed = true;
						data.entities = new Decompress(data.entities, compressed).run();
				}
				for(var id in data.entities){
						var curData = data.entities[id];
						var curEnt = this._createEntity(curData, compressed);
						entities[id] = curEnt;
						if (curData.parent === null) {
								parent = curEnt;
						}
				}
				for(var id1 in data.entities){
						var curEnt1 = entities[id1];
						var children = data.entities[id1].children;
						var len = children.length;
						for(var i = 0; i < len; i++){
								var childEnt = entities[children[i]];
								if (childEnt) {
										curEnt1.addChild(childEnt);
								}
						}
				}
				this._openComponentData(parent, data.entities);
				return parent;
		}
		_createEntity(data, compressed) {
				var entity = new Entity(data.name, this._app);
				entity.setGuid(data.resource_id);
				this._setPosRotScale(entity, data, compressed);
				var _data_enabled;
				entity._enabled = (_data_enabled = data.enabled) != null ? _data_enabled : true;
				if (this._isTemplate) {
						entity._template = true;
				} else {
						entity._enabledInHierarchy = entity._enabled;
				}
				entity.template = data.template;
				if (data.tags) {
						for(var i = 0; i < data.tags.length; i++){
								entity.tags.add(data.tags[i]);
						}
				}
				return entity;
		}
		_setPosRotScale(entity, data, compressed) {
				if (compressed) {
						CompressUtils.setCompressedPRS(entity, data, compressed);
				} else {
						var p = data.position;
						var r = data.rotation;
						var s = data.scale;
						entity.setLocalPosition(p[0], p[1], p[2]);
						entity.setLocalEulerAngles(r[0], r[1], r[2]);
						entity.setLocalScale(s[0], s[1], s[2]);
				}
		}
		_openComponentData(entity, entities) {
				var systemsList = this._app.systems.list;
				var len = systemsList.length;
				var entityData = entities[entity.getGuid()];
				for(var i = 0; i < len; i++){
						var system = systemsList[i];
						var componentData = entityData.components[system.id];
						if (componentData) {
								system.addComponent(entity, componentData);
						}
				}
				len = entityData.children.length;
				var children = entity._children;
				for(var i1 = 0; i1 < len; i1++){
						if (children[i1]) {
								children[i1] = this._openComponentData(children[i1], entities);
						}
				}
				return entity;
		}
		constructor(app, isTemplate){
				this._app = app;
				this._isTemplate = isTemplate;
		}
}

class SceneUtils {
		static load(url, maxRetries, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						retry: maxRetries > 0,
						maxRetries: maxRetries
				}, (err, response)=>{
						if (!err) {
								callback(err, response);
						} else {
								var errMsg = "Error while loading scene JSON " + url.original;
								if (err.message) {
										errMsg += ": " + err.message;
										if (err.stack) {
												errMsg += "\n" + err.stack;
										}
								} else {
										errMsg += ": " + err;
								}
								callback(errMsg);
						}
				});
		}
}

class HierarchyHandler extends ResourceHandler {
		load(url, callback) {
				SceneUtils.load(url, this.maxRetries, callback);
		}
		open(url, data) {
				this._app.systems.script.preloading = true;
				var parser = new SceneParser(this._app, false);
				var parent = parser.parse(data);
				this._app.systems.script.preloading = false;
				return parent;
		}
		constructor(app){
				super(app, 'hierarchy');
		}
}

class HtmlHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				}, (err, response)=>{
						if (!err) {
								callback(null, response);
						} else {
								callback("Error loading html resource: " + url.original + " [" + err + "]");
						}
				});
		}
		openBinary(data) {
				var _this_decoder;
				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
				return this.decoder.decode(data);
		}
		constructor(app){
				super(app, 'html'), this.decoder = null;
		}
}

class JsonHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var options = {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				if (url.load.startsWith('blob:')) {
						options.responseType = Http.ResponseType.JSON;
				}
				http.get(url.load, options, (err, response)=>{
						if (!err) {
								callback(null, response);
						} else {
								callback("Error loading JSON resource: " + url.original + " [" + err + "]");
						}
				});
		}
		openBinary(data) {
				var _this_decoder;
				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
				return JSON.parse(this.decoder.decode(data));
		}
		constructor(app){
				super(app, 'json'), this.decoder = null;
		}
}

class StandardMaterialValidator {
		setInvalid(key, data) {
				this.valid = false;
				if (this.removeInvalid) {
						delete data[key];
				}
		}
		validate(data) {
				var TYPES = standardMaterialParameterTypes;
				var REMOVED = standardMaterialRemovedParameters;
				var pathMapping = data.mappingFormat === 'path';
				for(var key in data){
						var type = TYPES[key];
						if (!type) {
								if (REMOVED[key]) {
										delete data[key];
								} else {
										this.valid = false;
								}
								continue;
						}
						if (type.startsWith('enum')) {
								var enumType = type.split(':')[1];
								if (this.enumValidators[enumType]) {
										if (!this.enumValidators[enumType](data[key])) {
												this.setInvalid(key, data);
										}
								}
						} else if (type === 'number') {
								if (typeof data[key] !== 'number') {
										this.setInvalid(key, data);
								}
						} else if (type === 'boolean') {
								if (typeof data[key] !== 'boolean') {
										this.setInvalid(key, data);
								}
						} else if (type === 'string') {
								if (typeof data[key] !== 'string') {
										this.setInvalid(key, data);
								}
						} else if (type === 'vec2') {
								if (!(data[key] instanceof Array && data[key].length === 2)) {
										this.setInvalid(key, data);
								}
						} else if (type === 'rgb') {
								if (!(data[key] instanceof Array && data[key].length === 3)) {
										this.setInvalid(key, data);
								}
						} else if (type === 'texture') {
								if (!pathMapping) {
										if (!(typeof data[key] === 'number' || data[key] === null)) {
												if (!(data[key] instanceof Texture)) {
														this.setInvalid(key, data);
												}
										}
								} else {
										if (!(typeof data[key] === 'string' || data[key] === null)) {
												if (!(data[key] instanceof Texture)) {
														this.setInvalid(key, data);
												}
										}
								}
						} else if (type === 'boundingbox') {
								if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
										this.setInvalid(key, data);
								}
								if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
										this.setInvalid(key, data);
								}
						} else if (type === 'cubemap') {
								if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
										if (!(data[key] instanceof Texture && data[key].cubemap)) {
												this.setInvalid(key, data);
										}
								}
						} else if (type === 'chunks') {
								var chunkNames = Object.keys(data[key]);
								for(var i = 0; i < chunkNames.length; i++){
										if (typeof data[key][chunkNames[i]] !== 'string') {
												this.setInvalid(chunkNames[i], data[key]);
										}
								}
						} else {
								console.error("Unknown material type: " + type);
						}
				}
				data.validated = true;
				return this.valid;
		}
		_createEnumValidator(values) {
				return function(value) {
						return values.indexOf(value) >= 0;
				};
		}
		constructor(){
				this.removeInvalid = true;
				this.valid = true;
				this.enumValidators = {
						occludeSpecular: this._createEnumValidator([
								SPECOCC_NONE,
								SPECOCC_AO,
								SPECOCC_GLOSSDEPENDENT
						]),
						cull: this._createEnumValidator([
								CULLFACE_NONE,
								CULLFACE_BACK,
								CULLFACE_FRONT,
								CULLFACE_FRONTANDBACK
						]),
						blendType: this._createEnumValidator([
								BLEND_SUBTRACTIVE,
								BLEND_ADDITIVE,
								BLEND_NORMAL,
								BLEND_NONE,
								BLEND_PREMULTIPLIED,
								BLEND_MULTIPLICATIVE,
								BLEND_ADDITIVEALPHA,
								BLEND_MULTIPLICATIVE2X,
								BLEND_SCREEN,
								BLEND_MIN,
								BLEND_MAX
						]),
						depthFunc: this._createEnumValidator([
								FUNC_NEVER,
								FUNC_LESS,
								FUNC_EQUAL,
								FUNC_LESSEQUAL,
								FUNC_GREATER,
								FUNC_NOTEQUAL,
								FUNC_GREATEREQUAL,
								FUNC_ALWAYS
						])
				};
		}
}

function _extends$6() {
		_extends$6 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$6.apply(this, arguments);
}
class JsonStandardMaterialParser {
		parse(input) {
				var migrated = this.migrate(input);
				var validated = this._validate(migrated);
				var material = new StandardMaterial();
				this.initialize(material, validated);
				return material;
		}
		initialize(material, data) {
				if (!data.validated) {
						data = this._validate(data);
				}
				if (data.chunks) {
						material.chunks = _extends$6({}, data.chunks);
				}
				for(var key in data){
						var type = standardMaterialParameterTypes[key];
						var value = data[key];
						if (type === 'vec2') {
								material[key] = new Vec2(value[0], value[1]);
						} else if (type === 'rgb') {
								material[key] = new Color(value[0], value[1], value[2]);
						} else if (type === 'texture') {
								if (value instanceof Texture) {
										material[key] = value;
								} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
										material[key] = null;
								}
						} else if (type === 'cubemap') {
								if (value instanceof Texture) {
										material[key] = value;
								} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
										material[key] = null;
								}
								if (key === 'cubeMap' && !value) {
										material.prefilteredCubemaps = null;
								}
						} else if (type === 'boundingbox') {
								var center = new Vec3(value.center[0], value.center[1], value.center[2]);
								var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
								material[key] = new BoundingBox(center, halfExtents);
						} else {
								material[key] = data[key];
						}
				}
				material.update();
		}
		migrate(data) {
				if (data.shader) delete data.shader;
				if (data.mapping_format) {
						data.mappingFormat = data.mapping_format;
						delete data.mapping_format;
				}
				var i;
				var RENAMED_PROPERTIES = [
						[
								'bumpMapFactor',
								'bumpiness'
						],
						[
								'aoUvSet',
								'aoMapUv'
						],
						[
								'aoMapVertexColor',
								'aoVertexColor'
						],
						[
								'diffuseMapVertexColor',
								'diffuseVertexColor'
						],
						[
								'emissiveMapVertexColor',
								'emissiveVertexColor'
						],
						[
								'specularMapVertexColor',
								'specularVertexColor'
						],
						[
								'metalnessMapVertexColor',
								'metalnessVertexColor'
						],
						[
								'opacityMapVertexColor',
								'opacityVertexColor'
						],
						[
								'glossMapVertexColor',
								'glossVertexColor'
						],
						[
								'lightMapVertexColor',
								'lightVertexColor'
						],
						[
								'specularMapTint',
								'specularTint'
						],
						[
								'metalnessMapTint',
								'metalnessTint'
						],
						[
								'clearCoatGlossiness',
								'clearCoatGloss'
						]
				];
				for(i = 0; i < RENAMED_PROPERTIES.length; i++){
						var _old = RENAMED_PROPERTIES[i][0];
						var _new = RENAMED_PROPERTIES[i][1];
						if (data[_old] !== undefined) {
								if (data[_new] === undefined) {
										data[_new] = data[_old];
								}
								delete data[_old];
						}
				}
				var DEPRECATED_PROPERTIES = [
						'fresnelFactor',
						'shadowSampleType'
				];
				for(i = 0; i < DEPRECATED_PROPERTIES.length; i++){
						var name = DEPRECATED_PROPERTIES[i];
						if (data.hasOwnProperty(name)) {
								delete data[name];
						}
				}
				return data;
		}
		_validate(data) {
				if (!data.validated) {
						if (!this._validator) {
								this._validator = new StandardMaterialValidator();
						}
						this._validator.validate(data);
				}
				return data;
		}
		constructor(){
				this._validator = null;
		}
}

var PLACEHOLDER_MAP = {
		aoMap: 'white',
		aoDetailMap: 'white',
		diffuseMap: 'gray',
		diffuseDetailMap: 'gray',
		specularMap: 'gray',
		specularityFactorMap: 'white',
		metalnessMap: 'black',
		glossMap: 'gray',
		sheenMap: 'black',
		sheenGlossMap: 'gray',
		clearCoatMap: 'black',
		clearCoatGlossMap: 'gray',
		clearCoatNormalMap: 'normal',
		refractionMap: 'white',
		emissiveMap: 'gray',
		normalMap: 'normal',
		normalDetailMap: 'normal',
		heightMap: 'gray',
		opacityMap: 'gray',
		sphereMap: 'gray',
		lightMap: 'white',
		thicknessMap: 'black',
		iridescenceMap: 'black',
		iridescenceThicknessMap: 'black',
		envAtlas: 'black'
};
class MaterialHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				}, (err, response)=>{
						if (!err) {
								if (callback) {
										response._engine = true;
										callback(null, response);
								}
						} else {
								if (callback) {
										callback("Error loading material: " + url.original + " [" + err + "]");
								}
						}
				});
		}
		open(url, data) {
				var material = this._parser.parse(data);
				if (data._engine) {
						material._data = data;
						delete data._engine;
				}
				return material;
		}
		patch(asset, assets) {
				if (asset.resource._data) {
						asset._data = asset.resource._data;
						delete asset.resource._data;
				}
				asset.data.name = asset.name;
				asset.resource.name = asset.name;
				this._bindAndAssignAssets(asset, assets);
				asset.off('unload', this._onAssetUnload, this);
				asset.on('unload', this._onAssetUnload, this);
		}
		_onAssetUnload(asset) {
				delete asset.data.parameters;
				delete asset.data.chunks;
				delete asset.data.name;
		}
		_assignTexture(parameterName, materialAsset, texture) {
				materialAsset.resource[parameterName] = texture;
		}
		_getPlaceholderTexture(parameterName) {
				var placeholder = PLACEHOLDER_MAP[parameterName];
				return getBuiltInTexture(this._device, placeholder);
		}
		_assignPlaceholderTexture(parameterName, materialAsset) {
				materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
		}
		_onTextureLoad(parameterName, materialAsset, textureAsset) {
				this._assignTexture(parameterName, materialAsset, textureAsset.resource);
				materialAsset.resource.update();
		}
		_onTextureAdd(parameterName, materialAsset, textureAsset) {
				this._assets.load(textureAsset);
		}
		_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
				var material = materialAsset.resource;
				if (material) {
						if (materialAsset.resource[parameterName] === textureAsset.resource) {
								this._assignPlaceholderTexture(parameterName, materialAsset);
								material.update();
						}
				}
		}
		_assignCubemap(parameterName, materialAsset, textures) {
				materialAsset.resource[parameterName] = textures[0];
				if (parameterName === 'cubeMap') {
						var prefiltered = textures.slice(1);
						if (prefiltered.every((t)=>t)) {
								materialAsset.resource.prefilteredCubemaps = prefiltered;
						} else if (prefiltered[0]) {
								materialAsset.resource.envAtlas = prefiltered[0];
						}
				}
		}
		_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
				this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
				this._parser.initialize(materialAsset.resource, materialAsset.data);
		}
		_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
				this._assets.load(cubemapAsset);
		}
		_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
				var material = materialAsset.resource;
				if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
						this._assignCubemap(parameterName, materialAsset, [
								null,
								null,
								null,
								null,
								null,
								null,
								null
						]);
						material.update();
				}
		}
		_bindAndAssignAssets(materialAsset, assets) {
				var data = this._parser.migrate(materialAsset.data);
				var material = materialAsset.resource;
				var pathMapping = data.mappingFormat === 'path';
				var TEXTURES = standardMaterialTextureParameters;
				var i, name, assetReference;
				for(i = 0; i < TEXTURES.length; i++){
						name = TEXTURES[i];
						assetReference = material._assetReferences[name];
						var dataAssetId = data[name];
						var materialTexture = material[name];
						var isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);
						var dataValidated = data.validated;
						if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
								if (!assetReference) {
										assetReference = new AssetReference(name, materialAsset, assets, {
												load: this._onTextureLoad,
												add: this._onTextureAdd,
												remove: this._onTextureRemoveOrUnload,
												unload: this._onTextureRemoveOrUnload
										}, this);
										material._assetReferences[name] = assetReference;
								}
								if (pathMapping) {
										assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
								} else {
										assetReference.id = dataAssetId;
								}
								if (assetReference.asset) {
										if (assetReference.asset.resource) {
												this._assignTexture(name, materialAsset, assetReference.asset.resource);
										} else {
												this._assignPlaceholderTexture(name, materialAsset);
										}
										assets.load(assetReference.asset);
								}
						} else {
								if (assetReference) {
										if (pathMapping) {
												assetReference.url = null;
										} else {
												assetReference.id = null;
										}
								}
						}
				}
				var CUBEMAPS = standardMaterialCubemapParameters;
				for(i = 0; i < CUBEMAPS.length; i++){
						name = CUBEMAPS[i];
						assetReference = material._assetReferences[name];
						if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
								if (!assetReference) {
										assetReference = new AssetReference(name, materialAsset, assets, {
												load: this._onCubemapLoad,
												add: this._onCubemapAdd,
												remove: this._onCubemapRemoveOrUnload,
												unload: this._onCubemapRemoveOrUnload
										}, this);
										material._assetReferences[name] = assetReference;
								}
								if (pathMapping) {
										assetReference.url = data[name];
								} else {
										assetReference.id = data[name];
								}
								if (assetReference.asset) {
										if (assetReference.asset.loaded) {
												this._assignCubemap(name, materialAsset, assetReference.asset.resources);
										}
										assets.load(assetReference.asset);
								}
						}
				}
				this._parser.initialize(material, data);
		}
		constructor(app){
				super(app, 'material');
				this._assets = app.assets;
				this._device = app.graphicsDevice;
				this._parser = new JsonStandardMaterialParser();
		}
}

class GlbModelParser {
		parse(data, callback, asset) {
				var _asset_options;
				GlbParser.parse('filename.glb', '', data, this._device, this._assets, (_asset_options = asset == null ? void 0 : asset.options) != null ? _asset_options : {}, (err, result)=>{
						if (err) {
								callback(err);
						} else {
								var model = GlbContainerResource.createModel(result, this._defaultMaterial);
								result.destroy();
								callback(null, model);
						}
				});
		}
		constructor(modelHandler){
				this._device = modelHandler.device;
				this._defaultMaterial = modelHandler.defaultMaterial;
				this._assets = modelHandler.assets;
		}
}

var JSON_PRIMITIVE_TYPE = {
		'points': PRIMITIVE_POINTS,
		'lines': PRIMITIVE_LINES,
		'lineloop': PRIMITIVE_LINELOOP,
		'linestrip': PRIMITIVE_LINESTRIP,
		'triangles': PRIMITIVE_TRIANGLES,
		'trianglestrip': PRIMITIVE_TRISTRIP,
		'trianglefan': PRIMITIVE_TRIFAN
};
var JSON_VERTEX_ELEMENT_TYPE = {
		'int8': TYPE_INT8,
		'uint8': TYPE_UINT8,
		'int16': TYPE_INT16,
		'uint16': TYPE_UINT16,
		'int32': TYPE_INT32,
		'uint32': TYPE_UINT32,
		'float32': TYPE_FLOAT32
};
class JsonModelParser {
		parse(data, callback) {
				var modelData = data.model;
				if (!modelData) {
						callback(null, null);
						return;
				}
				if (modelData.version <= 1) {
						callback('JsonModelParser#parse: Trying to parse unsupported model format.');
						return;
				}
				var nodes = this._parseNodes(data);
				var skins = this._parseSkins(data, nodes);
				var vertexBuffers = this._parseVertexBuffers(data);
				var indices = this._parseIndexBuffers(data, vertexBuffers);
				var morphs = this._parseMorphs(data, nodes, vertexBuffers);
				var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
				var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
				var model = new Model();
				model.graph = nodes[0];
				model.meshInstances = meshInstances;
				model.skinInstances = skins.instances;
				model.morphInstances = morphs.instances;
				model.getGraph().syncHierarchy();
				callback(null, model);
		}
		_parseNodes(data) {
				var modelData = data.model;
				var nodes = [];
				var i;
				for(i = 0; i < modelData.nodes.length; i++){
						var nodeData = modelData.nodes[i];
						var node = new GraphNode(nodeData.name);
						node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
						node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
						node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
						node.scaleCompensation = !!nodeData.scaleCompensation;
						nodes.push(node);
				}
				for(i = 1; i < modelData.parents.length; i++){
						nodes[modelData.parents[i]].addChild(nodes[i]);
				}
				return nodes;
		}
		_parseSkins(data, nodes) {
				var modelData = data.model;
				var skins = [];
				var skinInstances = [];
				var i, j;
				for(i = 0; i < modelData.skins.length; i++){
						var skinData = modelData.skins[i];
						var inverseBindMatrices = [];
						for(j = 0; j < skinData.inverseBindMatrices.length; j++){
								var ibm = skinData.inverseBindMatrices[j];
								inverseBindMatrices[j] = new Mat4().set(ibm);
						}
						var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
						skins.push(skin);
						var skinInstance = new SkinInstance(skin);
						var bones = [];
						for(j = 0; j < skin.boneNames.length; j++){
								var boneName = skin.boneNames[j];
								var bone = nodes[0].findByName(boneName);
								bones.push(bone);
						}
						skinInstance.bones = bones;
						skinInstances.push(skinInstance);
				}
				return {
						skins: skins,
						instances: skinInstances
				};
		}
		_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
				for(var i = 0; i < modelData.meshes.length; i++){
						var meshData = modelData.meshes[i];
						if (meshData.morph === morphIndex) {
								var vertexBuffer = vertexBuffers[meshData.vertices];
								return vertexBuffer.numVertices;
						}
				}
				return undefined;
		}
		_parseMorphs(data, nodes, vertexBuffers) {
				var modelData = data.model;
				var morphs = [];
				var morphInstances = [];
				var i, j, vertexCount;
				var targets, morphTarget, morphTargetArray;
				if (modelData.morphs) {
						var sparseToFull = function sparseToFull(data, indices, totalCount) {
								var full = new Float32Array(totalCount * 3);
								for(var s = 0; s < indices.length; s++){
										var dstIndex = indices[s] * 3;
										full[dstIndex] = data[s * 3];
										full[dstIndex + 1] = data[s * 3 + 1];
										full[dstIndex + 2] = data[s * 3 + 2];
								}
								return full;
						};
						for(i = 0; i < modelData.morphs.length; i++){
								targets = modelData.morphs[i].targets;
								morphTargetArray = [];
								vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);
								for(j = 0; j < targets.length; j++){
										var targetAabb = targets[j].aabb;
										var min = targetAabb.min;
										var max = targetAabb.max;
										var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
										var indices = targets[j].indices;
										var deltaPositions = targets[j].deltaPositions;
										var deltaNormals = targets[j].deltaNormals;
										if (indices) {
												deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
												deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
										}
										morphTarget = new MorphTarget({
												deltaPositions: deltaPositions,
												deltaNormals: deltaNormals,
												name: targets[j].name,
												aabb: aabb
										});
										morphTargetArray.push(morphTarget);
								}
								var morph = new Morph(morphTargetArray, this._device);
								morphs.push(morph);
								var morphInstance = new MorphInstance(morph);
								morphInstances.push(morphInstance);
						}
				}
				return {
						morphs: morphs,
						instances: morphInstances
				};
		}
		_parseVertexBuffers(data) {
				var modelData = data.model;
				var vertexBuffers = [];
				var attributeMap = {
						position: SEMANTIC_POSITION,
						normal: SEMANTIC_NORMAL,
						tangent: SEMANTIC_TANGENT,
						blendWeight: SEMANTIC_BLENDWEIGHT,
						blendIndices: SEMANTIC_BLENDINDICES,
						color: SEMANTIC_COLOR,
						texCoord0: SEMANTIC_TEXCOORD0,
						texCoord1: SEMANTIC_TEXCOORD1,
						texCoord2: SEMANTIC_TEXCOORD2,
						texCoord3: SEMANTIC_TEXCOORD3,
						texCoord4: SEMANTIC_TEXCOORD4,
						texCoord5: SEMANTIC_TEXCOORD5,
						texCoord6: SEMANTIC_TEXCOORD6,
						texCoord7: SEMANTIC_TEXCOORD7
				};
				for(var i = 0; i < modelData.vertices.length; i++){
						var vertexData = modelData.vertices[i];
						var formatDesc = [];
						for(var attributeName in vertexData){
								var attribute = vertexData[attributeName];
								formatDesc.push({
										semantic: attributeMap[attributeName],
										components: attribute.components,
										type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
										normalize: attributeMap[attributeName] === SEMANTIC_COLOR
								});
						}
						var vertexFormat = new VertexFormat(this._device, formatDesc);
						var numVertices = vertexData.position.data.length / vertexData.position.components;
						var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
						var iterator = new VertexIterator(vertexBuffer);
						for(var j = 0; j < numVertices; j++){
								for(var attributeName1 in vertexData){
										var attribute1 = vertexData[attributeName1];
										switch(attribute1.components){
												case 1:
														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j]);
														break;
												case 2:
														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j * 2], 1.0 - attribute1.data[j * 2 + 1]);
														break;
												case 3:
														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j * 3], attribute1.data[j * 3 + 1], attribute1.data[j * 3 + 2]);
														break;
												case 4:
														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j * 4], attribute1.data[j * 4 + 1], attribute1.data[j * 4 + 2], attribute1.data[j * 4 + 3]);
														break;
										}
								}
								iterator.next();
						}
						iterator.end();
						vertexBuffers.push(vertexBuffer);
				}
				return vertexBuffers;
		}
		_parseIndexBuffers(data, vertexBuffers) {
				var modelData = data.model;
				var indexBuffer = null;
				var indexData = null;
				var i;
				var numIndices = 0;
				for(i = 0; i < modelData.meshes.length; i++){
						var meshData = modelData.meshes[i];
						if (meshData.indices !== undefined) {
								numIndices += meshData.indices.length;
						}
				}
				var maxVerts = 0;
				for(i = 0; i < vertexBuffers.length; i++){
						maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
				}
				if (numIndices > 0) {
						if (maxVerts > 0xFFFF) {
								indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
								indexData = new Uint32Array(indexBuffer.lock());
						} else {
								indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
								indexData = new Uint16Array(indexBuffer.lock());
						}
				}
				return {
						buffer: indexBuffer,
						data: indexData
				};
		}
		_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
				var modelData = data.model;
				var meshes = [];
				var indexBase = 0;
				for(var i = 0; i < modelData.meshes.length; i++){
						var meshData = modelData.meshes[i];
						var meshAabb = meshData.aabb;
						var min = meshAabb.min;
						var max = meshAabb.max;
						var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
						var indexed = meshData.indices !== undefined;
						var mesh = new Mesh(this._device);
						mesh.vertexBuffer = vertexBuffers[meshData.vertices];
						mesh.indexBuffer[0] = indexed ? indexBuffer : null;
						mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
						mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
						mesh.primitive[0].count = meshData.count;
						mesh.primitive[0].indexed = indexed;
						mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
						mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
						mesh.aabb = aabb;
						if (indexed) {
								indexData.set(meshData.indices, indexBase);
								indexBase += meshData.indices.length;
						}
						meshes.push(mesh);
				}
				if (indexBuffer !== null) {
						indexBuffer.unlock();
				}
				return meshes;
		}
		_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
				var modelData = data.model;
				var meshInstances = [];
				var i;
				for(i = 0; i < modelData.meshInstances.length; i++){
						var meshInstanceData = modelData.meshInstances[i];
						var node = nodes[meshInstanceData.node];
						var mesh = meshes[meshInstanceData.mesh];
						var meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);
						if (mesh.skin) {
								var skinIndex = skins.indexOf(mesh.skin);
								meshInstance.skinInstance = skinInstances[skinIndex];
						}
						if (mesh.morph) {
								var morphIndex = morphs.indexOf(mesh.morph);
								meshInstance.morphInstance = morphInstances[morphIndex];
						}
						meshInstances.push(meshInstance);
				}
				return meshInstances;
		}
		constructor(modelHandler){
				this._device = modelHandler.device;
				this._defaultMaterial = modelHandler.defaultMaterial;
		}
}

class ModelHandler extends ResourceHandler {
		load(url, callback, asset) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var options = {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
						if (path.getExtension(url.original).toLowerCase() === '.glb') {
								options.responseType = Http.ResponseType.ARRAY_BUFFER;
						} else {
								options.responseType = Http.ResponseType.JSON;
						}
				}
				http.get(url.load, options, (err, response)=>{
						if (!callback) {
								return;
						}
						if (!err) {
								for(var i = 0; i < this._parsers.length; i++){
										var p = this._parsers[i];
										if (p.decider(url.original, response)) {
												p.parser.parse(response, (err, parseResult)=>{
														if (err) {
																callback(err);
														} else {
																callback(null, parseResult);
														}
												}, asset);
												return;
										}
								}
								callback('No parsers found');
						} else {
								callback("Error loading model: " + url.original + " [" + err + "]");
						}
				});
		}
		open(url, data) {
				return data;
		}
		patch(asset, assets) {
				if (!asset.resource) {
						return;
				}
				var data = asset.data;
				var self = this;
				asset.resource.meshInstances.forEach((meshInstance, i)=>{
						if (data.mapping) {
								var handleMaterial = function handleMaterial1(asset) {
										if (asset.resource) {
												meshInstance.material = asset.resource;
										} else {
												asset.once('load', handleMaterial);
												assets.load(asset);
										}
										asset.once('remove', (asset)=>{
												if (meshInstance.material === asset.resource) {
														meshInstance.material = self.defaultMaterial;
												}
										});
								};
								if (!data.mapping[i]) {
										meshInstance.material = self.defaultMaterial;
										return;
								}
								var id = data.mapping[i].material;
								var url = data.mapping[i].path;
								var material;
								if (id !== undefined) {
										if (!id) {
												meshInstance.material = self.defaultMaterial;
										} else {
												material = assets.get(id);
												if (material) {
														handleMaterial(material);
												} else {
														assets.once("add:" + id, handleMaterial);
												}
										}
								} else if (url) {
										var path = asset.getAbsoluteUrl(data.mapping[i].path);
										material = assets.getByUrl(path);
										if (material) {
												handleMaterial(material);
										} else {
												assets.once("add:url:" + path, handleMaterial);
										}
								}
						}
				});
		}
		addParser(parser, decider) {
				this._parsers.push({
						parser: parser,
						decider: decider
				});
		}
		constructor(app){
				super(app, 'model');
				this._parsers = [];
				this.device = app.graphicsDevice;
				this.assets = app.assets;
				this.defaultMaterial = getDefaultMaterial(this.device);
				this.addParser(new JsonModelParser(this), (url, data)=>{
						return path.getExtension(url) === '.json';
				});
				this.addParser(new GlbModelParser(this), (url, data)=>{
						return path.getExtension(url) === '.glb';
				});
		}
}

class SceneHandler extends ResourceHandler {
		load(url, callback) {
				SceneUtils.load(url, this.maxRetries, callback);
		}
		open(url, data) {
				this._app.systems.script.preloading = true;
				var parser = new SceneParser(this._app, false);
				var parent = parser.parse(data);
				var scene = this._app.scene;
				scene.root = parent;
				this._app.applySceneSettings(data.settings);
				this._app.systems.script.preloading = false;
				return scene;
		}
		constructor(app){
				super(app, 'scene');
		}
}

class ScriptTypes {
		static push(Type) {
				ScriptTypes._types.push(Type);
		}
}
ScriptTypes._types = [];

var reservedScriptNames = new Set([
		'system',
		'entity',
		'create',
		'destroy',
		'swap',
		'move',
		'data',
		"scripts",
		"_scripts",
		"_scriptsIndex",
		"_scriptsData",
		'enabled',
		'_oldState',
		'onEnable',
		'onDisable',
		'onPostStateChange',
		'_onSetEnabled',
		'_checkState',
		'_onBeforeRemove',
		'_onInitializeAttributes',
		'_onInitialize',
		'_onPostInitialize',
		'_onUpdate',
		'_onPostUpdate',
		'_callbacks',
		'_callbackActive',
		'has',
		'get',
		'on',
		'off',
		'fire',
		'once',
		'hasEvent'
]);
function getReservedScriptNames() {
		return reservedScriptNames;
}
function createScript(name, app) {
		if (reservedScriptNames.has(name)) {
				throw new Error("Script name '" + name + "' is reserved, please rename the script");
		}
		var scriptType = function scriptType(args) {
				EventHandler.prototype.initEventHandler.call(this);
				ScriptType.prototype.initScriptType.call(this, args);
		};
		scriptType.prototype = Object.create(ScriptType.prototype);
		scriptType.prototype.constructor = scriptType;
		scriptType.extend = ScriptType.extend;
		scriptType.attributes = new ScriptAttributes(scriptType);
		registerScript(scriptType, name, app);
		return scriptType;
}
var reservedAttributes = {};
ScriptAttributes.reservedNames.forEach((value, value2, set)=>{
		reservedAttributes[value] = 1;
});
createScript.reservedAttributes = reservedAttributes;
function registerScript(script, name, app) {
		if (typeof script !== 'function') {
				throw new Error("script class: '" + script + "' must be a constructor function (i.e. class).");
		}
		if (!(script.prototype instanceof Script)) {
				throw new Error("script class: '" + ScriptType.__getScriptName(script) + "' does not extend pc.Script.");
		}
		name = name || script.__name || ScriptType.__getScriptName(script);
		if (reservedScriptNames.has(name)) {
				throw new Error("script name: '" + name + "' is reserved, please change script name");
		}
		script.__name = name;
		var registry = app ? app.scripts : AppBase.getApplication().scripts;
		registry.add(script);
		ScriptTypes.push(script);
}

var toLowerCamelCase = (str)=>str[0].toLowerCase() + str.substring(1);
class ScriptHandler extends ResourceHandler {
		clearCache() {
				for(var key in this._cache){
						var element = this._cache[key];
						var parent = element.parentNode;
						if (parent) {
								parent.removeChild(element);
						}
				}
				this._cache = {};
		}
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var self = this;
				script.app = this._app;
				var onScriptLoad = (url.load, (err, url, extra)=>{
						if (!err) {
								var obj = {};
								for(var i = 0; i < ScriptTypes._types.length; i++){
										obj[ScriptTypes._types[i].name] = ScriptTypes._types[i];
								}
								ScriptTypes._types.length = 0;
								callback(null, obj, extra);
								var urlWithoutEndHash = url.split('&hash=')[0];
								delete self._loader._cache[ResourceLoader.makeKey(urlWithoutEndHash, "script")];
						} else {
								callback(err);
						}
				});
				var [basePath] = url.load.split('?');
				var isEsmScript = basePath.endsWith('.mjs');
				if (isEsmScript) {
						this._loadModule(basePath, onScriptLoad);
				} else {
						this._loadScript(url.load, onScriptLoad);
				}
		}
		open(url, data) {
				return data;
		}
		patch(asset, assets) {}
		_loadScript(url, callback) {
				var head = document.head;
				var element = document.createElement("script");
				this._cache[url] = element;
				element.async = false;
				element.addEventListener('error', (e)=>{
						callback("Script: " + e.target.src + " failed to load");
				}, false);
				var done = false;
				element.onload = element.onreadystatechange = function() {
						if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {
								done = true;
								callback(null, url, element);
						}
				};
				element.src = url;
				head.appendChild(element);
		}
		_loadModule(url, callback) {
				var isBrowserWithOrigin = platform.browser && window.location.origin !== 'null';
				var baseUrl = isBrowserWithOrigin ? window.location.origin + window.location.pathname : import.meta.url;
				var importUrl = new URL(url, baseUrl);
				import(/* @vite-ignore */ /* webpackIgnore: true */ importUrl.toString()).then((module)=>{
						var _this__app_assets_find_data, _this__app_assets_find;
						var filename = importUrl.pathname.split('/').pop();
						var scriptSchema = (_this__app_assets_find = this._app.assets.find(filename, "script")) == null ? void 0 : (_this__app_assets_find_data = _this__app_assets_find.data) == null ? void 0 : _this__app_assets_find_data.scripts;
						for(var key in module){
								var scriptClass = module[key];
								var extendsScriptType = scriptClass.prototype instanceof Script;
								if (extendsScriptType) {
										var scriptName = toLowerCamelCase(scriptClass.name);
										registerScript(scriptClass, scriptName);
										if (scriptSchema) this._app.scripts.addSchema(scriptName, scriptSchema[scriptName]);
								}
						}
						callback(null, url, null);
				}).catch((err)=>{
						callback(err);
				});
		}
		constructor(app){
				super(app, "script");
				this._scripts = {};
				this._cache = {};
		}
}

class ShaderHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				}, (err, response)=>{
						if (!err) {
								callback(null, response);
						} else {
								callback("Error loading shader resource: " + url.original + " [" + err + "]");
						}
				});
		}
		openBinary(data) {
				var _this_decoder;
				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
				return this.decoder.decode(data);
		}
		constructor(app){
				super(app, 'shader'), this.decoder = null;
		}
}

function onTextureAtlasLoaded(atlasAsset) {
		var spriteAsset = this;
		if (spriteAsset.resource) {
				spriteAsset.resource.atlas = atlasAsset.resource;
		}
}
function onTextureAtlasAdded(atlasAsset) {
		var spriteAsset = this;
		spriteAsset.registry.load(atlasAsset);
}
class SpriteHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				if (path.getExtension(url.original) === '.json') {
						http.get(url.load, {
								retry: this.maxRetries > 0,
								maxRetries: this.maxRetries
						}, (err, response)=>{
								if (!err) {
										callback(null, response);
								} else {
										callback(err);
								}
						});
				}
		}
		open(url, data) {
				var sprite = new Sprite(this._device);
				if (url) {
						sprite.__data = data;
				}
				return sprite;
		}
		patch(asset, assets) {
				var sprite = asset.resource;
				if (sprite.__data) {
						asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
						asset.data.renderMode = sprite.__data.renderMode;
						asset.data.frameKeys = sprite.__data.frameKeys;
						if (sprite.__data.textureAtlasAsset) {
								var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
								if (atlas) {
										asset.data.textureAtlasAsset = atlas.id;
								} else {
										console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
								}
						}
				}
				sprite.startUpdate();
				sprite.renderMode = asset.data.renderMode;
				sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
				sprite.frameKeys = asset.data.frameKeys;
				this._updateAtlas(asset);
				sprite.endUpdate();
				asset.off('change', this._onAssetChange, this);
				asset.on('change', this._onAssetChange, this);
		}
		_updateAtlas(asset) {
				var sprite = asset.resource;
				if (!asset.data.textureAtlasAsset) {
						sprite.atlas = null;
						return;
				}
				this._assets.off("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
				this._assets.on("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
				var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
				if (atlasAsset && atlasAsset.resource) {
						sprite.atlas = atlasAsset.resource;
				} else {
						if (!atlasAsset) {
								this._assets.off("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
								this._assets.on("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
						} else {
								this._assets.load(atlasAsset);
						}
				}
		}
		_onAssetChange(asset, attribute, value, oldValue) {
				if (attribute === 'data') {
						if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
								this._assets.off("load:" + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
								this._assets.off("add:" + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
						}
				}
		}
		constructor(app){
				super(app, 'sprite');
				this._assets = app.assets;
				this._device = app.graphicsDevice;
		}
}

class Template {
		instantiate() {
				if (!this._templateRoot) {
						this._parseTemplate();
				}
				return this._templateRoot.clone();
		}
		_parseTemplate() {
				var parser = new SceneParser(this._app, true);
				this._templateRoot = parser.parse(this._data);
		}
		constructor(app, data){
				this._templateRoot = null;
				this._app = app;
				this._data = data;
		}
}

class TemplateHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var options = {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				http.get(url.load, options, (err, response)=>{
						if (err) {
								callback("Error requesting template: " + url.original);
						} else {
								callback(err, response);
						}
				});
		}
		open(url, data) {
				return new Template(this._app, data);
		}
		openBinary(data) {
				var _this_decoder;
				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
				return new Template(this._app, JSON.parse(this.decoder.decode(data)));
		}
		constructor(app){
				super(app, 'template'), this.decoder = null;
		}
}

class TextHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				http.get(url.load, {
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				}, (err, response)=>{
						if (!err) {
								callback(null, response);
						} else {
								callback("Error loading text resource: " + url.original + " [" + err + "]");
						}
				});
		}
		openBinary(data) {
				var _this_decoder;
				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
				return this.decoder.decode(data);
		}
		constructor(app){
				super(app, 'text'), this.decoder = null;
		}
}

var JSON_ADDRESS_MODE$1 = {
		'repeat': ADDRESS_REPEAT,
		'clamp': ADDRESS_CLAMP_TO_EDGE,
		'mirror': ADDRESS_MIRRORED_REPEAT
};
var JSON_FILTER_MODE$1 = {
		'nearest': FILTER_NEAREST,
		'linear': FILTER_LINEAR,
		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
};
var regexFrame = /^data\.frames\.(\d+)$/;
class TextureAtlasHandler extends ResourceHandler {
		load(url, callback) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				var self = this;
				var handler = this._loader.getHandler('texture');
				if (path.getExtension(url.original) === '.json') {
						http.get(url.load, {
								retry: this.maxRetries > 0,
								maxRetries: this.maxRetries
						}, (err, response)=>{
								if (!err) {
										var textureUrl = url.original.replace('.json', '.png');
										self._loader.load(textureUrl, 'texture', (err, texture)=>{
												if (err) {
														callback(err);
												} else {
														callback(null, {
																data: response,
																texture: texture
														});
												}
										});
								} else {
										callback(err);
								}
						});
				} else {
						handler.load(url, callback);
				}
		}
		open(url, data, asset) {
				var resource = new TextureAtlas();
				if (data.texture && data.data) {
						resource.texture = data.texture;
						resource.__data = data.data;
				} else {
						var handler = this._loader.getHandler('texture');
						var texture = handler.open(url, data, asset);
						if (!texture) return null;
						resource.texture = texture;
				}
				return resource;
		}
		patch(asset, assets) {
				if (!asset.resource) {
						return;
				}
				if (asset.resource.__data) {
						if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
						if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
						if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
						if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
						if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
						if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
						if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
						asset.data.frames = asset.resource.__data.frames;
						delete asset.resource.__data;
				}
				var texture = asset.resource.texture;
				if (texture) {
						texture.name = asset.name;
						if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) {
								texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
						}
						if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) {
								texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
						}
						if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) {
								texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
						}
						if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) {
								texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
						}
						if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) {
								texture.mipmaps = asset.data.mipmaps;
						}
						if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) {
								texture.anisotropy = asset.data.anisotropy;
						}
						if (asset.data.hasOwnProperty('rgbm')) {
								var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
								if (texture.type !== type) {
										texture.type = type;
								}
						}
				}
				asset.resource.texture = texture;
				var frames = {};
				for(var key in asset.data.frames){
						var frame = asset.data.frames[key];
						frames[key] = {
								rect: new Vec4(frame.rect),
								pivot: new Vec2(frame.pivot),
								border: new Vec4(frame.border)
						};
				}
				asset.resource.frames = frames;
				asset.off('change', this._onAssetChange, this);
				asset.on('change', this._onAssetChange, this);
		}
		_onAssetChange(asset, attribute, value) {
				var frame;
				if (attribute === 'data' || attribute === 'data.frames') {
						var frames = {};
						for(var key in value.frames){
								frame = value.frames[key];
								frames[key] = {
										rect: new Vec4(frame.rect),
										pivot: new Vec2(frame.pivot),
										border: new Vec4(frame.border)
								};
						}
						asset.resource.frames = frames;
				} else {
						var match = attribute.match(regexFrame);
						if (match) {
								var frameKey = match[1];
								if (value) {
										if (!asset.resource.frames[frameKey]) {
												asset.resource.frames[frameKey] = {
														rect: new Vec4(value.rect),
														pivot: new Vec2(value.pivot),
														border: new Vec4(value.border)
												};
										} else {
												frame = asset.resource.frames[frameKey];
												frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
												frame.pivot.set(value.pivot[0], value.pivot[1]);
												frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
										}
										asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
								} else {
										if (asset.resource.frames[frameKey]) {
												delete asset.resource.frames[frameKey];
												asset.resource.fire('remove:frame', frameKey);
										}
								}
						}
				}
		}
		constructor(app){
				super(app, 'textureatlas');
				this._loader = app.loader;
		}
}

function BasisWorker() {
		var BASIS_FORMAT = {
				cTFETC1: 0,
				cTFETC2: 1,
				cTFBC1: 2,
				cTFBC3: 3,
				cTFPVRTC1_4_RGB: 8,
				cTFPVRTC1_4_RGBA: 9,
				cTFASTC_4x4: 10,
				cTFATC_RGB: 11,
				cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
				cTFRGBA32: 13,
				cTFRGB565: 14,
				cTFRGBA4444: 16
		};
		var opaqueMapping = {
				astc: BASIS_FORMAT.cTFASTC_4x4,
				dxt: BASIS_FORMAT.cTFBC1,
				etc1: BASIS_FORMAT.cTFETC1,
				etc2: BASIS_FORMAT.cTFETC1,
				pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
				atc: BASIS_FORMAT.cTFATC_RGB,
				none: BASIS_FORMAT.cTFRGB565
		};
		var alphaMapping = {
				astc: BASIS_FORMAT.cTFASTC_4x4,
				dxt: BASIS_FORMAT.cTFBC3,
				etc1: BASIS_FORMAT.cTFRGBA4444,
				etc2: BASIS_FORMAT.cTFETC2,
				pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
				atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
				none: BASIS_FORMAT.cTFRGBA4444
		};
		var PIXEL_FORMAT = {
				ETC1: 21,
				ETC2_RGB: 22,
				ETC2_RGBA: 23,
				DXT1: 8,
				DXT5: 10,
				PVRTC_4BPP_RGB_1: 26,
				PVRTC_4BPP_RGBA_1: 27,
				ASTC_4x4: 28,
				ATC_RGB: 29,
				ATC_RGBA: 30,
				R8_G8_B8_A8: 7,
				R5_G6_B5: 3,
				R4_G4_B4_A4: 5
		};
		var basisToEngineMapping = (basisFormat, deviceDetails)=>{
				switch(basisFormat){
						case BASIS_FORMAT.cTFETC1:
								return deviceDetails.formats.etc2 ? PIXEL_FORMAT.ETC2_RGB : PIXEL_FORMAT.ETC1;
						case BASIS_FORMAT.cTFETC2:
								return PIXEL_FORMAT.ETC2_RGBA;
						case BASIS_FORMAT.cTFBC1:
								return PIXEL_FORMAT.DXT1;
						case BASIS_FORMAT.cTFBC3:
								return PIXEL_FORMAT.DXT5;
						case BASIS_FORMAT.cTFPVRTC1_4_RGB:
								return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;
						case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
								return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;
						case BASIS_FORMAT.cTFASTC_4x4:
								return PIXEL_FORMAT.ASTC_4x4;
						case BASIS_FORMAT.cTFATC_RGB:
								return PIXEL_FORMAT.ATC_RGB;
						case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
								return PIXEL_FORMAT.ATC_RGBA;
						case BASIS_FORMAT.cTFRGBA32:
								return PIXEL_FORMAT.R8_G8_B8_A8;
						case BASIS_FORMAT.cTFRGB565:
								return PIXEL_FORMAT.R5_G6_B5;
						case BASIS_FORMAT.cTFRGBA4444:
								return PIXEL_FORMAT.R4_G4_B4_A4;
				}
		};
		var unswizzleGGGR = (data)=>{
				var genB = function genB(R, G) {
						var r = R * (2.0 / 255.0) - 1.0;
						var g = G * (2.0 / 255.0) - 1.0;
						var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
						return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
				};
				for(var offset = 0; offset < data.length; offset += 4){
						var R = data[offset + 3];
						var G = data[offset + 1];
						data[offset + 0] = R;
						data[offset + 2] = genB(R, G);
						data[offset + 3] = 255;
				}
				return data;
		};
		var pack565 = (data)=>{
				var result = new Uint16Array(data.length / 4);
				for(var offset = 0; offset < data.length; offset += 4){
						var R = data[offset + 0];
						var G = data[offset + 1];
						var B = data[offset + 2];
						result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
				}
				return result;
		};
		var isPOT = (width, height)=>{
				return (width & width - 1) === 0 && (height & height - 1) === 0;
		};
		var performanceNow = ()=>{
				return typeof performance !== 'undefined' ? performance.now() : 0;
		};
		var basis;
		var rgbPriority;
		var rgbaPriority;
		var chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC)=>{
				if (isUASTC) {
						if (deviceDetails.formats.astc) {
								return 'astc';
						}
				} else {
						if (hasAlpha) {
								if (deviceDetails.formats.etc2) {
										return 'etc2';
								}
						} else {
								if (deviceDetails.formats.etc2) {
										return 'etc2';
								}
								if (deviceDetails.formats.etc1) {
										return 'etc1';
								}
						}
				}
				var testInOrder = (priority)=>{
						for(var i = 0; i < priority.length; ++i){
								var format = priority[i];
								if (deviceDetails.formats[format]) {
										return format;
								}
						}
						return 'none';
				};
				return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
		};
		var dimensionsValid = (width, height, format)=>{
				switch(format){
						case BASIS_FORMAT.cTFETC1:
						case BASIS_FORMAT.cTFETC2:
								return true;
						case BASIS_FORMAT.cTFBC1:
						case BASIS_FORMAT.cTFBC3:
								return (width & 0x3) === 0 && (height & 0x3) === 0;
						case BASIS_FORMAT.cTFPVRTC1_4_RGB:
						case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
								return isPOT(width, height);
						case BASIS_FORMAT.cTFASTC_4x4:
								return true;
						case BASIS_FORMAT.cTFATC_RGB:
						case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
								return true;
				}
				return false;
		};
		var transcodeKTX2 = (url, data, options)=>{
				if (!basis.KTX2File) {
						throw new Error('Basis transcoder module does not include support for KTX2.');
				}
				var funcStart = performanceNow();
				var basisFile = new basis.KTX2File(new Uint8Array(data));
				var width = basisFile.getWidth();
				var height = basisFile.getHeight();
				var levels = basisFile.getLevels();
				var hasAlpha = !!basisFile.getHasAlpha();
				var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
				if (!width || !height || !levels) {
						basisFile.close();
						basisFile.delete();
						throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " levels=" + levels);
				}
				var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
				var unswizzle = !!options.isGGGR && format === 'pvr';
				var basisFormat;
				if (unswizzle) {
						basisFormat = BASIS_FORMAT.cTFRGBA32;
				} else {
						basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
						if (!dimensionsValid(width, height, basisFormat)) {
								basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
						}
				}
				if (!basisFile.startTranscoding()) {
						basisFile.close();
						basisFile.delete();
						throw new Error("Failed to start transcoding url=" + url);
				}
				var i;
				var levelData = [];
				for(var mip = 0; mip < levels; ++mip){
						var dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
						var dst = new Uint8Array(dstSize);
						if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
								basisFile.close();
								basisFile.delete();
								throw new Error("Failed to transcode image url=" + url);
						}
						var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
						levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
				}
				basisFile.close();
				basisFile.delete();
				if (unswizzle) {
						basisFormat = BASIS_FORMAT.cTFRGB565;
						for(i = 0; i < levelData.length; ++i){
								levelData[i] = pack565(unswizzleGGGR(levelData[i]));
						}
				}
				return {
						format: basisToEngineMapping(basisFormat, options.deviceDetails),
						width: width,
						height: height,
						levels: levelData,
						cubemap: false,
						transcodeTime: performanceNow() - funcStart,
						url: url,
						unswizzledGGGR: unswizzle
				};
		};
		var transcodeBasis = (url, data, options)=>{
				var funcStart = performanceNow();
				var basisFile = new basis.BasisFile(new Uint8Array(data));
				var width = basisFile.getImageWidth(0, 0);
				var height = basisFile.getImageHeight(0, 0);
				var images = basisFile.getNumImages();
				var levels = basisFile.getNumLevels(0);
				var hasAlpha = !!basisFile.getHasAlpha();
				var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
				if (!width || !height || !images || !levels) {
						basisFile.close();
						basisFile.delete();
						throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " images=" + images + " levels=" + levels);
				}
				var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
				var unswizzle = !!options.isGGGR && format === 'pvr';
				var basisFormat;
				if (unswizzle) {
						basisFormat = BASIS_FORMAT.cTFRGBA32;
				} else {
						basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
						if (!dimensionsValid(width, height, basisFormat)) {
								basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
						}
				}
				if (!basisFile.startTranscoding()) {
						basisFile.close();
						basisFile.delete();
						throw new Error("Failed to start transcoding url=" + url);
				}
				var i;
				var levelData = [];
				for(var mip = 0; mip < levels; ++mip){
						var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
						var dst = new Uint8Array(dstSize);
						if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
								if (mip === levels - 1 && dstSize === levelData[mip - 1].buffer.byteLength) {
										dst.set(new Uint8Array(levelData[mip - 1].buffer));
										console.warn("Failed to transcode last mipmap level, using previous level instead url=" + url);
								} else {
										basisFile.close();
										basisFile.delete();
										throw new Error("Failed to transcode image url=" + url);
								}
						}
						var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
						levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
				}
				basisFile.close();
				basisFile.delete();
				if (unswizzle) {
						basisFormat = BASIS_FORMAT.cTFRGB565;
						for(i = 0; i < levelData.length; ++i){
								levelData[i] = pack565(unswizzleGGGR(levelData[i]));
						}
				}
				return {
						format: basisToEngineMapping(basisFormat, options.deviceDetails),
						width: width,
						height: height,
						levels: levelData,
						cubemap: false,
						transcodeTime: performanceNow() - funcStart,
						url: url,
						unswizzledGGGR: unswizzle
				};
		};
		var transcode = (url, data, options)=>{
				return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
		};
		var workerTranscode = (url, data, options)=>{
				try {
						var result = transcode(url, data, options);
						result.levels = result.levels.map((v)=>v.buffer);
						self.postMessage({
								url: url,
								data: result
						}, result.levels);
				} catch (err) {
						self.postMessage({
								url: url,
								err: err
						}, null);
				}
		};
		var workerInit = (config, callback)=>{
				var instantiateWasmFunc = (imports, successCallback)=>{
						WebAssembly.instantiate(config.module, imports).then((result)=>{
								successCallback(result);
						}).catch((reason)=>{
								console.error("instantiate failed + " + reason);
						});
						return {};
				};
				self.BASIS(config.module ? {
						instantiateWasm: instantiateWasmFunc
				} : null).then((instance)=>{
						instance.initializeBasis();
						basis = instance;
						rgbPriority = config.rgbPriority;
						rgbaPriority = config.rgbaPriority;
						callback(null);
				});
		};
		var queue = [];
		self.onmessage = (message)=>{
				var data = message.data;
				switch(data.type){
						case 'init':
								workerInit(data.config, ()=>{
										for(var i = 0; i < queue.length; ++i){
												workerTranscode(queue[i].url, queue[i].data, queue[i].options);
										}
										queue.length = 0;
								});
								break;
						case 'transcode':
								if (basis) {
										workerTranscode(data.url, data.data, data.options);
								} else {
										queue.push(data);
								}
								break;
				}
		};
}

var getCompressionFormats = (device)=>{
		return {
				astc: !!device.extCompressedTextureASTC,
				atc: !!device.extCompressedTextureATC,
				dxt: !!device.extCompressedTextureS3TC,
				etc1: !!device.extCompressedTextureETC1,
				etc2: !!device.extCompressedTextureETC,
				pvr: !!device.extCompressedTexturePVRTC
		};
};
var prepareWorkerModules = (config, callback)=>{
		var getWorkerBlob = (basisCode)=>{
				var code = [
						'/* basis */',
						basisCode,
						'',
						"(" + BasisWorker.toString() + ")()\n\n"
				].join('\n');
				return new Blob([
						code
				], {
						type: "application/javascript"
				});
		};
		var wasmSupported = ()=>{
				try {
						if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
								var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
								if (module instanceof WebAssembly.Module) {
										return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
								}
						}
				} catch (e) {}
				return false;
		};
		var sendResponse = (basisCode, module)=>{
				callback(null, {
						workerUrl: URL.createObjectURL(getWorkerBlob(basisCode)),
						module: module,
						rgbPriority: config.rgbPriority,
						rgbaPriority: config.rgbaPriority
				});
		};
		var options = {
				cache: true,
				responseType: 'text',
				retry: config.maxRetries > 0,
				maxRetries: config.maxRetries
		};
		if (config.glueUrl && config.wasmUrl && wasmSupported()) {
				var basisCode = null;
				var module = null;
				http.get(config.glueUrl, options, (err, response)=>{
						if (err) {
								callback(err);
						} else {
								if (module) {
										sendResponse(response, module);
								} else {
										basisCode = response;
								}
						}
				});
				var fetchPromise = fetch(config.wasmUrl);
				var compileManual = ()=>{
						fetchPromise.then((result)=>result.arrayBuffer()).then((buffer)=>WebAssembly.compile(buffer)).then((module_)=>{
								if (basisCode) {
										sendResponse(basisCode, module_);
								} else {
										module = module_;
								}
						}).catch((err)=>{
								callback(err, null);
						});
				};
				if (WebAssembly.compileStreaming) {
						WebAssembly.compileStreaming(fetchPromise).then((module_)=>{
								if (basisCode) {
										sendResponse(basisCode, module_);
								} else {
										module = module_;
								}
						}).catch((err)=>{
								compileManual();
						});
				} else {
						compileManual();
				}
		} else {
				http.get(config.fallbackUrl, options, (err, response)=>{
						if (err) {
								callback(err, null);
						} else {
								sendResponse(response, null);
						}
				});
		}
};
class BasisQueue {
		enqueueJob(url, data, callback, options) {
				if (this.callbacks.hasOwnProperty(url)) {
						this.callbacks[url].push(callback);
				} else {
						this.callbacks[url] = [
								callback
						];
						var job = {
								url: url,
								data: data,
								options: options
						};
						if (this.clients.length > 0) {
								this.clients.shift().run(job);
						} else {
								this.queue.push(job);
						}
				}
		}
		enqueueClient(client) {
				if (this.queue.length > 0) {
						client.run(this.queue.shift());
				} else {
						this.clients.push(client);
				}
		}
		handleResponse(url, err, data) {
				var callback = this.callbacks[url];
				if (err) {
						for(var i = 0; i < callback.length; ++i){
								callback[i](err);
						}
				} else {
						if (data.format === PIXELFORMAT_RGB565 || data.format === PIXELFORMAT_RGBA4) {
								data.levels = data.levels.map((v)=>{
										return new Uint16Array(v);
								});
						} else {
								data.levels = data.levels.map((v)=>{
										return new Uint8Array(v);
								});
						}
						for(var i1 = 0; i1 < callback.length; ++i1){
								callback[i1](null, data);
						}
				}
				delete this.callbacks[url];
		}
		constructor(){
				this.callbacks = {};
				this.queue = [];
				this.clients = [];
		}
}
class BasisClient {
		run(job) {
				var transfer = [];
				if (job.data instanceof ArrayBuffer) {
						transfer.push(job.data);
				}
				this.worker.postMessage({
						type: 'transcode',
						url: job.url,
						format: job.format,
						data: job.data,
						options: job.options
				}, transfer);
				if (this.eager) {
						this.queue.enqueueClient(this);
				}
		}
		constructor(queue, config, eager){
				this.queue = queue;
				this.worker = new Worker(config.workerUrl);
				this.worker.addEventListener('message', (message)=>{
						var data = message.data;
						this.queue.handleResponse(data.url, data.err, data.data);
						if (!this.eager) {
								this.queue.enqueueClient(this);
						}
				});
				this.worker.postMessage({
						type: 'init',
						config: config
				});
				this.eager = eager;
		}
}
var defaultNumWorkers = 1;
var defaultRgbPriority = [
		'etc2',
		'etc1',
		'astc',
		'dxt',
		'pvr',
		'atc'
];
var defaultRgbaPriority = [
		'astc',
		'dxt',
		'etc2',
		'pvr',
		'atc'
];
var defaultMaxRetries = 5;
var queue = new BasisQueue();
var lazyConfig = null;
var initializing = false;
function basisInitialize(config) {
		if (initializing) {
				return;
		}
		if (!config) {
				config = lazyConfig || {};
		} else if (config.lazyInit) {
				lazyConfig = config;
				return;
		}
		if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
				var moduleConfig = WasmModule.getConfig('BASIS');
				if (moduleConfig) {
						config = {
								glueUrl: moduleConfig.glueUrl,
								wasmUrl: moduleConfig.wasmUrl,
								fallbackUrl: moduleConfig.fallbackUrl,
								numWorkers: moduleConfig.numWorkers
						};
				}
		}
		if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
				initializing = true;
				var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
				var eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
				config.rgbPriority = config.rgbPriority || defaultRgbPriority;
				config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
				config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;
				prepareWorkerModules(config, (err, clientConfig)=>{
						if (err) {
								console.error("failed to initialize basis worker: " + err);
						} else {
								for(var i = 0; i < numWorkers; ++i){
										queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
								}
						}
				});
		}
}
var deviceDetails = null;
function basisTranscode(device, url, data, callback, options) {
		basisInitialize();
		if (!deviceDetails) {
				deviceDetails = {
						formats: getCompressionFormats(device)
				};
		}
		queue.enqueueJob(url, data, callback, {
				deviceDetails: deviceDetails,
				isGGGR: !!(options == null ? void 0 : options.isGGGR),
				isKTX2: !!(options == null ? void 0 : options.isKTX2)
		});
		return initializing;
}

class TextureParser {
		load(url, callback, asset) {
				throw new Error('not implemented');
		}
		open(url, data, device) {
				throw new Error('not implemented');
		}
}

function _extends$5() {
		_extends$5 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$5.apply(this, arguments);
}
class BasisParser extends TextureParser {
		load(url, callback, asset) {
				var device = this.device;
				var transcode = (data)=>{
						var _asset_file_variants_basis, _asset_file_variants, _asset_file;
						var basisModuleFound = basisTranscode(device, url.load, data, callback, {
								isGGGR: ((asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : (_asset_file_variants = _asset_file.variants) == null ? void 0 : (_asset_file_variants_basis = _asset_file_variants.basis) == null ? void 0 : _asset_file_variants_basis.opt) & 8) !== 0
						});
						if (!basisModuleFound) {
								callback("Basis module not found. Asset [" + asset.name + "](" + asset.getFileUrl() + ") basis texture variant will not be loaded.");
						}
				};
				Asset.fetchArrayBuffer(url.load, (err, result)=>{
						if (err) {
								callback(err);
						} else {
								transcode(result);
						}
				}, asset, this.maxRetries);
		}
		open(url, data, device, textureOptions) {
				if (textureOptions === void 0) textureOptions = {};
				var format = textureOptions.srgb ? pixelFormatLinearToGamma(data.format) : data.format;
				var texture = new Texture(device, _extends$5({
						name: url,
						addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						width: data.width,
						height: data.height,
						format: format,
						cubemap: data.cubemap,
						levels: data.levels
				}, textureOptions));
				texture.upload();
				return texture;
		}
		constructor(registry, device){
				super();
				this.device = device;
				this.maxRetries = 0;
		}
}

function _extends$4() {
		_extends$4 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$4.apply(this, arguments);
}
class ImgParser extends TextureParser {
		load(url, callback, asset) {
				var _asset_file;
				var hasContents = !!(asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : _asset_file.contents);
				if (hasContents) {
						if (this.device.supportsImageBitmap) {
								this._loadImageBitmapFromBlob(new Blob([
										asset.file.contents
								]), callback);
								return;
						}
						url = {
								load: URL.createObjectURL(new Blob([
										asset.file.contents
								])),
								original: url.original
						};
				}
				var handler = (err, result)=>{
						if (hasContents) {
								URL.revokeObjectURL(url.load);
						}
						callback(err, result);
				};
				var crossOrigin;
				if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
						crossOrigin = asset.options.crossOrigin;
				} else if (ABSOLUTE_URL.test(url.load)) {
						crossOrigin = this.crossOrigin;
				}
				if (this.device.supportsImageBitmap) {
						this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
				} else {
						this._loadImage(url.load, url.original, crossOrigin, handler);
				}
		}
		open(url, data, device, textureOptions) {
				if (textureOptions === void 0) textureOptions = {};
				var texture = new Texture(device, _extends$4({
						name: url,
						width: data.width,
						height: data.height,
						format: textureOptions.srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8
				}, textureOptions));
				texture.setSource(data);
				return texture;
		}
		_loadImage(url, originalUrl, crossOrigin, callback) {
				var image = new Image();
				if (crossOrigin) {
						image.crossOrigin = crossOrigin;
				}
				var retries = 0;
				var maxRetries = this.maxRetries;
				var retryTimeout;
				image.onload = function() {
						callback(null, image);
				};
				image.onerror = function() {
						if (retryTimeout) return;
						if (maxRetries > 0 && ++retries <= maxRetries) {
								var retryDelay = Math.pow(2, retries) * 100;
								console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
								var idx = url.indexOf('?');
								var separator = idx >= 0 ? '&' : '?';
								retryTimeout = setTimeout(()=>{
										image.src = url + separator + "retry=" + Date.now();
										retryTimeout = null;
								}, retryDelay);
						} else {
								callback("Error loading Texture from: '" + originalUrl + "'");
						}
				};
				image.src = url;
		}
		_loadImageBitmap(url, originalUrl, crossOrigin, callback) {
				var options = {
						cache: true,
						responseType: 'blob',
						retry: this.maxRetries > 0,
						maxRetries: this.maxRetries
				};
				http.get(url, options, (err, blob)=>{
						if (err) {
								callback(err);
						} else {
								this._loadImageBitmapFromBlob(blob, callback);
						}
				});
		}
		_loadImageBitmapFromBlob(blob, callback) {
				createImageBitmap(blob, {
						premultiplyAlpha: 'none',
						colorSpaceConversion: 'none'
				}).then((imageBitmap)=>callback(null, imageBitmap)).catch((e)=>callback(e));
		}
		constructor(registry, device){
				super();
				this.crossOrigin = registry.prefix ? 'anonymous' : null;
				this.maxRetries = 0;
				this.device = device;
		}
}

function _extends$3() {
		_extends$3 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$3.apply(this, arguments);
}
var IDENTIFIER = [
		0x58544BAB,
		0xBB313120,
		0x0A1A0A0D
];
var KNOWN_FORMATS = {
		0x83F0: PIXELFORMAT_DXT1,
		0x83F2: PIXELFORMAT_DXT3,
		0x83F3: PIXELFORMAT_DXT5,
		0x8D64: PIXELFORMAT_ETC1,
		0x9274: PIXELFORMAT_ETC2_RGB,
		0x9278: PIXELFORMAT_ETC2_RGBA,
		0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
		0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
		0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
		0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
		0x8051: PIXELFORMAT_RGB8,
		0x8058: PIXELFORMAT_RGBA8,
		0x8C41: PIXELFORMAT_SRGB8,
		0x8C43: PIXELFORMAT_SRGBA8,
		0x8C3A: PIXELFORMAT_111110F,
		0x881B: PIXELFORMAT_RGB16F,
		0x881A: PIXELFORMAT_RGBA16F
};
function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
		return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
}
class KtxParser extends TextureParser {
		load(url, callback, asset) {
				Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		}
		open(url, data, device, textureOptions) {
				if (textureOptions === void 0) textureOptions = {};
				var textureData = this.parse(data);
				if (!textureData) {
						return null;
				}
				var format = textureOptions.srgb ? pixelFormatLinearToGamma(textureData.format) : textureData.format;
				var texture = new Texture(device, _extends$3({
						name: url,
						addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						width: textureData.width,
						height: textureData.height,
						format: format,
						cubemap: textureData.cubemap,
						levels: textureData.levels
				}, textureOptions));
				texture.upload();
				return texture;
		}
		parse(data) {
				var dataU32 = new Uint32Array(data);
				if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
						return null;
				}
				var header = {
						endianness: dataU32[3],
						glType: dataU32[4],
						glTypeSize: dataU32[5],
						glFormat: dataU32[6],
						glInternalFormat: dataU32[7],
						glBaseInternalFormat: dataU32[8],
						pixelWidth: dataU32[9],
						pixelHeight: dataU32[10],
						pixelDepth: dataU32[11],
						numberOfArrayElements: dataU32[12],
						numberOfFaces: dataU32[13],
						numberOfMipmapLevels: dataU32[14],
						bytesOfKeyValueData: dataU32[15]
				};
				if (header.pixelDepth > 1) {
						return null;
				}
				if (header.numberOfArrayElements !== 0) {
						return null;
				}
				var format = KNOWN_FORMATS[header.glInternalFormat];
				if (format === undefined) {
						return null;
				}
				var offset = 16 + header.bytesOfKeyValueData / 4;
				var isCubemap = header.numberOfFaces > 1;
				var levels = [];
				for(var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++){
						var imageSizeInBytes = dataU32[offset++];
						if (isCubemap) {
								levels.push([]);
						}
						var target = isCubemap ? levels[mipmapLevel] : levels;
						for(var face = 0; face < (isCubemap ? 6 : 1); ++face){
								target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
								offset += imageSizeInBytes + 3 >> 2;
						}
				}
				return {
						format: format,
						width: header.pixelWidth,
						height: header.pixelHeight,
						levels: levels,
						cubemap: isCubemap
				};
		}
		constructor(registry){
				super();
				this.maxRetries = 0;
		}
}

function _extends$2() {
		_extends$2 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$2.apply(this, arguments);
}
var KHRConstants = {
		KHR_DF_MODEL_UASTC: 166
};
class Ktx2Parser extends TextureParser {
		load(url, callback, asset) {
				Asset.fetchArrayBuffer(url.load, (err, result)=>{
						if (err) {
								callback(err, result);
						} else {
								this.parse(result, url, callback, asset);
						}
				}, asset, this.maxRetries);
		}
		open(url, data, device, textureOptions) {
				if (textureOptions === void 0) textureOptions = {};
				var format = textureOptions.srgb ? pixelFormatLinearToGamma(data.format) : data.format;
				var texture = new Texture(device, _extends$2({
						name: url,
						addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						width: data.width,
						height: data.height,
						format: format,
						cubemap: data.cubemap,
						levels: data.levels
				}, textureOptions));
				texture.upload();
				return texture;
		}
		parse(arraybuffer, url, callback, asset) {
				var rs = new ReadStream(arraybuffer);
				var magic = [
						rs.readU32be(),
						rs.readU32be(),
						rs.readU32be()
				];
				if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
						return null;
				}
				var header = {
						vkFormat: rs.readU32(),
						typeSize: rs.readU32(),
						pixelWidth: rs.readU32(),
						pixelHeight: rs.readU32(),
						pixelDepth: rs.readU32(),
						layerCount: rs.readU32(),
						faceCount: rs.readU32(),
						levelCount: rs.readU32(),
						supercompressionScheme: rs.readU32()
				};
				var index = {
						dfdByteOffset: rs.readU32(),
						dfdByteLength: rs.readU32(),
						kvdByteOffset: rs.readU32(),
						kvdByteLength: rs.readU32(),
						sgdByteOffset: rs.readU64(),
						sgdByteLength: rs.readU64()
				};
				var levels = [];
				for(var i = 0; i < Math.max(1, header.levelCount); ++i){
						levels.push({
								byteOffset: rs.readU64(),
								byteLength: rs.readU64(),
								uncompressedByteLength: rs.readU64()
						});
				}
				var dfdTotalSize = rs.readU32();
				if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
						return null;
				}
				rs.skip(8);
				var colorModel = rs.readU8();
				rs.skip(index.dfdByteLength - 9);
				rs.skip(index.kvdByteLength);
				if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
						var _asset_file_variants_basis, _asset_file_variants, _asset_file;
						var basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
								isGGGR: ((asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : (_asset_file_variants = _asset_file.variants) == null ? void 0 : (_asset_file_variants_basis = _asset_file_variants.basis) == null ? void 0 : _asset_file_variants_basis.opt) & 8) !== 0,
								isKTX2: true
						});
						if (!basisModuleFound) {
								callback("Basis module not found. Asset [" + asset.name + "](" + asset.getFileUrl() + ") basis texture variant will not be loaded.");
						}
				} else {
						callback('unsupported KTX2 pixel format');
				}
		}
		constructor(registry, device){
				super();
				this.maxRetries = 0;
				this.device = device;
		}
}

function _extends$1() {
		_extends$1 = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends$1.apply(this, arguments);
}
class DdsParser extends TextureParser {
		load(url, callback, asset) {
				Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		}
		open(url, data, device, textureOptions) {
				if (textureOptions === void 0) textureOptions = {};
				var header = new Uint32Array(data, 0, 128 / 4);
				var width = header[4];
				var height = header[3];
				var mips = Math.max(header[7], 1);
				var isFourCc = header[20] === 4;
				var fcc = header[21];
				var bpp = header[22];
				var isCubemap = header[28] === 65024;
				var FCC_DXT1 = 827611204;
				var FCC_DXT5 = 894720068;
				var FCC_FP16 = 113;
				var FCC_FP32 = 116;
				var FCC_ETC1 = 826496069;
				var FCC_PVRTC_2BPP_RGB_1 = 825438800;
				var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
				var FCC_PVRTC_4BPP_RGB_1 = 825439312;
				var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
				var compressed = false;
				var etc1 = false;
				var pvrtc2 = false;
				var pvrtc4 = false;
				var format = null;
				var componentSize = 1;
				var texture;
				if (isFourCc) {
						if (fcc === FCC_DXT1) {
								format = PIXELFORMAT_DXT1;
								compressed = true;
						} else if (fcc === FCC_DXT5) {
								format = PIXELFORMAT_DXT5;
								compressed = true;
						} else if (fcc === FCC_FP16) {
								format = PIXELFORMAT_RGBA16F;
								componentSize = 2;
						} else if (fcc === FCC_FP32) {
								format = PIXELFORMAT_RGBA32F;
								componentSize = 4;
						} else if (fcc === FCC_ETC1) {
								format = PIXELFORMAT_ETC1;
								compressed = true;
								etc1 = true;
						} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
								format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
								compressed = true;
								pvrtc2 = true;
						} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
								format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
								compressed = true;
								pvrtc4 = true;
						}
				} else {
						if (bpp === 32) {
								format = PIXELFORMAT_RGBA8;
						}
				}
				if (!format) {
						texture = new Texture(device, {
								width: 4,
								height: 4,
								format: PIXELFORMAT_RGB8,
								name: 'dds-legacy-empty'
						});
						return texture;
				}
				texture = new Texture(device, _extends$1({
						name: url,
						addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
						width: width,
						height: height,
						format: format,
						cubemap: isCubemap,
						mipmaps: mips > 1
				}, textureOptions));
				var offset = 128;
				var faces = isCubemap ? 6 : 1;
				var mipSize;
				var DXT_BLOCK_WIDTH = 4;
				var DXT_BLOCK_HEIGHT = 4;
				var blockSize = fcc === FCC_DXT1 ? 8 : 16;
				var numBlocksAcross, numBlocksDown, numBlocks;
				for(var face = 0; face < faces; face++){
						var mipWidth = width;
						var mipHeight = height;
						for(var i = 0; i < mips; i++){
								if (compressed) {
										if (etc1) {
												mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
										} else if (pvrtc2) {
												mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
										} else if (pvrtc4) {
												mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
										} else {
												numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
												numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
												numBlocks = numBlocksAcross * numBlocksDown;
												mipSize = numBlocks * blockSize;
										}
								} else {
										mipSize = mipWidth * mipHeight * 4;
								}
								var mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
								if (!isCubemap) {
										texture._levels[i] = mipBuff;
								} else {
										if (!texture._levels[i]) texture._levels[i] = [];
										texture._levels[i][face] = mipBuff;
								}
								offset += mipSize * componentSize;
								mipWidth = Math.max(mipWidth * 0.5, 1);
								mipHeight = Math.max(mipHeight * 0.5, 1);
						}
				}
				texture.upload();
				return texture;
		}
		constructor(registry){
				super();
				this.maxRetries = 0;
		}
}

function _extends() {
		_extends = Object.assign || function(target) {
				for(var i = 1; i < arguments.length; i++){
						var source = arguments[i];
						for(var key in source){
								if (Object.prototype.hasOwnProperty.call(source, key)) {
										target[key] = source[key];
								}
						}
				}
				return target;
		};
		return _extends.apply(this, arguments);
}
class HdrParser extends TextureParser {
		load(url, callback, asset) {
				Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		}
		open(url, data, device, textureOptions) {
				if (textureOptions === void 0) textureOptions = {};
				var textureData = this.parse(data);
				if (!textureData) {
						return null;
				}
				var texture = new Texture(device, _extends({
						name: url,
						addressU: ADDRESS_REPEAT,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						width: textureData.width,
						height: textureData.height,
						levels: textureData.levels,
						format: PIXELFORMAT_RGBA8,
						type: TEXTURETYPE_RGBE,
						mipmaps: false
				}, textureOptions));
				texture.upload();
				return texture;
		}
		parse(data) {
				var readStream = new ReadStream(data);
				var magic = readStream.readLine();
				if (!magic.startsWith('#?RADIANCE')) {
						return null;
				}
				var variables = {};
				while(true){
						var line = readStream.readLine();
						if (line.length === 0) {
								break;
						} else {
								var parts = line.split('=');
								if (parts.length === 2) {
										variables[parts[0]] = parts[1];
								}
						}
				}
				if (!variables.hasOwnProperty('FORMAT')) {
						return null;
				}
				var resolution = readStream.readLine().split(' ');
				if (resolution.length !== 4) {
						return null;
				}
				var height = parseInt(resolution[1], 10);
				var width = parseInt(resolution[3], 10);
				var pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');
				if (!pixels) {
						return null;
				}
				return {
						width: width,
						height: height,
						levels: [
								pixels
						]
				};
		}
		_readPixels(readStream, width, height, flipY) {
				if (width < 8 || width > 0x7fff) {
						return this._readPixelsFlat(readStream, width, height);
				}
				var rgbe = [
						0,
						0,
						0,
						0
				];
				readStream.readArray(rgbe);
				if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
						readStream.skip(-4);
						return this._readPixelsFlat(readStream, width, height);
				}
				var buffer = new ArrayBuffer(width * height * 4);
				var view = new Uint8Array(buffer);
				var scanstart = flipY ? 0 : width * 4 * (height - 1);
				var x, y, i, channel, count, value;
				for(y = 0; y < height; ++y){
						if (y) {
								readStream.readArray(rgbe);
						}
						if ((rgbe[2] << 8) + rgbe[3] !== width) {
								return null;
						}
						for(channel = 0; channel < 4; ++channel){
								x = 0;
								while(x < width){
										count = readStream.readU8();
										if (count > 128) {
												count -= 128;
												if (x + count > width) {
														return null;
												}
												value = readStream.readU8();
												for(i = 0; i < count; ++i){
														view[scanstart + channel + 4 * x++] = value;
												}
										} else {
												if (count === 0 || x + count > width) {
														return null;
												}
												for(i = 0; i < count; ++i){
														view[scanstart + channel + 4 * x++] = readStream.readU8();
												}
										}
								}
						}
						scanstart += width * 4 * (flipY ? 1 : -1);
				}
				return view;
		}
		_readPixelsFlat(readStream, width, height) {
				return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
		}
		constructor(registry){
				super();
				this.maxRetries = 0;
		}
}

var JSON_ADDRESS_MODE = {
		'repeat': ADDRESS_REPEAT,
		'clamp': ADDRESS_CLAMP_TO_EDGE,
		'mirror': ADDRESS_MIRRORED_REPEAT
};
var JSON_FILTER_MODE = {
		'nearest': FILTER_NEAREST,
		'linear': FILTER_LINEAR,
		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
};
var JSON_TEXTURE_TYPE = {
		'default': TEXTURETYPE_DEFAULT,
		'rgbm': TEXTURETYPE_RGBM,
		'rgbe': TEXTURETYPE_RGBE,
		'rgbp': TEXTURETYPE_RGBP,
		'swizzleGGGR': TEXTURETYPE_SWIZZLEGGGR
};
var _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
		var requiredMipLevels = TextureUtils.calcMipLevelsCount(texture._width, texture._height);
		var isHtmlElement = function isHtmlElement(object) {
				return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
		};
		if (!(texture._format === PIXELFORMAT_RGBA8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
				return;
		}
		var downsample = function downsample(width, height, data) {
				var sampledWidth = Math.max(1, width >> 1);
				var sampledHeight = Math.max(1, height >> 1);
				var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
				var xs = Math.floor(width / sampledWidth);
				var ys = Math.floor(height / sampledHeight);
				var xsys = xs * ys;
				for(var y = 0; y < sampledHeight; ++y){
						for(var x = 0; x < sampledWidth; ++x){
								for(var e = 0; e < 4; ++e){
										var sum = 0;
										for(var sy = 0; sy < ys; ++sy){
												for(var sx = 0; sx < xs; ++sx){
														sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
												}
										}
										sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
								}
						}
				}
				return sampledData;
		};
		for(var level = texture._levels.length; level < requiredMipLevels; ++level){
				var width = Math.max(1, texture._width >> level - 1);
				var height = Math.max(1, texture._height >> level - 1);
				if (texture._cubemap) {
						var mips = [];
						for(var face = 0; face < 6; ++face){
								mips.push(downsample(width, height, texture._levels[level - 1][face]));
						}
						texture._levels.push(mips);
				} else {
						texture._levels.push(downsample(width, height, texture._levels[level - 1]));
				}
		}
		texture._levelsUpdated = texture._cubemap ? [
				[
						true,
						true,
						true,
						true,
						true,
						true
				]
		] : [
				true
		];
};
class TextureHandler extends ResourceHandler {
		set crossOrigin(value) {
				this.imgParser.crossOrigin = value;
		}
		get crossOrigin() {
				return this.imgParser.crossOrigin;
		}
		set maxRetries(value) {
				this.imgParser.maxRetries = value;
				for(var parser in this.parsers){
						if (this.parsers.hasOwnProperty(parser)) {
								this.parsers[parser].maxRetries = value;
						}
				}
		}
		get maxRetries() {
				return this.imgParser.maxRetries;
		}
		_getUrlWithoutParams(url) {
				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		}
		_getParser(url) {
				var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
				return this.parsers[ext] || this.imgParser;
		}
		_getTextureOptions(asset) {
				var options = {};
				if (asset) {
						var _asset_name;
						if (((_asset_name = asset.name) == null ? void 0 : _asset_name.length) > 0) {
								options.name = asset.name;
						}
						var assetData = asset.data;
						if (assetData.hasOwnProperty('minfilter')) {
								options.minFilter = JSON_FILTER_MODE[assetData.minfilter];
						}
						if (assetData.hasOwnProperty('magfilter')) {
								options.magFilter = JSON_FILTER_MODE[assetData.magfilter];
						}
						if (assetData.hasOwnProperty('addressu')) {
								options.addressU = JSON_ADDRESS_MODE[assetData.addressu];
						}
						if (assetData.hasOwnProperty('addressv')) {
								options.addressV = JSON_ADDRESS_MODE[assetData.addressv];
						}
						if (assetData.hasOwnProperty('mipmaps')) {
								options.mipmaps = assetData.mipmaps;
						}
						if (assetData.hasOwnProperty('anisotropy')) {
								options.anisotropy = assetData.anisotropy;
						}
						if (assetData.hasOwnProperty('flipY')) {
								options.flipY = !!assetData.flipY;
						}
						if (assetData.hasOwnProperty('srgb')) {
								options.srgb = !!assetData.srgb;
						}
						if (assetData.hasOwnProperty('type')) {
								options.type = JSON_TEXTURE_TYPE[assetData.type];
						} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
								options.type = TEXTURETYPE_RGBM;
						} else if (asset.file && (asset.file.opt & 8) !== 0) {
								options.type = TEXTURETYPE_SWIZZLEGGGR;
						}
				}
				return options;
		}
		load(url, callback, asset) {
				if (typeof url === 'string') {
						url = {
								load: url,
								original: url
						};
				}
				this._getParser(url.original).load(url, callback, asset);
		}
		open(url, data, asset) {
				if (!url) {
						return undefined;
				}
				var textureOptions = this._getTextureOptions(asset);
				var texture = this._getParser(url).open(url, data, this._device, textureOptions);
				if (texture === null) {
						texture = new Texture(this._device, {
								width: 4,
								height: 4,
								format: PIXELFORMAT_RGB8
						});
				} else {
						_completePartialMipmapChain(texture);
						if (data.unswizzledGGGR) {
								asset.file.variants.basis.opt &= -9;
						}
				}
				return texture;
		}
		patch(asset, assets) {
				var texture = asset.resource;
				if (!texture) {
						return;
				}
				var options = this._getTextureOptions(asset);
				for (var key of Object.keys(options)){
						texture[key] = options[key];
				}
		}
		constructor(app){
				super(app, 'texture');
				var assets = app.assets;
				var device = app.graphicsDevice;
				this._device = device;
				this._assets = assets;
				this.imgParser = new ImgParser(assets, device);
				this.parsers = {
						dds: new DdsParser(assets),
						ktx: new KtxParser(assets),
						ktx2: new Ktx2Parser(assets, device),
						basis: new BasisParser(assets, device),
						hdr: new HdrParser(assets)
				};
		}
}

var XRTYPE_INLINE = 'inline';
var XRTYPE_VR = 'immersive-vr';
var XRTYPE_AR = 'immersive-ar';
var XRSPACE_VIEWER = 'viewer';
var XRSPACE_LOCAL = 'local';
var XRSPACE_LOCALFLOOR = 'local-floor';
var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
var XRSPACE_UNBOUNDED = 'unbounded';
var XRTARGETRAY_GAZE = 'gaze';
var XRTARGETRAY_SCREEN = 'screen';
var XRTARGETRAY_POINTER = 'tracked-pointer';
var XREYE_NONE = 'none';
var XREYE_LEFT = 'left';
var XREYE_RIGHT = 'right';
var XRHAND_NONE = 'none';
var XRHAND_LEFT = 'left';
var XRHAND_RIGHT = 'right';
var XRTRACKABLE_POINT = 'point';
var XRTRACKABLE_PLANE = 'plane';
var XRTRACKABLE_MESH = 'mesh';
var XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
var XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
var XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
var XRDEPTHSENSINGFORMAT_R16U = 'unsigned-short';
var XRDEPTHSENSINGFORMAT_F32 = 'float32';

class XrDomOverlay {
		get supported() {
				return this._supported;
		}
		get available() {
				return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
		}
		get state() {
				if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) {
						return null;
				}
				return this._manager._session.domOverlayState.type;
		}
		set root(value) {
				if (!this._supported || this._manager.active) {
						return;
				}
				this._root = value;
		}
		get root() {
				return this._root;
		}
		constructor(manager){
				this._supported = platform.browser && !!window.XRDOMOverlayState;
				this._root = null;
				this._manager = manager;
		}
}

var poolVec3 = [];
var poolQuat = [];
class XrHitTestSource extends EventHandler {
		remove() {
				if (!this._xrHitTestSource) {
						return;
				}
				var sources = this.manager.hitTest.sources;
				var ind = sources.indexOf(this);
				if (ind !== -1) sources.splice(ind, 1);
				this.onStop();
		}
		onStop() {
				this._xrHitTestSource.cancel();
				this._xrHitTestSource = null;
				this.fire('remove');
				this.manager.hitTest.fire('remove', this);
		}
		update(frame) {
				if (this._transient) {
						var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
						for(var i = 0; i < transientResults.length; i++){
								var transientResult = transientResults[i];
								if (!transientResult.results.length) {
										continue;
								}
								var inputSource = void 0;
								if (transientResult.inputSource) {
										inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
								}
								this.updateHitResults(transientResult.results, inputSource);
						}
				} else {
						var results = frame.getHitTestResults(this._xrHitTestSource);
						if (!results.length) {
								return;
						}
						this.updateHitResults(results);
				}
		}
		updateHitResults(results, inputSource) {
				if (this._inputSource && this._inputSource !== inputSource) {
						return;
				}
				var _poolVec3_pop;
				var origin = (_poolVec3_pop = poolVec3.pop()) != null ? _poolVec3_pop : new Vec3();
				if (inputSource) {
						origin.copy(inputSource.getOrigin());
				} else {
						origin.copy(this.manager.camera.getPosition());
				}
				var candidateDistance = Infinity;
				var candidateHitTestResult = null;
				var _poolVec3_pop1;
				var position = (_poolVec3_pop1 = poolVec3.pop()) != null ? _poolVec3_pop1 : new Vec3();
				var _poolQuat_pop;
				var rotation = (_poolQuat_pop = poolQuat.pop()) != null ? _poolQuat_pop : new Quat();
				for(var i = 0; i < results.length; i++){
						var pose = results[i].getPose(this.manager._referenceSpace);
						var distance = origin.distance(pose.transform.position);
						if (distance >= candidateDistance) {
								continue;
						}
						candidateDistance = distance;
						candidateHitTestResult = results[i];
						position.copy(pose.transform.position);
						rotation.copy(pose.transform.orientation);
				}
				this.fire('result', position, rotation, inputSource || this._inputSource, candidateHitTestResult);
				this.manager.hitTest.fire('result', this, position, rotation, inputSource || this._inputSource, candidateHitTestResult);
				poolVec3.push(origin);
				poolVec3.push(position);
				poolQuat.push(rotation);
		}
		constructor(manager, xrHitTestSource, transient, inputSource = null){
				super();
				this.manager = manager;
				this._xrHitTestSource = xrHitTestSource;
				this._transient = transient;
				this._inputSource = inputSource;
		}
}
XrHitTestSource.EVENT_REMOVE = 'remove';
XrHitTestSource.EVENT_RESULT = 'result';

class XrHitTest extends EventHandler {
		_onSessionStart() {
				if (this.manager.session.enabledFeatures) {
						var available = this.manager.session.enabledFeatures.indexOf('hit-test') !== -1;
						if (!available) return;
						this._available = available;
						this.fire('available');
				} else if (!this._checkingAvailability) {
						this._checkingAvailability = true;
						this.manager.session.requestReferenceSpace(XRSPACE_VIEWER).then((referenceSpace)=>{
								this.manager.session.requestHitTestSource({
										space: referenceSpace
								}).then((hitTestSource)=>{
										hitTestSource.cancel();
										if (this.manager.active) {
												this._available = true;
												this.fire('available');
										}
								}).catch(()=>{});
						}).catch(()=>{});
				}
		}
		_onSessionEnd() {
				if (!this._available) return;
				this._available = false;
				for(var i = 0; i < this.sources.length; i++){
						this.sources[i].onStop();
				}
				this.sources = [];
				this.fire('unavailable');
		}
		start(options) {
				if (options === void 0) options = {};
				if (!this._supported) {
						options.callback == null ? void 0 : options.callback.call(options, new Error('XR HitTest is not supported'), null);
						return;
				}
				if (!this._available) {
						options.callback == null ? void 0 : options.callback.call(options, new Error('XR HitTest is not available'), null);
						return;
				}
				if (!options.profile && !options.spaceType) {
						options.spaceType = XRSPACE_VIEWER;
				}
				var xrRay;
				var offsetRay = options.offsetRay;
				if (offsetRay) {
						var origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);
						var direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);
						xrRay = new XRRay(origin, direction);
				}
				var callback = options.callback;
				if (options.spaceType) {
						this.manager.session.requestReferenceSpace(options.spaceType).then((referenceSpace)=>{
								if (!this.manager.session) {
										var err = new Error('XR Session is not started (2)');
										if (callback) callback(err);
										this.fire('error', err);
										return;
								}
								this.manager.session.requestHitTestSource({
										space: referenceSpace,
										entityTypes: options.entityTypes || undefined,
										offsetRay: xrRay
								}).then((xrHitTestSource)=>{
										this._onHitTestSource(xrHitTestSource, false, options.inputSource, callback);
								}).catch((ex)=>{
										if (callback) callback(ex);
										this.fire('error', ex);
								});
						}).catch((ex)=>{
								if (callback) callback(ex);
								this.fire('error', ex);
						});
				} else {
						this.manager.session.requestHitTestSourceForTransientInput({
								profile: options.profile,
								entityTypes: options.entityTypes || undefined,
								offsetRay: xrRay
						}).then((xrHitTestSource)=>{
								this._onHitTestSource(xrHitTestSource, true, options.inputSource, callback);
						}).catch((ex)=>{
								if (callback) callback(ex);
								this.fire('error', ex);
						});
				}
		}
		_onHitTestSource(xrHitTestSource, transient, inputSource, callback) {
				if (!this.manager.session) {
						xrHitTestSource.cancel();
						var err = new Error('XR Session is not started (3)');
						if (callback) callback(err);
						this.fire('error', err);
						return;
				}
				var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient, inputSource != null ? inputSource : null);
				this.sources.push(hitTestSource);
				if (callback) callback(null, hitTestSource);
				this.fire('add', hitTestSource);
		}
		update(frame) {
				if (!this._available) {
						return;
				}
				for(var i = 0; i < this.sources.length; i++){
						this.sources[i].update(frame);
				}
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		constructor(manager){
				super(), this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource), this._available = false, this._checkingAvailability = false, this.sources = [];
				this.manager = manager;
				if (this._supported) {
						this.manager.on('start', this._onSessionStart, this);
						this.manager.on('end', this._onSessionEnd, this);
				}
		}
}
XrHitTest.EVENT_AVAILABLE = 'available';
XrHitTest.EVENT_UNAVAILABLE = 'unavailable';
XrHitTest.EVENT_ADD = 'add';
XrHitTest.EVENT_REMOVE = 'remove';
XrHitTest.EVENT_RESULT = 'result';
XrHitTest.EVENT_ERROR = 'error';

class XrTrackedImage extends EventHandler {
		get image() {
				return this._image;
		}
		set width(value) {
				this._width = value;
		}
		get width() {
				return this._width;
		}
		get trackable() {
				return this._trackable;
		}
		get tracking() {
				return this._tracking;
		}
		get emulated() {
				return this._emulated;
		}
		prepare() {
				if (this._bitmap) {
						return {
								image: this._bitmap,
								widthInMeters: this._width
						};
				}
				return createImageBitmap(this._image).then((bitmap)=>{
						this._bitmap = bitmap;
						return {
								image: this._bitmap,
								widthInMeters: this._width
						};
				});
		}
		destroy() {
				this._image = null;
				this._pose = null;
				if (this._bitmap) {
						this._bitmap.close();
						this._bitmap = null;
				}
		}
		getPosition() {
				if (this._pose) this._position.copy(this._pose.transform.position);
				return this._position;
		}
		getRotation() {
				if (this._pose) this._rotation.copy(this._pose.transform.orientation);
				return this._rotation;
		}
		constructor(image, width){
				super(), this._bitmap = null, this._measuredWidth = 0, this._trackable = false, this._tracking = false, this._emulated = false, this._pose = null, this._position = new Vec3(), this._rotation = new Quat();
				this._image = image;
				this._width = width;
		}
}
XrTrackedImage.EVENT_TRACKED = 'tracked';
XrTrackedImage.EVENT_UNTRACKED = 'untracked';

class XrImageTracking extends EventHandler {
		add(image, width) {
				if (!this._supported || this._manager.active) return null;
				var trackedImage = new XrTrackedImage(image, width);
				this._images.push(trackedImage);
				return trackedImage;
		}
		remove(trackedImage) {
				if (this._manager.active) return;
				var ind = this._images.indexOf(trackedImage);
				if (ind !== -1) {
						trackedImage.destroy();
						this._images.splice(ind, 1);
				}
		}
		_onSessionStart() {
				this._manager.session.getTrackedImageScores().then((images)=>{
						this._available = true;
						for(var i = 0; i < images.length; i++){
								this._images[i]._trackable = images[i] === 'trackable';
						}
				}).catch((err)=>{
						this._available = false;
						this.fire('error', err);
				});
		}
		_onSessionEnd() {
				this._available = false;
				for(var i = 0; i < this._images.length; i++){
						var image = this._images[i];
						image._pose = null;
						image._measuredWidth = 0;
						if (image._tracking) {
								image._tracking = false;
								image.fire('untracked');
						}
				}
		}
		prepareImages(callback) {
				if (this._images.length) {
						Promise.all(this._images.map((trackedImage)=>{
								return trackedImage.prepare();
						})).then((bitmaps)=>{
								callback(null, bitmaps);
						}).catch((err)=>{
								callback(err, null);
						});
				} else {
						callback(null, null);
				}
		}
		update(frame) {
				if (!this._available) return;
				var results = frame.getImageTrackingResults();
				var index = {};
				for(var i = 0; i < results.length; i++){
						index[results[i].index] = results[i];
						var trackedImage = this._images[results[i].index];
						trackedImage._emulated = results[i].trackingState === 'emulated';
						trackedImage._measuredWidth = results[i].measuredWidthInMeters;
						trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
				}
				for(var i1 = 0; i1 < this._images.length; i1++){
						if (this._images[i1]._tracking && !index[i1]) {
								this._images[i1]._tracking = false;
								this._images[i1].fire('untracked');
						} else if (!this._images[i1]._tracking && index[i1]) {
								this._images[i1]._tracking = true;
								this._images[i1].fire('tracked');
						}
				}
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		get images() {
				return this._images;
		}
		constructor(manager){
				super(), this._supported = platform.browser && !!window.XRImageTrackingResult, this._available = false, this._images = [];
				this._manager = manager;
				if (this._supported) {
						this._manager.on('start', this._onSessionStart, this);
						this._manager.on('end', this._onSessionEnd, this);
				}
		}
}
XrImageTracking.EVENT_ERROR = 'error';

class XrFinger {
		get index() {
				return this._index;
		}
		get hand() {
				return this._hand;
		}
		get joints() {
				return this._joints;
		}
		get tip() {
				return this._tip;
		}
		constructor(index, hand){
				this._joints = [];
				this._tip = null;
				this._index = index;
				this._hand = hand;
				this._hand._fingers.push(this);
		}
}

var tipJointIds = platform.browser && window.XRHand ? [
		'thumb-tip',
		'index-finger-tip',
		'middle-finger-tip',
		'ring-finger-tip',
		'pinky-finger-tip'
] : [];
var tipJointIdsIndex = {};
for(var i$1 = 0; i$1 < tipJointIds.length; i$1++){
		tipJointIdsIndex[tipJointIds[i$1]] = true;
}
class XrJoint {
		update(pose) {
				this._dirtyLocal = true;
				this._radius = pose.radius;
				this._localPosition.copy(pose.transform.position);
				this._localRotation.copy(pose.transform.orientation);
		}
		_updateTransforms() {
				if (this._dirtyLocal) {
						this._dirtyLocal = false;
						this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
				}
				var manager = this._hand._manager;
				var parent = manager.camera.parent;
				if (parent) {
						this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
				} else {
						this._worldTransform.copy(this._localTransform);
				}
		}
		getPosition() {
				this._updateTransforms();
				this._worldTransform.getTranslation(this._position);
				return this._position;
		}
		getRotation() {
				this._updateTransforms();
				this._rotation.setFromMat4(this._worldTransform);
				return this._rotation;
		}
		get id() {
				return this._id;
		}
		get index() {
				return this._index;
		}
		get hand() {
				return this._hand;
		}
		get finger() {
				return this._finger;
		}
		get wrist() {
				return this._wrist;
		}
		get tip() {
				return this._tip;
		}
		get radius() {
				return this._radius || 0.005;
		}
		constructor(index, id, hand, finger = null){
				this._radius = null;
				this._localTransform = new Mat4();
				this._worldTransform = new Mat4();
				this._localPosition = new Vec3();
				this._localRotation = new Quat();
				this._position = new Vec3();
				this._rotation = new Quat();
				this._dirtyLocal = true;
				this._index = index;
				this._id = id;
				this._hand = hand;
				this._finger = finger;
				this._wrist = id === 'wrist';
				this._tip = this._finger && !!tipJointIdsIndex[id];
		}
}

var fingerJointIds = [];
var vecA$1 = new Vec3();
var vecB$1 = new Vec3();
var vecC = new Vec3();
if (platform.browser && window.XRHand) {
		fingerJointIds = [
				[
						'thumb-metacarpal',
						'thumb-phalanx-proximal',
						'thumb-phalanx-distal',
						'thumb-tip'
				],
				[
						'index-finger-metacarpal',
						'index-finger-phalanx-proximal',
						'index-finger-phalanx-intermediate',
						'index-finger-phalanx-distal',
						'index-finger-tip'
				],
				[
						'middle-finger-metacarpal',
						'middle-finger-phalanx-proximal',
						'middle-finger-phalanx-intermediate',
						'middle-finger-phalanx-distal',
						'middle-finger-tip'
				],
				[
						'ring-finger-metacarpal',
						'ring-finger-phalanx-proximal',
						'ring-finger-phalanx-intermediate',
						'ring-finger-phalanx-distal',
						'ring-finger-tip'
				],
				[
						'pinky-finger-metacarpal',
						'pinky-finger-phalanx-proximal',
						'pinky-finger-phalanx-intermediate',
						'pinky-finger-phalanx-distal',
						'pinky-finger-tip'
				]
		];
}
class XrHand extends EventHandler {
		update(frame) {
				var xrInputSource = this._inputSource._xrInputSource;
				for(var j = 0; j < this._joints.length; j++){
						var joint = this._joints[j];
						var jointSpace = xrInputSource.hand.get(joint._id);
						if (jointSpace) {
								var pose = void 0;
								if (frame.session.visibilityState !== 'hidden') {
										pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);
								}
								if (pose) {
										joint.update(pose);
										if (joint.wrist && !this._tracking) {
												this._tracking = true;
												this.fire('tracking');
										}
								} else if (joint.wrist) {
										if (this._tracking) {
												this._tracking = false;
												this.fire('trackinglost');
										}
										break;
								}
						}
				}
				var j1 = this._jointsById['thumb-metacarpal'];
				var j4 = this._jointsById['thumb-tip'];
				var j6 = this._jointsById['index-finger-phalanx-proximal'];
				var j9 = this._jointsById['index-finger-tip'];
				var j16 = this._jointsById['ring-finger-phalanx-proximal'];
				var j21 = this._jointsById['pinky-finger-phalanx-proximal'];
				if (j1 && j4 && j6 && j9 && j16 && j21) {
						this._inputSource._dirtyRay = true;
						this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);
						var jointL = j1;
						var jointR = j21;
						if (this._inputSource.handedness === XRHAND_LEFT) {
								var t = jointL;
								jointL = jointR;
								jointR = t;
						}
						vecA$1.sub2(jointL._localPosition, this._wrist._localPosition);
						vecB$1.sub2(jointR._localPosition, this._wrist._localPosition);
						vecC.cross(vecA$1, vecB$1).normalize();
						vecA$1.lerp(j6._localPosition, j16._localPosition, 0.5);
						vecA$1.sub(this._wrist._localPosition).normalize();
						this._inputSource._rayLocal.direction.lerp(vecC, vecA$1, 0.5).normalize();
				}
				var squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);
				if (squeezing) {
						if (!this._inputSource._squeezing) {
								this._inputSource._squeezing = true;
								this._inputSource.fire('squeezestart');
								this._manager.input.fire('squeezestart', this._inputSource);
						}
				} else {
						if (this._inputSource._squeezing) {
								this._inputSource._squeezing = false;
								this._inputSource.fire('squeeze');
								this._manager.input.fire('squeeze', this._inputSource);
								this._inputSource.fire('squeezeend');
								this._manager.input.fire('squeezeend', this._inputSource);
						}
				}
		}
		_fingerIsClosed(index) {
				var finger = this._fingers[index];
				vecA$1.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
				vecB$1.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
				return vecA$1.dot(vecB$1) < -0.8;
		}
		getJointById(id) {
				return this._jointsById[id] || null;
		}
		get fingers() {
				return this._fingers;
		}
		get joints() {
				return this._joints;
		}
		get tips() {
				return this._tips;
		}
		get wrist() {
				return this._wrist;
		}
		get tracking() {
				return this._tracking;
		}
		constructor(inputSource){
				super(), this._tracking = false, this._fingers = [], this._joints = [], this._jointsById = {}, this._tips = [], this._wrist = null;
				var xrHand = inputSource._xrInputSource.hand;
				this._manager = inputSource._manager;
				this._inputSource = inputSource;
				if (xrHand.get('wrist')) {
						var joint = new XrJoint(0, 'wrist', this, null);
						this._wrist = joint;
						this._joints.push(joint);
						this._jointsById.wrist = joint;
				}
				for(var f = 0; f < fingerJointIds.length; f++){
						var finger = new XrFinger(f, this);
						for(var j = 0; j < fingerJointIds[f].length; j++){
								var jointId = fingerJointIds[f][j];
								if (!xrHand.get(jointId)) continue;
								var joint1 = new XrJoint(j, jointId, this, finger);
								this._joints.push(joint1);
								this._jointsById[jointId] = joint1;
								if (joint1.tip) {
										this._tips.push(joint1);
										finger._tip = joint1;
								}
								finger._joints.push(joint1);
						}
				}
		}
}
XrHand.EVENT_TRACKING = 'tracking';
XrHand.EVENT_TRACKINGLOST = 'trackinglost';

var vec3A$1 = new Vec3();
var quat = new Quat();
var ids$1 = 0;
class XrInputSource extends EventHandler {
		get id() {
				return this._id;
		}
		get inputSource() {
				return this._xrInputSource;
		}
		get targetRayMode() {
				return this._xrInputSource.targetRayMode;
		}
		get handedness() {
				return this._xrInputSource.handedness;
		}
		get profiles() {
				return this._xrInputSource.profiles;
		}
		get grip() {
				return this._grip;
		}
		get hand() {
				return this._hand;
		}
		get gamepad() {
				return this._xrInputSource.gamepad || null;
		}
		get selecting() {
				return this._selecting;
		}
		get squeezing() {
				return this._squeezing;
		}
		set elementInput(value) {
				if (this._elementInput === value) {
						return;
				}
				this._elementInput = value;
				if (!this._elementInput) {
						this._elementEntity = null;
				}
		}
		get elementInput() {
				return this._elementInput;
		}
		get elementEntity() {
				return this._elementEntity;
		}
		get hitTestSources() {
				return this._hitTestSources;
		}
		update(frame) {
				if (this._hand) {
						this._hand.update(frame);
				} else {
						var gripSpace = this._xrInputSource.gripSpace;
						if (gripSpace) {
								var gripPose = frame.getPose(gripSpace, this._manager._referenceSpace);
								if (gripPose) {
										if (!this._grip) {
												this._grip = true;
												this._localTransform = new Mat4();
												this._worldTransform = new Mat4();
												this._localPositionLast = new Vec3();
												this._localPosition = new Vec3();
												this._localRotation = new Quat();
												this._linearVelocity = new Vec3();
										}
										var timestamp = now();
										var dt = (timestamp - this._velocitiesTimestamp) / 1000;
										this._velocitiesTimestamp = timestamp;
										this._dirtyLocal = true;
										this._localPositionLast.copy(this._localPosition);
										this._localPosition.copy(gripPose.transform.position);
										this._localRotation.copy(gripPose.transform.orientation);
										this._velocitiesAvailable = true;
										if (this._manager.input.velocitiesSupported && gripPose.linearVelocity) {
												this._linearVelocity.copy(gripPose.linearVelocity);
										} else if (dt > 0) {
												vec3A$1.sub2(this._localPosition, this._localPositionLast).divScalar(dt);
												this._linearVelocity.lerp(this._linearVelocity, vec3A$1, 0.15);
										}
								} else {
										this._velocitiesAvailable = false;
								}
						}
						var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
						if (targetRayPose) {
								this._dirtyRay = true;
								this._rayLocal.origin.copy(targetRayPose.transform.position);
								this._rayLocal.direction.set(0, 0, -1);
								quat.copy(targetRayPose.transform.orientation);
								quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
						}
				}
		}
		_updateTransforms() {
				if (this._dirtyLocal) {
						this._dirtyLocal = false;
						this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
				}
				var parent = this._manager.camera.parent;
				if (parent) {
						this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
				} else {
						this._worldTransform.copy(this._localTransform);
				}
		}
		_updateRayTransforms() {
				var dirty = this._dirtyRay;
				this._dirtyRay = false;
				var parent = this._manager.camera.parent;
				if (parent) {
						var parentTransform = this._manager.camera.parent.getWorldTransform();
						parentTransform.getTranslation(this._position);
						this._rotation.setFromMat4(parentTransform);
						this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
						this._ray.origin.add(this._position);
						this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
				} else if (dirty) {
						this._ray.origin.copy(this._rayLocal.origin);
						this._ray.direction.copy(this._rayLocal.direction);
				}
		}
		getPosition() {
				if (!this._position) return null;
				this._updateTransforms();
				this._worldTransform.getTranslation(this._position);
				return this._position;
		}
		getLocalPosition() {
				return this._localPosition;
		}
		getRotation() {
				if (!this._rotation) return null;
				this._updateTransforms();
				this._rotation.setFromMat4(this._worldTransform);
				return this._rotation;
		}
		getLocalRotation() {
				return this._localRotation;
		}
		getLinearVelocity() {
				if (!this._velocitiesAvailable) {
						return null;
				}
				return this._linearVelocity;
		}
		getOrigin() {
				this._updateRayTransforms();
				return this._ray.origin;
		}
		getDirection() {
				this._updateRayTransforms();
				return this._ray.direction;
		}
		hitTestStart(options) {
				if (options === void 0) options = {};
				options.inputSource = this;
				options.profile = this._xrInputSource.profiles[0];
				var callback = options.callback;
				options.callback = (err, hitTestSource)=>{
						if (hitTestSource) this.onHitTestSourceAdd(hitTestSource);
						if (callback) callback(err, hitTestSource);
				};
				this._manager.hitTest.start(options);
		}
		onHitTestSourceAdd(hitTestSource) {
				this._hitTestSources.push(hitTestSource);
				this.fire('hittest:add', hitTestSource);
				hitTestSource.on('result', (position, rotation, inputSource, hitTestResult)=>{
						if (inputSource !== this) return;
						this.fire('hittest:result', hitTestSource, position, rotation, hitTestResult);
				});
				hitTestSource.once('remove', ()=>{
						this.onHitTestSourceRemove(hitTestSource);
						this.fire('hittest:remove', hitTestSource);
				});
		}
		onHitTestSourceRemove(hitTestSource) {
				var ind = this._hitTestSources.indexOf(hitTestSource);
				if (ind !== -1) this._hitTestSources.splice(ind, 1);
		}
		constructor(manager, xrInputSource){
				super(), this._ray = new Ray(), this._rayLocal = new Ray(), this._grip = false, this._hand = null, this._velocitiesAvailable = false, this._velocitiesTimestamp = now(), this._localTransform = null, this._worldTransform = null, this._position = new Vec3(), this._rotation = new Quat(), this._localPosition = null, this._localPositionLast = null, this._localRotation = null, this._linearVelocity = null, this._dirtyLocal = true, this._dirtyRay = false, this._selecting = false, this._squeezing = false, this._elementInput = true, this._elementEntity = null, this._hitTestSources = [];
				this._id = ++ids$1;
				this._manager = manager;
				this._xrInputSource = xrInputSource;
				if (xrInputSource.hand) {
						this._hand = new XrHand(this);
				}
		}
}
XrInputSource.EVENT_REMOVE = 'remove';
XrInputSource.EVENT_SELECT = 'select';
XrInputSource.EVENT_SELECTSTART = 'selectstart';
XrInputSource.EVENT_SELECTEND = 'selectend';
XrInputSource.EVENT_SQUEEZE = 'squeeze';
XrInputSource.EVENT_SQUEEZESTART = 'squeezestart';
XrInputSource.EVENT_SQUEEZEEND = 'squeezeend';
XrInputSource.EVENT_HITTESTADD = 'hittest:add';
XrInputSource.EVENT_HITTESTREMOVE = 'hittest:remove';
XrInputSource.EVENT_HITTESTRESULT = 'hittest:result';

class XrInput extends EventHandler {
		_onSessionStart() {
				var session = this.manager.session;
				session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
				session.addEventListener('select', (evt)=>{
						var inputSource = this._getByInputSource(evt.inputSource);
						inputSource.update(evt.frame);
						inputSource.fire('select', evt);
						this.fire('select', inputSource, evt);
				});
				session.addEventListener('selectstart', (evt)=>{
						var inputSource = this._getByInputSource(evt.inputSource);
						inputSource.update(evt.frame);
						inputSource._selecting = true;
						inputSource.fire('selectstart', evt);
						this.fire('selectstart', inputSource, evt);
				});
				session.addEventListener('selectend', (evt)=>{
						var inputSource = this._getByInputSource(evt.inputSource);
						inputSource.update(evt.frame);
						inputSource._selecting = false;
						inputSource.fire('selectend', evt);
						this.fire('selectend', inputSource, evt);
				});
				session.addEventListener('squeeze', (evt)=>{
						var inputSource = this._getByInputSource(evt.inputSource);
						inputSource.update(evt.frame);
						inputSource.fire('squeeze', evt);
						this.fire('squeeze', inputSource, evt);
				});
				session.addEventListener('squeezestart', (evt)=>{
						var inputSource = this._getByInputSource(evt.inputSource);
						inputSource.update(evt.frame);
						inputSource._squeezing = true;
						inputSource.fire('squeezestart', evt);
						this.fire('squeezestart', inputSource, evt);
				});
				session.addEventListener('squeezeend', (evt)=>{
						var inputSource = this._getByInputSource(evt.inputSource);
						inputSource.update(evt.frame);
						inputSource._squeezing = false;
						inputSource.fire('squeezeend', evt);
						this.fire('squeezeend', inputSource, evt);
				});
				var inputSources = session.inputSources;
				for(var i = 0; i < inputSources.length; i++){
						this._addInputSource(inputSources[i]);
				}
		}
		_onSessionEnd() {
				var i = this._inputSources.length;
				while(i--){
						var inputSource = this._inputSources[i];
						this._inputSources.splice(i, 1);
						inputSource.fire('remove');
						this.fire('remove', inputSource);
				}
				var session = this.manager.session;
				session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		}
		_onInputSourcesChange(evt) {
				for(var i = 0; i < evt.removed.length; i++){
						this._removeInputSource(evt.removed[i]);
				}
				for(var i1 = 0; i1 < evt.added.length; i1++){
						this._addInputSource(evt.added[i1]);
				}
		}
		_getByInputSource(xrInputSource) {
				for(var i = 0; i < this._inputSources.length; i++){
						if (this._inputSources[i].inputSource === xrInputSource) {
								return this._inputSources[i];
						}
				}
				return null;
		}
		_addInputSource(xrInputSource) {
				if (this._getByInputSource(xrInputSource)) {
						return;
				}
				var inputSource = new XrInputSource(this.manager, xrInputSource);
				this._inputSources.push(inputSource);
				this.fire('add', inputSource);
		}
		_removeInputSource(xrInputSource) {
				for(var i = 0; i < this._inputSources.length; i++){
						if (this._inputSources[i].inputSource !== xrInputSource) {
								continue;
						}
						var inputSource = this._inputSources[i];
						this._inputSources.splice(i, 1);
						var h = inputSource.hitTestSources.length;
						while(h--){
								inputSource.hitTestSources[h].remove();
						}
						inputSource.fire('remove');
						this.fire('remove', inputSource);
						return;
				}
		}
		update(frame) {
				for(var i = 0; i < this._inputSources.length; i++){
						this._inputSources[i].update(frame);
				}
		}
		get inputSources() {
				return this._inputSources;
		}
		constructor(manager){
				var _window_XRPose_prototype, _window_XRPose;
				super(), this._inputSources = [], this.velocitiesSupported = false;
				this.manager = manager;
				this.velocitiesSupported = !!(platform.browser && ((_window_XRPose = window.XRPose) == null ? void 0 : (_window_XRPose_prototype = _window_XRPose.prototype) == null ? void 0 : _window_XRPose_prototype.hasOwnProperty('linearVelocity')));
				this._onInputSourcesChangeEvt = (evt)=>{
						this._onInputSourcesChange(evt);
				};
				this.manager.on('start', this._onSessionStart, this);
				this.manager.on('end', this._onSessionEnd, this);
		}
}
XrInput.EVENT_ADD = 'add';
XrInput.EVENT_REMOVE = 'remove';
XrInput.EVENT_SELECT = 'select';
XrInput.EVENT_SELECTSTART = 'selectstart';
XrInput.EVENT_SELECTEND = 'selectend';
XrInput.EVENT_SQUEEZE = 'squeeze';
XrInput.EVENT_SQUEEZESTART = 'squeezestart';
XrInput.EVENT_SQUEEZEEND = 'squeezeend';

var vec3A = new Vec3();
var vec3B = new Vec3();
var mat4A = new Mat4();
var mat4B = new Mat4();
class XrLightEstimation extends EventHandler {
		_onSessionStart() {
				var supported = !!this._manager.session.requestLightProbe;
				if (!supported) return;
				this._supported = true;
		}
		_onSessionEnd() {
				this._supported = false;
				this._available = false;
				this._lightProbeRequested = false;
				this._lightProbe = null;
		}
		start() {
				var err;
				if (!this._manager.session) {
						err = new Error('XR session is not running');
				}
				if (!err && this._manager.type !== XRTYPE_AR) {
						err = new Error('XR session type is not AR');
				}
				if (!err && !this._supported) {
						err = new Error('light-estimation is not supported');
				}
				if (!err && this._lightProbe || this._lightProbeRequested) {
						err = new Error('light estimation is already requested');
				}
				if (err) {
						this.fire('error', err);
						return;
				}
				this._lightProbeRequested = true;
				this._manager.session.requestLightProbe().then((lightProbe)=>{
						var wasRequested = this._lightProbeRequested;
						this._lightProbeRequested = false;
						if (this._manager.active) {
								if (wasRequested) {
										this._lightProbe = lightProbe;
								}
						} else {
								this.fire('error', new Error('XR session is not active'));
						}
				}).catch((ex)=>{
						this._lightProbeRequested = false;
						this.fire('error', ex);
				});
		}
		end() {
				this._lightProbeRequested = false;
				this._lightProbe = null;
				this._available = false;
		}
		update(frame) {
				if (!this._lightProbe) return;
				var lightEstimate = frame.getLightEstimate(this._lightProbe);
				if (!lightEstimate) return;
				if (!this._available) {
						this._available = true;
						this.fire('available');
				}
				var pli = lightEstimate.primaryLightIntensity;
				this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
				vec3A.copy(pli).mulScalar(1 / this._intensity);
				this._color.set(vec3A.x, vec3A.y, vec3A.z);
				vec3A.set(0, 0, 0);
				vec3B.copy(lightEstimate.primaryLightDirection);
				mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
				mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
				mat4A.mul(mat4B);
				this._rotation.setFromMat4(mat4A);
				this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		get intensity() {
				return this._available ? this._intensity : null;
		}
		get color() {
				return this._available ? this._color : null;
		}
		get rotation() {
				return this._available ? this._rotation : null;
		}
		get sphericalHarmonics() {
				return this._available ? this._sphericalHarmonics : null;
		}
		constructor(manager){
				super(), this._supported = false, this._available = false, this._lightProbeRequested = false, this._lightProbe = null, this._intensity = 0, this._rotation = new Quat(), this._color = new Color(), this._sphericalHarmonics = new Float32Array(27);
				this._manager = manager;
				this._manager.on('start', this._onSessionStart, this);
				this._manager.on('end', this._onSessionEnd, this);
		}
}
XrLightEstimation.EVENT_AVAILABLE = 'available';
XrLightEstimation.EVENT_ERROR = 'error';

var ids = 0;
class XrPlane extends EventHandler {
		destroy() {
				if (!this._xrPlane) return;
				this._xrPlane = null;
				this.fire('remove');
		}
		update(frame) {
				var manager = this._planeDetection._manager;
				var pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);
				if (pose) {
						this._position.copy(pose.transform.position);
						this._rotation.copy(pose.transform.orientation);
				}
				if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
						this._lastChangedTime = this._xrPlane.lastChangedTime;
						this.fire('change');
				}
		}
		getPosition() {
				return this._position;
		}
		getRotation() {
				return this._rotation;
		}
		get id() {
				return this._id;
		}
		get orientation() {
				return this._orientation;
		}
		get points() {
				return this._xrPlane.polygon;
		}
		get label() {
				return this._xrPlane.semanticLabel || '';
		}
		constructor(planeDetection, xrPlane){
				super(), this._position = new Vec3(), this._rotation = new Quat();
				this._id = ++ids;
				this._planeDetection = planeDetection;
				this._xrPlane = xrPlane;
				this._lastChangedTime = xrPlane.lastChangedTime;
				this._orientation = xrPlane.orientation;
		}
}
XrPlane.EVENT_REMOVE = 'remove';
XrPlane.EVENT_CHANGE = 'change';

class XrPlaneDetection extends EventHandler {
		_onSessionStart() {
				if (this._manager.session.enabledFeatures) {
						var available = this._manager.session.enabledFeatures.indexOf('plane-detection') !== -1;
						if (available) {
								this._available = true;
								this.fire('available');
						}
				}
		}
		_onSessionEnd() {
				for(var i = 0; i < this._planes.length; i++){
						this._planes[i].destroy();
						this.fire('remove', this._planes[i]);
				}
				this._planesIndex.clear();
				this._planes.length = 0;
				if (this._available) {
						this._available = false;
						this.fire('unavailable');
				}
		}
		update(frame) {
				if (!this._available) {
						if (!this._manager.session.enabledFeatures && frame.detectedPlanes.size) {
								this._available = true;
								this.fire('available');
						} else {
								return;
						}
				}
				var detectedPlanes = frame.detectedPlanes;
				for (var [xrPlane, plane] of this._planesIndex){
						if (detectedPlanes.has(xrPlane)) {
								continue;
						}
						this._planesIndex.delete(xrPlane);
						this._planes.splice(this._planes.indexOf(plane), 1);
						plane.destroy();
						this.fire('remove', plane);
				}
				for (var xrPlane1 of detectedPlanes){
						var plane1 = this._planesIndex.get(xrPlane1);
						if (!plane1) {
								plane1 = new XrPlane(this, xrPlane1);
								this._planesIndex.set(xrPlane1, plane1);
								this._planes.push(plane1);
								plane1.update(frame);
								this.fire('add', plane1);
						} else {
								plane1.update(frame);
						}
				}
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		get planes() {
				return this._planes;
		}
		constructor(manager){
				super(), this._supported = platform.browser && !!window.XRPlane, this._available = false, this._planesIndex = new Map(), this._planes = [];
				this._manager = manager;
				if (this._supported) {
						this._manager.on('start', this._onSessionStart, this);
						this._manager.on('end', this._onSessionEnd, this);
				}
		}
}
XrPlaneDetection.EVENT_AVAILABLE = 'available';
XrPlaneDetection.EVENT_UNAVAILABLE = 'unavailable';
XrPlaneDetection.EVENT_ADD = 'add';
XrPlaneDetection.EVENT_REMOVE = 'remove';

class XrAnchor extends EventHandler {
		destroy() {
				if (!this._xrAnchor) return;
				var xrAnchor = this._xrAnchor;
				this._xrAnchor.delete();
				this._xrAnchor = null;
				this.fire('destroy', xrAnchor, this);
		}
		update(frame) {
				if (!this._xrAnchor) {
						return;
				}
				var pose = frame.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);
				if (pose) {
						if (this._position.equals(pose.transform.position) && this._rotation.equals(pose.transform.orientation)) {
								return;
						}
						this._position.copy(pose.transform.position);
						this._rotation.copy(pose.transform.orientation);
						this.fire('change');
				}
		}
		getPosition() {
				return this._position;
		}
		getRotation() {
				return this._rotation;
		}
		persist(callback) {
				if (!this._anchors.persistence) {
						callback == null ? void 0 : callback(new Error('Persistent Anchors are not supported'), null);
						return;
				}
				if (this._uuid) {
						callback == null ? void 0 : callback(null, this._uuid);
						return;
				}
				if (this._uuidRequests) {
						if (callback) this._uuidRequests.push(callback);
						return;
				}
				this._uuidRequests = [];
				this._xrAnchor.requestPersistentHandle().then((uuid)=>{
						this._uuid = uuid;
						this._anchors._indexByUuid.set(this._uuid, this);
						callback == null ? void 0 : callback(null, uuid);
						for (var uuidRequest of this._uuidRequests){
								uuidRequest(null, uuid);
						}
						this._uuidRequests = null;
						this.fire('persist', uuid);
				}).catch((ex)=>{
						callback == null ? void 0 : callback(ex, null);
						for (var uuidRequest of this._uuidRequests){
								uuidRequest(ex, null);
						}
						this._uuidRequests = null;
				});
		}
		forget(callback) {
				if (!this._uuid) {
						callback == null ? void 0 : callback(new Error('Anchor is not persistent'));
						return;
				}
				this._anchors.forget(this._uuid, (ex)=>{
						this._uuid = null;
						callback == null ? void 0 : callback(ex);
						this.fire('forget');
				});
		}
		get uuid() {
				return this._uuid;
		}
		get persistent() {
				return !!this._uuid;
		}
		constructor(anchors, xrAnchor, uuid = null){
				super(), this._position = new Vec3(), this._rotation = new Quat(), this._uuid = null, this._uuidRequests = null;
				this._anchors = anchors;
				this._xrAnchor = xrAnchor;
				this._uuid = uuid;
		}
}
XrAnchor.EVENT_DESTROY = 'destroy';
XrAnchor.EVENT_CHANGE = 'change';
XrAnchor.EVENT_PERSIST = 'persist';
XrAnchor.EVENT_FORGET = 'forget';

class XrAnchors extends EventHandler {
		_onSessionStart() {
				var available = this.manager.session.enabledFeatures.indexOf('anchors') !== -1;
				if (!available) return;
				this._available = available;
				this.fire('available');
		}
		_onSessionEnd() {
				if (!this._available) return;
				this._available = false;
				for(var i = 0; i < this._creationQueue.length; i++){
						if (!this._creationQueue[i].callback) {
								continue;
						}
						this._creationQueue[i].callback(new Error('session ended'), null);
				}
				this._creationQueue.length = 0;
				this._index.clear();
				this._indexByUuid.clear();
				var i1 = this._list.length;
				while(i1--){
						this._list[i1].destroy();
				}
				this._list.length = 0;
				this.fire('unavailable');
		}
		_createAnchor(xrAnchor, uuid) {
				if (uuid === void 0) uuid = null;
				var anchor = new XrAnchor(this, xrAnchor, uuid);
				this._index.set(xrAnchor, anchor);
				if (uuid) this._indexByUuid.set(uuid, anchor);
				this._list.push(anchor);
				anchor.once('destroy', this._onAnchorDestroy, this);
				return anchor;
		}
		_onAnchorDestroy(xrAnchor, anchor) {
				this._index.delete(xrAnchor);
				if (anchor.uuid) this._indexByUuid.delete(anchor.uuid);
				var ind = this._list.indexOf(anchor);
				if (ind !== -1) this._list.splice(ind, 1);
				this.fire('destroy', anchor);
		}
		create(position, rotation, callback) {
				if (!this._available) {
						callback == null ? void 0 : callback(new Error('Anchors API is not available'), null);
						return;
				}
				if (window.XRHitTestResult && position instanceof XRHitTestResult) {
						var hitResult = position;
						callback = rotation;
						if (!this._supported) {
								callback == null ? void 0 : callback(new Error('Anchors API is not supported'), null);
								return;
						}
						if (!hitResult.createAnchor) {
								callback == null ? void 0 : callback(new Error('Creating Anchor from Hit Test is not supported'), null);
								return;
						}
						hitResult.createAnchor().then((xrAnchor)=>{
								var anchor = this._createAnchor(xrAnchor);
								callback == null ? void 0 : callback(null, anchor);
								this.fire('add', anchor);
						}).catch((ex)=>{
								callback == null ? void 0 : callback(ex, null);
								this.fire('error', ex);
						});
				} else {
						this._creationQueue.push({
								transform: new XRRigidTransform(position, rotation),
								callback: callback
						});
				}
		}
		restore(uuid, callback) {
				if (!this._available) {
						callback == null ? void 0 : callback(new Error('Anchors API is not available'), null);
						return;
				}
				if (!this._persistence) {
						callback == null ? void 0 : callback(new Error('Anchor Persistence is not supported'), null);
						return;
				}
				if (!this.manager.active) {
						callback == null ? void 0 : callback(new Error('WebXR session is not active'), null);
						return;
				}
				this.manager.session.restorePersistentAnchor(uuid).then((xrAnchor)=>{
						var anchor = this._createAnchor(xrAnchor, uuid);
						callback == null ? void 0 : callback(null, anchor);
						this.fire('add', anchor);
				}).catch((ex)=>{
						callback == null ? void 0 : callback(ex, null);
						this.fire('error', ex);
				});
		}
		forget(uuid, callback) {
				if (!this._available) {
						callback == null ? void 0 : callback(new Error('Anchors API is not available'));
						return;
				}
				if (!this._persistence) {
						callback == null ? void 0 : callback(new Error('Anchor Persistence is not supported'));
						return;
				}
				if (!this.manager.active) {
						callback == null ? void 0 : callback(new Error('WebXR session is not active'));
						return;
				}
				this.manager.session.deletePersistentAnchor(uuid).then(()=>{
						callback == null ? void 0 : callback(null);
				}).catch((ex)=>{
						callback == null ? void 0 : callback(ex);
						this.fire('error', ex);
				});
		}
		update(frame) {
				if (!this._available) {
						if (!this.manager.session.enabledFeatures && !this._checkingAvailability) {
								this._checkingAvailability = true;
								frame.createAnchor(new XRRigidTransform(), this.manager._referenceSpace).then((xrAnchor)=>{
										xrAnchor.delete();
										if (this.manager.active) {
												this._available = true;
												this.fire('available');
										}
								}).catch(()=>{});
						}
						return;
				}
				if (this._creationQueue.length) {
						var _this, _loop = function(i) {
								var request = _this._creationQueue[i];
								frame.createAnchor(request.transform, _this.manager._referenceSpace).then((xrAnchor)=>{
										if (request.callback) {
												_this._callbacksAnchors.set(xrAnchor, request.callback);
										}
								}).catch((ex)=>{
										if (request.callback) {
												request.callback(ex, null);
										}
										_this.fire('error', ex);
								});
						};
						for(var i = 0; i < this._creationQueue.length; i++)_this = this, _loop(i);
						this._creationQueue.length = 0;
				}
				for (var [xrAnchor, anchor] of this._index){
						if (frame.trackedAnchors.has(xrAnchor)) {
								continue;
						}
						this._index.delete(xrAnchor);
						anchor.destroy();
				}
				for(var i1 = 0; i1 < this._list.length; i1++){
						this._list[i1].update(frame);
				}
				for (var xrAnchor1 of frame.trackedAnchors){
						if (this._index.has(xrAnchor1)) {
								continue;
						}
						try {
								var tmp = xrAnchor1.anchorSpace;
						} catch (ex) {
								continue;
						}
						var anchor1 = this._createAnchor(xrAnchor1);
						anchor1.update(frame);
						var callback = this._callbacksAnchors.get(xrAnchor1);
						if (callback) {
								this._callbacksAnchors.delete(xrAnchor1);
								callback(null, anchor1);
						}
						this.fire('add', anchor1);
				}
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		get persistence() {
				return this._persistence;
		}
		get uuids() {
				if (!this._available) {
						return null;
				}
				if (!this._persistence) {
						return null;
				}
				if (!this.manager.active) {
						return null;
				}
				return this.manager.session.persistentAnchors;
		}
		get list() {
				return this._list;
		}
		constructor(manager){
				var _window_XRSession, _window;
				super(), this._supported = platform.browser && !!window.XRAnchor, this._available = false, this._checkingAvailability = false, this._persistence = platform.browser && !!((_window = window) == null ? void 0 : (_window_XRSession = _window.XRSession) == null ? void 0 : _window_XRSession.prototype.restorePersistentAnchor), this._creationQueue = [], this._index = new Map(), this._indexByUuid = new Map(), this._list = [], this._callbacksAnchors = new Map();
				this.manager = manager;
				if (this._supported) {
						this.manager.on('start', this._onSessionStart, this);
						this.manager.on('end', this._onSessionEnd, this);
				}
		}
}
XrAnchors.EVENT_AVAILABLE = 'available';
XrAnchors.EVENT_UNAVAILABLE = 'unavailable';
XrAnchors.EVENT_ERROR = 'error';
XrAnchors.EVENT_ADD = 'add';
XrAnchors.EVENT_DESTROY = 'destroy';

class XrMesh extends EventHandler {
		get xrMesh() {
				return this._xrMesh;
		}
		get label() {
				return this._xrMesh.semanticLabel || '';
		}
		get vertices() {
				return this._xrMesh.vertices;
		}
		get indices() {
				return this._xrMesh.indices;
		}
		destroy() {
				if (!this._xrMesh) return;
				this._xrMesh = null;
				this.fire('remove');
		}
		update(frame) {
				var manager = this._meshDetection._manager;
				var pose = frame.getPose(this._xrMesh.meshSpace, manager._referenceSpace);
				if (pose) {
						this._position.copy(pose.transform.position);
						this._rotation.copy(pose.transform.orientation);
				}
				if (this._lastChanged !== this._xrMesh.lastChangedTime) {
						this._lastChanged = this._xrMesh.lastChangedTime;
						this.fire('change');
				}
		}
		getPosition() {
				return this._position;
		}
		getRotation() {
				return this._rotation;
		}
		constructor(meshDetection, xrMesh){
				super(), this._lastChanged = 0, this._position = new Vec3(), this._rotation = new Quat();
				this._meshDetection = meshDetection;
				this._xrMesh = xrMesh;
				this._lastChanged = this._xrMesh.lastChangedTime;
		}
}
XrMesh.EVENT_REMOVE = 'remove';
XrMesh.EVENT_CHANGE = 'change';

class XrMeshDetection extends EventHandler {
		update(frame) {
				if (!this._available) {
						if (!this._manager.session.enabledFeatures && frame.detectedMeshes.size) {
								this._available = true;
								this.fire('available');
						} else {
								return;
						}
				}
				for (var xrMesh of frame.detectedMeshes){
						var mesh = this._index.get(xrMesh);
						if (!mesh) {
								mesh = new XrMesh(this, xrMesh);
								this._index.set(xrMesh, mesh);
								this._list.push(mesh);
								mesh.update(frame);
								this.fire('add', mesh);
						} else {
								mesh.update(frame);
						}
				}
				for (var mesh1 of this._index.values()){
						if (frame.detectedMeshes.has(mesh1.xrMesh)) {
								continue;
						}
						this._removeMesh(mesh1);
				}
		}
		_removeMesh(mesh) {
				this._index.delete(mesh.xrMesh);
				this._list.splice(this._list.indexOf(mesh), 1);
				mesh.destroy();
				this.fire('remove', mesh);
		}
		_onSessionStart() {
				if (this._manager.session.enabledFeatures) {
						var available = this._manager.session.enabledFeatures.indexOf('mesh-detection') !== -1;
						if (!available) return;
						this._available = available;
						this.fire('available');
				}
		}
		_onSessionEnd() {
				if (!this._available) return;
				this._available = false;
				for (var mesh of this._index.values()){
						this._removeMesh(mesh);
				}
				this.fire('unavailable');
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		get meshes() {
				return this._list;
		}
		constructor(manager){
				super(), this._supported = platform.browser && !!window.XRMesh, this._available = false, this._index = new Map(), this._list = [];
				this._manager = manager;
				if (this._supported) {
						this._manager.on('start', this._onSessionStart, this);
						this._manager.on('end', this._onSessionEnd, this);
				}
		}
}
XrMeshDetection.EVENT_AVAILABLE = 'available';
XrMeshDetection.EVENT_UNAVAILABLE = 'unavailable';
XrMeshDetection.EVENT_ADD = 'add';
XrMeshDetection.EVENT_REMOVE = 'remove';

class XrView extends EventHandler {
		get textureColor() {
				return this._textureColor;
		}
		get textureDepth() {
				return this._textureDepth;
		}
		get depthUvMatrix() {
				return this._depthMatrix;
		}
		get depthValueToMeters() {
				var _this__depthInfo;
				return ((_this__depthInfo = this._depthInfo) == null ? void 0 : _this__depthInfo.rawValueToMeters) || 0;
		}
		get eye() {
				return this._xrView.eye;
		}
		get viewport() {
				return this._viewport;
		}
		get projMat() {
				return this._projMat;
		}
		get projViewOffMat() {
				return this._projViewOffMat;
		}
		get viewOffMat() {
				return this._viewOffMat;
		}
		get viewInvOffMat() {
				return this._viewInvOffMat;
		}
		get viewMat3() {
				return this._viewMat3;
		}
		get positionData() {
				return this._positionData;
		}
		update(frame, xrView) {
				this._xrView = xrView;
				if (this._manager.views.availableColor) {
						this._xrCamera = this._xrView.camera;
				}
				var layer = frame.session.renderState.baseLayer;
				var viewport = layer.getViewport(this._xrView);
				this._viewport.x = viewport.x;
				this._viewport.y = viewport.y;
				this._viewport.z = viewport.width;
				this._viewport.w = viewport.height;
				this._projMat.set(this._xrView.projectionMatrix);
				this._viewMat.set(this._xrView.transform.inverse.matrix);
				this._viewInvMat.set(this._xrView.transform.matrix);
				this._updateTextureColor();
				this._updateDepth(frame);
		}
		_updateTextureColor() {
				if (!this._manager.views.availableColor || !this._xrCamera || !this._textureColor) {
						return;
				}
				var binding = this._manager.webglBinding;
				if (!binding) {
						return;
				}
				var texture = binding.getCameraImage(this._xrCamera);
				if (!texture) {
						return;
				}
				var device = this._manager.app.graphicsDevice;
				var gl = device.gl;
				if (!this._frameBufferSource) {
						this._frameBufferSource = gl.createFramebuffer();
						this._frameBuffer = gl.createFramebuffer();
				} else {
						var attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
						var width = this._xrCamera.width;
						var height = this._xrCamera.height;
						device.setFramebuffer(this._frameBufferSource);
						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, texture, 0);
						device.setFramebuffer(this._frameBuffer);
						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, this._textureColor.impl._glTexture, 0);
						gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._frameBufferSource);
						gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
						gl.blitFramebuffer(0, height, width, 0, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
				}
		}
		_updateDepth(frame) {
				var _this__depthInfo, _this__depthInfo1;
				if (!this._manager.views.availableDepth || !this._textureDepth) {
						return;
				}
				var gpu = this._manager.views.depthGpuOptimized;
				var infoSource = gpu ? this._manager.webglBinding : frame;
				if (!infoSource) {
						this._depthInfo = null;
						return;
				}
				var depthInfo = infoSource.getDepthInformation(this._xrView);
				if (!depthInfo) {
						this._depthInfo = null;
						return;
				}
				var matrixDirty = !this._depthInfo !== !depthInfo;
				this._depthInfo = depthInfo;
				var width = ((_this__depthInfo = this._depthInfo) == null ? void 0 : _this__depthInfo.width) || 4;
				var height = ((_this__depthInfo1 = this._depthInfo) == null ? void 0 : _this__depthInfo1.height) || 4;
				var resized = false;
				if (this._textureDepth.width !== width || this._textureDepth.height !== height) {
						this._textureDepth._width = width;
						this._textureDepth._height = height;
						matrixDirty = true;
						resized = true;
				}
				if (matrixDirty) {
						if (this._depthInfo) {
								this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix);
						} else {
								this._depthMatrix.setIdentity();
						}
				}
				if (this._depthInfo) {
						if (gpu) {
								if (this._depthInfo.texture) {
										var gl = this._manager.app.graphicsDevice.gl;
										this._textureDepth.impl._glTexture = this._depthInfo.texture;
										if (this._depthInfo.textureType === 'texture-array') {
												this._textureDepth.impl._glTarget = gl.TEXTURE_2D_ARRAY;
										} else {
												this._textureDepth.impl._glTarget = gl.TEXTURE_2D;
										}
										switch(this._manager.views.depthPixelFormat){
												case PIXELFORMAT_R32F:
														this._textureDepth.impl._glInternalFormat = gl.R32F;
														this._textureDepth.impl._glPixelType = gl.FLOAT;
														this._textureDepth.impl._glFormat = gl.RED;
														break;
												case PIXELFORMAT_DEPTH:
														this._textureDepth.impl._glInternalFormat = gl.DEPTH_COMPONENT16;
														this._textureDepth.impl._glPixelType = gl.UNSIGNED_SHORT;
														this._textureDepth.impl._glFormat = gl.DEPTH_COMPONENT;
														break;
										}
										this._textureDepth.impl._glCreated = true;
								}
						} else {
								this._textureDepth._levels[0] = new Uint8Array(this._depthInfo.data);
								this._textureDepth.upload();
						}
				} else {
						this._textureDepth._levels[0] = this._emptyDepthBuffer;
						this._textureDepth.upload();
				}
				if (resized) this.fire('depth:resize', width, height);
		}
		updateTransforms(transform) {
				if (transform) {
						this._viewInvOffMat.mul2(transform, this._viewInvMat);
						this.viewOffMat.copy(this._viewInvOffMat).invert();
				} else {
						this._viewInvOffMat.copy(this._viewInvMat);
						this.viewOffMat.copy(this._viewMat);
				}
				this._viewMat3.setFromMat4(this._viewOffMat);
				this._projViewOffMat.mul2(this._projMat, this._viewOffMat);
				this._positionData[0] = this._viewInvOffMat.data[12];
				this._positionData[1] = this._viewInvOffMat.data[13];
				this._positionData[2] = this._viewInvOffMat.data[14];
		}
		_onDeviceLost() {
				this._frameBufferSource = null;
				this._frameBuffer = null;
				this._depthInfo = null;
		}
		getDepth(u, v) {
				var _this__depthInfo;
				if (this._manager.views.depthGpuOptimized) {
						return null;
				}
				var _this__depthInfo_getDepthInMeters;
				return (_this__depthInfo_getDepthInMeters = (_this__depthInfo = this._depthInfo) == null ? void 0 : _this__depthInfo.getDepthInMeters(u, v)) != null ? _this__depthInfo_getDepthInMeters : null;
		}
		destroy() {
				this._depthInfo = null;
				if (this._textureColor) {
						this._textureColor.destroy();
						this._textureColor = null;
				}
				if (this._textureDepth) {
						this._textureDepth.destroy();
						this._textureDepth = null;
				}
				if (this._frameBufferSource) {
						var gl = this._manager.app.graphicsDevice.gl;
						gl.deleteFramebuffer(this._frameBufferSource);
						this._frameBufferSource = null;
						gl.deleteFramebuffer(this._frameBuffer);
						this._frameBuffer = null;
				}
		}
		constructor(manager, xrView, viewsCount){
				super(), this._positionData = new Float32Array(3), this._viewport = new Vec4(), this._projMat = new Mat4(), this._projViewOffMat = new Mat4(), this._viewMat = new Mat4(), this._viewOffMat = new Mat4(), this._viewMat3 = new Mat3(), this._viewInvMat = new Mat4(), this._viewInvOffMat = new Mat4(), this._xrCamera = null, this._textureColor = null, this._textureDepth = null, this._depthInfo = null, this._emptyDepthBuffer = new Uint8Array(32), this._depthMatrix = new Mat4();
				this._manager = manager;
				this._xrView = xrView;
				var device = this._manager.app.graphicsDevice;
				if (this._manager.views.supportedColor) {
						this._xrCamera = this._xrView.camera;
						if (this._manager.views.availableColor && this._xrCamera) {
								this._textureColor = new Texture(device, {
										format: PIXELFORMAT_RGB8,
										mipmaps: false,
										addressU: ADDRESS_CLAMP_TO_EDGE,
										addressV: ADDRESS_CLAMP_TO_EDGE,
										minFilter: FILTER_LINEAR,
										magFilter: FILTER_LINEAR,
										width: this._xrCamera.width,
										height: this._xrCamera.height,
										name: "XrView-" + this._xrView.eye + "-Color"
								});
						}
				}
				if (this._manager.views.supportedDepth && this._manager.views.availableDepth) {
						var filtering = this._manager.views.depthGpuOptimized ? FILTER_NEAREST : FILTER_LINEAR;
						this._textureDepth = new Texture(device, {
								format: this._manager.views.depthPixelFormat,
								arrayLength: viewsCount === 1 ? 0 : viewsCount,
								mipmaps: false,
								addressU: ADDRESS_CLAMP_TO_EDGE,
								addressV: ADDRESS_CLAMP_TO_EDGE,
								minFilter: filtering,
								magFilter: filtering,
								width: 4,
								height: 4,
								name: "XrView-" + this._xrView.eye + "-Depth"
						});
						for(var i = 0; i < this._textureDepth._levels.length; i++){
								this._textureDepth._levels[i] = this._emptyDepthBuffer;
						}
						this._textureDepth.upload();
				}
				if (this._textureColor || this._textureDepth) {
						device.on('devicelost', this._onDeviceLost, this);
				}
		}
}
XrView.EVENT_DEPTHRESIZE = 'depth:resize';

class XrViews extends EventHandler {
		get list() {
				return this._list;
		}
		get supportedColor() {
				return this._supportedColor;
		}
		get supportedDepth() {
				return this._supportedDepth;
		}
		get availableColor() {
				return this._availableColor;
		}
		get availableDepth() {
				return this._availableDepth;
		}
		get depthUsage() {
				return this._depthUsage;
		}
		get depthGpuOptimized() {
				return this._depthUsage === XRDEPTHSENSINGUSAGE_GPU;
		}
		get depthFormat() {
				return this._depthFormat;
		}
		get depthPixelFormat() {
				var _this__depthFormats_this__depthFormat;
				return (_this__depthFormats_this__depthFormat = this._depthFormats[this._depthFormat]) != null ? _this__depthFormats_this__depthFormat : null;
		}
		update(frame, xrViews) {
				for(var i = 0; i < xrViews.length; i++){
						this._indexTmp.set(xrViews[i].eye, xrViews[i]);
				}
				for (var [eye, xrView] of this._indexTmp){
						var view = this._index.get(eye);
						if (!view) {
								view = new XrView(this._manager, xrView, xrViews.length);
								this._index.set(eye, view);
								this._list.push(view);
								view.update(frame, xrView);
								this.fire('add', view);
						} else {
								view.update(frame, xrView);
						}
				}
				for (var [eye1, view1] of this._index){
						if (this._indexTmp.has(eye1)) {
								continue;
						}
						view1.destroy();
						this._index.delete(eye1);
						var ind = this._list.indexOf(view1);
						if (ind !== -1) this._list.splice(ind, 1);
						this.fire('remove', view1);
				}
				this._indexTmp.clear();
		}
		get(eye) {
				return this._index.get(eye) || null;
		}
		_onSessionStart() {
				if (this._manager.type !== XRTYPE_AR) {
						return;
				}
				if (!this._manager.session.enabledFeatures) {
						return;
				}
				this._availableColor = this._manager.session.enabledFeatures.indexOf('camera-access') !== -1;
				this._availableDepth = this._manager.session.enabledFeatures.indexOf('depth-sensing') !== -1;
				if (this._availableDepth) {
						var session = this._manager.session;
						this._depthUsage = session.depthUsage;
						this._depthFormat = session.depthDataFormat;
				}
		}
		_onSessionEnd() {
				for (var view of this._index.values()){
						view.destroy();
				}
				this._index.clear();
				this._availableColor = false;
				this._availableDepth = false;
				this._depthUsage = '';
				this._depthFormat = '';
				this._list.length = 0;
		}
		constructor(manager){
				super(), this._index = new Map(), this._indexTmp = new Map(), this._list = [], this._supportedColor = platform.browser && !!window.XRCamera && !!window.XRWebGLBinding, this._supportedDepth = platform.browser && !!window.XRDepthInformation, this._availableColor = false, this._availableDepth = false, this._depthUsage = '', this._depthFormat = '', this._depthFormats = {
						[XRDEPTHSENSINGFORMAT_L8A8]: PIXELFORMAT_LA8,
						[XRDEPTHSENSINGFORMAT_R16U]: PIXELFORMAT_DEPTH,
						[XRDEPTHSENSINGFORMAT_F32]: PIXELFORMAT_R32F
				};
				this._manager = manager;
				this._manager.on('start', this._onSessionStart, this);
				this._manager.on('end', this._onSessionEnd, this);
		}
}
XrViews.EVENT_ADD = 'add';
XrViews.EVENT_REMOVE = 'remove';

class XrManager extends EventHandler {
		destroy() {}
		start(camera, type, spaceType, options) {
				var _this_app_graphicsDevice;
				var callback = options;
				if (typeof options === 'object') {
						callback = options.callback;
				}
				if (!this._available[type]) {
						if (callback) callback(new Error('XR is not available'));
						return;
				}
				if (this._session) {
						if (callback) callback(new Error('XR session is already started'));
						return;
				}
				this._camera = camera;
				this._camera.camera.xr = this;
				this._type = type;
				this._spaceType = spaceType;
				var _options_framebufferScaleFactor;
				this._framebufferScaleFactor = (_options_framebufferScaleFactor = options == null ? void 0 : options.framebufferScaleFactor) != null ? _options_framebufferScaleFactor : 1.0;
				this._setClipPlanes(camera.nearClip, camera.farClip);
				var opts = {
						requiredFeatures: [
								spaceType
						],
						optionalFeatures: []
				};
				var webgl = (_this_app_graphicsDevice = this.app.graphicsDevice) == null ? void 0 : _this_app_graphicsDevice.isWebGL2;
				if (type === XRTYPE_AR) {
						opts.optionalFeatures.push('light-estimation');
						opts.optionalFeatures.push('hit-test');
						if (options) {
								if (options.imageTracking && this.imageTracking.supported) {
										opts.optionalFeatures.push('image-tracking');
								}
								if (options.planeDetection) {
										opts.optionalFeatures.push('plane-detection');
								}
								if (options.meshDetection) {
										opts.optionalFeatures.push('mesh-detection');
								}
						}
						if (this.domOverlay.supported && this.domOverlay.root) {
								opts.optionalFeatures.push('dom-overlay');
								opts.domOverlay = {
										root: this.domOverlay.root
								};
						}
						if (options && options.anchors && this.anchors.supported) {
								opts.optionalFeatures.push('anchors');
						}
						if (options && options.depthSensing && this.views.supportedDepth) {
								opts.optionalFeatures.push('depth-sensing');
								var usagePreference = [];
								var dataFormatPreference = [];
								usagePreference.push(XRDEPTHSENSINGUSAGE_GPU, XRDEPTHSENSINGUSAGE_CPU);
								dataFormatPreference.push(XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGFORMAT_R16U);
								if (options.depthSensing.usagePreference) {
										var ind = usagePreference.indexOf(options.depthSensing.usagePreference);
										if (ind !== -1) usagePreference.splice(ind, 1);
										usagePreference.unshift(options.depthSensing.usagePreference);
								}
								if (options.depthSensing.dataFormatPreference) {
										var ind1 = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);
										if (ind1 !== -1) dataFormatPreference.splice(ind1, 1);
										dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
								}
								opts.depthSensing = {
										usagePreference: usagePreference,
										dataFormatPreference: dataFormatPreference
								};
						}
						if (webgl && options && options.cameraColor && this.views.supportedColor) {
								opts.optionalFeatures.push('camera-access');
						}
				}
				opts.optionalFeatures.push('hand-tracking');
				if (options && options.optionalFeatures) {
						opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);
				}
				if (this.imageTracking.supported && this.imageTracking.images.length) {
						this.imageTracking.prepareImages((err, trackedImages)=>{
								if (err) {
										if (callback) callback(err);
										this.fire('error', err);
										return;
								}
								if (trackedImages !== null) {
										opts.trackedImages = trackedImages;
								}
								this._onStartOptionsReady(type, spaceType, opts, callback);
						});
				} else {
						this._onStartOptionsReady(type, spaceType, opts, callback);
				}
		}
		_onStartOptionsReady(type, spaceType, options, callback) {
				navigator.xr.requestSession(type, options).then((session)=>{
						this._onSessionStart(session, spaceType, callback);
				}).catch((ex)=>{
						this._camera.camera.xr = null;
						this._camera = null;
						this._type = null;
						this._spaceType = null;
						if (callback) callback(ex);
						this.fire('error', ex);
				});
		}
		end(callback) {
				if (!this._session) {
						if (callback) callback(new Error('XR Session is not initialized'));
						return;
				}
				this.webglBinding = null;
				if (callback) this.once('end', callback);
				this._session.end();
		}
		isAvailable(type) {
				return this._available[type];
		}
		_deviceAvailabilityCheck() {
				for(var key in this._available){
						this._sessionSupportCheck(key);
				}
		}
		initiateRoomCapture(callback) {
				if (!this._session) {
						callback(new Error('Session is not active'));
						return;
				}
				if (!this._session.initiateRoomCapture) {
						callback(new Error('Session does not support manual room capture'));
						return;
				}
				this._session.initiateRoomCapture().then(()=>{
						if (callback) callback(null);
				}).catch((err)=>{
						if (callback) callback(err);
				});
		}
		updateTargetFrameRate(frameRate, callback) {
				var _this__session;
				if (!((_this__session = this._session) == null ? void 0 : _this__session.updateTargetFrameRate)) {
						callback == null ? void 0 : callback(new Error('unable to update frameRate'));
						return;
				}
				this._session.updateTargetFrameRate(frameRate).then(()=>{
						callback == null ? void 0 : callback();
				}).catch((err)=>{
						callback == null ? void 0 : callback(err);
				});
		}
		_sessionSupportCheck(type) {
				navigator.xr.isSessionSupported(type).then((available)=>{
						if (this._available[type] === available) {
								return;
						}
						this._available[type] = available;
						this.fire('available', type, available);
						this.fire("available:" + type, available);
				}).catch((ex)=>{
						this.fire('error', ex);
				});
		}
		_onSessionStart(session, spaceType, callback) {
				var failed = false;
				this._session = session;
				var onVisibilityChange = ()=>{
						this.fire('visibility:change', session.visibilityState);
				};
				var onClipPlanesChange = ()=>{
						this._setClipPlanes(this._camera.nearClip, this._camera.farClip);
				};
				var onEnd = ()=>{
						if (this._camera) {
								this._camera.off('set_nearClip', onClipPlanesChange);
								this._camera.off('set_farClip', onClipPlanesChange);
								this._camera.camera.xr = null;
								this._camera = null;
						}
						session.removeEventListener('end', onEnd);
						session.removeEventListener('visibilitychange', onVisibilityChange);
						if (!failed) this.fire('end');
						this._session = null;
						this._referenceSpace = null;
						this._width = 0;
						this._height = 0;
						this._type = null;
						this._spaceType = null;
						if (this.app.systems) {
								this.app.tick();
						}
				};
				session.addEventListener('end', onEnd);
				session.addEventListener('visibilitychange', onVisibilityChange);
				this._camera.on('set_nearClip', onClipPlanesChange);
				this._camera.on('set_farClip', onClipPlanesChange);
				this._createBaseLayer();
				if (this.session.supportedFrameRates) {
						this._supportedFrameRates = Array.from(this.session.supportedFrameRates);
				} else {
						this._supportedFrameRates = null;
				}
				this._session.addEventListener('frameratechange', ()=>{
						var _this__session;
						this.fire('frameratechange', (_this__session = this._session) == null ? void 0 : _this__session.frameRate);
				});
				session.requestReferenceSpace(spaceType).then((referenceSpace)=>{
						this._referenceSpace = referenceSpace;
						this.app.tick();
						if (callback) callback(null);
						this.fire('start');
				}).catch((ex)=>{
						failed = true;
						session.end();
						if (callback) callback(ex);
						this.fire('error', ex);
				});
		}
		_setClipPlanes(near, far) {
				if (this._depthNear === near && this._depthFar === far) {
						return;
				}
				this._depthNear = near;
				this._depthFar = far;
				if (!this._session) {
						return;
				}
				this._session.updateRenderState({
						depthNear: this._depthNear,
						depthFar: this._depthFar
				});
		}
		_createBaseLayer() {
				var device = this.app.graphicsDevice;
				var framebufferScaleFactor = device.maxPixelRatio / window.devicePixelRatio * this._framebufferScaleFactor;
				this._baseLayer = new XRWebGLLayer(this._session, device.gl, {
						alpha: true,
						depth: true,
						stencil: true,
						framebufferScaleFactor: framebufferScaleFactor,
						antialias: false
				});
				if ((device == null ? void 0 : device.isWebGL2) && window.XRWebGLBinding) {
						try {
								this.webglBinding = new XRWebGLBinding(this._session, device.gl);
						} catch (ex) {
								this.fire('error', ex);
						}
				}
				this._session.updateRenderState({
						baseLayer: this._baseLayer,
						depthNear: this._depthNear,
						depthFar: this._depthFar
				});
		}
		_onDeviceLost() {
				if (!this._session) {
						return;
				}
				if (this.webglBinding) {
						this.webglBinding = null;
				}
				this._baseLayer = null;
				this._session.updateRenderState({
						baseLayer: this._baseLayer,
						depthNear: this._depthNear,
						depthFar: this._depthFar
				});
		}
		_onDeviceRestored() {
				if (!this._session) {
						return;
				}
				setTimeout(()=>{
						this.app.graphicsDevice.gl.makeXRCompatible().then(()=>{
								this._createBaseLayer();
						}).catch((ex)=>{
								this.fire('error', ex);
						});
				}, 0);
		}
		update(frame) {
				if (!this._session) return false;
				var width = frame.session.renderState.baseLayer.framebufferWidth;
				var height = frame.session.renderState.baseLayer.framebufferHeight;
				if (this._width !== width || this._height !== height) {
						this._width = width;
						this._height = height;
						this.app.graphicsDevice.setResolution(width, height);
				}
				var pose = frame.getViewerPose(this._referenceSpace);
				if (!pose) return false;
				var lengthOld = this.views.list.length;
				this.views.update(frame, pose.views);
				var posePosition = pose.transform.position;
				var poseOrientation = pose.transform.orientation;
				this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
				this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);
				if (lengthOld === 0 && this.views.list.length > 0) {
						var viewProjMat = new Mat4();
						var view = this.views.list[0];
						viewProjMat.copy(view.projMat);
						var data = viewProjMat.data;
						var fov = 2.0 * Math.atan(1.0 / data[5]) * 180.0 / Math.PI;
						var aspectRatio = data[5] / data[0];
						var farClip = data[14] / (data[10] + 1);
						var nearClip = data[14] / (data[10] - 1);
						var horizontalFov = false;
						var camera = this._camera.camera;
						camera.setXrProperties({
								aspectRatio,
								farClip,
								fov,
								horizontalFov,
								nearClip
						});
				}
				this._camera.camera._node.setLocalPosition(this._localPosition);
				this._camera.camera._node.setLocalRotation(this._localRotation);
				this.input.update(frame);
				if (this._type === XRTYPE_AR) {
						if (this.hitTest.supported) {
								this.hitTest.update(frame);
						}
						if (this.lightEstimation.supported) {
								this.lightEstimation.update(frame);
						}
						if (this.imageTracking.supported) {
								this.imageTracking.update(frame);
						}
						if (this.anchors.supported) {
								this.anchors.update(frame);
						}
						if (this.planeDetection.supported) {
								this.planeDetection.update(frame);
						}
						if (this.meshDetection.supported) {
								this.meshDetection.update(frame);
						}
				}
				this.fire('update', frame);
				return true;
		}
		get supported() {
				return this._supported;
		}
		get active() {
				return !!this._session;
		}
		get type() {
				return this._type;
		}
		get spaceType() {
				return this._spaceType;
		}
		get session() {
				return this._session;
		}
		get frameRate() {
				var _this__session;
				var _this__session_frameRate;
				return (_this__session_frameRate = (_this__session = this._session) == null ? void 0 : _this__session.frameRate) != null ? _this__session_frameRate : null;
		}
		get supportedFrameRates() {
				return this._supportedFrameRates;
		}
		get framebufferScaleFactor() {
				return this._framebufferScaleFactor;
		}
		set fixedFoveation(value) {
				var _this__baseLayer;
				var _this__baseLayer_fixedFoveation;
				if (((_this__baseLayer_fixedFoveation = (_this__baseLayer = this._baseLayer) == null ? void 0 : _this__baseLayer.fixedFoveation) != null ? _this__baseLayer_fixedFoveation : null) !== null) {
						if (this.app.graphicsDevice.samples > 1) ;
						this._baseLayer.fixedFoveation = value;
				}
		}
		get fixedFoveation() {
				var _this__baseLayer;
				var _this__baseLayer_fixedFoveation;
				return (_this__baseLayer_fixedFoveation = (_this__baseLayer = this._baseLayer) == null ? void 0 : _this__baseLayer.fixedFoveation) != null ? _this__baseLayer_fixedFoveation : null;
		}
		get camera() {
				return this._camera ? this._camera.entity : null;
		}
		get visibilityState() {
				if (!this._session) {
						return null;
				}
				return this._session.visibilityState;
		}
		constructor(app){
				super(), this._supported = platform.browser && !!navigator.xr, this._available = {}, this._type = null, this._spaceType = null, this._session = null, this._baseLayer = null, this.webglBinding = null, this._referenceSpace = null, this._camera = null, this._localPosition = new Vec3(), this._localRotation = new Quat(), this._depthNear = 0.1, this._depthFar = 1000, this._supportedFrameRates = null, this._width = 0, this._height = 0, this._framebufferScaleFactor = 1.0;
				this.app = app;
				this._available[XRTYPE_INLINE] = false;
				this._available[XRTYPE_VR] = false;
				this._available[XRTYPE_AR] = false;
				this.views = new XrViews(this);
				this.domOverlay = new XrDomOverlay(this);
				this.hitTest = new XrHitTest(this);
				this.imageTracking = new XrImageTracking(this);
				this.planeDetection = new XrPlaneDetection(this);
				this.meshDetection = new XrMeshDetection(this);
				this.input = new XrInput(this);
				this.lightEstimation = new XrLightEstimation(this);
				this.anchors = new XrAnchors(this);
				this.views = new XrViews(this);
				if (this._supported) {
						navigator.xr.addEventListener('devicechange', ()=>{
								this._deviceAvailabilityCheck();
						});
						this._deviceAvailabilityCheck();
						this.app.graphicsDevice.on('devicelost', this._onDeviceLost, this);
						this.app.graphicsDevice.on('devicerestored', this._onDeviceRestored, this);
				}
		}
}
XrManager.EVENT_AVAILABLE = 'available';
XrManager.EVENT_START = 'start';
XrManager.EVENT_END = 'end';
XrManager.EVENT_UPDATE = 'update';
XrManager.EVENT_ERROR = 'error';

class Application extends AppBase {
		createDevice(canvas, options) {
				if (!options.graphicsDeviceOptions) {
						options.graphicsDeviceOptions = {};
				}
				if (platform.browser && !!navigator.xr) {
						options.graphicsDeviceOptions.xrCompatible = true;
				}
				options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
				return new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);
		}
		addComponentSystems(appOptions) {
				appOptions.componentSystems = [
						RigidBodyComponentSystem,
						CollisionComponentSystem,
						JointComponentSystem,
						AnimationComponentSystem,
						AnimComponentSystem,
						ModelComponentSystem,
						RenderComponentSystem,
						CameraComponentSystem,
						LightComponentSystem,
						ScriptComponentSystem,
						SoundComponentSystem,
						AudioListenerComponentSystem,
						ParticleSystemComponentSystem,
						ScreenComponentSystem,
						ElementComponentSystem,
						ButtonComponentSystem,
						ScrollViewComponentSystem,
						ScrollbarComponentSystem,
						SpriteComponentSystem,
						LayoutGroupComponentSystem,
						LayoutChildComponentSystem,
						ZoneComponentSystem,
						GSplatComponentSystem
				];
		}
		addResourceHandles(appOptions) {
				appOptions.resourceHandlers = [
						RenderHandler,
						AnimationHandler,
						AnimClipHandler,
						AnimStateGraphHandler,
						ModelHandler,
						MaterialHandler,
						TextureHandler,
						TextHandler,
						JsonHandler,
						AudioHandler,
						ScriptHandler,
						SceneHandler,
						CubemapHandler,
						HtmlHandler,
						CssHandler,
						ShaderHandler,
						HierarchyHandler,
						FolderHandler,
						FontHandler,
						BinaryHandler,
						TextureAtlasHandler,
						SpriteHandler,
						TemplateHandler,
						ContainerHandler,
						GSplatHandler
				];
		}
		constructor(canvas, options = {}){
				super(canvas);
				var appOptions = new AppOptions();
				var _options_graphicsDevice;
				appOptions.graphicsDevice = (_options_graphicsDevice = options.graphicsDevice) != null ? _options_graphicsDevice : this.createDevice(canvas, options);
				this.addComponentSystems(appOptions);
				this.addResourceHandles(appOptions);
				appOptions.elementInput = options.elementInput;
				appOptions.keyboard = options.keyboard;
				appOptions.mouse = options.mouse;
				appOptions.touch = options.touch;
				appOptions.gamepads = options.gamepads;
				appOptions.scriptPrefix = options.scriptPrefix;
				appOptions.assetPrefix = options.assetPrefix;
				appOptions.scriptsOrder = options.scriptsOrder;
				appOptions.soundManager = new SoundManager();
				appOptions.lightmapper = Lightmapper;
				appOptions.batchManager = BatchManager;
				appOptions.xr = XrManager;
				this.init(appOptions);
		}
}

class AssetListLoader extends EventHandler {
		destroy() {
				this._registry.off('load', this._onLoad);
				this._registry.off('error', this._onError);
				this._waitingAssets.forEach((id)=>{
						this._registry.off("add:" + id, this._onAddAsset);
				});
				this.off('progress');
				this.off('load');
		}
		_assetHasDependencies(asset) {
				var _asset_file;
				return asset.type === 'model' && ((_asset_file = asset.file) == null ? void 0 : _asset_file.url) && asset.file.url && asset.file.url.match(/.json$/g);
		}
		load(done, scope) {
				if (this._loading) {
						return;
				}
				this._loading = true;
				this._callback = done;
				this._scope = scope;
				this._registry.on('load', this._onLoad, this);
				this._registry.on('error', this._onError, this);
				var loadingAssets = false;
				this._assets.forEach((asset)=>{
						if (!asset.loaded) {
								loadingAssets = true;
								if (this._assetHasDependencies(asset)) {
										this._registry.loadFromUrl(asset.file.url, asset.type, (err, loadedAsset)=>{
												if (err) {
														this._onError(err, asset);
														return;
												}
												this._onLoad(asset);
										});
								}
								this._loadingAssets.add(asset);
								this._registry.add(asset);
						}
				});
				this._loadingAssets.forEach((asset)=>{
						if (!this._assetHasDependencies(asset)) {
								this._registry.load(asset);
						}
				});
				if (!loadingAssets && this._waitingAssets.size === 0) {
						this._loadingComplete();
				}
		}
		ready(done, scope) {
				if (scope === void 0) scope = this;
				if (this._loaded) {
						done.call(scope, Array.from(this._assets));
				} else {
						this.once('load', (assets)=>{
								done.call(scope, assets);
						});
				}
		}
		_loadingComplete() {
				if (this._loaded) return;
				this._loaded = true;
				this._registry.off('load', this._onLoad, this);
				this._registry.off('error', this._onError, this);
				if (this._failed.length) {
						if (this._callback) {
								this._callback.call(this._scope, 'Failed to load some assets', this._failed);
						}
						this.fire('error', this._failed);
				} else {
						if (this._callback) {
								this._callback.call(this._scope);
						}
						this.fire('load', Array.from(this._assets));
				}
		}
		_onLoad(asset) {
				if (this._loadingAssets.has(asset)) {
						this.fire('progress', asset);
						this._loadingAssets.delete(asset);
				}
				if (this._loadingAssets.size === 0) {
						setTimeout(()=>{
								this._loadingComplete();
						}, 0);
				}
		}
		_onError(err, asset) {
				if (this._loadingAssets.has(asset)) {
						this._failed.push(asset);
						this._loadingAssets.delete(asset);
				}
				if (this._loadingAssets.size === 0) {
						setTimeout(()=>{
								this._loadingComplete();
						}, 0);
				}
		}
		_onAddAsset(asset) {
				this._waitingAssets.delete(asset);
				this._assets.add(asset);
				if (!asset.loaded) {
						this._loadingAssets.add(asset);
						this._registry.load(asset);
				}
		}
		_waitForAsset(assetId) {
				this._waitingAssets.add(assetId);
				this._registry.once("add:" + assetId, this._onAddAsset, this);
		}
		constructor(assetList, assetRegistry){
				super(), this._assets = new Set(), this._loadingAssets = new Set(), this._waitingAssets = new Set(), this._loading = false, this._loaded = false, this._failed = [];
				this._registry = assetRegistry;
				assetList.forEach((a)=>{
						if (a instanceof Asset) {
								if (!a.registry) {
										a.registry = assetRegistry;
								}
								this._assets.add(a);
						} else {
								var asset = assetRegistry.get(a);
								if (asset) {
										this._assets.add(asset);
								} else {
										this._waitForAsset(a);
								}
						}
				});
		}
}

var MAX_TEXTURE_SIZE = 4096;
var DEFAULT_TEXTURE_SIZE = 512;
class Atlas {
		destroy() {
				this.texture.destroy();
		}
		clear(clearColor) {
				var { width, height } = this.canvas;
				this.ctx.clearRect(0, 0, width, height);
				this.ctx.fillStyle = clearColor;
				this.ctx.fillRect(0, 0, width, height);
		}
		constructor(device, width, height, name){
				this.canvas = document.createElement('canvas');
				this.canvas.width = width;
				this.canvas.height = height;
				this.texture = new Texture(device, {
						name: name,
						format: PIXELFORMAT_SRGBA8,
						width: width,
						height: height,
						mipmaps: true,
						minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
						magFilter: FILTER_LINEAR,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						levels: [
								this.canvas
						]
				});
				this.ctx = this.canvas.getContext('2d', {
						alpha: true
				});
		}
}
class CanvasFont extends EventHandler {
		createTextures(text) {
				var _chars = this._normalizeCharsSet(text);
				if (_chars.length !== this.chars.length) {
						this._renderAtlas(_chars);
						return;
				}
				for(var i = 0; i < _chars.length; i++){
						if (_chars[i] !== this.chars[i]) {
								this._renderAtlas(_chars);
								return;
						}
				}
		}
		updateTextures(text) {
				var _chars = this._normalizeCharsSet(text);
				var newCharsSet = [];
				for(var i = 0; i < _chars.length; i++){
						var char = _chars[i];
						if (!this.data.chars[char]) {
								newCharsSet.push(char);
						}
				}
				if (newCharsSet.length > 0) {
						this._renderAtlas(this.chars.concat(newCharsSet));
				}
		}
		destroy() {
				this.atlases.forEach((atlas)=>atlas.destroy());
				this.chars = null;
				this.color = null;
				this.data = null;
				this.fontName = null;
				this.fontSize = null;
				this.glyphSize = null;
				this.intensity = null;
				this.atlases = null;
				this.type = null;
				this.fontWeight = null;
		}
		_colorToRgbString(color, alpha) {
				var str;
				var r = Math.round(255 * color.r);
				var g = Math.round(255 * color.g);
				var b = Math.round(255 * color.b);
				if (alpha) {
						str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
				} else {
						str = "rgb(" + r + ", " + g + ", " + b + ")";
				}
				return str;
		}
		renderCharacter(context, char, x, y, color) {
				context.fillStyle = color;
				context.fillText(char, x, y);
		}
		_getAtlas(index) {
				if (index >= this.atlases.length) {
						this.atlases[index] = new Atlas(this.app.graphicsDevice, this.width, this.height, "font-atlas-" + this.fontName + "-" + index);
				}
				return this.atlases[index];
		}
		_renderAtlas(charsArray) {
				this.chars = charsArray;
				var w = this.width;
				var h = this.height;
				var color = this._colorToRgbString(this.color, false);
				var a = this.color.a;
				this.color.a = 1 / 255;
				var transparent = this._colorToRgbString(this.color, true);
				this.color.a = a;
				var TEXT_ALIGN = 'center';
				var TEXT_BASELINE = 'alphabetic';
				var atlasIndex = 0;
				var atlas = this._getAtlas(atlasIndex++);
				atlas.clear(transparent);
				this.data = this._createJson(this.chars, this.fontName, w, h);
				var symbols = string.getSymbols(this.chars.join(''));
				var maxHeight = 0;
				var maxDescent = 0;
				var metrics = {};
				for(var i = 0; i < symbols.length; i++){
						var ch = symbols[i];
						metrics[ch] = this._getTextMetrics(ch);
						maxHeight = Math.max(maxHeight, metrics[ch].height);
						maxDescent = Math.max(maxDescent, metrics[ch].descent);
				}
				this.glyphSize = Math.max(this.glyphSize, maxHeight);
				var sx = this.glyphSize + this.padding * 2;
				var sy = this.glyphSize + this.padding * 2;
				var _xOffset = this.glyphSize / 2 + this.padding;
				var _yOffset = sy - maxDescent - this.padding;
				var _x = 0;
				var _y = 0;
				for(var i1 = 0; i1 < symbols.length; i1++){
						var ch1 = symbols[i1];
						var code = string.getCodePoint(symbols[i1]);
						var fs = this.fontSize;
						atlas.ctx.font = this.fontWeight + " " + fs.toString() + "px " + this.fontName;
						atlas.ctx.textAlign = TEXT_ALIGN;
						atlas.ctx.textBaseline = TEXT_BASELINE;
						var width = atlas.ctx.measureText(ch1).width;
						if (width > fs) {
								fs = this.fontSize * this.fontSize / width;
								atlas.ctx.font = this.fontWeight + " " + fs.toString() + "px " + this.fontName;
								width = this.fontSize;
						}
						this.renderCharacter(atlas.ctx, ch1, _x + _xOffset, _y + _yOffset, color);
						var xoffset = this.padding + (this.glyphSize - width) / 2;
						var yoffset = -this.padding + metrics[ch1].descent - maxDescent;
						var xadvance = width;
						this._addChar(this.data, ch1, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, atlasIndex - 1, w, h);
						_x += sx;
						if (_x + sx > w) {
								_x = 0;
								_y += sy;
								if (_y + sy > h) {
										atlas = this._getAtlas(atlasIndex++);
										atlas.clear(transparent);
										_y = 0;
								}
						}
				}
				this.atlases.splice(atlasIndex).forEach((atlas)=>atlas.destroy());
				this.atlases.forEach((atlas)=>atlas.texture.upload());
				this.fire('render');
		}
		_createJson(chars, fontName, width, height) {
				var base = {
						'version': 3,
						'intensity': this.intensity,
						'info': {
								'face': fontName,
								'width': width,
								'height': height,
								'maps': [
										{
												'width': width,
												'height': height
										}
								]
						},
						'chars': {}
				};
				return base;
		}
		_addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
				if (json.info.maps.length < mapNum + 1) {
						json.info.maps.push({
								'width': mapW,
								'height': mapH
						});
				}
				var scale = this.fontSize / 32;
				json.chars[char] = {
						'id': charCode,
						'letter': char,
						'x': x,
						'y': y,
						'width': w,
						'height': h,
						'xadvance': xadvance / scale,
						'xoffset': xoffset / scale,
						'yoffset': (yoffset + this.padding) / scale,
						'scale': scale,
						'range': 1,
						'map': mapNum,
						'bounds': [
								0,
								0,
								w / scale,
								h / scale
						]
				};
		}
		_normalizeCharsSet(text) {
				var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
				if (unicodeConverterFunc) {
						text = unicodeConverterFunc(text);
				}
				var set = {};
				var symbols = string.getSymbols(text);
				for(var i = 0; i < symbols.length; i++){
						var ch = symbols[i];
						if (set[ch]) continue;
						set[ch] = ch;
				}
				var chars = Object.keys(set);
				return chars.sort();
		}
		_getTextMetrics(text) {
				var textSpan = document.createElement('span');
				textSpan.id = 'content-span';
				textSpan.innerHTML = text;
				var block = document.createElement('div');
				block.id = 'content-block';
				block.style.display = 'inline-block';
				block.style.width = '1px';
				block.style.height = '0px';
				var div = document.createElement('div');
				div.appendChild(textSpan);
				div.appendChild(block);
				div.style.font = this.fontSize + "px " + this.fontName;
				var body = document.body;
				body.appendChild(div);
				var ascent = -1;
				var descent = -1;
				var height = -1;
				try {
						block.style['vertical-align'] = 'baseline';
						ascent = block.offsetTop - textSpan.offsetTop;
						block.style['vertical-align'] = 'bottom';
						height = block.offsetTop - textSpan.offsetTop;
						descent = height - ascent;
				} finally{
						document.body.removeChild(div);
				}
				return {
						ascent: ascent,
						descent: descent,
						height: height
				};
		}
		get textures() {
				return this.atlases.map((atlas)=>atlas.texture);
		}
		constructor(app, options = {}){
				super();
				this.type = 'bitmap';
				this.app = app;
				this.intensity = 0;
				this.fontWeight = options.fontWeight || 'normal';
				this.fontSize = parseInt(options.fontSize, 10);
				this.glyphSize = this.fontSize;
				this.fontName = options.fontName || 'Arial';
				this.color = options.color || new Color(1, 1, 1);
				this.padding = options.padding || 0;
				this.width = Math.min(MAX_TEXTURE_SIZE, options.width || DEFAULT_TEXTURE_SIZE);
				this.height = Math.min(MAX_TEXTURE_SIZE, options.height || DEFAULT_TEXTURE_SIZE);
				this.atlases = [];
				this.chars = '';
				this.data = {};
		}
}

var tempMeshInstances$1 = [];
var lights = [
		[],
		[],
		[]
];
class RenderPassPicker extends RenderPass {
		destroy() {
				this.viewBindGroups.forEach((bg)=>{
						bg.defaultUniformBuffer.destroy();
						bg.destroy();
				});
				this.viewBindGroups.length = 0;
		}
		update(camera, scene, layers, mapping) {
				this.camera = camera;
				this.scene = scene;
				this.layers = layers;
				this.mapping = mapping;
		}
		execute() {
				var device = this.device;
				var { renderer, camera, scene, layers, mapping, renderTarget } = this;
				var srcLayers = scene.layers.layerList;
				var subLayerEnabled = scene.layers.subLayerEnabled;
				var isTransparent = scene.layers.subLayerList;
				for(var i = 0; i < srcLayers.length; i++){
						var srcLayer = srcLayers[i];
						if (layers && layers.indexOf(srcLayer) < 0) {
								continue;
						}
						if (srcLayer.enabled && subLayerEnabled[i]) {
								if (srcLayer.camerasSet.has(camera.camera)) {
										var transparent = isTransparent[i];
										if (srcLayer._clearDepthBuffer) {
												renderer.clear(camera.camera, false, true, false);
										}
										var meshInstances = srcLayer.meshInstances;
										for(var j = 0; j < meshInstances.length; j++){
												var meshInstance = meshInstances[j];
												if (meshInstance.pick && meshInstance.transparent === transparent) {
														tempMeshInstances$1.push(meshInstance);
														mapping.set(meshInstance.id, meshInstance);
												}
										}
										if (tempMeshInstances$1.length > 0) {
												var clusteredLightingEnabled = scene.clusteredLightingEnabled;
												if (clusteredLightingEnabled) {
														var lightClusters = renderer.worldClustersAllocator.empty;
														lightClusters.activate();
												}
												renderer.setCameraUniforms(camera.camera, renderTarget);
												if (device.supportsUniformBuffers) {
														renderer.setupViewUniformBuffers(this.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, 1);
												}
												renderer.renderForward(camera.camera, renderTarget, tempMeshInstances$1, lights, SHADER_PICK, (meshInstance)=>{
														device.setBlendState(BlendState.NOBLEND);
												});
												tempMeshInstances$1.length = 0;
										}
								}
						}
				}
		}
		constructor(device, renderer){
				super(device), this.viewBindGroups = [];
				this.renderer = renderer;
		}
}

var tempSet = new Set();
var _rect = new Vec4();
class Picker {
		getSelection(x, y, width, height) {
				if (width === void 0) width = 1;
				if (height === void 0) height = 1;
				var device = this.device;
				if (device.isWebGPU) {
						return [];
				}
				y = this.renderTarget.height - (y + height);
				var rect = this.sanitizeRect(x, y, width, height);
				device.setRenderTarget(this.renderTarget);
				device.updateBegin();
				var pixels = new Uint8Array(4 * rect.z * rect.w);
				device.readPixels(rect.x, rect.y, rect.z, rect.w, pixels);
				device.updateEnd();
				return this.decodePixels(pixels, this.mapping);
		}
		getSelectionAsync(x, y, width, height) {
				if (width === void 0) width = 1;
				if (height === void 0) height = 1;
				var _this_device;
				if ((_this_device = this.device) == null ? void 0 : _this_device.isWebGL2) {
						y = this.renderTarget.height - (y + height);
				}
				var rect = this.sanitizeRect(x, y, width, height);
				return this.renderTarget.colorBuffer.read(rect.x, rect.y, rect.z, rect.w, {
						renderTarget: this.renderTarget,
						immediate: true
				}).then((pixels)=>{
						return this.decodePixels(pixels, this.mapping);
				});
		}
		sanitizeRect(x, y, width, height) {
				var maxWidth = this.renderTarget.width;
				var maxHeight = this.renderTarget.height;
				x = math.clamp(Math.floor(x), 0, maxWidth - 1);
				y = math.clamp(Math.floor(y), 0, maxHeight - 1);
				width = Math.floor(Math.max(width, 1));
				width = Math.min(width, maxWidth - x);
				height = Math.floor(Math.max(height, 1));
				height = Math.min(height, maxHeight - y);
				return _rect.set(x, y, width, height);
		}
		decodePixels(pixels, mapping) {
				var selection = [];
				if (this.deviceValid) {
						var count = pixels.length;
						for(var i = 0; i < count; i += 4){
								var r = pixels[i + 0];
								var g = pixels[i + 1];
								var b = pixels[i + 2];
								var a = pixels[i + 3];
								var index = a << 24 | r << 16 | g << 8 | b;
								if (index !== -1) {
										tempSet.add(mapping.get(index));
								}
						}
						tempSet.forEach((meshInstance)=>{
								if (meshInstance) {
										selection.push(meshInstance);
								}
						});
						tempSet.clear();
				}
				return selection;
		}
		allocateRenderTarget() {
				var colorBuffer = new Texture(this.device, {
						format: PIXELFORMAT_RGBA8,
						width: this.width,
						height: this.height,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						name: 'pick'
				});
				this.renderTarget = new RenderTarget({
						colorBuffer: colorBuffer,
						depth: true
				});
		}
		releaseRenderTarget() {
				if (this.renderTarget) {
						this.renderTarget.destroyTextureBuffers();
						this.renderTarget.destroy();
						this.renderTarget = null;
				}
		}
		prepare(camera, scene, layers) {
				if (layers instanceof Layer) {
						layers = [
								layers
						];
				}
				if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
						this.releaseRenderTarget();
						this.allocateRenderTarget();
				}
				this.mapping.clear();
				var renderPass = this.renderPass;
				renderPass.init(this.renderTarget);
				renderPass.colorOps.clearValue = Color.WHITE;
				renderPass.colorOps.clear = true;
				renderPass.depthStencilOps.clearDepth = true;
				renderPass.update(camera, scene, layers, this.mapping);
				renderPass.render();
		}
		resize(width, height) {
				this.width = Math.floor(width);
				this.height = Math.floor(height);
		}
		constructor(app, width, height){
				this.renderTarget = null;
				this.mapping = new Map();
				this.deviceValid = true;
				this.renderer = app.renderer;
				this.device = app.graphicsDevice;
				this.renderPass = new RenderPassPicker(this.device, app.renderer);
				this.width = 0;
				this.height = 0;
				this.resize(width, height);
				this.device.on('destroy', ()=>{
						this.deviceValid = false;
				});
		}
}

class SceneSettingsHandler extends ResourceHandler {
		load(url, callback) {
				SceneUtils.load(url, this.maxRetries, callback);
		}
		open(url, data) {
				return data.settings;
		}
		constructor(app){
				super(app, 'scenesettings');
		}
}

var targetX, targetY;
var vecA = new Vec3();
var vecB = new Vec3();
var rayA = new Ray();
var rayB = new Ray();
var rayC = new Ray();
rayA.end = new Vec3();
rayB.end = new Vec3();
rayC.end = new Vec3();
var _pq = new Vec3();
var _pa = new Vec3();
var _pb = new Vec3();
var _pc = new Vec3();
var _pd = new Vec3();
var _m = new Vec3();
var _au = new Vec3();
var _bv = new Vec3();
var _cw = new Vec3();
var _ir = new Vec3();
var _sct = new Vec3();
var _accumulatedScale = new Vec3();
var _paddingTop = new Vec3();
var _paddingBottom = new Vec3();
var _paddingLeft = new Vec3();
var _paddingRight = new Vec3();
var _cornerBottomLeft = new Vec3();
var _cornerBottomRight = new Vec3();
var _cornerTopRight = new Vec3();
var _cornerTopLeft = new Vec3();
var ZERO_VEC4 = new Vec4();
function scalarTriple(p1, p2, p3) {
		return _sct.cross(p1, p2).dot(p3);
}
function intersectLineQuad(p, q, corners) {
		_pq.sub2(q, p);
		_pa.sub2(corners[0], p);
		_pb.sub2(corners[1], p);
		_pc.sub2(corners[2], p);
		_m.cross(_pc, _pq);
		var v = _pa.dot(_m);
		var u;
		var w;
		if (v >= 0) {
				u = -_pb.dot(_m);
				if (u < 0) {
						return -1;
				}
				w = scalarTriple(_pq, _pb, _pa);
				if (w < 0) {
						return -1;
				}
				var denom = 1.0 / (u + v + w);
				_au.copy(corners[0]).mulScalar(u * denom);
				_bv.copy(corners[1]).mulScalar(v * denom);
				_cw.copy(corners[2]).mulScalar(w * denom);
				_ir.copy(_au).add(_bv).add(_cw);
		} else {
				_pd.sub2(corners[3], p);
				u = _pd.dot(_m);
				if (u < 0) {
						return -1;
				}
				w = scalarTriple(_pq, _pa, _pd);
				if (w < 0) {
						return -1;
				}
				v = -v;
				var denom1 = 1.0 / (u + v + w);
				_au.copy(corners[0]).mulScalar(u * denom1);
				_bv.copy(corners[3]).mulScalar(v * denom1);
				_cw.copy(corners[2]).mulScalar(w * denom1);
				_ir.copy(_au).add(_bv).add(_cw);
		}
		if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
		if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
		return _ir.sub(p).lengthSq();
}
class ElementInputEvent {
		stopPropagation() {
				this._stopPropagation = true;
				if (this.event) {
						this.event.stopImmediatePropagation();
						this.event.stopPropagation();
				}
		}
		constructor(event, element, camera){
				this.event = event;
				this.element = element;
				this.camera = camera;
				this._stopPropagation = false;
		}
}
class ElementMouseEvent extends ElementInputEvent {
		constructor(event, element, camera, x, y, lastX, lastY){
				super(event, element, camera);
				this.x = x;
				this.y = y;
				this.ctrlKey = event.ctrlKey || false;
				this.altKey = event.altKey || false;
				this.shiftKey = event.shiftKey || false;
				this.metaKey = event.metaKey || false;
				this.button = event.button;
				if (Mouse.isPointerLocked()) {
						this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
						this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
				} else {
						this.dx = x - lastX;
						this.dy = y - lastY;
				}
				this.wheelDelta = 0;
				if (event.type === 'wheel') {
						if (event.deltaY > 0) {
								this.wheelDelta = 1;
						} else if (event.deltaY < 0) {
								this.wheelDelta = -1;
						}
				}
		}
}
class ElementTouchEvent extends ElementInputEvent {
		constructor(event, element, camera, x, y, touch){
				super(event, element, camera);
				this.touches = event.touches;
				this.changedTouches = event.changedTouches;
				this.x = x;
				this.y = y;
				this.touch = touch;
		}
}
class ElementSelectEvent extends ElementInputEvent {
		constructor(event, element, camera, inputSource){
				super(event, element, camera);
				this.inputSource = inputSource;
		}
}
class ElementInput {
		set enabled(value) {
				this._enabled = value;
		}
		get enabled() {
				return this._enabled;
		}
		set app(value) {
				this._app = value;
		}
		get app() {
				return this._app || getApplication();
		}
		attach(domElement) {
				if (this._attached) {
						this._attached = false;
						this.detach();
				}
				this._target = domElement;
				this._attached = true;
				var opts = platform.passiveEvents ? {
						passive: true
				} : false;
				if (this._useMouse) {
						window.addEventListener('mouseup', this._upHandler, opts);
						window.addEventListener('mousedown', this._downHandler, opts);
						window.addEventListener('mousemove', this._moveHandler, opts);
						window.addEventListener('wheel', this._wheelHandler, opts);
				}
				if (this._useTouch && platform.touch) {
						this._target.addEventListener('touchstart', this._touchstartHandler, opts);
						this._target.addEventListener('touchend', this._touchendHandler, false);
						this._target.addEventListener('touchmove', this._touchmoveHandler, false);
						this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
				}
				this.attachSelectEvents();
		}
		attachSelectEvents() {
				if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
						if (!this._clickedEntities) {
								this._clickedEntities = {};
						}
						this._selectEventsAttached = true;
						this.app.xr.on('start', this._onXrStart, this);
				}
		}
		detach() {
				if (!this._attached) return;
				this._attached = false;
				var opts = platform.passiveEvents ? {
						passive: true
				} : false;
				if (this._useMouse) {
						window.removeEventListener('mouseup', this._upHandler, opts);
						window.removeEventListener('mousedown', this._downHandler, opts);
						window.removeEventListener('mousemove', this._moveHandler, opts);
						window.removeEventListener('wheel', this._wheelHandler, opts);
				}
				if (this._useTouch) {
						this._target.removeEventListener('touchstart', this._touchstartHandler, opts);
						this._target.removeEventListener('touchend', this._touchendHandler, false);
						this._target.removeEventListener('touchmove', this._touchmoveHandler, false);
						this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
				}
				if (this._selectEventsAttached) {
						this._selectEventsAttached = false;
						this.app.xr.off('start', this._onXrStart, this);
						this.app.xr.off('end', this._onXrEnd, this);
						this.app.xr.off('update', this._onXrUpdate, this);
						this.app.xr.input.off('selectstart', this._onSelectStart, this);
						this.app.xr.input.off('selectend', this._onSelectEnd, this);
						this.app.xr.input.off('remove', this._onXrInputRemove, this);
				}
				this._target = null;
		}
		addElement(element) {
				if (this._elements.indexOf(element) === -1) {
						this._elements.push(element);
				}
		}
		removeElement(element) {
				var idx = this._elements.indexOf(element);
				if (idx !== -1) {
						this._elements.splice(idx, 1);
				}
		}
		_handleUp(event) {
				if (!this._enabled) return;
				if (Mouse.isPointerLocked()) {
						return;
				}
				this._calcMouseCoords(event);
				this._onElementMouseEvent('mouseup', event);
		}
		_handleDown(event) {
				if (!this._enabled) return;
				if (Mouse.isPointerLocked()) {
						return;
				}
				this._calcMouseCoords(event);
				this._onElementMouseEvent('mousedown', event);
		}
		_handleMove(event) {
				if (!this._enabled) return;
				this._calcMouseCoords(event);
				this._onElementMouseEvent('mousemove', event);
				this._lastX = targetX;
				this._lastY = targetY;
		}
		_handleWheel(event) {
				if (!this._enabled) return;
				this._calcMouseCoords(event);
				this._onElementMouseEvent('mousewheel', event);
		}
		_determineTouchedElements(event) {
				var touchedElements = {};
				var cameras = this.app.systems.camera.cameras;
				for(var i = cameras.length - 1; i >= 0; i--){
						var camera = cameras[i];
						var done = 0;
						var len = event.changedTouches.length;
						for(var j = 0; j < len; j++){
								if (touchedElements[event.changedTouches[j].identifier]) {
										done++;
										continue;
								}
								var coords = getTouchTargetCoords(event.changedTouches[j]);
								var element = this._getTargetElementByCoords(camera, coords.x, coords.y);
								if (element) {
										done++;
										touchedElements[event.changedTouches[j].identifier] = {
												element: element,
												camera: camera,
												x: coords.x,
												y: coords.y
										};
								}
						}
						if (done === len) {
								break;
						}
				}
				return touchedElements;
		}
		_handleTouchStart(event) {
				if (!this._enabled) return;
				var newTouchedElements = this._determineTouchedElements(event);
				for(var i = 0, len = event.changedTouches.length; i < len; i++){
						var touch = event.changedTouches[i];
						var newTouchInfo = newTouchedElements[touch.identifier];
						var oldTouchInfo = this._touchedElements[touch.identifier];
						if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
								this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));
								this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
						}
				}
				for(var touchId in newTouchedElements){
						this._touchedElements[touchId] = newTouchedElements[touchId];
				}
		}
		_handleTouchEnd(event) {
				if (!this._enabled) return;
				var cameras = this.app.systems.camera.cameras;
				for(var key in this._clickedEntities){
						delete this._clickedEntities[key];
				}
				for(var i = 0, len = event.changedTouches.length; i < len; i++){
						var touch = event.changedTouches[i];
						var touchInfo = this._touchedElements[touch.identifier];
						if (!touchInfo) {
								continue;
						}
						var element = touchInfo.element;
						var camera = touchInfo.camera;
						var x = touchInfo.x;
						var y = touchInfo.y;
						delete this._touchedElements[touch.identifier];
						delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];
						var coords = getTouchTargetCoords(touch);
						for(var c = cameras.length - 1; c >= 0; c--){
								var hovered = this._getTargetElementByCoords(cameras[c], coords.x, coords.y);
								if (hovered === element) {
										if (!this._clickedEntities[element.entity.getGuid()]) {
												this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));
												this._clickedEntities[element.entity.getGuid()] = Date.now();
										}
								}
						}
						this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));
				}
		}
		_handleTouchMove(event) {
				event.preventDefault();
				if (!this._enabled) return;
				var newTouchedElements = this._determineTouchedElements(event);
				for(var i = 0, len = event.changedTouches.length; i < len; i++){
						var touch = event.changedTouches[i];
						var newTouchInfo = newTouchedElements[touch.identifier];
						var oldTouchInfo = this._touchedElements[touch.identifier];
						if (oldTouchInfo) {
								var coords = getTouchTargetCoords(touch);
								if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
										this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
										this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
								}
								this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
						}
				}
		}
		_onElementMouseEvent(eventType, event) {
				var element = null;
				var lastHovered = this._hoveredElement;
				this._hoveredElement = null;
				var cameras = this.app.systems.camera.cameras;
				var camera;
				for(var i = cameras.length - 1; i >= 0; i--){
						camera = cameras[i];
						element = this._getTargetElementByCoords(camera, targetX, targetY);
						if (element) {
								break;
						}
				}
				this._hoveredElement = element;
				if ((eventType === 'mousemove' || eventType === 'mouseup') && this._pressedElement) {
						this._fireEvent(eventType, new ElementMouseEvent(event, this._pressedElement, camera, targetX, targetY, this._lastX, this._lastY));
				} else if (element) {
						this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
						if (eventType === 'mousedown') {
								this._pressedElement = element;
						}
				}
				if (lastHovered !== this._hoveredElement) {
						if (lastHovered) {
								this._fireEvent('mouseleave', new ElementMouseEvent(event, lastHovered, camera, targetX, targetY, this._lastX, this._lastY));
						}
						if (this._hoveredElement) {
								this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
						}
				}
				if (eventType === 'mouseup' && this._pressedElement) {
						if (this._pressedElement === this._hoveredElement) {
								var guid = this._hoveredElement.entity.getGuid();
								var fireClick = !this._clickedEntities;
								if (this._clickedEntities) {
										var lastTouchUp = this._clickedEntities[guid] || 0;
										var dt = Date.now() - lastTouchUp;
										fireClick = dt > 300;
										delete this._clickedEntities[guid];
								}
								if (fireClick) {
										this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
								}
						}
						this._pressedElement = null;
				}
		}
		_onXrStart() {
				this.app.xr.on('end', this._onXrEnd, this);
				this.app.xr.on('update', this._onXrUpdate, this);
				this.app.xr.input.on('selectstart', this._onSelectStart, this);
				this.app.xr.input.on('selectend', this._onSelectEnd, this);
				this.app.xr.input.on('remove', this._onXrInputRemove, this);
		}
		_onXrEnd() {
				this.app.xr.off('update', this._onXrUpdate, this);
				this.app.xr.input.off('selectstart', this._onSelectStart, this);
				this.app.xr.input.off('selectend', this._onSelectEnd, this);
				this.app.xr.input.off('remove', this._onXrInputRemove, this);
		}
		_onXrUpdate() {
				if (!this._enabled) return;
				var inputSources = this.app.xr.input.inputSources;
				for(var i = 0; i < inputSources.length; i++){
						this._onElementSelectEvent('selectmove', inputSources[i], null);
				}
		}
		_onXrInputRemove(inputSource) {
				var hovered = this._selectedElements[inputSource.id];
				if (hovered) {
						inputSource._elementEntity = null;
						this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
				}
				delete this._selectedElements[inputSource.id];
				delete this._selectedPressedElements[inputSource.id];
		}
		_onSelectStart(inputSource, event) {
				if (!this._enabled) return;
				this._onElementSelectEvent('selectstart', inputSource, event);
		}
		_onSelectEnd(inputSource, event) {
				if (!this._enabled) return;
				this._onElementSelectEvent('selectend', inputSource, event);
		}
		_onElementSelectEvent(eventType, inputSource, event) {
				var element;
				var hoveredBefore = this._selectedElements[inputSource.id];
				var hoveredNow;
				var cameras = this.app.systems.camera.cameras;
				var camera;
				if (inputSource.elementInput) {
						rayC.set(inputSource.getOrigin(), inputSource.getDirection());
						for(var i = cameras.length - 1; i >= 0; i--){
								camera = cameras[i];
								element = this._getTargetElementByRay(rayC, camera);
								if (element) {
										break;
								}
						}
				}
				inputSource._elementEntity = element || null;
				if (element) {
						this._selectedElements[inputSource.id] = element;
						hoveredNow = element;
				} else {
						delete this._selectedElements[inputSource.id];
				}
				if (hoveredBefore !== hoveredNow) {
						if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
						if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
				}
				var pressed = this._selectedPressedElements[inputSource.id];
				if (eventType === 'selectmove' && pressed) {
						this._fireEvent('selectmove', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
				if (eventType === 'selectstart') {
						this._selectedPressedElements[inputSource.id] = hoveredNow;
						if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
				}
				if (!inputSource.elementInput && pressed) {
						delete this._selectedPressedElements[inputSource.id];
						if (hoveredBefore) {
								this._fireEvent('selectend', new ElementSelectEvent(event, pressed, camera, inputSource));
						}
				}
				if (eventType === 'selectend' && inputSource.elementInput) {
						delete this._selectedPressedElements[inputSource.id];
						if (pressed) {
								this._fireEvent('selectend', new ElementSelectEvent(event, pressed, camera, inputSource));
						}
						if (pressed && pressed === hoveredBefore) {
								this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
						}
				}
		}
		_fireEvent(name, evt) {
				var element = evt.element;
				while(true){
						element.fire(name, evt);
						if (evt._stopPropagation) {
								break;
						}
						if (!element.entity.parent) {
								break;
						}
						element = element.entity.parent.element;
						if (!element) {
								break;
						}
				}
		}
		_calcMouseCoords(event) {
				var rect = this._target.getBoundingClientRect();
				var left = Math.floor(rect.left);
				var top = Math.floor(rect.top);
				targetX = event.clientX - left;
				targetY = event.clientY - top;
		}
		_sortElements(a, b) {
				var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
				if (layerOrder !== 0) return layerOrder;
				if (a.screen && !b.screen) {
						return -1;
				}
				if (!a.screen && b.screen) {
						return 1;
				}
				if (!a.screen && !b.screen) {
						return 0;
				}
				if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) {
						return -1;
				}
				if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) {
						return 1;
				}
				return b.drawOrder - a.drawOrder;
		}
		_getTargetElementByCoords(camera, x, y) {
				var rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
				var ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
				return this._getTargetElement(camera, rayScreen, ray3d);
		}
		_getTargetElementByRay(ray, camera) {
				rayA.origin.copy(ray.origin);
				rayA.direction.copy(ray.direction);
				rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);
				var ray3d = rayA;
				var screenPos = camera.worldToScreen(ray3d.origin, vecA);
				var rayScreen = this._calculateRayScreen(screenPos.x, screenPos.y, camera, rayB) ? rayB : null;
				return this._getTargetElement(camera, rayScreen, ray3d);
		}
		_getTargetElement(camera, rayScreen, ray3d) {
				var result = null;
				var closestDistance3d = Infinity;
				this._elements.sort(this._sortHandler);
				for(var i = 0, len = this._elements.length; i < len; i++){
						var element = this._elements[i];
						if (!element.layers.some((v)=>camera.layersSet.has(v))) {
								continue;
						}
						if (element.screen && element.screen.screen.screenSpace) {
								if (!rayScreen) {
										continue;
								}
								var currentDistance = this._checkElement(rayScreen, element, true);
								if (currentDistance >= 0) {
										result = element;
										break;
								}
						} else {
								if (!ray3d) {
										continue;
								}
								var currentDistance1 = this._checkElement(ray3d, element, false);
								if (currentDistance1 >= 0) {
										if (currentDistance1 < closestDistance3d) {
												result = element;
												closestDistance3d = currentDistance1;
										}
										if (element.screen) {
												result = element;
												break;
										}
								}
						}
				}
				return result;
		}
		_calculateRayScreen(x, y, camera, ray) {
				var sw = this.app.graphicsDevice.width;
				var sh = this.app.graphicsDevice.height;
				var cameraWidth = camera.rect.z * sw;
				var cameraHeight = camera.rect.w * sh;
				var cameraLeft = camera.rect.x * sw;
				var cameraRight = cameraLeft + cameraWidth;
				var cameraBottom = (1 - camera.rect.y) * sh;
				var cameraTop = cameraBottom - cameraHeight;
				var _x = x * sw / this._target.clientWidth;
				var _y = y * sh / this._target.clientHeight;
				if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
						_x = sw * (_x - cameraLeft) / cameraWidth;
						_y = sh * (_y - cameraTop) / cameraHeight;
						_y = sh - _y;
						ray.origin.set(_x, _y, 1);
						ray.direction.set(0, 0, -1);
						ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
						return true;
				}
				return false;
		}
		_calculateRay3d(x, y, camera, ray) {
				var sw = this._target.clientWidth;
				var sh = this._target.clientHeight;
				var cameraWidth = camera.rect.z * sw;
				var cameraHeight = camera.rect.w * sh;
				var cameraLeft = camera.rect.x * sw;
				var cameraRight = cameraLeft + cameraWidth;
				var cameraBottom = (1 - camera.rect.y) * sh;
				var cameraTop = cameraBottom - cameraHeight;
				var _x = x;
				var _y = y;
				if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
						_x = sw * (_x - cameraLeft) / cameraWidth;
						_y = sh * (_y - cameraTop) / cameraHeight;
						camera.screenToWorld(_x, _y, camera.nearClip, vecA);
						camera.screenToWorld(_x, _y, camera.farClip, vecB);
						ray.origin.copy(vecA);
						ray.direction.set(0, 0, -1);
						ray.end.copy(vecB);
						return true;
				}
				return false;
		}
		_checkElement(ray, element, screen) {
				if (element.maskedBy) {
						if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
								return -1;
						}
				}
				var scale;
				if (screen) {
						scale = ElementInput.calculateScaleToScreen(element);
				} else {
						scale = ElementInput.calculateScaleToWorld(element);
				}
				var corners = ElementInput.buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale);
				return intersectLineQuad(ray.origin, ray.end, corners);
		}
		static buildHitCorners(element, screenOrWorldCorners, scale) {
				var hitCorners = screenOrWorldCorners;
				var button = element.entity && element.entity.button;
				if (button) {
						var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
						_paddingTop.copy(element.entity.up);
						_paddingBottom.copy(_paddingTop).mulScalar(-1);
						_paddingRight.copy(element.entity.right);
						_paddingLeft.copy(_paddingRight).mulScalar(-1);
						_paddingTop.mulScalar(hitPadding.w * scale.y);
						_paddingBottom.mulScalar(hitPadding.y * scale.y);
						_paddingRight.mulScalar(hitPadding.z * scale.x);
						_paddingLeft.mulScalar(hitPadding.x * scale.x);
						_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
						_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
						_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
						_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
						hitCorners = [
								_cornerBottomLeft,
								_cornerBottomRight,
								_cornerTopRight,
								_cornerTopLeft
						];
				}
				if (scale.x < 0) {
						var left = hitCorners[2].x;
						var right = hitCorners[0].x;
						hitCorners[0].x = left;
						hitCorners[1].x = right;
						hitCorners[2].x = right;
						hitCorners[3].x = left;
				}
				if (scale.y < 0) {
						var bottom = hitCorners[2].y;
						var top = hitCorners[0].y;
						hitCorners[0].y = bottom;
						hitCorners[1].y = bottom;
						hitCorners[2].y = top;
						hitCorners[3].y = top;
				}
				if (scale.z < 0) {
						var x = hitCorners[2].x;
						var y = hitCorners[2].y;
						var z = hitCorners[2].z;
						hitCorners[2].x = hitCorners[0].x;
						hitCorners[2].y = hitCorners[0].y;
						hitCorners[2].z = hitCorners[0].z;
						hitCorners[0].x = x;
						hitCorners[0].y = y;
						hitCorners[0].z = z;
				}
				return hitCorners;
		}
		static calculateScaleToScreen(element) {
				var current = element.entity;
				var screenScale = element.screen.screen.scale;
				_accumulatedScale.set(screenScale, screenScale, screenScale);
				while(current && !current.screen){
						_accumulatedScale.mul(current.getLocalScale());
						current = current.parent;
				}
				return _accumulatedScale;
		}
		static calculateScaleToWorld(element) {
				var current = element.entity;
				_accumulatedScale.set(1, 1, 1);
				while(current){
						_accumulatedScale.mul(current.getLocalScale());
						current = current.parent;
				}
				return _accumulatedScale;
		}
		constructor(domElement, options){
				this._app = null;
				this._attached = false;
				this._target = null;
				this._enabled = true;
				this._lastX = 0;
				this._lastY = 0;
				this._upHandler = this._handleUp.bind(this);
				this._downHandler = this._handleDown.bind(this);
				this._moveHandler = this._handleMove.bind(this);
				this._wheelHandler = this._handleWheel.bind(this);
				this._touchstartHandler = this._handleTouchStart.bind(this);
				this._touchendHandler = this._handleTouchEnd.bind(this);
				this._touchcancelHandler = this._touchendHandler;
				this._touchmoveHandler = this._handleTouchMove.bind(this);
				this._sortHandler = this._sortElements.bind(this);
				this._elements = [];
				this._hoveredElement = null;
				this._pressedElement = null;
				this._touchedElements = {};
				this._touchesForWhichTouchLeaveHasFired = {};
				this._selectedElements = {};
				this._selectedPressedElements = {};
				this._useMouse = !options || options.useMouse !== false;
				this._useTouch = !options || options.useTouch !== false;
				this._useXr = !options || options.useXr !== false;
				this._selectEventsAttached = false;
				if (platform.touch) {
						this._clickedEntities = {};
				}
				this.attach(domElement);
		}
}

Vec2.prototype.scale = Vec2.prototype.mulScalar;
Vec3.prototype.scale = Vec3.prototype.mulScalar;
Vec4.prototype.scale = Vec4.prototype.mulScalar;
var PIXELFORMAT_L8_A8 = PIXELFORMAT_LA8;
var PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_RGB565;
var PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_RGBA5551;
var PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_RGBA4;
var PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_RGB8;
var PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_RGBA8;
var PIXELFORMAT_SRGB = PIXELFORMAT_SRGB8;
var PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA8;
var BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT;
var BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT;
var BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT;
var BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT;
var _viewport = new Vec4();
function createSphere(device, opts) {
		return Mesh.fromGeometry(device, new SphereGeometry(opts));
}
function createPlane(device, opts) {
		return Mesh.fromGeometry(device, new PlaneGeometry(opts));
}
function createBox(device, opts) {
		return Mesh.fromGeometry(device, new BoxGeometry(opts));
}
function createTorus(device, opts) {
		return Mesh.fromGeometry(device, new TorusGeometry(opts));
}
function createCapsule(device, opts) {
		return Mesh.fromGeometry(device, new CapsuleGeometry(opts));
}
function createCone(device, opts) {
		return Mesh.fromGeometry(device, new ConeGeometry(opts));
}
function createCylinder(device, opts) {
		return Mesh.fromGeometry(device, new CylinderGeometry(opts));
}
function createMesh(device, positions, opts) {
		if (opts === void 0) opts = {};
		var geom = new Geometry();
		geom.positions = positions;
		geom.normals = opts.normals;
		geom.tangents = opts.tangents;
		geom.colors = opts.colors;
		geom.uvs = opts.uvs;
		geom.uvs1 = opts.uvs1;
		geom.blendIndices = opts.blendIndices;
		geom.blendWeights = opts.blendWeights;
		geom.indices = opts.indices;
		return Mesh.fromGeometry(device, geom, opts);
}
function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
		var viewport;
		if (rect) {
				var w = target ? target.width : device.width;
				var h = target ? target.height : device.height;
				viewport = _viewport.set(rect.x * w, rect.y * h, rect.z * w, rect.w * h);
		}
		drawQuadWithShader(device, target, shader, viewport);
}
var deprecatedChunks = {
		'ambientPrefilteredCube.frag': 'ambientEnv.frag',
		'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
		'dpAtlasQuad.frag': null,
		'genParaboloid.frag': null,
		'prefilterCubemap.frag': null,
		'reflectionDpAtlas.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
};
Object.keys(deprecatedChunks).forEach((chunkName)=>{
		Object.defineProperty(shaderChunks, chunkName, {
				get: function get() {
						return null;
				},
				set: function set() {}
		});
});
Object.defineProperties(RenderTarget.prototype, {
		_glFrameBuffer: {
				get: function get() {
						return this.impl._glFrameBuffer;
				},
				set: function set(rgbm) {}
		}
});
Object.defineProperty(VertexFormat, 'defaultInstancingFormat', {
		get: function get() {
				return null;
		}
});
Object.defineProperties(Texture.prototype, {
		rgbm: {
				get: function get() {
						return this.type === TEXTURETYPE_RGBM;
				},
				set: function set(rgbm) {
						this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
				}
		},
		swizzleGGGR: {
				get: function get() {
						return this.type === TEXTURETYPE_SWIZZLEGGGR;
				},
				set: function set(swizzleGGGR) {
						this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
				}
		},
		_glTexture: {
				get: function get() {
						return this.impl._glTexture;
				}
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'boneLimit', {
		get: function get() {
				return 1024;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'webgl2', {
		get: function get() {
				return this.isWebGL2;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'textureFloatHighPrecision', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'extBlendMinmax', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'extTextureHalfFloat', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'extTextureLod', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'textureHalfFloatFilterable', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'supportsMrt', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'supportsVolumeTextures', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'supportsInstancing', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'textureHalfFloatUpdatable', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'extTextureFloat', {
		get: function get() {
				return true;
		}
});
Object.defineProperty(GraphicsDevice.prototype, 'extStandardDerivatives', {
		get: function get() {
				return true;
		}
});
BlendState.DEFAULT = Object.freeze(new BlendState());
var _tempBlendState = new BlendState();
var _tempDepthState = new DepthState();
GraphicsDevice.prototype.setBlendFunction = function(blendSrc, blendDst) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
		_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrc, blendDst);
		this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setBlendFunctionSeparate = function(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
		_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrcAlpha, blendDstAlpha);
		this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setBlendEquation = function(blendEquation) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
		_tempBlendState.setAlphaBlend(blendEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
		this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setBlendEquationSeparate = function(blendEquation, blendAlphaEquation) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
		_tempBlendState.setAlphaBlend(blendAlphaEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
		this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setColorWrite = function(redWrite, greenWrite, blueWrite, alphaWrite) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
		this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.getBlending = function() {
		return this.blendState.blend;
};
GraphicsDevice.prototype.setBlending = function(blending) {
		_tempBlendState.copy(this.blendState);
		_tempBlendState.blend = blending;
		this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setDepthWrite = function(write) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.write = write;
		this.setDepthState(_tempDepthState);
};
GraphicsDevice.prototype.setDepthFunc = function(func) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.func = func;
		this.setDepthState(_tempDepthState);
};
GraphicsDevice.prototype.setDepthTest = function(test) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.test = test;
		this.setDepthState(_tempDepthState);
};
GraphicsDevice.prototype.getCullMode = function() {
		return this.cullMode;
};
var LitOptions = LitShaderOptions;
Object.defineProperty(Scene.prototype, 'defaultMaterial', {
		get: function get() {
				return getDefaultMaterial(getApplication().graphicsDevice);
		}
});
Object.defineProperty(Scene.prototype, 'fogColor', {
		set: function set(value) {
				this.fog.color = value;
		},
		get: function get() {
				return this.fog.color;
		}
});
Object.defineProperty(Scene.prototype, 'fogEnd', {
		set: function set(value) {
				this.fog.end = value;
		},
		get: function get() {
				return this.fog.end;
		}
});
Object.defineProperty(Scene.prototype, 'fogStart', {
		set: function set(value) {
				this.fog.start = value;
		},
		get: function get() {
				return this.fog.start;
		}
});
Object.defineProperty(Scene.prototype, 'fogDensity', {
		set: function set(value) {
				this.fog.density = value;
		},
		get: function get() {
				return this.fog.density;
		}
});
Object.defineProperty(Scene.prototype, 'toneMapping', {
		set: function set(value) {},
		get: function get() {
				return undefined;
		}
});
Object.defineProperty(Scene.prototype, 'gammaCorrection', {
		set: function set(value) {},
		get: function get() {
				return undefined;
		}
});
Object.defineProperty(Scene.prototype, 'rendering', {
		set: function set(value) {},
		get: function get() {
				return undefined;
		}
});
Object.defineProperty(LayerComposition.prototype, '_meshInstances', {
		get: function get() {
				return null;
		}
});
Object.defineProperty(Scene.prototype, 'drawCalls', {
		get: function get() {
				return null;
		}
});
[
		'128',
		'64',
		'32',
		'16',
		'8',
		'4'
].forEach((size, index)=>{
		Object.defineProperty(Scene.prototype, "skyboxPrefiltered" + size, {
				get: function get() {
						return this._prefilteredCubemaps[index];
				},
				set: function set(value) {
						this._prefilteredCubemaps[index] = value;
						this.updateShaders = true;
				}
		});
});
Object.defineProperty(Scene.prototype, 'models', {
		get: function get() {
				if (!this._models) {
						this._models = [];
				}
				return this._models;
		}
});
function _removedClassProperty(targetClass, name, comment) {
		Object.defineProperty(targetClass.prototype, name, {
				set: function set(value) {},
				get: function get() {
						return undefined;
				}
		});
}
_removedClassProperty(Layer, 'renderTarget');
_removedClassProperty(Layer, 'onPreCull');
_removedClassProperty(Layer, 'onPreRender');
_removedClassProperty(Layer, 'onPreRenderOpaque');
_removedClassProperty(Layer, 'onPreRenderTransparent');
_removedClassProperty(Layer, 'onPostCull');
_removedClassProperty(Layer, 'onPostRender');
_removedClassProperty(Layer, 'onPostRenderOpaque');
_removedClassProperty(Layer, 'onPostRenderTransparent');
_removedClassProperty(Layer, 'onDrawCall');
_removedClassProperty(Layer, 'layerReference');
_removedClassProperty(CameraComponent, 'onPreCull');
_removedClassProperty(CameraComponent, 'onPostCull');
_removedClassProperty(CameraComponent, 'onPreRender');
_removedClassProperty(CameraComponent, 'onPostRender');
_removedClassProperty(CameraComponent, 'onPreRenderLayer');
_removedClassProperty(CameraComponent, 'onPostRenderLayer');
ForwardRenderer.prototype.renderComposition = function(comp) {
		getApplication().renderComposition(comp);
};
MeshInstance.prototype.syncAabb = function() {};
Morph.prototype.getTarget = function(index) {
		return this.targets[index];
};
GraphNode.prototype.getChildren = function() {
		return this.children;
};
GraphNode.prototype.getName = function() {
		return this.name;
};
GraphNode.prototype.getPath = function() {
		return this.path;
};
GraphNode.prototype.getRoot = function() {
		return this.root;
};
GraphNode.prototype.getParent = function() {
		return this.parent;
};
GraphNode.prototype.setName = function(name) {
		this.name = name;
};
Object.defineProperty(Material.prototype, 'shader', {
		set: function set(value) {},
		get: function get() {
				return null;
		}
});
Object.defineProperty(Material.prototype, 'blend', {
		set: function set(value) {
				this.blendState.blend = value;
		},
		get: function get() {
				return this.blendState.blend;
		}
});
Object.defineProperty(StandardMaterial.prototype, 'shininess', {
		get: function get() {
				return this.gloss * 100;
		},
		set: function set(value) {
				this.gloss = value * 0.01;
		}
});
Object.defineProperty(StandardMaterial.prototype, 'useGammaTonemap', {
		get: function get() {
				return this.useTonemap;
		},
		set: function set(value) {
				this.useTonemap = value;
		}
});
function _defineAlias(newName, oldName) {
		Object.defineProperty(StandardMaterial.prototype, oldName, {
				get: function get() {
						return this[newName];
				},
				set: function set(value) {
						this[newName] = value;
				}
		});
}
function _deprecateTint(name) {
		Object.defineProperty(StandardMaterial.prototype, name, {
				get: function get() {
						return true;
				},
				set: function set(value) {}
		});
}
_deprecateTint('sheenTint');
_deprecateTint('diffuseTint');
_deprecateTint('emissiveTint');
_deprecateTint('ambientTint');
_defineAlias('specularTint', 'specularMapTint');
_defineAlias('aoVertexColor', 'aoMapVertexColor');
_defineAlias('diffuseVertexColor', 'diffuseMapVertexColor');
_defineAlias('specularVertexColor', 'specularMapVertexColor');
_defineAlias('emissiveVertexColor', 'emissiveMapVertexColor');
_defineAlias('metalnessVertexColor', 'metalnessMapVertexColor');
_defineAlias('glossVertexColor', 'glossMapVertexColor');
_defineAlias('opacityVertexColor', 'opacityMapVertexColor');
_defineAlias('lightVertexColor', 'lightMapVertexColor');
_defineAlias('sheenGloss', 'sheenGlossiess');
_defineAlias('clearCoatGloss', 'clearCostGlossiness');
function _defineOption(name, newName) {
		if (name !== 'pass') {
				Object.defineProperty(StandardMaterialOptions.prototype, name, {
						get: function get() {
								return this.litOptions[newName || name];
						},
						set: function set(value) {
								this.litOptions[newName || name] = value;
						}
				});
		}
}
_defineOption('refraction', 'useRefraction');
var tempOptions = new LitShaderOptions();
var litOptionProperties = Object.getOwnPropertyNames(tempOptions);
for(var litOption in litOptionProperties){
		_defineOption(litOptionProperties[litOption]);
}
AssetRegistry.prototype.getAssetById = function(id) {
		return this.get(id);
};
Object.defineProperty(XrInputSource.prototype, 'ray', {
		get: function get() {
				return this._rayLocal;
		}
});
Object.defineProperty(XrInputSource.prototype, 'position', {
		get: function get() {
				return this._localPosition;
		}
});
Object.defineProperty(XrInputSource.prototype, 'rotation', {
		get: function get() {
				return this._localRotation;
		}
});
Object.defineProperty(ElementInput.prototype, 'wheel', {
		get: function get() {
				return this.wheelDelta * -2;
		}
});
Object.defineProperty(MouseEvent.prototype, 'wheel', {
		get: function get() {
				return this.wheelDelta * -2;
		}
});
var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
AppBase.prototype.isFullscreen = function() {
		return !!document.fullscreenElement;
};
AppBase.prototype.enableFullscreen = function(element, success, error) {
		element = element || this.graphicsDevice.canvas;
		var s = function s1() {
				success();
				document.removeEventListener('fullscreenchange', s);
		};
		var e = function e1() {
				error();
				document.removeEventListener('fullscreenerror', e);
		};
		if (success) {
				document.addEventListener('fullscreenchange', s, false);
		}
		if (error) {
				document.addEventListener('fullscreenerror', e, false);
		}
		if (element.requestFullscreen) {
				element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
		} else {
				error();
		}
};
AppBase.prototype.disableFullscreen = function(success) {
		var s = function s1() {
				success();
				document.removeEventListener('fullscreenchange', s);
		};
		if (success) {
				document.addEventListener('fullscreenchange', s, false);
		}
		document.exitFullscreen();
};
AppBase.prototype.getSceneUrl = function(name) {
		var entry = this.scenes.find(name);
		if (entry) {
				return entry.url;
		}
		return null;
};
AppBase.prototype.loadScene = function(url, callback) {
		this.scenes.loadScene(url, callback);
};
AppBase.prototype.loadSceneHierarchy = function(url, callback) {
		this.scenes.loadSceneHierarchy(url, callback);
};
AppBase.prototype.loadSceneSettings = function(url, callback) {
		this.scenes.loadSceneSettings(url, callback);
};
ModelComponent.prototype.setVisible = function(visible) {
		this.enabled = visible;
};
Object.defineProperty(RigidBodyComponent.prototype, 'bodyType', {
		get: function get() {
				return this.type;
		},
		set: function set(type) {
				this.type = type;
		}
});
RigidBodyComponent.prototype.syncBodyToEntity = function() {
		this._updateDynamic();
};
RigidBodyComponentSystem.prototype.setGravity = function() {
		if (arguments.length === 1) {
				this.gravity.copy(arguments[0]);
		} else {
				this.gravity.set(arguments[0], arguments[1], arguments[2]);
		}
};

class CpuTimer {
		begin(name) {
				if (!this.enabled) {
						return;
				}
				if (this._frameIndex < this._frameTimings.length) {
						this._frameTimings.splice(this._frameIndex);
				}
				var tmp = this._prevTimings;
				this._prevTimings = this._timings;
				this._timings = this._frameTimings;
				this._frameTimings = tmp;
				this._frameIndex = 0;
				this.mark(name);
		}
		mark(name) {
				if (!this.enabled) {
						return;
				}
				var timestamp = now();
				if (this._frameIndex > 0) {
						var prev = this._frameTimings[this._frameIndex - 1];
						prev[1] = timestamp - prev[1];
				} else if (this._timings.length > 0) {
						var prev1 = this._timings[this._timings.length - 1];
						prev1[1] = timestamp - prev1[1];
				}
				if (this._frameIndex >= this._frameTimings.length) {
						this._frameTimings.push([
								name,
								timestamp
						]);
				} else {
						var timing = this._frameTimings[this._frameIndex];
						timing[0] = name;
						timing[1] = timestamp;
				}
				this._frameIndex++;
		}
		get timings() {
				return this._timings.slice(0, -1).map((v)=>v[1]);
		}
		constructor(app){
				this._frameIndex = 0;
				this._frameTimings = [];
				this._timings = [];
				this._prevTimings = [];
				this.unitsName = 'ms';
				this.decimalPlaces = 1;
				this.enabled = true;
				app.on('frameupdate', this.begin.bind(this, 'update'));
				app.on('framerender', this.mark.bind(this, 'render'));
				app.on('frameend', this.mark.bind(this, 'other'));
		}
}

class GpuTimer {
		get timings() {
				this._timings[0] = this.device.gpuProfiler._frameTime;
				return this._timings;
		}
		constructor(device){
				this.device = device;
				device.gpuProfiler.enabled = true;
				this.enabled = true;
				this.unitsName = 'ms';
				this.decimalPlaces = 1;
				this._timings = [];
		}
}

class StatsTimer {
		get timings() {
				return this.values;
		}
		constructor(app, statNames, decimalPlaces, unitsName, multiplier){
				this.app = app;
				this.values = [];
				this.statNames = statNames;
				if (this.statNames.length > 3) {
						this.statNames.length = 3;
				}
				this.unitsName = unitsName;
				this.decimalPlaces = decimalPlaces;
				this.multiplier = multiplier || 1;
				var resolve = (path, obj)=>{
						return path.split('.').reduce((prev, curr)=>{
								return prev ? prev[curr] : null;
						}, obj || this);
				};
				app.on('frameupdate', (ms)=>{
						for(var i = 0; i < this.statNames.length; i++){
								this.values[i] = resolve(this.statNames[i], this.app.stats) * this.multiplier;
						}
				});
		}
}

class Graph {
		destroy() {
				this.app.off('frameupdate', this.update, this);
		}
		loseContext() {
				if (this.timer && typeof this.timer.loseContext === 'function') {
						this.timer.loseContext();
				}
		}
		update(ms) {
				var timings = this.timer.timings;
				var total = timings.reduce((a, v)=>a + v, 0);
				this.avgTotal += total;
				this.avgTimer += ms;
				this.avgCount++;
				if (this.avgTimer > this.textRefreshRate) {
						this.timingText = (this.avgTotal / this.avgCount).toFixed(this.timer.decimalPlaces);
						this.avgTimer = 0;
						this.avgTotal = 0;
						this.avgCount = 0;
				}
				if (this.enabled) {
						var value = 0;
						var range = 1.5 * this.watermark;
						for(var i = 0; i < timings.length; ++i){
								value += Math.floor(timings[i] / range * 255);
								this.sample[i] = value;
						}
						this.sample[3] = this.watermark / range * 255;
						var data = this.texture.lock();
						data.set(this.sample, (this.cursor + this.yOffset * this.texture.width) * 4);
						this.texture.unlock();
						this.cursor++;
						if (this.cursor === this.texture.width) {
								this.cursor = 0;
						}
				}
		}
		render(render2d, x, y, w, h) {
				render2d.quad(x + w, y, -w, h, this.enabled ? this.cursor : 0, this.enabled ? 0.5 + this.yOffset : this.texture.height - 1, -w, 0, this.texture, 0);
		}
		constructor(name, app, watermark, textRefreshRate, timer){
				this.app = app;
				this.name = name;
				this.device = app.graphicsDevice;
				this.timer = timer;
				this.watermark = watermark;
				this.enabled = false;
				this.textRefreshRate = textRefreshRate;
				this.avgTotal = 0;
				this.avgTimer = 0;
				this.avgCount = 0;
				this.timingText = '';
				this.texture = null;
				this.yOffset = 0;
				this.cursor = 0;
				this.sample = new Uint8ClampedArray(4);
				this.sample.set([
						0,
						0,
						0,
						255
				]);
				this.counter = 0;
				this.app.on('frameupdate', this.update, this);
		}
}

class WordAtlas {
		destroy() {
				this.texture.destroy();
				this.texture = null;
		}
		render(render2d, word, x, y) {
				var p = this.placements.get(word);
				if (p) {
						var padding = 1;
						render2d.quad(x + p.l - padding, y - p.d + padding, p.w + padding * 2, p.h + padding * 2, p.x - padding, this.texture.height - p.y - p.h - padding, undefined, undefined, this.texture, 1);
						return p.w;
				}
				return 0;
		}
		constructor(device, words){
				var initContext = (context)=>{
						context.font = '10px "Lucida Console", Monaco, monospace';
						context.textAlign = 'left';
						context.textBaseline = 'alphabetic';
				};
				var isNumber = (word)=>{
						return word === '.' || word.length === 1 && word.charCodeAt(0) >= 48 && word.charCodeAt(0) <= 57;
				};
				var canvas = document.createElement('canvas');
				var context = canvas.getContext('2d', {
						alpha: true
				});
				initContext(context);
				var placements = new Map();
				var padding = 5;
				var width = 512;
				var x = padding;
				var y = padding;
				words.forEach((word)=>{
						var measurement = context.measureText(word);
						var l = Math.ceil(-measurement.actualBoundingBoxLeft);
						var r = Math.ceil(measurement.actualBoundingBoxRight);
						var a = Math.ceil(measurement.actualBoundingBoxAscent);
						var d = Math.ceil(measurement.actualBoundingBoxDescent);
						var w = l + r;
						var h = a + d;
						if (x + w + padding >= width) {
								x = padding;
								y += 16;
						}
						placements.set(word, {
								l,
								r,
								a,
								d,
								w,
								h,
								x: x,
								y: y
						});
						x += w + padding;
				});
				canvas.width = 512;
				canvas.height = math.nextPowerOfTwo(y + 16 + padding);
				initContext(context);
				context.fillStyle = 'rgb(0, 0, 0)';
				context.fillRect(0, 0, canvas.width, canvas.height);
				placements.forEach((m, word)=>{
						context.fillStyle = isNumber(word) ? 'rgb(255, 255, 255)' : 'rgb(170, 170, 170)';
						context.fillText(word, m.x - m.l, m.y + m.a);
				});
				this.placements = placements;
				var data = context.getImageData(0, 0, canvas.width, canvas.height).data;
				for(var i = 0; i < data.length; i += 4){
						data[i + 3] = data[i + 0];
						data[i + 0] = 255;
						data[i + 1] = 255;
						data[i + 2] = 255;
				}
				this.texture = new Texture(device, {
						name: 'mini-stats-word-atlas',
						width: canvas.width,
						height: canvas.height,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						levels: [
								data
						]
				});
		}
}

var vertexShaderGLSL = "\n	attribute vec3 vertex_position;\n	attribute vec4 vertex_texCoord0;\n	varying vec4 uv0;\n	varying float wordFlag;\n	void main(void) {\n		gl_Position = vec4(vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);\n		uv0 = vertex_texCoord0;\n		wordFlag = vertex_position.z;\n	}\n";
var vertexShaderWGSL = "\n    attribute vertex_position: vec3f;         // unnormalized xy, word flag\n    attribute vertex_texCoord0: vec4f;        // unnormalized texture space uv, normalized uv\n\n    varying uv0: vec4f;\n    varying wordFlag: f32;\n\n    @vertex fn vertexMain(input : VertexInput) -> VertexOutput {\n        var output : VertexOutput;\n        output.position = vec4(input.vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);\n        output.uv0 = input.vertex_texCoord0;\n        output.wordFlag = input.vertex_position.z;\n        return output;\n    }\n";
var fragmentShaderGLSL = "\n	varying vec4 uv0;\n	varying float wordFlag;\n	uniform vec4 clr;\n	uniform sampler2D graphTex;\n	uniform sampler2D wordsTex;\n	void main (void) {\n		vec4 graphSample = texture2D(graphTex, uv0.xy);\n		vec4 graph;\n		if (uv0.w < graphSample.r)\n			graph = vec4(0.7, 0.2, 0.2, 1.0);\n		else if (uv0.w < graphSample.g)\n			graph = vec4(0.2, 0.7, 0.2, 1.0);\n		else if (uv0.w < graphSample.b)\n			graph = vec4(0.2, 0.2, 0.7, 1.0);\n		else\n			graph = vec4(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));\n		vec4 words = texture2D(wordsTex, vec2(uv0.x, 1.0 - uv0.y));\n		gl_FragColor = mix(graph, words, wordFlag) * clr;\n	}\n";
var fragmentShaderWGSL = "\n    varying uv0: vec4f;\n    varying wordFlag: f32;\n\n    uniform clr: vec4f;\n\n    var graphTex : texture_2d<f32>;\n    var graphTex_sampler : sampler;\n\n    var wordsTex : texture_2d<f32>;\n    var wordsTex_sampler : sampler;\n\n    @fragment fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var uv0: vec4f = input.uv0;\n        var graphSample: vec4f = textureSample(graphTex, graphTex_sampler, uv0.xy);\n\n        var graph: vec4f;\n        if (uv0.w < graphSample.r) {\n            graph = vec4f(0.7, 0.2, 0.2, 1.0);\n        } else if (uv0.w < graphSample.g) {\n            graph = vec4f(0.2, 0.7, 0.2, 1.0);\n        } else if (uv0.w < graphSample.b) {\n            graph = vec4f(0.2, 0.2, 0.7, 1.0);\n        } else {\n            graph = vec4f(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));\n        }\n\n        var words: vec4f = textureSample(wordsTex, wordsTex_sampler, vec2f(uv0.x, 1.0 - uv0.y));\n\n        var output: FragmentOutput;\n        output.color = mix(graph, words, input.wordFlag) * uniform.clr;\n        return output;\n    }\n";
class Render2d {
		quad(x, y, w, h, u, v, uw, uh, texture, wordFlag) {
				if (wordFlag === void 0) wordFlag = 0;
				var rw = this.targetSize.width;
				var rh = this.targetSize.height;
				var x0 = x / rw;
				var y0 = y / rh;
				var x1 = (x + w) / rw;
				var y1 = (y + h) / rh;
				var tw = texture.width;
				var th = texture.height;
				var u0 = u / tw;
				var v0 = v / th;
				var u1 = (u + (uw != null ? uw : w)) / tw;
				var v1 = (v + (uh != null ? uh : h)) / th;
				this.data.set([
						x0,
						y0,
						wordFlag,
						u0,
						v0,
						0,
						0,
						x1,
						y0,
						wordFlag,
						u1,
						v0,
						1,
						0,
						x1,
						y1,
						wordFlag,
						u1,
						v1,
						1,
						1,
						x0,
						y1,
						wordFlag,
						u0,
						v1,
						0,
						1
				], 4 * 7 * this.quads);
				this.quads++;
				this.prim.count += 6;
		}
		startFrame() {
				this.quads = 0;
				this.prim.count = 0;
				this.targetSize.width = this.device.canvas.scrollWidth;
				this.targetSize.height = this.device.canvas.scrollHeight;
		}
		render(app, layer, graphTexture, wordsTexture, clr, height) {
				this.buffer.setData(this.data.buffer);
				this.uniforms.clr.set(clr, 0);
				this.material.setParameter('clr', this.uniforms.clr);
				this.material.setParameter('graphTex', graphTexture);
				this.material.setParameter('wordsTex', wordsTexture);
				app.drawMeshInstance(this.meshInstance, layer);
		}
		constructor(device, maxQuads = 512){
				var format = new VertexFormat(device, [
						{
								semantic: SEMANTIC_POSITION,
								components: 3,
								type: TYPE_FLOAT32
						},
						{
								semantic: SEMANTIC_TEXCOORD0,
								components: 4,
								type: TYPE_FLOAT32
						}
				]);
				var indices = new Uint16Array(maxQuads * 6);
				for(var i = 0; i < maxQuads; ++i){
						indices[i * 6 + 0] = i * 4;
						indices[i * 6 + 1] = i * 4 + 1;
						indices[i * 6 + 2] = i * 4 + 2;
						indices[i * 6 + 3] = i * 4;
						indices[i * 6 + 4] = i * 4 + 2;
						indices[i * 6 + 5] = i * 4 + 3;
				}
				this.device = device;
				this.buffer = new VertexBuffer(device, format, maxQuads * 4, {
						usage: BUFFER_STREAM
				});
				this.data = new Float32Array(this.buffer.numBytes / 4);
				this.indexBuffer = new IndexBuffer(device, INDEXFORMAT_UINT16, maxQuads * 6, BUFFER_STATIC, indices);
				this.prim = {
						type: PRIMITIVE_TRIANGLES,
						indexed: true,
						base: 0,
						count: 0
				};
				this.quads = 0;
				this.mesh = new Mesh(device);
				this.mesh.vertexBuffer = this.buffer;
				this.mesh.indexBuffer[0] = this.indexBuffer;
				this.mesh.primitive = [
						this.prim
				];
				var wgsl = device.isWebGPU;
				var material = new ShaderMaterial({
						uniqueName: 'MiniStats',
						vertexCode: wgsl ? vertexShaderWGSL : vertexShaderGLSL,
						fragmentCode: wgsl ? fragmentShaderWGSL : fragmentShaderGLSL,
						shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL,
						attributes: {
								vertex_position: SEMANTIC_POSITION,
								vertex_texCoord0: SEMANTIC_TEXCOORD0
						}
				});
				this.material = material;
				material.cull = CULLFACE_NONE;
				material.depthState = DepthState.NODEPTH;
				material.blendState = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
				material.update();
				this.meshInstance = new MeshInstance(this.mesh, material, new GraphNode('MiniStatsMesh'));
				this.uniforms = {
						clr: new Float32Array(4)
				};
				this.targetSize = {
						width: device.width,
						height: device.height
				};
		}
}

class MiniStats {
		destroy() {
				this.device.off('resizecanvas', this.updateDiv, this);
				this.device.off('losecontext', this.loseContext, this);
				this.app.off('postrender', this.postRender, this);
				this.graphs.forEach((graph)=>graph.destroy());
				this.wordAtlas.destroy();
				this.texture.destroy();
		}
		static getDefaultOptions() {
				return {
						sizes: [
								{
										width: 100,
										height: 16,
										spacing: 0,
										graphs: false
								},
								{
										width: 128,
										height: 32,
										spacing: 2,
										graphs: true
								},
								{
										width: 256,
										height: 64,
										spacing: 2,
										graphs: true
								}
						],
						startSizeIndex: 0,
						textRefreshRate: 500,
						cpu: {
								enabled: true,
								watermark: 33
						},
						gpu: {
								enabled: true,
								watermark: 33
						},
						stats: [
								{
										name: 'Frame',
										stats: [
												'frame.ms'
										],
										decimalPlaces: 1,
										unitsName: 'ms',
										watermark: 33
								},
								{
										name: 'DrawCalls',
										stats: [
												'drawCalls.total'
										],
										watermark: 1000
								}
						]
				};
		}
		set activeSizeIndex(value) {
				this._activeSizeIndex = value;
				this.gspacing = this.sizes[value].spacing;
				this.resize(this.sizes[value].width, this.sizes[value].height, this.sizes[value].graphs);
		}
		get activeSizeIndex() {
				return this._activeSizeIndex;
		}
		set opacity(value) {
				this.clr[3] = value;
		}
		get opacity() {
				return this.clr[3];
		}
		get overallHeight() {
				var graphs = this.graphs;
				var spacing = this.gspacing;
				return this.height * graphs.length + spacing * (graphs.length - 1);
		}
		set enabled(value) {
				if (value !== this._enabled) {
						this._enabled = value;
						for(var i = 0; i < this.graphs.length; ++i){
								this.graphs[i].enabled = value;
								this.graphs[i].timer.enabled = value;
						}
				}
		}
		get enabled() {
				return this._enabled;
		}
		initGraphs(app, device, options) {
				this.graphs = [];
				if (options.cpu.enabled) {
						var timer = new CpuTimer(app);
						var graph = new Graph('CPU', app, options.cpu.watermark, options.textRefreshRate, timer);
						this.graphs.push(graph);
				}
				if (options.gpu.enabled) {
						var timer1 = new GpuTimer(device);
						var graph1 = new Graph('GPU', app, options.gpu.watermark, options.textRefreshRate, timer1);
						this.graphs.push(graph1);
				}
				if (options.stats) {
						options.stats.forEach((entry)=>{
								var timer = new StatsTimer(app, entry.stats, entry.decimalPlaces, entry.unitsName, entry.multiplier);
								var graph = new Graph(entry.name, app, entry.watermark, options.textRefreshRate, timer);
								this.graphs.push(graph);
						});
				}
				var maxWidth = options.sizes.reduce((max, v)=>{
						return v.width > max ? v.width : max;
				}, 0);
				this.texture = new Texture(device, {
						name: 'mini-stats-graph-texture',
						width: math.nextPowerOfTwo(maxWidth),
						height: math.nextPowerOfTwo(this.graphs.length),
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_REPEAT,
						addressV: ADDRESS_REPEAT
				});
				this.graphs.forEach((graph, i)=>{
						graph.texture = this.texture;
						graph.yOffset = i;
				});
		}
		render() {
				var graphs = this.graphs;
				var wordAtlas = this.wordAtlas;
				var render2d = this.render2d;
				var width = this.width;
				var height = this.height;
				var gspacing = this.gspacing;
				render2d.startFrame();
				for(var i = 0; i < graphs.length; ++i){
						var graph = graphs[i];
						var y = i * (height + gspacing);
						graph.render(render2d, 0, y, width, height);
						var x = 1;
						y += height - 13;
						x += wordAtlas.render(render2d, graph.name, x, y) + 10;
						var timingText = graph.timingText;
						for(var j = 0; j < timingText.length; ++j){
								x += wordAtlas.render(render2d, timingText[j], x, y);
						}
						if (graph.timer.unitsName) {
								x += 3;
								wordAtlas.render(render2d, graph.timer.unitsName, x, y);
						}
				}
				render2d.render(this.app, this.drawLayer, this.texture, this.wordAtlas.texture, this.clr, height);
		}
		resize(width, height, showGraphs) {
				var graphs = this.graphs;
				for(var i = 0; i < graphs.length; ++i){
						graphs[i].enabled = showGraphs;
				}
				this.width = width;
				this.height = height;
				this.updateDiv();
		}
		updateDiv() {
				var rect = this.device.canvas.getBoundingClientRect();
				this.div.style.left = "" + rect.left + "px";
				this.div.style.bottom = "" + (window.innerHeight - rect.bottom) + "px";
				this.div.style.width = "" + this.width + "px";
				this.div.style.height = "" + this.overallHeight + "px";
		}
		loseContext() {
				this.graphs.forEach((graph)=>graph.loseContext());
		}
		postRender() {
				if (this._enabled) {
						this.render();
				}
		}
		constructor(app, options){
				var device = app.graphicsDevice;
				options = options || MiniStats.getDefaultOptions();
				this.initGraphs(app, device, options);
				var words = new Set([
						'',
						'ms',
						'0',
						'1',
						'2',
						'3',
						'4',
						'5',
						'6',
						'7',
						'8',
						'9',
						'.'
				].concat(this.graphs.map((graph)=>graph.name)).concat(options.stats ? options.stats.map((stat)=>stat.unitsName) : []).filter((item)=>!!item));
				this.wordAtlas = new WordAtlas(device, words);
				this.sizes = options.sizes;
				this._activeSizeIndex = options.startSizeIndex;
				var div = document.createElement('div');
				div.setAttribute('id', 'mini-stats');
				div.style.cssText = 'position:fixed;bottom:0;left:0;background:transparent;';
				document.body.appendChild(div);
				div.addEventListener('mouseenter', (event)=>{
						this.opacity = 1.0;
				});
				div.addEventListener('mouseleave', (event)=>{
						this.opacity = 0.7;
				});
				div.addEventListener('click', (event)=>{
						event.preventDefault();
						if (this._enabled) {
								this.activeSizeIndex = (this.activeSizeIndex + 1) % this.sizes.length;
								this.resize(this.sizes[this.activeSizeIndex].width, this.sizes[this.activeSizeIndex].height, this.sizes[this.activeSizeIndex].graphs);
						}
				});
				device.on('resizecanvas', this.updateDiv, this);
				device.on('losecontext', this.loseContext, this);
				app.on('postrender', this.postRender, this);
				this.app = app;
				this.drawLayer = app.scene.layers.getLayerById(LAYERID_UI);
				this.device = device;
				this.render2d = new Render2d(device);
				this.div = div;
				this.width = 0;
				this.height = 0;
				this.gspacing = 2;
				this.clr = [
						1,
						1,
						1,
						0.5
				];
				this._enabled = true;
				this.activeSizeIndex = this._activeSizeIndex;
		}
}

var shaderOutlineExtendPS = "\n	varying vec2 vUv0;\n	uniform vec2 uOffset;\n	uniform float uSrcMultiplier;\n	uniform sampler2D source;\n	void main(void)\n	{\n		vec4 pixel;\n		vec4 texel = texture2D(source, vUv0);\n		vec4 firstTexel = texel;\n		float diff = texel.a * uSrcMultiplier;\n		pixel = texture2D(source, vUv0 + uOffset * -2.0);\n		texel = max(texel, pixel);\n		diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n		pixel = texture2D(source, vUv0 + uOffset * -1.0);\n		texel = max(texel, pixel);\n		diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n		pixel = texture2D(source, vUv0 + uOffset * 1.0);\n		texel = max(texel, pixel);\n		diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n		pixel = texture2D(source, vUv0 + uOffset * 2.0);\n		texel = max(texel, pixel);\n		diff = max(diff, length(firstTexel.rgb - pixel.rgb));\n	   gl_FragColor = vec4(texel.rgb, min(diff, 1.0));\n	}\n";
var _tempFloatArray = new Float32Array(2);
var _tempColor = new Color();
class OutlineRenderer {
		destroy() {
				var _this_quadRenderer;
				this.whiteTex.destroy();
				this.whiteTex = null;
				this.outlineCameraEntity.destroy();
				this.outlineCameraEntity = null;
				this.rt.destroyTextureBuffers();
				this.rt.destroy();
				this.rt = null;
				this.tempRt.destroyTextureBuffers();
				this.tempRt.destroy();
				this.tempRt = null;
				this.app.scene.off('postrender', this.postRender);
				(_this_quadRenderer = this.quadRenderer) == null ? void 0 : _this_quadRenderer.destroy();
				this.quadRenderer = null;
		}
		getMeshInstances(entity, recursive) {
				var meshInstances = [];
				var renders = recursive ? entity.findComponents('render') : entity.render ? [
						entity.render
				] : [];
				renders.forEach((render)=>{
						if (render.meshInstances) {
								meshInstances.push(...render.meshInstances);
						}
				});
				var models = recursive ? entity.findComponents('model') : entity.model ? [
						entity.model
				] : [];
				models.forEach((model)=>{
						if (model.meshInstances) {
								meshInstances.push(...model.meshInstances);
						}
				});
				return meshInstances;
		}
		addEntity(entity, color, recursive) {
				if (recursive === void 0) recursive = true;
				var meshInstances = this.getMeshInstances(entity, recursive);
				meshInstances.forEach((meshInstance)=>{
						if (meshInstance.material instanceof StandardMaterial) {
								var outlineShaderPass = this.outlineShaderPass;
								meshInstance.material.onUpdateShader = (options)=>{
										if (options.pass === outlineShaderPass) {
												var opts = new StandardMaterialOptions();
												opts.defines = options.defines;
												opts.opacityMap = options.opacityMap;
												opts.opacityMapUv = options.opacityMapUv;
												opts.opacityMapChannel = options.opacityMapChannel;
												opts.opacityMapTransform = options.opacityMapTransform;
												opts.opacityVertexColor = options.opacityVertexColor;
												opts.opacityVertexColorChannel = options.opacityVertexColorChannel;
												opts.litOptions.vertexColors = options.litOptions.vertexColors;
												opts.litOptions.alphaTest = options.litOptions.alphaTest;
												opts.litOptions.skin = options.litOptions.skin;
												opts.litOptions.batch = options.litOptions.batch;
												opts.litOptions.useInstancing = options.litOptions.useInstancing;
												opts.litOptions.useMorphPosition = options.litOptions.useMorphPosition;
												opts.litOptions.useMorphNormal = options.litOptions.useMorphNormal;
												opts.litOptions.useMorphTextureBasedInt = options.litOptions.useMorphTextureBasedInt;
												return opts;
										}
										return options;
								};
								_tempColor.linear(color);
								var colArray = new Float32Array([
										_tempColor.r,
										_tempColor.g,
										_tempColor.b
								]);
								meshInstance.setParameter('material_emissive', colArray, 1 << this.outlineShaderPass);
								meshInstance.setParameter('texture_emissiveMap', this.whiteTex, 1 << this.outlineShaderPass);
						}
				});
				this.renderingLayer.addMeshInstances(meshInstances, true);
		}
		removeEntity(entity, recursive) {
				if (recursive === void 0) recursive = true;
				var meshInstances = this.getMeshInstances(entity, recursive);
				this.renderingLayer.removeMeshInstances(meshInstances);
				meshInstances.forEach((meshInstance)=>{
						if (meshInstance.material instanceof StandardMaterial) {
								meshInstance.material.onUpdateShader = null;
								meshInstance.deleteParameter('material_emissive');
						}
				});
		}
		removeAllEntities() {
				this.renderingLayer.clearMeshInstances();
		}
		blendOutlines() {
				var device = this.app.graphicsDevice;
				device.scope.resolve('source').setValue(this.rt.colorBuffer);
				device.setDepthState(DepthState.NODEPTH);
				device.setCullMode(CULLFACE_NONE);
				device.setBlendState(this.blendState);
				this.quadRenderer.render();
		}
		onPostRender() {
				var device = this.app.graphicsDevice;
				var uOffset = device.scope.resolve('uOffset');
				var uColorBuffer = device.scope.resolve('source');
				var uSrcMultiplier = device.scope.resolve('uSrcMultiplier');
				var { rt, tempRt, shaderExtend } = this;
				var { width, height } = rt;
				_tempFloatArray[0] = 1.0 / width / 2.0;
				_tempFloatArray[1] = 0;
				uOffset.setValue(_tempFloatArray);
				uColorBuffer.setValue(rt.colorBuffer);
				uSrcMultiplier.setValue(0.0);
				drawQuadWithShader(device, tempRt, shaderExtend);
				_tempFloatArray[0] = 0;
				_tempFloatArray[1] = 1.0 / height / 2.0;
				uOffset.setValue(_tempFloatArray);
				uColorBuffer.setValue(tempRt.colorBuffer);
				uSrcMultiplier.setValue(1.0);
				drawQuadWithShader(device, rt, shaderExtend);
		}
		createRenderTarget(name, width, height, depth) {
				var texture = new Texture(this.app.graphicsDevice, {
						name: name,
						width: width,
						height: height,
						format: PIXELFORMAT_SRGBA8,
						mipmaps: false,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
						magFilter: FILTER_LINEAR
				});
				return new RenderTarget({
						colorBuffer: texture,
						depth: depth,
						flipY: this.app.graphicsDevice.isWebGPU
				});
		}
		updateRenderTarget(sceneCamera) {
				var _sceneCamera_renderTarget, _sceneCamera_renderTarget1;
				var _sceneCamera_renderTarget_width;
				var width = (_sceneCamera_renderTarget_width = (_sceneCamera_renderTarget = sceneCamera.renderTarget) == null ? void 0 : _sceneCamera_renderTarget.width) != null ? _sceneCamera_renderTarget_width : this.app.graphicsDevice.width;
				var _sceneCamera_renderTarget_height;
				var height = (_sceneCamera_renderTarget_height = (_sceneCamera_renderTarget1 = sceneCamera.renderTarget) == null ? void 0 : _sceneCamera_renderTarget1.height) != null ? _sceneCamera_renderTarget_height : this.app.graphicsDevice.height;
				var outlineCamera = this.outlineCameraEntity.camera;
				if (!outlineCamera.renderTarget || outlineCamera.renderTarget.width !== width || outlineCamera.renderTarget.height !== height) {
						this.rt.resize(width, height);
						this.tempRt.resize(width, height);
				}
		}
		frameUpdate(sceneCameraEntity, blendLayer, blendLayerTransparent) {
				var sceneCamera = sceneCameraEntity.camera;
				this.updateRenderTarget(sceneCamera);
				var evt = this.app.scene.on('prerender:layer', (cameraComponent, layer, transparent)=>{
						if (sceneCamera === cameraComponent && transparent === blendLayerTransparent && layer === blendLayer) {
								this.blendOutlines();
								evt.off();
						}
				});
				this.outlineCameraEntity.setLocalPosition(sceneCameraEntity.getPosition());
				this.outlineCameraEntity.setLocalRotation(sceneCameraEntity.getRotation());
				var outlineCamera = this.outlineCameraEntity.camera;
				outlineCamera.projection = sceneCamera.projection;
				outlineCamera.horizontalFov = sceneCamera.horizontalFov;
				outlineCamera.fov = sceneCamera.fov;
				outlineCamera.orthoHeight = sceneCamera.orthoHeight;
				outlineCamera.nearClip = sceneCamera.nearClip;
				outlineCamera.farClip = sceneCamera.farClip;
		}
		constructor(app, renderingLayer, priority = -1){
				this.app = app;
				this.renderingLayer = renderingLayer != null ? renderingLayer : app.scene.layers.getLayerByName('Immediate');
				this.rt = this.createRenderTarget('OutlineTexture', 1, 1, true);
				this.outlineCameraEntity = new Entity('OutlineCamera');
				this.outlineCameraEntity.addComponent('camera', {
						layers: [
								this.renderingLayer.id
						],
						priority: priority,
						clearColor: new Color(0, 0, 0, 0),
						renderTarget: this.rt
				});
				this.outlineShaderPass = this.outlineCameraEntity.camera.setShaderPass('OutlineShaderPass');
				this.postRender = (cameraComponent)=>{
						if (this.outlineCameraEntity.camera === cameraComponent) {
								this.onPostRender();
						}
				};
				app.scene.on('postrender', this.postRender);
				this.app.root.addChild(this.outlineCameraEntity);
				this.tempRt = this.createRenderTarget('OutlineTempTexture', 1, 1, false);
				this.blendState = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA);
				var device = this.app.graphicsDevice;
				this.shaderExtend = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderOutlineExtendPS, 'OutlineExtendShader');
				this.shaderBlend = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.outputTex2DPS, 'OutlineBlendShader');
				this.quadRenderer = new QuadRender(this.shaderBlend);
				this.whiteTex = new Texture(device, {
						name: 'OutlineWhiteTexture',
						width: 1,
						height: 1,
						format: PIXELFORMAT_SRGBA8,
						mipmaps: false
				});
				var pixels = this.whiteTex.lock();
				pixels.set(new Uint8Array([
						255,
						255,
						255,
						255
				]));
				this.whiteTex.unlock();
		}
}

var textureBlitVertexShader = "\n	attribute vec2 vertex_position;\n	varying vec2 uv0;\n	void main(void) {\n		gl_Position = vec4(vertex_position, 0.5, 1.0);\n		uv0 = vertex_position.xy * 0.5 + 0.5;\n	}";
var textureBlitFragmentShader = "\n	varying vec2 uv0;\n	uniform sampler2D blitTexture;\n	void main(void) {\n		gl_FragColor = texture2D(blitTexture, uv0);\n	}";
class CoreExporter {
		textureToCanvas(texture, options) {
				if (options === void 0) options = {};
				var image = texture.getSource();
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
						var { width, height } = this.calcTextureSize(image.width, image.height, options.maxTextureSize);
						var canvas = document.createElement('canvas');
						canvas.width = width;
						canvas.height = height;
						var context = canvas.getContext('2d');
						if (context === null) {
								return Promise.resolve(undefined);
						}
						context.drawImage(image, 0, 0, canvas.width, canvas.height);
						if (options.color) {
								var { r, g, b } = options.color;
								var imagedata = context.getImageData(0, 0, width, height);
								var data = imagedata.data;
								for(var i = 0; i < data.length; i += 4){
										data[i + 0] = data[i + 0] * r;
										data[i + 1] = data[i + 1] * g;
										data[i + 2] = data[i + 2] * b;
								}
								context.putImageData(imagedata, 0, 0);
						}
						return Promise.resolve(canvas);
				}
				var device = texture.device;
				var { width: width1, height: height1 } = this.calcTextureSize(texture.width, texture.height, options.maxTextureSize);
				var format = isCompressedPixelFormat(texture.format) ? PIXELFORMAT_RGBA8 : texture.format;
				var dstTexture = new Texture(device, {
						name: 'ExtractedTexture',
						width: width1,
						height: height1,
						format: format,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_LINEAR,
						magFilter: FILTER_LINEAR,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				var renderTarget = new RenderTarget({
						colorBuffer: dstTexture,
						depth: false
				});
				var shader = createShaderFromCode(device, textureBlitVertexShader, textureBlitFragmentShader, 'ShaderCoreExporterBlit');
				device.scope.resolve('blitTexture').setValue(texture);
				device.setBlendState(BlendState.NOBLEND);
				drawQuadWithShader(device, renderTarget, shader);
				return dstTexture.read(0, 0, width1, height1, {
						renderTarget: renderTarget,
						immediate: true
				}).then((textureData)=>{
						dstTexture.destroy();
						renderTarget.destroy();
						var pixels = new Uint8ClampedArray(width1 * height1 * 4);
						pixels.set(textureData);
						var newImage = new ImageData(pixels, width1, height1);
						var canvas = document.createElement('canvas');
						canvas.width = width1;
						canvas.height = height1;
						var newContext = canvas.getContext('2d');
						if (!newContext) {
								return Promise.resolve(undefined);
						}
						newContext.putImageData(newImage, 0, 0);
						return Promise.resolve(canvas);
				});
		}
		calcTextureSize(width, height, maxTextureSize) {
				if (maxTextureSize) {
						var scale = Math.min(maxTextureSize / Math.max(width, height), 1);
						width = Math.round(width * scale);
						height = Math.round(height * scale);
				}
				return {
						width,
						height
				};
		}
		constructor(){}
}

var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		3,
		3,
		3,
		3,
		4,
		4,
		4,
		4,
		5,
		5,
		5,
		5,
		0,
		0,
		0,
		0
]);
var fdeb = new u8([
		0,
		0,
		0,
		0,
		1,
		1,
		2,
		2,
		3,
		3,
		4,
		4,
		5,
		5,
		6,
		6,
		7,
		7,
		8,
		8,
		9,
		9,
		10,
		10,
		11,
		11,
		12,
		12,
		13,
		13,
		0,
		0
]);
var clim = new u8([
		16,
		17,
		18,
		0,
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15
]);
var freb = function freb(eb, start) {
		var b = new u16(31);
		for(var i = 0; i < 31; ++i){
				b[i] = start += 1 << eb[i - 1];
		}
		var r = new i32(b[30]);
		for(var i = 1; i < 30; ++i){
				for(var j = b[i]; j < b[i + 1]; ++j){
						r[j] = j - b[i] << 5 | i;
				}
		}
		return {
				b: b,
				r: r
		};
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), revfd = _b.r;
var rev = new u16(32768);
for(var i = 0; i < 32768; ++i){
		var x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1;
		x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;
		x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;
		rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;
}
var hMap = function hMap(cd, mb, r) {
		var s = cd.length;
		var i = 0;
		var l = new u16(mb);
		for(; i < s; ++i){
				if (cd[i]) ++l[cd[i] - 1];
		}
		var le = new u16(mb);
		for(i = 1; i < mb; ++i){
				le[i] = le[i - 1] + l[i - 1] << 1;
		}
		var co;
		if (r) {
				co = new u16(1 << mb);
				var rvb = 15 - mb;
				for(i = 0; i < s; ++i){
						if (cd[i]) {
								var sv = i << 4 | cd[i];
								var r_1 = mb - cd[i];
								var v = le[cd[i] - 1]++ << r_1;
								for(var m = v | (1 << r_1) - 1; v <= m; ++v){
										co[rev[v] >> rvb] = sv;
								}
						}
				}
		} else {
				co = new u16(s);
				for(i = 0; i < s; ++i){
						if (cd[i]) {
								co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
						}
				}
		}
		return co;
};
var flt = new u8(288);
for(var i = 0; i < 144; ++i)flt[i] = 8;
for(var i = 144; i < 256; ++i)flt[i] = 9;
for(var i = 256; i < 280; ++i)flt[i] = 7;
for(var i = 280; i < 288; ++i)flt[i] = 8;
var fdt = new u8(32);
for(var i = 0; i < 32; ++i)fdt[i] = 5;
var flm = hMap(flt, 9, 0); hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0); hMap(fdt, 5, 1);
var shft = function shft(p) {
		return (p + 7) / 8 | 0;
};
var slc = function slc(v, s, e) {
		if (e == null || e > v.length) e = v.length;
		return new u8(v.subarray(s, e));
};
var ec = [
		'unexpected EOF',
		'invalid block type',
		'invalid length/literal',
		'invalid distance',
		'stream finished',
		'no stream handler',
		,
		'no callback',
		'invalid UTF-8 data',
		'extra field too long',
		'date not in range 1980-2099',
		'filename too long',
		'stream finishing',
		'invalid zip data'
];
var err = function err1(ind, msg, nt) {
		var e = new Error(msg || ec[ind]);
		e.code = ind;
		if (Error.captureStackTrace) Error.captureStackTrace(e, err);
		if (!nt) throw e;
		return e;
};
var wbits = function wbits(d, p, v) {
		v <<= p & 7;
		var o = p / 8 | 0;
		d[o] |= v;
		d[o + 1] |= v >> 8;
};
var wbits16 = function wbits16(d, p, v) {
		v <<= p & 7;
		var o = p / 8 | 0;
		d[o] |= v;
		d[o + 1] |= v >> 8;
		d[o + 2] |= v >> 16;
};
var hTree = function hTree(d, mb) {
		var t = [];
		for(var i = 0; i < d.length; ++i){
				if (d[i]) t.push({
						s: i,
						f: d[i]
				});
		}
		var s = t.length;
		var t2 = t.slice();
		if (!s) return {
				t: et,
				l: 0
		};
		if (s == 1) {
				var v = new u8(t[0].s + 1);
				v[t[0].s] = 1;
				return {
						t: v,
						l: 1
				};
		}
		t.sort(function(a, b) {
				return a.f - b.f;
		});
		t.push({
				s: -1,
				f: 25001
		});
		var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
		t[0] = {
				s: -1,
				f: l.f + r.f,
				l: l,
				r: r
		};
		while(i1 != s - 1){
				l = t[t[i0].f < t[i2].f ? i0++ : i2++];
				r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
				t[i1++] = {
						s: -1,
						f: l.f + r.f,
						l: l,
						r: r
				};
		}
		var maxSym = t2[0].s;
		for(var i = 1; i < s; ++i){
				if (t2[i].s > maxSym) maxSym = t2[i].s;
		}
		var tr = new u16(maxSym + 1);
		var mbt = ln(t[i1 - 1], tr, 0);
		if (mbt > mb) {
				var i = 0, dt = 0;
				var lft = mbt - mb, cst = 1 << lft;
				t2.sort(function(a, b) {
						return tr[b.s] - tr[a.s] || a.f - b.f;
				});
				for(; i < s; ++i){
						var i2_1 = t2[i].s;
						if (tr[i2_1] > mb) {
								dt += cst - (1 << mbt - tr[i2_1]);
								tr[i2_1] = mb;
						} else break;
				}
				dt >>= lft;
				while(dt > 0){
						var i2_2 = t2[i].s;
						if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;
						else ++i;
				}
				for(; i >= 0 && dt; --i){
						var i2_3 = t2[i].s;
						if (tr[i2_3] == mb) {
								--tr[i2_3];
								++dt;
						}
				}
				mbt = mb;
		}
		return {
				t: new u8(tr),
				l: mbt
		};
};
var ln = function ln1(n, l, d) {
		return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function lc(c) {
		var s = c.length;
		while(s && !c[--s]);
		var cl = new u16(++s);
		var cli = 0, cln = c[0], cls = 1;
		var w = function w(v) {
				cl[cli++] = v;
		};
		for(var i = 1; i <= s; ++i){
				if (c[i] == cln && i != s) ++cls;
				else {
						if (!cln && cls > 2) {
								for(; cls > 138; cls -= 138)w(32754);
								if (cls > 2) {
										w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
										cls = 0;
								}
						} else if (cls > 3) {
								w(cln), --cls;
								for(; cls > 6; cls -= 6)w(8304);
								if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
						}
						while(cls--)w(cln);
						cls = 1;
						cln = c[i];
				}
		}
		return {
				c: cl.subarray(0, cli),
				n: s
		};
};
var clen = function clen(cf, cl) {
		var l = 0;
		for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];
		return l;
};
var wfblk = function wfblk(out, pos, dat) {
		var s = dat.length;
		var o = shft(pos + 2);
		out[o] = s & 255;
		out[o + 1] = s >> 8;
		out[o + 2] = out[o] ^ 255;
		out[o + 3] = out[o + 1] ^ 255;
		for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];
		return (o + 4 + s) * 8;
};
var wblk = function wblk(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
		wbits(out, p++, final);
		++lf[256];
		var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
		var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
		var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
		var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
		var lcfreq = new u16(19);
		for(var i = 0; i < lclt.length; ++i)++lcfreq[lclt[i] & 31];
		for(var i = 0; i < lcdt.length; ++i)++lcfreq[lcdt[i] & 31];
		var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
		var nlcc = 19;
		for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
		var flen = bl + 5 << 3;
		var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
		var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
		if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
		var lm, ll, dm, dl;
		wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
		if (dtlen < ftlen) {
				lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
				var llm = hMap(lct, mlcb, 0);
				wbits(out, p, nlc - 257);
				wbits(out, p + 5, ndc - 1);
				wbits(out, p + 10, nlcc - 4);
				p += 14;
				for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);
				p += 3 * nlcc;
				var lcts = [
						lclt,
						lcdt
				];
				for(var it = 0; it < 2; ++it){
						var clct = lcts[it];
						for(var i = 0; i < clct.length; ++i){
								var len = clct[i] & 31;
								wbits(out, p, llm[len]), p += lct[len];
								if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
						}
				}
		} else {
				lm = flm, ll = flt, dm = fdm, dl = fdt;
		}
		for(var i = 0; i < li; ++i){
				var sym = syms[i];
				if (sym > 255) {
						var len = sym >> 18 & 31;
						wbits16(out, p, lm[len + 257]), p += ll[len + 257];
						if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
						var dst = sym & 31;
						wbits16(out, p, dm[dst]), p += dl[dst];
						if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
				} else {
						wbits16(out, p, lm[sym]), p += ll[sym];
				}
		}
		wbits16(out, p, lm[256]);
		return p + ll[256];
};
var deo = new i32([
		65540,
		131080,
		131088,
		131104,
		262176,
		1048704,
		1048832,
		2114560,
		2117632
]);
var et = new u8(0);
var dflt = function dflt(dat, lvl, plvl, pre, post, st) {
		var s = st.z || dat.length;
		var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
		var w = o.subarray(pre, o.length - post);
		var lst = st.l;
		var pos = (st.r || 0) & 7;
		if (lvl) {
				if (pos) w[0] = st.r >> 3;
				var opt = deo[lvl - 1];
				var n = opt >> 13, c = opt & 8191;
				var msk_1 = (1 << plvl) - 1;
				var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
				var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
				var hsh = function hsh(i) {
						return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
				};
				var syms = new i32(25000);
				var lf = new u16(288), df = new u16(32);
				var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
				for(; i + 2 < s; ++i){
						var hv = hsh(i);
						var imod = i & 32767, pimod = head[hv];
						prev[imod] = pimod;
						head[hv] = imod;
						if (wi <= i) {
								var rem = s - i;
								if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
										pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
										li = lc_1 = eb = 0, bs = i;
										for(var j = 0; j < 286; ++j)lf[j] = 0;
										for(var j = 0; j < 30; ++j)df[j] = 0;
								}
								var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
								if (rem > 2 && hv == hsh(i - dif)) {
										var maxn = Math.min(n, rem) - 1;
										var maxd = Math.min(32767, i);
										var ml = Math.min(258, rem);
										while(dif <= maxd && --ch_1 && imod != pimod){
												if (dat[i + l] == dat[i + l - dif]) {
														var nl = 0;
														for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
														if (nl > l) {
																l = nl, d = dif;
																if (nl > maxn) break;
																var mmd = Math.min(dif, nl - 2);
																var md = 0;
																for(var j = 0; j < mmd; ++j){
																		var ti = i - dif + j & 32767;
																		var pti = prev[ti];
																		var cd = ti - pti & 32767;
																		if (cd > md) md = cd, pimod = ti;
																}
														}
												}
												imod = pimod, pimod = prev[imod];
												dif += imod - pimod & 32767;
										}
								}
								if (d) {
										syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
										var lin = revfl[l] & 31, din = revfd[d] & 31;
										eb += fleb[lin] + fdeb[din];
										++lf[257 + lin];
										++df[din];
										wi = i + l;
										++lc_1;
								} else {
										syms[li++] = dat[i];
										++lf[dat[i]];
								}
						}
				}
				for(i = Math.max(i, wi); i < s; ++i){
						syms[li++] = dat[i];
						++lf[dat[i]];
				}
				pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
				if (!lst) {
						st.r = pos & 7 | w[pos / 8 | 0] << 3;
						pos -= 7;
						st.h = head, st.p = prev, st.i = i, st.w = wi;
				}
		} else {
				for(var i = st.w || 0; i < s + lst; i += 65535){
						var e = i + 65535;
						if (e >= s) {
								w[pos / 8 | 0] = lst;
								e = s;
						}
						pos = wfblk(w, pos + 1, dat.subarray(i, e));
				}
				st.i = s;
		}
		return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
		var t = new Int32Array(256);
		for(var i = 0; i < 256; ++i){
				var c = i, k = 9;
				while(--k)c = (c & 1 && -306674912) ^ c >>> 1;
				t[i] = c;
		}
		return t;
}();
var crc = function crc() {
		var c = -1;
		return {
				p: function p(d) {
						var cr = c;
						for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
						c = cr;
				},
				d: function d() {
						return ~c;
				}
		};
};
var dopt = function dopt(dat, opt, pre, post, st) {
		if (!st) {
				st = {
						l: 1
				};
				if (opt.dictionary) {
						var dict = opt.dictionary.subarray(-32768);
						var newDat = new u8(dict.length + dat.length);
						newDat.set(dict);
						newDat.set(dat, dict.length);
						dat = newDat;
						st.w = dict.length;
				}
		}
		return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function mrg(a, b) {
		var o = {};
		for(var k in a)o[k] = a[k];
		for(var k in b)o[k] = b[k];
		return o;
};
var wbytes = function wbytes(d, b, v) {
		for(; v; ++b)d[b] = v, v >>>= 8;
};
function deflateSync(data, opts) {
		return dopt(data, opts || {}, 0, 0);
}
var fltn = function fltn1(d, p, t, o) {
		for(var k in d){
				var val = d[k], n = p + k, op = o;
				if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
				if (val instanceof u8) t[n] = [
						val,
						op
				];
				else {
						t[n += '/'] = [
								new u8(0),
								op
						];
						fltn(val, n, t, o);
				}
		}
};
var te = typeof TextEncoder != 'undefined' && new TextEncoder();
var td = typeof TextDecoder != 'undefined' && new TextDecoder();
var tds = 0;
try {
		td.decode(et, {
				stream: true
		});
		tds = 1;
} catch (e) {}
function strToU8(str, latin1) {
		var i; 
		if (te) return te.encode(str);
		var l = str.length;
		var ar = new u8(str.length + (str.length >> 1));
		var ai = 0;
		var w = function w(v) {
				ar[ai++] = v;
		};
		for(var i = 0; i < l; ++i){
				if (ai + 5 > ar.length) {
						var n = new u8(ai + 8 + (l - i << 1));
						n.set(ar);
						ar = n;
				}
				var c = str.charCodeAt(i);
				if (c < 128 || latin1) w(c);
				else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);
				else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
				else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
		}
		return slc(ar, 0, ai);
}
var exfl = function exfl(ex) {
		var le = 0;
		if (ex) {
				for(var k in ex){
						var l = ex[k].length;
						if (l > 65535) err(9);
						le += l + 4;
				}
		}
		return le;
};
var wzh = function wzh(d, b, f, fn, u, c, ce, co) {
		var fl = fn.length, ex = f.extra, col = co && co.length;
		var exl = exfl(ex);
		wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
		if (ce != null) d[b++] = 20, d[b++] = f.os;
		d[b] = 20, b += 2;
		d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
		d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
		var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
		if (y < 0 || y > 119) err(10);
		wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
		if (c != -1) {
				wbytes(d, b, f.crc);
				wbytes(d, b + 4, c < 0 ? -c - 2 : c);
				wbytes(d, b + 8, f.size);
		}
		wbytes(d, b + 12, fl);
		wbytes(d, b + 14, exl), b += 16;
		if (ce != null) {
				wbytes(d, b, col);
				wbytes(d, b + 6, f.attrs);
				wbytes(d, b + 10, ce), b += 14;
		}
		d.set(fn, b);
		b += fl;
		if (exl) {
				for(var k in ex){
						var exf = ex[k], l = exf.length;
						wbytes(d, b, +k);
						wbytes(d, b + 2, l);
						d.set(exf, b + 4), b += 4 + l;
				}
		}
		if (col) d.set(co, b), b += col;
		return b;
};
var wzf = function wzf(o, b, c, d, e) {
		wbytes(o, b, 0x6054B50);
		wbytes(o, b + 8, c);
		wbytes(o, b + 10, c);
		wbytes(o, b + 12, d);
		wbytes(o, b + 16, e);
};
function zipSync(data, opts) {
		if (!opts) opts = {};
		var r = {};
		var files = [];
		fltn(data, '', r, opts);
		var o = 0;
		var tot = 0;
		for(var fn in r){
				var _a = r[fn], file = _a[0], p = _a[1];
				var compression = p.level == 0 ? 0 : 8;
				var f = strToU8(fn), s = f.length;
				var com = p.comment, m = com && strToU8(com), ms = m && m.length;
				var exl = exfl(p.extra);
				if (s > 65535) err(11);
				var d = compression ? deflateSync(file, p) : file, l = d.length;
				var c = crc();
				c.p(file);
				files.push(mrg(p, {
						size: file.length,
						crc: c.d(),
						c: d,
						f: f,
						m: m,
						u: s != fn.length || m && com.length != ms,
						o: o,
						compression: compression
				}));
				o += 30 + s + exl + l;
				tot += 76 + 2 * (s + exl) + (ms || 0) + l;
		}
		var out = new u8(tot + 22), oe = o, cdl = tot - o;
		for(var i = 0; i < files.length; ++i){
				var f = files[i];
				wzh(out, f.o, f, f.f, f.u, f.c.length);
				var badd = 30 + f.f.length + exfl(f.extra);
				out.set(f.c, f.o + badd);
				wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
		}
		wzf(out, o, files.length, cdl, oe);
		return out;
}

var ROOT_FILE_NAME = 'root';
var header = '#usda 1.0\n(\n    customLayerData = {\n        string creator = "PlayCanvas UsdzExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n';
var materialListTemplate = (materials)=>'\ndef "Materials"\n{\n    ' + materials.join('\n') + "\n}\n";
var meshTemplate = (faceVertexCounts, indices, normals, positions, uv0, uv1)=>'\ndef "Mesh"\n{\n    def Mesh "Mesh"\n    {\n        int[] faceVertexCounts = [' + faceVertexCounts + "]\n        int[] faceVertexIndices = [" + indices + "]\n        normal3f[] normals = [" + normals + '] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [' + positions + "]\n        texCoord2f[] primvars:st = [" + uv0 + '] (\n            interpolation = "vertex"\n        )\n        texCoord2f[] primvars:st1 = [' + uv1 + '] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n}\n';
var meshInstanceTemplate = (nodeName, meshRefPath, worldMatrix, materialRefPath)=>'\ndef Xform "' + nodeName + '" (\n    prepend references = ' + meshRefPath + "\n)\n{\n    matrix4d xformOp:transform = " + worldMatrix + '\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = ' + materialRefPath + "\n}\n";
var materialValueTemplate = (type, name, value)=>"                    " + type + " inputs:" + name + " = " + value;
class UsdzExporter extends CoreExporter {
		init() {
				this.meshMap = new Map();
				this.textureMap = new Map();
				this.materialMap = new Map();
				this.materials = [];
				this.files = {};
				this.nodeNames = new Set();
		}
		done() {
				this.meshMap = null;
				this.textureMap = null;
				this.materialMap = null;
				this.materials = null;
				this.files = null;
				this.nodeNames = null;
		}
		build(entity, options) {
				var _this, _loop = function(i) {
						var mimeType = 'image/png' ;
						var texture = textureArray[i];
						var texturePromise = _this.textureToCanvas(texture, textureOptions).then((canvas)=>{
								if (canvas) {
										return new Promise((resolve)=>canvas.toBlob(resolve, mimeType, 1)).then((blob)=>blob.arrayBuffer());
								}
								console.warn("Export of texture " + texture.name + " is not currently supported.");
								return new Promise((resolve)=>resolve(null));
						});
						promises.push(texturePromise);
				};
				if (options === void 0) options = {};
				this.init();
				this.addFile(null, ROOT_FILE_NAME);
				var allMeshInstances = [];
				if (entity) {
						var renders = entity.findComponents('render');
						renders.forEach((render)=>{
								allMeshInstances.push(...render.meshInstances);
						});
				}
				var rootContent = '';
				allMeshInstances.forEach((meshInstance)=>{
						rootContent += this.buildMeshInstance(meshInstance);
				});
				rootContent += materialListTemplate(this.materials);
				this.addFile(null, ROOT_FILE_NAME, '', rootContent);
				var textureOptions = {
						maxTextureSize: options.maxTextureSize
				};
				var textureArray = Array.from(this.textureMap.keys());
				var promises = [];
				for(var i = 0; i < textureArray.length; i++)_this = this, _loop(i);
				var finalData = Promise.all(promises).then((values)=>{
						values.forEach((textureArrayBuffer, index)=>{
								var texture = textureArray[index];
								var ids = this.getTextureFileIds(texture);
								this.files[ids.fileName] = new Uint8Array(textureArrayBuffer);
						});
						this.alignFiles();
						var arraybuffer = zipSync(this.files, {
								level: 0
						});
						this.done();
						return arraybuffer;
				});
				return finalData;
		}
		alignFiles() {
				var offset = 0;
				for(var filename in this.files){
						var file = this.files[filename];
						var headerSize = 34 + filename.length;
						offset += headerSize;
						var offsetMod64 = offset & 63;
						if (offsetMod64 !== 4) {
								var padLength = 64 - offsetMod64;
								var padding = new Uint8Array(padLength);
								this.files[filename] = [
										file,
										{
												extra: {
														12345: padding
												}
										}
								];
						}
						offset = file.length;
				}
		}
		getFileIds(category, name, ref, extension) {
				if (extension === void 0) extension = 'usda';
				var fileName = "" + (category ? "" + category + "/" : '') + name + "." + extension;
				var refName = "@./" + fileName + "@</" + ref + ">";
				return {
						name,
						fileName,
						refName
				};
		}
		getTextureFileIds(texture) {
				return this.getFileIds('texture', "Texture_" + texture.id, 'Texture', 'png');
		}
		addFile(category, uniqueId, refName, content) {
				if (refName === void 0) refName = '';
				if (content === void 0) content = '';
				var contentU8 = null;
				if (content) {
						content = header + "\n" + content;
						contentU8 = strToU8(content);
				}
				var ids = this.getFileIds(category, uniqueId, refName);
				this.files[ids.fileName] = contentU8;
				return ids.refName;
		}
		getMaterialRef(material) {
				var materialRef = this.materialMap.get(material);
				if (!materialRef) {
						materialRef = this.buildMaterial(material);
						this.materialMap.set(material, materialRef);
				}
				return materialRef;
		}
		getMeshRef(mesh) {
				var meshRef = this.meshMap.get(mesh);
				if (!meshRef) {
						meshRef = this.buildMesh(mesh);
						this.meshMap.set(mesh, meshRef);
				}
				return meshRef;
		}
		buildArray2(array) {
				var components = [];
				var count = array.length;
				for(var i = 0; i < count; i += 2){
						components.push("(" + array[i] + ", " + (1 - array[i + 1]) + ")");
				}
				return components.join(', ');
		}
		buildArray3(array) {
				var components = [];
				var count = array.length;
				for(var i = 0; i < count; i += 3){
						components.push("(" + array[i] + ", " + array[i + 1] + ", " + array[i + 2] + ")");
				}
				return components.join(', ');
		}
		buildMat4(mat) {
				var data = mat.data;
				var vectors = [];
				for(var i = 0; i < 16; i += 4){
						vectors.push("(" + data[i] + ", " + data[i + 1] + ", " + data[i + 2] + ", " + data[i + 3] + ")");
				}
				return "( " + vectors.join(', ') + " )";
		}
		buildMaterial(material) {
				var materialName = "Material_" + material.id;
				var materialPath = "/Materials/" + materialName;
				var materialPropertyPath = (property)=>"<" + materialPath + property + ">";
				var buildTexture = (texture, textureIds, mapType, uvChannel, tiling, offset, rotation, tintColor)=>{
						return '\n                def Shader "Transform2d_' + mapType + '" (\n                    sdrMetadata = {\n                        string role = "math"\n                    }\n                )\n                {\n                    uniform token info:id = "UsdTransform2d"\n                    float2 inputs:in.connect = ' + materialPropertyPath("/uvReader_" + uvChannel + ".outputs:result") + "\n                    float inputs:rotation = " + rotation + "\n                    float2 inputs:scale = (" + tiling.x + ", " + tiling.y + ")\n                    float2 inputs:translation = (" + offset.x + ", " + offset.y + ')\n                    float2 outputs:result\n                }\n\n                def Shader "Texture_' + texture.id + "_" + mapType + '"\n                {\n                    uniform token info:id = "UsdUVTexture"\n                    asset inputs:file = @' + textureIds.fileName + "@\n                    float2 inputs:st.connect = " + materialPropertyPath("/Transform2d_" + mapType + ".outputs:result") + '\n                    token inputs:wrapS = "repeat"\n                    token inputs:wrapT = "repeat"\n                    float4 inputs:scale = (' + tintColor.r + ", " + tintColor.g + ", " + tintColor.b + ", " + tintColor.a + ")\n                    float outputs:r\n                    float outputs:g\n                    float outputs:b\n                    float3 outputs:rgb\n                    float outputs:a\n                }\n            ";
				};
				var inputs = [];
				var samplers = [];
				var addTexture = (textureSlot, uniform, propType, propName, valueName, handleOpacity, tintTexture)=>{
						if (handleOpacity === void 0) handleOpacity = false;
						if (tintTexture === void 0) tintTexture = false;
						var texture = material[textureSlot];
						if (texture) {
								var textureIds = this.getTextureFileIds(texture);
								this.textureMap.set(texture, textureIds.refName);
								var channel = material["" + textureSlot + "Channel"] || 'rgb';
								var textureValue = materialPropertyPath("/" + textureIds.name + "_" + valueName + ".outputs:" + channel);
								inputs.push(materialValueTemplate(propType, "" + propName + ".connect", textureValue));
								if (handleOpacity) {
										if (material.alphaTest > 0.0) ;
								}
								var tiling = material["" + textureSlot + "Tiling"];
								var offset = material["" + textureSlot + "Offset"];
								var rotation = material["" + textureSlot + "Rotation"];
								var uvChannel = material["" + textureSlot + "Uv"] === 1 ? 'st1' : 'st';
								var tintColor = tintTexture && uniform ? uniform : Color.WHITE;
								samplers.push(buildTexture(texture, textureIds, valueName, uvChannel, tiling, offset, rotation, tintColor));
						} else if (uniform) {
								var value = propType === 'float' ? "" + uniform : "(" + uniform.r + ", " + uniform.g + ", " + uniform.b + ")";
								inputs.push(materialValueTemplate(propType, propName, value));
						}
				};
				addTexture('diffuseMap', material.diffuse, 'color3f', 'diffuseColor', 'diffuse', false, true);
				if (material.transparent || material.alphaTest > 0.0) {
						addTexture('opacityMap', material.opacity, 'float', 'opacity', 'opacity', true);
				}
				addTexture('normalMap', null, 'normal3f', 'normal', 'normal');
				addTexture('emissiveMap', material.emissive, 'color3f', 'emissiveColor', 'emissive', false, true);
				addTexture('aoMap', null, 'float', 'occlusion', 'occlusion');
				addTexture('metalnessMap', material.metalness, 'float', 'metallic', 'metallic');
				addTexture('glossMap', material.gloss, 'float', 'roughness', 'roughness');
				var materialObject = '\n            def Material "' + materialName + '"\n            {\n                def Shader "PreviewSurface"\n                {\n                    uniform token info:id = "UsdPreviewSurface"\n' + inputs.join('\n') + "\n                    int inputs:useSpecularWorkflow = 0\n                    token outputs:surface\n                }\n\n                token outputs:surface.connect = " + materialPropertyPath('/PreviewSurface.outputs:surface') + '\n\n                def Shader "uvReader_st"\n                {\n                    uniform token info:id = "UsdPrimvarReader_float2"\n                    token inputs:varname = "st"\n                    float2 inputs:fallback = (0.0, 0.0)\n                    float2 outputs:result\n                }\n\n                def Shader "uvReader_st1"\n                {\n                    uniform token info:id = "UsdPrimvarReader_float2"\n                    token inputs:varname = "st1"\n                    float2 inputs:fallback = (0.0, 0.0)\n                    float2 outputs:result\n                }\n\n                ' + samplers.join('\n') + "\n            }\n        ";
				this.materials.push(materialObject);
				return materialPropertyPath('');
		}
		buildMesh(mesh) {
				var positions = [];
				var indices = [];
				var normals = [];
				var uv0 = [];
				var uv1 = [];
				mesh.getVertexStream(SEMANTIC_POSITION, positions);
				mesh.getVertexStream(SEMANTIC_NORMAL, normals);
				mesh.getVertexStream(SEMANTIC_TEXCOORD0, uv0);
				mesh.getVertexStream(SEMANTIC_TEXCOORD1, uv1);
				mesh.getIndices(indices);
				var indicesCount = indices.length || positions.length;
				var faceVertexCounts = Array(indicesCount / 3).fill(3).join(', ');
				if (!indices.length) {
						for(var i = 0; i < indicesCount; i++){
								indices[i] = i;
						}
				}
				var numVerts = positions.length / 3;
				normals = normals.length ? normals : Array(numVerts * 3).fill(0);
				uv0 = uv0.length ? uv0 : Array(numVerts * 2).fill(0);
				uv1 = uv1.length ? uv1 : Array(numVerts * 2).fill(0);
				positions = this.buildArray3(positions);
				normals = this.buildArray3(normals);
				uv0 = this.buildArray2(uv0);
				uv1 = this.buildArray2(uv1);
				var meshObject = meshTemplate(faceVertexCounts, indices, normals, positions, uv0, uv1);
				var refPath = this.addFile('mesh', "Mesh_" + mesh.id, 'Mesh', meshObject);
				return refPath;
		}
		buildMeshInstance(meshInstance) {
				var meshRefPath = this.getMeshRef(meshInstance.mesh);
				var materialRefPath = this.getMaterialRef(meshInstance.material);
				var worldMatrix = this.buildMat4(meshInstance.node.getWorldTransform());
				var name = meshInstance.node.name.replace(/[^a-z0-9]/gi, '_');
				var nodeName = name;
				while(this.nodeNames.has(nodeName)){
						nodeName = name + "_" + Math.random().toString(36).slice(2, 7);
				}
				this.nodeNames.add(nodeName);
				return meshInstanceTemplate(nodeName, meshRefPath, worldMatrix, materialRefPath);
		}
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		try {
				var info = gen[key](arg);
				var value = info.value;
		} catch (error) {
				reject(error);
				return;
		}
		if (info.done) {
				resolve(value);
		} else {
				Promise.resolve(value).then(_next, _throw);
		}
}
function _async_to_generator(fn) {
		return function() {
				var self = this, args = arguments;
				return new Promise(function(resolve, reject) {
						var gen = fn.apply(self, args);
						function _next(value) {
								asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
						}
						function _throw(err) {
								asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
						}
						_next(undefined);
				});
		};
}
var ARRAY_BUFFER = 34962;
var ELEMENT_ARRAY_BUFFER = 34963;
var getIndexComponentType = (indexFormat)=>{
		switch(indexFormat){
				case INDEXFORMAT_UINT8:
						return 5121;
				case INDEXFORMAT_UINT16:
						return 5123;
				case INDEXFORMAT_UINT32:
						return 5125;
		}
		return 0;
};
var getComponentType = (dataType)=>{
		switch(dataType){
				case TYPE_INT8:
						return 5120;
				case TYPE_UINT8:
						return 5121;
				case TYPE_INT16:
						return 5122;
				case TYPE_UINT16:
						return 5123;
				case TYPE_INT32:
						return 5124;
				case TYPE_UINT32:
						return 5125;
				case TYPE_FLOAT32:
						return 5126;
		}
		return 0;
};
var getAccessorType = (componentCount)=>{
		switch(componentCount){
				case 1:
						return 'SCALAR';
				case 2:
						return 'VEC2';
				case 3:
						return 'VEC3';
				case 4:
						return 'VEC4';
		}
		return 0;
};
var getSemantic = (engineSemantic)=>{
		switch(engineSemantic){
				case SEMANTIC_POSITION:
						return 'POSITION';
				case SEMANTIC_NORMAL:
						return 'NORMAL';
				case SEMANTIC_TANGENT:
						return 'TANGENT';
				case SEMANTIC_COLOR:
						return 'COLOR_0';
				case SEMANTIC_BLENDINDICES:
						return 'JOINTS_0';
				case SEMANTIC_BLENDWEIGHT:
						return 'WEIGHTS_0';
				case SEMANTIC_TEXCOORD0:
						return 'TEXCOORD_0';
				case SEMANTIC_TEXCOORD1:
						return 'TEXCOORD_1';
				case SEMANTIC_TEXCOORD2:
						return 'TEXCOORD_2';
				case SEMANTIC_TEXCOORD3:
						return 'TEXCOORD_3';
				case SEMANTIC_TEXCOORD4:
						return 'TEXCOORD_4';
				case SEMANTIC_TEXCOORD5:
						return 'TEXCOORD_5';
				case SEMANTIC_TEXCOORD6:
						return 'TEXCOORD_6';
				case SEMANTIC_TEXCOORD7:
						return 'TEXCOORD_7';
		}
		return '';
};
var getFilter = function getFilter(filter) {
		switch(filter){
				case FILTER_NEAREST:
						return 9728;
				case FILTER_LINEAR:
						return 9729;
				case FILTER_NEAREST_MIPMAP_NEAREST:
						return 9984;
				case FILTER_LINEAR_MIPMAP_NEAREST:
						return 9985;
				case FILTER_NEAREST_MIPMAP_LINEAR:
						return 9986;
				case FILTER_LINEAR_MIPMAP_LINEAR:
						return 9987;
		}
		return 0;
};
var getWrap = function getWrap(wrap) {
		switch(wrap){
				case ADDRESS_CLAMP_TO_EDGE:
						return 33071;
				case ADDRESS_MIRRORED_REPEAT:
						return 33648;
				case ADDRESS_REPEAT:
						return 10497;
		}
		return 0;
};
function isCanvasTransparent(canvas) {
		var context = canvas.getContext('2d');
		var pixelData = context.getImageData(0, 0, canvas.width, canvas.height).data;
		for(var i = 3; i < pixelData.length; i += 4){
				if (pixelData[i] < 255) {
						return true;
				}
		}
		return false;
}
var textureSemantics = [
		'diffuseMap',
		'colorMap',
		'normalMap',
		'metalnessMap',
		'emissiveMap'
];
class GltfExporter extends CoreExporter {
		collectResources(root) {
				var resources = {
						buffers: [],
						cameras: [],
						entities: [],
						materials: [],
						skins: [],
						textures: [],
						entityMeshInstances: [],
						bufferViewMap: new Map(),
						compressableTexture: new Set()
				};
				var { materials, buffers, entityMeshInstances, textures } = resources;
				root.forEach((entity)=>{
						resources.entities.push(entity);
				});
				var collectMeshInstances = (meshInstances)=>{
						meshInstances.forEach((meshInstance)=>{
								var material = meshInstance.material;
								if (materials.indexOf(material) < 0) {
										resources.materials.push(material);
										textureSemantics.forEach((semantic)=>{
												var texture = material[semantic];
												if (texture && textures.indexOf(texture) < 0) {
														if (semantic !== 'normalMap') {
																resources.compressableTexture.add(texture);
														}
														textures.push(texture);
												}
										});
								}
								var node = meshInstance.node;
								var nodeMeshInstances = entityMeshInstances.find((e)=>e.node === node);
								if (!nodeMeshInstances) {
										nodeMeshInstances = {
												node: node,
												meshInstances: []
										};
										entityMeshInstances.push(nodeMeshInstances);
								}
								nodeMeshInstances.meshInstances.push(meshInstance);
								var mesh = meshInstance.mesh;
								var vertexBuffer = mesh.vertexBuffer;
								if (buffers.indexOf(vertexBuffer) < 0) {
										buffers.unshift(vertexBuffer);
								}
								var indexBuffer = mesh.indexBuffer[0];
								if (buffers.indexOf(indexBuffer) < 0) {
										buffers.push(indexBuffer);
								}
								if (mesh.skin && resources.skins.indexOf(mesh.skin) < 0) {
										resources.skins.push(mesh.skin);
								}
						});
				};
				resources.entities.forEach((entity)=>{
						if (entity.camera) {
								resources.cameras.push(entity.camera);
						}
						if (entity.render && entity.render.enabled) {
								collectMeshInstances(entity.render.meshInstances);
						}
						if (entity.model && entity.model.enabled && entity.model.meshInstances) {
								collectMeshInstances(entity.model.meshInstances);
						}
				});
				return resources;
		}
		writeBufferViews(resources, json) {
				json.bufferViews = [];
				for (var buffer of resources.buffers){
						GltfExporter.writeBufferView(resources, json, buffer);
				}
		}
		static writeBufferView(resources, json, buffer) {
				var _json_buffers;
				json.buffers = (_json_buffers = json.buffers) != null ? _json_buffers : [];
				var _json_buffers_;
				json.buffers[0] = (_json_buffers_ = json.buffers[0]) != null ? _json_buffers_ : {
						byteLength: 0
				};
				var bufferInfo = json.buffers[0];
				bufferInfo.byteLength = math.roundUp(bufferInfo.byteLength, 4);
				var offset = bufferInfo.byteLength;
				var addBufferView = (target, byteLength, byteOffset, byteStride)=>{
						var bufferView = {
								buffer: 0,
								byteLength: byteLength,
								byteOffset: byteOffset
						};
						if (target === ARRAY_BUFFER || target === ELEMENT_ARRAY_BUFFER) {
								bufferView.target = target;
						}
						if (byteStride !== undefined) {
								bufferView.byteStride = byteStride;
						}
						return json.bufferViews.push(bufferView) - 1;
				};
				var arrayBuffer;
				if (buffer instanceof VertexBuffer) {
						arrayBuffer = buffer.lock();
						var format = buffer.getFormat();
						if (format.interleaved) {
								var bufferViewIndex = addBufferView(ARRAY_BUFFER, arrayBuffer.byteLength, offset, format.size);
								resources.bufferViewMap.set(buffer, [
										bufferViewIndex
								]);
						} else {
								var bufferViewIndices = [];
								for (var element of format.elements){
										var bufferViewIndex1 = addBufferView(ARRAY_BUFFER, element.size * format.vertexCount, offset + element.offset, element.size);
										bufferViewIndices.push(bufferViewIndex1);
								}
								resources.bufferViewMap.set(buffer, bufferViewIndices);
						}
				} else if (buffer instanceof IndexBuffer) {
						arrayBuffer = buffer.lock();
						var bufferViewIndex2 = addBufferView(ELEMENT_ARRAY_BUFFER, arrayBuffer.byteLength, offset);
						resources.bufferViewMap.set(buffer, [
								bufferViewIndex2
						]);
				} else {
						arrayBuffer = buffer;
						var bufferViewIndex3 = addBufferView(undefined, arrayBuffer.byteLength, offset);
						resources.bufferViewMap.set(buffer, [
								bufferViewIndex3
						]);
				}
				bufferInfo.byteLength += arrayBuffer.byteLength;
		}
		writeCameras(resources, json) {
				if (resources.cameras.length > 0) {
						json.cameras = resources.cameras.map((cam)=>{
								var projection = cam.projection;
								var nearClip = cam.nearClip;
								var farClip = cam.farClip;
								var camera = {};
								if (projection === PROJECTION_ORTHOGRAPHIC) {
										camera.type = 'orthographic';
										camera.orthographic = {
												xmag: 1,
												ymag: 1,
												znear: nearClip,
												zfar: farClip
										};
								} else {
										var fov = cam.fov;
										camera.type = 'perspective';
										camera.perspective = {
												yfov: fov * Math.PI / 180,
												znear: nearClip,
												zfar: farClip
										};
								}
								return camera;
						});
				}
		}
		attachTexture(resources, material, destination, name, textureSemantic, json) {
				var texture = material[textureSemantic];
				if (texture) {
						var textureIndex = resources.textures.indexOf(texture);
						if (textureIndex < 0) console.warn("Texture " + texture.name + " wasn't collected.");
						destination[name] = {
								index: textureIndex
						};
						var scale = material["" + textureSemantic + "Tiling"];
						var offset = material["" + textureSemantic + "Offset"];
						var rotation = material["" + textureSemantic + "Rotation"];
						if (scale && !scale.equals(Vec2.ONE) || offset && !offset.equals(Vec2.ZERO) || rotation !== 0) {
								destination[name].extensions = {
										KHR_texture_transform: {}
								};
								var _json_extensionsUsed;
								json.extensionsUsed = (_json_extensionsUsed = json.extensionsUsed) != null ? _json_extensionsUsed : [];
								if (json.extensionsUsed.indexOf('KHR_texture_transform') < 0) {
										json.extensionsUsed.push('KHR_texture_transform');
								}
								var _json_extensionsRequired;
								json.extensionsRequired = (_json_extensionsRequired = json.extensionsRequired) != null ? _json_extensionsRequired : [];
								if (json.extensionsRequired.indexOf('KHR_texture_transform') < 0) {
										json.extensionsRequired.push('KHR_texture_transform');
								}
								if (scale && !scale.equals(Vec2.ONE)) {
										destination[name].extensions.KHR_texture_transform.scale = [
												scale.x,
												scale.y
										];
								}
								if (offset && !offset.equals(Vec2.ZERO)) {
										destination[name].extensions.KHR_texture_transform.offset = [
												offset.x,
												offset.y - 1 + scale.y
										];
								}
								if (rotation !== 0) {
										destination[name].extensions.KHR_texture_transform.rotation = rotation * math.DEG_TO_RAD;
								}
						}
				}
		}
		writeStandardMaterial(resources, mat, output, json) {
				var { diffuse, emissive, opacity, metalness, gloss, glossInvert } = mat;
				var pbr = output.pbrMetallicRoughness;
				if (!diffuse.equals(Color.WHITE) || opacity !== 1) {
						pbr.baseColorFactor = [
								diffuse.r,
								diffuse.g,
								diffuse.b,
								opacity
						];
				}
				if (metalness !== 1) {
						pbr.metallicFactor = metalness;
				}
				var roughness = glossInvert ? gloss : 1 - gloss;
				if (roughness !== 1) {
						pbr.roughnessFactor = roughness;
				}
				this.attachTexture(resources, mat, pbr, 'baseColorTexture', 'diffuseMap', json);
				this.attachTexture(resources, mat, pbr, 'metallicRoughnessTexture', 'metalnessMap', json);
				if (!emissive.equals(Color.BLACK)) {
						output.emissiveFactor = [
								emissive.r,
								emissive.g,
								emissive.b
						];
				}
		}
		writeMaterials(resources, json) {
				if (resources.materials.length > 0) {
						json.materials = resources.materials.map((mat)=>{
								var { name, blendType, cull, alphaTest } = mat;
								var material = {
										pbrMetallicRoughness: {}
								};
								if (name && name.length > 0) {
										material.name = name;
								}
								if (mat instanceof StandardMaterial) {
										this.writeStandardMaterial(resources, mat, material, json);
								}
								if (blendType === BLEND_NORMAL) {
										material.alphaMode = 'BLEND';
								} else if (blendType === BLEND_NONE) {
										if (alphaTest !== 0) {
												material.alphaMode = 'MASK';
												material.alphaCutoff = alphaTest;
										}
								}
								if (cull === CULLFACE_NONE) {
										material.doubleSided = true;
								}
								this.attachTexture(resources, mat, material, 'normalTexture', 'normalMap', json);
								this.attachTexture(resources, mat, material, 'occlusionTexture', 'aoMap', json);
								this.attachTexture(resources, mat, material, 'emissiveTexture', 'emissiveMap', json);
								return material;
						});
				}
		}
		writeNodes(resources, json) {
				if (resources.entities.length > 0) {
						json.nodes = resources.entities.map((entity)=>{
								var name = entity.name;
								var t = entity.getLocalPosition();
								var r = entity.getLocalRotation();
								var s = entity.getLocalScale();
								var node = {};
								if (name && name.length > 0) {
										node.name = name;
								}
								if (!t.equals(Vec3.ZERO)) {
										node.translation = [
												t.x,
												t.y,
												t.z
										];
								}
								if (!r.equals(Quat.IDENTITY)) {
										node.rotation = [
												r.x,
												r.y,
												r.z,
												r.w
										];
								}
								if (!s.equals(Vec3.ONE)) {
										node.scale = [
												s.x,
												s.y,
												s.z
										];
								}
								if (entity.camera && entity.camera.enabled) {
										node.camera = resources.cameras.indexOf(entity.camera);
								}
								var entityMeshInstance = resources.entityMeshInstances.find((e)=>e.node === entity);
								if (entityMeshInstance) {
										node.mesh = resources.entityMeshInstances.indexOf(entityMeshInstance);
										var meshInstance = entityMeshInstance.meshInstances[0];
										if (meshInstance && meshInstance.mesh.skin) {
												node.skin = resources.skins.indexOf(meshInstance.mesh.skin);
										}
								}
								if (entity.children.length > 0) {
										node.children = [];
										entity.children.forEach((child)=>{
												node.children.push(resources.entities.indexOf(child));
										});
								}
								return node;
						});
				}
		}
		writeMeshes(resources, json, options) {
				if (resources.entityMeshInstances.length > 0) {
						json.accessors = [];
						json.meshes = [];
						resources.entityMeshInstances.forEach((entityMeshInstances)=>{
								var mesh = {
										primitives: []
								};
								var meshInstances = entityMeshInstances.meshInstances;
								meshInstances.forEach((meshInstance)=>{
										var primitive = GltfExporter.createPrimitive(resources, json, meshInstance.mesh, options);
										primitive.material = resources.materials.indexOf(meshInstance.material);
										mesh.primitives.push(primitive);
								});
								json.meshes.push(mesh);
						});
				}
		}
		static createPrimitive(resources, json, mesh, options) {
				if (options === void 0) options = {};
				var primitive = {
						attributes: {}
				};
				var { vertexBuffer } = mesh;
				var { format } = vertexBuffer;
				var { interleaved, elements } = format;
				var numVertices = vertexBuffer.getNumVertices();
				elements.forEach((element, elementIndex)=>{
						var semantic = getSemantic(element.name);
						if (options.stripUnusedAttributes) {
								var isUsed = true;
								if (semantic.startsWith('TEXCOORD_')) {
										var texCoordIndex = parseInt(semantic.split('_')[1], 10);
										isUsed = resources.materials.some((material)=>{
												return textureSemantics.some((texSemantic)=>{
														var _material_;
														var texture = material[texSemantic];
														return texture && (texCoordIndex === 0 || ((_material_ = material["" + texSemantic + "Tiling"]) == null ? void 0 : _material_.uv) === texCoordIndex);
												});
										});
								}
								if (semantic === 'COLOR_0') {
										isUsed = resources.materials.some((material)=>material.vertexColors);
								}
								if (semantic === 'TANGENT') {
										isUsed = resources.materials.some((material)=>material.normalMap);
								}
								if (semantic === 'JOINTS_0' || semantic === 'WEIGHTS_0') {
										isUsed = resources.entityMeshInstances.some((emi)=>emi.meshInstances.some((mi)=>mi.mesh.skin));
								}
								if (!isUsed) {
										return;
								}
						}
						var bufferView = resources.bufferViewMap.get(vertexBuffer);
						if (!bufferView) {
								GltfExporter.writeBufferView(resources, json, vertexBuffer);
								resources.buffers.push(vertexBuffer);
								bufferView = resources.bufferViewMap.get(vertexBuffer);
						}
						var viewIndex = bufferView[interleaved ? 0 : elementIndex];
						var accessor = {
								bufferView: viewIndex,
								byteOffset: interleaved ? element.offset : 0,
								componentType: getComponentType(element.dataType),
								type: getAccessorType(element.numComponents),
								count: numVertices
						};
						var idx = json.accessors.push(accessor) - 1;
						primitive.attributes[semantic] = idx;
						if (element.name === SEMANTIC_POSITION) {
								var positions = [];
								mesh.getPositions(positions);
								var min = new Vec3();
								var max = new Vec3();
								BoundingBox.computeMinMax(positions, min, max);
								accessor.min = [
										min.x,
										min.y,
										min.z
								];
								accessor.max = [
										max.x,
										max.y,
										max.z
								];
						}
				});
				var indexBuffer = mesh.indexBuffer[0];
				if (indexBuffer) {
						var bufferView = resources.bufferViewMap.get(indexBuffer);
						if (!bufferView) {
								GltfExporter.writeBufferView(resources, json, indexBuffer);
								resources.buffers.push(indexBuffer);
								bufferView = resources.bufferViewMap.get(indexBuffer);
						}
						var viewIndex = bufferView[0];
						var accessor = {
								bufferView: viewIndex,
								componentType: getIndexComponentType(indexBuffer.getFormat()),
								count: indexBuffer.getNumIndices(),
								type: 'SCALAR'
						};
						var idx = json.accessors.push(accessor) - 1;
						primitive.indices = idx;
				}
				return primitive;
		}
		writeSkins(resources, json) {
				if (resources.skins.length > 0) {
						json.skins = resources.skins.map((skin)=>{
								var matrices = new Float32Array(skin.inverseBindPose.length * 16);
								for(var i = 0; i < skin.inverseBindPose.length; i++){
										var ibm = skin.inverseBindPose[i];
										matrices.set(ibm.data, i * 16);
								}
								var matrixBuffer = matrices.buffer;
								GltfExporter.writeBufferView(resources, json, matrixBuffer);
								resources.buffers.push(matrixBuffer);
								var bufferView = resources.bufferViewMap.get(matrixBuffer);
								var accessor = {
										bufferView: bufferView[0],
										componentType: getComponentType(TYPE_FLOAT32),
										count: skin.inverseBindPose.length,
										type: 'MAT4'
								};
								var accessorIndex = json.accessors.push(accessor) - 1;
								var joints = skin.boneNames.map((boneName)=>{
										var node = resources.entities.find((entity)=>entity.name === boneName);
										return resources.entities.indexOf(node);
								});
								return {
										inverseBindMatrices: accessorIndex,
										joints: joints
								};
						});
				}
		}
		convertTextures(srcTextures, options) {
				var textureOptions = {
						maxTextureSize: options.maxTextureSize
				};
				var promises = [];
				srcTextures.forEach((srcTexture)=>{
						var promise = this.textureToCanvas(srcTexture, textureOptions);
						promise.then((canvas)=>{
								return new Promise((resolve)=>resolve(canvas));
						});
						promises.push(promise);
				});
				return promises;
		}
		writeTextures(resources, textureCanvases, json, options) {
				var _this, _loop = function(i) {
						var texture = textures[i];
						var canvas = textureCanvases[i];
						var isRGBA = isCanvasTransparent(canvas) || !resources.compressableTexture.has(texture);
						var mimeType = isRGBA ? 'image/png' : 'image/jpeg';
						promises.push(_this.getBlob(canvas, mimeType).then((blob)=>{
								var reader = new FileReader();
								reader.readAsArrayBuffer(blob);
								return new Promise((resolve)=>{
										reader.onloadend = ()=>{
												resolve(reader);
										};
								});
						}).then((reader)=>{
								var buffer = _this.getPaddedArrayBuffer(reader.result);
								GltfExporter.writeBufferView(resources, json, buffer);
								resources.buffers.push(buffer);
								var bufferView = resources.bufferViewMap.get(buffer);
								json.images[i] = {
										mimeType: mimeType,
										bufferView: bufferView[0]
								};
								json.samplers[i] = {
										minFilter: getFilter(texture.minFilter),
										magFilter: getFilter(texture.magFilter),
										wrapS: getWrap(texture.addressU),
										wrapT: getWrap(texture.addressV)
								};
								json.textures[i] = {
										sampler: i,
										source: i
								};
						}));
				};
				var textures = resources.textures;
				var promises = [];
				for(var i = 0; i < textureCanvases.length; i++)_this = this, _loop(i);
				return Promise.all(promises);
		}
		getBlob(canvas, mimeType) {
				if (canvas.toBlob !== undefined) {
						return new Promise((resolve)=>{
								canvas.toBlob(resolve, mimeType);
						});
				}
				var quality = 1.0;
				if (mimeType === 'image/jpeg') {
						quality = 0.92;
				}
				return canvas.convertToBlob({
						type: mimeType,
						quality: quality
				});
		}
		getPaddedArrayBuffer(arrayBuffer, paddingByte) {
				if (paddingByte === void 0) paddingByte = 0;
				var paddedLength = math.roundUp(arrayBuffer.byteLength, 4);
				if (paddedLength !== arrayBuffer.byteLength) {
						var array = new Uint8Array(paddedLength);
						array.set(new Uint8Array(arrayBuffer));
						if (paddingByte !== 0) {
								for(var i = arrayBuffer.byteLength; i < paddedLength; i++){
										array[i] = paddingByte;
								}
						}
						return array.buffer;
				}
				return arrayBuffer;
		}
		buildJson(resources, options) {
				var promises = this.convertTextures(resources.textures, options);
				var _this = this;
				return Promise.all(promises).then(/*#__PURE__*/ _async_to_generator(function*(textureCanvases) {
						var json = {
								asset: {
										version: '2.0',
										generator: 'PlayCanvas GltfExporter'
								},
								scenes: [
										{
												nodes: [
														0
												]
										}
								],
								images: [],
								samplers: [],
								textures: [],
								scene: 0
						};
						_this.writeBufferViews(resources, json);
						_this.writeCameras(resources, json);
						_this.writeMeshes(resources, json, options);
						_this.writeMaterials(resources, json);
						_this.writeNodes(resources, json, options);
						_this.writeSkins(resources, json);
						yield _this.writeTextures(resources, textureCanvases, json, options);
						if (!json.images.length) delete json.images;
						if (!json.samplers.length) delete json.samplers;
						if (!json.textures.length) delete json.textures;
						return json;
				}));
		}
		build(entity, options) {
				if (options === void 0) options = {};
				var resources = this.collectResources(entity);
				return this.buildJson(resources, options).then((json)=>{
						var encoder = new TextEncoder();
						var jsonData = encoder.encode(JSON.stringify(json));
						var headerLength = 12;
						var jsonHeaderLength = 8;
						var jsonDataLength = jsonData.length;
						var jsonPaddingLength = 4 - (jsonDataLength & 3) & 3;
						var binaryHeaderLength = 8;
						var binaryDataLength = json.buffers.reduce((total, buffer)=>math.roundUp(total + buffer.byteLength, 4), 0);
						var totalLength = headerLength + jsonHeaderLength + jsonDataLength + jsonPaddingLength;
						if (binaryDataLength > 0) {
								totalLength += binaryHeaderLength + binaryDataLength;
						}
						var glbBuffer = new ArrayBuffer(totalLength);
						var glbView = new DataView(glbBuffer);
						glbView.setUint32(0, 0x46546C67, true);
						glbView.setUint32(4, 2, true);
						glbView.setUint32(8, totalLength, true);
						glbView.setUint32(12, jsonDataLength + jsonPaddingLength, true);
						glbView.setUint32(16, 0x4E4F534A, true);
						var offset = headerLength + jsonHeaderLength;
						new Uint8Array(glbBuffer, offset, jsonDataLength).set(jsonData);
						offset += jsonDataLength;
						for(var i = 0; i < jsonPaddingLength; i++){
								glbView.setUint8(offset + i, 0x20);
						}
						offset += jsonPaddingLength;
						if (binaryDataLength > 0) {
								glbView.setUint32(offset, binaryDataLength, true);
								glbView.setUint32(offset + 4, 0x004E4942, true);
								offset += binaryHeaderLength;
								resources.buffers.forEach((buffer)=>{
										var src;
										var bufferViewId = resources.bufferViewMap.get(buffer)[0];
										var bufferOffset = json.bufferViews[bufferViewId].byteOffset;
										if (buffer instanceof ArrayBuffer) {
												src = new Uint8Array(buffer);
										} else {
												var srcBuffer = buffer.lock();
												if (srcBuffer instanceof ArrayBuffer) {
														src = new Uint8Array(srcBuffer);
												} else {
														src = new Uint8Array(srcBuffer.buffer, srcBuffer.byteOffset, srcBuffer.byteLength);
												}
										}
										var dst = new Uint8Array(glbBuffer, offset + bufferOffset, src.byteLength);
										dst.set(src);
								});
						}
						return Promise.resolve(glbBuffer);
				});
		}
}

var SSAOTYPE_NONE = 'none';
var SSAOTYPE_LIGHTING = 'lighting';
var SSAOTYPE_COMBINE = 'combine';

class RenderPassDownsample extends RenderPassShaderQuad {
		setSourceTexture(value) {
				this._sourceTexture = value;
				this.options.resizeSource = value;
		}
		execute() {
				this.sourceTextureId.setValue(this.sourceTexture);
				if (this.premultiplyTexture) {
						this.premultiplyTextureId.setValue(this.premultiplyTexture);
				}
				this.sourceInvResolutionValue[0] = 1.0 / this.sourceTexture.width;
				this.sourceInvResolutionValue[1] = 1.0 / this.sourceTexture.height;
				this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
				super.execute();
		}
		constructor(device, sourceTexture, options = {}){
				super(device);
				this.sourceTexture = sourceTexture;
				this.premultiplyTexture = options.premultiplyTexture;
				var _options_boxFilter;
				var boxFilter = (_options_boxFilter = options.boxFilter) != null ? _options_boxFilter : false;
				var _options_premultiplySrcChannel;
				var key = (boxFilter ? 'Box' : '') + "-" + (options.premultiplyTexture ? 'Premultiply' : '') + "-" + ((_options_premultiplySrcChannel = options.premultiplySrcChannel) != null ? _options_premultiplySrcChannel : '') + "}";
				this.shader = this.createQuadShader("DownSampleShader:" + key, "\n			" + (boxFilter ? '#define BOXFILTER' : '') + "\n			" + (options.premultiplyTexture ? '#define PREMULTIPLY' : '') + "\n			uniform sampler2D sourceTexture;\n			uniform vec2 sourceInvResolution;\n			varying vec2 uv0;\n			#ifdef PREMULTIPLY\n				uniform sampler2D premultiplyTexture;\n			#endif\n			void main()\n			{\n				vec3 e = texture2D (sourceTexture, vec2 (uv0.x, uv0.y)).rgb;\n				#ifdef BOXFILTER\n					vec3 value = e;\n					#ifdef PREMULTIPLY\n						float premultiply = texture2D(premultiplyTexture, vec2 (uv0.x, uv0.y))." + options.premultiplySrcChannel + ";\n						value *= vec3(premultiply);\n					#endif\n				#else\n					float x = sourceInvResolution.x;\n					float y = sourceInvResolution.y;\n					vec3 a = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y + 2.0 * y)).rgb;\n					vec3 b = texture2D(sourceTexture, vec2 (uv0.x,		   uv0.y + 2.0 * y)).rgb;\n					vec3 c = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y + 2.0 * y)).rgb;\n					vec3 d = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y)).rgb;\n					vec3 f = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y)).rgb;\n					vec3 g = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y - 2.0 * y)).rgb;\n					vec3 h = texture2D(sourceTexture, vec2 (uv0.x,		   uv0.y - 2.0 * y)).rgb;\n					vec3 i = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y - 2.0 * y)).rgb;\n					vec3 j = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n					vec3 k = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n					vec3 l = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n					vec3 m = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n					vec3 value = e * 0.125;\n					value += (a + c + g + i) * 0.03125;\n					value += (b + d + f + h) * 0.0625;\n					value += (j + k + l + m) * 0.125;\n				#endif\n				gl_FragColor = vec4(value, 1.0);\n			}");
				this.sourceTextureId = device.scope.resolve('sourceTexture');
				this.premultiplyTextureId = device.scope.resolve('premultiplyTexture');
				this.sourceInvResolutionId = device.scope.resolve('sourceInvResolution');
				this.sourceInvResolutionValue = new Float32Array(2);
		}
}

class RenderPassUpsample extends RenderPassShaderQuad {
		execute() {
				this.sourceTextureId.setValue(this.sourceTexture);
				this.sourceInvResolutionValue[0] = 1.0 / this.sourceTexture.width;
				this.sourceInvResolutionValue[1] = 1.0 / this.sourceTexture.height;
				this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
				super.execute();
		}
		constructor(device, sourceTexture){
				super(device);
				this.sourceTexture = sourceTexture;
				this.shader = this.createQuadShader('UpSampleShader', "\n			uniform sampler2D sourceTexture;\n			uniform vec2 sourceInvResolution;\n			varying vec2 uv0;\n			void main()\n			{\n				float x = sourceInvResolution.x;\n				float y = sourceInvResolution.y;\n				vec3 a = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n				vec3 b = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y + y)).rgb;\n				vec3 c = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n				vec3 d = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y)).rgb;\n				vec3 e = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y)).rgb;\n				vec3 f = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y)).rgb;\n				vec3 g = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n				vec3 h = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y - y)).rgb;\n				vec3 i = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n				vec3 value = e * 4.0;\n				value += (b + d + f + h) * 2.0;\n				value += (a + c + g + i);\n				value *= 1.0 / 16.0;\n				gl_FragColor = vec4(value, 1.0);\n			}");
				this.sourceTextureId = device.scope.resolve('sourceTexture');
				this.sourceInvResolutionId = device.scope.resolve('sourceInvResolution');
				this.sourceInvResolutionValue = new Float32Array(2);
		}
}

class RenderPassBloom extends RenderPass {
		destroy() {
				this.destroyRenderPasses();
				this.destroyRenderTargets();
		}
		destroyRenderTargets(startIndex) {
				if (startIndex === void 0) startIndex = 0;
				for(var i = startIndex; i < this.renderTargets.length; i++){
						var rt = this.renderTargets[i];
						rt.destroyTextureBuffers();
						rt.destroy();
				}
				this.renderTargets.length = 0;
		}
		destroyRenderPasses() {
				for(var i = 0; i < this.beforePasses.length; i++){
						this.beforePasses[i].destroy();
				}
				this.beforePasses.length = 0;
		}
		createRenderTarget(index) {
				return new RenderTarget({
						depth: false,
						colorBuffer: new Texture(this.device, {
								name: "BloomTexture" + index,
								width: 1,
								height: 1,
								format: this.textureFormat,
								mipmaps: false,
								minFilter: FILTER_LINEAR,
								magFilter: FILTER_LINEAR,
								addressU: ADDRESS_CLAMP_TO_EDGE,
								addressV: ADDRESS_CLAMP_TO_EDGE
						})
				});
		}
		createRenderTargets(count) {
				for(var i = 0; i < count; i++){
						var rt = i === 0 ? this.bloomRenderTarget : this.createRenderTarget(i);
						this.renderTargets.push(rt);
				}
		}
		calcMipLevels(width, height, minSize) {
				var min = Math.min(width, height);
				return Math.floor(Math.log2(min) - Math.log2(minSize));
		}
		createRenderPasses(numPasses) {
				var device = this.device;
				var passSourceTexture = this._sourceTexture;
				for(var i = 0; i < numPasses; i++){
						var pass = new RenderPassDownsample(device, passSourceTexture);
						var rt = this.renderTargets[i];
						pass.init(rt, {
								resizeSource: passSourceTexture,
								scaleX: 0.5,
								scaleY: 0.5
						});
						pass.setClearColor(Color.BLACK);
						this.beforePasses.push(pass);
						passSourceTexture = rt.colorBuffer;
				}
				passSourceTexture = this.renderTargets[numPasses - 1].colorBuffer;
				for(var i1 = numPasses - 2; i1 >= 0; i1--){
						var pass1 = new RenderPassUpsample(device, passSourceTexture);
						var rt1 = this.renderTargets[i1];
						pass1.init(rt1);
						pass1.blendState = BlendState.ADDBLEND;
						this.beforePasses.push(pass1);
						passSourceTexture = rt1.colorBuffer;
				}
		}
		onDisable() {
				var _this_renderTargets_;
				(_this_renderTargets_ = this.renderTargets[0]) == null ? void 0 : _this_renderTargets_.resize(1, 1);
				this.destroyRenderPasses();
				this.destroyRenderTargets(1);
		}
		frameUpdate() {
				super.frameUpdate();
				var maxNumPasses = this.calcMipLevels(this._sourceTexture.width, this._sourceTexture.height, 1);
				var numPasses = math.clamp(maxNumPasses, 1, this.blurLevel);
				if (this.renderTargets.length !== numPasses) {
						this.destroyRenderPasses();
						this.destroyRenderTargets(1);
						this.createRenderTargets(numPasses);
						this.createRenderPasses(numPasses);
				}
		}
		constructor(device, sourceTexture, format){
				super(device), this.blurLevel = 16, this.renderTargets = [];
				this._sourceTexture = sourceTexture;
				this.textureFormat = format;
				this.bloomRenderTarget = this.createRenderTarget(0);
				this.bloomTexture = this.bloomRenderTarget.colorBuffer;
		}
}

var fragmentShader = '\n	#include "tonemappingPS"\n	#include "gammaPS"\n	varying vec2 uv0;\n	uniform sampler2D sceneTexture;\n	uniform vec2 sceneTextureInvRes;\n	#ifdef BLOOM\n		uniform sampler2D bloomTexture;\n		uniform float bloomIntensity;\n	#endif\n	#ifdef DOF\n		uniform sampler2D cocTexture;\n		uniform sampler2D blurTexture;\n		vec3 dofBlur(vec2 uv, out vec2 coc) {\n			coc = texture2DLod(cocTexture, uv, 0.0).rg;\n			#if DOF_UPSCALE\n				vec2 blurTexelSize = 1.0 / vec2(textureSize(blurTexture, 0));\n				vec3 bilinearBlur = vec3(0.0);\n				float totalWeight = 0.0;\n				for (int i = -1; i <= 1; i++) {\n					for (int j = -1; j <= 1; j++) {\n						vec2 offset = vec2(i, j) * blurTexelSize;\n						vec2 cocSample = texture2DLod(cocTexture, uv + offset, 0.0).rg;\n						vec3 blurSample = texture2DLod(blurTexture, uv + offset, 0.0).rgb;\n						float cocWeight = clamp(cocSample.r + cocSample.g, 0.0, 1.0);\n						bilinearBlur += blurSample * cocWeight;\n						totalWeight += cocWeight;\n					}\n				}\n				if (totalWeight > 0.0) {\n					bilinearBlur /= totalWeight;\n				}\n				return bilinearBlur;\n			#else\n				return texture2DLod(blurTexture, uv, 0.0).rgb;\n			#endif\n		}\n	#endif\n	#ifdef SSAO\n		#define SSAO_TEXTURE\n	#endif\n	#if DEBUG_COMPOSE == ssao\n		#define SSAO_TEXTURE\n	#endif\n	#ifdef SSAO_TEXTURE\n		uniform sampler2D ssaoTexture;\n	#endif\n	#ifdef GRADING\n		uniform vec3 brightnessContrastSaturation;\n		uniform vec3 tint;\n		vec3 colorGradingHDR(vec3 color, float brt, float sat, float con)\n		{\n			color *= tint;\n			color = color * brt;\n			float grey = dot(color, vec3(0.3, 0.59, 0.11));\n			grey = grey / max(1.0, max(color.r, max(color.g, color.b)));\n			color = mix(vec3(grey), color, sat);\n			return mix(vec3(0.5), color, con);\n		}\n	\n	#endif\n	#ifdef VIGNETTE\n		uniform vec4 vignetterParams;\n		float vignette(vec2 uv) {\n			float inner = vignetterParams.x;\n			float outer = vignetterParams.y;\n			float curvature = vignetterParams.z;\n			float intensity = vignetterParams.w;\n			vec2 curve = pow(abs(uv * 2.0 -1.0), vec2(1.0 / curvature));\n			float edge = pow(length(curve), curvature);\n			return 1.0 - intensity * smoothstep(inner, outer, edge);\n		}		\n	#endif\n	#ifdef FRINGING\n		uniform float fringingIntensity;\n		vec3 fringing(vec2 uv, vec3 color) {\n			vec2 centerDistance = uv - 0.5;\n			vec2 offset = fringingIntensity * pow(centerDistance, vec2(2.0, 2.0));\n			color.r = texture2D(sceneTexture, uv - offset).r;\n			color.b = texture2D(sceneTexture, uv + offset).b;\n			return color;\n		}\n	#endif\n	#ifdef CAS\n		uniform float sharpness;\n		float maxComponent(float x, float y, float z) { return max(x, max(y, z)); }\n		vec3 toSDR(vec3 c) { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }\n		vec3 toHDR(vec3 c) { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }\n		vec3 cas(vec3 color, vec2 uv, float sharpness) {\n			float x = sceneTextureInvRes.x;\n			float y = sceneTextureInvRes.y;\n			vec3 a = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, -y), 0.0).rgb);\n			vec3 b = toSDR(texture2DLod(sceneTexture, uv + vec2(-x, 0.0), 0.0).rgb);\n			vec3 c = toSDR(color.rgb);\n			vec3 d = toSDR(texture2DLod(sceneTexture, uv + vec2(x, 0.0), 0.0).rgb);\n			vec3 e = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, y), 0.0).rgb);\n			float min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));\n			float max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));\n			float sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);\n			float w = sharpening_amount * sharpness;\n			vec3 res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);\n			res = max(res, 0.0);\n			return toHDR(res);\n		}\n	#endif\n	void main() {\n		vec2 uv = uv0;\n		#ifdef TAA\n		#ifdef WEBGPU\n			uv.y = 1.0 - uv.y;\n		#endif\n		#endif\n		vec4 scene = texture2DLod(sceneTexture, uv, 0.0);\n		vec3 result = scene.rgb;\n		#ifdef CAS\n			result = cas(result, uv, sharpness);\n		#endif\n		#ifdef DOF\n			vec2 coc;\n			vec3 blur = dofBlur(uv0, coc);\n			result = mix(result, blur, coc.r + coc.g);\n		#endif\n		#ifdef SSAO_TEXTURE\n			mediump float ssao = texture2DLod(ssaoTexture, uv0, 0.0).r;\n		#endif\n		#ifdef SSAO\n			result *= ssao;\n		#endif\n		#ifdef FRINGING\n			result = fringing(uv, result);\n		#endif\n		#ifdef BLOOM\n			vec3 bloom = texture2DLod(bloomTexture, uv0, 0.0).rgb;\n			result += bloom * bloomIntensity;\n		#endif\n		#ifdef GRADING\n			result = colorGradingHDR(result, brightnessContrastSaturation.x, brightnessContrastSaturation.z, brightnessContrastSaturation.y);\n		#endif\n		result = toneMap(result);\n		#ifdef VIGNETTE\n			mediump float vig = vignette(uv);\n			result *= vig;\n		#endif\n		#ifdef DEBUG_COMPOSE\n			#ifdef BLOOM\n				#if DEBUG_COMPOSE == bloom\n					result = bloom * bloomIntensity;\n				#endif\n			#endif\n			#ifdef DOF\n				#ifdef DEBUG_COMPOSE == dofcoc\n					result = vec3(coc, 0.0);\n				#endif\n				#ifdef DEBUG_COMPOSE == dofblur\n					result = blur;\n				#endif\n			#endif\n			#if DEBUG_COMPOSE == ssao\n				result = vec3(ssao);\n			#endif\n			#if DEBUG_COMPOSE == vignette\n				result = vec3(vig);\n			#endif\n			#if DEBUG_COMPOSE == scene\n				result = scene.rgb;\n			#endif\n		#endif\n		result = gammaCorrectOutput(result);\n		gl_FragColor = vec4(result, scene.a);\n	}\n';
class RenderPassCompose extends RenderPassShaderQuad {
		set debug(value) {
				if (this._debug !== value) {
						this._debug = value;
						this._shaderDirty = true;
				}
		}
		get debug() {
				return this._debug;
		}
		set bloomTexture(value) {
				if (this._bloomTexture !== value) {
						this._bloomTexture = value;
						this._shaderDirty = true;
				}
		}
		get bloomTexture() {
				return this._bloomTexture;
		}
		set cocTexture(value) {
				if (this._cocTexture !== value) {
						this._cocTexture = value;
						this._shaderDirty = true;
				}
		}
		get cocTexture() {
				return this._cocTexture;
		}
		set ssaoTexture(value) {
				if (this._ssaoTexture !== value) {
						this._ssaoTexture = value;
						this._shaderDirty = true;
				}
		}
		get ssaoTexture() {
				return this._ssaoTexture;
		}
		set taaEnabled(value) {
				if (this._taaEnabled !== value) {
						this._taaEnabled = value;
						this._shaderDirty = true;
				}
		}
		get taaEnabled() {
				return this._taaEnabled;
		}
		set gradingEnabled(value) {
				if (this._gradingEnabled !== value) {
						this._gradingEnabled = value;
						this._shaderDirty = true;
				}
		}
		get gradingEnabled() {
				return this._gradingEnabled;
		}
		set vignetteEnabled(value) {
				if (this._vignetteEnabled !== value) {
						this._vignetteEnabled = value;
						this._shaderDirty = true;
				}
		}
		get vignetteEnabled() {
				return this._vignetteEnabled;
		}
		set fringingEnabled(value) {
				if (this._fringingEnabled !== value) {
						this._fringingEnabled = value;
						this._shaderDirty = true;
				}
		}
		get fringingEnabled() {
				return this._fringingEnabled;
		}
		set toneMapping(value) {
				if (this._toneMapping !== value) {
						this._toneMapping = value;
						this._shaderDirty = true;
				}
		}
		get toneMapping() {
				return this._toneMapping;
		}
		set sharpness(value) {
				if (this._sharpness !== value) {
						this._sharpness = value;
						this._shaderDirty = true;
				}
		}
		get sharpness() {
				return this._sharpness;
		}
		get isSharpnessEnabled() {
				return this._sharpness > 0;
		}
		postInit() {
				this.setClearColor(Color.BLACK);
				this.setClearDepth(1.0);
				this.setClearStencil(0);
		}
		frameUpdate() {
				var _this_renderTarget;
				var rt = (_this_renderTarget = this.renderTarget) != null ? _this_renderTarget : this.device.backBuffer;
				var srgb = rt.isColorBufferSrgb(0);
				var neededGammaCorrection = srgb ? GAMMA_NONE : GAMMA_SRGB;
				if (this._gammaCorrection !== neededGammaCorrection) {
						this._gammaCorrection = neededGammaCorrection;
						this._shaderDirty = true;
				}
				if (this._shaderDirty) {
						this._shaderDirty = false;
						var gammaCorrectionName = gammaNames[this._gammaCorrection];
						var _this__debug;
						var key = "" + this.toneMapping + ("-" + gammaCorrectionName) + ("-" + (this.bloomTexture ? 'bloom' : 'nobloom')) + ("-" + (this.cocTexture ? 'dof' : 'nodof')) + ("-" + (this.blurTextureUpscale ? 'dofupscale' : '')) + ("-" + (this.ssaoTexture ? 'ssao' : 'nossao')) + ("-" + (this.gradingEnabled ? 'grading' : 'nograding')) + ("-" + (this.vignetteEnabled ? 'vignette' : 'novignette')) + ("-" + (this.fringingEnabled ? 'fringing' : 'nofringing')) + ("-" + (this.taaEnabled ? 'taa' : 'notaa')) + ("-" + (this.isSharpnessEnabled ? 'cas' : 'nocas')) + ("-" + ((_this__debug = this._debug) != null ? _this__debug : ''));
						if (this._key !== key) {
								this._key = key;
								var defines = new Map();
								defines.set('TONEMAP', tonemapNames[this.toneMapping]);
								defines.set('GAMMA', gammaCorrectionName);
								if (this.bloomTexture) defines.set('BLOOM', true);
								if (this.cocTexture) defines.set('DOF', true);
								if (this.blurTextureUpscale) defines.set('DOF_UPSCALE', true);
								if (this.ssaoTexture) defines.set('SSAO', true);
								if (this.gradingEnabled) defines.set('GRADING', true);
								if (this.vignetteEnabled) defines.set('VIGNETTE', true);
								if (this.fringingEnabled) defines.set('FRINGING', true);
								if (this.taaEnabled) defines.set('TAA', true);
								if (this.isSharpnessEnabled) defines.set('CAS', true);
								if (this._debug) defines.set('DEBUG_COMPOSE', this._debug);
								var includes = new Map(Object.entries(shaderChunks));
								this.shader = this.createQuadShader("ComposeShader-" + key, fragmentShader, {
										fragmentIncludes: includes,
										fragmentDefines: defines
								});
						}
				}
		}
		execute() {
				this.sceneTextureId.setValue(this.sceneTexture);
				this.sceneTextureInvResValue[0] = 1.0 / this.sceneTexture.width;
				this.sceneTextureInvResValue[1] = 1.0 / this.sceneTexture.height;
				this.sceneTextureInvResId.setValue(this.sceneTextureInvResValue);
				if (this._bloomTexture) {
						this.bloomTextureId.setValue(this._bloomTexture);
						this.bloomIntensityId.setValue(this.bloomIntensity);
				}
				if (this._cocTexture) {
						this.cocTextureId.setValue(this._cocTexture);
						this.blurTextureId.setValue(this.blurTexture);
				}
				if (this._ssaoTexture) {
						this.ssaoTextureId.setValue(this._ssaoTexture);
				}
				if (this._gradingEnabled) {
						this.bcsId.setValue([
								this.gradingBrightness,
								this.gradingContrast,
								this.gradingSaturation
						]);
						this.tintId.setValue([
								this.gradingTint.r,
								this.gradingTint.g,
								this.gradingTint.b
						]);
				}
				if (this._vignetteEnabled) {
						this.vignetterParamsId.setValue([
								this.vignetteInner,
								this.vignetteOuter,
								this.vignetteCurvature,
								this.vignetteIntensity
						]);
				}
				if (this._fringingEnabled) {
						this.fringingIntensityId.setValue(this.fringingIntensity / 1024);
				}
				if (this.isSharpnessEnabled) {
						this.sharpnessId.setValue(math.lerp(-0.125, -0.2, this.sharpness));
				}
				super.execute();
		}
		constructor(graphicsDevice){
				super(graphicsDevice), this.sceneTexture = null, this.bloomIntensity = 0.01, this._bloomTexture = null, this._cocTexture = null, this.blurTexture = null, this.blurTextureUpscale = false, this._ssaoTexture = null, this._toneMapping = TONEMAP_LINEAR, this._gradingEnabled = false, this.gradingSaturation = 1, this.gradingContrast = 1, this.gradingBrightness = 1, this.gradingTint = new Color(1, 1, 1, 1), this._shaderDirty = true, this._vignetteEnabled = false, this.vignetteInner = 0.5, this.vignetteOuter = 1.0, this.vignetteCurvature = 0.5, this.vignetteIntensity = 0.3, this._fringingEnabled = false, this.fringingIntensity = 10, this._taaEnabled = false, this._sharpness = 0.5, this._gammaCorrection = GAMMA_SRGB, this._key = '', this._debug = null;
				var { scope } = graphicsDevice;
				this.sceneTextureId = scope.resolve('sceneTexture');
				this.bloomTextureId = scope.resolve('bloomTexture');
				this.cocTextureId = scope.resolve('cocTexture');
				this.ssaoTextureId = scope.resolve('ssaoTexture');
				this.blurTextureId = scope.resolve('blurTexture');
				this.bloomIntensityId = scope.resolve('bloomIntensity');
				this.bcsId = scope.resolve('brightnessContrastSaturation');
				this.tintId = scope.resolve('tint');
				this.vignetterParamsId = scope.resolve('vignetterParams');
				this.fringingIntensityId = scope.resolve('fringingIntensity');
				this.sceneTextureInvResId = scope.resolve('sceneTextureInvRes');
				this.sceneTextureInvResValue = new Float32Array(2);
				this.sharpnessId = scope.resolve('sharpness');
		}
}

var fs$1 = "\n	uniform sampler2D sourceTexture;\n	uniform sampler2D historyTexture;\n	uniform mat4 matrix_viewProjectionPrevious;\n	uniform mat4 matrix_viewProjectionInverse;\n	uniform vec4 jitters;\n	uniform vec2 textureSize;\n	varying vec2 uv0;\n	vec2 reproject(vec2 uv, float depth) {\n		#ifndef WEBGPU\n			depth = depth * 2.0 - 1.0;\n		#endif\n		vec4 ndc = vec4(uv * 2.0 - 1.0, depth, 1.0);\n		ndc.xy -= jitters.xy;\n		vec4 worldPosition = matrix_viewProjectionInverse * ndc;\n		worldPosition /= worldPosition.w;\n	\n		vec4 screenPrevious = matrix_viewProjectionPrevious * worldPosition;\n		return (screenPrevious.xy / screenPrevious.w) * 0.5 + 0.5;\n	}\n	vec4 colorClamp(vec2 uv, vec4 historyColor) {\n		vec3 minColor = vec3(9999.0);\n		vec3 maxColor = vec3(-9999.0);\n \n		for(float x = -1.0; x <= 1.0; ++x)\n		{\n			for(float y = -1.0; y <= 1.0; ++y)\n			{\n				vec3 color = texture2D(sourceTexture, uv + vec2(x, y) / textureSize).rgb;\n				minColor = min(minColor, color);\n				maxColor = max(maxColor, color);\n			}\n		}\n \n		vec3 clamped = clamp(historyColor.rgb, minColor, maxColor);\n		return vec4(clamped, historyColor.a);\n	}\n	void main()\n	{\n		vec2 uv = uv0;\n		#ifdef WEBGPU\n			uv.y = 1.0 - uv.y;\n		#endif\n		vec4 srcColor = texture2D(sourceTexture, uv);\n		float linearDepth = getLinearScreenDepth(uv0);\n		float depth = delinearizeDepth(linearDepth);\n		vec2 historyUv = reproject(uv0, depth);\n		#ifdef QUALITY_HIGH\n			vec4 historyColor = SampleTextureCatmullRom(TEXTURE_PASS(historyTexture), historyUv, textureSize);\n		#else\n			vec4 historyColor = texture2D(historyTexture, historyUv);\n		#endif\n		vec4 historyColorClamped = colorClamp(uv, historyColor);\n		float mixFactor = (historyUv.x < 0.0 || historyUv.x > 1.0 || historyUv.y < 0.0 || historyUv.y > 1.0) ?\n			1.0 : 0.05;\n		gl_FragColor = mix(historyColorClamped, srcColor, mixFactor);\n	}\n";
class RenderPassTAA extends RenderPassShaderQuad {
		destroy() {
				if (this.renderTarget) {
						this.renderTarget.destroyTextureBuffers();
						this.renderTarget.destroy();
						this.renderTarget = null;
				}
		}
		setup() {
				for(var i = 0; i < 2; ++i){
						this.historyTextures[i] = new Texture(this.device, {
								name: "TAA-History-" + i,
								width: 4,
								height: 4,
								format: this.sourceTexture.format,
								mipmaps: false,
								minFilter: FILTER_LINEAR,
								magFilter: FILTER_LINEAR,
								addressU: ADDRESS_CLAMP_TO_EDGE,
								addressV: ADDRESS_CLAMP_TO_EDGE
						});
						this.historyRenderTargets[i] = new RenderTarget({
								colorBuffer: this.historyTextures[i],
								depth: false
						});
				}
				this.historyTexture = this.historyTextures[0];
				this.init(this.historyRenderTargets[0], {
						resizeSource: this.sourceTexture
				});
		}
		before() {
				this.sourceTextureId.setValue(this.sourceTexture);
				this.historyTextureId.setValue(this.historyTextures[1 - this.historyIndex]);
				this.textureSize[0] = this.sourceTexture.width;
				this.textureSize[1] = this.sourceTexture.height;
				this.textureSizeId.setValue(this.textureSize);
				var camera = this.cameraComponent.camera;
				this.viewProjPrevId.setValue(camera._viewProjPrevious.data);
				this.viewProjInvId.setValue(camera._viewProjInverse.data);
				this.jittersId.setValue(camera._jitters);
				var f = camera._farClip;
				this.cameraParams[0] = 1 / f;
				this.cameraParams[1] = f;
				this.cameraParams[2] = camera._nearClip;
				this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
				this.cameraParamsId.setValue(this.cameraParams);
		}
		update() {
				this.historyIndex = 1 - this.historyIndex;
				this.historyTexture = this.historyTextures[this.historyIndex];
				this.renderTarget = this.historyRenderTargets[this.historyIndex];
				return this.historyTexture;
		}
		constructor(device, sourceTexture, cameraComponent){
				super(device), this.historyIndex = 0, this.historyTexture = null, this.historyTextures = [], this.historyRenderTargets = [];
				this.sourceTexture = sourceTexture;
				this.cameraComponent = cameraComponent;
				var defines = "\n			#define QUALITY_HIGH\n		";
				var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
				var fsChunks = shaderChunks.sampleCatmullRomPS + screenDepth;
				this.shader = this.createQuadShader('TaaResolveShader', defines + fsChunks + fs$1);
				var { scope } = device;
				this.sourceTextureId = scope.resolve('sourceTexture');
				this.textureSizeId = scope.resolve('textureSize');
				this.textureSize = new Float32Array(2);
				this.historyTextureId = scope.resolve('historyTexture');
				this.viewProjPrevId = scope.resolve('matrix_viewProjectionPrevious');
				this.viewProjInvId = scope.resolve('matrix_viewProjectionInverse');
				this.jittersId = scope.resolve('jitters');
				this.cameraParams = new Float32Array(4);
				this.cameraParamsId = scope.resolve('camera_params');
				this.setup();
		}
}

class RenderPassCoC extends RenderPassShaderQuad {
		execute() {
				var { paramsValue, focusRange } = this;
				paramsValue[0] = this.focusDistance + 0.001;
				paramsValue[1] = focusRange;
				paramsValue[2] = 1 / focusRange;
				this.paramsId.setValue(paramsValue);
				var camera = this.cameraComponent.camera;
				var f = camera._farClip;
				this.cameraParams[0] = 1 / f;
				this.cameraParams[1] = f;
				this.cameraParams[2] = camera._nearClip;
				this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
				this.cameraParamsId.setValue(this.cameraParams);
				super.execute();
		}
		constructor(device, cameraComponent, nearBlur){
				super(device);
				this.cameraComponent = cameraComponent;
				var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
				this.shader = this.createQuadShader("CocShader-" + nearBlur, "\n			" + (nearBlur ? '#define NEAR_BLUR' : '') + "\n			" + screenDepth + "\n			varying vec2 uv0;\n			uniform vec3 params;\n			void main()\n			{\n				float depth = getLinearScreenDepth(uv0);\n				float focusDistance = params.x;\n				float focusRange = params.y;\n				float invRange = params.z;\n				float farRange = focusDistance + focusRange * 0.5;\n				\n				float cocFar = min((depth - farRange) * invRange, 1.0);\n				#ifdef NEAR_BLUR\n					float nearRange = focusDistance - focusRange * 0.5;\n					float cocNear = min((nearRange - depth) * invRange, 1.0);\n				#else\n					float cocNear = 0.0;\n				#endif\n				gl_FragColor = vec4(cocFar, cocNear, 0.0, 0.0);\n			}");
				this.paramsId = device.scope.resolve('params');
				this.paramsValue = new Float32Array(3);
				this.cameraParams = new Float32Array(4);
				this.cameraParamsId = device.scope.resolve('camera_params');
		}
}

class RenderPassDofBlur extends RenderPassShaderQuad {
		set blurRings(value) {
				if (this._blurRings !== value) {
						this._blurRings = value;
						this.shader = null;
				}
		}
		get blurRings() {
				return this._blurRings;
		}
		set blurRingPoints(value) {
				if (this._blurRingPoints !== value) {
						this._blurRingPoints = value;
						this.shader = null;
				}
		}
		get blurRingPoints() {
				return this._blurRingPoints;
		}
		createShader() {
				this.kernel = new Float32Array(Kernel.concentric(this.blurRings, this.blurRingPoints));
				var kernelCount = this.kernel.length >> 1;
				var nearBlur = this.nearTexture !== null;
				var shaderName = "DofBlurShader-" + kernelCount + "-" + (nearBlur ? 'nearBlur' : 'noNearBlur');
				this.shader = this.createQuadShader(shaderName, "\n			" + (nearBlur ? '#define NEAR_BLUR' : '') + "\n			#if defined(NEAR_BLUR)\n				uniform sampler2D nearTexture;\n			#endif\n			uniform sampler2D farTexture;\n			uniform sampler2D cocTexture;\n			uniform float blurRadiusNear;\n			uniform float blurRadiusFar;\n			uniform vec2 kernel[" + kernelCount + "];\n			varying vec2 uv0;\n			void main()\n			{\n				vec2 coc = texture2D(cocTexture, uv0).rg;\n				float cocFar = coc.r;\n				vec3 sum = vec3(0.0, 0.0, 0.0);\n				#if defined(NEAR_BLUR)\n					float cocNear = coc.g;\n					if (cocNear > 0.0001) {\n						ivec2 nearTextureSize = textureSize(nearTexture, 0);\n						vec2 step = cocNear * blurRadiusNear / vec2(nearTextureSize);\n						for (int i = 0; i < " + kernelCount + "; i++) {\n							vec2 uv = uv0 + step * kernel[i];\n							vec3 tap = texture2DLod(nearTexture, uv, 0.0).rgb;\n							sum += tap.rgb;\n						}\n						sum *= " + 1.0 / kernelCount + ";\n					} else\n				#endif\n					\n					if (cocFar > 0.0001) {\n					ivec2 farTextureSize = textureSize(farTexture, 0);\n					vec2 step = cocFar * blurRadiusFar / vec2(farTextureSize);\n					float sumCoC = 0.0; \n					for (int i = 0; i < " + kernelCount + "; i++) {\n						vec2 uv = uv0 + step * kernel[i];\n						vec3 tap = texture2DLod(farTexture, uv, 0.0).rgb;\n						float cocThis = texture2DLod(cocTexture, uv, 0.0).r;\n						tap *= cocThis;\n						sumCoC += cocThis;\n						sum += tap.rgb;\n					}\n					if (sumCoC > 0.0)\n						sum /= sumCoC;\n					sum /= cocFar;\n				}\n				pcFragColor0 = vec4(sum, 1.0);\n			}");
		}
		execute() {
				if (!this.shader) {
						this.createShader();
				}
				this.nearTextureId.setValue(this.nearTexture);
				this.farTextureId.setValue(this.farTexture);
				this.cocTextureId.setValue(this.cocTexture);
				this.kernelId.setValue(this.kernel);
				this.kernelCountId.setValue(this.kernel.length >> 1);
				this.blurRadiusNearId.setValue(this.blurRadiusNear);
				this.blurRadiusFarId.setValue(this.blurRadiusFar);
				super.execute();
		}
		constructor(device, nearTexture, farTexture, cocTexture){
				super(device), this.blurRadiusNear = 1, this.blurRadiusFar = 1, this._blurRings = 3, this._blurRingPoints = 3;
				this.nearTexture = nearTexture;
				this.farTexture = farTexture;
				this.cocTexture = cocTexture;
				var { scope } = device;
				this.kernelId = scope.resolve('kernel[0]');
				this.kernelCountId = scope.resolve('kernelCount');
				this.blurRadiusNearId = scope.resolve('blurRadiusNear');
				this.blurRadiusFarId = scope.resolve('blurRadiusFar');
				this.nearTextureId = scope.resolve('nearTexture');
				this.farTextureId = scope.resolve('farTexture');
				this.cocTextureId = scope.resolve('cocTexture');
		}
}

class RenderPassDof extends RenderPass {
		destroy() {
				this.destroyRenderPasses();
				this.cocPass = null;
				this.farPass = null;
				this.blurPass = null;
				this.destroyRT(this.cocRT);
				this.destroyRT(this.farRt);
				this.destroyRT(this.blurRt);
				this.cocRT = null;
				this.farRt = null;
				this.blurRt = null;
		}
		destroyRenderPasses() {
				for(var i = 0; i < this.beforePasses.length; i++){
						this.beforePasses[i].destroy();
				}
				this.beforePasses.length = 0;
		}
		destroyRT(rt) {
				if (rt) {
						rt.destroyTextureBuffers();
						rt.destroy();
				}
		}
		setupCocPass(device, cameraComponent, sourceTexture, nearBlur) {
				var format = nearBlur ? PIXELFORMAT_RG8 : PIXELFORMAT_R8;
				this.cocRT = this.createRenderTarget('CoCTexture', format);
				this.cocTexture = this.cocRT.colorBuffer;
				var cocPass = new RenderPassCoC(device, cameraComponent, nearBlur);
				cocPass.init(this.cocRT, {
						resizeSource: sourceTexture
				});
				cocPass.setClearColor(Color.BLACK);
				return cocPass;
		}
		setupFarPass(device, sourceTexture, scale) {
				this.farRt = this.createRenderTarget('FarDofTexture', sourceTexture.format);
				var farPass = new RenderPassDownsample(device, sourceTexture, {
						boxFilter: true,
						premultiplyTexture: this.cocTexture,
						premultiplySrcChannel: 'r'
				});
				farPass.init(this.farRt, {
						resizeSource: sourceTexture,
						scaleX: scale,
						scaleY: scale
				});
				farPass.setClearColor(Color.BLACK);
				return farPass;
		}
		setupBlurPass(device, nearTexture, nearBlur, scale) {
				var _this_farRt;
				var farTexture = (_this_farRt = this.farRt) == null ? void 0 : _this_farRt.colorBuffer;
				this.blurRt = this.createRenderTarget('DofBlurTexture', nearTexture.format);
				this.blurTexture = this.blurRt.colorBuffer;
				var blurPass = new RenderPassDofBlur(device, nearBlur ? nearTexture : null, farTexture, this.cocTexture);
				blurPass.init(this.blurRt, {
						resizeSource: nearTexture,
						scaleX: scale,
						scaleY: scale
				});
				blurPass.setClearColor(Color.BLACK);
				return blurPass;
		}
		createTexture(name, format) {
				return new Texture(this.device, {
						name: name,
						width: 1,
						height: 1,
						format: format,
						mipmaps: false,
						minFilter: FILTER_LINEAR,
						magFilter: FILTER_LINEAR,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
		}
		createRenderTarget(name, format) {
				return new RenderTarget({
						colorBuffer: this.createTexture(name, format),
						depth: false,
						stencil: false
				});
		}
		frameUpdate() {
				super.frameUpdate();
				this.cocPass.focusDistance = this.focusDistance;
				this.cocPass.focusRange = this.focusRange;
				this.blurPass.blurRadiusNear = this.blurRadius;
				this.blurPass.blurRadiusFar = this.blurRadius * (this.highQuality ? 1 : 0.5);
				this.blurPass.blurRings = this.blurRings;
				this.blurPass.blurRingPoints = this.blurRingPoints;
		}
		constructor(device, cameraComponent, sceneTexture, sceneTextureHalf, highQuality, nearBlur){
				super(device), this.focusDistance = 100, this.focusRange = 50, this.blurRadius = 1, this.blurRings = 3, this.blurRingPoints = 3, this.highQuality = true, this.cocTexture = null, this.blurTexture = null, this.cocPass = null, this.farPass = null, this.blurPass = null;
				this.highQuality = highQuality;
				this.cocPass = this.setupCocPass(device, cameraComponent, sceneTexture, nearBlur);
				this.beforePasses.push(this.cocPass);
				var sourceTexture = highQuality ? sceneTexture : sceneTextureHalf;
				this.farPass = this.setupFarPass(device, sourceTexture, 0.5);
				this.beforePasses.push(this.farPass);
				this.blurPass = this.setupBlurPass(device, sceneTextureHalf, nearBlur, highQuality ? 2 : 0.5);
				this.beforePasses.push(this.blurPass);
		}
}

var tempMeshInstances = [];
var DEPTH_UNIFORM_NAME = 'uSceneDepthMap';
class RenderPassPrepass extends RenderPass {
		destroy() {
				var _this_renderTarget, _this_linearDepthTexture;
				super.destroy();
				(_this_renderTarget = this.renderTarget) == null ? void 0 : _this_renderTarget.destroy();
				this.renderTarget = null;
				(_this_linearDepthTexture = this.linearDepthTexture) == null ? void 0 : _this_linearDepthTexture.destroy();
				this.linearDepthTexture = null;
				this.viewBindGroups.forEach((bg)=>{
						bg.defaultUniformBuffer.destroy();
						bg.destroy();
				});
				this.viewBindGroups.length = 0;
		}
		setupRenderTarget(options) {
				var { device } = this;
				this.linearDepthFormat = device.textureFloatRenderable ? PIXELFORMAT_R32F : PIXELFORMAT_RGBA8;
				this.linearDepthTexture = new Texture(device, {
						name: 'SceneLinearDepthTexture',
						width: 1,
						height: 1,
						format: this.linearDepthFormat,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				var renderTarget = new RenderTarget({
						name: 'PrepassRT',
						colorBuffer: this.linearDepthTexture,
						depth: true,
						samples: 1
				});
				this.camera.shaderParams.sceneDepthMapLinear = true;
				this.init(renderTarget, options);
		}
		after() {
				this.device.scope.resolve(DEPTH_UNIFORM_NAME).setValue(this.linearDepthTexture);
		}
		execute() {
				var { renderer, scene, renderTarget } = this;
				var camera = this.camera.camera;
				var layers = scene.layers.layerList;
				var subLayerEnabled = scene.layers.subLayerEnabled;
				var isTransparent = scene.layers.subLayerList;
				for(var i = 0; i < layers.length; i++){
						var layer = layers[i];
						if (layer.id === LAYERID_DEPTH) {
								break;
						}
						if (layer.enabled && subLayerEnabled[i]) {
								if (layer.camerasSet.has(camera)) {
										var culledInstances = layer.getCulledInstances(camera);
										var meshInstances = isTransparent[i] ? culledInstances.transparent : culledInstances.opaque;
										for(var j = 0; j < meshInstances.length; j++){
												var _meshInstance_material;
												var meshInstance = meshInstances[j];
												if ((_meshInstance_material = meshInstance.material) == null ? void 0 : _meshInstance_material.depthWrite) {
														tempMeshInstances.push(meshInstance);
												}
										}
										renderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_PREPASS, this.viewBindGroups, {
												meshInstances: tempMeshInstances
										});
										tempMeshInstances.length = 0;
								}
						}
				}
		}
		frameUpdate() {
				super.frameUpdate();
				var { camera } = this;
				this.setClearDepth(camera.clearDepthBuffer ? 1 : undefined);
				var clearValue;
				if (camera.clearDepthBuffer) {
						var farClip = camera.farClip - Number.MIN_VALUE;
						clearValue = this.linearDepthClearValue;
						if (this.linearDepthFormat === PIXELFORMAT_R32F) {
								clearValue.r = farClip;
						} else {
								FloatPacking.float2RGBA8(farClip, clearValue);
						}
				}
				this.setClearColor(clearValue);
		}
		constructor(device, scene, renderer, camera, options){
				super(device), this.viewBindGroups = [], this.linearDepthClearValue = new Color(0, 0, 0, 0);
				this.scene = scene;
				this.renderer = renderer;
				this.camera = camera;
				this.setupRenderTarget(options);
		}
}

class RenderPassDepthAwareBlur extends RenderPassShaderQuad {
		execute() {
				this.filterSizeId.setValue(4);
				this.sourceTextureId.setValue(this.sourceTexture);
				var { width, height } = this.sourceTexture;
				this.sourceInvResolutionValue[0] = 1.0 / width;
				this.sourceInvResolutionValue[1] = 1.0 / height;
				this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
				super.execute();
		}
		constructor(device, sourceTexture, cameraComponent, horizontal){
				super(device);
				this.sourceTexture = sourceTexture;
				var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
				this.shader = this.createQuadShader("DepthAware" + (horizontal ? 'Horizontal' : 'Vertical') + "BlurShader", screenDepth + "\n			" + (horizontal ? '#define HORIZONTAL' : '') + "\n			varying vec2 uv0;\n			uniform sampler2D sourceTexture;\n			uniform vec2 sourceInvResolution;\n			uniform int filterSize;\n			float random(const highp vec2 w) {\n				const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n				return fract(m.z * fract(dot(w, m.xy)));\n			}\n			mediump float bilateralWeight(in mediump float depth, in mediump float sampleDepth) {\n				mediump float diff = (sampleDepth - depth);\n				return max(0.0, 1.0 - diff * diff);\n			}\n			void tap(inout float sum, inout float totalWeight, float weight, float depth, vec2 position) {\n				mediump float color = texture2D(sourceTexture, position).r;\n				mediump float textureDepth = -getLinearScreenDepth(position);\n			\n				mediump float bilateral = bilateralWeight(depth, textureDepth);\n				bilateral *= weight;\n				sum += color * bilateral;\n				totalWeight += bilateral;\n			}\n			void main() {\n				mediump float depth = -getLinearScreenDepth(uv0);\n				mediump float totalWeight = 1.0;\n				mediump float color = texture2D(sourceTexture, uv0 ).r;\n				mediump float sum = color * totalWeight;\n				for (mediump int i = -filterSize; i <= filterSize; i++) {\n					mediump float weight = 1.0;\n					#ifdef HORIZONTAL\n						vec2 offset = vec2(i, 0) * sourceInvResolution;\n					#else\n						vec2 offset = vec2(0, i) * sourceInvResolution;\n					#endif\n					tap(sum, totalWeight, weight, depth, uv0 + offset);\n				}\n				mediump float ao = sum / totalWeight;\n				gl_FragColor.r = ao;\n			}\n		");
				var scope = this.device.scope;
				this.sourceTextureId = scope.resolve('sourceTexture');
				this.sourceInvResolutionId = scope.resolve('sourceInvResolution');
				this.sourceInvResolutionValue = new Float32Array(2);
				this.filterSizeId = scope.resolve('filterSize');
		}
}

var fs = "\n	varying vec2 uv0;\n	uniform vec2 uInvResolution;\n	uniform float uAspect;\n	#define saturate(x) clamp(x,0.0,1.0)\n	highp float getWFromProjectionMatrix(const mat4 p, const vec3 v) {\n		return -v.z;\n	}\n	highp float getViewSpaceZFromW(const mat4 p, const float w) {\n		return -w;\n	}\n	const float kLog2LodRate = 3.0;\n	float random(const highp vec2 w) {\n		const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n		return fract(m.z * fract(dot(w, m.xy)));\n	}\n	highp vec2 getFragCoord() {\n		return gl_FragCoord.xy;\n	}\n	highp vec3 computeViewSpacePositionFromDepth(highp vec2 uv, highp float linearDepth) {\n		return vec3((0.5 - uv) * vec2(uAspect, 1.0) * linearDepth, linearDepth);\n	}\n	highp vec3 faceNormal(highp vec3 dpdx, highp vec3 dpdy) {\n		return normalize(cross(dpdx, dpdy));\n	}\n	highp vec3 computeViewSpaceNormal(const highp vec3 position) {\n		return faceNormal(dFdx(position), dFdy(position));\n	}\n	highp vec3 computeViewSpaceNormal(const highp vec3 position, const highp vec2 uv) {\n		highp vec2 uvdx = uv + vec2(uInvResolution.x, 0.0);\n		highp vec2 uvdy = uv + vec2(0.0, uInvResolution.y);\n		highp vec3 px = computeViewSpacePositionFromDepth(uvdx, -getLinearScreenDepth(uvdx));\n		highp vec3 py = computeViewSpacePositionFromDepth(uvdy, -getLinearScreenDepth(uvdy));\n		highp vec3 dpdx = px - position;\n		highp vec3 dpdy = py - position;\n		return faceNormal(dpdx, dpdy);\n	}\n	uniform vec2 uSampleCount;\n	uniform float uSpiralTurns;\n	#define PI (3.14159)\n	mediump vec3 tapLocation(mediump float i, const mediump float noise) {\n		mediump float offset = ((2.0 * PI) * 2.4) * noise;\n		mediump float angle = ((i * uSampleCount.y) * uSpiralTurns) * (2.0 * PI) + offset;\n		mediump float radius = (i + noise + 0.5) * uSampleCount.y;\n		return vec3(cos(angle), sin(angle), radius * radius);\n	}\n	highp vec2 startPosition(const float noise) {\n		float angle = ((2.0 * PI) * 2.4) * noise;\n		return vec2(cos(angle), sin(angle));\n	}\n	uniform vec2 uAngleIncCosSin;\n	highp mat2 tapAngleStep() {\n		highp vec2 t = uAngleIncCosSin;\n		return mat2(t.x, t.y, -t.y, t.x);\n	}\n	mediump vec3 tapLocationFast(mediump float i, mediump vec2 p, const mediump float noise) {\n		mediump float radius = (i + noise + 0.5) * uSampleCount.y;\n		return vec3(p, radius * radius);\n	}\n	uniform float uMaxLevel;\n	uniform float uInvRadiusSquared;\n	uniform float uMinHorizonAngleSineSquared;\n	uniform float uBias;\n	uniform float uPeak2;\n	void computeAmbientOcclusionSAO(inout mediump float occlusion, mediump float i, mediump float ssDiskRadius,\n			const highp vec2 uv, const highp vec3 origin, const mediump vec3 normal,\n			const mediump vec2 tapPosition, const float noise) {\n		mediump vec3 tap = tapLocationFast(i, tapPosition, noise);\n		mediump float ssRadius = max(1.0, tap.z * ssDiskRadius);\n		mediump vec2 uvSamplePos = uv + vec2(ssRadius * tap.xy) * uInvResolution;\n		mediump float level = clamp(floor(log2(ssRadius)) - kLog2LodRate, 0.0, float(uMaxLevel));\n		highp float occlusionDepth = -getLinearScreenDepth(uvSamplePos);\n		highp vec3 p = computeViewSpacePositionFromDepth(uvSamplePos, occlusionDepth);\n		vec3 v = p - origin;\n		float vv = dot(v, v);\n		float vn = dot(v, normal);\n		mediump float w = max(0.0, 1.0 - vv * uInvRadiusSquared);\n		w = w * w;\n		w *= step(vv * uMinHorizonAngleSineSquared, vn * vn);\n		occlusion += w * max(0.0, vn + origin.z * uBias) / (vv + uPeak2);\n	}\n	uniform float uProjectionScaleRadius;\n	uniform float uIntensity;\n	uniform float uRandomize;\n	float scalableAmbientObscurance(highp vec2 uv, highp vec3 origin, vec3 normal) {\n		float noise = random(getFragCoord()) + uRandomize;\n		highp vec2 tapPosition = startPosition(noise);\n		highp mat2 angleStep = tapAngleStep();\n		float ssDiskRadius = -(uProjectionScaleRadius / origin.z);\n		float occlusion = 0.0;\n		for (float i = 0.0; i < uSampleCount.x; i += 1.0) {\n			computeAmbientOcclusionSAO(occlusion, i, ssDiskRadius, uv, origin, normal, tapPosition, noise);\n			tapPosition = angleStep * tapPosition;\n		}\n		return occlusion;\n	}\n	uniform float uPower;\n	void main() {\n		highp vec2 uv = uv0;\n		highp float depth = -getLinearScreenDepth(uv0);\n		highp vec3 origin = computeViewSpacePositionFromDepth(uv, depth);\n		vec3 normal = computeViewSpaceNormal(origin, uv);\n		float occlusion = 0.0;\n		if (uIntensity > 0.0) {\n			occlusion = scalableAmbientObscurance(uv, origin, normal);\n		}\n		float ao = max(0.0, 1.0 - occlusion * uIntensity);\n		ao = pow(ao, uPower);\n		gl_FragColor = vec4(ao, ao, ao, 1.0);\n	}\n";
class RenderPassSsao extends RenderPassShaderQuad {
		destroy() {
				var _this_renderTarget, _this_renderTarget1;
				(_this_renderTarget = this.renderTarget) == null ? void 0 : _this_renderTarget.destroyTextureBuffers();
				(_this_renderTarget1 = this.renderTarget) == null ? void 0 : _this_renderTarget1.destroy();
				this.renderTarget = null;
				if (this.afterPasses.length > 0) {
						var blurRt = this.afterPasses[0].renderTarget;
						blurRt == null ? void 0 : blurRt.destroyTextureBuffers();
						blurRt == null ? void 0 : blurRt.destroy();
				}
				this.afterPasses.forEach((pass)=>pass.destroy());
				this.afterPasses.length = 0;
				super.destroy();
		}
		set scale(value) {
				this._scale = value;
				this.scaleX = value;
				this.scaleY = value;
		}
		get scale() {
				return this._scale;
		}
		createRenderTarget(name) {
				return new RenderTarget({
						depth: false,
						colorBuffer: new Texture(this.device, {
								name: name,
								width: 1,
								height: 1,
								format: PIXELFORMAT_R8,
								mipmaps: false,
								minFilter: FILTER_NEAREST,
								magFilter: FILTER_NEAREST,
								addressU: ADDRESS_CLAMP_TO_EDGE,
								addressV: ADDRESS_CLAMP_TO_EDGE
						})
				});
		}
		execute() {
				var { device, sourceTexture, sampleCount, minAngle, scale } = this;
				var { width, height } = this.renderTarget.colorBuffer;
				var scope = device.scope;
				scope.resolve('uAspect').setValue(width / height);
				scope.resolve('uInvResolution').setValue([
						1.0 / width,
						1.0 / height
				]);
				scope.resolve('uSampleCount').setValue([
						sampleCount,
						1.0 / sampleCount
				]);
				var minAngleSin = Math.sin(minAngle * Math.PI / 180.0);
				scope.resolve('uMinHorizonAngleSineSquared').setValue(minAngleSin * minAngleSin);
				var spiralTurns = 10.0;
				var step = 1.0 / (sampleCount - 0.5) * spiralTurns * 2.0 * 3.141;
				var radius = this.radius / scale;
				var bias = 0.001;
				var peak = 0.1 * radius;
				var intensity = 2 * (peak * 2.0 * 3.141) * this.intensity / sampleCount;
				var projectionScale = 0.5 * sourceTexture.height;
				scope.resolve('uSpiralTurns').setValue(spiralTurns);
				scope.resolve('uAngleIncCosSin').setValue([
						Math.cos(step),
						Math.sin(step)
				]);
				scope.resolve('uMaxLevel').setValue(0.0);
				scope.resolve('uInvRadiusSquared').setValue(1.0 / (radius * radius));
				scope.resolve('uBias').setValue(bias);
				scope.resolve('uPeak2').setValue(peak * peak);
				scope.resolve('uIntensity').setValue(intensity);
				scope.resolve('uPower').setValue(this.power);
				scope.resolve('uProjectionScaleRadius').setValue(projectionScale * radius);
				scope.resolve('uRandomize').setValue(this.randomize ? this._blueNoise.value() : 0);
				super.execute();
		}
		after() {
				this.ssaoTextureId.setValue(this.ssaoTexture);
				var srcTexture = this.sourceTexture;
				this.ssaoTextureSizeInvId.setValue([
						1.0 / srcTexture.width,
						1.0 / srcTexture.height
				]);
		}
		constructor(device, sourceTexture, cameraComponent, blurEnabled){
				super(device), this.radius = 5, this.intensity = 1, this.power = 1, this.sampleCount = 10, this.minAngle = 5, this.randomize = false, this._scale = 1, this._blueNoise = new BlueNoise(19);
				this.sourceTexture = sourceTexture;
				this.cameraComponent = cameraComponent;
				var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
				this.shader = this.createQuadShader('SsaoShader', screenDepth + fs);
				var rt = this.createRenderTarget('SsaoFinalTexture');
				this.ssaoTexture = rt.colorBuffer;
				this.init(rt, {
						resizeSource: this.sourceTexture
				});
				var clearColor = new Color(0, 0, 0, 0);
				this.setClearColor(clearColor);
				if (blurEnabled) {
						var blurRT = this.createRenderTarget('SsaoTempTexture');
						var blurPassHorizontal = new RenderPassDepthAwareBlur(device, rt.colorBuffer, cameraComponent, true);
						blurPassHorizontal.init(blurRT, {
								resizeSource: rt.colorBuffer
						});
						blurPassHorizontal.setClearColor(clearColor);
						var blurPassVertical = new RenderPassDepthAwareBlur(device, blurRT.colorBuffer, cameraComponent, false);
						blurPassVertical.init(rt, {
								resizeSource: rt.colorBuffer
						});
						blurPassVertical.setClearColor(clearColor);
						this.afterPasses.push(blurPassHorizontal);
						this.afterPasses.push(blurPassVertical);
				}
				this.ssaoTextureId = device.scope.resolve('ssaoTexture');
				this.ssaoTextureSizeInvId = device.scope.resolve('ssaoTextureSizeInv');
		}
}

class CameraFrameOptions {
		constructor(){
				this.stencil = false;
				this.samples = 1;
				this.sceneColorMap = false;
				this.lastGrabLayerId = LAYERID_SKYBOX;
				this.lastGrabLayerIsTransparent = false;
				this.lastSceneLayerId = LAYERID_IMMEDIATE;
				this.lastSceneLayerIsTransparent = true;
				this.taaEnabled = false;
				this.bloomEnabled = false;
				this.ssaoType = SSAOTYPE_NONE;
				this.ssaoBlurEnabled = true;
				this.prepassEnabled = false;
				this.dofEnabled = false;
				this.dofNearBlur = false;
				this.dofHighQuality = true;
		}
}
var _defaultOptions = new CameraFrameOptions();
class RenderPassCameraFrame extends RenderPass {
		destroy() {
				this.reset();
		}
		reset() {
				this.sceneTexture = null;
				this.sceneTextureHalf = null;
				if (this.rt) {
						this.rt.destroyTextureBuffers();
						this.rt.destroy();
						this.rt = null;
				}
				if (this.rtHalf) {
						this.rtHalf.destroyTextureBuffers();
						this.rtHalf.destroy();
						this.rtHalf = null;
				}
				this.beforePasses.forEach((pass)=>pass.destroy());
				this.beforePasses.length = 0;
				this.prePass = null;
				this.scenePass = null;
				this.scenePassTransparent = null;
				this.colorGrabPass = null;
				this.composePass = null;
				this.bloomPass = null;
				this.ssaoPass = null;
				this.taaPass = null;
				this.afterPass = null;
				this.scenePassHalf = null;
				this.dofPass = null;
		}
		sanitizeOptions(options) {
				options = Object.assign({}, _defaultOptions, options);
				if (options.taaEnabled || options.ssaoType !== SSAOTYPE_NONE || options.dofEnabled) {
						options.prepassEnabled = true;
				}
				return options;
		}
		set renderTargetScale(value) {
				this._renderTargetScale = value;
				if (this.scenePass) {
						this.scenePass.scaleX = value;
						this.scenePass.scaleY = value;
				}
		}
		get renderTargetScale() {
				return this._renderTargetScale;
		}
		needsReset(options) {
				var currentOptions = this.options;
				var arraysNotEqual = (arr1, arr2)=>arr1 !== arr2 && (!(Array.isArray(arr1) && Array.isArray(arr2)) || arr1.length !== arr2.length || !arr1.every((value, index)=>value === arr2[index]));
				return options.ssaoType !== currentOptions.ssaoType || options.ssaoBlurEnabled !== currentOptions.ssaoBlurEnabled || options.taaEnabled !== currentOptions.taaEnabled || options.samples !== currentOptions.samples || options.stencil !== currentOptions.stencil || options.bloomEnabled !== currentOptions.bloomEnabled || options.prepassEnabled !== currentOptions.prepassEnabled || options.sceneColorMap !== currentOptions.sceneColorMap || options.dofEnabled !== currentOptions.dofEnabled || options.dofNearBlur !== currentOptions.dofNearBlur || options.dofHighQuality !== currentOptions.dofHighQuality || arraysNotEqual(options.formats, currentOptions.formats);
		}
		update(options) {
				options = this.sanitizeOptions(options);
				if (this.needsReset(options)) {
						this.reset();
				}
				this.options = options;
				if (!this.sceneTexture) {
						this.setupRenderPasses(this.options);
				}
		}
		createRenderTarget(name, depth, stencil, samples, flipY) {
				var texture = new Texture(this.device, {
						name: name,
						width: 4,
						height: 4,
						format: this.hdrFormat,
						mipmaps: false,
						minFilter: FILTER_LINEAR,
						magFilter: FILTER_LINEAR,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				});
				return new RenderTarget({
						colorBuffer: texture,
						depth: depth,
						stencil: stencil,
						samples: samples,
						flipY: flipY
				});
		}
		setupRenderPasses(options) {
				var { device } = this;
				var cameraComponent = this.cameraComponent;
				var targetRenderTarget = cameraComponent.renderTarget;
				this.hdrFormat = device.getRenderableHdrFormat(options.formats, true, options.samples) || PIXELFORMAT_RGBA8;
				this._bloomEnabled = options.bloomEnabled && this.hdrFormat !== PIXELFORMAT_RGBA8;
				this._sceneHalfEnabled = this._bloomEnabled || options.dofEnabled;
				cameraComponent.shaderParams.ssaoEnabled = options.ssaoType === SSAOTYPE_LIGHTING;
				var flipY = !!(targetRenderTarget == null ? void 0 : targetRenderTarget.flipY);
				this.rt = this.createRenderTarget('SceneColor', true, options.stencil, options.samples, flipY);
				this.sceneTexture = this.rt.colorBuffer;
				if (this._sceneHalfEnabled) {
						this.rtHalf = this.createRenderTarget('SceneColorHalf', false, false, 1, flipY);
						this.sceneTextureHalf = this.rtHalf.colorBuffer;
				}
				this.sceneOptions = {
						resizeSource: targetRenderTarget,
						scaleX: this.renderTargetScale,
						scaleY: this.renderTargetScale
				};
				this.createPasses(options);
				var allPasses = this.collectPasses();
				this.beforePasses = allPasses.filter((element)=>element !== undefined && element !== null);
		}
		collectPasses() {
				return [
						this.prePass,
						this.ssaoPass,
						this.scenePass,
						this.colorGrabPass,
						this.scenePassTransparent,
						this.taaPass,
						this.scenePassHalf,
						this.bloomPass,
						this.dofPass,
						this.composePass,
						this.afterPass
				];
		}
		createPasses(options) {
				this.setupScenePrepass(options);
				this.setupSsaoPass(options);
				var scenePassesInfo = this.setupScenePass(options);
				var sceneTextureWithTaa = this.setupTaaPass(options);
				this.setupSceneHalfPass(options, sceneTextureWithTaa);
				this.setupBloomPass(options, this.sceneTextureHalf);
				this.setupDofPass(options, this.sceneTexture, this.sceneTextureHalf);
				this.setupComposePass(options);
				this.setupAfterPass(options, scenePassesInfo);
		}
		setupScenePrepass(options) {
				if (options.prepassEnabled) {
						var { app, device, cameraComponent } = this;
						var { scene, renderer } = app;
						this.prePass = new RenderPassPrepass(device, scene, renderer, cameraComponent, this.sceneOptions);
				}
		}
		setupScenePassSettings(pass) {
				pass.gammaCorrection = GAMMA_NONE;
				pass.toneMapping = TONEMAP_NONE;
		}
		setupScenePass(options) {
				var { app, device, cameraComponent } = this;
				var { scene, renderer } = app;
				var composition = scene.layers;
				this.scenePass = new RenderPassForward(device, composition, scene, renderer);
				this.setupScenePassSettings(this.scenePass);
				this.scenePass.init(this.rt, this.sceneOptions);
				var lastLayerId = options.sceneColorMap ? options.lastGrabLayerId : options.lastSceneLayerId;
				var lastLayerIsTransparent = options.sceneColorMap ? options.lastGrabLayerIsTransparent : options.lastSceneLayerIsTransparent;
				var ret = {
						lastAddedIndex: 0,
						clearRenderTarget: true
				};
				ret.lastAddedIndex = this.scenePass.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, lastLayerId, lastLayerIsTransparent);
				ret.clearRenderTarget = false;
				if (options.sceneColorMap) {
						this.colorGrabPass = new RenderPassColorGrab(device);
						this.colorGrabPass.source = this.rt;
						this.scenePassTransparent = new RenderPassForward(device, composition, scene, renderer);
						this.setupScenePassSettings(this.scenePassTransparent);
						this.scenePassTransparent.init(this.rt);
						ret.lastAddedIndex = this.scenePassTransparent.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, options.lastSceneLayerId, options.lastSceneLayerIsTransparent);
						if (!this.scenePassTransparent.rendersAnything) {
								this.scenePassTransparent.destroy();
								this.scenePassTransparent = null;
						}
						if (this.scenePassTransparent) {
								if (options.prepassEnabled) {
										this.scenePassTransparent.depthStencilOps.storeDepth = true;
								}
						}
				}
				return ret;
		}
		setupSsaoPass(options) {
				var { ssaoBlurEnabled, ssaoType } = options;
				var { device, cameraComponent } = this;
				if (ssaoType !== SSAOTYPE_NONE) {
						this.ssaoPass = new RenderPassSsao(device, this.sceneTexture, cameraComponent, ssaoBlurEnabled);
				}
		}
		setupSceneHalfPass(options, sourceTexture) {
				if (this._sceneHalfEnabled) {
						this.scenePassHalf = new RenderPassDownsample(this.device, this.sceneTexture, {
								boxFilter: true
						});
						this.scenePassHalf.name = 'RenderPassSceneHalf';
						this.scenePassHalf.init(this.rtHalf, {
								resizeSource: sourceTexture,
								scaleX: 0.5,
								scaleY: 0.5
						});
						this.scenePassHalf.setClearColor(Color.BLACK);
				}
		}
		setupBloomPass(options, inputTexture) {
				if (this._bloomEnabled) {
						this.bloomPass = new RenderPassBloom(this.device, inputTexture, this.hdrFormat);
				}
		}
		setupDofPass(options, inputTexture, inputTextureHalf) {
				if (options.dofEnabled) {
						this.dofPass = new RenderPassDof(this.device, this.cameraComponent, inputTexture, inputTextureHalf, options.dofHighQuality, options.dofNearBlur);
				}
		}
		setupTaaPass(options) {
				var textureWithTaa = this.sceneTexture;
				if (options.taaEnabled) {
						this.taaPass = new RenderPassTAA(this.device, this.sceneTexture, this.cameraComponent);
						textureWithTaa = this.taaPass.historyTexture;
				}
				return textureWithTaa;
		}
		setupComposePass(options) {
				var _this_bloomPass, _this_dofPass, _this_dofPass1, _this_dofPass2;
				this.composePass = new RenderPassCompose(this.device);
				this.composePass.bloomTexture = (_this_bloomPass = this.bloomPass) == null ? void 0 : _this_bloomPass.bloomTexture;
				this.composePass.taaEnabled = options.taaEnabled;
				this.composePass.cocTexture = (_this_dofPass = this.dofPass) == null ? void 0 : _this_dofPass.cocTexture;
				this.composePass.blurTexture = (_this_dofPass1 = this.dofPass) == null ? void 0 : _this_dofPass1.blurTexture;
				this.composePass.blurTextureUpscale = !((_this_dofPass2 = this.dofPass) == null ? void 0 : _this_dofPass2.highQuality);
				var cameraComponent = this.cameraComponent;
				var targetRenderTarget = cameraComponent.renderTarget;
				this.composePass.init(targetRenderTarget);
				this.composePass.ssaoTexture = options.ssaoType === SSAOTYPE_COMBINE ? this.ssaoPass.ssaoTexture : null;
		}
		setupAfterPass(options, scenePassesInfo) {
				var { app, cameraComponent } = this;
				var { scene, renderer } = app;
				var composition = scene.layers;
				var targetRenderTarget = cameraComponent.renderTarget;
				this.afterPass = new RenderPassForward(this.device, composition, scene, renderer);
				this.afterPass.init(targetRenderTarget);
				this.afterPass.addLayers(composition, cameraComponent, scenePassesInfo.lastAddedIndex, scenePassesInfo.clearRenderTarget);
		}
		frameUpdate() {
				var _this_taaPass, _this_scenePassHalf;
				super.frameUpdate();
				var _this_taaPass_update;
				var sceneTexture = (_this_taaPass_update = (_this_taaPass = this.taaPass) == null ? void 0 : _this_taaPass.update()) != null ? _this_taaPass_update : this.rt.colorBuffer;
				this.composePass.sceneTexture = sceneTexture;
				(_this_scenePassHalf = this.scenePassHalf) == null ? void 0 : _this_scenePassHalf.setSourceTexture(sceneTexture);
		}
		constructor(app, cameraComponent, options = {}){
				super(app.graphicsDevice), this._renderTargetScale = 1, this.rt = null;
				this.app = app;
				this.cameraComponent = cameraComponent;
				this.options = this.sanitizeOptions(options);
				this.setupRenderPasses(this.options);
		}
}

class CameraFrame {
		destroy() {
				this.disable();
		}
		enable() {
				this.renderPassCamera = this.createRenderPass();
				this.cameraComponent.renderPasses = [
						this.renderPassCamera
				];
		}
		disable() {
				var _cameraComponent_renderPasses;
				var cameraComponent = this.cameraComponent;
				(_cameraComponent_renderPasses = cameraComponent.renderPasses) == null ? void 0 : _cameraComponent_renderPasses.forEach((renderPass)=>{
						renderPass.destroy();
				});
				cameraComponent.renderPasses = [];
				cameraComponent.rendering = null;
				cameraComponent.jitter = 0;
				cameraComponent.shaderParams.ssaoEnabled = false;
				this.renderPassCamera = null;
		}
		createRenderPass() {
				return new RenderPassCameraFrame(this.app, this.cameraComponent, this.options);
		}
		set enabled(value) {
				if (this._enabled !== value) {
						if (value) {
								this.enable();
						} else {
								this.disable();
						}
						this._enabled = value;
				}
		}
		get enabled() {
				return this._enabled;
		}
		updateOptions() {
				var { options, rendering, bloom, taa, ssao } = this;
				options.stencil = rendering.stencil;
				options.samples = rendering.samples;
				options.sceneColorMap = rendering.sceneColorMap;
				options.prepassEnabled = rendering.sceneDepthMap;
				options.bloomEnabled = bloom.intensity > 0;
				options.taaEnabled = taa.enabled;
				options.ssaoType = ssao.type;
				options.ssaoBlurEnabled = ssao.blurEnabled;
				options.formats = rendering.renderFormats.slice();
				options.dofEnabled = this.dof.enabled;
				options.dofNearBlur = this.dof.nearBlur;
				options.dofHighQuality = this.dof.highQuality;
		}
		update() {
				if (!this._enabled) return;
				var cameraComponent = this.cameraComponent;
				var { options, renderPassCamera, rendering, bloom, grading, vignette, fringing, taa, ssao } = this;
				this.updateOptions();
				renderPassCamera.update(options);
				var { composePass, bloomPass, ssaoPass, dofPass } = renderPassCamera;
				renderPassCamera.renderTargetScale = math.clamp(rendering.renderTargetScale, 0.1, 1);
				composePass.toneMapping = rendering.toneMapping;
				composePass.sharpness = rendering.sharpness;
				if (options.bloomEnabled && bloomPass) {
						composePass.bloomIntensity = bloom.intensity;
						bloomPass.blurLevel = bloom.blurLevel;
				}
				if (options.dofEnabled) {
						dofPass.focusDistance = this.dof.focusDistance;
						dofPass.focusRange = this.dof.focusRange;
						dofPass.blurRadius = this.dof.blurRadius;
						dofPass.blurRings = this.dof.blurRings;
						dofPass.blurRingPoints = this.dof.blurRingPoints;
				}
				if (options.ssaoType !== SSAOTYPE_NONE) {
						ssaoPass.intensity = ssao.intensity;
						ssaoPass.power = ssao.power;
						ssaoPass.radius = ssao.radius;
						ssaoPass.sampleCount = ssao.samples;
						ssaoPass.minAngle = ssao.minAngle;
						ssaoPass.scale = ssao.scale;
						ssaoPass.randomize = ssao.randomize;
				}
				composePass.gradingEnabled = grading.enabled;
				if (grading.enabled) {
						composePass.gradingSaturation = grading.saturation;
						composePass.gradingBrightness = grading.brightness;
						composePass.gradingContrast = grading.contrast;
						composePass.gradingTint = grading.tint;
				}
				composePass.vignetteEnabled = vignette.intensity > 0;
				if (composePass.vignetteEnabled) {
						composePass.vignetteInner = vignette.inner;
						composePass.vignetteOuter = vignette.outer;
						composePass.vignetteCurvature = vignette.curvature;
						composePass.vignetteIntensity = vignette.intensity;
				}
				composePass.fringingEnabled = fringing.intensity > 0;
				if (composePass.fringingEnabled) {
						composePass.fringingIntensity = fringing.intensity;
				}
				cameraComponent.jitter = taa.enabled ? taa.jitter : 0;
				composePass.debug = this.debug;
				if (composePass.debug === 'ssao' && options.ssaoType === SSAOTYPE_NONE) composePass.debug = null;
				if (composePass.debug === 'vignette' && !composePass.vignetteEnabled) composePass.debug = null;
		}
		constructor(app, cameraComponent){
				this._enabled = true;
				this.rendering = {
						renderFormats: [
								PIXELFORMAT_111110F,
								PIXELFORMAT_RGBA16F,
								PIXELFORMAT_RGBA32F
						],
						stencil: false,
						renderTargetScale: 1.0,
						samples: 1,
						sceneColorMap: false,
						sceneDepthMap: false,
						toneMapping: 0,
						sharpness: 0.0
				};
				this.ssao = {
						type: SSAOTYPE_NONE,
						blurEnabled: true,
						randomize: false,
						intensity: 0.5,
						radius: 30,
						samples: 12,
						power: 6,
						minAngle: 10,
						scale: 1
				};
				this.bloom = {
						intensity: 0,
						blurLevel: 16
				};
				this.grading = {
						enabled: false,
						brightness: 1,
						contrast: 1,
						saturation: 1,
						tint: new Color(1, 1, 1, 1)
				};
				this.vignette = {
						intensity: 0,
						inner: 0.5,
						outer: 1,
						curvature: 0.5
				};
				this.taa = {
						enabled: false,
						jitter: 1
				};
				this.fringing = {
						intensity: 0
				};
				this.dof = {
						enabled: false,
						nearBlur: false,
						focusDistance: 100,
						focusRange: 10,
						blurRadius: 3,
						blurRings: 4,
						blurRingPoints: 5,
						highQuality: true
				};
				this.debug = null;
				this.options = new CameraFrameOptions();
				this.renderPassCamera = null;
				this.app = app;
				this.cameraComponent = cameraComponent;
				this.updateOptions();
				this.enable();
		}
}

var GIZMOSPACE_LOCAL = 'local';
var GIZMOSPACE_WORLD = 'world';
var GIZMOAXIS_X = 'x';
var GIZMOAXIS_Y = 'y';
var GIZMOAXIS_Z = 'z';
var GIZMOAXIS_YZ = 'yz';
var GIZMOAXIS_XZ = 'xz';
var GIZMOAXIS_XY = 'xy';
var GIZMOAXIS_XYZ = 'xyz';
var GIZMOAXIS_FACE = 'face';

var tmpV1$9 = new Vec3();
var tmpV2$9 = new Vec3();
var tmpM1$3 = new Mat4();
var tmpM2 = new Mat4();
var tmpR1$1 = new Ray();
var LAYER_NAME = 'Gizmo';
var MIN_SCALE = 1e-4;
var PERS_SCALE_RATIO = 0.3;
var ORTHO_SCALE_RATIO = 0.32;
var UPDATE_EPSILON$1 = 1e-6;
class Gizmo extends EventHandler {
		static createLayer(app, layerName, layerIndex) {
				if (layerName === void 0) layerName = LAYER_NAME;
				var layer = new Layer({
						name: layerName,
						clearDepthBuffer: true,
						opaqueSortMode: SORTMODE_NONE,
						transparentSortMode: SORTMODE_NONE
				});
				app.scene.layers.insert(layer, layerIndex != null ? layerIndex : app.scene.layers.layerList.length);
				return layer;
		}
		get layer() {
				return this._layer;
		}
		set coordSpace(value) {
				this._coordSpace = value != null ? value : GIZMOSPACE_WORLD;
				this._updateRotation();
		}
		get coordSpace() {
				return this._coordSpace;
		}
		set size(value) {
				this._size = value;
				this._updateScale();
		}
		get size() {
				return this._size;
		}
		get facing() {
				if (this._camera.projection === PROJECTION_PERSPECTIVE) {
						var gizmoPos = this.root.getPosition();
						var cameraPos = this._camera.entity.getPosition();
						return tmpV2$9.sub2(cameraPos, gizmoPos).normalize();
				}
				return tmpV2$9.copy(this._camera.entity.forward).mulScalar(-1);
		}
		_onPointerDown(e) {
				if (!this.root.enabled || document.pointerLockElement) {
						return;
				}
				var selection = this._getSelection(e.offsetX, e.offsetY);
				if (selection[0]) {
						e.preventDefault();
						e.stopPropagation();
				}
				var { canvas } = this._device;
				canvas.setPointerCapture(e.pointerId);
				this.fire(Gizmo.EVENT_POINTERDOWN, e.offsetX, e.offsetY, selection[0]);
		}
		_onPointerMove(e) {
				if (!this.root.enabled || document.pointerLockElement) {
						return;
				}
				var selection = this._getSelection(e.offsetX, e.offsetY);
				if (selection[0]) {
						e.preventDefault();
						e.stopPropagation();
				}
				this.fire(Gizmo.EVENT_POINTERMOVE, e.offsetX, e.offsetY, selection[0]);
		}
		_onPointerUp(e) {
				if (!this.root.enabled || document.pointerLockElement) {
						return;
				}
				var selection = this._getSelection(e.offsetX, e.offsetY);
				if (selection[0]) {
						e.preventDefault();
						e.stopPropagation();
				}
				var { canvas } = this._device;
				canvas.releasePointerCapture(e.pointerId);
				this.fire(Gizmo.EVENT_POINTERUP, e.offsetX, e.offsetY, selection[0]);
		}
		_updatePosition() {
				tmpV1$9.set(0, 0, 0);
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						tmpV1$9.add(node.getPosition());
				}
				tmpV1$9.mulScalar(1.0 / (this.nodes.length || 1));
				if (tmpV1$9.distance(this.root.getPosition()) < UPDATE_EPSILON$1) {
						return;
				}
				this.root.setPosition(tmpV1$9);
				this.fire(Gizmo.EVENT_POSITIONUPDATE, tmpV1$9);
		}
		_updateRotation() {
				tmpV1$9.set(0, 0, 0);
				if (this._coordSpace === GIZMOSPACE_LOCAL && this.nodes.length !== 0) {
						tmpV1$9.copy(this.nodes[this.nodes.length - 1].getEulerAngles());
				}
				if (tmpV1$9.distance(this.root.getEulerAngles()) < UPDATE_EPSILON$1) {
						return;
				}
				this.root.setEulerAngles(tmpV1$9);
				this.fire(Gizmo.EVENT_ROTATIONUPDATE, tmpV1$9);
		}
		_updateScale() {
				if (this._camera.projection === PROJECTION_PERSPECTIVE) {
						var gizmoPos = this.root.getPosition();
						var cameraPos = this._camera.entity.getPosition();
						var dist = gizmoPos.distance(cameraPos);
						this._scale = Math.tan(0.5 * this._camera.fov * math.DEG_TO_RAD) * dist * PERS_SCALE_RATIO;
				} else {
						this._scale = this._camera.orthoHeight * ORTHO_SCALE_RATIO;
				}
				this._scale = Math.max(this._scale * this._size, MIN_SCALE);
				if (Math.abs(this._scale - this.root.getLocalScale().x) < UPDATE_EPSILON$1) {
						return;
				}
				this.root.setLocalScale(this._scale, this._scale, this._scale);
				this.fire(Gizmo.EVENT_SCALEUPDATE, this._scale);
		}
		_getSelection(x, y) {
				var start = this._camera.screenToWorld(x, y, 0);
				var end = this._camera.screenToWorld(x, y, this._camera.farClip - this._camera.nearClip);
				var dir = tmpV1$9.copy(end).sub(start).normalize();
				var selection = [];
				for(var i = 0; i < this.intersectShapes.length; i++){
						var shape = this.intersectShapes[i];
						if (shape.disabled || !shape.entity.enabled) {
								continue;
						}
						var parentTM = shape.entity.getWorldTransform();
						for(var j = 0; j < shape.triData.length; j++){
								var { tris, transform, priority } = shape.triData[j];
								var triWTM = tmpM1$3.copy(parentTM).mul(transform);
								var invTriWTM = tmpM2.copy(triWTM).invert();
								var ray = tmpR1$1;
								invTriWTM.transformPoint(start, ray.origin);
								invTriWTM.transformVector(dir, ray.direction);
								ray.direction.normalize();
								for(var k = 0; k < tris.length; k++){
										if (tris[k].intersectsRay(ray, tmpV1$9)) {
												selection.push({
														dist: triWTM.transformPoint(tmpV1$9).sub(start).length(),
														meshInstances: shape.meshInstances,
														priority: priority
												});
										}
								}
						}
				}
				if (selection.length) {
						selection.sort((s0, s1)=>{
								if (s0.priority !== 0 && s1.priority !== 0) {
										return s1.priority - s0.priority;
								}
								return s0.dist - s1.dist;
						});
						return selection[0].meshInstances;
				}
				return [];
		}
		attach(nodes) {
				if (nodes === void 0) nodes = [];
				if (Array.isArray(nodes)) {
						if (nodes.length === 0) {
								return;
						}
						this.nodes = nodes;
				} else {
						this.nodes = [
								nodes
						];
				}
				this._updatePosition();
				this._updateRotation();
				this._updateScale();
				this.fire(Gizmo.EVENT_NODESATTACH);
				this.root.enabled = true;
				this.fire(Gizmo.EVENT_RENDERUPDATE);
		}
		detach() {
				this.root.enabled = false;
				this.fire(Gizmo.EVENT_RENDERUPDATE);
				this.fire(Gizmo.EVENT_NODESDETACH);
				this.nodes = [];
		}
		destroy() {
				this.detach();
				this._device.canvas.removeEventListener('pointerdown', this._onPointerDown);
				this._device.canvas.removeEventListener('pointermove', this._onPointerMove);
				this._device.canvas.removeEventListener('pointerup', this._onPointerUp);
				this.root.destroy();
		}
		constructor(camera, layer){
				super(), this._size = 1, this._scale = 1, this._coordSpace = GIZMOSPACE_WORLD, this.nodes = [], this.intersectShapes = [];
				this._camera = camera;
				this._app = camera.system.app;
				this._device = this._app.graphicsDevice;
				this._layer = layer;
				camera.layers = camera.layers.concat(layer.id);
				this.root = new Entity('gizmo');
				this._app.root.addChild(this.root);
				this.root.enabled = false;
				this._updateScale();
				this._onPointerDown = this._onPointerDown.bind(this);
				this._onPointerMove = this._onPointerMove.bind(this);
				this._onPointerUp = this._onPointerUp.bind(this);
				this._device.canvas.addEventListener('pointerdown', this._onPointerDown);
				this._device.canvas.addEventListener('pointermove', this._onPointerMove);
				this._device.canvas.addEventListener('pointerup', this._onPointerUp);
				this._app.on('update', ()=>{
						this._updatePosition();
						this._updateRotation();
						this._updateScale();
				});
				this._app.on('destroy', ()=>this.destroy());
		}
}
Gizmo.EVENT_POINTERDOWN = 'pointer:down';
Gizmo.EVENT_POINTERMOVE = 'pointer:move';
Gizmo.EVENT_POINTERUP = 'pointer:up';
Gizmo.EVENT_POSITIONUPDATE = 'position:update';
Gizmo.EVENT_ROTATIONUPDATE = 'rotation:update';
Gizmo.EVENT_SCALEUPDATE = 'scale:update';
Gizmo.EVENT_NODESATTACH = 'nodes:attach';
Gizmo.EVENT_NODESDETACH = 'nodes:detach';
Gizmo.EVENT_RENDERUPDATE = 'render:update';

var COLOR_RED = Object.freeze(new Color(1, 0.3, 0.3));
var COLOR_GREEN = Object.freeze(new Color(0.3, 1, 0.3));
var COLOR_BLUE = Object.freeze(new Color(0.3, 0.3, 1));
var COLOR_YELLOW = Object.freeze(new Color(1, 1, 0.5));
var COLOR_GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 0.5));
var color3from4 = (color)=>{
		return new Color(color.r, color.g, color.b);
};
var color4from3 = (color, a)=>{
		return new Color(color.r, color.g, color.b, a);
};

var tmpV1$8 = new Vec3();
var tmpV2$8 = new Vec3();
var tmpQ1$5 = new Quat();
var tmpR1 = new Ray();
var tmpP1 = new Plane();
var VEC3_AXES = Object.keys(tmpV1$8);
class TransformGizmo extends Gizmo {
		set shading(value) {
				this._shading = this.root.enabled && value;
				for(var name in this._shapes){
						this._shapes[name].shading = this._shading;
				}
		}
		get shading() {
				return this._shading;
		}
		set snap(value) {
				this._snap = this.root.enabled && value;
		}
		get snap() {
				return this._snap;
		}
		set xAxisColor(value) {
				this._updateAxisColor(GIZMOAXIS_X, value);
		}
		get xAxisColor() {
				return this._meshColors.axis.x;
		}
		set yAxisColor(value) {
				this._updateAxisColor(GIZMOAXIS_Y, value);
		}
		get yAxisColor() {
				return this._meshColors.axis.y;
		}
		set zAxisColor(value) {
				this._updateAxisColor(GIZMOAXIS_Z, value);
		}
		get zAxisColor() {
				return this._meshColors.axis.z;
		}
		set colorAlpha(value) {
				this._colorAlpha = math.clamp(value, 0, 1);
				this._meshColors.axis.x.copy(this._colorSemi(this._meshColors.axis.x));
				this._meshColors.axis.y.copy(this._colorSemi(this._meshColors.axis.y));
				this._meshColors.axis.z.copy(this._colorSemi(this._meshColors.axis.z));
				this._meshColors.axis.xyz.copy(this._colorSemi(this._meshColors.axis.xyz));
				this._meshColors.axis.f.copy(this._colorSemi(this._meshColors.axis.f));
				for(var name in this._shapes){
						this._shapes[name].hover(!!this._hoverAxis);
				}
		}
		get colorAlpha() {
				return this._colorAlpha;
		}
		_colorSemi(color) {
				return color4from3(color, this._colorAlpha);
		}
		_updateAxisColor(axis, value) {
				var color3 = color3from4(value);
				var color4 = this._colorSemi(value);
				this._guideColors[axis].copy(color3);
				this._meshColors.axis[axis].copy(color4);
				this._meshColors.hover[axis].copy(color3);
				for(var name in this._shapes){
						this._shapes[name].hover(!!this._hoverAxis);
				}
		}
		_getAxis(meshInstance) {
				if (!meshInstance) {
						return '';
				}
				return meshInstance.node.name.split(':')[1];
		}
		_getIsPlane(meshInstance) {
				if (!meshInstance) {
						return false;
				}
				return meshInstance.node.name.indexOf('plane') !== -1;
		}
		_hover(meshInstance) {
				if (this._dragging) {
						return;
				}
				this._hoverAxis = this._getAxis(meshInstance);
				this._hoverIsPlane = this._getIsPlane(meshInstance);
				var _this__shapeMap_get;
				var shape = meshInstance ? (_this__shapeMap_get = this._shapeMap.get(meshInstance)) != null ? _this__shapeMap_get : null : null;
				if (shape === this._hoverShape) {
						return;
				}
				if (this._hoverShape) {
						this._hoverShape.hover(false);
						this._hoverShape = null;
				}
				if (shape) {
						shape.hover(true);
						this._hoverShape = shape;
				}
				this.fire(Gizmo.EVENT_RENDERUPDATE);
		}
		_createRay(mouseWPos) {
				if (this._camera.projection === PROJECTION_PERSPECTIVE) {
						tmpR1.origin.copy(this._camera.entity.getPosition());
						tmpR1.direction.sub2(mouseWPos, tmpR1.origin).normalize();
						return tmpR1;
				}
				var orthoDepth = this._camera.farClip - this._camera.nearClip;
				tmpR1.origin.sub2(mouseWPos, tmpV1$8.copy(this._camera.entity.forward).mulScalar(orthoDepth));
				tmpR1.direction.copy(this._camera.entity.forward);
				return tmpR1;
		}
		_createPlane(axis, isFacing, isLine) {
				var facingDir = tmpV1$8.copy(this.facing);
				var normal = tmpP1.normal.set(0, 0, 0);
				if (isFacing) {
						normal.copy(facingDir);
				} else {
						normal[axis] = 1;
						this._rootStartRot.transformVector(normal, normal);
						if (isLine) {
								tmpV2$8.cross(normal, facingDir).normalize();
								normal.cross(tmpV2$8, normal).normalize();
						}
				}
				return tmpP1.setFromPointNormal(this._rootStartPos, normal);
		}
		_dirFromAxis(axis, dir) {
				if (axis === GIZMOAXIS_FACE) {
						dir.copy(this._camera.entity.forward).mulScalar(-1);
				} else {
						dir.set(0, 0, 0);
						dir[axis] = 1;
				}
				return dir;
		}
		_projectToAxis(point, axis) {
				tmpV1$8.set(0, 0, 0);
				tmpV1$8[axis] = 1;
				point.copy(tmpV1$8.mulScalar(tmpV1$8.dot(point)));
				var v = point[axis];
				point.set(0, 0, 0);
				point[axis] = v;
		}
		_screenToPoint(x, y, isFacing, isLine) {
				if (isFacing === void 0) isFacing = false;
				if (isLine === void 0) isLine = false;
				var mouseWPos = this._camera.screenToWorld(x, y, 1);
				var axis = this._selectedAxis;
				var ray = this._createRay(mouseWPos);
				var plane = this._createPlane(axis, isFacing, isLine);
				var point = new Vec3();
				plane.intersectsRay(ray, point);
				return point;
		}
		_drawGuideLines() {
				var gizmoPos = this.root.getPosition();
				var gizmoRot = tmpQ1$5.copy(this.root.getRotation());
				var checkAxis = this._hoverAxis || this._selectedAxis;
				var checkIsPlane = this._hoverIsPlane || this._selectedIsPlane;
				for(var i = 0; i < VEC3_AXES.length; i++){
						var axis = VEC3_AXES[i];
						if (checkAxis === GIZMOAXIS_XYZ) {
								this._drawSpanLine(gizmoPos, gizmoRot, axis);
								continue;
						}
						if (checkIsPlane) {
								if (axis !== checkAxis) {
										this._drawSpanLine(gizmoPos, gizmoRot, axis);
								}
						} else {
								if (axis === checkAxis) {
										this._drawSpanLine(gizmoPos, gizmoRot, axis);
								}
						}
				}
		}
		_drawSpanLine(pos, rot, axis) {
				tmpV1$8.set(0, 0, 0);
				tmpV1$8[axis] = 1;
				tmpV1$8.mulScalar(this._camera.farClip - this._camera.nearClip);
				tmpV2$8.copy(tmpV1$8).mulScalar(-1);
				rot.transformVector(tmpV1$8, tmpV1$8);
				rot.transformVector(tmpV2$8, tmpV2$8);
				this._app.drawLine(tmpV1$8.add(pos), tmpV2$8.add(pos), this._guideColors[axis], true);
		}
		_createTransform() {
				for(var key in this._shapes){
						var shape = this._shapes[key];
						this.root.addChild(shape.entity);
						this.intersectShapes.push(shape);
						for(var i = 0; i < shape.meshInstances.length; i++){
								this._shapeMap.set(shape.meshInstances[i], shape);
						}
				}
		}
		enableShape(shapeAxis, enabled) {
				if (!this._shapes.hasOwnProperty(shapeAxis)) {
						return;
				}
				this._shapes[shapeAxis].disabled = !enabled;
		}
		isShapeEnabled(shapeAxis) {
				if (!this._shapes.hasOwnProperty(shapeAxis)) {
						return false;
				}
				return !this._shapes[shapeAxis].disabled;
		}
		destroy() {
				super.destroy();
				for(var key in this._shapes){
						this._shapes[key].destroy();
				}
		}
		constructor(camera, layer){
				super(camera, layer), this._colorAlpha = 0.6, this._meshColors = {
						axis: {
								x: this._colorSemi(COLOR_RED),
								y: this._colorSemi(COLOR_GREEN),
								z: this._colorSemi(COLOR_BLUE),
								xyz: this._colorSemi(Color.WHITE),
								f: this._colorSemi(Color.WHITE)
						},
						hover: {
								x: COLOR_RED.clone(),
								y: COLOR_GREEN.clone(),
								z: COLOR_BLUE.clone(),
								xyz: Color.WHITE.clone(),
								f: COLOR_YELLOW.clone()
						},
						disabled: COLOR_GRAY.clone()
				}, this._guideColors = {
						x: COLOR_RED.clone(),
						y: COLOR_GREEN.clone(),
						z: COLOR_BLUE.clone(),
						f: COLOR_YELLOW.clone()
				}, this._rootStartPos = new Vec3(), this._rootStartRot = new Quat(), this._shading = false, this._shapes = {}, this._shapeMap = new Map(), this._hoverShape = null, this._hoverAxis = '', this._hoverIsPlane = false, this._noSelection = false, this._selectedAxis = '', this._selectedIsPlane = false, this._selectionStartPoint = new Vec3(), this._dragging = false, this._snap = false, this.snapIncrement = 1;
				this._app.on('prerender', ()=>{
						if (!this.root.enabled) {
								return;
						}
						this._drawGuideLines();
				});
				this.on(Gizmo.EVENT_POINTERDOWN, (x, y, meshInstance)=>{
						var shape = this._shapeMap.get(meshInstance);
						if (shape == null ? void 0 : shape.disabled) {
								return;
						}
						if (this._dragging) {
								return;
						}
						if (!meshInstance) {
								this._noSelection = true;
								return;
						}
						this._selectedAxis = this._getAxis(meshInstance);
						this._selectedIsPlane = this._getIsPlane(meshInstance);
						this._rootStartPos.copy(this.root.getPosition());
						this._rootStartRot.copy(this.root.getRotation());
						var point = this._screenToPoint(x, y);
						this._selectionStartPoint.copy(point);
						this._dragging = true;
						this.fire(TransformGizmo.EVENT_TRANSFORMSTART, point, x, y);
				});
				this.on(Gizmo.EVENT_POINTERMOVE, (x, y, meshInstance)=>{
						var shape = this._shapeMap.get(meshInstance);
						if (shape == null ? void 0 : shape.disabled) {
								return;
						}
						if (!this._noSelection) {
								this._hover(meshInstance);
						}
						if (!this._dragging) {
								return;
						}
						var point = this._screenToPoint(x, y);
						this.fire(TransformGizmo.EVENT_TRANSFORMMOVE, point, x, y);
						this._hoverAxis = '';
						this._hoverIsPlane = false;
				});
				this.on(Gizmo.EVENT_POINTERUP, (x, y, meshInstance)=>{
						this._noSelection = false;
						this._hover(meshInstance);
						if (!this._dragging) {
								return;
						}
						this._dragging = false;
						this.fire(TransformGizmo.EVENT_TRANSFORMEND);
						this._selectedAxis = '';
						this._selectedIsPlane = false;
				});
				this.on(Gizmo.EVENT_NODESDETACH, ()=>{
						this.snap = false;
						this._hoverAxis = '';
						this._hoverIsPlane = false;
						this._hover();
						this.fire(Gizmo.EVENT_POINTERUP);
				});
		}
}
TransformGizmo.EVENT_TRANSFORMSTART = 'transform:start';
TransformGizmo.EVENT_TRANSFORMMOVE = 'transform:move';
TransformGizmo.EVENT_TRANSFORMEND = 'transform:end';

var tmpV1$7 = new Vec3();
var tmpV2$7 = new Vec3();
var tmpV3$4 = new Vec3();
class TriData {
		get transform() {
				return this._transform;
		}
		get priority() {
				return this._priority;
		}
		setTransform(pos, rot, scale) {
				if (pos === void 0) pos = new Vec3();
				if (rot === void 0) rot = new Quat();
				if (scale === void 0) scale = new Vec3();
				this.transform.setTRS(pos, rot, scale);
		}
		fromGeometry(geometry) {
				if (!geometry || !(geometry instanceof Geometry)) {
						throw new Error('No geometry provided.');
				}
				var _geometry_positions;
				var positions = (_geometry_positions = geometry.positions) != null ? _geometry_positions : [];
				var _geometry_indices;
				var indices = (_geometry_indices = geometry.indices) != null ? _geometry_indices : [];
				this.tris = [];
				for(var k = 0; k < indices.length; k += 3){
						var i1 = indices[k];
						var i2 = indices[k + 1];
						var i3 = indices[k + 2];
						tmpV1$7.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
						tmpV2$7.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
						tmpV3$4.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
						var tri = new Tri(tmpV1$7, tmpV2$7, tmpV3$4);
						this.tris.push(tri);
				}
		}
		constructor(geometry, priority = 0){
				this._priority = 0;
				this._transform = new Mat4();
				this.tris = [];
				this.fromGeometry(geometry);
				this._priority = priority;
		}
}

var SHADING_DAMP_SCALE = 0.25;
var SHADING_DAMP_OFFSET = 0.75;
var LIGHT_DIR = new Vec3(1, 2, 3);
var GEOMETRIES = {
		box: BoxGeometry,
		cone: ConeGeometry,
		cylinder: CylinderGeometry,
		plane: PlaneGeometry,
		sphere: SphereGeometry,
		torus: TorusGeometry
};
var shaderDesc = {
		uniqueName: 'axis-shape',
		attributes: {
				vertex_position: SEMANTIC_POSITION,
				vertex_color: SEMANTIC_COLOR
		},
		vertexCode: "\n		attribute vec3 vertex_position;\n		attribute vec4 vertex_color;\n		varying vec4 vColor;\n		uniform mat4 matrix_model;\n		uniform mat4 matrix_viewProjection;\n		void main(void) {\n			gl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1.0);\n			gl_Position.z = clamp(gl_Position.z, -abs(gl_Position.w), abs(gl_Position.w));\n			vColor = vertex_color;\n		}\n	",
		fragmentCode: '\n		#include "gammaPS"\n		precision highp float;\n		varying vec4 vColor;\n		void main(void) {\n			gl_FragColor = vec4(gammaCorrectOutput(decodeGamma(vColor)), vColor.w);\n		}\n	'
};
var shadingMeshMap = new Map();
var tmpV1$6 = new Vec3();
var tmpV2$6 = new Vec3();
var tmpM1$2 = new Mat4();
var tmpG = new Geometry();
tmpG.positions = [];
tmpG.normals = [];
var applyShadowColor = (geom, color, transform)=>{
		if (!geom.normals || !geom.positions) {
				return [];
		}
		var localLightDir;
		if (transform) {
				localLightDir = tmpM1$2.copy(transform).invert().transformVector(tmpV1$6.copy(LIGHT_DIR), tmpV1$6).normalize();
		}
		geom.colors = [];
		var shading = [];
		var numVertices = geom.positions.length / 3;
		for(var i = 0; i < numVertices; i++){
				var strength = 1;
				if (localLightDir) {
						var x = geom.normals[i * 3];
						var y = geom.normals[i * 3 + 1];
						var z = geom.normals[i * 3 + 2];
						var normal = tmpV2$6.set(x, y, z);
						var dot = localLightDir.dot(normal);
						strength = dot * SHADING_DAMP_SCALE + SHADING_DAMP_OFFSET;
				}
				shading.push(strength);
				geom.colors.push(strength * color.r * 0xFF, strength * color.g * 0xFF, strength * color.b * 0xFF, color.a * 0xFF);
		}
		return shading;
};
var setMeshColor = (mesh, color)=>{
		var shading = shadingMeshMap.get(mesh);
		var colors = [];
		for(var i = 0; i < shading.length; i++){
				colors.push(shading[i] * color.r * 0xFF, shading[i] * color.g * 0xFF, shading[i] * color.b * 0xFF, color.a * 0xFF);
		}
		mesh.setColors32(colors);
		mesh.update();
};
class Shape {
		set disabled(value) {
				for(var i = 0; i < this.meshInstances.length; i++){
						setMeshColor(this.meshInstances[i].mesh, value ? this._disabledColor : this._defaultColor);
				}
				this._disabled = value != null ? value : false;
		}
		get disabled() {
				return this._disabled;
		}
		set shading(value) {
				this._shading = value != null ? value : true;
				var color = this._disabled ? this._disabledColor : this._defaultColor;
				for(var i = 0; i < this.meshInstances.length; i++){
						var mesh = this.meshInstances[i].mesh;
						mesh.getPositions(tmpG.positions);
						mesh.getNormals(tmpG.normals);
						var shadow = applyShadowColor(tmpG, color, this._shading ? this.entity.getWorldTransform() : undefined);
						shadingMeshMap.set(mesh, shadow);
						setMeshColor(mesh, color);
				}
		}
		get shading() {
				return this._shading;
		}
		_createRoot(name) {
				this.entity = new Entity(name + ":" + this.axis);
				this.entity.setLocalPosition(this._position);
				this.entity.setLocalEulerAngles(this._rotation);
				this.entity.setLocalScale(this._scale);
		}
		_createMesh(geom, shading) {
				if (shading === void 0) shading = true;
				var color = this._disabled ? this._disabledColor : this._defaultColor;
				var shadow = applyShadowColor(geom, color, shading ? this.entity.getWorldTransform() : undefined);
				var mesh = Mesh.fromGeometry(this.device, geom);
				shadingMeshMap.set(mesh, shadow);
				return mesh;
		}
		_createRenderComponent(entity, meshes) {
				var material = new ShaderMaterial(shaderDesc);
				material.cull = this._cull;
				material.blendType = BLEND_NORMAL;
				material.update();
				var meshInstances = [];
				for(var i = 0; i < meshes.length; i++){
						var mi = new MeshInstance(meshes[i], material);
						mi.cull = false;
						meshInstances.push(mi);
						this.meshInstances.push(mi);
				}
				entity.addComponent('render', {
						meshInstances: meshInstances,
						layers: this._layers,
						castShadows: false
				});
		}
		_addRenderMesh(entity, type, shading) {
				var _$Geometry = GEOMETRIES[type];
				if (!_$Geometry) {
						throw new Error('Invalid primitive type.');
				}
				this._createRenderComponent(entity, [
						this._createMesh(new _$Geometry(), shading)
				]);
		}
		hover(state) {
				if (this._disabled) {
						return;
				}
				for(var i = 0; i < this.meshInstances.length; i++){
						var color = state ? this._hoverColor : this._defaultColor;
						var mesh = this.meshInstances[i].mesh;
						setMeshColor(mesh, color);
				}
		}
		destroy() {
				this.entity.destroy();
		}
		constructor(device, options){
				this._layers = [];
				this._shading = true;
				this._defaultColor = Color.WHITE;
				this._hoverColor = Color.BLACK;
				this._disabledColor = COLOR_GRAY;
				this._cull = CULLFACE_BACK;
				this.triData = [];
				this.meshInstances = [];
				this.device = device;
				var _options_axis;
				this.axis = (_options_axis = options.axis) != null ? _options_axis : 'x';
				var _options_position;
				this._position = (_options_position = options.position) != null ? _options_position : new Vec3();
				var _options_rotation;
				this._rotation = (_options_rotation = options.rotation) != null ? _options_rotation : new Vec3();
				var _options_scale;
				this._scale = (_options_scale = options.scale) != null ? _options_scale : new Vec3(1, 1, 1);
				var _options_disabled;
				this._disabled = (_options_disabled = options.disabled) != null ? _options_disabled : false;
				var _options_layers;
				this._layers = (_options_layers = options.layers) != null ? _options_layers : this._layers;
				var _options_shading;
				this._shading = (_options_shading = options.shading) != null ? _options_shading : this._shading;
				if (options.defaultColor instanceof Color) {
						this._defaultColor = options.defaultColor;
				}
				if (options.hoverColor instanceof Color) {
						this._hoverColor = options.hoverColor;
				}
				if (options.disabledColor instanceof Color) {
						this._disabledColor = options.disabledColor;
				}
		}
}

var UPDATE_EPSILON = 1e-6;
class PlaneShape extends Shape {
		set size(value) {
				this._size = value != null ? value : 1;
				this._updateTransform();
		}
		get size() {
				return this._size;
		}
		set gap(value) {
				this._gap = value != null ? value : 0;
				this._updateTransform();
		}
		get gap() {
				return this._gap;
		}
		set flipped(value) {
				if (this._flipped.distance(value) < UPDATE_EPSILON) {
						return;
				}
				this._flipped.copy(value);
				this.entity.setLocalPosition(this._getPosition());
		}
		get flipped() {
				return this._flipped;
		}
		_getPosition() {
				var offset = this._size / 2 + this._gap;
				var position = new Vec3(this._flipped.x ? -offset : offset, this._flipped.y ? -offset : offset, this._flipped.z ? -offset : offset);
				position[this.axis] = 0;
				return position;
		}
		_createPlane() {
				this._createRoot('plane');
				this._updateTransform();
				this._addRenderMesh(this.entity, 'plane', this._shading);
		}
		_updateTransform() {
				this.entity.setLocalPosition(this._getPosition());
				this.entity.setLocalEulerAngles(this._rotation);
				this.entity.setLocalScale(this._size, this._size, this._size);
		}
		constructor(device, options = {}){
				super(device, options), this._cull = CULLFACE_NONE, this._size = 0.2, this._gap = 0.1, this._flipped = new Vec3();
				this.triData = [
						new TriData(new PlaneGeometry())
				];
				this._createPlane();
		}
}

var tmpV1$5 = new Vec3();
var tmpV2$5 = new Vec3();
var tmpQ1$4 = new Quat();
class ArrowShape extends Shape {
		set gap(value) {
				this._gap = value != null ? value : 0;
				this._updateHead();
				this._updateLine();
		}
		get gap() {
				return this._gap;
		}
		set lineThickness(value) {
				this._lineThickness = value != null ? value : 1;
				this._updateHead();
				this._updateLine();
		}
		get lineThickness() {
				return this._lineThickness;
		}
		set lineLength(value) {
				this._lineLength = value != null ? value : 1;
				this._updateHead();
				this._updateLine();
		}
		get lineLength() {
				return this._lineLength;
		}
		set arrowThickness(value) {
				this._arrowThickness = value != null ? value : 1;
				this._updateHead();
		}
		get arrowThickness() {
				return this._arrowThickness;
		}
		set arrowLength(value) {
				this._arrowLength = value != null ? value : 1;
				this._updateHead();
		}
		get arrowLength() {
				return this._arrowLength;
		}
		set tolerance(value) {
				this._tolerance = value;
				this._updateLine();
		}
		get tolerance() {
				return this._tolerance;
		}
		set flipped(value) {
				if (this._flipped === value) {
						return;
				}
				this._flipped = value;
				if (this._rotation.equals(Vec3.ZERO)) {
						tmpV1$5.set(0, 0, this._flipped ? 180 : 0);
				} else {
						tmpV1$5.copy(this._rotation).mulScalar(this._flipped ? -1 : 1);
				}
				this._line.enabled = !this._flipped;
				this.entity.setLocalEulerAngles(tmpV1$5);
		}
		get flipped() {
				return this._flipped;
		}
		_createArrow() {
				this._createRoot('arrow');
				this._head = new Entity("head:" + this.axis);
				this.entity.addChild(this._head);
				this._updateHead();
				this._addRenderMesh(this._head, 'cone', this._shading);
				this._line = new Entity("line:" + this.axis);
				this.entity.addChild(this._line);
				this._updateLine();
				this._addRenderMesh(this._line, 'cylinder', this._shading);
		}
		_updateHead() {
				tmpV1$5.set(0, this._gap + this._arrowLength * 0.5 + this._lineLength, 0);
				tmpQ1$4.set(0, 0, 0, 1);
				tmpV2$5.set(this._arrowThickness, this._arrowLength, this._arrowThickness);
				this.triData[0].setTransform(tmpV1$5, tmpQ1$4, tmpV2$5);
				this._head.setLocalPosition(0, this._gap + this._arrowLength * 0.5 + this._lineLength, 0);
				this._head.setLocalScale(this._arrowThickness, this._arrowLength, this._arrowThickness);
		}
		_updateLine() {
				tmpV1$5.set(0, this._gap + this._lineLength * 0.5, 0);
				tmpQ1$4.set(0, 0, 0, 1);
				tmpV2$5.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
				this.triData[1].setTransform(tmpV1$5, tmpQ1$4, tmpV2$5);
				this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
				this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
		}
		constructor(device, options = {}){
				super(device, options), this._gap = 0, this._lineThickness = 0.02, this._lineLength = 0.5, this._arrowThickness = 0.12, this._arrowLength = 0.18, this._tolerance = 0.1, this._flipped = false;
				this.triData = [
						new TriData(new ConeGeometry()),
						new TriData(new CylinderGeometry(), 1)
				];
				this._createArrow();
		}
}

class SphereShape extends Shape {
		_createCenter() {
				this._createRoot('sphereCenter');
				this._updateTransform();
				this._addRenderMesh(this.entity, 'sphere', this._shading);
		}
		set size(value) {
				this._size = value != null ? value : 1;
				this._updateTransform();
		}
		get size() {
				return this._size;
		}
		set tolerance(value) {
				this._tolerance = value;
				this._updateTransform();
		}
		get tolerance() {
				return this._tolerance;
		}
		_updateTransform() {
				this.entity.setLocalScale(this._size, this._size, this._size);
		}
		constructor(device, options = {}){
				super(device, options), this._size = 0.12, this._tolerance = 0.05;
				this.triData = [
						new TriData(new SphereGeometry(), 2)
				];
				this._createCenter();
		}
}

var tmpV1$4 = new Vec3();
var tmpV2$4 = new Vec3();
var tmpV3$3 = new Vec3();
var tmpQ1$3 = new Quat();
var GLANCE_EPSILON$1 = 0.98;
class TranslateGizmo extends TransformGizmo {
		set axisGap(value) {
				this._setArrowProp('gap', value);
		}
		get axisGap() {
				return this._shapes.x.gap;
		}
		set axisLineThickness(value) {
				this._setArrowProp('lineThickness', value);
		}
		get axisLineThickness() {
				return this._shapes.x.lineThickness;
		}
		set axisLineLength(value) {
				this._setArrowProp('lineLength', value);
		}
		get axisLineLength() {
				return this._shapes.x.lineLength;
		}
		set axisLineTolerance(value) {
				this._setArrowProp('tolerance', value);
		}
		get axisLineTolerance() {
				return this._shapes.x.tolerance;
		}
		set axisArrowThickness(value) {
				this._setArrowProp('arrowThickness', value);
		}
		get axisArrowThickness() {
				return this._shapes.x.arrowThickness;
		}
		set axisArrowLength(value) {
				this._setArrowProp('arrowLength', value);
		}
		get axisArrowLength() {
				return this._shapes.x.arrowLength;
		}
		set axisPlaneSize(value) {
				this._setPlaneProp('size', value);
		}
		get axisPlaneSize() {
				return this._shapes.yz.size;
		}
		set axisPlaneGap(value) {
				this._setPlaneProp('gap', value);
		}
		get axisPlaneGap() {
				return this._shapes.yz.gap;
		}
		set axisCenterSize(value) {
				this._shapes.face.size = value;
		}
		get axisCenterSize() {
				return this._shapes.face.size;
		}
		set axisCenterTolerance(value) {
				this._shapes.face.tolerance = value;
		}
		get axisCenterTolerance() {
				return this._shapes.face.tolerance;
		}
		_setArrowProp(prop, value) {
				this._shapes.x[prop] = value;
				this._shapes.y[prop] = value;
				this._shapes.z[prop] = value;
		}
		_setPlaneProp(prop, value) {
				this._shapes.yz[prop] = value;
				this._shapes.xz[prop] = value;
				this._shapes.xy[prop] = value;
		}
		_shapesLookAtCamera() {
				var facingDir = this.facing;
				var dot = facingDir.dot(this.root.right);
				this._shapes.x.entity.enabled = Math.abs(dot) < GLANCE_EPSILON$1;
				if (this.flipShapes) {
						this._shapes.x.flipped = dot < 0;
				}
				dot = facingDir.dot(this.root.up);
				this._shapes.y.entity.enabled = Math.abs(dot) < GLANCE_EPSILON$1;
				if (this.flipShapes) {
						this._shapes.y.flipped = dot < 0;
				}
				dot = facingDir.dot(this.root.forward);
				this._shapes.z.entity.enabled = Math.abs(dot) < GLANCE_EPSILON$1;
				if (this.flipShapes) {
						this._shapes.z.flipped = dot > 0;
				}
				tmpV1$4.cross(facingDir, this.root.right);
				this._shapes.yz.entity.enabled = tmpV1$4.length() < GLANCE_EPSILON$1;
				if (this.flipShapes) {
						this._shapes.yz.flipped = tmpV2$4.set(0, +(tmpV1$4.dot(this.root.forward) < 0), +(tmpV1$4.dot(this.root.up) < 0));
				}
				tmpV1$4.cross(facingDir, this.root.forward);
				this._shapes.xy.entity.enabled = tmpV1$4.length() < GLANCE_EPSILON$1;
				if (this.flipShapes) {
						this._shapes.xy.flipped = tmpV2$4.set(+(tmpV1$4.dot(this.root.up) < 0), +(tmpV1$4.dot(this.root.right) > 0), 0);
				}
				tmpV1$4.cross(facingDir, this.root.up);
				this._shapes.xz.entity.enabled = tmpV1$4.length() < GLANCE_EPSILON$1;
				if (this.flipShapes) {
						this._shapes.xz.flipped = tmpV2$4.set(+(tmpV1$4.dot(this.root.forward) > 0), 0, +(tmpV1$4.dot(this.root.right) > 0));
				}
		}
		_storeNodePositions() {
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						this._nodeLocalPositions.set(node, node.getLocalPosition().clone());
						this._nodePositions.set(node, node.getPosition().clone());
				}
		}
		_setNodePositions(pointDelta) {
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						if (this._coordSpace === GIZMOSPACE_LOCAL) {
								var _node_parent;
								var pos = this._nodeLocalPositions.get(node);
								if (!pos) {
										continue;
								}
								tmpV1$4.copy(pointDelta);
								(_node_parent = node.parent) == null ? void 0 : _node_parent.getWorldTransform().getScale(tmpV2$4);
								tmpV2$4.x = 1 / tmpV2$4.x;
								tmpV2$4.y = 1 / tmpV2$4.y;
								tmpV2$4.z = 1 / tmpV2$4.z;
								tmpQ1$3.copy(node.getLocalRotation()).transformVector(tmpV1$4, tmpV1$4);
								tmpV1$4.mul(tmpV2$4);
								node.setLocalPosition(tmpV1$4.add(pos));
						} else {
								var pos1 = this._nodePositions.get(node);
								if (!pos1) {
										continue;
								}
								node.setPosition(tmpV1$4.copy(pointDelta).add(pos1));
						}
				}
				this._updatePosition();
		}
		_screenToPoint(x, y) {
				var mouseWPos = this._camera.screenToWorld(x, y, 1);
				var axis = this._selectedAxis;
				var isPlane = this._selectedIsPlane;
				var ray = this._createRay(mouseWPos);
				var plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, !isPlane);
				var point = new Vec3();
				plane.intersectsRay(ray, point);
				tmpQ1$3.copy(this._rootStartRot).invert().transformVector(point, point);
				if (!isPlane && axis !== GIZMOAXIS_FACE) {
						this._projectToAxis(point, axis);
				}
				return point;
		}
		constructor(camera, layer){
				super(camera, layer), this._shapes = {
						face: new SphereShape(this._device, {
								axis: GIZMOAXIS_FACE,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								defaultColor: this._meshColors.axis.xyz,
								hoverColor: this._meshColors.hover.xyz
						}),
						yz: new PlaneShape(this._device, {
								axis: GIZMOAXIS_X,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._meshColors.axis.x,
								hoverColor: this._meshColors.hover.x
						}),
						xz: new PlaneShape(this._device, {
								axis: GIZMOAXIS_Y,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._meshColors.axis.y,
								hoverColor: this._meshColors.hover.y
						}),
						xy: new PlaneShape(this._device, {
								axis: GIZMOAXIS_Z,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(90, 0, 0),
								defaultColor: this._meshColors.axis.z,
								hoverColor: this._meshColors.hover.z
						}),
						x: new ArrowShape(this._device, {
								axis: GIZMOAXIS_X,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._meshColors.axis.x,
								hoverColor: this._meshColors.hover.x
						}),
						y: new ArrowShape(this._device, {
								axis: GIZMOAXIS_Y,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._meshColors.axis.y,
								hoverColor: this._meshColors.hover.y
						}),
						z: new ArrowShape(this._device, {
								axis: GIZMOAXIS_Z,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(90, 0, 0),
								defaultColor: this._meshColors.axis.z,
								hoverColor: this._meshColors.hover.z
						})
				}, this._nodeLocalPositions = new Map(), this._nodePositions = new Map(), this.snapIncrement = 1, this.flipShapes = true;
				this._createTransform();
				this.on(TransformGizmo.EVENT_TRANSFORMSTART, ()=>{
						this._storeNodePositions();
				});
				this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (point)=>{
						var pointDelta = tmpV3$3.copy(point).sub(this._selectionStartPoint);
						if (this.snap) {
								pointDelta.mulScalar(1 / this.snapIncrement);
								pointDelta.round();
								pointDelta.mulScalar(this.snapIncrement);
						}
						this._setNodePositions(pointDelta);
				});
				this.on(TransformGizmo.EVENT_NODESDETACH, ()=>{
						this._nodeLocalPositions.clear();
						this._nodePositions.clear();
				});
				this._app.on('prerender', ()=>{
						this._shapesLookAtCamera();
				});
		}
}

var TORUS_RENDER_SEGMENTS = 80;
var TORUS_INTERSECT_SEGMENTS = 20;
class ArcShape extends Shape {
		_createTorusGeometry() {
				return new TorusGeometry({
						tubeRadius: this._tubeRadius + this._tolerance,
						ringRadius: this._ringRadius,
						sectorAngle: this._sectorAngle,
						segments: TORUS_INTERSECT_SEGMENTS
				});
		}
		_createTorusMesh(sectorAngle) {
				var geom = new TorusGeometry({
						tubeRadius: this._tubeRadius,
						ringRadius: this._ringRadius,
						sectorAngle: sectorAngle,
						segments: TORUS_RENDER_SEGMENTS
				});
				return this._createMesh(geom, this._shading);
		}
		_createDisk() {
				this._createRoot('disk');
				this._createRenderComponent(this.entity, [
						this._createTorusMesh(this._sectorAngle),
						this._createTorusMesh(360)
				]);
				this.drag(false);
		}
		set tubeRadius(value) {
				this._tubeRadius = value != null ? value : 0.1;
				this._updateTransform();
		}
		get tubeRadius() {
				return this._tubeRadius;
		}
		set ringRadius(value) {
				this._ringRadius = value != null ? value : 0.1;
				this._updateTransform();
		}
		get ringRadius() {
				return this._ringRadius;
		}
		set tolerance(value) {
				this._tolerance = value;
				this._updateTransform();
		}
		get tolerance() {
				return this._tolerance;
		}
		_updateTransform() {
				this.triData[0].fromGeometry(this._createTorusGeometry());
				this.meshInstances[0].mesh = this._createTorusMesh(this._sectorAngle);
				this.meshInstances[1].mesh = this._createTorusMesh(360);
		}
		drag(state) {
				this.meshInstances[0].visible = !state;
				this.meshInstances[1].visible = state;
		}
		hide(state) {
				if (state) {
						this.meshInstances[0].visible = false;
						this.meshInstances[1].visible = false;
						return;
				}
				this.drag(false);
		}
		constructor(device, options = {}){
				super(device, options), this._tubeRadius = 0.01, this._ringRadius = 0.5, this._tolerance = 0.05;
				var _options_tubeRadius;
				this._tubeRadius = (_options_tubeRadius = options.tubeRadius) != null ? _options_tubeRadius : this._tubeRadius;
				var _options_ringRadius;
				this._ringRadius = (_options_ringRadius = options.ringRadius) != null ? _options_ringRadius : this._ringRadius;
				var _options_sectorAngle;
				this._sectorAngle = (_options_sectorAngle = options.sectorAngle) != null ? _options_sectorAngle : this._sectorAngle;
				this.triData = [
						new TriData(this._createTorusGeometry())
				];
				this._createDisk();
		}
}

var tmpV1$3 = new Vec3();
var tmpV2$3 = new Vec3();
var tmpV3$2 = new Vec3();
var tmpV4 = new Vec3();
var tmpM1$1 = new Mat4();
var tmpQ1$2 = new Quat();
var tmpQ2 = new Quat();
var FACING_THRESHOLD = 0.9;
var GUIDE_ANGLE_COLOR = new Color(0, 0, 0, 0.3);
class RotateGizmo extends TransformGizmo {
		set xyzTubeRadius(value) {
				this._setDiskProp('tubeRadius', value);
		}
		get xyzTubeRadius() {
				return this._shapes.x.tubeRadius;
		}
		set xyzRingRadius(value) {
				this._setDiskProp('ringRadius', value);
		}
		get xyzRingRadius() {
				return this._shapes.x.ringRadius;
		}
		set faceTubeRadius(value) {
				this._shapes.face.tubeRadius = value;
		}
		get faceTubeRadius() {
				return this._shapes.face.tubeRadius;
		}
		set faceRingRadius(value) {
				this._shapes.face.ringRadius = value;
		}
		get faceRingRadius() {
				return this._shapes.face.ringRadius;
		}
		set ringTolerance(value) {
				this._setDiskProp('tolerance', value);
				this._shapes.face.tolerance = value;
		}
		get ringTolerance() {
				return this._shapes.x.tolerance;
		}
		_setDiskProp(prop, value) {
				this._shapes.x[prop] = value;
				this._shapes.y[prop] = value;
				this._shapes.z[prop] = value;
		}
		_storeGuidePoints() {
				var gizmoPos = this.root.getPosition();
				var axis = this._selectedAxis;
				var isFacing = axis === GIZMOAXIS_FACE;
				var scale = isFacing ? this.faceRingRadius : this.xyzRingRadius;
				this._guideAngleStart.copy(this._selectionStartPoint).sub(gizmoPos).normalize();
				this._guideAngleStart.mulScalar(scale);
				this._guideAngleEnd.copy(this._guideAngleStart);
		}
		_updateGuidePoints(angleDelta) {
				var axis = this._selectedAxis;
				var isFacing = axis === GIZMOAXIS_FACE;
				if (isFacing) {
						tmpV1$3.copy(this.facing);
				} else {
						tmpV1$3.set(0, 0, 0);
						tmpV1$3[axis] = 1;
						this._rootStartRot.transformVector(tmpV1$3, tmpV1$3);
				}
				tmpQ1$2.setFromAxisAngle(tmpV1$3, angleDelta);
				tmpQ1$2.transformVector(this._guideAngleStart, this._guideAngleEnd);
		}
		_drawGuideAngleLine(pos, axis, point, color) {
				if (color === void 0) color = this._guideColors[axis];
				tmpV1$3.set(0, 0, 0);
				tmpV2$3.copy(point).mulScalar(this._scale);
				this._app.drawLine(tmpV1$3.add(pos), tmpV2$3.add(pos), color, false, this._layer);
		}
		_getLookAtEulerAngles(position) {
				tmpV1$3.set(0, 0, 0);
				tmpM1$1.setLookAt(tmpV1$3, position, Vec3.UP);
				tmpQ1$2.setFromMat4(tmpM1$1);
				tmpQ1$2.getEulerAngles(tmpV1$3);
				tmpV1$3.x += 90;
				return tmpV1$3;
		}
		_shapesLookAtCamera() {
				if (this._camera.projection === PROJECTION_PERSPECTIVE) {
						this._shapes.face.entity.lookAt(this._camera.entity.getPosition());
						this._shapes.face.entity.rotateLocal(90, 0, 0);
				} else {
						tmpQ1$2.copy(this._camera.entity.getRotation()).getEulerAngles(tmpV1$3);
						this._shapes.face.entity.setEulerAngles(tmpV1$3);
						this._shapes.face.entity.rotateLocal(-90, 0, 0);
				}
				var facingDir = tmpV1$3.copy(this.facing);
				tmpQ1$2.copy(this.root.getRotation()).invert().transformVector(facingDir, facingDir);
				var angle = Math.atan2(facingDir.z, facingDir.y) * math.RAD_TO_DEG;
				this._shapes.x.entity.setLocalEulerAngles(0, angle - 90, -90);
				angle = Math.atan2(facingDir.x, facingDir.z) * math.RAD_TO_DEG;
				this._shapes.y.entity.setLocalEulerAngles(0, angle, 0);
				angle = Math.atan2(facingDir.y, facingDir.x) * math.RAD_TO_DEG;
				this._shapes.z.entity.setLocalEulerAngles(90, 0, angle + 90);
		}
		_drag(state) {
				for(var axis in this._shapes){
						var shape = this._shapes[axis];
						if (axis === this._selectedAxis) {
								shape.drag(state);
						} else {
								shape.hide(state);
						}
				}
				this.fire(TransformGizmo.EVENT_RENDERUPDATE);
		}
		_storeNodeRotations() {
				var gizmoPos = this.root.getPosition();
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						this._nodeLocalRotations.set(node, node.getLocalRotation().clone());
						this._nodeRotations.set(node, node.getRotation().clone());
						this._nodeOffsets.set(node, node.getPosition().clone().sub(gizmoPos));
				}
		}
		_setNodeRotations(axis, angleDelta) {
				var gizmoPos = this.root.getPosition();
				var isFacing = axis === GIZMOAXIS_FACE;
				tmpQ1$2.setFromAxisAngle(this._dirFromAxis(axis, tmpV1$3), angleDelta);
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						if (!isFacing && this._coordSpace === GIZMOSPACE_LOCAL) {
								var rot = this._nodeLocalRotations.get(node);
								if (!rot) {
										continue;
								}
								tmpQ2.copy(rot).mul(tmpQ1$2);
								node.setLocalRotation(tmpQ2);
						} else {
								var rot1 = this._nodeRotations.get(node);
								if (!rot1) {
										continue;
								}
								var offset = this._nodeOffsets.get(node);
								if (!offset) {
										continue;
								}
								tmpV1$3.copy(offset);
								tmpQ1$2.transformVector(tmpV1$3, tmpV1$3);
								tmpQ2.copy(tmpQ1$2).mul(rot1);
								node.setEulerAngles(tmpQ2.getEulerAngles());
								node.setPosition(tmpV1$3.add(gizmoPos));
						}
				}
				if (this._coordSpace === GIZMOSPACE_LOCAL) {
						this._updateRotation();
				}
		}
		_screenToPoint(x, y) {
				var mouseWPos = this._camera.screenToWorld(x, y, 1);
				var axis = this._selectedAxis;
				var ray = this._createRay(mouseWPos);
				var plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, false);
				var point = new Vec3();
				plane.intersectsRay(ray, point);
				return point;
		}
		_calculateAngle(point, x, y) {
				var gizmoPos = this.root.getPosition();
				var axis = this._selectedAxis;
				var plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, false);
				var angle = 0;
				var facingDir = tmpV2$3.copy(this.facing);
				var facingDot = plane.normal.dot(facingDir);
				if (this.orbitRotation || Math.abs(facingDot) > FACING_THRESHOLD) {
						tmpV1$3.sub2(point, gizmoPos);
						tmpQ1$2.copy(this._camera.entity.getRotation()).invert().transformVector(tmpV1$3, tmpV1$3);
						angle = Math.sign(facingDot) * Math.atan2(tmpV1$3.y, tmpV1$3.x) * math.RAD_TO_DEG;
				} else {
						tmpV1$3.copy(gizmoPos);
						tmpV2$3.cross(plane.normal, facingDir).normalize().add(gizmoPos);
						this._camera.worldToScreen(tmpV1$3, tmpV3$2);
						this._camera.worldToScreen(tmpV2$3, tmpV4);
						tmpV1$3.sub2(tmpV4, tmpV3$2).normalize();
						tmpV2$3.set(x, y, 0);
						angle = tmpV1$3.dot(tmpV2$3);
				}
				return angle;
		}
		constructor(camera, layer){
				super(camera, layer), this._shapes = {
						z: new ArcShape(this._device, {
								axis: GIZMOAXIS_Z,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(90, 0, 90),
								defaultColor: this._meshColors.axis.z,
								hoverColor: this._meshColors.hover.z,
								sectorAngle: 180
						}),
						x: new ArcShape(this._device, {
								axis: GIZMOAXIS_X,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._meshColors.axis.x,
								hoverColor: this._meshColors.hover.x,
								sectorAngle: 180
						}),
						y: new ArcShape(this._device, {
								axis: GIZMOAXIS_Y,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._meshColors.axis.y,
								hoverColor: this._meshColors.hover.y,
								sectorAngle: 180
						}),
						face: new ArcShape(this._device, {
								axis: GIZMOAXIS_FACE,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: this._getLookAtEulerAngles(this._camera.entity.getPosition()),
								defaultColor: this._meshColors.axis.f,
								hoverColor: this._meshColors.hover.f,
								ringRadius: 0.55
						})
				}, this._selectionStartAngle = 0, this._nodeLocalRotations = new Map(), this._nodeRotations = new Map(), this._nodeOffsets = new Map(), this._guideAngleStartColor = GUIDE_ANGLE_COLOR.clone(), this._guideAngleStart = new Vec3(), this._guideAngleEnd = new Vec3(), this.snapIncrement = 5, this.orbitRotation = false;
				this._createTransform();
				this.on(TransformGizmo.EVENT_TRANSFORMSTART, (point, x, y)=>{
						this._selectionStartAngle = this._calculateAngle(point, x, y);
						this._storeNodeRotations();
						this._storeGuidePoints();
						this._drag(true);
				});
				this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (point, x, y)=>{
						var axis = this._selectedAxis;
						var angleDelta = this._calculateAngle(point, x, y) - this._selectionStartAngle;
						if (this.snap) {
								angleDelta = Math.round(angleDelta / this.snapIncrement) * this.snapIncrement;
						}
						this._setNodeRotations(axis, angleDelta);
						this._updateGuidePoints(angleDelta);
				});
				this.on(TransformGizmo.EVENT_TRANSFORMEND, ()=>{
						this._drag(false);
				});
				this.on(TransformGizmo.EVENT_NODESDETACH, ()=>{
						this._nodeLocalRotations.clear();
						this._nodeRotations.clear();
						this._nodeOffsets.clear();
				});
				this._app.on('prerender', ()=>{
						this._shapesLookAtCamera();
						if (this._dragging) {
								var gizmoPos = this.root.getPosition();
								this._drawGuideAngleLine(gizmoPos, this._selectedAxis, this._guideAngleStart, this._guideAngleStartColor);
								this._drawGuideAngleLine(gizmoPos, this._selectedAxis, this._guideAngleEnd);
						}
				});
		}
}

class BoxShape extends Shape {
		_createCenter() {
				this._createRoot('boxCenter');
				this._updateTransform();
				this._addRenderMesh(this.entity, 'box', this._shading);
		}
		set size(value) {
				this._size = value != null ? value : 1;
				this._updateTransform();
		}
		get size() {
				return this._size;
		}
		set tolerance(value) {
				this._tolerance = value;
				this._updateTransform();
		}
		get tolerance() {
				return this._tolerance;
		}
		_updateTransform() {
				this.entity.setLocalScale(this._size, this._size, this._size);
		}
		constructor(device, options = {}){
				super(device, options), this._size = 0.12, this._tolerance = 0.05;
				this.triData = [
						new TriData(new BoxGeometry(), 2)
				];
				this._createCenter();
		}
}

var tmpV1$2 = new Vec3();
var tmpV2$2 = new Vec3();
var tmpQ1$1 = new Quat();
class BoxLineShape extends Shape {
		set gap(value) {
				this._gap = value != null ? value : 0;
				this._updateLine();
				this._updateBox();
		}
		get gap() {
				return this._gap;
		}
		set lineThickness(value) {
				this._lineThickness = value != null ? value : 1;
				this._updateLine();
				this._updateBox();
		}
		get lineThickness() {
				return this._lineThickness;
		}
		set lineLength(value) {
				this._lineLength = value != null ? value : 1;
				this._updateLine();
				this._updateBox();
		}
		get lineLength() {
				return this._lineLength;
		}
		set boxSize(value) {
				this._boxSize = value != null ? value : 1;
				this._updateBox();
		}
		get boxSize() {
				return this._boxSize;
		}
		set tolerance(value) {
				this._tolerance = value;
				this._updateLine();
		}
		get tolerance() {
				return this._tolerance;
		}
		set flipped(value) {
				if (this._flipped === value) {
						return;
				}
				this._flipped = value;
				if (this._rotation.equals(Vec3.ZERO)) {
						tmpV1$2.set(0, 0, this._flipped ? 180 : 0);
				} else {
						tmpV1$2.copy(this._rotation).mulScalar(this._flipped ? -1 : 1);
				}
				this._line.enabled = !this._flipped;
				this.entity.setLocalEulerAngles(tmpV1$2);
		}
		get flipped() {
				return this._flipped;
		}
		_createBoxLine() {
				this._createRoot('boxLine');
				this._box = new Entity("box:" + this.axis);
				this.entity.addChild(this._box);
				this._updateBox();
				this._addRenderMesh(this._box, 'box', this._shading);
				this._line = new Entity("line:" + this.axis);
				this.entity.addChild(this._line);
				this._updateLine();
				this._addRenderMesh(this._line, 'cylinder', this._shading);
		}
		_updateBox() {
				tmpV1$2.set(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
				tmpQ1$1.set(0, 0, 0, 1);
				tmpV2$2.set(this._boxSize, this._boxSize, this._boxSize);
				this.triData[0].setTransform(tmpV1$2, tmpQ1$1, tmpV2$2);
				this._box.setLocalPosition(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
				this._box.setLocalScale(this._boxSize, this._boxSize, this._boxSize);
		}
		_updateLine() {
				tmpV1$2.set(0, this._gap + this._lineLength * 0.5, 0);
				tmpQ1$1.set(0, 0, 0, 1);
				tmpV2$2.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
				this.triData[1].setTransform(tmpV1$2, tmpQ1$1, tmpV2$2);
				this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
				this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
		}
		constructor(device, options = {}){
				super(device, options), this._gap = 0, this._lineThickness = 0.02, this._lineLength = 0.5, this._boxSize = 0.12, this._tolerance = 0.1, this._flipped = false;
				this.triData = [
						new TriData(new BoxGeometry()),
						new TriData(new CylinderGeometry(), 1)
				];
				this._createBoxLine();
		}
}

var tmpV1$1 = new Vec3();
var tmpV2$1 = new Vec3();
var tmpV3$1 = new Vec3();
var tmpQ1 = new Quat();
var GLANCE_EPSILON = 0.98;
class ScaleGizmo extends TransformGizmo {
		set coordSpace(value) {}
		get coordSpace() {
				return this._coordSpace;
		}
		set uniform(value) {
				this._useUniformScaling = value != null ? value : true;
		}
		get uniform() {
				return this._useUniformScaling;
		}
		set axisGap(value) {
				this._setArrowProp('gap', value);
		}
		get axisGap() {
				return this._shapes.x.gap;
		}
		set axisLineThickness(value) {
				this._setArrowProp('lineThickness', value);
		}
		get axisLineThickness() {
				return this._shapes.x.lineThickness;
		}
		set axisLineLength(value) {
				this._setArrowProp('lineLength', value);
		}
		get axisLineLength() {
				return this._shapes.x.lineLength;
		}
		set axisLineTolerance(value) {
				this._setArrowProp('tolerance', value);
		}
		get axisLineTolerance() {
				return this._shapes.x.tolerance;
		}
		set axisBoxSize(value) {
				this._setArrowProp('boxSize', value);
		}
		get axisBoxSize() {
				return this._shapes.x.boxSize;
		}
		set axisPlaneSize(value) {
				this._setPlaneProp('size', value);
		}
		get axisPlaneSize() {
				return this._shapes.yz.size;
		}
		set axisPlaneGap(value) {
				this._setPlaneProp('gap', value);
		}
		get axisPlaneGap() {
				return this._shapes.yz.gap;
		}
		set axisCenterSize(value) {
				this._shapes.xyz.size = value;
		}
		get axisCenterSize() {
				return this._shapes.xyz.size;
		}
		set axisCenterTolerance(value) {
				this._shapes.xyz.tolerance = value;
		}
		get axisCenterTolerance() {
				return this._shapes.xyz.tolerance;
		}
		_setArrowProp(prop, value) {
				this._shapes.x[prop] = value;
				this._shapes.y[prop] = value;
				this._shapes.z[prop] = value;
		}
		_setPlaneProp(prop, value) {
				this._shapes.yz[prop] = value;
				this._shapes.xz[prop] = value;
				this._shapes.xy[prop] = value;
		}
		_shapesLookAtCamera() {
				var facingDir = this.facing;
				var dot = facingDir.dot(this.root.right);
				this._shapes.x.entity.enabled = Math.abs(dot) < GLANCE_EPSILON;
				if (this.flipShapes) {
						this._shapes.x.flipped = dot < 0;
				}
				dot = facingDir.dot(this.root.up);
				this._shapes.y.entity.enabled = Math.abs(dot) < GLANCE_EPSILON;
				if (this.flipShapes) {
						this._shapes.y.flipped = dot < 0;
				}
				dot = facingDir.dot(this.root.forward);
				this._shapes.z.entity.enabled = Math.abs(dot) < GLANCE_EPSILON;
				if (this.flipShapes) {
						this._shapes.z.flipped = dot > 0;
				}
				tmpV1$1.cross(facingDir, this.root.right);
				this._shapes.yz.entity.enabled = tmpV1$1.length() < GLANCE_EPSILON;
				if (this.flipShapes) {
						this._shapes.yz.flipped = tmpV2$1.set(0, +(tmpV1$1.dot(this.root.forward) < 0), +(tmpV1$1.dot(this.root.up) < 0));
				}
				tmpV1$1.cross(facingDir, this.root.forward);
				this._shapes.xy.entity.enabled = tmpV1$1.length() < GLANCE_EPSILON;
				if (this.flipShapes) {
						this._shapes.xy.flipped = tmpV2$1.set(+(tmpV1$1.dot(this.root.up) < 0), +(tmpV1$1.dot(this.root.right) > 0), 0);
				}
				tmpV1$1.cross(facingDir, this.root.up);
				this._shapes.xz.entity.enabled = tmpV1$1.length() < GLANCE_EPSILON;
				if (this.flipShapes) {
						this._shapes.xz.flipped = tmpV2$1.set(+(tmpV1$1.dot(this.root.forward) > 0), 0, +(tmpV1$1.dot(this.root.right) > 0));
				}
		}
		_storeNodeScales() {
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						this._nodeScales.set(node, node.getLocalScale().clone());
				}
		}
		_setNodeScales(pointDelta) {
				for(var i = 0; i < this.nodes.length; i++){
						var node = this.nodes[i];
						var scale = this._nodeScales.get(node);
						if (!scale) {
								continue;
						}
						node.setLocalScale(tmpV1$1.copy(scale).mul(pointDelta).max(this.lowerBoundScale));
				}
		}
		_screenToPoint(x, y) {
				var gizmoPos = this.root.getPosition();
				var mouseWPos = this._camera.screenToWorld(x, y, 1);
				var axis = this._selectedAxis;
				var isPlane = this._selectedIsPlane;
				var isScaleUniform = this._useUniformScaling && isPlane || axis === GIZMOAXIS_XYZ;
				var ray = this._createRay(mouseWPos);
				var plane = this._createPlane(axis, isScaleUniform, !isPlane);
				var point = new Vec3();
				plane.intersectsRay(ray, point);
				if (isScaleUniform) {
						switch(axis){
								case GIZMOAXIS_X:
										tmpV1$1.copy(this.root.up);
										tmpV2$1.copy(this.root.forward).mulScalar(-1);
										break;
								case GIZMOAXIS_Y:
										tmpV1$1.copy(this.root.right);
										tmpV2$1.copy(this.root.forward).mulScalar(-1);
										break;
								case GIZMOAXIS_Z:
										tmpV1$1.copy(this.root.up);
										tmpV2$1.copy(this.root.right);
										break;
								default:
										tmpV1$1.copy(this._camera.entity.up);
										tmpV2$1.copy(this._camera.entity.right);
										break;
						}
						tmpV2$1.add(tmpV1$1).normalize();
						tmpV1$1.sub2(point, gizmoPos);
						var length = tmpV1$1.length();
						var v = length * tmpV1$1.normalize().dot(tmpV2$1);
						point.set(v, v, v);
						if (axis !== GIZMOAXIS_XYZ) {
								point[axis] = 1;
						}
						return point;
				}
				tmpQ1.copy(this._rootStartRot).invert().transformVector(point, point);
				if (!isPlane) {
						this._projectToAxis(point, axis);
				}
				return point;
		}
		constructor(camera, layer){
				super(camera, layer), this._shapes = {
						xyz: new BoxShape(this._device, {
								axis: GIZMOAXIS_XYZ,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								defaultColor: this._meshColors.axis.xyz,
								hoverColor: this._meshColors.hover.xyz
						}),
						yz: new PlaneShape(this._device, {
								axis: GIZMOAXIS_X,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._meshColors.axis.x,
								hoverColor: this._meshColors.hover.x
						}),
						xz: new PlaneShape(this._device, {
								axis: GIZMOAXIS_Y,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._meshColors.axis.y,
								hoverColor: this._meshColors.hover.y
						}),
						xy: new PlaneShape(this._device, {
								axis: GIZMOAXIS_Z,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(90, 0, 0),
								defaultColor: this._meshColors.axis.z,
								hoverColor: this._meshColors.hover.z
						}),
						x: new BoxLineShape(this._device, {
								axis: GIZMOAXIS_X,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._meshColors.axis.x,
								hoverColor: this._meshColors.hover.x
						}),
						y: new BoxLineShape(this._device, {
								axis: GIZMOAXIS_Y,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._meshColors.axis.y,
								hoverColor: this._meshColors.hover.y
						}),
						z: new BoxLineShape(this._device, {
								axis: GIZMOAXIS_Z,
								layers: [
										this._layer.id
								],
								shading: this._shading,
								rotation: new Vec3(90, 0, 0),
								defaultColor: this._meshColors.axis.z,
								hoverColor: this._meshColors.hover.z
						})
				}, this._coordSpace = GIZMOSPACE_LOCAL, this._nodeScales = new Map(), this._useUniformScaling = false, this.snapIncrement = 1, this.flipShapes = true, this.lowerBoundScale = new Vec3(-Infinity, -Infinity, -Infinity);
				this._createTransform();
				this.on(TransformGizmo.EVENT_TRANSFORMSTART, ()=>{
						this._storeNodeScales();
				});
				this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (point)=>{
						var pointDelta = tmpV3$1.copy(point).sub(this._selectionStartPoint);
						if (this.snap) {
								pointDelta.mulScalar(1 / this.snapIncrement);
								pointDelta.round();
								pointDelta.mulScalar(this.snapIncrement);
						}
						pointDelta.mulScalar(1 / this._scale);
						this._setNodeScales(pointDelta.add(Vec3.ONE));
				});
				this.on(TransformGizmo.EVENT_NODESDETACH, ()=>{
						this._nodeScales.clear();
				});
				this._app.on('prerender', ()=>{
						this._shapesLookAtCamera();
				});
		}
}

var tmpV1 = new Vec3();
var tmpV2 = new Vec3();
var tmpV3 = new Vec3();
var tmpM1 = new Mat4();
class ViewCube extends EventHandler {
		set anchor(value) {
				this._anchor.copy(value);
				this.dom.style.top = this._anchor.x ? '0px' : 'auto';
				this.dom.style.right = this._anchor.y ? '0px' : 'auto';
				this.dom.style.bottom = this._anchor.z ? '0px' : 'auto';
				this.dom.style.left = this._anchor.w ? '0px' : 'auto';
		}
		get anchor() {
				return this._anchor;
		}
		set colorX(value) {
				this._colorX.copy(value);
				this._shapes.px.children[0].setAttribute('fill', this._colorX.toString(false));
				this._shapes.px.children[0].setAttribute('stroke', this._colorX.toString(false));
				this._shapes.nx.children[0].setAttribute('stroke', this._colorX.toString(false));
				this._shapes.xaxis.setAttribute('stroke', this._colorX.toString(false));
		}
		get colorX() {
				return this._colorX;
		}
		set colorY(value) {
				this._colorY.copy(value);
				this._shapes.py.children[0].setAttribute('fill', this._colorY.toString(false));
				this._shapes.py.children[0].setAttribute('stroke', this._colorY.toString(false));
				this._shapes.ny.children[0].setAttribute('stroke', this._colorY.toString(false));
				this._shapes.yaxis.setAttribute('stroke', this._colorY.toString(false));
		}
		get colorY() {
				return this._colorY;
		}
		set colorZ(value) {
				this._colorZ.copy(value);
				this._shapes.pz.children[0].setAttribute('fill', this._colorZ.toString(false));
				this._shapes.pz.children[0].setAttribute('stroke', this._colorZ.toString(false));
				this._shapes.nz.children[0].setAttribute('stroke', this._colorZ.toString(false));
				this._shapes.zaxis.setAttribute('stroke', this._colorZ.toString(false));
		}
		get colorZ() {
				return this._colorZ;
		}
		set colorNeg(value) {
				this._colorNeg.copy(value);
				this._shapes.px.children[0].setAttribute('fill', this._colorNeg.toString(false));
				this._shapes.py.children[0].setAttribute('fill', this._colorNeg.toString(false));
				this._shapes.pz.children[0].setAttribute('fill', this._colorNeg.toString(false));
		}
		get colorNeg() {
				return this._colorNeg;
		}
		set radius(value) {
				this._radius = value;
				this._shapes.px.children[0].setAttribute('r', "" + value);
				this._shapes.py.children[0].setAttribute('r', "" + value);
				this._shapes.pz.children[0].setAttribute('r', "" + value);
				this._shapes.nx.children[0].setAttribute('r', "" + value);
				this._shapes.ny.children[0].setAttribute('r', "" + value);
				this._shapes.nz.children[0].setAttribute('r', "" + value);
				this._resize();
		}
		get radius() {
				return this._radius;
		}
		set textSize(value) {
				this._textSize = value;
				this._shapes.px.children[1].setAttribute('font-size', "" + value);
				this._shapes.py.children[1].setAttribute('font-size', "" + value);
				this._shapes.pz.children[1].setAttribute('font-size', "" + value);
		}
		get textSize() {
				return this._textSize;
		}
		set lineThickness(value) {
				this._lineThickness = value;
				this._shapes.xaxis.setAttribute('stroke-width', "" + value);
				this._shapes.yaxis.setAttribute('stroke-width', "" + value);
				this._shapes.zaxis.setAttribute('stroke-width', "" + value);
				this._shapes.px.children[0].setAttribute('stroke-width', "" + value);
				this._shapes.py.children[0].setAttribute('stroke-width', "" + value);
				this._shapes.pz.children[0].setAttribute('stroke-width', "" + value);
				this._shapes.nx.children[0].setAttribute('stroke-width', "" + value);
				this._shapes.ny.children[0].setAttribute('stroke-width', "" + value);
				this._shapes.nz.children[0].setAttribute('stroke-width', "" + value);
				this._resize();
		}
		get lineThickness() {
				return this._lineThickness;
		}
		set lineLength(value) {
				this._lineLength = value;
				this._resize();
		}
		get lineLength() {
				return this._lineLength;
		}
		_resize() {
				this._size = 2 * (this.lineLength + this.radius + this.lineThickness);
				this.dom.style.width = "" + this._size + "px";
				this.dom.style.height = "" + this._size + "px";
				this._svg.setAttribute('width', "" + this._size);
				this._svg.setAttribute('height', "" + this._size);
				this._group.setAttribute('transform', "translate(" + this._size * 0.5 + ", " + this._size * 0.5 + ")");
		}
		_transform(group, x, y) {
				group.setAttribute('transform', "translate(" + x * this._lineLength + ", " + y * this._lineLength + ")");
		}
		_x2y2(line, x, y) {
				line.setAttribute('x2', "" + x * this._lineLength);
				line.setAttribute('y2', "" + y * this._lineLength);
		}
		_line(color) {
				var result = document.createElementNS(this._svg.namespaceURI, 'line');
				result.setAttribute('stroke', color);
				result.setAttribute('stroke-width', "" + this._lineThickness);
				this._group.appendChild(result);
				return result;
		}
		_circle(color, fill, text) {
				if (fill === void 0) fill = false;
				var group = document.createElementNS(this._svg.namespaceURI, 'g');
				var circle = document.createElementNS(this._svg.namespaceURI, 'circle');
				circle.setAttribute('fill', fill ? color : this._colorNeg.toString(false));
				circle.setAttribute('stroke', color);
				circle.setAttribute('stroke-width', "" + this._lineThickness);
				circle.setAttribute('r', "" + this._radius);
				circle.setAttribute('cx', '0');
				circle.setAttribute('cy', '0');
				circle.setAttribute('pointer-events', 'all');
				group.appendChild(circle);
				if (text) {
						var t = document.createElementNS(this._svg.namespaceURI, 'text');
						t.setAttribute('font-size', "" + this._textSize);
						t.setAttribute('font-family', 'Arial');
						t.setAttribute('font-weight', 'bold');
						t.setAttribute('text-anchor', 'middle');
						t.setAttribute('alignment-baseline', 'central');
						t.textContent = text;
						group.appendChild(t);
				}
				group.setAttribute('cursor', 'pointer');
				this._group.appendChild(group);
				return group;
		}
		update(cameraMatrix) {
				if (!this._size) {
						return;
				}
				tmpM1.invert(cameraMatrix);
				tmpM1.getX(tmpV1);
				tmpM1.getY(tmpV2);
				tmpM1.getZ(tmpV3);
				this._transform(this._shapes.px, tmpV1.x, -tmpV1.y);
				this._transform(this._shapes.nx, -tmpV1.x, tmpV1.y);
				this._transform(this._shapes.py, tmpV2.x, -tmpV2.y);
				this._transform(this._shapes.ny, -tmpV2.x, tmpV2.y);
				this._transform(this._shapes.pz, tmpV3.x, -tmpV3.y);
				this._transform(this._shapes.nz, -tmpV3.x, tmpV3.y);
				this._x2y2(this._shapes.xaxis, tmpV1.x, -tmpV1.y);
				this._x2y2(this._shapes.yaxis, tmpV2.x, -tmpV2.y);
				this._x2y2(this._shapes.zaxis, tmpV3.x, -tmpV3.y);
				var order = [
						{
								n: [
										'xaxis',
										'px'
								],
								value: tmpV1.z
						},
						{
								n: [
										'yaxis',
										'py'
								],
								value: tmpV2.z
						},
						{
								n: [
										'zaxis',
										'pz'
								],
								value: tmpV3.z
						},
						{
								n: [
										'nx'
								],
								value: -tmpV1.z
						},
						{
								n: [
										'ny'
								],
								value: -tmpV2.z
						},
						{
								n: [
										'nz'
								],
								value: -tmpV3.z
						}
				].sort((a, b)=>a.value - b.value);
				var fragment = document.createDocumentFragment();
				order.forEach((o)=>{
						o.n.forEach((n)=>{
								fragment.appendChild(this._shapes[n]);
						});
				});
				this._group.appendChild(fragment);
		}
		destroy() {
				this.dom.remove();
				this.off();
		}
		constructor(anchor){
				super(), this._size = 0, this._anchor = new Vec4(1, 1, 1, 1), this._colorX = COLOR_RED.clone(), this._colorY = COLOR_GREEN.clone(), this._colorZ = COLOR_BLUE.clone(), this._colorNeg = new Color(0.3, 0.3, 0.3), this._radius = 10, this._textSize = 10, this._lineThickness = 2, this._lineLength = 40;
				this.dom = document.createElement('div');
				this.dom.id = 'view-cube-container';
				this.dom.style.cssText = [
						'position: absolute',
						'margin: auto',
						'pointer-events: none'
				].join(';');
				document.body.appendChild(this.dom);
				this.anchor = anchor != null ? anchor : this._anchor;
				this._svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
				this._svg.id = 'view-cube-svg';
				this._group = document.createElementNS(this._svg.namespaceURI, 'g');
				this._svg.appendChild(this._group);
				this._resize();
				var colX = this._colorX.toString(false);
				var colY = this._colorY.toString(false);
				var colZ = this._colorZ.toString(false);
				this._shapes = {
						nx: this._circle(colX),
						ny: this._circle(colY),
						nz: this._circle(colZ),
						px: this._circle(colX, true, 'X'),
						py: this._circle(colY, true, 'Y'),
						pz: this._circle(colZ, true, 'Z'),
						xaxis: this._line(colX),
						yaxis: this._line(colY),
						zaxis: this._line(colZ)
				};
				this._shapes.px.children[0].addEventListener('pointerdown', ()=>{
						this.fire(ViewCube.EVENT_CAMERAALIGN, Vec3.RIGHT);
				});
				this._shapes.py.children[0].addEventListener('pointerdown', ()=>{
						this.fire(ViewCube.EVENT_CAMERAALIGN, Vec3.UP);
				});
				this._shapes.pz.children[0].addEventListener('pointerdown', ()=>{
						this.fire(ViewCube.EVENT_CAMERAALIGN, Vec3.BACK);
				});
				this._shapes.nx.children[0].addEventListener('pointerdown', ()=>{
						this.fire(ViewCube.EVENT_CAMERAALIGN, Vec3.LEFT);
				});
				this._shapes.ny.children[0].addEventListener('pointerdown', ()=>{
						this.fire(ViewCube.EVENT_CAMERAALIGN, Vec3.DOWN);
				});
				this._shapes.nz.children[0].addEventListener('pointerdown', ()=>{
						this.fire(ViewCube.EVENT_CAMERAALIGN, Vec3.FORWARD);
				});
				this.dom.appendChild(this._svg);
		}
}
ViewCube.EVENT_CAMERAALIGN = 'camera:align';

export { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, AMBIENTSRC_AMBIENTSH, AMBIENTSRC_CONSTANT, AMBIENTSRC_ENVALATLAS, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, ASSET_TEXTUREATLAS, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder, AnimClip, AnimClipHandler, AnimComponent, AnimComponentLayer, AnimComponentSystem, AnimController, AnimCurve, AnimData, AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget, AnimTrack, Animation, AnimationComponent, AnimationComponentSystem, AnimationHandler, AppBase, AppOptions, Application, Asset, AssetListLoader, AssetReference, AssetRegistry, AudioHandler, AudioListenerComponent, AudioListenerComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BINDGROUP_MESH, BINDGROUP_MESH_UB, BINDGROUP_VIEW, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_CONSTANT, BLENDMODE_CONSTANT_ALPHA, BLENDMODE_CONSTANT_COLOR, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_CONSTANT, BLENDMODE_ONE_MINUS_CONSTANT_ALPHA, BLENDMODE_ONE_MINUS_CONSTANT_COLOR, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFERUSAGE_COPY_DST, BUFFERUSAGE_COPY_SRC, BUFFERUSAGE_INDEX, BUFFERUSAGE_INDIRECT, BUFFERUSAGE_READ, BUFFERUSAGE_STORAGE, BUFFERUSAGE_UNIFORM, BUFFERUSAGE_VERTEX, BUFFERUSAGE_WRITE, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, Batch, BatchGroup, BatchManager, BinaryHandler, BindGroupFormat, BindStorageBufferFormat, BindStorageTextureFormat, BindTextureFormat, BindUniformBufferFormat, BlendState, BoundingBox, BoundingSphere, BoxGeometry, Bundle, BundleHandler, BundleRegistry, ButtonComponent, ButtonComponentSystem, CHUNKAPI_1_51, CHUNKAPI_1_55, CHUNKAPI_1_56, CHUNKAPI_1_57, CHUNKAPI_1_58, CHUNKAPI_1_60, CHUNKAPI_1_62, CHUNKAPI_1_65, CHUNKAPI_1_70, CHUNKAPI_2_1, CHUNKAPI_2_3, CHUNKAPI_2_5, CHUNKAPI_2_6, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent, CameraComponentSystem, CameraFrame, CameraFrameOptions, CameraShaderParams, CanvasFont, CapsuleGeometry, ChunkBuilder, ChunkUtils, CollisionComponent, CollisionComponentSystem, Color, Component, ComponentSystem, ComponentSystemRegistry, Compute, ConeGeometry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, Controller, CssHandler, CubemapHandler, Curve, CurveSet, CylinderGeometry, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DEVICETYPE_NULL, DEVICETYPE_WEBGL2, DEVICETYPE_WEBGPU, DISPLAYFORMAT_HDR, DISPLAYFORMAT_LDR, DISPLAYFORMAT_LDR_SRGB, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DITHER_BAYER8, DITHER_BLUENOISE, DITHER_IGNNOISE, DITHER_NONE, DefaultAnimBinder, DepthState, DomeGeometry, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_TEXT, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_GAMEPADCONNECTED, EVENT_GAMEPADDISCONNECTED, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_POSTCULL, EVENT_POSTRENDER, EVENT_POSTRENDER_LAYER, EVENT_PRECULL, EVENT_PRERENDER, EVENT_PRERENDER_LAYER, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent, ElementComponentSystem, ElementDragHelper, ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity, EnvLighting, EventHandle, EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITMODE_CONTAIN, FITMODE_COVER, FITMODE_STRETCH, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FloatPacking, FogParams, FolderHandler, Font, FontHandler, ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GIZMOAXIS_FACE, GIZMOAXIS_X, GIZMOAXIS_XY, GIZMOAXIS_XYZ, GIZMOAXIS_XZ, GIZMOAXIS_Y, GIZMOAXIS_YZ, GIZMOAXIS_Z, GIZMOSPACE_LOCAL, GIZMOSPACE_WORLD, GSplat, GSplatComponent, GSplatComponentSystem, GSplatData, GSplatHandler, GSplatInstance, GSplatResource, GamePads, Geometry, Gizmo, GltfExporter, GraphNode, GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer, IndexedList, JointComponent, JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Kernel, Key, Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_COUNT, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, Layer, LayerComposition, LayoutCalculator, LayoutChildComponent, LayoutChildComponentSystem, LayoutGroupComponent, LayoutGroupComponentSystem, Light, LightComponent, LightComponentSystem, LightingParams, Lightmapper, LitMaterial, LitOptions, LitShaderOptions, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4, Material, MaterialHandler, Mesh, MeshInstance, MiniStats, Model, ModelComponent, ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget, Mouse, MouseEvent, Node, NullGraphicsDevice, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, OutlineRenderer, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ASTC_4x4_SRGB, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_BC6F, PIXELFORMAT_BC6UF, PIXELFORMAT_BC7, PIXELFORMAT_BC7_SRGBA, PIXELFORMAT_BGRA8, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTH16, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT1_SRGB, PIXELFORMAT_DXT3, PIXELFORMAT_DXT3_SRGBA, PIXELFORMAT_DXT5, PIXELFORMAT_DXT5_SRGBA, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_ETC2_SRGB, PIXELFORMAT_ETC2_SRGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_LA8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R16F, PIXELFORMAT_R16I, PIXELFORMAT_R16U, PIXELFORMAT_R32F, PIXELFORMAT_R32I, PIXELFORMAT_R32U, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8, PIXELFORMAT_R8I, PIXELFORMAT_R8U, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RG16F, PIXELFORMAT_RG16I, PIXELFORMAT_RG16U, PIXELFORMAT_RG32I, PIXELFORMAT_RG32U, PIXELFORMAT_RG8, PIXELFORMAT_RG8I, PIXELFORMAT_RG8U, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGB565, PIXELFORMAT_RGB8, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA16I, PIXELFORMAT_RGBA16U, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA32I, PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA4, PIXELFORMAT_RGBA5551, PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA8I, PIXELFORMAT_RGBA8U, PIXELFORMAT_SBGRA8, PIXELFORMAT_SRGB, PIXELFORMAT_SRGB8, PIXELFORMAT_SRGBA, PIXELFORMAT_SRGBA8, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent, ParticleSystemComponentSystem, Picker, Plane, PlaneGeometry, PostEffect, PostEffectQueue, ProgramLibrary, QuadRender, Quat, REFLECTIONSRC_CUBEMAP, REFLECTIONSRC_ENVATLAS, REFLECTIONSRC_ENVATLASHQ, REFLECTIONSRC_NONE, REFLECTIONSRC_SPHEREMAP, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray, RaycastResult, ReadStream, RenderComponent, RenderComponentSystem, RenderHandler, RenderPass, RenderPassBloom, RenderPassCameraFrame, RenderPassColorGrab, RenderPassCompose, RenderPassDepthAwareBlur, RenderPassDof, RenderPassDownsample, RenderPassForward, RenderPassPrepass, RenderPassShaderQuad, RenderPassSsao, RenderPassTAA, RenderPassUpsample, RenderTarget, ResourceHandler, ResourceLoader, RigidBodyComponent, RigidBodyComponentSystem, RotateGizmo, SAMPLETYPE_DEPTH, SAMPLETYPE_FLOAT, SAMPLETYPE_INT, SAMPLETYPE_UINT, SAMPLETYPE_UNFILTERABLE_FLOAT, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_BATCH, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED_INT, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERLANGUAGE_GLSL, SHADERLANGUAGE_WGSL, SHADERPASS_ALBEDO, SHADERPASS_AO, SHADERPASS_EMISSION, SHADERPASS_FORWARD, SHADERPASS_GLOSS, SHADERPASS_LIGHTING, SHADERPASS_METALNESS, SHADERPASS_OPACITY, SHADERPASS_SPECULARITY, SHADERPASS_UV0, SHADERPASS_WORLDNORMAL, SHADERSTAGE_COMPUTE, SHADERSTAGE_FRAGMENT, SHADERSTAGE_VERTEX, SHADERTAG_MATERIAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_PICK, SHADER_PREPASS, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_PCF1, SHADOW_PCF1_16F, SHADOW_PCF1_32F, SHADOW_PCF3, SHADOW_PCF3_16F, SHADOW_PCF3_32F, SHADOW_PCF5, SHADOW_PCF5_16F, SHADOW_PCF5_32F, SHADOW_PCSS_32F, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM_16F, SHADOW_VSM_32F, SKYTYPE_BOX, SKYTYPE_DOME, SKYTYPE_INFINITE, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, SSAOTYPE_COMBINE, SSAOTYPE_LIGHTING, SSAOTYPE_NONE, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, ScaleGizmo, Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId, ScopeSpace, ScreenComponent, ScreenComponentSystem, Script, ScriptAttributes, ScriptComponent, ScriptComponentSystem, ScriptHandler, ScriptRegistry, ScriptType, ScrollViewComponent, ScrollViewComponentSystem, ScrollbarComponent, ScrollbarComponentSystem, Shader, ShaderHandler, ShaderMaterial, ShaderPass, SingleContactResult, Skeleton, Skin, SkinBatchInstance, SkinInstance, Sky, SortedLoopArray, Sound, SoundComponent, SoundComponentSystem, SoundInstance, SoundInstance3d, SoundManager, SoundSlot, SphereGeometry, Sprite, SpriteAnimationClip, SpriteComponent, SpriteComponentSystem, SpriteHandler, StandardMaterial, StandardMaterialOptions, StencilParameters, StorageBuffer, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXPROPERTY_ADDRESS_U, TEXPROPERTY_ADDRESS_V, TEXPROPERTY_ADDRESS_W, TEXPROPERTY_ALL, TEXPROPERTY_ANISOTROPY, TEXPROPERTY_COMPARE_FUNC, TEXPROPERTY_COMPARE_ON_READ, TEXPROPERTY_MAG_FILTER, TEXPROPERTY_MIN_FILTER, TEXTUREDIMENSION_1D, TEXTUREDIMENSION_2D, TEXTUREDIMENSION_2D_ARRAY, TEXTUREDIMENSION_3D, TEXTUREDIMENSION_CUBE, TEXTUREDIMENSION_CUBE_ARRAY, TEXTURELOCK_NONE, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_RGBP, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TONEMAP_NEUTRAL, TONEMAP_NONE, TRACEID_BINDGROUPFORMAT_ALLOC, TRACEID_BINDGROUP_ALLOC, TRACEID_COMPUTEPIPELINE_ALLOC, TRACEID_GPU_TIMINGS, TRACEID_PIPELINELAYOUT_ALLOC, TRACEID_RENDERPIPELINE_ALLOC, TRACEID_RENDER_ACTION, TRACEID_RENDER_FRAME, TRACEID_RENDER_FRAME_TIME, TRACEID_RENDER_PASS, TRACEID_RENDER_PASS_DETAIL, TRACEID_RENDER_QUEUE, TRACEID_RENDER_TARGET_ALLOC, TRACEID_SHADER_ALLOC, TRACEID_SHADER_COMPILE, TRACEID_TEXTURES, TRACEID_TEXTURE_ALLOC, TRACEID_VRAM_IB, TRACEID_VRAM_SB, TRACEID_VRAM_TEXTURE, TRACEID_VRAM_VB, TRACE_ID_ELEMENT, TYPE_FLOAT16, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture, TextureAtlas, TextureAtlasHandler, TextureHandler, TextureUtils, TorusGeometry, Touch, TouchDevice, TouchEvent, Tracing, TransformFeedback, TransformGizmo, TranslateGizmo, Tri, UNIFORMTYPE_BOOL, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_BVEC4, UNIFORMTYPE_BVEC4ARRAY, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_ITEXTURE2D, UNIFORMTYPE_ITEXTURE2D_ARRAY, UNIFORMTYPE_ITEXTURE3D, UNIFORMTYPE_ITEXTURECUBE, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_IVEC4, UNIFORMTYPE_IVEC4ARRAY, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_MAT4ARRAY, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_ARRAY, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_UINT, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_UTEXTURE2D, UNIFORMTYPE_UTEXTURE2D_ARRAY, UNIFORMTYPE_UTEXTURE3D, UNIFORMTYPE_UTEXTURECUBE, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC3ARRAY, UNIFORMTYPE_UVEC4, UNIFORMTYPE_UVEC4ARRAY, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, UNIFORM_BUFFER_DEFAULT_SLOT_NAME, UNUSED_UNIFORM_NAME, URI, UniformBufferFormat, UniformFormat, UsdzExporter, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2, Vec3, Vec4, VertexBuffer, VertexFormat, VertexIterator, ViewCube, WasmModule, WebglGraphicsDevice, WebgpuGraphicsDevice, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGFORMAT_R16U, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XREYE_LEFT, XREYE_NONE, XREYE_RIGHT, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRPAD_A, XRPAD_B, XRPAD_SQUEEZE, XRPAD_STICK_BUTTON, XRPAD_STICK_X, XRPAD_STICK_Y, XRPAD_TOUCHPAD_BUTTON, XRPAD_TOUCHPAD_X, XRPAD_TOUCHPAD_Y, XRPAD_TRIGGER, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrAnchor, XrAnchors, XrDomOverlay, XrFinger, XrHand, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource, XrJoint, XrLightEstimation, XrManager, XrMeshDetection, XrPlane, XrPlaneDetection, XrTrackedImage, XrView, XrViews, ZoneComponent, ZoneComponentSystem, ambientSrcNames, app, basisInitialize, bindGroupNames, blendNames, calculateNormals, calculateTangents, createBox, createCapsule, createCone, createCylinder, createGraphicsDevice, createMesh, createPlane, createScript, createShader, createShaderFromCode, createSphere, createTorus, createURI, cubemaProjectionNames, dracoInitialize, drawFullscreenQuad, drawQuadWithShader, extend, fresnelNames, gammaNames, getPixelFormatArrayType, getReservedScriptNames, getTouchTargetCoords, guid, http, isCompressedPixelFormat, isIntegerPixelFormat, isSrgbPixelFormat, lightFalloffNames, lightShapeNames, lightTypeNames, math, now, path, pixelFormatGammaToLinear, pixelFormatInfo, pixelFormatLinearToGamma, platform, reflectionSrcNames, registerScript, reprojectTexture, requiresManualGamma, revision, script, semanticToLocation, shaderChunks, shaderChunksLightmapper, shadowTypeInfo, specularOcclusionNames, spriteRenderModeNames, string, tonemapNames, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, uniformTypeToName, uniformTypeToNameMapWGSL, uniformTypeToNameWGSL, uniformTypeToStorage, version, vertexTypesNames };
